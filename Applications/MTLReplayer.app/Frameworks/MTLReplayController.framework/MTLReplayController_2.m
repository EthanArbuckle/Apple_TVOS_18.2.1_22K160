void GTMTLReplayController_defaultDispatchFunction_noPinning(uint64_t a1, void *a2)
{
  uint64_t v4;
  id v5;
  id v6;
  int v7;
  uint64_t v8;
  char *v9;
  int32x2_t v10;
  char *v11;
  void *v12;
  char *v13;
  id v14;
  void *v15;
  char *v16;
  id v17;
  id v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  void *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t *v30;
  void *v31;
  uint64_t DrawableTexture;
  void *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  double v38;
  double v39;
  double v40;
  double v41;
  char *v42;
  char *v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  char *v58;
  char *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  char *v65;
  void *v66;
  MTLFunctionDescriptor *v67;
  void *v68;
  id v69;
  char *v70;
  const void *v71;
  char *v72;
  void *v73;
  char *v74;
  void *v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  id v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  char *v102;
  void *v103;
  id v104;
  char *v105;
  void *v106;
  id MTLTextureDescriptor;
  id v108;
  id v109;
  char *v110;
  void *v111;
  id v112;
  id v113;
  void *v114;
  char *v115;
  NSString *v116;
  char *v117;
  char *v118;
  void *v119;
  MTLRenderPassDescriptor *MTLRenderPassDescriptor;
  id v121;
  NSString *v122;
  uint64_t v123;
  char *v124;
  uint64_t v125;
  char *v126;
  char *v127;
  void *v128;
  MTLRenderPassDescriptor *v129;
  NSString *v130;
  char *v131;
  NSString *v132;
  char *v133;
  char *v134;
  id v135;
  id v136;
  char *v137;
  uint64_t v138;
  char *v139;
  uint64_t v140;
  char *v141;
  char *v142;
  char *v143;
  unint64_t v144;
  uint64_t v145;
  void *v146;
  unint64_t v147;
  char *v148;
  uint64_t v149;
  char *v150;
  char *v151;
  char *v152;
  unint64_t v153;
  uint64_t v154;
  void *v155;
  unint64_t v156;
  char *v157;
  uint64_t v158;
  char *v159;
  char *v160;
  char *v161;
  unint64_t v162;
  uint64_t v163;
  void *v164;
  unint64_t v165;
  char *v166;
  double v167;
  double v168;
  char *v169;
  char *v170;
  char *v171;
  char *v172;
  unint64_t v173;
  uint64_t v174;
  void *v175;
  unint64_t v176;
  char *v177;
  void *v178;
  char *v179;
  uint64_t v180;
  uint64_t v181;
  char *v182;
  char *v183;
  char *v184;
  void *v185;
  __int128 v186;
  id v187;
  char *v188;
  char *v189;
  MTLDepthStencilDescriptor *MTLDepthStencilDescriptor;
  id v191;
  uint64_t v192;
  unsigned int v193;
  char *v194;
  uint64_t (*v195)(void);
  char *v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  char *v201;
  uint64_t v202;
  id v203;
  id v204;
  void *v205;
  char *v206;
  char *v207;
  char *v208;
  uint64_t v209;
  id v210;
  char *v211;
  char *v212;
  void *v213;
  MTLCompileOptions *MTLCompileOptions;
  void *v215;
  id v216;
  void *v217;
  char *v218;
  char *v219;
  MTLCompileOptions *v220;
  id v221;
  char *v222;
  void *v223;
  id MTLRenderPipelineDescriptor;
  id v225;
  void *v226;
  void *v227;
  id v228;
  unint64_t v229;
  void *v230;
  id v231;
  void *v232;
  id v233;
  unint64_t v234;
  char *v235;
  void *v236;
  uint64_t v237;
  unint64_t v238;
  id v239;
  char *v240;
  char *v241;
  id IOSurface;
  void *v243;
  id v244;
  void *v245;
  id v246;
  uint64_t v247;
  char *v248;
  void *v249;
  NSString *v250;
  void *v251;
  id v252;
  char *v253;
  NSString *v254;
  char *v255;
  char *v256;
  void *v257;
  id v258;
  void *v259;
  char *v260;
  uint64_t v261;
  char *v262;
  uint64_t v263;
  char *v264;
  char *v265;
  char *v266;
  unint64_t v267;
  uint64_t v268;
  void *v269;
  unint64_t v270;
  char *v271;
  char *v272;
  char *v273;
  char *v274;
  unint64_t v275;
  uint64_t v276;
  void *v277;
  unint64_t v278;
  char *v279;
  char *v280;
  char *v281;
  char *v282;
  unint64_t v283;
  uint64_t v284;
  void *v285;
  unint64_t v286;
  char *v287;
  double v288;
  double v289;
  char *v290;
  char *v291;
  char *v292;
  char *v293;
  unint64_t v294;
  uint64_t v295;
  void *v296;
  unint64_t v297;
  char *v298;
  __int128 v299;
  __int128 v300;
  char *v301;
  char *v302;
  char *v303;
  char *v304;
  double v305;
  double v306;
  double v307;
  char *v308;
  __int128 v309;
  char *v310;
  char *v311;
  uint64_t v312;
  char *v313;
  char *v314;
  char *v315;
  unint64_t v316;
  uint64_t v317;
  void *v318;
  unint64_t v319;
  char *v320;
  char *v321;
  char *v322;
  char *v323;
  unint64_t v324;
  uint64_t v325;
  void *v326;
  unint64_t v327;
  char *v328;
  char *v329;
  char *v330;
  char *v331;
  unint64_t v332;
  uint64_t v333;
  void *v334;
  unint64_t v335;
  char *v336;
  double v337;
  double v338;
  char *v339;
  char *v340;
  char *v341;
  char *v342;
  unint64_t v343;
  uint64_t v344;
  void *v345;
  unint64_t v346;
  char *v347;
  double v348;
  double v349;
  double v350;
  double v351;
  char *v352;
  char *v353;
  char *v354;
  char *v355;
  char *v356;
  char *v357;
  char *v358;
  char *v359;
  double v360;
  char *v361;
  char *v362;
  uint64_t v363;
  uint64_t v364;
  char *v365;
  uint64_t Object;
  uint64_t v367;
  id v368;
  void *v369;
  char v370;
  uint64_t v371;
  uint64_t v372;
  char *v373;
  char *v374;
  char *v375;
  char *v376;
  char *v377;
  char *v378;
  char *v379;
  uint64_t v380;
  uint64_t v381;
  char *v382;
  char *v383;
  void *v384;
  char *v385;
  uint64_t v386;
  char *v387;
  char *v388;
  char *v389;
  char *v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  char *v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  char *v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  char *v411;
  void *v412;
  id MTLComputePipelineDescriptor;
  void *v414;
  id v415;
  unint64_t v416;
  void *v417;
  id v418;
  void *v419;
  id v420;
  unint64_t v421;
  uint64_t v422;
  uint64_t v423;
  id v424;
  void *v425;
  char v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  char *v434;
  unsigned int *v435;
  MTLCommandQueueDescriptor *MTLCommandQueueDescriptor;
  char *v437;
  char *v438;
  id v439;
  id v440;
  char *v441;
  void *v442;
  char *v443;
  void *v444;
  char *v445;
  void *v446;
  char *v447;
  char *v448;
  char *v449;
  char *v450;
  char *v451;
  char *v452;
  char *v453;
  char *v454;
  void *v455;
  char *v456;
  char *v457;
  char *v458;
  char *v459;
  char *v460;
  char *v461;
  double v462;
  double v463;
  char *v464;
  uint64_t v465;
  char *v466;
  double v467;
  char *v468;
  uint64_t v469;
  char *v470;
  uint64_t v471;
  char *v472;
  char *v473;
  char *v474;
  id v475;
  void *v476;
  char *v477;
  char *v478;
  MTLHeapDescriptor *MTLHeapDescriptor;
  void *v480;
  void *v481;
  id v482;
  id v483;
  id v484;
  void *v485;
  char *v486;
  unint64_t v487;
  id v488;
  id v489;
  id v490;
  char *v491;
  char *v492;
  MTLFunctionConstantValues *MTLFunctionConstantValues;
  int v494;
  NSString *v495;
  void *v496;
  char *v497;
  MTLFunctionConstantValues *v498;
  NSString *v499;
  char *v500;
  void *v501;
  char *v502;
  uint64_t *v503;
  int v504;
  void *v505;
  int v506;
  NSMutableArray *NSArray;
  char *v508;
  uint64_t v509;
  char *v510;
  void *v511;
  _OWORD *v512;
  id v513;
  char *v514;
  uint64_t v515;
  id v516;
  id v517;
  id v518;
  uint64_t v519;
  id v520;
  void *v521;
  id v522;
  uint64_t v523;
  char *v524;
  char *v525;
  void *v526;
  id MTLTileRenderPipelineDescriptor;
  char *v528;
  void *v529;
  id v530;
  unint64_t v531;
  char *v532;
  void *v533;
  id v534;
  char *v535;
  void *v536;
  id v537;
  unint64_t v538;
  char *v539;
  char *v540;
  char *v541;
  unint64_t v542;
  uint64_t v543;
  void *v544;
  uint64_t i3;
  char *v546;
  char *v547;
  char *v548;
  unint64_t v549;
  uint64_t v550;
  void *v551;
  unint64_t v552;
  char *v553;
  char *v554;
  char *v555;
  unint64_t v556;
  uint64_t v557;
  void *v558;
  unint64_t v559;
  char *v560;
  char *v561;
  char *v562;
  char *v563;
  unint64_t v564;
  uint64_t v565;
  void *v566;
  unint64_t v567;
  char *v568;
  void *v569;
  NSString *v570;
  void *v571;
  char *v572;
  void *v573;
  char *v574;
  MTLFunctionConstantValues *v575;
  void *v576;
  int v577;
  NSString *v578;
  void *v579;
  char *v580;
  MTLFunctionConstantValues *v581;
  NSString *v582;
  char *v583;
  char *v584;
  uint64_t v585;
  uint64_t v586;
  char *v587;
  char *v588;
  char *v589;
  char *v590;
  char *v591;
  char *v592;
  char *v593;
  unsigned int v594;
  char *v595;
  char *v596;
  char *v597;
  char *v598;
  char *v599;
  unint64_t v600;
  uint64_t v601;
  void *v602;
  unint64_t v603;
  char *v604;
  char *v605;
  char *v606;
  unint64_t v607;
  uint64_t v608;
  void *v609;
  unint64_t v610;
  char *v611;
  char *v612;
  char *v613;
  unint64_t v614;
  uint64_t v615;
  void *v616;
  unint64_t v617;
  char *v618;
  id v619;
  char *v620;
  uint64_t v621;
  char *v622;
  apr_pool_t *v623;
  void *v624;
  char *v625;
  char *v626;
  unint64_t v627;
  unint64_t v628;
  char *v629;
  uint64_t v630;
  char *v631;
  apr_pool_t *v632;
  void *v633;
  char *v634;
  char *v635;
  unint64_t v636;
  unint64_t v637;
  char *v638;
  char *v639;
  unint64_t v640;
  char *v641;
  char *v642;
  char *v643;
  unint64_t v644;
  char *v645;
  char *v646;
  char *v647;
  uint64_t v648;
  id v649;
  void *v650;
  NSString *v651;
  char *v652;
  char *v653;
  void *v654;
  char *v655;
  void *v656;
  char *v657;
  void *v658;
  char *v659;
  char *v660;
  char *v661;
  void *v662;
  char *v663;
  char *v664;
  unint64_t v665;
  unint64_t v666;
  char *v667;
  void *v668;
  uint64_t v669;
  char *v670;
  void *v671;
  char *v672;
  char *v673;
  unint64_t v674;
  unint64_t v675;
  char *v676;
  char *v677;
  void *v678;
  char *v679;
  char *v680;
  unint64_t v681;
  unint64_t v682;
  char *v683;
  char *v684;
  char *v685;
  char *v686;
  char *v687;
  char *v688;
  uint64_t v689;
  char *v690;
  uint64_t v691;
  char *v692;
  double v693;
  char *v694;
  id v695;
  char *v696;
  __int128 v697;
  char *v698;
  __int128 v699;
  char *v700;
  void *v701;
  uint64_t (*v702)(void);
  char *v703;
  uint64_t v704;
  unint64_t v705;
  char *v706;
  char *v707;
  uint64_t (*v708)(void);
  char *v709;
  uint64_t v710;
  unint64_t v711;
  char *v712;
  char *v713;
  char *v714;
  uint64_t v715;
  char *v716;
  uint64_t v717;
  char *v718;
  char *v719;
  char *v720;
  char *v721;
  char *v722;
  void *v723;
  char *v724;
  char *v725;
  uint64_t v726;
  uint64_t v727;
  char *v728;
  char *v729;
  char *v730;
  char *v731;
  id v732;
  char *v733;
  char *v734;
  void *v735;
  char *v736;
  char *v737;
  unint64_t v738;
  unint64_t v739;
  id v740;
  id v741;
  char *v742;
  uint64_t v743;
  char *v744;
  id v745;
  void *v746;
  id v747;
  char *v748;
  char *v749;
  char *v750;
  void *v751;
  char *v752;
  NSString *v753;
  char *v754;
  char *v755;
  void *v756;
  MTLCounterSampleBufferDescriptor *MTLCounterSampleBufferDescriptor;
  char *v758;
  void *v759;
  uint64_t *v760;
  int v761;
  void *v762;
  int v763;
  NSMutableArray *v764;
  char *v765;
  void *v766;
  char *v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  char *v771;
  char *v772;
  char *v773;
  void *v774;
  char *v775;
  char *v776;
  unint64_t v777;
  unint64_t v778;
  char *v779;
  char *v780;
  void *v781;
  char *v782;
  char *v783;
  unint64_t v784;
  unint64_t v785;
  char *v786;
  char *v787;
  char *v788;
  char *v789;
  char *v790;
  char *v791;
  char *v792;
  char *v793;
  id MTLRasterizationRateMapDescriptor;
  char *v795;
  id v796;
  char *v797;
  char *v798;
  uint64_t v799;
  __int128 v800;
  char *v801;
  void *v802;
  uint64_t v803;
  char *v804;
  char *v805;
  void *v806;
  unint64_t v807;
  char *v808;
  id v809;
  void *v810;
  uint64_t v811;
  uint64_t v812;
  id v813;
  void *v814;
  char v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  char *v824;
  double v825;
  double v826;
  char *v827;
  uint64_t v828;
  const void *v829;
  size_t v830;
  char *v831;
  id v832;
  char *v833;
  char *v834;
  int v835;
  NSString *v836;
  void *v837;
  char *v838;
  int v839;
  NSString *v840;
  void *v841;
  char *v842;
  char *v843;
  id v844;
  char *v845;
  uint64_t v846;
  dispatch_data_t v847;
  char *v848;
  double v849;
  char *v850;
  id v851;
  char *v852;
  char *v853;
  id v854;
  char *v855;
  char *v856;
  char *v857;
  char *v858;
  char *v859;
  id v860;
  NSString *v861;
  char *v862;
  char *v863;
  char *v864;
  char *v865;
  char *v866;
  unint64_t v867;
  uint64_t v868;
  void *v869;
  unint64_t v870;
  char *v871;
  char *v872;
  char *v873;
  uint64_t *v874;
  int v875;
  void *v876;
  NSMutableArray *v877;
  int v878;
  NSString *v879;
  void *v880;
  void *v881;
  id v882;
  void *v883;
  char v884;
  id v885;
  void *v886;
  id v887;
  void *v888;
  char v889;
  uint64_t v890;
  uint64_t v891;
  void *v892;
  id v893;
  void *v894;
  char v895;
  char *v896;
  NSString *v897;
  id v898;
  id v899;
  char *v900;
  void *v901;
  unsigned __int8 *v902;
  void *v903;
  id MTLAccelerationStructureDescriptor;
  void *v905;
  char *v906;
  char *v907;
  char *v908;
  NSString *v909;
  id v910;
  NSString *v911;
  char *v912;
  void *v913;
  void *v914;
  unsigned __int8 *v915;
  void *v916;
  id v917;
  void *v918;
  char *v919;
  char *v920;
  char *v921;
  char *v922;
  unint64_t v923;
  char *v924;
  char *v925;
  unint64_t v926;
  char *v927;
  char *v928;
  char *v929;
  char *v930;
  uint64_t v931;
  char *v932;
  unsigned __int8 *v933;
  void *v934;
  id v935;
  void *v936;
  id v937;
  char *v938;
  uint64_t v939;
  char *v940;
  char *v941;
  char *v942;
  id v943;
  char *v944;
  void *v945;
  MTLFunctionDescriptor *MTLFunctionDescriptor;
  void *v947;
  char *v948;
  void *v949;
  MTLFunctionDescriptor *v950;
  char *v951;
  char *v952;
  char *v953;
  char *v954;
  char *v955;
  void *v956;
  MTLBlitPassDescriptor *MTLBlitPassDescriptor;
  NSString *v958;
  char *v959;
  char *v960;
  void *v961;
  MTLComputePassDescriptor *MTLComputePassDescriptor;
  NSString *v963;
  char *v964;
  char *v965;
  void *v966;
  MTLResourceStatePassDescriptor *MTLResourceStatePassDescriptor;
  NSString *v968;
  char *v969;
  char *v970;
  void *v971;
  MTLComputePassDescriptor *v972;
  id v973;
  void *v974;
  NSString *v975;
  uint64_t v976;
  char *v977;
  char *v978;
  void *v979;
  char *v980;
  char *v981;
  unint64_t v982;
  unint64_t v983;
  char *v984;
  uint64_t v985;
  char *v986;
  void *v987;
  char *v988;
  char *v989;
  unint64_t v990;
  unint64_t v991;
  char *v992;
  uint64_t (*v993)(void);
  char *v994;
  uint64_t v995;
  id v996;
  char *v997;
  uint64_t v998;
  char *v999;
  void *v1000;
  MTLIntersectionFunctionDescriptor *MTLIntersectionFunctionDescriptor;
  char *v1002;
  void *v1003;
  MTLIntersectionFunctionDescriptor *v1004;
  uint64_t (*v1005)(void);
  char *v1006;
  uint64_t v1007;
  id v1008;
  char *v1009;
  char *v1010;
  void *v1011;
  char *v1012;
  char *v1013;
  unint64_t v1014;
  unint64_t v1015;
  char *v1016;
  char *v1017;
  char *v1018;
  id v1019;
  id v1020;
  uint64_t v1021;
  char *v1022;
  char *v1023;
  unint64_t v1024;
  char *v1025;
  char *v1026;
  uint64_t *v1027;
  int v1028;
  void *v1029;
  NSMutableArray *v1030;
  void *v1031;
  char *v1032;
  char *v1033;
  char *v1034;
  uint64_t *v1035;
  int v1036;
  void *v1037;
  NSMutableArray *v1038;
  char *v1039;
  id v1040;
  char *v1041;
  id MTLBufferDescriptor;
  char *v1043;
  void *v1044;
  char *v1045;
  char *v1046;
  char *v1047;
  char *v1048;
  char *v1049;
  char *v1050;
  id v1051;
  char *v1052;
  __int128 v1053;
  __int128 v1054;
  char *v1055;
  void *v1056;
  char *v1057;
  void *v1058;
  MTLFunctionDescriptor *v1059;
  void *v1060;
  char *v1061;
  char *v1062;
  uint64_t v1063;
  uint64_t v1064;
  __int128 v1065;
  char *v1066;
  uint64_t v1067;
  uint64_t v1068;
  __int128 v1069;
  char *v1070;
  uint64_t v1071;
  uint64_t v1072;
  __int128 v1073;
  char *v1074;
  char *v1075;
  char *v1076;
  void *v1077;
  char *v1078;
  uint64_t *v1079;
  int v1080;
  void *v1081;
  void *v1082;
  NSMutableArray *v1083;
  void *v1084;
  uint64_t v1085;
  unsigned __int8 *v1086;
  void *v1087;
  id v1088;
  void *v1089;
  char *v1090;
  unsigned __int8 *v1091;
  void *v1092;
  id v1093;
  char *v1094;
  id v1095;
  uint64_t (*v1096)(void);
  char *v1097;
  uint64_t v1098;
  char *v1099;
  void *v1100;
  MTLRenderPipelineFunctionsDescriptor *MTLRenderPipelineFunctionsDescriptor;
  uint64_t (*v1102)(void);
  char *v1103;
  uint64_t v1104;
  char *v1105;
  char *v1106;
  char *v1107;
  void *v1108;
  char *v1109;
  char *v1110;
  unint64_t v1111;
  unint64_t v1112;
  char *v1113;
  char *v1114;
  void *v1115;
  char *v1116;
  char *v1117;
  unint64_t v1118;
  unint64_t v1119;
  char *v1120;
  char *v1121;
  char *v1122;
  void *v1123;
  char *v1124;
  char *v1125;
  unint64_t v1126;
  unint64_t v1127;
  char *v1128;
  char *v1129;
  void *v1130;
  char *v1131;
  char *v1132;
  unint64_t v1133;
  unint64_t v1134;
  char *v1135;
  char *v1136;
  char *v1137;
  void *v1138;
  char *v1139;
  char *v1140;
  unint64_t v1141;
  unint64_t v1142;
  char *v1143;
  char *v1144;
  void *v1145;
  char *v1146;
  char *v1147;
  unint64_t v1148;
  unint64_t v1149;
  uint64_t (*v1150)(void);
  char *v1151;
  uint64_t v1152;
  uint64_t (*v1153)(void);
  char *v1154;
  uint64_t v1155;
  uint64_t (*v1156)(void);
  char *v1157;
  uint64_t v1158;
  uint64_t (*v1159)(void);
  char *v1160;
  uint64_t v1161;
  uint64_t (*v1162)(void);
  char *v1163;
  uint64_t v1164;
  uint64_t (*v1165)(void);
  char *v1166;
  uint64_t v1167;
  char *v1168;
  void *v1169;
  MTLStitchedLibraryDescriptor *MTLStitchedLibraryDescriptor;
  char *v1171;
  void *v1172;
  id MTLStitchedLibraryDescriptorSPI;
  uint64_t v1174;
  uint64_t v1175;
  char *v1176;
  char *v1177;
  void *v1178;
  MTLStitchedLibraryDescriptor *v1179;
  char *v1180;
  void *v1181;
  MTLStitchedLibraryDescriptor *v1182;
  char *v1183;
  void *v1184;
  MTLStitchedLibraryDescriptor *v1185;
  char *v1186;
  void *v1187;
  MTLStitchedLibraryDescriptor *v1188;
  char *v1189;
  void *v1190;
  id v1191;
  char *v1192;
  void *v1193;
  uint64_t v1194;
  uint64_t v1195;
  uint64_t v1196;
  __int128 *v1197;
  __int128 *v1198;
  __int128 *v1199;
  char *v1200;
  uint64_t v1201;
  uint64_t v1202;
  uint64_t v1203;
  char *v1204;
  void *v1205;
  uint64_t v1206;
  uint64_t v1207;
  uint64_t v1208;
  __int128 *v1209;
  __int128 *v1210;
  __int128 *v1211;
  char *v1212;
  char *v1213;
  void *v1214;
  id MTLMeshRenderPipelineDescriptor;
  void *v1216;
  id v1217;
  void *v1218;
  id v1219;
  unint64_t v1220;
  void *v1221;
  id v1222;
  unint64_t v1223;
  char *v1224;
  uint64_t v1225;
  char *v1226;
  char *v1227;
  char *v1228;
  char *v1229;
  unint64_t v1230;
  uint64_t v1231;
  void *v1232;
  uint64_t i10;
  char *v1234;
  char *v1235;
  char *v1236;
  double v1237;
  double v1238;
  char *v1239;
  char *v1240;
  char *v1241;
  unint64_t v1242;
  uint64_t v1243;
  void *v1244;
  char *v1245;
  uint64_t i11;
  char *v1247;
  char *v1248;
  char *v1249;
  unint64_t v1250;
  uint64_t v1251;
  void *v1252;
  unint64_t v1253;
  char *v1254;
  char *v1255;
  char *v1256;
  char *v1257;
  unint64_t v1258;
  uint64_t v1259;
  void *v1260;
  unint64_t v1261;
  char *v1262;
  uint64_t v1263;
  char *v1264;
  char *v1265;
  char *v1266;
  char *v1267;
  unint64_t v1268;
  uint64_t v1269;
  void *v1270;
  uint64_t i14;
  char *v1272;
  char *v1273;
  char *v1274;
  double v1275;
  double v1276;
  char *v1277;
  char *v1278;
  char *v1279;
  unint64_t v1280;
  uint64_t v1281;
  void *v1282;
  char *v1283;
  uint64_t i15;
  char *v1285;
  char *v1286;
  char *v1287;
  unint64_t v1288;
  uint64_t v1289;
  void *v1290;
  unint64_t v1291;
  char *v1292;
  char *v1293;
  char *v1294;
  char *v1295;
  unint64_t v1296;
  uint64_t v1297;
  void *v1298;
  unint64_t v1299;
  char *v1300;
  void *v1301;
  char *v1302;
  unsigned __int8 *v1303;
  id v1304;
  char *v1305;
  char *v1306;
  char *v1307;
  void *v1308;
  MTLAccelerationStructurePassDescriptor *MTLAccelerationStructurePassDescriptor;
  NSString *v1310;
  char *v1311;
  char *v1312;
  uint64_t *v1313;
  int v1314;
  void *v1315;
  NSMutableArray *v1316;
  char *v1317;
  unsigned __int8 *v1318;
  void *v1319;
  id v1320;
  void *v1321;
  char *v1322;
  unsigned __int8 *v1323;
  void *v1324;
  id v1325;
  char *v1326;
  char *v1327;
  char *v1328;
  id MTLAccelerationStructureAllocationDescriptor;
  void *v1330;
  id v1331;
  char *v1332;
  unsigned __int8 *v1333;
  void *v1334;
  id v1335;
  void *v1336;
  id v1337;
  void *v1338;
  id v1339;
  os_log_s *v1340;
  void *v1341;
  unsigned __int8 *v1342;
  id v1343;
  void *v1344;
  uint64_t v1345;
  uint64_t v1346;
  uint64_t v1347;
  id v1348;
  char *v1349;
  unsigned int *v1350;
  MTLIOCommandQueueDescriptor *MTLIOCommandQueueDescriptor;
  char *v1352;
  char *v1353;
  id v1354;
  id v1355;
  char *v1356;
  uint64_t v1357;
  char *v1358;
  void *v1359;
  char *v1360;
  char *v1361;
  char *v1362;
  id v1363;
  char *v1364;
  char *v1365;
  uint64_t v1366;
  uint64_t v1367;
  uint64_t v1368;
  uint64_t v1369;
  uint64_t v1370;
  char *v1371;
  char *v1372;
  char *v1373;
  char *v1374;
  __int128 v1375;
  __int128 v1376;
  char *v1377;
  id v1378;
  NSString *v1379;
  char *v1380;
  char *v1381;
  char *v1382;
  char *v1383;
  char *v1384;
  char *v1385;
  unint64_t v1386;
  uint64_t v1387;
  void *v1388;
  char *v1389;
  uint64_t i18;
  char *v1391;
  char *v1392;
  char *v1393;
  char *v1394;
  char *v1395;
  char *v1396;
  uint64_t v1397;
  char *v1398;
  char *v1399;
  char *v1400;
  char *v1401;
  unint64_t v1402;
  uint64_t v1403;
  void *v1404;
  char *v1405;
  uint64_t i19;
  char *v1407;
  char *v1408;
  uint64_t v1409;
  uint64_t v1410;
  uint64_t v1411;
  char *v1412;
  uint64_t v1413;
  uint64_t v1414;
  uint64_t v1415;
  char *v1416;
  char *v1417;
  void *v1418;
  char *v1419;
  char *v1420;
  unint64_t v1421;
  unint64_t v1422;
  char *v1423;
  char *v1424;
  void *v1425;
  char *v1426;
  char *v1427;
  unint64_t v1428;
  unint64_t v1429;
  char *v1430;
  char *v1431;
  void *v1432;
  char *v1433;
  char *v1434;
  unint64_t v1435;
  unint64_t v1436;
  char *v1437;
  char *v1438;
  char *v1439;
  id MTLResidencySetDescriptor;
  id v1441;
  id v1442;
  id v1443;
  char *v1444;
  char *v1445;
  char *v1446;
  void *v1447;
  char *v1448;
  char *v1449;
  unint64_t v1450;
  unint64_t v1451;
  id v1452;
  char *v1453;
  char *v1454;
  void *v1455;
  char *v1456;
  char *v1457;
  unint64_t v1458;
  unint64_t v1459;
  char *v1460;
  uint64_t v1461;
  char *v1462;
  uint64_t v1463;
  uint64_t v1464;
  uint64_t v1465;
  uint64_t v1466;
  uint64_t v1467;
  uint64_t v1468;
  uint64_t v1469;
  void *v1470;
  uint64_t v1471;
  unsigned __int8 *v1472;
  void *v1473;
  id v1474;
  void *v1475;
  void *v1476;
  uint64_t v1477;
  unsigned __int8 *v1478;
  void *v1479;
  id v1480;
  void *v1481;
  id v1482;
  void *v1483;
  id v1484;
  os_log_s *v1485;
  id v1486;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  char *v1491;
  uint64_t v1492;
  id v1493;
  uint64_t v1494;
  id v1495;
  uint64_t n;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t mm;
  uint64_t nn;
  uint64_t i1;
  uint64_t i2;
  void *v1504;
  uint64_t i4;
  uint64_t i5;
  uint64_t i6;
  id v1508;
  void *v1509;
  uint64_t v1510;
  id v1511;
  uint64_t v1512;
  uint64_t v1513;
  const CATransform3D **v1514;
  char *v1515;
  void *v1516;
  void *v1517;
  void *v1518;
  void *v1519;
  id v1520;
  id v1521;
  id v1522;
  void *v1523;
  uint64_t i7;
  uint64_t i8;
  uint64_t i9;
  id v1527;
  unint64_t v1528;
  unint64_t v1529;
  id v1530;
  apr_pool_t *v1531;
  uint64_t i12;
  uint64_t i13;
  uint64_t i16;
  uint64_t i17;
  uint64_t v1536;
  void *v1537;
  id v1538;
  id v1539;
  void *v1540;
  void *v1541;
  void *v1542;
  void *v1543;
  void *v1544;
  id NSError;
  id v1546;
  void *v1547;
  FILE *v1548;
  id v1549;
  id v1550;
  FILE *v1551;
  id v1552;
  void *v1553;
  char *v1554;
  void *v1555;
  void *v1556;
  id v1557;
  id v1558[2];
  id v1559;
  void v1560[4];
  id v1561;
  __int128 v1562;
  uint64_t v1563;
  uint64_t v1564;
  uint64_t v1565;
  char v1566;
  _DWORD v1567[3];
  id v1568;
  void *v1569;
  void *v1570;
  void *v1571;
  void *v1572;
  void *v1573;
  void *v1574;
  void *v1575;
  void *v1576;
  void *v1577;
  void *v1578;
  _OWORD v1579[2];
  uint64_t v1580;
  char v1581;
  _BYTE v1582[7];
  id v1583;
  _BYTE __dst[128];
  __int128 v1585;
  uint64_t v1586;
  __int128 v1587;
  uint64_t v1588;
  _OWORD v1589[3];
  void *v1590;
  __int128 v1591;
  uint64_t v1592;
  __int128 v1593;
  uint64_t v1594;
  __int128 v1595;
  uint64_t v1596;
  __int128 v1597;
  uint64_t v1598;
  __int128 v1599;
  uint64_t v1600;
  __int128 v1601;
  uint64_t v1602;
  __int128 v1603;
  uint64_t v1604;
  __int128 v1605;
  uint64_t v1606;
  _OWORD v1607[3];
  __int128 v1608;
  uint64_t v1609;
  _OWORD v1610[3];
  __int128 v1611;
  uint64_t v1612;
  __int128 v1613;
  uint64_t v1614;
  id v1615;
  id v1616;
  void *v1617;
  void *v1618;
  void *v1619;
  void *v1620;
  void *v1621;
  void *v1622;
  void *v1623;
  void *v1624;
  __int128 v1625;
  uint64_t v1626;
  __int128 v1627;
  uint64_t v1628;
  __int128 v1629;
  uint64_t v1630;
  __int128 v1631;
  uint64_t v1632;
  __int128 v1633;
  uint64_t v1634;
  __int128 v1635;
  uint64_t v1636;
  _OWORD v1637[3];
  __int128 v1638;
  uint64_t v1639;
  __int128 v1640;
  uint64_t v1641;
  id v1642;
  void *v1643;
  void *v1644;
  void *v1645;
  void *v1646;
  void *v1647;
  void *v1648;
  void *v1649;
  void *v1650;
  void *v1651;
  void *v1652;
  void *v1653;
  void *v1654;
  void *v1655;
  void *v1656;
  void *v1657;
  void *v1658;
  void *v1659;
  void *v1660;
  id v1661;
  id v1662;
  id v1663;
  void *v1664;
  void *v1665;
  void *v1666;
  void *v1667;
  void *v1668;
  void *v1669;
  id v1670;
  _OWORD v1671[3];
  __int128 v1672;
  uint64_t v1673;
  __int128 v1674;
  uint64_t v1675;
  __int128 v1676;
  uint64_t v1677;
  __int128 v1678;
  uint64_t v1679;
  __int128 v1680;
  uint64_t v1681;
  _OWORD v1682[3];
  _OWORD v1683[3];
  _OWORD v1684[3];
  _OWORD v1685[3];
  _OWORD v1686[3];
  __int128 v1687;
  uint64_t v1688;
  __int128 v1689;
  uint64_t v1690;
  __int128 v1691;
  uint64_t v1692;
  __int128 v1693;
  uint64_t v1694;
  __int128 v1695;
  uint64_t v1696;
  __int128 v1697;
  uint64_t v1698;
  __int128 v1699;
  uint64_t v1700;
  __int128 v1701;
  uint64_t v1702;
  __int128 v1703;
  uint64_t v1704;
  __int128 v1705;
  uint64_t v1706;
  __int128 v1707;
  uint64_t v1708;
  __int128 v1709;
  uint64_t v1710;
  __int128 v1711;
  uint64_t v1712;
  __int128 v1713;
  uint64_t v1714;
  id v1715;
  void v1716[5];
  void v1717[5];
  void v1718[2];
  void v1719[2];
  uint8_t buf[16];
  __int128 v1721;
  __int128 v1722;
  __int128 v1723;
  __int128 v1724;
  __int128 v1725;
  __int128 v1726;
  __int128 v1727;
  __int128 v1728;
  __int128 v1729;
  __int128 v1730;
  __int128 v1731;
  __int128 v1732;
  __int128 v1733;
  __int128 v1734;
  uint64_t v1735;
  v4 = *(void *)(*(void *)a1 + 16LL);
  v5 = *(id *)(a1 + 8);
  v6 = 0LL;
  v7 = *((_DWORD *)a2 + 2);
  if (v7 <= -10158)
  {
    switch(v7)
    {
      case -16384:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16383:
        objc_msgSend( v5,  "removeBlitCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16382:
        v74 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v74]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v74 + 1)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v74 + 10)]);
        v77 = *((void *)v74 + 2);
        v78 = *((void *)v74 + 3);
        v79 = *((void *)v74 + 6);
        v1697 = *((_OWORD *)v74 + 2);
        v1698 = v79;
        v80 = *((void *)v74 + 9);
        v1695 = *(_OWORD *)(v74 + 56);
        v1696 = v80;
        v81 = *((void *)v74 + 11);
        v82 = *((void *)v74 + 12);
        v83 = *((void *)v74 + 15);
        v1693 = *(_OWORD *)(v74 + 104);
        v1694 = v83;
        [v14 copyFromTexture:v75 sourceSlice:v77 sourceLevel:v78 sourceOrigin:&v1697 sourceSize:&v1695 toTexture:v76 destinationSlice:v81 destinationLevel:v82 de stinationOrigin:&v1693];
        goto LABEL_1040;
      case -16381:
        v84 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v84]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v84 + 1)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v84 + 8)]);
        v85 = *((void *)v84 + 2);
        v86 = *((void *)v84 + 3);
        v87 = *((void *)v84 + 4);
        v88 = *((void *)v84 + 7);
        v1713 = *(_OWORD *)(v84 + 40);
        v1714 = v88;
        v89 = *((void *)v84 + 9);
        v90 = *((void *)v84 + 10);
        v91 = *((void *)v84 + 13);
        v1711 = *(_OWORD *)(v84 + 88);
        v1712 = v91;
        [v14 copyFromBuffer:v75 sourceOffset:v85 sourceBytesPerRow:v86 sourceBytesPerImage:v87 sourceSize:&v1713 toTexture:v76 destinationSlice:v89 destin ationLevel:v90 destinationOrigin:&v1711];
        goto LABEL_1040;
      case -16380:
        v92 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v92]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v92 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v92 + 10)]);
        v94 = *((void *)v92 + 2);
        v95 = *((void *)v92 + 3);
        v96 = *((void *)v92 + 6);
        v1705 = *((_OWORD *)v92 + 2);
        v1706 = v96;
        v97 = *((void *)v92 + 9);
        v1703 = *(_OWORD *)(v92 + 56);
        v1704 = v97;
        [v12 copyFromTexture:v18 sourceSlice:v94 sourceLevel:v95 sourceOrigin:&v1705 sourceSize:&v1703 toBuffer:v93 destinationOffset:*((void *)v92 + 11) destinationBytesPer Row:*((void *)v92 + 12) destinationBytesPerImage:*((void *)v92 + 13)];
        goto LABEL_1063;
      case -16379:
        v98 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v98]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v98 + 1)]);
        [v12 generateMipmapsForTexture:v33];
        goto LABEL_1131;
      case -16378:
        v99 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v99]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v99 + 1)]);
        objc_msgSend( v12,  "fillBuffer:range:value:",  v18,  *((void *)v99 + 2),  *((void *)v99 + 3),  v99[32]);
        goto LABEL_1064;
      case -16377:
        v100 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v100]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v100 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v100 + 3)]);
        [v12 copyFromBuffer:v18 sourceOffset:*((void *)v100 + 2) toBuffer:v93 destinationOffset:*((void *)v100 + 4) size:*((void *)v100 + 5)];
        goto LABEL_1063;
      case -16376:
        v101 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v101]);
        [v5 removeBlitCommandEncoderForKey:*(void *)v101];
        goto LABEL_707;
      case -16375:
        v102 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v102]);
        goto LABEL_709;
      case -16374:
      case -16373:
      case -16371:
      case -16367:
      case -16366:
      case -16362:
      case -16360:
      case -16356:
      case -16348:
      case -16326:
      case -16323:
      case -16322:
      case -16319:
      case -16289:
      case -16244:
      case -16243:
      case -16239:
      case -16237:
      case -16235:
      case -16232:
      case -16231:
      case -16230:
      case -16229:
      case -16228:
      case -16221:
      case -16213:
      case -16212:
      case -16207:
      case -16206:
      case -16205:
      case -16204:
      case -16203:
      case -16201:
      case -16195:
      case -16194:
      case -16193:
      case -16192:
      case -16191:
      case -16190:
      case -16189:
      case -16188:
      case -16187:
      case -16186:
      case -16185:
      case -16184:
      case -16183:
      case -16182:
      case -16181:
      case -16180:
      case -16179:
      case -16178:
      case -16177:
      case -16176:
      case -16175:
      case -16174:
      case -16173:
      case -16172:
      case -16171:
      case -16170:
      case -16169:
      case -16168:
      case -16167:
      case -16166:
      case -16164:
      case -16154:
      case -16153:
      case -16152:
      case -16151:
      case -16150:
      case -16135:
      case -16134:
      case -16121:
      case -16115:
      case -16113:
      case -16112:
      case -16111:
      case -16110:
      case -16109:
      case -16108:
      case -16104:
      case -16103:
      case -16102:
      case -16099:
      case -16097:
      case -16095:
      case -16094:
      case -16092:
      case -16080:
      case -16073:
      case -16072:
      case -16071:
      case -16070:
      case -16069:
      case -16068:
      case -16067:
      case -16066:
      case -16065:
      case -16064:
      case -16054:
      case -16050:
      case -16049:
      case -16048:
      case -16037:
      case -16036:
      case -16035:
      case -16034:
      case -16032:
      case -16031:
      case -16030:
      case -16029:
      case -16025:
      case -16024:
      case -16023:
      case -16019:
      case -16018:
      case -16016:
      case -16015:
      case -16013:
      case -16012:
      case -16011:
      case -16010:
      case -16007:
      case -16006:
      case -16005:
      case -16000:
      case -15999:
      case -15998:
      case -15989:
      case -15987:
      case -15986:
      case -15985:
      case -15983:
      case -15982:
      case -15981:
      case -15979:
      case -15978:
      case -15971:
      case -15968:
      case -15965:
      case -15953:
      case -15951:
      case -15947:
      case -15946:
      case -15945:
      case -15944:
      case -15943:
      case -15942:
      case -15941:
      case -15940:
      case -15939:
      case -15938:
      case -15937:
      case -15936:
      case -15932:
      case -15930:
      case -15929:
      case -15928:
      case -15920:
      case -15918:
      case -15917:
      case -15914:
      case -15913:
      case -15911:
      case -15904:
      case -15903:
      case -15902:
      case -15901:
      case -15900:
      case -15899:
      case -15898:
      case -15897:
      case -15895:
      case -15894:
      case -15893:
      case -15892:
      case -15891:
      case -15890:
      case -15889:
      case -15888:
      case -15887:
      case -15886:
      case -15885:
      case -15884:
      case -15883:
      case -15882:
      case -15881:
      case -15876:
      case -15875:
      case -15874:
      case -15873:
      case -15872:
      case -15871:
      case -15869:
      case -15868:
      case -15866:
      case -15865:
      case -15864:
      case -15863:
      case -15862:
      case -15861:
      case -15860:
      case -15859:
      case -15858:
      case -15857:
      case -15856:
      case -15855:
      case -15854:
      case -15853:
      case -15852:
      case -15851:
      case -15850:
      case -15849:
      case -15846:
      case -15845:
      case -15844:
      case -15843:
      case -15842:
      case -15841:
      case -15840:
      case -15839:
      case -15838:
      case -15837:
      case -15836:
      case -15835:
      case -15834:
      case -15833:
      case -15832:
      case -15831:
      case -15829:
      case -15828:
      case -15827:
      case -15826:
      case -15825:
      case -15824:
      case -15823:
      case -15817:
      case -15816:
      case -15815:
      case -15814:
      case -15813:
      case -15811:
      case -15810:
      case -15807:
      case -15804:
      case -15803:
      case -15802:
      case -15800:
      case -15799:
      case -15798:
      case -15797:
      case -15795:
      case -15792:
      case -15791:
      case -15780:
      case -15779:
      case -15776:
      case -15774:
      case -15773:
      case -15772:
      case -15771:
      case -15768:
      case -15767:
      case -15766:
      case -15765:
      case -15764:
      case -15763:
      case -15762:
      case -15761:
      case -15760:
      case -15759:
      case -15758:
      case -15757:
      case -15755:
      case -15754:
      case -15752:
      case -15751:
      case -15750:
      case -15749:
      case -15748:
      case -15747:
      case -15746:
      case -15745:
      case -15741:
      case -15739:
      case -15737:
      case -15736:
      case -15735:
      case -15734:
      case -15733:
      case -15719:
      case -15718:
      case -15717:
      case -15716:
      case -15713:
      case -15708:
      case -15706:
      case -15704:
      case -15703:
      case -15702:
      case -15700:
      case -15699:
      case -15697:
      case -15696:
      case -15694:
      case -15692:
      case -15691:
      case -15687:
      case -15686:
      case -15684:
      case -15683:
      case -15682:
      case -15681:
      case -15680:
      case -15679:
      case -15678:
      case -15677:
      case -15674:
      case -15672:
      case -15671:
      case -15670:
      case -15669:
      case -15667:
      case -15666:
      case -15665:
      case -15664:
      case -15663:
      case -15662:
      case -15660:
      case -15658:
      case -15657:
      case -15656:
      case -15655:
      case -15654:
      case -15653:
      case -15652:
      case -15650:
      case -15643:
      case -15636:
      case -15628:
      case -15626:
      case -15625:
      case -15624:
      case -15622:
      case -15621:
      case -15619:
      case -15618:
      case -15617:
      case -15616:
      case -15612:
      case -15611:
      case -15606:
      case -15604:
      case -15603:
      case -15602:
      case -15601:
      case -15600:
      case -15599:
      case -15598:
      case -15597:
      case -15596:
      case -15595:
      case -15594:
      case -15593:
      case -15590:
      case -15589:
      case -15579:
      case -15576:
      case -15575:
      case -15574:
      case -15573:
      case -15572:
      case -15571:
      case -15569:
      case -15567:
      case -15566:
      case -15565:
      case -15564:
      case -15563:
      case -15562:
      case -15561:
      case -15560:
      case -15559:
      case -15558:
      case -15557:
      case -15556:
      case -15555:
      case -15554:
      case -15553:
      case -15552:
      case -15549:
      case -15548:
      case -15547:
      case -15546:
      case -15545:
      case -15544:
      case -15543:
      case -15542:
      case -15541:
      case -15537:
      case -15536:
      case -15535:
      case -15534:
      case -15533:
      case -15532:
      case -15530:
      case -15529:
      case -15528:
      case -15527:
      case -15520:
      case -15519:
      case -15518:
      case -15517:
      case -15516:
      case -15515:
      case -15514:
      case -15513:
      case -15512:
      case -15510:
      case -15508:
      case -15507:
      case -15503:
      case -15499:
      case -15498:
      case -15497:
      case -15493:
      case -15492:
      case -15487:
      case -15485:
      case -15484:
      case -15483:
      case -15482:
      case -15481:
      case -15480:
      case -15479:
      case -15478:
      case -15477:
      case -15476:
      case -15468:
      case -15467:
      case -15433:
      case -15432:
      case -15431:
      case -15424:
      case -15423:
      case -15422:
      case -15418:
      case -15417:
      case -15413:
      case -15412:
      case -15411:
      case -15409:
      case -15408:
      case -15407:
      case -15402:
      case -15380:
      case -15379:
      case -15378:
      case -15377:
      case -15376:
      case -15375:
      case -15374:
      case -15373:
      case -15372:
      case -15371:
      case -15370:
      case -15369:
      case -15368:
      case -15367:
      case -15361:
      case -15360:
      case -15357:
      case -15349:
      case -15348:
      case -15347:
      case -15346:
      case -15345:
      case -15344:
      case -15338:
      case -15337:
      case -15334:
      case -15330:
      case -15328:
      case -15327:
      case -15326:
      case -15323:
      case -15322:
      case -15319:
      case -15305:
      case -15304:
      case -15303:
      case -15302:
      case -15301:
      case -15300:
      case -15298:
      case -15296:
      case -15295:
      case -15293:
      case -15292:
      case -15288:
      case -15286:
      case -15285:
      case -15271:
      case -15270:
      case -15269:
      case -15268:
      case -15267:
      case -15261:
      case -15260:
      case -15259:
      case -15258:
      case -15257:
      case -15256:
      case -15255:
      case -15248:
      case -15247:
      case -15244:
      case -15243:
      case -15242:
      case -15241:
      case -15240:
      case -15239:
      case -15238:
      case -15237:
      case -15236:
      case -15235:
      case -15234:
      case -15233:
      case -15232:
      case -15229:
      case -15228:
      case -15227:
      case -15226:
      case -15225:
      case -15224:
      case -15222:
      case -15221:
      case -15219:
      case -15218:
      case -15216:
      case -15215:
      case -15214:
      case -15213:
      case -15210:
      case -15209:
        goto LABEL_1431;
      case -16372:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16370:
        objc_msgSend( v5,  "removeBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16369:
        v104 = objc_msgSend( v5,  "bufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = objc_claimAutoreleasedReturnValue(v104);
        [v14 contents];
        goto LABEL_1041;
      case -16368:
        v105 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)v105]);
        GTTraceFunc_argumentBytesWithMap(a2, v105[32], v4);
        MTLTextureDescriptor = _MakeMTLTextureDescriptor();
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLTextureDescriptor);
        v109 = [v106 newTextureWithDescriptor:v108 offset:*((void *)v105 + 2) bytesPerRow:*((void *)v105 + 3)];
        goto LABEL_463;
      case -16365:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16364:
        v110 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v111 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v110]);
        goto LABEL_86;
      case -16363:
        objc_msgSend( v5,  "removeCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16361:
      case -16202:
      case -15318:
        v13 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v13]);
        [v5 removeCommandBufferForKey:*(void *)v13];
        [(id)g_activityLog logCommandBuffer:v14 atIndex:*(unsigned int *)(a1 + 22480)];
        GTMTLReplay_commitCommandBuffer(v14);
        if ((dword_5B9DE4 & 0x4000000) != 0)
        {
          [v14 waitUntilCompleted];
          if ([v14 status] == (char *)&dword_4 + 1)
          {
            v15 = (void *)objc_claimAutoreleasedReturnValue([v14 error]);
            NSLog(@"error: %@", v15);

            *(void *)(a1 + 22488) = *(void *)(a1 + 22480);
          }
        }

        goto LABEL_1041;
      case -16359:
      case -16358:
      case -16133:
        v8 = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4) + 1);
        goto LABEL_7;
      case -16357:
        v112 = objc_msgSend( v5,  "commandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v112);
        [v14 waitUntilScheduled];
        goto LABEL_1041;
      case -16355:
        v113 = objc_msgSend( v5,  "commandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v114 = (void *)objc_claimAutoreleasedReturnValue(v113);
        goto LABEL_1022;
      case -16354:
        v115 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v115]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 blitCommandEncoder]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v116 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v18 insertDebugSignpost:v116];
        }

        v19 = *((void *)v115 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setBlitCommandEncoder:v18 forKey:v19];
        goto LABEL_1064;
      case -16353:
        v117 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v117]);
        v118 = GTTraceFunc_argumentBytesWithMap(a2, v117[16], v4);
        v119 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPassDescriptorMap]);
        MTLRenderPassDescriptor = MakeMTLRenderPassDescriptor((uint64_t)v118, v119);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

        v121 = (id)objc_claimAutoreleasedReturnValue([v106 renderCommandEncoderWithDescriptor:v108]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v122 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v121 insertDebugSignpost:v122];
        }

        v123 = *((void *)v117 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setRenderCommandEncoder:v121 forKey:v123];
        goto LABEL_1304;
      case -16352:
        v124 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v124]);
        v125 = objc_claimAutoreleasedReturnValue([v12 computeCommandEncoder]);
        goto LABEL_632;
      case -16351:
        v126 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v126]);
        v127 = GTTraceFunc_argumentBytesWithMap(a2, v126[16], v4);
        v128 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPassDescriptorMap]);
        v129 = MakeMTLRenderPassDescriptor((uint64_t)v127, v128);
        v108 = (id)objc_claimAutoreleasedReturnValue(v129);

        v121 = (id)objc_claimAutoreleasedReturnValue([v106 parallelRenderCommandEncoderWithDescriptor:v108]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v130 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v121 insertDebugSignpost:v130];
        }

        v123 = *((void *)v126 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setParallelRenderCommandEncoder:v121 forKey:v123];
        goto LABEL_1304;
      case -16350:
        v131 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v131]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 debugCommandEncoder]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v132 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v18 insertDebugSignpost:v132];
        }

        v19 = *((void *)v131 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setDebugCommandEncoder:v18 forKey:v19];
        goto LABEL_1064;
      case -16349:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16347:
        v133 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v133]);
        [v12 setSkipRender:*((_DWORD *)v133 + 2) != 0];
        break;
      case -16346:
        v134 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v134]);
        [v12 setExecutionEnabled:*((_DWORD *)v134 + 2) != 0];
        break;
      case -16345:
        v110 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v111 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v110]);
LABEL_86:
        v12 = v111;
        [v111 setProfilingEnabled:*((_DWORD *)v110 + 2) != 0];
        break;
      case -16344:
        objc_msgSend( v5,  "removeCommandQueueForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16343:
      case -16342:
      case -15701:
        v16 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v16]);
        v17 = NewCommandBuffer(v12);
        v18 = (id)objc_claimAutoreleasedReturnValue(v17);
        v19 = *((void *)v16 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setCommandBuffer:v18 forKey:v19];
        goto LABEL_1064;
      case -16341:
        v135 = objc_msgSend( v5,  "commandQueueForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v135);
        [v14 insertDebugCaptureBoundary];
        goto LABEL_1041;
      case -16340:
        v136 = objc_msgSend( v5,  "commandQueueForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v136);
        [v14 finish];
        goto LABEL_1041;
      case -16339:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16338:
        objc_msgSend( v5,  "removeComputeCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16337:
        v137 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v138 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v137]);
        goto LABEL_506;
      case -16336:
        v139 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v140 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v139]);
        goto LABEL_377;
      case -16335:
        v141 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v141]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v142 = GTTraceFunc_argumentBytesWithMap(a2, v141[24], v4);
        v143 = GTTraceFunc_argumentBytesWithMap(a2, v141[25], v4);
        if (*((void *)v141 + 2))
        {
          v144 = 0LL;
          do
          {
            v145 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v142[8 * v144]]);
            v146 = *(void **)&buf[8 * v144];
            *(void *)&buf[8 * v144] = v145;

            ++v144;
            v147 = *((void *)v141 + 2);
          }

          while (v147 > v144);
        }

        else
        {
          v147 = 0LL;
        }

        objc_msgSend(v106, "setBuffers:offsets:withRange:", buf, v143, *((void *)v141 + 1), v147);
        for (i = 240LL; i != -8; i -= 8LL)

        goto LABEL_1429;
      case -16334:
        v148 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v149 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v148]);
        goto LABEL_383;
      case -16333:
        v150 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v150]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v151 = GTTraceFunc_argumentBytesWithMap(a2, v150[24], v4);
        if (*((void *)v150 + 2))
        {
          v152 = v151;
          v153 = 0LL;
          do
          {
            v154 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v152[8 * v153]]);
            v155 = *(void **)&buf[8 * v153];
            *(void *)&buf[8 * v153] = v154;

            ++v153;
            v156 = *((void *)v150 + 2);
          }

          while (v156 > v153);
        }

        else
        {
          v156 = 0LL;
        }

        objc_msgSend(v106, "setTextures:withRange:", buf, *((void *)v150 + 1), v156);
        for (j = 240LL; j != -8; j -= 8LL)

        goto LABEL_1429;
      case -16332:
        v157 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v158 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v157]);
        goto LABEL_389;
      case -16331:
        v159 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v159]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v160 = GTTraceFunc_argumentBytesWithMap(a2, v159[24], v4);
        if (*((void *)v159 + 2))
        {
          v161 = v160;
          v162 = 0LL;
          do
          {
            v163 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v161[8 * v162]]);
            v164 = *(void **)&buf[8 * v162];
            *(void *)&buf[8 * v162] = v163;

            ++v162;
            v165 = *((void *)v159 + 2);
          }

          while (v165 > v162);
        }

        else
        {
          v165 = 0LL;
        }

        objc_msgSend(v106, "setSamplerStates:withRange:", buf, *((void *)v159 + 1), v165);
        for (k = 120LL; k != -8; k -= 8LL)

        goto LABEL_1429;
      case -16330:
        v166 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v166]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v166 + 1)]);
        LODWORD(v167) = *((_DWORD *)v166 + 6);
        LODWORD(v168) = *((_DWORD *)v166 + 7);
        [v12 setSamplerState:v18 lodMinClamp:*((void *)v166 + 2) lodMaxClamp:v167 atIndex:v168];
        goto LABEL_1064;
      case -16329:
        v169 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v169]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v170 = GTTraceFunc_argumentBytesWithMap(a2, v169[24], v4);
        v171 = GTTraceFunc_argumentBytesWithMap(a2, v169[25], v4);
        v172 = GTTraceFunc_argumentBytesWithMap(a2, v169[26], v4);
        if (*((void *)v169 + 2))
        {
          v173 = 0LL;
          do
          {
            v174 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v170[8 * v173]]);
            v175 = *(void **)&buf[8 * v173];
            *(void *)&buf[8 * v173] = v174;

            ++v173;
            v176 = *((void *)v169 + 2);
          }

          while (v176 > v173);
        }

        else
        {
          v176 = 0LL;
        }

        objc_msgSend( v106,  "setSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  buf,  v171,  v172,  *((void *)v169 + 1),  v176);
        for (m = 120LL; m != -8; m -= 8LL)

        goto LABEL_1429;
      case -16328:
        v177 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v178 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v177]);
        goto LABEL_510;
      case -16327:
        v179 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v179]);
        v180 = *((void *)v179 + 3);
        v1680 = *(_OWORD *)(v179 + 8);
        v1681 = v180;
        v181 = *((void *)v179 + 6);
        v1678 = *((_OWORD *)v179 + 2);
        v1679 = v181;
        [v12 dispatchThreadgroups:&v1680 threadsPerThreadgroup:&v1678];
        break;
      case -16325:
        v182 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v182]);
        [v5 removeComputeCommandEncoderForKey:*(void *)v182];
        goto LABEL_707;
      case -16324:
        v102 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v102]);
        goto LABEL_709;
      case -16321:
        objc_msgSend( v5,  "removeComputePipelineStateForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16320:
        objc_msgSend( v5,  "removeDepthStencilStateForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16318:
        v183 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v183]);
        [v12 setMetalAssertionsEnabled:*((_DWORD *)v183 + 2) != 0];
        break;
      case -16317:
        objc_msgSend( v5,  "removeDeviceForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16316:
      case -16315:
        v20 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 defaultCommandQueue]);
        v21 = *((void *)v20 + 1);
        if (!v12) {
          goto LABEL_125;
        }
        [v5 setCommandQueue:v12 forKey:v21];
        break;
      case -16314:
        v184 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v185 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v184]);
        goto LABEL_318;
      case -16313:
LABEL_24:
        v24 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v25 = a1;
        v26 = a2;
        v27 = v24;
        goto LABEL_123;
      case -16312:
        v24 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v186 = *((_OWORD *)v24 + 1);
        v1579[0] = *(_OWORD *)v24;
        v1579[1] = v186;
        v1580 = 0LL;
        v1581 = v24[40];
        memset(v1582, 0, sizeof(v1582));
        v27 = (char *)v1579;
        v25 = a1;
        v26 = a2;
LABEL_123:
        v187 = MTLDevice_newBufferWithBytes_length_options(v25, v26, (uint64_t)v27);
        v12 = (void *)objc_claimAutoreleasedReturnValue(v187);
        v21 = *((void *)v24 + 1);
        if (v12)
        {
          [v5 setBuffer:v12 forKey:v21];
        }

        else
        {
LABEL_125:
          if (v21) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v21);
          }
        }

        break;
      case -16311:
        v188 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v188]);
        v189 = GTTraceFunc_argumentBytesWithMap(a2, v188[16], v4);
        MTLDepthStencilDescriptor = MakeMTLDepthStencilDescriptor((uint64_t)v189);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLDepthStencilDescriptor);
        v191 = [v106 newDepthStencilStateWithDescriptor:v108];
        v192 = *((void *)v188 + 1);
        if (!v191) {
          goto LABEL_1425;
        }
        [v5 setDepthStencilState:v191 forKey:v192];
        goto LABEL_1427;
      case -16310:
        v105 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v105]);
        v193 = v105[24];
        goto LABEL_323;
      case -16309:
        v194 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v194]);
        v195 = (uint64_t (*)(void))MakeMTLSamplerDescriptor;
        v196 = GTTraceFunc_argumentBytesWithMap(a2, v194[16], v4);
        v197 = v195(v196);
        v108 = (id)objc_claimAutoreleasedReturnValue(v197);
        v191 = [v106 newSamplerStateWithDescriptor:v108];
        v192 = *((void *)v194 + 1);
        if (!v191) {
          goto LABEL_1425;
        }
        [v5 setSamplerState:v191 forKey:v192];
        goto LABEL_1427;
      case -16308:
        v198 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v198]);
        v199 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 14), v4);
        v200 = GTTraceFunc_argumentBytesWithMap(a2, v198[16], v4);
        v201 = *(char **)v199;
        v202 = *((void *)v198 + 1);
        v1575 = 0LL;
        v203 = NewLibraryWithFile(v60, a1, v200, v201, 1, v202, &v1575);
        v204 = (id)objc_claimAutoreleasedReturnValue(v203);
        v205 = v1575;
        goto LABEL_1192;
      case -16307:
        v198 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v198]);
        v206 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 14), v4);
        if (v206) {
          v207 = *(char **)v206;
        }
        else {
          v207 = 0LL;
        }
        v1491 = GTTraceFunc_argumentBytesWithMap(a2, v198[24], v4);
        v1492 = *((void *)v198 + 1);
        v1573 = 0LL;
        v1493 = NewLibraryWithFile(v60, a1, v1491, v207, v207 != 0LL, v1492, &v1573);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1493);
        v205 = v1573;
        goto LABEL_1192;
      case -16306:
        v198 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v198]);
        v208 = GTTraceFunc_argumentBytesWithMap(a2, v198[24], v4);
        v209 = *((void *)v198 + 1);
        v1574 = 0LL;
        v210 = NewLibraryWithFile(v60, a1, v208, 0LL, 0, v209, &v1574);
        v204 = (id)objc_claimAutoreleasedReturnValue(v210);
        v205 = v1574;
        goto LABEL_1192;
      case -16305:
        v198 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v198]);
        v211 = GTTraceFunc_argumentBytesWithMap(a2, v198[24], v4);
        v212 = GTTraceFunc_argumentBytesWithMap(a2, v198[25], v4);
        v213 = (void *)objc_claimAutoreleasedReturnValue([v5 dynamicLibraries]);
        MTLCompileOptions = _MakeMTLCompileOptions((uint64_t)v212, v213);
        v215 = (void *)objc_claimAutoreleasedReturnValue(MTLCompileOptions);
        v1570 = 0LL;
        v216 = NewLibraryWithSource(a1, v60, v211, v215, &v1570);
        v204 = (id)objc_claimAutoreleasedReturnValue(v216);
        v217 = v1570;
        goto LABEL_138;
      case -16304:
        v198 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v198]);
        v218 = GTTraceFunc_argumentBytesWithMap(a2, v198[24], v4);
        v219 = GTTraceFunc_argumentBytesWithMap(a2, v198[25], v4);
        v213 = (void *)objc_claimAutoreleasedReturnValue([v5 dynamicLibraries]);
        v220 = _MakeMTLCompileOptions((uint64_t)v219, v213);
        v215 = (void *)objc_claimAutoreleasedReturnValue(v220);
        v1569 = 0LL;
        v221 = NewLibraryWithSource(a1, v60, v218, v215, &v1569);
        v204 = (id)objc_claimAutoreleasedReturnValue(v221);
        v217 = v1569;
LABEL_138:
        v6 = v217;

        goto LABEL_1193;
      case -16303:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v223 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        MTLRenderPipelineDescriptor = _MakeMTLRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptor);

        v1653 = 0LL;
        v225 = [v60 newRenderPipelineStateWithDescriptor:v204 error:&v1653];
        v226 = v1653;
        goto LABEL_923;
      case -16302:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[32], v4);
        v227 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v228 = _MakeMTLRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v228);

        v229 = *((void *)v222 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1651 = 0LL;
        v225 = [v60 newRenderPipelineStateWithDescriptor:v204 options:v229 reflection:0 error:&v1651];
        v226 = v1651;
        goto LABEL_923;
      case -16301:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v230 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v231 = _MakeMTLRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v231);

        v1654 = 0LL;
        v225 = [v60 newRenderPipelineStateWithDescriptor:v204 error:&v1654];
        v226 = v1654;
        goto LABEL_923;
      case -16300:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[32], v4);
        v232 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v233 = _MakeMTLRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v233);

        v234 = *((void *)v222 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1652 = 0LL;
        v225 = [v60 newRenderPipelineStateWithDescriptor:v204 options:v234 reflection:0 error:&v1652];
        v226 = v1652;
        goto LABEL_923;
      case -16299:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v235 + 2)]);
        v1578 = 0LL;
        v225 = [v60 newComputePipelineStateWithFunction:v204 error:&v1578];
        v236 = v1578;
        goto LABEL_331;
      case -16298:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v235 + 2)]);
        v237 = *((void *)v235 + 3);
        v1577 = 0LL;
        v225 = [v60 newComputePipelineStateWithFunction:v204 options:v237 reflection:0 error:&v1577];
        v236 = v1577;
        goto LABEL_331;
      case -16297:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v235 + 2)]);
        v1665 = 0LL;
        v225 = [v60 newComputePipelineStateWithFunction:v204 error:&v1665];
        v236 = v1665;
        goto LABEL_331;
      case -16296:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v235 + 2)]);
        v238 = *((void *)v235 + 3) & 0xFFFFFFFFFFFFFFFBLL;
        v1664 = 0LL;
        v225 = [v60 newComputePipelineStateWithFunction:v204 options:v238 reflection:0 error:&v1664];
        v236 = v1664;
        goto LABEL_331;
      case -16295:
        v239 = objc_msgSend( v5,  "deviceForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v239);
        [v14 unmapShaderSampleBuffer];
        goto LABEL_1041;
      case -16294:
        v240 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v240]);
        v241 = GTTraceFunc_argumentBytesWithMap(a2, v240[25], v4);
        IOSurface = _MakeIOSurface((uint64_t)v241, v5);
        v243 = (void *)objc_claimAutoreleasedReturnValue(IOSurface);
        GTTraceFunc_argumentBytesWithMap(a2, v240[24], v4);
        v244 = _MakeMTLTextureDescriptor();
        v245 = (void *)objc_claimAutoreleasedReturnValue(v244);
        v246 = [v106 newTextureWithDescriptor:v245 iosurface:v243 plane:*((void *)v240 + 2)];

        v247 = *((void *)v240 + 1);
        if (v246)
        {
          [v5 setTexture:v246 forKey:v247];
        }

        else if (v247)
        {
          GTMTLReplay_dispatchFailedToSet((uint64_t)a2, *((void *)v240 + 1));
        }

        goto LABEL_1313;
      case -16293:
        objc_msgSend( v5,  "removeFunctionForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16292:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16291:
        objc_msgSend( v5,  "removeLibraryForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16290:
        v248 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v249 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v248]);
        v106 = v249;
        if (v248[16])
        {
          v250 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v248[16], v4));
          v251 = (void *)objc_claimAutoreleasedReturnValue(v250);
          v252 = [v106 newFunctionWithName:v251];
          goto LABEL_422;
        }

        v1495 = [v249 newFunctionWithName:0];
        goto LABEL_1288;
      case -16288:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16287:
        objc_msgSend( v5,  "removeParallelRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16286:
        v253 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v253]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 renderCommandEncoder]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v254 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v18 insertDebugSignpost:v254];
        }

        v19 = *((void *)v253 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setRenderCommandEncoder:v18 forKey:v19];
        goto LABEL_1064;
      case -16285:
        v255 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v255]);
        [v5 removeParallelRenderCommandEncoderForKey:*(void *)v255];
        goto LABEL_707;
      case -16284:
        v102 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v102]);
        goto LABEL_709;
      case -16283:
        v256 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v257 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v256]);
        goto LABEL_715;
      case -16282:
        v258 = objc_msgSend( v5,  "parallelRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v259 = (void *)objc_claimAutoreleasedReturnValue(v258);
        goto LABEL_713;
      case -16281:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16280:
        objc_msgSend( v5,  "removeRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16279:
        v260 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v261 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v260]);
        goto LABEL_493;
      case -16278:
        v262 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v263 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v262]);
        goto LABEL_495;
      case -16277:
        v264 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v264]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v265 = GTTraceFunc_argumentBytesWithMap(a2, v264[24], v4);
        v266 = GTTraceFunc_argumentBytesWithMap(a2, v264[25], v4);
        if (*((void *)v264 + 2))
        {
          v267 = 0LL;
          do
          {
            v268 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v265[8 * v267]]);
            v269 = *(void **)&buf[8 * v267];
            *(void *)&buf[8 * v267] = v268;

            ++v267;
            v270 = *((void *)v264 + 2);
          }

          while (v270 > v267);
        }

        else
        {
          v270 = 0LL;
        }

        objc_msgSend(v106, "setVertexBuffers:offsets:withRange:", buf, v266, *((void *)v264 + 1), v270);
        for (n = 240LL; n != -8; n -= 8LL)

        goto LABEL_1429;
      case -16276:
        v271 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v271]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v271 + 1)]);
        [v12 setVertexTexture:v18 atIndex:*((void *)v271 + 2)];
        goto LABEL_1064;
      case -16275:
        v272 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v272]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v273 = GTTraceFunc_argumentBytesWithMap(a2, v272[24], v4);
        if (*((void *)v272 + 2))
        {
          v274 = v273;
          v275 = 0LL;
          do
          {
            v276 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v274[8 * v275]]);
            v277 = *(void **)&buf[8 * v275];
            *(void *)&buf[8 * v275] = v276;

            ++v275;
            v278 = *((void *)v272 + 2);
          }

          while (v278 > v275);
        }

        else
        {
          v278 = 0LL;
        }

        objc_msgSend(v106, "setVertexTextures:withRange:", buf, *((void *)v272 + 1), v278);
        for (ii = 240LL; ii != -8; ii -= 8LL)

        goto LABEL_1429;
      case -16274:
        v279 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v279]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v279 + 1)]);
        [v12 setVertexSamplerState:v18 atIndex:*((void *)v279 + 2)];
        goto LABEL_1064;
      case -16273:
        v280 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v280]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v281 = GTTraceFunc_argumentBytesWithMap(a2, v280[24], v4);
        if (*((void *)v280 + 2))
        {
          v282 = v281;
          v283 = 0LL;
          do
          {
            v284 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v282[8 * v283]]);
            v285 = *(void **)&buf[8 * v283];
            *(void *)&buf[8 * v283] = v284;

            ++v283;
            v286 = *((void *)v280 + 2);
          }

          while (v286 > v283);
        }

        else
        {
          v286 = 0LL;
        }

        objc_msgSend(v106, "setVertexSamplerStates:withRange:", buf, *((void *)v280 + 1), v286);
        for (jj = 120LL; jj != -8; jj -= 8LL)

        goto LABEL_1429;
      case -16272:
        v287 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v287]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v287 + 1)]);
        LODWORD(v288) = *((_DWORD *)v287 + 6);
        LODWORD(v289) = *((_DWORD *)v287 + 7);
        [v12 setVertexSamplerState:v18 lodMinClamp:*((void *)v287 + 2) lodMaxClamp:v288 atIndex:v289];
        goto LABEL_1064;
      case -16271:
        v290 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v290]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v291 = GTTraceFunc_argumentBytesWithMap(a2, v290[24], v4);
        v292 = GTTraceFunc_argumentBytesWithMap(a2, v290[25], v4);
        v293 = GTTraceFunc_argumentBytesWithMap(a2, v290[26], v4);
        if (*((void *)v290 + 2))
        {
          v294 = 0LL;
          do
          {
            v295 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v291[8 * v294]]);
            v296 = *(void **)&buf[8 * v294];
            *(void *)&buf[8 * v294] = v295;

            ++v294;
            v297 = *((void *)v290 + 2);
          }

          while (v297 > v294);
        }

        else
        {
          v297 = 0LL;
        }

        objc_msgSend( v106,  "setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  buf,  v292,  v293,  *((void *)v290 + 1),  v297);
        for (kk = 120LL; kk != -8; kk -= 8LL)

        goto LABEL_1429;
      case -16270:
        v298 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v298]);
        v299 = *(_OWORD *)(v298 + 24);
        v300 = *(_OWORD *)(v298 + 40);
        *(_OWORD *)buf = *(_OWORD *)(v298 + 8);
        v1721 = v299;
        v1722 = v300;
        [v12 setViewport:buf];
        break;
      case -16269:
        v301 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v301]);
        [v12 setFrontFacingWinding:*((void *)v301 + 1)];
        break;
      case -16268:
        v302 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v302]);
        [v12 setCullMode:*((void *)v302 + 1)];
        break;
      case -16267:
        v303 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v303]);
        [v12 setDepthClipMode:*((void *)v303 + 1)];
        break;
      case -16266:
        v304 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v304]);
        LODWORD(v305) = *((_DWORD *)v304 + 2);
        LODWORD(v306) = *((_DWORD *)v304 + 3);
        LODWORD(v307) = *((_DWORD *)v304 + 4);
        [v12 setDepthBias:v305 slopeScale:v306 clamp:v307];
        break;
      case -16265:
        v308 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v308]);
        v309 = *(_OWORD *)(v308 + 24);
        *(_OWORD *)buf = *(_OWORD *)(v308 + 8);
        v1721 = v309;
        [v12 setScissorRect:buf];
        break;
      case -16264:
        v310 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v310]);
        [v12 setTriangleFillMode:*((void *)v310 + 1)];
        break;
      case -16263:
        v311 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v312 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v311]);
        goto LABEL_497;
      case -16262:
        v313 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v313]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v314 = GTTraceFunc_argumentBytesWithMap(a2, v313[24], v4);
        v315 = GTTraceFunc_argumentBytesWithMap(a2, v313[25], v4);
        if (*((void *)v313 + 2))
        {
          v316 = 0LL;
          do
          {
            v317 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v314[8 * v316]]);
            v318 = *(void **)&buf[8 * v316];
            *(void *)&buf[8 * v316] = v317;

            ++v316;
            v319 = *((void *)v313 + 2);
          }

          while (v319 > v316);
        }

        else
        {
          v319 = 0LL;
        }

        objc_msgSend(v106, "setFragmentBuffers:offsets:withRange:", buf, v315, *((void *)v313 + 1), v319);
        for (mm = 240LL; mm != -8; mm -= 8LL)

        goto LABEL_1429;
      case -16261:
        v320 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v320]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v320 + 1)]);
        [v12 setFragmentTexture:v18 atIndex:*((void *)v320 + 2)];
        goto LABEL_1064;
      case -16260:
        v321 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v321]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v322 = GTTraceFunc_argumentBytesWithMap(a2, v321[24], v4);
        if (*((void *)v321 + 2))
        {
          v323 = v322;
          v324 = 0LL;
          do
          {
            v325 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v323[8 * v324]]);
            v326 = *(void **)&buf[8 * v324];
            *(void *)&buf[8 * v324] = v325;

            ++v324;
            v327 = *((void *)v321 + 2);
          }

          while (v327 > v324);
        }

        else
        {
          v327 = 0LL;
        }

        objc_msgSend(v106, "setFragmentTextures:withRange:", buf, *((void *)v321 + 1), v327);
        for (nn = 240LL; nn != -8; nn -= 8LL)

        goto LABEL_1429;
      case -16259:
        v328 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v328]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v328 + 1)]);
        [v12 setFragmentSamplerState:v18 atIndex:*((void *)v328 + 2)];
        goto LABEL_1064;
      case -16258:
        v329 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v329]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v330 = GTTraceFunc_argumentBytesWithMap(a2, v329[24], v4);
        if (*((void *)v329 + 2))
        {
          v331 = v330;
          v332 = 0LL;
          do
          {
            v333 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v331[8 * v332]]);
            v334 = *(void **)&buf[8 * v332];
            *(void *)&buf[8 * v332] = v333;

            ++v332;
            v335 = *((void *)v329 + 2);
          }

          while (v335 > v332);
        }

        else
        {
          v335 = 0LL;
        }

        objc_msgSend(v106, "setFragmentSamplerStates:withRange:", buf, *((void *)v329 + 1), v335);
        for (i1 = 120LL; i1 != -8; i1 -= 8LL)

        goto LABEL_1429;
      case -16257:
        v336 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v336]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v336 + 1)]);
        LODWORD(v337) = *((_DWORD *)v336 + 6);
        LODWORD(v338) = *((_DWORD *)v336 + 7);
        [v12 setFragmentSamplerState:v18 lodMinClamp:*((void *)v336 + 2) lodMaxClamp:v337 atIndex:v338];
        goto LABEL_1064;
      case -16256:
        v339 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v339]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v340 = GTTraceFunc_argumentBytesWithMap(a2, v339[24], v4);
        v341 = GTTraceFunc_argumentBytesWithMap(a2, v339[25], v4);
        v342 = GTTraceFunc_argumentBytesWithMap(a2, v339[26], v4);
        if (*((void *)v339 + 2))
        {
          v343 = 0LL;
          do
          {
            v344 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v340[8 * v343]]);
            v345 = *(void **)&buf[8 * v343];
            *(void *)&buf[8 * v343] = v344;

            ++v343;
            v346 = *((void *)v339 + 2);
          }

          while (v346 > v343);
        }

        else
        {
          v346 = 0LL;
        }

        objc_msgSend( v106,  "setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  buf,  v341,  v342,  *((void *)v339 + 1),  v346);
        for (i2 = 120LL; i2 != -8; i2 -= 8LL)

        goto LABEL_1429;
      case -16255:
        v347 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v347]);
        LODWORD(v348) = *((_DWORD *)v347 + 2);
        LODWORD(v349) = *((_DWORD *)v347 + 3);
        LODWORD(v350) = *((_DWORD *)v347 + 4);
        LODWORD(v351) = *((_DWORD *)v347 + 5);
        [v12 setBlendColorRed:v348 green:v349 blue:v350 alpha:v351];
        break;
      case -16254:
        v352 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v352]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 depthStencilStateForKey:*((void *)v352 + 1)]);
        [v12 setDepthStencilState:v33];
        goto LABEL_1131;
      case -16253:
        v353 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v353]);
        [v12 setStencilReferenceValue:*((unsigned int *)v353 + 2)];
        break;
      case -16252:
        v354 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v354]);
        [v12 setVisibilityResultMode:*((void *)v354 + 1) offset:*((void *)v354 + 2)];
        break;
      case -16251:
        v355 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v355]);
        [v12 drawPrimitives:*((void *)v355 + 1) vertexStart:*((void *)v355 + 2) vertexCount:*((void *)v355 + 3) instanceCount:*((void *)v355 + 4)];
        break;
      case -16250:
        v356 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v356]);
        [v12 drawPrimitives:*((void *)v356 + 1) vertexStart:*((void *)v356 + 2) vertexCount:*((void *)v356 + 3)];
        break;
      case -16249:
        v357 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v357]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v357 + 4)]);
        [v12 drawIndexedPrimitives:*((void *)v357 + 1) indexCount:*((void *)v357 + 2) indexType:*((void *)v357 + 3) indexBuffer:v18 indexBufferOffset:*((void *)v357 + 5) instanceCount:*((void *)v357 + 6)];
        goto LABEL_1064;
      case -16248:
        v358 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v358]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v358 + 4)]);
        [v12 drawIndexedPrimitives:*((void *)v358 + 1) indexCount:*((void *)v358 + 2) indexType:*((void *)v358 + 3) indexBuffer:v18 indexBufferOffset:*((void *)v358 + 5)];
        goto LABEL_1064;
      case -16247:
        v359 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v359]);
        LODWORD(v360) = *((_DWORD *)v359 + 2);
        [v12 setLineWidth:v360];
        break;
      case -16246:
        v361 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v361]);
        [v5 removeRenderCommandEncoderForKey:*(void *)v361];
        goto LABEL_707;
      case -16245:
        v102 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v102]);
        goto LABEL_709;
      case -16242:
        objc_msgSend( v5,  "removeRenderPipelineStateForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16241:
        objc_msgSend( v5,  "removeSamplerStateForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16240:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16238:
        objc_msgSend( v5,  "removeTextureForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16236:
LABEL_9:
        v9 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        *(void *)buf = 80LL;
        *(void *)&buf[8] = *(void *)v9;
        *(void *)&v1721 = 0LL;
        *((void *)&v1721 + 1) = GTTraceFunc_argumentBytesWithMap(a2, v9[96], v4);
        *(int16x4_t *)&v1722 = vmovn_s32( vuzp1q_s32( (int32x4_t)vextq_s8(*(int8x16_t *)(v9 + 56), *(int8x16_t *)(v9 + 56), 8uLL),  *(int32x4_t *)(v9 + 8)));
        v10 = vmovn_s64(*(int64x2_t *)(v9 + 72));
        *((int16x4_t *)&v1722 + 1) = vmovn_s32(vuzp1q_s32(*(int32x4_t *)(v9 + 24), *(int32x4_t *)(v9 + 40)));
        v1723 = (unint64_t)v10;
        goto LABEL_231;
      case -16234:
        v362 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        *(void *)buf = 80LL;
        *(void *)&buf[8] = *(void *)v362;
        *(void *)&v1721 = 0LL;
        *((void *)&v1721 + 1) = GTTraceFunc_argumentBytesWithMap(a2, v362[72], v4);
        LOWORD(v1722) = 0;
        v363 = *((void *)v362 + 8);
        WORD1(v1722) = *((void *)v362 + 7);
        *(int16x4_t *)((char *)&v1722 + 4) = vmovn_s32(vuzp1q_s32(*(int32x4_t *)(v362 + 8), *(int32x4_t *)(v362 + 24)));
        v364 = *((void *)v362 + 6);
        WORD6(v1722) = *((void *)v362 + 5);
        HIWORD(v1722) = v364;
        *(void *)((char *)&v1723 + 4) = 0LL;
        LODWORD(v1723) = v363;
        HIDWORD(v1723) = 0;
LABEL_231:
        GTMTLReplayController_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage(a1, (uint64_t)buf);
        goto LABEL_1430;
      case -16233:
        v365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v365]);
        Object = GTMTLSMContext_lastObject(**(void **)(*(void *)a1 + 40LL), *((void *)v365 + 1), *a2);
        if ((g_enableIndexedResourceType & 1) == 0) {
          goto LABEL_659;
        }
        v367 = Object;
        if (!*(void *)(Object + 176)) {
          goto LABEL_659;
        }
        v368 = DEVICEOBJECT(v12);
        v369 = (void *)objc_claimAutoreleasedReturnValue(v368);
        v370 = objc_opt_respondsToSelector(v369, "newTextureViewWithPixelFormat:resourceIndex:");

        if ((v370 & 1) == 0) {
          goto LABEL_659;
        }
        v371 = *((void *)v365 + 2);
        v372 = *(void *)(v367 + 176);
        goto LABEL_658;
      case -16227:
        v373 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v373]);
        objc_msgSend( v56,  "setBytes:length:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v373[24], v4),  *((void *)v373 + 1),  *((void *)v373 + 2));
        goto LABEL_1090;
      case -16226:
        v374 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v374]);
        [v12 setBufferOffset:*((void *)v374 + 1) atIndex:*((void *)v374 + 2)];
        break;
      case -16225:
        v375 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v375]);
        objc_msgSend( v56,  "setVertexBytes:length:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v375[24], v4),  *((void *)v375 + 1),  *((void *)v375 + 2));
        goto LABEL_1090;
      case -16224:
        v376 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v376]);
        [v12 setVertexBufferOffset:*((void *)v376 + 1) atIndex:*((void *)v376 + 2)];
        break;
      case -16223:
        v377 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v377]);
        objc_msgSend( v56,  "setFragmentBytes:length:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v377[24], v4),  *((void *)v377 + 1),  *((void *)v377 + 2));
        goto LABEL_1090;
      case -16222:
        v378 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v378]);
        [v12 setFragmentBufferOffset:*((void *)v378 + 1) atIndex:*((void *)v378 + 2)];
        break;
      case -16220:
        v379 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v379]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v379 + 1)]);
        v380 = *((void *)v379 + 2);
        v381 = *((void *)v379 + 5);
        v1676 = *(_OWORD *)(v379 + 24);
        v1677 = v381;
        [v12 dispatchThreadgroupsWithIndirectBuffer:v18 indirectBufferOffset:v380 threadsPerThreadgroup:&v1676];
        goto LABEL_1064;
      case -16219:
        v382 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v382]);
        [v12 setStencilFrontReferenceValue:*((unsigned int *)v382 + 2) backReferenceValue:*((unsigned int *)v382 + 3)];
        break;
      case -16218:
        v383 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v384 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v383]);
        goto LABEL_501;
      case -16217:
        v385 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v386 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v385]);
        goto LABEL_503;
      case -16216:
        v387 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v387]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v387 + 2)]);
        [v12 drawPrimitives:*((void *)v387 + 1) indirectBuffer:v18 indirectBufferOffset:*((void *)v387 + 3)];
        goto LABEL_1064;
      case -16215:
        v388 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v388]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v388 + 3)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v388 + 5)]);
        [v12 drawIndexedPrimitives:*((void *)v388 + 1) indexType:*((void *)v388 + 2) indexBuffer:v18 indexBufferOffset:*((void *)v388 + 4) indirectBuffer:v93 indirectBufferOffset:*((void *)v388 + 6)];
        goto LABEL_1063;
      case -16214:
        v389 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v389]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v389 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v389 + 3)]);
        [v12 setFragmentTexture:v18 atTextureIndex:*((void *)v389 + 2) samplerState:v93 atSamplerIndex:*((void *)v389 + 4)];
        goto LABEL_1063;
      case -16211:
        v390 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v390]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v390 + 1)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v390 + 10)]);
        v391 = *((void *)v390 + 2);
        v392 = *((void *)v390 + 3);
        v393 = *((void *)v390 + 6);
        v1691 = *((_OWORD *)v390 + 2);
        v1692 = v393;
        v394 = *((void *)v390 + 9);
        v1689 = *(_OWORD *)(v390 + 56);
        v1690 = v394;
        v395 = *((void *)v390 + 11);
        v396 = *((void *)v390 + 12);
        v1687 = *(_OWORD *)(v390 + 104);
        v397 = *((void *)v390 + 16);
        v1688 = *((void *)v390 + 15);
        [v14 copyFromTexture:v75 sourceSlice:v391 sourceLevel:v392 sourceOrigin:&v1691 sourceSize:&v1689 toTexture:v76 destinationSlice:v395 destinationLevel:v396 de stinationOrigin:&v1687 options:v397];
        goto LABEL_1040;
      case -16210:
        v398 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v398]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v398 + 1)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v398 + 8)]);
        v399 = *((void *)v398 + 2);
        v400 = *((void *)v398 + 3);
        v401 = *((void *)v398 + 4);
        v402 = *((void *)v398 + 7);
        v1709 = *(_OWORD *)(v398 + 40);
        v1710 = v402;
        v403 = *((void *)v398 + 9);
        v404 = *((void *)v398 + 10);
        v1707 = *(_OWORD *)(v398 + 88);
        v405 = *((void *)v398 + 14);
        v1708 = *((void *)v398 + 13);
        [v14 copyFromBuffer:v75 sourceOffset:v399 sourceBytesPerRow:v400 sourceBytesPerImage:v401 sourceSize:&v1709 toTexture:v76 destinationSlice:v403 destin ationLevel:v404 destinationOrigin:&v1707 options:v405];
        goto LABEL_1040;
      case -16209:
        v406 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v406]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v406 + 1)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v406 + 10)]);
        v407 = *((void *)v406 + 2);
        v408 = *((void *)v406 + 3);
        v409 = *((void *)v406 + 6);
        v1701 = *((_OWORD *)v406 + 2);
        v1702 = v409;
        v410 = *((void *)v406 + 9);
        v1699 = *(_OWORD *)(v406 + 56);
        v1700 = v410;
        [v14 copyFromTexture:v75 sourceSlice:v407 sourceLevel:v408 sourceOrigin:&v1701 sourceSize:&v1699 toBuffer:v76 destinationOffset:*((void *)v406 + 11) destinationBytesPer Row:*((void *)v406 + 12) destinationBytesPerImage:*((void *)v406 + 13) options:*((void *)v406 + 14)];
        goto LABEL_1040;
      case -16208:
        v411 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)v411]);
        objc_msgSend(v12, "didModifyRange:", *((void *)v411 + 1), *((void *)v411 + 2));
        break;
      case -16200:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        GTTraceFunc_argumentBytesWithMap(a2, v235[24], v4);
        v412 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineDescriptorMap]);
        MTLComputePipelineDescriptor = _MakeMTLComputePipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptor);

        v1668 = 0LL;
        v225 = [v60 newComputePipelineStateWithDescriptor:v204 error:&v1668];
        v236 = v1668;
        goto LABEL_331;
      case -16199:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        GTTraceFunc_argumentBytesWithMap(a2, v235[32], v4);
        v414 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineDescriptorMap]);
        v415 = _MakeMTLComputePipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v415);

        v416 = *((void *)v235 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1666 = 0LL;
        v225 = [v60 newComputePipelineStateWithDescriptor:v204 options:v416 reflection:0 error:&v1666];
        v236 = v1666;
        goto LABEL_331;
      case -16198:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        GTTraceFunc_argumentBytesWithMap(a2, v235[24], v4);
        v417 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineDescriptorMap]);
        v418 = _MakeMTLComputePipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v418);

        v1669 = 0LL;
        v225 = [v60 newComputePipelineStateWithDescriptor:v204 error:&v1669];
        v236 = v1669;
        goto LABEL_331;
      case -16197:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        GTTraceFunc_argumentBytesWithMap(a2, v235[32], v4);
        v419 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineDescriptorMap]);
        v420 = _MakeMTLComputePipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v420);

        v421 = *((void *)v235 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1667 = 0LL;
        v225 = [v60 newComputePipelineStateWithDescriptor:v204 options:v421 reflection:0 error:&v1667];
        v236 = v1667;
        goto LABEL_331;
      case -16196:
        v365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v365]);
        v422 = GTMTLSMContext_lastObject(**(void **)(*(void *)a1 + 40LL), *((void *)v365 + 1), *a2);
        if ((g_enableIndexedResourceType & 1) == 0) {
          goto LABEL_670;
        }
        v423 = v422;
        if (!*(void *)(v422 + 176)) {
          goto LABEL_670;
        }
        v424 = DEVICEOBJECT(v12);
        v425 = (void *)objc_claimAutoreleasedReturnValue(v424);
        v426 = objc_opt_respondsToSelector( v425,  "newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:");

        if ((v426 & 1) == 0) {
          goto LABEL_670;
        }
        v427 = *((void *)v365 + 2);
        v428 = *((void *)v365 + 3);
        v429 = *((void *)v365 + 4);
        if (*((void *)v365 + 5) <= 1uLL) {
          v430 = 1LL;
        }
        else {
          v430 = *((void *)v365 + 5);
        }
        v431 = *((void *)v365 + 6);
        if (*((void *)v365 + 7) <= 1uLL) {
          v432 = 1LL;
        }
        else {
          v432 = *((void *)v365 + 7);
        }
        v433 = *(void *)(v423 + 176);
        goto LABEL_669;
      case -16165:
        v434 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v435 = (unsigned int *)GTTraceFunc_argumentBytesWithMap(a2, v434[16], v4);
        MTLCommandQueueDescriptor = MakeMTLCommandQueueDescriptor(v435);
        v12 = (void *)objc_claimAutoreleasedReturnValue(MTLCommandQueueDescriptor);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 defaultCommandQueue]);
        v19 = *((void *)v434 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setCommandQueue:v18 forKey:v19];
        goto LABEL_1064;
      case -16163:
        v437 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v437]);
        v438 = GTTraceFunc_argumentBytesWithMap(a2, v437[16], v4);
        v439 = _MakeIOSurface((uint64_t)v438, v5);
        v108 = (id)objc_claimAutoreleasedReturnValue(v439);
        v440 = [v106 newBufferWithIOSurface:v108];
        goto LABEL_814;
      case -16162:
        v441 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v442 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v441]);
        goto LABEL_274;
      case -16161:
        v443 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v444 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v443]);
        goto LABEL_276;
      case -16160:
        v445 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v446 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v445]);
        goto LABEL_278;
      case -16159:
        v441 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v442 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v441]);
LABEL_274:
        v12 = v442;
        [v442 setColorStoreAction:*((void *)v441 + 1) atIndex:*((void *)v441 + 2)];
        break;
      case -16158:
        v443 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v444 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v443]);
LABEL_276:
        v12 = v444;
        [v444 setDepthStoreAction:*((void *)v443 + 1)];
        break;
      case -16157:
        v445 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v446 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v445]);
LABEL_278:
        v12 = v446;
        [v446 setStencilStoreAction:*((void *)v445 + 1)];
        break;
      case -16156:
        v447 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v447]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v447 + 1)]);
        [v12 setColorResolveTexture:v18 slice:*((void *)v447 + 2) depthPlane:*((void *)v447 + 3) level:*((void *)v447 + 4) atIndex:*((void *)v447 + 5)];
        goto LABEL_1064;
      case -16155:
        v448 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v448]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v448 + 1)]);
        [v12 setDepthResolveTexture:v18 slice:*((void *)v448 + 2) depthPlane:*((void *)v448 + 3) level:*((void *)v448 + 4)];
        goto LABEL_1064;
      case -16149:
        v449 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v449]);
        [v12 setImageblockWidth:*((void *)v449 + 1) height:*((void *)v449 + 2)];
        break;
      case -16148:
        v450 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v450]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v450 + 1)]);
        [v12 setTessellationFactorBuffer:v18 offset:*((void *)v450 + 2) instanceStride:*((void *)v450 + 3)];
        goto LABEL_1064;
      case -16147:
        v451 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v451]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v451 + 4)]);
        [v12 drawPatches:*((void *)v451 + 1) patchStart:*((void *)v451 + 2) patchCount:*((void *)v451 + 3) patchIndexBuffer:v18 patchIndexBufferOffset:*((void *)v451 + 5) instanceCount:*((void *)v451 + 6) baseInstance:*((void *)v451 + 7)];
        goto LABEL_1064;
      case -16146:
        v452 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v452]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v452 + 2)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v452 + 4)]);
        [v12 drawPatches:*((void *)v452 + 1) patchIndexBuffer:v18 patchIndexBufferOffset:*((void *)v452 + 3) indirectBuffer:v93 indirectBufferOffset:*((void *)v452 + 5)];
        goto LABEL_1063;
      case -16145:
        v453 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v453]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v453 + 4)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v453 + 6)]);
        [v12 drawIndexedPatches:*((void *)v453 + 1) patchStart:*((void *)v453 + 2) patchCount:*((void *)v453 + 3) patchIndexBuffer:v18 patchIndexBufferOffset:*((void *)v453 + 5) controlPointIndexBuffer:v93 contr olPointIndexBufferOffset:*((void *)v453 + 7) instanceCount:*((void *)v453 + 8) baseInstance:*((void *)v453 + 9)];
        goto LABEL_1063;
      case -16144:
        v454 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v454]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v454 + 2)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v454 + 4)]);
        v455 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v454 + 6)]);
        [v12 drawIndexedPatches:*((void *)v454 + 1) patchIndexBuffer:v18 patchIndexBufferOffset:*((void *)v454 + 3) controlPointIndexBuffer:v93 controlPointIndexBufferOffs et:*((void *)v454 + 5) indirectBuffer:v455 indirectBufferOffset:*((void *)v454 + 7)];

        goto LABEL_1063;
      case -16143:
        v456 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v456]);
        objc_msgSend( v56,  "setTileBytes:length:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v456[24], v4),  *((void *)v456 + 1),  *((void *)v456 + 2));
        goto LABEL_1090;
      case -16142:
        v457 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v457]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v457 + 1)]);
        [v12 setTileBuffer:v18 offset:*((void *)v457 + 2) atIndex:*((void *)v457 + 3)];
        goto LABEL_1064;
      case -16141:
        v458 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v458]);
        [v12 setTileBufferOffset:*((void *)v458 + 1) atIndex:*((void *)v458 + 2)];
        break;
      case -16140:
        v459 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v459]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v459 + 1)]);
        [v12 setTileTexture:v18 atIndex:*((void *)v459 + 2)];
        goto LABEL_1064;
      case -16139:
        v460 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v460]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v460 + 1)]);
        [v12 setTileSamplerState:v18 atIndex:*((void *)v460 + 2)];
        goto LABEL_1064;
      case -16138:
        v461 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v461]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v461 + 1)]);
        LODWORD(v462) = *((_DWORD *)v461 + 6);
        LODWORD(v463) = *((_DWORD *)v461 + 7);
        [v12 setTileSamplerState:v18 lodMinClamp:*((void *)v461 + 2) lodMaxClamp:v462 atIndex:v463];
        goto LABEL_1064;
      case -16137:
        v464 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v464]);
        v465 = *((void *)v464 + 3);
        v1613 = *(_OWORD *)(v464 + 8);
        v1614 = v465;
        [v12 dispatchThreadsPerTile:&v1613];
        break;
      case -16136:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 fenceForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16132:
        v466 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v466]);
        LODWORD(v467) = *((_DWORD *)v466 + 2);
        [v12 setTessellationFactorScale:v467];
        break;
      case -16131:
        v468 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v469 = objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v468]);
        goto LABEL_739;
      case -16130:
        v470 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v471 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v470]);
        goto LABEL_721;
      case -16129:
        v468 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v469 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v468]);
        goto LABEL_739;
      case -16128:
        v472 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v472]);
        v18 = [v12 newFence];
        v19 = *((void *)v472 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setFence:v18 forKey:v19];
        goto LABEL_1064;
      case -16127:
        objc_msgSend( v5,  "removeFenceForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16126:
        v473 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v473]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 fenceForKey:*((void *)v473 + 1)]);
        [v12 updateFence:v18 afterStages:*((void *)v473 + 2)];
        goto LABEL_1064;
      case -16125:
        v474 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v474]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 fenceForKey:*((void *)v474 + 1)]);
        [v12 waitForFence:v18 beforeStages:*((void *)v474 + 2)];
        goto LABEL_1064;
      case -16124:
        v470 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v471 = objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v470]);
        goto LABEL_721;
      case -16123:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 functionForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16122:
        v475 = objc_msgSend( v5,  "bufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v476 = (void *)objc_claimAutoreleasedReturnValue(v475);
        goto LABEL_698;
      case -16120:
        v477 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v477]);
        v478 = GTTraceFunc_argumentBytesWithMap(a2, v477[16], v4);
        MTLHeapDescriptor = MakeMTLHeapDescriptor((uint64_t)v478);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLHeapDescriptor);
        v480 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v477 + 1), *a2);
        if (v480)
        {
          v481 = v480;
          v482 = [v108 size];
          v483 = (id)*((unsigned int *)v481 + 19);
          if (v482 >= v483) {
            v483 = [v108 size];
          }
          [v108 setSize:v483];
        }

        v121 = [v106 newHeapWithDescriptor:v108];
        if ([v121 type] != (char *)&dword_0 + 2)
        {
          v484 = MTLHeap_backbuffer(v121);
          v485 = (void *)objc_claimAutoreleasedReturnValue(v484);
          [v5 setBuffer:v485 forHeapKey:*((void *)v477 + 1)];
        }

        v123 = *((void *)v477 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setHeap:v121 forKey:v123];
        goto LABEL_1304;
      case -16119:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16118:
        v486 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        [v5 removeHeapForKey:*(void *)v486];
        [v5 removeBufferForHeapKey:*(void *)v486];
        goto LABEL_1430;
      case -16117:
        v184 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v185 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v184]);
LABEL_318:
        v12 = v185;
        if ((dword_5B9DE4 & 0x40000) != 0) {
          v487 = *((void *)v184 + 3) & 0xFFFFFFFFFFFFFCFFLL;
        }
        else {
          v487 = *((void *)v184 + 3);
        }
        v488 = [v185 newBufferWithLength:*((void *)v184 + 2) options:v487];
        goto LABEL_648;
      case -16116:
        v105 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v105]);
        v193 = v105[16];
LABEL_323:
        GTTraceFunc_argumentBytesWithMap(a2, v193, v4);
        v489 = _MakeMTLTextureDescriptor();
        v108 = (id)objc_claimAutoreleasedReturnValue(v489);
        v109 = [v106 newTextureWithDescriptor:v108];
        goto LABEL_463;
      case -16114:
        v490 = objc_msgSend( v5,  "textureForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v476 = (void *)objc_claimAutoreleasedReturnValue(v490);
        goto LABEL_698;
      case -16107:
        v491 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v491]);
        v492 = GTTraceFunc_argumentBytesWithMap(a2, v491[25], v4);
        MTLFunctionConstantValues = MakeMTLFunctionConstantValues(v492);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
        v494 = v491[24];
        if (v491[24])
        {
          v495 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v491[24], v4));
          v496 = (void *)objc_claimAutoreleasedReturnValue(v495);
        }

        else
        {
          v496 = 0LL;
        }

        v1621 = 0LL;
        v225 = [v60 newFunctionWithName:v496 constantValues:v204 error:&v1621];
        v1504 = v1621;
        goto LABEL_1235;
      case -16106:
        v491 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v491]);
        v497 = GTTraceFunc_argumentBytesWithMap(a2, v491[25], v4);
        v498 = MakeMTLFunctionConstantValues(v497);
        v204 = (id)objc_claimAutoreleasedReturnValue(v498);
        v494 = v491[24];
        if (v491[24])
        {
          v499 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v491[24], v4));
          v496 = (void *)objc_claimAutoreleasedReturnValue(v499);
        }

        else
        {
          v496 = 0LL;
        }

        v1622 = 0LL;
        v225 = [v60 newFunctionWithName:v496 constantValues:v204 error:&v1622];
        v1504 = v1622;
LABEL_1235:
        v6 = v1504;
        if (v494) {

        }
        goto LABEL_1237;
      case -16105:
        v500 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v500]);
        [v12 maxAvailableSizeWithAlignment:*((void *)v500 + 2)];
        break;
      case -16101:
        v235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v501 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v235]);
        v502 = GTTraceFunc_argumentBytesWithMap(a2, v235[24], v4);
        v503 = (uint64_t *)(v502 + 8);
        v504 = *(_DWORD *)v502;
        v505 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v506 = v504;
        v60 = v501;
        NSArray = MakeNSArray(v503, v506, v505);
        v204 = (id)objc_claimAutoreleasedReturnValue(NSArray);

        v508 = GTTraceFunc_argumentBytesWithMap(a2, v235[25], v4);
        v1576 = 0LL;
        v225 = [v501 newComputePipelineStateWithImageFilterFunctionsSPI:v204 imageFilterFunctionInfo:v508 error:&v1576];
        v236 = v1576;
LABEL_331:
        v6 = v236;
        v509 = *((void *)v235 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setComputePipelineState:v225 forKey:v509];
        goto LABEL_1397;
      case -16100:
        v510 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v511 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v510]);
        v12 = v511;
        v1671[0] = *(_OWORD *)(v510 + 8);
        v1671[1] = *(_OWORD *)(v510 + 24);
        v1671[2] = *(_OWORD *)(v510 + 40);
        v512 = v1671;
        goto LABEL_512;
      case -16098:
        v105 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)v105]);
        GTTraceFunc_argumentBytesWithMap(a2, v105[40], v4);
        v513 = _MakeMTLTextureDescriptor();
        v108 = (id)objc_claimAutoreleasedReturnValue(v513);
        v109 = [v106 newLinearTextureWithDescriptor:v108 offset:*((void *)v105 + 2) bytesPerRow:*((void *)v105 + 3) bytesPerImage:*((void *)v105 + 4)];
        goto LABEL_463;
      case -16096:
        v514 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v514]);
        v1562 = *(_OWORD *)v514;
        v515 = *((void *)v514 + 2);
        v1564 = 0LL;
        v1565 = 0LL;
        v1563 = v515;
        v1566 = v514[32];
        v1567[0] = 0;
        *(_DWORD *)((char *)v1567 + 3) = 0;
        v516 = MTLDevice_newBufferWithBytes_length_options(a1, a2, (uint64_t)&v1562);
        v517 = objc_claimAutoreleasedReturnValue(v516);
        v518 = [v517 contents];
        v519 = *((void *)v514 + 2);
        GTTraceFunc_argumentBytesWithMap(a2, v514[33], v4);
        v520 = _MakeMTLTextureDescriptor();
        v521 = (void *)objc_claimAutoreleasedReturnValue(v520);
        v1560[0] = _NSConcreteStackBlock;
        v1560[1] = 3221225472LL;
        v1560[2] = __GTMTLReplayController_defaultDispatchFunction_noPinning_block_invoke_4;
        v1560[3] = &unk_58EC78;
        v108 = v517;
        v1561 = v108;
        v522 = [v106 newTextureWithBytesNoCopy:v518 length:v519 descriptor:v521 deallocator:v1560];

        v523 = *((void *)v514 + 1);
        if (v522)
        {
          [v5 setTexture:v522 forKey:v523];
        }

        else if (v523)
        {
          GTMTLReplay_dispatchFailedToSet((uint64_t)a2, *((void *)v514 + 1));
        }

        goto LABEL_1428;
      case -16093:
        v524 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v524]);
        [v12 minLinearTextureAlignmentForPixelFormat:*((void *)v524 + 2)];
        break;
      case -16091:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        v525 = GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v526 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        MTLTileRenderPipelineDescriptor = _MakeMTLTileRenderPipelineDescriptor((uint64_t)v525, v526);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);

        v1645 = 0LL;
        v225 = [v60 newRenderPipelineStateWithTileDescriptor:v204 error:&v1645];
        v226 = v1645;
        goto LABEL_923;
      case -16090:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        v528 = GTTraceFunc_argumentBytesWithMap(a2, v222[32], v4);
        v529 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v530 = _MakeMTLTileRenderPipelineDescriptor((uint64_t)v528, v529);
        v204 = (id)objc_claimAutoreleasedReturnValue(v530);

        v531 = *((void *)v222 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1643 = 0LL;
        v225 = [v60 newRenderPipelineStateWithTileDescriptor:v204 options:v531 reflection:0 error:&v1643];
        v226 = v1643;
        goto LABEL_923;
      case -16089:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        v532 = GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v533 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v534 = _MakeMTLTileRenderPipelineDescriptor((uint64_t)v532, v533);
        v204 = (id)objc_claimAutoreleasedReturnValue(v534);

        v1646 = 0LL;
        v225 = [v60 newRenderPipelineStateWithTileDescriptor:v204 error:&v1646];
        v226 = v1646;
        goto LABEL_923;
      case -16088:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        v535 = GTTraceFunc_argumentBytesWithMap(a2, v222[32], v4);
        v536 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v537 = _MakeMTLTileRenderPipelineDescriptor((uint64_t)v535, v536);
        v204 = (id)objc_claimAutoreleasedReturnValue(v537);

        v538 = *((void *)v222 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1644 = 0LL;
        v225 = [v60 newRenderPipelineStateWithTileDescriptor:v204 options:v538 reflection:0 error:&v1644];
        v226 = v1644;
        goto LABEL_923;
      case -16087:
        v539 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v539]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v540 = GTTraceFunc_argumentBytesWithMap(a2, v539[24], v4);
        if (*((void *)v539 + 2))
        {
          v541 = v540;
          v542 = 0LL;
          do
          {
            v543 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v541[8 * v542]]);
            v544 = *(void **)&buf[8 * v542];
            *(void *)&buf[8 * v542] = v543;

            ++v542;
          }

          while (*((void *)v539 + 2) > v542);
        }

        objc_msgSend( v106,  "setTileBuffers:offsets:withRange:",  buf,  GTTraceFunc_argumentBytesWithMap(a2, v539[25], v4),  *((void *)v539 + 1),  *((void *)v539 + 2));
        for (i3 = 240LL; i3 != -8; i3 -= 8LL)

        goto LABEL_1429;
      case -16086:
        v546 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v546]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v547 = GTTraceFunc_argumentBytesWithMap(a2, v546[24], v4);
        if (*((void *)v546 + 2))
        {
          v548 = v547;
          v549 = 0LL;
          do
          {
            v550 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v548[8 * v549]]);
            v551 = *(void **)&buf[8 * v549];
            *(void *)&buf[8 * v549] = v550;

            ++v549;
            v552 = *((void *)v546 + 2);
          }

          while (v552 > v549);
        }

        else
        {
          v552 = 0LL;
        }

        objc_msgSend(v106, "setTileTextures:withRange:", buf, *((void *)v546 + 1), v552);
        for (i4 = 240LL; i4 != -8; i4 -= 8LL)

        goto LABEL_1429;
      case -16085:
        v553 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v553]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v554 = GTTraceFunc_argumentBytesWithMap(a2, v553[24], v4);
        if (*((void *)v553 + 2))
        {
          v555 = v554;
          v556 = 0LL;
          do
          {
            v557 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v555[8 * v556]]);
            v558 = *(void **)&buf[8 * v556];
            *(void *)&buf[8 * v556] = v557;

            ++v556;
            v559 = *((void *)v553 + 2);
          }

          while (v559 > v556);
        }

        else
        {
          v559 = 0LL;
        }

        objc_msgSend(v106, "setTileSamplerStates:withRange:", buf, *((void *)v553 + 1), v559);
        for (i5 = 120LL; i5 != -8; i5 -= 8LL)

        goto LABEL_1429;
      case -16084:
        v560 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v560]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v561 = GTTraceFunc_argumentBytesWithMap(a2, v560[24], v4);
        v562 = GTTraceFunc_argumentBytesWithMap(a2, v560[25], v4);
        v563 = GTTraceFunc_argumentBytesWithMap(a2, v560[26], v4);
        if (*((void *)v560 + 2))
        {
          v564 = 0LL;
          do
          {
            v565 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v561[8 * v564]]);
            v566 = *(void **)&buf[8 * v564];
            *(void *)&buf[8 * v564] = v565;

            ++v564;
            v567 = *((void *)v560 + 2);
          }

          while (v567 > v564);
        }

        else
        {
          v567 = 0LL;
        }

        objc_msgSend( v106,  "setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  buf,  v562,  v563,  *((void *)v560 + 1),  v567);
        for (i6 = 120LL; i6 != -8; i6 -= 8LL)

        goto LABEL_1429;
      case -16083:
        v568 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v569 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v568]);
        v106 = v569;
        if (v568[8])
        {
          v570 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v568[8], v4));
          v571 = (void *)objc_claimAutoreleasedReturnValue(v570);
          [v106 setOverrideTriple:v571];
          goto LABEL_1059;
        }

        [v569 setOverrideTriple:0];
        goto LABEL_1429;
      case -16082:
        v572 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v572]);
        v573 = v5;
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*((void *)v572 + 2)]);
        v574 = GTTraceFunc_argumentBytesWithMap(a2, v572[33], v4);
        v575 = MakeMTLFunctionConstantValues(v574);
        v576 = (void *)objc_claimAutoreleasedReturnValue(v575);
        v577 = v572[32];
        if (v572[32])
        {
          v578 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v572[32], v4));
          v579 = (void *)objc_claimAutoreleasedReturnValue(v578);
        }

        else
        {
          v579 = 0LL;
        }

        v1619 = 0LL;
        v1508 = [v60 newFunctionWithName:v579 constantValues:v576 pipelineLibrary:v204 error:&v1619];
        v1509 = v1619;
        goto LABEL_1259;
      case -16081:
        v572 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v572]);
        v573 = v5;
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*((void *)v572 + 2)]);
        v580 = GTTraceFunc_argumentBytesWithMap(a2, v572[33], v4);
        v581 = MakeMTLFunctionConstantValues(v580);
        v576 = (void *)objc_claimAutoreleasedReturnValue(v581);
        v577 = v572[32];
        if (v572[32])
        {
          v582 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v572[32], v4));
          v579 = (void *)objc_claimAutoreleasedReturnValue(v582);
        }

        else
        {
          v579 = 0LL;
        }

        v1620 = 0LL;
        v1508 = [v60 newFunctionWithName:v579 constantValues:v576 pipelineLibrary:v204 error:&v1620];
        v1509 = v1620;
LABEL_1259:
        v6 = v1509;
        if (v577) {

        }
        v1510 = *((void *)v572 + 1);
        if (v1508)
        {
          v5 = v573;
          [v573 setFunction:v1508 forKey:v1510];
        }

        else
        {
          v5 = v573;
          if (v1510) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, *((void *)v572 + 1));
          }
        }

        goto LABEL_1398;
      case -16079:
        v583 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v583]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v583 + 1)]);
        [v12 dispatchThreadsWithIndirectBuffer:v18 indirectBufferOffset:*((void *)v583 + 2)];
        goto LABEL_1064;
      case -16078:
        v584 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v584]);
        v585 = *((void *)v584 + 3);
        v1674 = *(_OWORD *)(v584 + 8);
        v1675 = v585;
        v586 = *((void *)v584 + 6);
        v1672 = *((_OWORD *)v584 + 2);
        v1673 = v586;
        [v12 dispatchThreads:&v1674 threadsPerThreadgroup:&v1672];
        break;
      case -16077:
        v587 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v587]);
        objc_msgSend( v56,  "setViewports:count:",  GTTraceFunc_argumentBytesWithMap(a2, v587[16], v4),  *((void *)v587 + 1));
        goto LABEL_1090;
      case -16076:
        v588 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v588]);
        objc_msgSend( v56,  "setScissorRects:count:",  GTTraceFunc_argumentBytesWithMap(a2, v588[16], v4),  *((void *)v588 + 1));
        goto LABEL_1090;
      case -16075:
        v589 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1556 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v589]);
        v590 = GTTraceFunc_argumentBytesWithMap(a2, v589[24], v4);
        v591 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 14), v4);
        v592 = v591;
        v1553 = v5;
        v1554 = v589;
        if (v591)
        {
          v593 = *(char **)v591;
          v594 = *((unsigned __int16 *)v591 + 12);
        }

        else
        {
          v594 = 0;
          v593 = 0LL;
        }

        v1511 = GTMTLReplayController_dumpPipelineLibrary(a1, v590, v593);
        v1555 = (void *)objc_claimAutoreleasedReturnValue(v1511);
        if (v594)
        {
          v1512 = 0LL;
          v1513 = 8LL * v594;
          v1514 = &CATransform3DIdentity_ptr;
          do
          {
            v1515 = *(char **)(*((void *)v592 + 1) + v1512);
            v1516 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D stringWithUTF8String:]( (id)v1514[288],  "stringWithUTF8String:",  *(void *)(*((void *)v592 + 2) + v1512)));
            v1517 = v1516;
            if (v593)
            {
              v1518 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D stringWithUTF8String:]((id)v1514[288], "stringWithUTF8String:", v593));
              v1519 = (void *)objc_claimAutoreleasedReturnValue([v1518 stringByDeletingLastPathComponent]);

              v1520 = (id)objc_claimAutoreleasedReturnValue([v1519 stringByAppendingPathComponent:v1517]);
            }

            else
            {
              v1520 = v1516;
            }

            v1521 = v1520;
            v1522 = GTMTLReplayController_dumpLibrary(a1, v1515, (char *)[v1521 UTF8String]);

            v1512 += 8LL;
            v1514 = &CATransform3DIdentity_ptr;
          }

          while (v1513 != v1512);
        }

        v204 = v1555;
        v1523 = (void *)objc_claimAutoreleasedReturnValue([v1555 path]);
        v1568 = 0LL;
        v60 = v1556;
        v225 = [v1556 newPipelineLibraryWithFilePath:v1523 error:&v1568];
        v6 = v1568;

        v509 = *((void *)v1554 + 1);
        if (v225)
        {
          v5 = v1553;
          [v1553 setPipelineLibrarySPI:v225 forKey:v509];
        }

        else
        {
          v5 = v1553;
LABEL_1395:
          if (v509) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v509);
          }
        }

        goto LABEL_1397;
      case -16074:
        v595 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v595]);
        [v12 setThreadgroupMemoryLength:*((void *)v595 + 1) offset:*((void *)v595 + 2) atIndex:*((void *)v595 + 3)];
        break;
      case -16063:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -16062:
        objc_msgSend( v5,  "removeArgumentEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -16061:
        v596 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v596]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v596 + 1)]);
        [v12 setArgumentBuffer:v18 offset:*((void *)v596 + 2)];
        goto LABEL_1064;
      case -16060:
        v139 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v140 = objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v139]);
LABEL_377:
        v12 = (void *)v140;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v139 + 1)]);
        [v12 setBuffer:v18 offset:*((void *)v139 + 2) atIndex:*((void *)v139 + 3)];
        goto LABEL_1064;
      case -16059:
        v597 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v597]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v598 = GTTraceFunc_argumentBytesWithMap(a2, v597[24], v4);
        v599 = GTTraceFunc_argumentBytesWithMap(a2, v597[25], v4);
        if (*((void *)v597 + 2))
        {
          v600 = 0LL;
          do
          {
            v601 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v598[8 * v600]]);
            v602 = *(void **)&buf[8 * v600];
            *(void *)&buf[8 * v600] = v601;

            ++v600;
            v603 = *((void *)v597 + 2);
          }

          while (v603 > v600);
        }

        else
        {
          v603 = 0LL;
        }

        objc_msgSend(v106, "setBuffers:offsets:withRange:", buf, v599, *((void *)v597 + 1), v603);
        for (i7 = 240LL; i7 != -8; i7 -= 8LL)

        goto LABEL_1429;
      case -16058:
        v148 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v149 = objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v148]);
LABEL_383:
        v12 = (void *)v149;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v148 + 1)]);
        [v12 setTexture:v18 atIndex:*((void *)v148 + 2)];
        goto LABEL_1064;
      case -16057:
        v604 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v604]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v605 = GTTraceFunc_argumentBytesWithMap(a2, v604[24], v4);
        if (*((void *)v604 + 2))
        {
          v606 = v605;
          v607 = 0LL;
          do
          {
            v608 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v606[8 * v607]]);
            v609 = *(void **)&buf[8 * v607];
            *(void *)&buf[8 * v607] = v608;

            ++v607;
            v610 = *((void *)v604 + 2);
          }

          while (v610 > v607);
        }

        else
        {
          v610 = 0LL;
        }

        objc_msgSend(v106, "setTextures:withRange:", buf, *((void *)v604 + 1), v610);
        for (i8 = 240LL; i8 != -8; i8 -= 8LL)

        goto LABEL_1429;
      case -16056:
        v157 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v158 = objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v157]);
LABEL_389:
        v12 = (void *)v158;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v157 + 1)]);
        [v12 setSamplerState:v18 atIndex:*((void *)v157 + 2)];
        goto LABEL_1064;
      case -16055:
        v611 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v611]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v612 = GTTraceFunc_argumentBytesWithMap(a2, v611[24], v4);
        if (*((void *)v611 + 2))
        {
          v613 = v612;
          v614 = 0LL;
          do
          {
            v615 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v613[8 * v614]]);
            v616 = *(void **)&buf[8 * v614];
            *(void *)&buf[8 * v614] = v615;

            ++v614;
            v617 = *((void *)v611 + 2);
          }

          while (v617 > v614);
        }

        else
        {
          v617 = 0LL;
        }

        objc_msgSend(v106, "setSamplerStates:withRange:", buf, *((void *)v611 + 1), v617);
        for (i9 = 120LL; i9 != -8; i9 -= 8LL)

        goto LABEL_1429;
      case -16053:
        v618 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v618]);
        v619 = [v12 newArgumentEncoderForBufferAtIndex:*((void *)v618 + 2)];
        goto LABEL_397;
      case -16052:
        v618 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 functionForKey:*(void *)v618]);
        v619 = [v12 newArgumentEncoderWithBufferIndex:*((void *)v618 + 2)];
        goto LABEL_397;
      case -16051:
        v618 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 functionForKey:*(void *)v618]);
        v619 = [v12 newArgumentEncoderWithBufferIndex:*((void *)v618 + 2) reflection:0];
LABEL_397:
        v18 = v619;
        v19 = *((void *)v618 + 1);
        if (!v619) {
          goto LABEL_1050;
        }
        [v5 setArgumentEncoder:v619 forKey:v19];
        goto LABEL_1064;
      case -16047:
        v620 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v621 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v620]);
        goto LABEL_731;
      case -16046:
        v622 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v622]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v624 = apr_palloc(v623, 8LL * *((void *)v622 + 1));
        v625 = GTTraceFunc_argumentBytesWithMap(a2, v622[24], v4);
        if (!*((void *)v622 + 1)) {
          goto LABEL_736;
        }
        v626 = v625;
        v627 = 0LL;
        do
        {
          v624[v627] = [v5 resourceForKey:*(void *)&v626[8 * v627]];
          ++v627;
          v628 = *((void *)v622 + 1);
        }

        while (v628 > v627);
        goto LABEL_737;
      case -16045:
        v629 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v630 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v629]);
        goto LABEL_723;
      case -16044:
        v631 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v631]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v633 = apr_palloc(v632, 8LL * *((void *)v631 + 1));
        v634 = GTTraceFunc_argumentBytesWithMap(a2, v631[16], v4);
        if (!*((void *)v631 + 1)) {
          goto LABEL_728;
        }
        v635 = v634;
        v636 = 0LL;
        do
        {
          v633[v636] = [v5 heapForKey:*(void *)&v635[8 * v636]];
          ++v636;
          v637 = *((void *)v631 + 1);
        }

        while (v637 > v636);
        goto LABEL_729;
      case -16043:
        v620 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v621 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v620]);
        goto LABEL_731;
      case -16042:
        v622 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v622]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v624 = apr_palloc(v623, 8LL * *((void *)v622 + 1));
        v638 = GTTraceFunc_argumentBytesWithMap(a2, v622[24], v4);
        if (!*((void *)v622 + 1)) {
          goto LABEL_736;
        }
        v639 = v638;
        v640 = 0LL;
        do
        {
          v624[v640] = [v5 resourceForKey:*(void *)&v639[8 * v640]];
          ++v640;
          v628 = *((void *)v622 + 1);
        }

        while (v628 > v640);
        goto LABEL_737;
      case -16041:
        v629 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v630 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v629]);
        goto LABEL_723;
      case -16040:
        v641 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v641]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v633 = apr_palloc(v632, 8LL * *((void *)v641 + 1));
        v642 = GTTraceFunc_argumentBytesWithMap(a2, v641[16], v4);
        if (!*((void *)v641 + 1)) {
          goto LABEL_728;
        }
        v643 = v642;
        v644 = 0LL;
        do
        {
          v633[v644] = [v5 heapForKey:*(void *)&v643[8 * v644]];
          ++v644;
          v637 = *((void *)v641 + 1);
        }

        while (v637 > v644);
        goto LABEL_729;
      case -16039:
        v198 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v198]);
        v645 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 14), v4);
        v646 = GTTraceFunc_argumentBytesWithMap(a2, v198[24], v4);
        v647 = *(char **)v645;
        v648 = *((void *)v198 + 1);
        v1572 = 0LL;
        v649 = NewLibraryWithFile(v60, a1, v646, v647, 1, v648, &v1572);
        v204 = (id)objc_claimAutoreleasedReturnValue(v649);
        v205 = v1572;
LABEL_1192:
        v6 = v205;
LABEL_1193:
        v1494 = *((void *)v198 + 1);
        if (!v204) {
          goto LABEL_1324;
        }
        [v5 setLibrary:v204 forKey:v1494];
        goto LABEL_1398;
      case -16038:
        v248 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v650 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v248]);
        v106 = v650;
        if (v248[16])
        {
          v651 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v248[16], v4));
          v251 = (void *)objc_claimAutoreleasedReturnValue(v651);
          v252 = [v106 newExternFunctionWithName:v251];
LABEL_422:
          v108 = v252;
        }

        else
        {
          v1495 = [v650 newExternFunctionWithName:0];
LABEL_1288:
          v108 = v1495;
        }

        v868 = *((void *)v248 + 1);
        if (!v108) {
          goto LABEL_1437;
        }
LABEL_1290:
        [v5 setFunction:v108 forKey:v868];
        goto LABEL_1428;
      case -16033:
        v652 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v652]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v652 + 1)]);
        [v12 setArgumentBuffer:v18 startOffset:*((void *)v652 + 2) arrayElement:*((void *)v652 + 3)];
        goto LABEL_1064;
      case -16028:
        v653 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v654 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v653]);
        goto LABEL_428;
      case -16027:
        v655 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v656 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v655]);
        goto LABEL_430;
      case -16026:
        v657 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v658 = (void *)objc_claimAutoreleasedReturnValue([v5 parallelRenderCommandEncoderForKey:*(void *)v657]);
        goto LABEL_432;
      case -16022:
        v653 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v654 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v653]);
LABEL_428:
        v12 = v654;
        [v654 setColorStoreActionOptions:*((void *)v653 + 1) atIndex:*((void *)v653 + 2)];
        break;
      case -16021:
        v655 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v656 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v655]);
LABEL_430:
        v12 = v656;
        [v656 setDepthStoreActionOptions:*((void *)v655 + 1)];
        break;
      case -16020:
        v657 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v658 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v657]);
LABEL_432:
        v12 = v658;
        [v658 setStencilStoreActionOptions:*((void *)v657 + 1)];
        break;
      case -16017:
        v659 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v659]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v659 + 1)]);
        [v12 setStageInRegionWithIndirectBuffer:v18 indirectBufferOffset:*((void *)v659 + 2)];
        goto LABEL_1064;
      case -16014:
        v124 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v124]);
        v125 = objc_claimAutoreleasedReturnValue([v12 computeCommandEncoderWithDispatchType:*((void *)v124 + 2)]);
        goto LABEL_632;
      case -16009:
        v660 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v660]);
        [v12 memoryBarrierWithScope:*((void *)v660 + 1)];
        break;
      case -16008:
        v661 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v661]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v662 = apr_palloc(v632, 8LL * *((void *)v661 + 1));
        v663 = GTTraceFunc_argumentBytesWithMap(a2, v661[16], v4);
        if (*((void *)v661 + 1))
        {
          v664 = v663;
          v665 = 0LL;
          do
          {
            v662[v665] = [v5 resourceForKey:*(void *)&v664[8 * v665]];
            ++v665;
            v666 = *((void *)v661 + 1);
          }

          while (v666 > v665);
        }

        else
        {
          v666 = 0LL;
        }

        [v106 memoryBarrierWithResources:v662 count:v666];
        goto LABEL_1389;
      case -16004:
        v667 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v668 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v667]);
        v14 = v668;
        v669 = *((void *)v667 + 1);
        if ((dword_5B9DE4 & 0x20000) == 0 || (v669 & 4) == 0) {
          [v668 memoryBarrierWithScope:v669 afterStages:*((void *)v667 + 2) beforeStages:*((void *)v667 + 3)];
        }
        goto LABEL_1041;
      case -16003:
        v670 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v670]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v671 = apr_palloc(v623, 8LL * *((void *)v670 + 1));
        v672 = GTTraceFunc_argumentBytesWithMap(a2, v670[32], v4);
        if (*((void *)v670 + 1))
        {
          v673 = v672;
          v674 = 0LL;
          do
          {
            v671[v674] = [v5 resourceForKey:*(void *)&v673[8 * v674]];
            ++v674;
            v675 = *((void *)v670 + 1);
          }

          while (v675 > v674);
        }

        else
        {
          v675 = 0LL;
        }

        [v106 memoryBarrierWithResources:v671 count:v675 afterStages:*((void *)v670 + 2) beforeStages:*((void *)v670 + 3)];
        goto LABEL_1352;
      case -16002:
        v676 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v676]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*((void *)v676 + 1)]);
        [v12 setRenderPipelineState:v18 atIndex:*((void *)v676 + 2)];
        goto LABEL_1064;
      case -16001:
        v677 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v677]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v678 = apr_palloc(v623, 8LL * *((void *)v677 + 2));
        v679 = GTTraceFunc_argumentBytesWithMap(a2, v677[24], v4);
        if (*((void *)v677 + 2))
        {
          v680 = v679;
          v681 = 0LL;
          do
          {
            v678[v681] = [v5 renderPipelineStateForKey:*(void *)&v680[8 * v681]];
            ++v681;
            v682 = *((void *)v677 + 2);
          }

          while (v682 > v681);
        }

        else
        {
          v682 = 0LL;
        }

        objc_msgSend(v106, "setRenderPipelineStates:withRange:", v678, *((void *)v677 + 1), v682);
        goto LABEL_1352;
      case -15997:
        v683 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v683]);
        v18 = [v12 newEvent];
        v19 = *((void *)v683 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setEvent:v18 forKey:v19];
        goto LABEL_1064;
      case -15996:
      case -15912:
        v23 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v23]);
        v18 = [v12 newSharedEvent];
        v19 = *((void *)v23 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setSharedEvent:v18 forKey:v19];
        goto LABEL_1064;
      case -15995:
        v684 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v684]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v684 + 1)]);
        [v12 optimizeContentsForGPUAccess:v33];
        goto LABEL_1131;
      case -15994:
        v685 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v685]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v685 + 1)]);
        [v12 optimizeContentsForGPUAccess:v18 slice:*((void *)v685 + 2) level:*((void *)v685 + 3)];
        goto LABEL_1064;
      case -15993:
        v686 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v686]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v686 + 1)]);
        [v12 optimizeContentsForCPUAccess:v33];
        goto LABEL_1131;
      case -15992:
        v687 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v687]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v687 + 1)]);
        [v12 optimizeContentsForCPUAccess:v18 slice:*((void *)v687 + 2) level:*((void *)v687 + 3)];
        goto LABEL_1064;
      case -15991:
        v688 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v688]);
        v689 = objc_claimAutoreleasedReturnValue([v5 eventForKey:*((void *)v688 + 1)]);
        goto LABEL_1019;
      case -15990:
        v690 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v690]);
        v691 = objc_claimAutoreleasedReturnValue([v5 eventForKey:*((void *)v690 + 1)]);
        goto LABEL_1017;
      case -15988:
        v692 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v692]);
        LODWORD(v693) = *((_DWORD *)v692 + 2);
        [v12 setPointSize:v693];
        break;
      case -15984:
        v694 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v694]);
        [v12 setPrimitiveRestartEnabled:*((_DWORD *)v694 + 4) != 0 index:*((void *)v694 + 1)];
        break;
      case -15980:
        v105 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v105]);
        GTTraceFunc_argumentBytesWithMap(a2, v105[24], v4);
        v695 = _MakeMTLTextureDescriptor();
        v108 = (id)objc_claimAutoreleasedReturnValue(v695);
        v109 = [v106 newSharedTextureWithDescriptor:v108];
LABEL_463:
        v191 = v109;
        v192 = *((void *)v105 + 1);
        if (!v109) {
          goto LABEL_1425;
        }
        [v5 setTexture:v109 forKey:v192];
        goto LABEL_1427;
      case -15977:
        v696 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v696]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v696 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v696 + 10)]);
        v697 = *((_OWORD *)v696 + 2);
        v1683[0] = *((_OWORD *)v696 + 1);
        v1683[1] = v697;
        v1683[2] = *((_OWORD *)v696 + 3);
        [v12 getTextureAccessCounters:v18 region:v1683 mipLevel:*((void *)v696 + 8) slice:*((void *)v696 + 9) resetCounters:*((_DWORD *)v696 + 24) != 0 countersBuffer:v93 countersBufferOffset:*((void *)v696 + 11)];
        goto LABEL_1063;
      case -15976:
        v698 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v698]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v698 + 1)]);
        v699 = *((_OWORD *)v698 + 2);
        v1682[0] = *((_OWORD *)v698 + 1);
        v1682[1] = v699;
        v1682[2] = *((_OWORD *)v698 + 3);
        [v12 resetTextureAccessCounters:v18 region:v1682 mipLevel:*((void *)v698 + 8) slice:*((void *)v698 + 9)];
        goto LABEL_1064;
      case -15975:
        v700 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v701 = (void *)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*(void *)v700]);
        goto LABEL_828;
      case -15974:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15973:
        objc_msgSend( v5,  "removeSharedEventForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15972:
        v437 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v437]);
        v702 = (uint64_t (*)(void))MakeMTLIndirectCommandBufferDescriptor;
        v703 = GTTraceFunc_argumentBytesWithMap(a2, v437[32], v4);
        v704 = v702(v703);
        v108 = (id)objc_claimAutoreleasedReturnValue(v704);
        if ((dword_5B9DE4 & 0x40000) != 0) {
          v705 = *((void *)v437 + 3) & 0xFFFFFFFFFFFFFCFFLL;
        }
        else {
          v705 = *((void *)v437 + 3);
        }
        v440 = [v106 newIndirectCommandBufferWithDescriptor:v108 maxCount:*((void *)v437 + 2) options:v705];
        goto LABEL_814;
      case -15970:
        v706 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v706]);
        [v12 setPrimitiveRestartEnabled:*((_DWORD *)v706 + 2) != 0];
        break;
      case -15969:
        v707 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v707]);
        v708 = (uint64_t (*)(void))MakeMTLIndirectCommandBufferDescriptor;
        v709 = GTTraceFunc_argumentBytesWithMap(a2, v707[32], v4);
        v710 = v708(v709);
        v108 = (id)objc_claimAutoreleasedReturnValue(v710);
        if ((dword_5B9DE4 & 0x40000) != 0) {
          v711 = *((void *)v707 + 3) & 0xFFFFFFFFFFFFFCFFLL;
        }
        else {
          v711 = *((void *)v707 + 3);
        }
        v191 = [v106 newIndirectCommandBufferWithDescriptor:v108 maxCommandCount:*((void *)v707 + 2) options:v711];
        v192 = *((void *)v707 + 1);
        if (!v191) {
          goto LABEL_1425;
        }
        [v5 setIndirectCommandBuffer:v191 forKey:v192];
        goto LABEL_1427;
      case -15967:
        v712 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v712]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceForKey:*((void *)v712 + 1)]);
        [v12 addPurgedResource:v33];
        goto LABEL_1131;
      case -15966:
        v713 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v713]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*((void *)v713 + 1)]);
        [v12 addPurgedHeap:v33];
        goto LABEL_1131;
      case -15964:
        v714 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v715 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v714]);
        goto LABEL_485;
      case -15963:
        v716 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v717 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v716]);
        goto LABEL_487;
      case -15962:
        v714 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v715 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v714]);
LABEL_485:
        v12 = (void *)v715;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v714 + 1)]);
        objc_msgSend(v12, "executeCommandsInBuffer:withRange:", v18, *((void *)v714 + 2), *((void *)v714 + 3));
        goto LABEL_1064;
      case -15961:
        v716 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v717 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v716]);
LABEL_487:
        v12 = (void *)v717;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v716 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v716 + 2)]);
        [v12 executeCommandsInBuffer:v18 indirectBuffer:v93 indirectBufferOffset:*((void *)v716 + 3)];
        goto LABEL_1063;
      case -15960:
        v718 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v718]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v718 + 1)]);
        objc_msgSend(v12, "resetCommandsInBuffer:withRange:", v18, *((void *)v718 + 2), *((void *)v718 + 3));
        goto LABEL_1064;
      case -15959:
        v719 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v719]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v719 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v719 + 4)]);
        objc_msgSend( v12,  "copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:",  v18,  *((void *)v719 + 2),  *((void *)v719 + 3),  v93,  *((void *)v719 + 5));
        goto LABEL_1063;
      case -15958:
        v720 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v720]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v720 + 1)]);
        objc_msgSend(v12, "optimizeIndirectCommandBuffer:withRange:", v18, *((void *)v720 + 2), *((void *)v720 + 3));
        goto LABEL_1064;
      case -15957:
        objc_msgSend( v5,  "removeIndirectRenderCommandForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15956:
        v260 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v261 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v260]);
LABEL_493:
        v12 = (void *)v261;
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*((void *)v260 + 1)]);
        [v12 setRenderPipelineState:v33];
        goto LABEL_1131;
      case -15955:
        v262 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v263 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v262]);
LABEL_495:
        v12 = (void *)v263;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v262 + 1)]);
        [v12 setVertexBuffer:v18 offset:*((void *)v262 + 2) atIndex:*((void *)v262 + 3)];
        goto LABEL_1064;
      case -15954:
        v311 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v312 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v311]);
LABEL_497:
        v12 = (void *)v312;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v311 + 1)]);
        [v12 setFragmentBuffer:v18 offset:*((void *)v311 + 2) atIndex:*((void *)v311 + 3)];
        goto LABEL_1064;
      case -15952:
        v721 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v721]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v721 + 4)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v721 + 8)]);
        [v12 drawPatches:*((void *)v721 + 1) patchStart:*((void *)v721 + 2) patchCount:*((void *)v721 + 3) patchIndexBuffer:v18 patchIndexBufferOffset:*((void *)v721 + 5) instanceCount:*((void *)v721 + 6) baseInstance:*((void *)v721 + 7) tessellat ionFactorBuffer:v93 tessellationFactorBufferOffset:*((void *)v721 + 9) tessellationFactorBufferInstanceStride:*((void *)v721 + 10)];
        goto LABEL_1063;
      case -15950:
        v722 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v722]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v722 + 4)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v722 + 6)]);
        v723 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v722 + 10)]);
        [v14 drawIndexedPatches:*((void *)v722 + 1) patchStart:*((void *)v722 + 2) patchCount:*((void *)v722 + 3) patchIndexBuffer:v75 patchIndexBufferOffset:*((void *)v722 + 5) controlPointIndexBuffer:v76 contr olPointIndexBufferOffset:*((void *)v722 + 7) instanceCount:*((void *)v722 + 8) baseInstance:*((void *)v722 + 9) tessellationFactorBuffer:v723 tessellationFactorBufferOffset:*((void *)v722 + 11) te ssellationFactorBufferInstanceStride:*((void *)v722 + 12)];

        goto LABEL_1040;
      case -15949:
        v383 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v384 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v383]);
LABEL_501:
        v12 = v384;
        [v384 drawPrimitives:*((void *)v383 + 1) vertexStart:*((void *)v383 + 2) vertexCount:*((void *)v383 + 3) instanceCount:*((void *)v383 + 4) baseInstance:*((void *)v383 + 5)];
        break;
      case -15948:
        v385 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v386 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v385]);
LABEL_503:
        v12 = (void *)v386;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v385 + 4)]);
        [v12 drawIndexedPrimitives:*((void *)v385 + 1) indexCount:*((void *)v385 + 2) indexType:*((void *)v385 + 3) indexBuffer:v18 indexBufferOffset:*((void *)v385 + 5) instanceCount:*((void *)v385 + 6) baseVertex:*((void *)v385 + 7) baseInstance:*((void *)v385 + 8)];
        goto LABEL_1064;
      case -15935:
        objc_msgSend( v5,  "removeIndirectComputeCommandForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15934:
        v137 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v138 = objc_claimAutoreleasedReturnValue([v5 indirectComputeCommandForKey:*(void *)v137]);
LABEL_506:
        v12 = (void *)v138;
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineStateForKey:*((void *)v137 + 1)]);
        [v12 setComputePipelineState:v33];
        goto LABEL_1131;
      case -15933:
        v724 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectComputeCommandForKey:*(void *)v724]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v724 + 1)]);
        [v12 setKernelBuffer:v18 offset:*((void *)v724 + 2) atIndex:*((void *)v724 + 3)];
        goto LABEL_1064;
      case -15931:
        v725 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectComputeCommandForKey:*(void *)v725]);
        v726 = *((void *)v725 + 3);
        v1640 = *(_OWORD *)(v725 + 8);
        v1641 = v726;
        v727 = *((void *)v725 + 6);
        v1638 = *((_OWORD *)v725 + 2);
        v1639 = v727;
        [v12 concurrentDispatchThreadgroups:&v1640 threadsPerThreadgroup:&v1638];
        break;
      case -15927:
        v177 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v178 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectComputeCommandForKey:*(void *)v177]);
LABEL_510:
        v12 = v178;
        [v178 setThreadgroupMemoryLength:*((void *)v177 + 1) atIndex:*((void *)v177 + 2)];
        break;
      case -15926:
        v728 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v511 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectComputeCommandForKey:*(void *)v728]);
        v12 = v511;
        v1637[0] = *(_OWORD *)(v728 + 8);
        v1637[1] = *(_OWORD *)(v728 + 24);
        v1637[2] = *(_OWORD *)(v728 + 40);
        v512 = v1637;
LABEL_512:
        [v511 setStageInRegion:v512];
        break;
      case -15925:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15924:
        v729 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*(void *)v729]);
        [v12 setResponsibleProcess:*((unsigned int *)v729 + 2)];
        break;
      case -15923:
        objc_msgSend( v5,  "removeIndirectCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15922:
        v730 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*(void *)v730]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 indirectRenderCommandAtIndex:*((void *)v730 + 2)]);
        v19 = *((void *)v730 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setIndirectRenderCommand:v18 forKey:v19];
        goto LABEL_1064;
      case -15921:
        v731 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*(void *)v731]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 indirectComputeCommandAtIndex:*((void *)v731 + 2)]);
        v19 = *((void *)v731 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setIndirectComputeCommand:v18 forKey:v19];
        goto LABEL_1064;
      case -15919:
        v732 = objc_msgSend( v5,  "indirectCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v476 = (void *)objc_claimAutoreleasedReturnValue(v732);
        goto LABEL_698;
      case -15916:
        v733 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v733]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*((void *)v733 + 1)]);
        [v12 setIndirectCommandBuffer:v18 atIndex:*((void *)v733 + 2)];
        goto LABEL_1064;
      case -15915:
        v734 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v734]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v735 = apr_palloc(v623, 8LL * *((void *)v734 + 2));
        v736 = GTTraceFunc_argumentBytesWithMap(a2, v734[24], v4);
        if (*((void *)v734 + 2))
        {
          v737 = v736;
          v738 = 0LL;
          do
          {
            v735[v738] = [v5 indirectCommandBufferForKey:*(void *)&v737[8 * v738]];
            ++v738;
            v739 = *((void *)v734 + 2);
          }

          while (v739 > v738);
        }

        else
        {
          v739 = 0LL;
        }

        objc_msgSend(v106, "setIndirectCommandBuffers:withRange:", v735, *((void *)v734 + 1), v739);
        goto LABEL_1352;
      case -15910:
        v740 = objc_msgSend( v5,  "textureForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v740);
        v741 = [v14 newSharedTextureHandle];
        goto LABEL_831;
      case -15909:
        v742 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v742]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 sharedEventHandleForKey:*((void *)v742 + 2)]);
        v93 = [v12 newSharedEventWithHandle:v18];
        v743 = *((void *)v742 + 1);
        if (!v93) {
          goto LABEL_990;
        }
        [v5 setSharedEvent:v93 forKey:v743];
        goto LABEL_1063;
      case -15908:
      case -15316:
        v22 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v22]);
        [v5 removeCommandBufferForKey:*(void *)v22];
        [(id)g_activityLog logCommandBuffer:v12 atIndex:*(unsigned int *)(a1 + 22480)];
        GTMTLReplay_commitCommandBufferAndWaitUntilSubmitted(v12);
        break;
      case -15907:
        v744 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*(void *)v744]);
        v18 = [v12 newSharedEventHandle];
        v19 = *((void *)v744 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setSharedEventHandle:v18 forKey:v19];
        goto LABEL_1064;
      case -15906:
        v745 = objc_msgSend( v5,  "indirectRenderCommandForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v746 = (void *)objc_claimAutoreleasedReturnValue(v745);
        goto LABEL_533;
      case -15905:
        v747 = objc_msgSend( v5,  "indirectComputeCommandForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v746 = (void *)objc_claimAutoreleasedReturnValue(v747);
LABEL_533:
        v14 = v746;
        [v746 reset];
        goto LABEL_1041;
      case -15896:
        v748 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectCommandBufferForKey:*(void *)v748]);
        objc_msgSend(v12, "resetWithRange:", *((void *)v748 + 1), *((void *)v748 + 2));
        break;
      case -15880:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 eventForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15879:
        objc_msgSend( v5,  "removeEventForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15878:
        v749 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v749]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v749 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v749 + 4)]);
        [v12 copyFromTexture:v18 sourceSlice:*((void *)v749 + 2) sourceLevel:*((void *)v749 + 3) toTexture:v93 destinationSlice:*((void *)v749 + 5) destinationLevel:*((void *)v749 + 6) sliceCount:*((void *)v749 + 7) levelCount:*((void *)v749 + 8)];
        goto LABEL_1063;
      case -15877:
        v750 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v750]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v750 + 1)]);
        v751 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v750 + 2)]);
        [v12 copyFromTexture:v18 toTexture:v751];
        goto LABEL_704;
      case -15870:
        v752 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v752]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 resourceStateCommandEncoder]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v753 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v18 insertDebugSignpost:v753];
        }

        v19 = *((void *)v752 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setResourceStateCommandEncoder:v18 forKey:v19];
        goto LABEL_1064;
      case -15867:
        objc_msgSend( v5,  "removeCounterSampleBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15848:
        v754 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v754]);
        v755 = GTTraceFunc_argumentBytesWithMap(a2, v754[24], v4);
        v756 = (void *)objc_claimAutoreleasedReturnValue([v5 defaultDevice]);
        MTLCounterSampleBufferDescriptor = MakeMTLCounterSampleBufferDescriptor((uint64_t)v755, v756);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLCounterSampleBufferDescriptor);

        v1663 = 0LL;
        v225 = [v60 newCounterSampleBufferWithDescriptor:v204 error:&v1663];
        v6 = v1663;
        v509 = *((void *)v754 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setCounterSampleBuffer:v225 forKey:v509];
        goto LABEL_1397;
      case -15847:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v759 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v760 = (uint64_t *)GTTraceFunc_argumentBytesWithMap(a2, v758[32], v4);
        v761 = *((_DWORD *)v758 + 4);
        v762 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v763 = v761;
        v60 = v759;
        v764 = MakeNSArray(v760, v763, v762);
        v204 = (id)objc_claimAutoreleasedReturnValue(v764);

        v765 = GTTraceFunc_argumentBytesWithMap(a2, v758[33], v4);
        v1571 = 0LL;
        v225 = [v759 newLibraryWithImageFilterFunctionsSPI:v204 imageFilterFunctionInfo:v765 error:&v1571];
        v766 = v1571;
        goto LABEL_912;
      case -15830:
        v767 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 functionForKey:*(void *)v767]);
        v768 = GTTraceFunc_argumentBlobWithMap(a2, v767[16], v4);
        if (v768)
        {
          v769 = v768 + 16;
          v770 = *(unsigned int *)(v768 + 12);
        }

        else
        {
          v769 = 0LL;
          v770 = 0LL;
        }

        v108 = (id)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  v769,  v770,  0LL));
        v121 = [v106 newFunctionWithPluginData:v108 bitcodeType:v767[17]];
        v123 = *((void *)v767 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setFunction:v121 forKey:v123];
        goto LABEL_1304;
      case -15822:
        v771 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v771]);
        objc_msgSend( v56,  "setVertexAmplificationCount:viewMappings:",  *((void *)v771 + 1),  GTTraceFunc_argumentBytesWithMap(a2, v771[16], v4));
        goto LABEL_1090;
      case -15821:
        v772 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v772]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 heapForKey:*((void *)v772 + 1)]);
        [v12 useHeap:v18 stages:*((void *)v772 + 2)];
        goto LABEL_1064;
      case -15820:
        v773 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v773]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v774 = apr_palloc(v623, 8LL * *((void *)v773 + 1));
        v775 = GTTraceFunc_argumentBytesWithMap(a2, v773[24], v4);
        if (*((void *)v773 + 1))
        {
          v776 = v775;
          v777 = 0LL;
          do
          {
            v774[v777] = [v5 heapForKey:*(void *)&v776[8 * v777]];
            ++v777;
            v778 = *((void *)v773 + 1);
          }

          while (v778 > v777);
        }

        else
        {
          v778 = 0LL;
        }

        [v106 useHeaps:v774 count:v778 stages:*((void *)v773 + 2)];
        goto LABEL_1352;
      case -15819:
        v779 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v779]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 resourceForKey:*((void *)v779 + 1)]);
        [v12 useResource:v18 usage:*((void *)v779 + 2) stages:*((void *)v779 + 3)];
        goto LABEL_1064;
      case -15818:
        v780 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v780]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v781 = apr_palloc(v623, 8LL * *((void *)v780 + 1));
        v782 = GTTraceFunc_argumentBytesWithMap(a2, v780[32], v4);
        if (*((void *)v780 + 1))
        {
          v783 = v782;
          v784 = 0LL;
          do
          {
            v781[v784] = [v5 resourceForKey:*(void *)&v783[8 * v784]];
            ++v784;
            v785 = *((void *)v780 + 1);
          }

          while (v785 > v784);
        }

        else
        {
          v785 = 0LL;
        }

        [v106 useResources:v781 count:v785 usage:*((void *)v780 + 2) stages:*((void *)v780 + 3)];
        goto LABEL_1352;
      case -15812:
        v786 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v786]);
        [v12 setVertexAmplificationMode:*((void *)v786 + 1) value:*((void *)v786 + 2)];
        break;
      case -15809:
        v787 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v787]);
        [v12 setBackgroundGPUPriority:*((void *)v787 + 1)];
        break;
      case -15808:
        v788 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v788]);
        [v12 setBackgroundGPUPriority:*((void *)v788 + 1) offset:*((unsigned __int16 *)v788 + 10)];
        break;
      case -15806:
        v789 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v789]);
        [v12 setGPUPriority:*((void *)v789 + 1)];
        break;
      case -15805:
        v790 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v790]);
        [v12 setGPUPriority:*((void *)v790 + 1) offset:*((unsigned __int16 *)v790 + 10)];
        break;
      case -15801:
        objc_msgSend( v5,  "removeRasterizationRateMapForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15796:
        v791 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v791]);
        [v12 tileSizeWithSparsePageSize:*((void *)v791 + 4) textureType:*((void *)v791 + 5) pixelFormat:*((void *)v791 + 6) sampleCount:*((void *)v791 + 7)];
        break;
      case -15794:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15793:
        v792 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v792]);
        v793 = GTTraceFunc_argumentBytesWithMap(a2, v792[16], v4);
        MTLRasterizationRateMapDescriptor = MakeMTLRasterizationRateMapDescriptor((uint64_t)v793);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLRasterizationRateMapDescriptor);
        v121 = [v106 newRasterizationRateMapWithDescriptor:v108];
        v123 = *((void *)v792 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setRasterizationRateMap:v121 forKey:v123];
        goto LABEL_1304;
      case -15790:
        objc_msgSend( v5,  "removeResourceStateCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15789:
        v795 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v795]);
        [v5 removeResourceStateCommandEncoderForKey:*(void *)v795];
        goto LABEL_707;
      case -15788:
        v102 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v102]);
        goto LABEL_709;
      case -15787:
        v796 = objc_msgSend( v5,  "resourceStateCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v259 = (void *)objc_claimAutoreleasedReturnValue(v796);
        goto LABEL_713;
      case -15786:
        v256 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v257 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v256]);
        goto LABEL_715;
      case -15785:
        v470 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v471 = objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v470]);
        goto LABEL_721;
      case -15784:
        v797 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v797]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v797 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v797 + 3)]);
        [v12 updateTextureMapping:v18 mode:*((void *)v797 + 2) indirectBuffer:v93 indirectBufferOffset:*((void *)v797 + 4)];
        goto LABEL_1063;
      case -15783:
        v798 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v798]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v798 + 1)]);
        v799 = *((void *)v798 + 2);
        v800 = *(_OWORD *)(v798 + 40);
        v1589[0] = *(_OWORD *)(v798 + 24);
        v1589[1] = v800;
        v1589[2] = *(_OWORD *)(v798 + 56);
        [v12 updateTextureMapping:v18 mode:v799 region:v1589 mipLevel:*((void *)v798 + 9) slice:*((void *)v798 + 10)];
        goto LABEL_1064;
      case -15782:
        v801 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v801]);
        v802 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v801 + 1)]);
        v803 = *((void *)v801 + 2);
        v804 = GTTraceFunc_argumentBytesWithMap(a2, v801[32], v4);
        v805 = GTTraceFunc_argumentBytesWithMap(a2, v801[33], v4);
        objc_msgSend( v56,  "updateTextureMappings:mode:regions:mipLevels:slices:numRegions:",  v802,  v803,  v804,  v805,  GTTraceFunc_argumentBytesWithMap(a2, v801[34], v4),  *((void *)v801 + 3));
        goto LABEL_1054;
      case -15781:
        v468 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v469 = objc_claimAutoreleasedReturnValue([v5 resourceStateCommandEncoderForKey:*(void *)v468]);
        goto LABEL_739;
      case -15778:
        v184 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v806 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v184]);
        v12 = v806;
        if ((dword_5B9DE4 & 0x40000) != 0) {
          v807 = *((void *)v184 + 3) & 0xFFFFFFFFFFFFFCFFLL;
        }
        else {
          v807 = *((void *)v184 + 3);
        }
        v488 = [v806 newBufferWithLength:*((void *)v184 + 2) options:v807 offset:*((void *)v184 + 4)];
        goto LABEL_648;
      case -15777:
        v808 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v808]);
        GTTraceFunc_argumentBytesWithMap(a2, v808[24], v4);
        v809 = _MakeMTLTextureDescriptor();
        v810 = (void *)objc_claimAutoreleasedReturnValue(v809);
        v108 = v810;
        if ((dword_5B9DE4 & 0x2000) != 0) {
          [v810 setCompressionMode:2];
        }
        v121 = [v106 newTextureWithDescriptor:v108 offset:*((void *)v808 + 2)];
        v123 = *((void *)v808 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setTexture:v121 forKey:v123];
        goto LABEL_1304;
      case -15775:
        v365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v365]);
        v811 = GTMTLSMContext_lastObject(**(void **)(*(void *)a1 + 40LL), *((void *)v365 + 1), *a2);
        if ((g_enableIndexedResourceType & 1) != 0)
        {
          v812 = v811;
          if (*(void *)(v811 + 176))
          {
            v813 = DEVICEOBJECT(v12);
            v814 = (void *)objc_claimAutoreleasedReturnValue(v813);
            v815 = objc_opt_respondsToSelector( v814,  "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:");

            if ((v815 & 1) != 0)
            {
              v816 = *((void *)v365 + 2);
              v817 = *((void *)v365 + 3);
              v818 = *((void *)v365 + 4);
              if (*((void *)v365 + 5) <= 1uLL) {
                v819 = 1LL;
              }
              else {
                v819 = *((void *)v365 + 5);
              }
              v820 = *((void *)v365 + 6);
              if (*((void *)v365 + 7) <= 1uLL) {
                v821 = 1LL;
              }
              else {
                v821 = *((void *)v365 + 7);
              }
              v822 = *((unsigned int *)v365 + 16);
              v823 = *(void *)(v812 + 176);
              goto LABEL_686;
            }
          }
        }

        v1463 = *((void *)v365 + 2);
        v1464 = *((void *)v365 + 3);
        v1465 = *((void *)v365 + 4);
        if (*((void *)v365 + 5) <= 1uLL) {
          v1466 = 1LL;
        }
        else {
          v1466 = *((void *)v365 + 5);
        }
        v1467 = *((void *)v365 + 6);
        if (*((void *)v365 + 7) <= 1uLL) {
          v1468 = 1LL;
        }
        else {
          v1468 = *((void *)v365 + 7);
        }
        v1469 = *((unsigned int *)v365 + 16);
        goto LABEL_1152;
      case -15770:
        v824 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 rasterizationRateMapForKey:*(void *)v824]);
        LODWORD(v825) = *((_DWORD *)v824 + 6);
        LODWORD(v826) = *((_DWORD *)v824 + 7);
        objc_msgSend(v12, "mapScreenToPhysicalCoordinates:forLayer:", *((void *)v824 + 1), v825, v826);
        break;
      case -15769:
        objc_msgSend( v5,  "removeResourceGroupForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15756:
        v827 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v827]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v827 + 4)]);
        v828 = GTTraceFunc_argumentBlobWithMap(a2, v827[48], v4);
        if (v828)
        {
          v829 = (const void *)(v828 + 16);
          v830 = *(unsigned int *)(v828 + 12);
        }

        else
        {
          v829 = 0LL;
          v830 = 0LL;
        }

        v1527 = *(id *)(a1 + 24);
        v913 = (void *)objc_claimAutoreleasedReturnValue([v1527 bufferWithLength:v830 alignment:1]);
        memcpy([v913 contents], v829, v830);

        v1319 = (void *)objc_claimAutoreleasedReturnValue([v913 heapBuffer]);
        objc_msgSend( v106,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v1319,  objc_msgSend(v913, "heapLocation"),  v243,  0,  v830);
        goto LABEL_1311;
      case -15753:
        v831 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 counterSampleBufferForKey:*(void *)v831]);
        v832 = objc_msgSend(v12, "resolveCounterRange:", *((void *)v831 + 1), *((void *)v831 + 2));
        break;
      case -15744:
        v833 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*(void *)v833]);
        [v12 setDisableRunTimeCompilation:*((_DWORD *)v833 + 2) != 0];
        break;
      case -15743:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15742:
        objc_msgSend( v5,  "removePipelineLibraryForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15740:
        v834 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*(void *)v834]);
        v835 = v834[32];
        if (v834[32])
        {
          v836 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v834[32], v4));
          v837 = (void *)objc_claimAutoreleasedReturnValue(v836);
        }

        else
        {
          v837 = 0LL;
        }

        v1528 = *((void *)v834 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1616 = 0LL;
        v204 = [v60 newComputePipelineStateWithName:v837 options:v1528 reflection:0 error:&v1616];
        v6 = v1616;
        if (v835) {

        }
        v1494 = *((void *)v834 + 1);
        if (!v204) {
          goto LABEL_1324;
        }
        [v5 setComputePipelineState:v204 forKey:v1494];
        goto LABEL_1398;
      case -15738:
        v838 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*(void *)v838]);
        v839 = v838[32];
        if (v838[32])
        {
          v840 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v838[32], v4));
          v841 = (void *)objc_claimAutoreleasedReturnValue(v840);
        }

        else
        {
          v841 = 0LL;
        }

        v1529 = *((void *)v838 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1615 = 0LL;
        v204 = [v60 newRenderPipelineStateWithName:v841 options:v1529 reflection:0 error:&v1615];
        v6 = v1615;
        if (v839) {

        }
        v1494 = *((void *)v838 + 1);
        if (v204)
        {
          [v5 setRenderPipelineState:v204 forKey:v1494];
        }

        else
        {
LABEL_1324:
          if (v1494) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v1494);
          }
          v204 = 0LL;
        }

        goto LABEL_1398;
      case -15732:
        v842 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v842]);
        if ((objc_opt_respondsToSelector(v14, "enableNullBufferBinds:") & 1) != 0) {
          [v14 enableNullBufferBinds:*((_DWORD *)v842 + 2) != 0];
        }
        goto LABEL_1041;
      case -15731:
        v843 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v843]);
        v844 = objc_msgSend( v106,  "newFunctionWithGLIR:functionType:",  GTTraceFunc_argumentBytesWithMap(a2, v843[24], v4),  *((void *)v843 + 2));
        goto LABEL_903;
      case -15730:
        v845 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v845]);
        v846 = GTTraceFunc_argumentBlobWithMap(a2, v845[25], v4);
        if (v846) {
          v847 = dispatch_data_create( (const void *)(v846 + 16),  *(unsigned int *)(v846 + 12),  0LL,  &__block_literal_global_36_2336);
        }
        else {
          v847 = 0LL;
        }
        v1530 = objc_msgSend( v106,  "newFunctionWithGLIR:inputsDescription:functionType:",  GTTraceFunc_argumentBytesWithMap(a2, v845[24], v4),  v847,  *((void *)v845 + 2));
        goto LABEL_1357;
      case -15729:
        v848 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v848]);
        LODWORD(v849) = *((_DWORD *)v848 + 2);
        [v12 setAlphaTestReferenceValue:v849];
        break;
      case -15728:
        v850 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v850]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v850 + 1)]);
        [v12 setColorResolveTexture:v18 slice:*((void *)v850 + 2) depthPlane:*((void *)v850 + 3) level:*((void *)v850 + 4) yInvert:*((_DWORD *)v850 + 12) != 0 atIndex:*((void *)v850 + 5)];
        goto LABEL_1064;
      case -15727:
        v851 = objc_msgSend( v5,  "renderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v851);
        [v14 setDepthCleared];
        goto LABEL_1041;
      case -15726:
        v852 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v852]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v852 + 1)]);
        [v12 setDepthResolveTexture:v18 slice:*((void *)v852 + 2) depthPlane:*((void *)v852 + 3) level:*((void *)v852 + 4) yInvert:*((_DWORD *)v852 + 10) != 0];
        goto LABEL_1064;
      case -15725:
        v853 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v853]);
        [v12 setProvokingVertexMode:*((void *)v853 + 1)];
        break;
      case -15724:
        v854 = objc_msgSend( v5,  "renderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v854);
        [v14 setStencilCleared];
        goto LABEL_1041;
      case -15723:
        v855 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v855]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v855 + 1)]);
        [v12 setStencilResolveTexture:v18 slice:*((void *)v855 + 2) depthPlane:*((void *)v855 + 3) level:*((void *)v855 + 4)];
        goto LABEL_1064;
      case -15722:
        v856 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v856]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v856 + 1)]);
        [v12 setStencilResolveTexture:v18 slice:*((void *)v856 + 2) depthPlane:*((void *)v856 + 3) level:*((void *)v856 + 4) yInvert:*((_DWORD *)v856 + 10) != 0];
        goto LABEL_1064;
      case -15721:
        v857 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v857]);
        [v12 setTriangleFrontFillMode:*((void *)v857 + 1) backFillMode:*((void *)v857 + 2)];
        break;
      case -15720:
        v858 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v858]);
        [v12 setViewportTransformEnabled:*((_DWORD *)v858 + 2) != 0];
        break;
      case -15715:
        v859 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 functionForKey:*(void *)v859]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*((void *)v859 + 3)]);
        v860 = [v12 newArgumentEncoderWithBufferIndex:*((void *)v859 + 2) pipelineLibrary:v18];
        goto LABEL_629;
      case -15714:
        v859 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 functionForKey:*(void *)v859]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 pipelineLibraryForKey:*((void *)v859 + 3)]);
        v860 = [v12 newArgumentEncoderWithBufferIndex:*((void *)v859 + 2) reflection:0 pipelineLibrary:v18];
LABEL_629:
        v93 = v860;
        v743 = *((void *)v859 + 1);
        if (!v860) {
          goto LABEL_990;
        }
        [v5 setArgumentEncoder:v860 forKey:v743];
        goto LABEL_1063;
      case -15712:
        v124 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v124]);
        v125 = objc_claimAutoreleasedReturnValue( [v12 computeCommandEncoderWithDispatchType:*((void *)v124 + 2) substreamCount:*((unsigned int *)v124 + 6)]);
LABEL_632:
        v18 = (id)v125;
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v861 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v18 insertDebugSignpost:v861];
        }

        v19 = *((void *)v124 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setComputeCommandEncoder:v18 forKey:v19];
        goto LABEL_1064;
      case -15711:
        v862 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v862]);
        [v12 setSubstream:*((unsigned int *)v862 + 2)];
        break;
      case -15710:
        v863 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v863]);
        [v12 signalProgress:*((unsigned int *)v863 + 2)];
        break;
      case -15709:
        v864 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v864]);
        [v12 waitForProgress:*((unsigned int *)v864 + 2)];
        break;
      case -15707:
        v865 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v865]);
        v866 = GTTraceFunc_argumentBytesWithMap(a2, v865[40], v4);
        if ((dword_5B9DE4 & 0x40000) != 0) {
          v867 = *((void *)v865 + 3) & 0xFFFFFFFFFFFFFCFFLL;
        }
        else {
          v867 = *((void *)v865 + 3);
        }
        v108 = [v106 newBufferWithBytes:v866 length:*((void *)v865 + 2) options:v867 gpuAddress:*((void *)v865 + 4)];
        v868 = *((void *)v865 + 1);
        if (!v108) {
          goto LABEL_1437;
        }
        [v5 setBuffer:v108 forKey:v868];
        goto LABEL_1428;
      case -15705:
        v184 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v869 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v184]);
        v12 = v869;
        if ((dword_5B9DE4 & 0x40000) != 0) {
          v870 = *((void *)v184 + 3) & 0xFFFFFFFFFFFFFCFFLL;
        }
        else {
          v870 = *((void *)v184 + 3);
        }
        v488 = [v869 newBufferWithLength:*((void *)v184 + 2) options:v870 gpuAddress:*((void *)v184 + 4)];
LABEL_648:
        v18 = v488;
        v19 = *((void *)v184 + 1);
        if (!v488) {
          goto LABEL_1050;
        }
        [v5 setBuffer:v488 forKey:v19];
        goto LABEL_1064;
      case -15698:
        v871 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v871]);
        [v12 setCommandBufferErrorOptions:*((void *)v871 + 1)];
        break;
      case -15695:
        v872 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v872]);
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*((void *)v872 + 2)]);
        v1662 = 0LL;
        v225 = [v60 newDynamicLibrary:v204 error:&v1662];
        v6 = v1662;
        v509 = *((void *)v872 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        goto LABEL_750;
      case -15693:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v873 = GTTraceFunc_argumentBytesWithMap(a2, v758[25], v4);
        v874 = (uint64_t *)(v873 + 8);
        v875 = *(_DWORD *)v873;
        v876 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v877 = MakeNSArray(v874, v875, v876);
        v204 = (id)objc_claimAutoreleasedReturnValue(v877);

        v878 = v758[24];
        if (v758[24])
        {
          v879 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4));
          v880 = (void *)objc_claimAutoreleasedReturnValue(v879);
        }

        else
        {
          v880 = 0LL;
        }

        v1559 = 0LL;
        v225 = [v60 newLibraryWithDAG:v880 functions:v204 error:&v1559];
        v6 = v1559;
        if (v878) {

        }
        goto LABEL_913;
      case -15690:
        v365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v881 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v365]);
        v12 = v881;
        if ((g_enableIndexedResourceType & 1) != 0
          && (v882 = DEVICEOBJECT(v881),
              v883 = (void *)objc_claimAutoreleasedReturnValue(v882),
              v884 = objc_opt_respondsToSelector(v883, "newTextureViewWithPixelFormat:resourceIndex:"),
              v883,
              (v884 & 1) != 0))
        {
          v371 = *((void *)v365 + 2);
          v372 = *((void *)v365 + 3);
LABEL_658:
          v885 = [v12 newTextureViewWithPixelFormat:v371 resourceIndex:v372];
        }

        else
        {
LABEL_659:
          v885 = [v12 newTextureViewWithPixelFormat:*((void *)v365 + 2)];
        }

        goto LABEL_1153;
      case -15689:
        v365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v886 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v365]);
        v12 = v886;
        if ((g_enableIndexedResourceType & 1) != 0
          && (v887 = DEVICEOBJECT(v886),
              v888 = (void *)objc_claimAutoreleasedReturnValue(v887),
              v889 = objc_opt_respondsToSelector( v888,  "newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:"),  v888,  (v889 & 1) != 0))
        {
          v427 = *((void *)v365 + 2);
          v428 = *((void *)v365 + 3);
          v429 = *((void *)v365 + 4);
          if (*((void *)v365 + 5) <= 1uLL) {
            v430 = 1LL;
          }
          else {
            v430 = *((void *)v365 + 5);
          }
          v431 = *((void *)v365 + 6);
          if (*((void *)v365 + 7) <= 1uLL) {
            v432 = 1LL;
          }
          else {
            v432 = *((void *)v365 + 7);
          }
          v433 = *((void *)v365 + 8);
LABEL_669:
          v885 = objc_msgSend( v12,  "newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:",  v427,  v428,  v429,  v430,  v431,  v432,  v433);
        }

        else
        {
LABEL_670:
          if (*((void *)v365 + 5) <= 1uLL) {
            v890 = 1LL;
          }
          else {
            v890 = *((void *)v365 + 5);
          }
          if (*((void *)v365 + 7) <= 1uLL) {
            v891 = 1LL;
          }
          else {
            v891 = *((void *)v365 + 7);
          }
          v885 = objc_msgSend( v12,  "newTextureViewWithPixelFormat:textureType:levels:slices:",  *((void *)v365 + 2),  *((void *)v365 + 3),  *((void *)v365 + 4),  v890,  *((void *)v365 + 6),  v891);
        }

        goto LABEL_1153;
      case -15688:
        v365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v892 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)v365]);
        v12 = v892;
        if ((g_enableIndexedResourceType & 1) != 0
          && (v893 = DEVICEOBJECT(v892),
              v894 = (void *)objc_claimAutoreleasedReturnValue(v893),
              v895 = objc_opt_respondsToSelector( v894,  "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:"),  v894,  (v895 & 1) != 0))
        {
          v816 = *((void *)v365 + 2);
          v817 = *((void *)v365 + 3);
          v818 = *((void *)v365 + 4);
          if (*((void *)v365 + 5) <= 1uLL) {
            v819 = 1LL;
          }
          else {
            v819 = *((void *)v365 + 5);
          }
          v820 = *((void *)v365 + 6);
          if (*((void *)v365 + 7) <= 1uLL) {
            v821 = 1LL;
          }
          else {
            v821 = *((void *)v365 + 7);
          }
          v822 = *((unsigned int *)v365 + 18);
          v823 = *((void *)v365 + 8);
LABEL_686:
          v885 = objc_msgSend( v12,  "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:",  v816,  v817,  v818,  v819,  v820,  v821,  v822,  v823);
        }

        else
        {
          v1463 = *((void *)v365 + 2);
          v1464 = *((void *)v365 + 3);
          v1465 = *((void *)v365 + 4);
          if (*((void *)v365 + 5) <= 1uLL) {
            v1466 = 1LL;
          }
          else {
            v1466 = *((void *)v365 + 5);
          }
          v1467 = *((void *)v365 + 6);
          if (*((void *)v365 + 7) <= 1uLL) {
            v1468 = 1LL;
          }
          else {
            v1468 = *((void *)v365 + 7);
          }
          v1469 = *((unsigned int *)v365 + 18);
LABEL_1152:
          v885 = objc_msgSend( v12,  "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:",  v1463,  v1464,  v1465,  v1466,  v1467,  v1468,  v1469);
        }

LABEL_1153:
        v1470 = v885;
        v1471 = *((void *)v365 + 1);
        if (!v885) {
          goto LABEL_1418;
        }
        [v5 setTexture:v885 forKey:v1471];
        goto LABEL_1420;
      case -15685:
        objc_msgSend( v5,  "removeBinaryArchiveForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15676:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 dynamicLibraryForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15675:
        objc_msgSend( v5,  "removeDynamicLibraryForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15673:
        v896 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v896]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 accelerationStructureCommandEncoder]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v897 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v18 insertDebugSignpost:v897];
        }

        v19 = *((void *)v896 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setAccelerationStructureCommandEncoder:v18 forKey:v19];
        goto LABEL_1064;
      case -15668:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 binaryArchiveForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15661:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15659:
        objc_msgSend( v5,  "removeAccelerationStructureForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15651:
        v898 = objc_msgSend( v5,  "accelerationStructureForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v476 = (void *)objc_claimAutoreleasedReturnValue(v898);
LABEL_698:
        v14 = v476;
        [v476 makeAliasable];
        goto LABEL_1041;
      case -15649:
        v899 = objc_msgSend( v5,  "accelerationStructureForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v899);
        [v14 waitUntilComplete];
        goto LABEL_1041;
      case -15648:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15647:
        v900 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v900]);
        v847 = (dispatch_data_t)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v900 + 1)]);
        v901 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v900 + 2)]);
        v902 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v900[32], v4);
        v903 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        MTLAccelerationStructureDescriptor = MakeMTLAccelerationStructureDescriptor(v902, v903);
        v905 = (void *)objc_claimAutoreleasedReturnValue(MTLAccelerationStructureDescriptor);

        [v106 buildAccelerationStructure:v847 descriptor:v905 scratchBuffer:v901 scratchBufferOffset:*((void *)v900 + 3)];
        goto LABEL_842;
      case -15646:
        v906 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v906]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v906 + 1)]);
        v751 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v906 + 2)]);
        [v12 copyAccelerationStructure:v18 toAccelerationStructure:v751];
        goto LABEL_704;
      case -15645:
        v907 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v907]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v907 + 1)]);
        v751 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v907 + 2)]);
        [v12 copyAndCompactAccelerationStructure:v18 toAccelerationStructure:v751];
LABEL_704:

        goto LABEL_1064;
      case -15644:
        objc_msgSend( v5,  "removeAccelerationStructureCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15642:
        v908 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v908]);
        [v5 removeAccelerationStructureCommandEncoderForKey:*(void *)v908];
LABEL_707:
        [v12 endEncoding];
        break;
      case -15641:
        v102 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v103 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v102]);
LABEL_709:
        v106 = v103;
        if (v102[8])
        {
          v909 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v102[8], v4));
          v571 = (void *)objc_claimAutoreleasedReturnValue(v909);
          [v106 insertDebugSignpost:v571];
          goto LABEL_1059;
        }

        [v103 insertDebugSignpost:0];
        goto LABEL_1429;
      case -15640:
        v910 = objc_msgSend( v5,  "accelerationStructureCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v259 = (void *)objc_claimAutoreleasedReturnValue(v910);
LABEL_713:
        v14 = v259;
        [v259 popDebugGroup];
        goto LABEL_1041;
      case -15639:
        v256 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v257 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v256]);
LABEL_715:
        v106 = v257;
        if (v256[8])
        {
          v911 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v256[8], v4));
          v571 = (void *)objc_claimAutoreleasedReturnValue(v911);
          [v106 pushDebugGroup:v571];
          goto LABEL_1059;
        }

        [v257 pushDebugGroup:0];
        goto LABEL_1429;
      case -15638:
        v912 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v912]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v912 + 1)]);
        v913 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v912 + 2)]);
        v914 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v912 + 3)]);
        v915 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v912[40], v4);
        v916 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v917 = MakeMTLAccelerationStructureDescriptor(v915, v916);
        v918 = (void *)objc_claimAutoreleasedReturnValue(v917);

        [v106 refitAccelerationStructure:v243 descriptor:v918 destination:v913 scratchBuffer:v914 scratchBufferOffset:*((void *)v912 + 4)];
        goto LABEL_1312;
      case -15637:
        v919 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v919]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 counterSampleBufferForKey:*((void *)v919 + 1)]);
        [v12 sampleCountersInBuffer:v18 atSampleIndex:*((void *)v919 + 2) withBarrier:*((_DWORD *)v919 + 6) != 0];
        goto LABEL_1064;
      case -15635:
        v470 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v471 = objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v470]);
LABEL_721:
        v12 = (void *)v471;
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 fenceForKey:*((void *)v470 + 1)]);
        [v12 updateFence:v33];
        goto LABEL_1131;
      case -15634:
        v629 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v630 = objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v629]);
LABEL_723:
        v12 = (void *)v630;
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*((void *)v629 + 1)]);
        [v12 useHeap:v33];
        goto LABEL_1131;
      case -15633:
        v920 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v920]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v633 = apr_palloc(v632, 8LL * *((void *)v920 + 1));
        v921 = GTTraceFunc_argumentBytesWithMap(a2, v920[16], v4);
        if (*((void *)v920 + 1))
        {
          v922 = v921;
          v923 = 0LL;
          do
          {
            v633[v923] = [v5 heapForKey:*(void *)&v922[8 * v923]];
            ++v923;
            v637 = *((void *)v920 + 1);
          }

          while (v637 > v923);
        }

        else
        {
LABEL_728:
          v637 = 0LL;
        }

LABEL_729:
        [v106 useHeaps:v633 count:v637];
        goto LABEL_1389;
      case -15632:
        v620 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v621 = objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v620]);
LABEL_731:
        v12 = (void *)v621;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 resourceForKey:*((void *)v620 + 1)]);
        [v12 useResource:v18 usage:*((void *)v620 + 2)];
        goto LABEL_1064;
      case -15631:
        v622 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v622]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v624 = apr_palloc(v623, 8LL * *((void *)v622 + 1));
        v924 = GTTraceFunc_argumentBytesWithMap(a2, v622[24], v4);
        if (*((void *)v622 + 1))
        {
          v925 = v924;
          v926 = 0LL;
          do
          {
            v624[v926] = [v5 resourceForKey:*(void *)&v925[8 * v926]];
            ++v926;
            v628 = *((void *)v622 + 1);
          }

          while (v628 > v926);
        }

        else
        {
LABEL_736:
          v628 = 0LL;
        }

LABEL_737:
        [v106 useResources:v624 count:v628 usage:*((void *)v622 + 2)];
        goto LABEL_1352;
      case -15630:
        v468 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v469 = objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v468]);
LABEL_739:
        v12 = (void *)v469;
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 fenceForKey:*((void *)v468 + 1)]);
        [v12 waitForFence:v33];
        goto LABEL_1131;
      case -15629:
        v927 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v927]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v927 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v927 + 2)]);
        [v12 writeCompactedAccelerationStructureSize:v18 toBuffer:v93 offset:*((void *)v927 + 3)];
        goto LABEL_1063;
      case -15627:
        v928 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v928]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v928 + 1)]);
        [v12 setAccelerationStructure:v18 atIndex:*((void *)v928 + 2)];
        goto LABEL_1064;
      case -15623:
        v929 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v929]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v929 + 1)]);
        [v12 setAccelerationStructure:v18 atBufferIndex:*((void *)v929 + 2)];
        goto LABEL_1064;
      case -15620:
        v930 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineStateForKey:*(void *)v930]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v930 + 2)]);
        v931 = objc_claimAutoreleasedReturnValue([v12 functionHandleWithFunction:v18]);
        goto LABEL_895;
      case -15615:
        v932 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v932]);
        if ((GT_SUPPORT_0 & 0x100000) == 0)
        {
          v933 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v932[16], v4);
          v934 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
          v935 = MakeMTLAccelerationStructureDescriptor(v933, v934);
          v936 = (void *)objc_claimAutoreleasedReturnValue(v935);
          v937 = [v106 newAccelerationStructureWithDescriptor:v936];
          goto LABEL_1001;
        }

        v1472 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v932[16], v4);
        v1473 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1474 = MakeMTLAccelerationStructureDescriptor(v1472, v1473);
        v1475 = (void *)objc_claimAutoreleasedReturnValue(v1474);
        if (v106)
        {
          [v106 accelerationStructureSizesWithDescriptor:v1475];
        }

        else
        {
          memset(buf, 0, sizeof(buf));
          *(void *)&v1721 = 0LL;
        }

        v108 = objc_msgSend( v106,  "newAccelerationStructureWithSize:resourceIndex:",  *(void *)buf,  GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40), *((void *)v932 + 1), *a2)[19]);
        goto LABEL_1435;
      case -15614:
        v938 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v938]);
        if ((GT_SUPPORT_0 & 0x100000) == 0)
        {
          v939 = *((void *)v938 + 2);
          goto LABEL_1170;
        }

        v1344 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v938 + 1), *a2);
        v939 = *((void *)v938 + 2);
        goto LABEL_1171;
      case -15613:
        v940 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v940]);
        v941 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 14), v4);
        v942 = GTTraceFunc_argumentBytesWithMap(a2, v940[24], v4);
        v943 = GTMTLReplayController_dumpLibrary(a1, v942, *((char **)v941 + 1));
        v204 = (id)objc_claimAutoreleasedReturnValue(v943);
        v1558[0] = 0LL;
        v225 = [v60 newDynamicLibraryWithURL:v204 error:v1558];
        v6 = v1558[0];
        v509 = *((void *)v940 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setDynamicLibrary:v225 forKey:v509];
        v509 = *((void *)v940 + 1);
LABEL_750:
        [v5 setDynamicLibrary:v225 forKey:v509];
        goto LABEL_1397;
      case -15610:
        objc_msgSend( v5,  "removeFunctionHandleForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15609:
        v491 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v491]);
        v944 = GTTraceFunc_argumentBytesWithMap(a2, v491[24], v4);
        v945 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        MTLFunctionDescriptor = MakeMTLFunctionDescriptor((uint64_t)v944, v945);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);

        v1624 = 0LL;
        v225 = [v60 newFunctionWithDescriptor:v204 error:&v1624];
        v947 = v1624;
        goto LABEL_791;
      case -15608:
        v491 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v491]);
        v948 = GTTraceFunc_argumentBytesWithMap(a2, v491[24], v4);
        v949 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v950 = MakeMTLFunctionDescriptor((uint64_t)v948, v949);
        v204 = (id)objc_claimAutoreleasedReturnValue(v950);

        v1623 = 0LL;
        v225 = [v60 newFunctionWithDescriptor:v204 error:&v1623];
        v947 = v1623;
        goto LABEL_791;
      case -15607:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 visibleFunctionTableForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15605:
        objc_msgSend( v5,  "removeVisibleFunctionTableForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15592:
        v951 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v951]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v951 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v951 + 3)]);
        [v12 writeDeserializedAccelerationStructureSize:v18 serializedOffset:*((void *)v951 + 2) toBuffer:v93 sizeBufferOffset:*((void *)v951 + 4)];
        goto LABEL_1063;
      case -15591:
        v952 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v952]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v952 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v952 + 3)]);
        [v12 writeDeserializedPrimitiveAccelerationStructureSizes:v18 serializedOffset:*((void *)v952 + 2) toBuffer:v93 sizesBufferOffset:*((void *)v952 + 4)];
        goto LABEL_1063;
      case -15588:
        v953 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v953]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v953 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v953 + 2)]);
        [v12 writeSerializedAccelerationStructureSize:v18 toBuffer:v93 sizeBufferOffset:*((void *)v953 + 3)];
        goto LABEL_1063;
      case -15587:
        v954 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v954]);
        v955 = GTTraceFunc_argumentBytesWithMap(a2, v954[16], v4);
        v956 = (void *)objc_claimAutoreleasedReturnValue([v5 blitPassDescriptorMap]);
        MTLBlitPassDescriptor = MakeMTLBlitPassDescriptor((uint64_t)v955, v956);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLBlitPassDescriptor);

        v121 = (id)objc_claimAutoreleasedReturnValue([v106 blitCommandEncoderWithDescriptor:v108]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v958 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v121 insertDebugSignpost:v958];
        }

        v123 = *((void *)v954 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setBlitCommandEncoder:v121 forKey:v123];
        goto LABEL_1304;
      case -15586:
        v959 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v959]);
        v960 = GTTraceFunc_argumentBytesWithMap(a2, v959[16], v4);
        v961 = (void *)objc_claimAutoreleasedReturnValue([v5 computePassDescriptorMap]);
        MTLComputePassDescriptor = MakeMTLComputePassDescriptor((uint64_t)v960, v961);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLComputePassDescriptor);

        v121 = (id)objc_claimAutoreleasedReturnValue([v106 computeCommandEncoderWithDescriptor:v108]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v963 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v121 insertDebugSignpost:v963];
        }

        v123 = *((void *)v959 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setComputeCommandEncoder:v121 forKey:v123];
        goto LABEL_1304;
      case -15585:
        v964 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v964]);
        v965 = GTTraceFunc_argumentBytesWithMap(a2, v964[16], v4);
        v966 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceStatePassDescriptorMap]);
        MTLResourceStatePassDescriptor = MakeMTLResourceStatePassDescriptor((uint64_t)v965, v966);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLResourceStatePassDescriptor);

        v121 = (id)objc_claimAutoreleasedReturnValue([v106 resourceStateCommandEncoderWithDescriptor:v108]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v968 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v121 insertDebugSignpost:v968];
        }

        v123 = *((void *)v964 + 1);
        if (!v121) {
          goto LABEL_1302;
        }
        [v5 setResourceStateCommandEncoder:v121 forKey:v123];
        goto LABEL_1304;
      case -15584:
        v969 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v969]);
        v970 = GTTraceFunc_argumentBytesWithMap(a2, v969[24], v4);
        v971 = (void *)objc_claimAutoreleasedReturnValue([v5 computePassDescriptorMap]);
        v972 = MakeMTLComputePassDescriptor((uint64_t)v970, v971);
        v847 = (dispatch_data_t)objc_claimAutoreleasedReturnValue(v972);

        v973 = objc_msgSend( v106,  "sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:",  v847,  GTTraceFunc_argumentBytesWithMap(a2, v969[25], v4),  *((void *)v969 + 2));
        v974 = (void *)objc_claimAutoreleasedReturnValue(v973);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v975 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v974 insertDebugSignpost:v975];
        }

        v976 = *((void *)v969 + 1);
        if (!v974) {
          goto LABEL_1359;
        }
        [v5 setComputeCommandEncoder:v974 forKey:v976];
        goto LABEL_1361;
      case -15583:
        v977 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v977]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*((void *)v977 + 1)]);
        [v12 setIntersectionFunctionTable:v18 atBufferIndex:*((void *)v977 + 2)];
        goto LABEL_1064;
      case -15582:
        v978 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v978]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v979 = apr_palloc(v623, 8LL * *((void *)v978 + 2));
        v980 = GTTraceFunc_argumentBytesWithMap(a2, v978[24], v4);
        if (*((void *)v978 + 2))
        {
          v981 = v980;
          v982 = 0LL;
          do
          {
            v979[v982] = [v5 intersectionFunctionTableForKey:*(void *)&v981[8 * v982]];
            ++v982;
            v983 = *((void *)v978 + 2);
          }

          while (v983 > v982);
        }

        else
        {
          v983 = 0LL;
        }

        objc_msgSend(v106, "setIntersectionFunctionTables:withBufferRange:", v979, *((void *)v978 + 1), v983);
        goto LABEL_1352;
      case -15581:
        v984 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v985 = objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v984]);
        goto LABEL_802;
      case -15580:
        v986 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v986]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v987 = apr_palloc(v623, 8LL * *((void *)v986 + 2));
        v988 = GTTraceFunc_argumentBytesWithMap(a2, v986[24], v4);
        if (!*((void *)v986 + 2)) {
          goto LABEL_1155;
        }
        v989 = v988;
        v990 = 0LL;
        do
        {
          v987[v990] = [v5 visibleFunctionTableForKey:*(void *)&v989[8 * v990]];
          ++v990;
          v991 = *((void *)v986 + 2);
        }

        while (v991 > v990);
        goto LABEL_1156;
      case -15578:
        v992 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computePipelineStateForKey:*(void *)v992]);
        v993 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptor;
        v994 = GTTraceFunc_argumentBytesWithMap(a2, v992[16], v4);
        v995 = v993(v994);
        v108 = (id)objc_claimAutoreleasedReturnValue(v995);
        v996 = [v106 newVisibleFunctionTableWithDescriptor:v108];
        goto LABEL_891;
      case -15577:
        v997 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v998 = objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v997]);
        goto LABEL_793;
      case -15570:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15568:
        objc_msgSend( v5,  "removeIntersectionFunctionTableForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15551:
        v491 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v491]);
        v999 = GTTraceFunc_argumentBytesWithMap(a2, v491[32], v4);
        v1000 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        MTLIntersectionFunctionDescriptor = MakeMTLIntersectionFunctionDescriptor((uint64_t)v999, v1000);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionDescriptor);

        v1618 = 0LL;
        v225 = [v60 newIntersectionFunctionWithDescriptor:v204 error:&v1618];
        v947 = v1618;
        goto LABEL_791;
      case -15550:
        v491 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*(void *)v491]);
        v1002 = GTTraceFunc_argumentBytesWithMap(a2, v491[24], v4);
        v1003 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1004 = MakeMTLIntersectionFunctionDescriptor((uint64_t)v1002, v1003);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1004);

        v1617 = 0LL;
        v225 = [v60 newIntersectionFunctionWithDescriptor:v204 error:&v1617];
        v947 = v1617;
LABEL_791:
        v6 = v947;
LABEL_1237:
        v509 = *((void *)v491 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setFunction:v225 forKey:v509];
        goto LABEL_1397;
      case -15540:
        v997 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v998 = objc_claimAutoreleasedReturnValue([v5 computePipelineStateForKey:*(void *)v997]);
LABEL_793:
        v106 = (void *)v998;
        v1005 = (uint64_t (*)(void))MakeMTLIntersectionFunctionTableDescriptor;
        v1006 = GTTraceFunc_argumentBytesWithMap(a2, v997[16], v4);
        v1007 = v1005(v1006);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1007);
        v1008 = [v106 newIntersectionFunctionTableWithDescriptor:v108];
        goto LABEL_886;
      case -15539:
        v1009 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v1009]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*((void *)v1009 + 1)]);
        [v12 setIntersectionFunctionTable:v18 atIndex:*((void *)v1009 + 2)];
        goto LABEL_1064;
      case -15538:
        v1010 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 argumentEncoderForKey:*(void *)v1010]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1011 = apr_palloc(v623, 8LL * *((void *)v1010 + 2));
        v1012 = GTTraceFunc_argumentBytesWithMap(a2, v1010[24], v4);
        if (*((void *)v1010 + 2))
        {
          v1013 = v1012;
          v1014 = 0LL;
          do
          {
            v1011[v1014] = [v5 intersectionFunctionTableForKey:*(void *)&v1013[8 * v1014]];
            ++v1014;
            v1015 = *((void *)v1010 + 2);
          }

          while (v1015 > v1014);
        }

        else
        {
          v1015 = 0LL;
        }

        objc_msgSend(v106, "setIntersectionFunctionTables:withRange:", v1011, *((void *)v1010 + 1), v1015);
        goto LABEL_1352;
      case -15531:
        v1016 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1016]);
        v1017 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 14), v4);
        v1018 = GTTraceFunc_argumentBytesWithMap(a2, v1016[32], v4);
        v1019 = GTMTLReplayController_dumpLibrary(a1, v1018, *((char **)v1017 + 1));
        v1558[1] = 0LL;
        v69 = (id)objc_claimAutoreleasedReturnValue(v1019);
        v1020 = objc_msgSend(v60, "newDynamicLibraryWithURL:options:error:");
        v6 = 0LL;
        v1021 = *((void *)v1016 + 1);
        if (v1020)
        {
          [v5 setDynamicLibrary:v1020 forKey:v1021];
        }

        else if (v1021)
        {
          GTMTLReplay_dispatchFailedToSet((uint64_t)a2, *((void *)v1016 + 1));
        }

        goto LABEL_1339;
      case -15526:
        v984 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v985 = objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*(void *)v984]);
LABEL_802:
        v12 = (void *)v985;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 visibleFunctionTableForKey:*((void *)v984 + 1)]);
        [v12 setVisibleFunctionTable:v18 atBufferIndex:*((void *)v984 + 2)];
        goto LABEL_1064;
      case -15525:
        v986 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*(void *)v986]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v987 = apr_palloc(v623, 8LL * *((void *)v986 + 2));
        v1022 = GTTraceFunc_argumentBytesWithMap(a2, v986[24], v4);
        if (*((void *)v986 + 2))
        {
          v1023 = v1022;
          v1024 = 0LL;
          do
          {
            v987[v1024] = [v5 visibleFunctionTableForKey:*(void *)&v1023[8 * v1024]];
            ++v1024;
            v991 = *((void *)v986 + 2);
          }

          while (v991 > v1024);
        }

        else
        {
LABEL_1155:
          v991 = 0LL;
        }

LABEL_1156:
        objc_msgSend(v106, "setVisibleFunctionTables:withBufferRange:", v987, *((void *)v986 + 1), v991);
        goto LABEL_1352;
      case -15524:
        v1025 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1025]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1025 + 1)]);
        v913 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1025 + 2)]);
        v1026 = GTTraceFunc_argumentBytesWithMap(a2, v1025[32], v4);
        v1027 = (uint64_t *)(v1026 + 8);
        v1028 = *(_DWORD *)v1026;
        v1029 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1030 = MakeNSArray(v1027, v1028, v1029);
        v1031 = (void *)objc_claimAutoreleasedReturnValue(v1030);

        [v106 deserializeInstanceAccelerationStructure:v243 primitiveAccelerationStructures:v1031 fromBuffer:v913 serializedBufferOffset:*((void *)v1025 + 3)];
        goto LABEL_810;
      case -15523:
        v1032 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1032]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1032 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1032 + 2)]);
        [v12 deserializePrimitiveAccelerationStructure:v18 fromBuffer:v93 serializedBufferOffset:*((void *)v1032 + 3)];
        goto LABEL_1063;
      case -15522:
        v1033 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1033]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1033 + 1)]);
        v913 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1033 + 2)]);
        v1034 = GTTraceFunc_argumentBytesWithMap(a2, v1033[32], v4);
        v1035 = (uint64_t *)(v1034 + 8);
        v1036 = *(_DWORD *)v1034;
        v1037 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1038 = MakeNSArray(v1035, v1036, v1037);
        v1031 = (void *)objc_claimAutoreleasedReturnValue(v1038);

        [v106 serializeInstanceAccelerationStructure:v243 primitiveAccelerationStructures:v1031 toBuffer:v913 serializedBufferOffset:*((void *)v1033 + 3)];
LABEL_810:

        goto LABEL_1312;
      case -15521:
        v1039 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1039]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1039 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1039 + 2)]);
        [v12 serializePrimitiveAccelerationStructure:v18 toBuffer:v93 serializedBufferOffset:*((void *)v1039 + 3)];
        goto LABEL_1063;
      case -15511:
        v1040 = objc_msgSend( v5,  "computeCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1040);
        [v14 insertCompressedTextureReinterpretationFlush];
        goto LABEL_1041;
      case -15509:
        v437 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v437]);
        v1041 = GTTraceFunc_argumentBytesWithMap(a2, v437[16], v4);
        MTLBufferDescriptor = MakeMTLBufferDescriptor((uint64_t)v1041);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLBufferDescriptor);
        v440 = [v106 newBufferWithDescriptor:v108];
LABEL_814:
        v191 = v440;
        v192 = *((void *)v437 + 1);
        if (!v440) {
          goto LABEL_1425;
        }
        [v5 setBuffer:v440 forKey:v192];
        goto LABEL_1427;
      case -15506:
        v1043 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1044 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1043]);
        goto LABEL_1008;
      case -15505:
        v1045 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)v1045]);
        [v12 setParentGPUAddress:*((void *)v1045 + 1)];
        break;
      case -15504:
        v1046 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)v1046]);
        [v12 setParentGPUSize:*((void *)v1046 + 1)];
        break;
      case -15502:
        v1047 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1047]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1047 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1047 + 2)]);
        [v12 writeCompactedAccelerationStructureSize:v18 toBuffer:v93 offset:*((void *)v1047 + 3) sizeDataType:*((void *)v1047 + 4)];
        goto LABEL_1063;
      case -15501:
        v1048 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1048]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 resourceGroupSPIForKey:*((void *)v1048 + 1)]);
        [v12 encodeDashboardFinalizeForResourceGroup:v18 dashboard:*((void *)v1048 + 2) value:*((void *)v1048 + 3) forIndex:*((void *)v1048 + 4)];
        goto LABEL_1064;
      case -15500:
        v1049 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1049]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceGroupSPIForKey:*((void *)v1049 + 1)]);
        [v12 encodeDashboardTagForResourceGroup:v33];
        goto LABEL_1131;
      case -15496:
        v1050 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1050]);
        v18 = [v12 newLateEvalEvent];
        v19 = *((void *)v1050 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setLateEvalEvent:v18 forKey:v19];
        goto LABEL_1064;
      case -15495:
        objc_msgSend( v5,  "removeFunctionPointerHandleForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15494:
        objc_msgSend( v5,  "removeFunctionPrivateArgumentForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15491:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 lateEvalEventForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15490:
        v700 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v701 = (void *)objc_claimAutoreleasedReturnValue([v5 lateEvalEventForKey:*(void *)v700]);
LABEL_828:
        v12 = v701;
        [v701 setSignaledValue:*((void *)v700 + 1)];
        break;
      case -15489:
        objc_msgSend( v5,  "removeLateEvalEventForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15488:
        v1051 = objc_msgSend( v5,  "lateEvalEventForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1051);
        v741 = [v14 newSharedEventHandle];
LABEL_831:

        goto LABEL_1041;
      case -15486:
        v1052 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1052]);
        v1053 = *(_OWORD *)(v1052 + 8);
        v1612 = *((void *)v1052 + 3);
        v1054 = *((_OWORD *)v1052 + 3);
        v1610[0] = *((_OWORD *)v1052 + 2);
        v1610[1] = v1054;
        v1610[2] = *((_OWORD *)v1052 + 4);
        v1611 = v1053;
        [v12 dispatchThreadsPerTile:&v1611 inRegion:v1610];
        break;
      case -15475:
        v1055 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1055]);
        v204 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v1055 + 1)]);
        v1056 = (void *)objc_claimAutoreleasedReturnValue([v5 binaryArchiveForKey:*((void *)v1055 + 2)]);
        v1057 = GTTraceFunc_argumentBytesWithMap(a2, v1055[32], v4);
        v1058 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1059 = MakeMTLFunctionDescriptor((uint64_t)v1057, v1058);
        v1060 = (void *)objc_claimAutoreleasedReturnValue(v1059);

        v1670 = 0LL;
        [v60 compileVisibleFunction:v204 withDescriptor:v1060 destinationBinaryArchive:v1056 error:&v1670];
        v6 = v1670;

        goto LABEL_1398;
      case -15474:
        v1061 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v1061]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1061 + 1)]);
        objc_msgSend( v12,  "fillBuffer:range:pattern4:",  v18,  *((void *)v1061 + 2),  *((void *)v1061 + 3),  *((unsigned int *)v1061 + 8));
        goto LABEL_1064;
      case -15473:
        v1062 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v1062]);
        v802 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1062 + 1)]);
        v1063 = *((void *)v1062 + 2);
        v1064 = *((void *)v1062 + 3);
        v1065 = *((_OWORD *)v1062 + 3);
        v1686[0] = *((_OWORD *)v1062 + 2);
        v1686[1] = v1065;
        v1686[2] = *((_OWORD *)v1062 + 4);
        objc_msgSend( v56,  "fillTexture:level:slice:region:bytes:length:",  v802,  v1063,  v1064,  v1686,  GTTraceFunc_argumentBytesWithMap(a2, v1062[88], v4),  *((void *)v1062 + 10));
        goto LABEL_1054;
      case -15472:
        v1066 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v1066]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1066 + 1)]);
        v1067 = *((void *)v1066 + 2);
        v1068 = *((void *)v1066 + 3);
        v1069 = *((_OWORD *)v1066 + 3);
        v1685[0] = *((_OWORD *)v1066 + 2);
        v1685[1] = v1069;
        v1685[2] = *((_OWORD *)v1066 + 4);
        objc_msgSend( v12,  "fillTexture:level:slice:region:color:",  v18,  v1067,  v1068,  v1685,  *((double *)v1066 + 10),  *((double *)v1066 + 11),  *((double *)v1066 + 12),  *((double *)v1066 + 13));
        goto LABEL_1064;
      case -15471:
        v1070 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v1070]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1070 + 1)]);
        v1071 = *((void *)v1070 + 2);
        v1072 = *((void *)v1070 + 3);
        v1073 = *((_OWORD *)v1070 + 3);
        v1684[0] = *((_OWORD *)v1070 + 2);
        v1684[1] = v1073;
        v1684[2] = *((_OWORD *)v1070 + 4);
        objc_msgSend( v12,  "fillTexture:level:slice:region:color:pixelFormat:",  v18,  v1071,  v1072,  v1684,  *((void *)v1070 + 14),  *((double *)v1070 + 10),  *((double *)v1070 + 11),  *((double *)v1070 + 12),  *((double *)v1070 + 13));
        goto LABEL_1064;
      case -15470:
        v1074 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v1074]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1074 + 1)]);
        [v12 invalidateCompressedTexture:v33];
        goto LABEL_1131;
      case -15469:
        v1075 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 blitCommandEncoderForKey:*(void *)v1075]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1075 + 1)]);
        [v12 invalidateCompressedTexture:v18 slice:*((void *)v1075 + 2) level:*((void *)v1075 + 3)];
        goto LABEL_1064;
      case -15466:
        v1076 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1076]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1076 + 1)]);
        v1077 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1076 + 2)]);
        v1078 = GTTraceFunc_argumentBytesWithMap(a2, v1076[32], v4);
        v1079 = (uint64_t *)(v1078 + 8);
        v1080 = *(_DWORD *)v1078;
        v1081 = v5;
        v1082 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1083 = MakeNSArray(v1079, v1080, v1082);
        v1084 = (void *)objc_claimAutoreleasedReturnValue(v1083);

        v5 = v1081;
        v1085 = *((void *)v1076 + 3);
        v1086 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v1076[33], v4);
        v1087 = (void *)objc_claimAutoreleasedReturnValue([v1081 resources]);
        v1088 = MakeMTLAccelerationStructureDescriptor(v1086, v1087);
        v1089 = (void *)objc_claimAutoreleasedReturnValue(v1088);
        [v106 deserializeInstanceAccelerationStructure:v243 primitiveAccelerationStructures:v1084 fromBuffer:v1077 serializedBufferOffset:v1085 withDescriptor:v1089];
        goto LABEL_979;
      case -15465:
        v1090 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1090]);
        v847 = (dispatch_data_t)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1090 + 1)]);
        v901 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1090 + 2)]);
        v1091 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v1090[32], v4);
        v1092 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1093 = MakeMTLAccelerationStructureDescriptor(v1091, v1092);
        v905 = (void *)objc_claimAutoreleasedReturnValue(v1093);

        [v106 deserializePrimitiveAccelerationStructure:v847 fromBuffer:v901 serializedBufferOffset:*((void *)v1090 + 3) withDescriptor:v905];
LABEL_842:

        goto LABEL_987;
      case -15464:
        v1094 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1094]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1094 + 2)]);
        if ((GT_SUPPORT_0 & 0x100000) != 0) {
          v1095 = objc_msgSend( v12,  "newAccelerationStructureWithBuffer:offset:resourceIndex:",  v18,  *((void *)v1094 + 3),  GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40), *((void *)v1094 + 1), *a2)[19]);
        }
        else {
          v1095 = [v12 newAccelerationStructureWithBuffer:v18 offset:*((void *)v1094 + 3)];
        }
        v1476 = v1095;
        v1477 = *((void *)v1094 + 1);
        if (v1095)
        {
          [v5 setAccelerationStructure:v1095 forKey:v1477];
        }

        else if (v1477)
        {
          GTMTLReplay_dispatchFailedToSet((uint64_t)a2, *((void *)v1094 + 1));
        }

        goto LABEL_1064;
      case -15463:
        v930 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v930]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v930 + 2)]);
        v931 = objc_claimAutoreleasedReturnValue([v12 functionHandleWithFunction:v18 stage:*((void *)v930 + 3)]);
        goto LABEL_895;
      case -15462:
        v997 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v997]);
        v1096 = (uint64_t (*)(void))MakeMTLIntersectionFunctionTableDescriptor;
        v1097 = GTTraceFunc_argumentBytesWithMap(a2, v997[24], v4);
        v1098 = v1096(v1097);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1098);
        v1008 = [v106 newIntersectionFunctionTableWithDescriptor:v108 stage:*((void *)v997 + 2)];
        goto LABEL_886;
      case -15461:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v222]);
        v1099 = GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v1100 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        MTLRenderPipelineFunctionsDescriptor = MakeMTLRenderPipelineFunctionsDescriptor((uint64_t)v1099, v1100);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLRenderPipelineFunctionsDescriptor);

        v1590 = 0LL;
        v225 = [v60 newRenderPipelineStateWithAdditionalBinaryFunctions:v204 error:&v1590];
        v226 = v1590;
        goto LABEL_923;
      case -15460:
        v992 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v992]);
        v1102 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptor;
        v1103 = GTTraceFunc_argumentBytesWithMap(a2, v992[24], v4);
        v1104 = v1102(v1103);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1104);
        v996 = [v106 newVisibleFunctionTableWithDescriptor:v108 stage:*((void *)v992 + 2)];
        goto LABEL_891;
      case -15459:
        v1105 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1105]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1105 + 1)]);
        [v12 setFragmentAccelerationStructure:v18 atBufferIndex:*((void *)v1105 + 2)];
        goto LABEL_1064;
      case -15458:
        v1106 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1106]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*((void *)v1106 + 1)]);
        [v12 setFragmentIntersectionFunctionTable:v18 atBufferIndex:*((void *)v1106 + 2)];
        goto LABEL_1064;
      case -15457:
        v1107 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1107]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1108 = apr_palloc(v623, 8LL * *((void *)v1107 + 2));
        v1109 = GTTraceFunc_argumentBytesWithMap(a2, v1107[24], v4);
        if (*((void *)v1107 + 2))
        {
          v1110 = v1109;
          v1111 = 0LL;
          do
          {
            v1108[v1111] = [v5 intersectionFunctionTableForKey:*(void *)&v1110[8 * v1111]];
            ++v1111;
            v1112 = *((void *)v1107 + 2);
          }

          while (v1112 > v1111);
        }

        else
        {
          v1112 = 0LL;
        }

        objc_msgSend( v106,  "setFragmentIntersectionFunctionTables:withBufferRange:",  v1108,  *((void *)v1107 + 1),  v1112);
        goto LABEL_1352;
      case -15456:
        v1113 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1113]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 visibleFunctionTableForKey:*((void *)v1113 + 1)]);
        [v12 setFragmentVisibleFunctionTable:v18 atBufferIndex:*((void *)v1113 + 2)];
        goto LABEL_1064;
      case -15455:
        v1114 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1114]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1115 = apr_palloc(v623, 8LL * *((void *)v1114 + 2));
        v1116 = GTTraceFunc_argumentBytesWithMap(a2, v1114[24], v4);
        if (*((void *)v1114 + 2))
        {
          v1117 = v1116;
          v1118 = 0LL;
          do
          {
            v1115[v1118] = [v5 visibleFunctionTableForKey:*(void *)&v1117[8 * v1118]];
            ++v1118;
            v1119 = *((void *)v1114 + 2);
          }

          while (v1119 > v1118);
        }

        else
        {
          v1119 = 0LL;
        }

        objc_msgSend(v106, "setFragmentVisibleFunctionTables:withBufferRange:", v1115, *((void *)v1114 + 1), v1119);
        goto LABEL_1352;
      case -15454:
        v1120 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1120]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1120 + 1)]);
        [v12 setTileAccelerationStructure:v18 atBufferIndex:*((void *)v1120 + 2)];
        goto LABEL_1064;
      case -15453:
        v1121 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1121]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*((void *)v1121 + 1)]);
        [v12 setTileIntersectionFunctionTable:v18 atBufferIndex:*((void *)v1121 + 2)];
        goto LABEL_1064;
      case -15452:
        v1122 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1122]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1123 = apr_palloc(v623, 8LL * *((void *)v1122 + 2));
        v1124 = GTTraceFunc_argumentBytesWithMap(a2, v1122[24], v4);
        if (*((void *)v1122 + 2))
        {
          v1125 = v1124;
          v1126 = 0LL;
          do
          {
            v1123[v1126] = [v5 intersectionFunctionTableForKey:*(void *)&v1125[8 * v1126]];
            ++v1126;
            v1127 = *((void *)v1122 + 2);
          }

          while (v1127 > v1126);
        }

        else
        {
          v1127 = 0LL;
        }

        objc_msgSend(v106, "setTileIntersectionFunctionTables:withBufferRange:", v1123, *((void *)v1122 + 1), v1127);
        goto LABEL_1352;
      case -15451:
        v1128 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1128]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 visibleFunctionTableForKey:*((void *)v1128 + 1)]);
        [v12 setTileVisibleFunctionTable:v18 atBufferIndex:*((void *)v1128 + 2)];
        goto LABEL_1064;
      case -15450:
        v1129 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1129]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1130 = apr_palloc(v623, 8LL * *((void *)v1129 + 2));
        v1131 = GTTraceFunc_argumentBytesWithMap(a2, v1129[24], v4);
        if (*((void *)v1129 + 2))
        {
          v1132 = v1131;
          v1133 = 0LL;
          do
          {
            v1130[v1133] = [v5 visibleFunctionTableForKey:*(void *)&v1132[8 * v1133]];
            ++v1133;
            v1134 = *((void *)v1129 + 2);
          }

          while (v1134 > v1133);
        }

        else
        {
          v1134 = 0LL;
        }

        objc_msgSend(v106, "setTileVisibleFunctionTables:withBufferRange:", v1130, *((void *)v1129 + 1), v1134);
        goto LABEL_1352;
      case -15449:
        v1135 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1135]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1135 + 1)]);
        [v12 setVertexAccelerationStructure:v18 atBufferIndex:*((void *)v1135 + 2)];
        goto LABEL_1064;
      case -15448:
        v1136 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1136]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 intersectionFunctionTableForKey:*((void *)v1136 + 1)]);
        [v12 setVertexIntersectionFunctionTable:v18 atBufferIndex:*((void *)v1136 + 2)];
        goto LABEL_1064;
      case -15447:
        v1137 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1137]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1138 = apr_palloc(v623, 8LL * *((void *)v1137 + 2));
        v1139 = GTTraceFunc_argumentBytesWithMap(a2, v1137[24], v4);
        if (*((void *)v1137 + 2))
        {
          v1140 = v1139;
          v1141 = 0LL;
          do
          {
            v1138[v1141] = [v5 intersectionFunctionTableForKey:*(void *)&v1140[8 * v1141]];
            ++v1141;
            v1142 = *((void *)v1137 + 2);
          }

          while (v1142 > v1141);
        }

        else
        {
          v1142 = 0LL;
        }

        objc_msgSend(v106, "setVertexIntersectionFunctionTables:withBufferRange:", v1138, *((void *)v1137 + 1), v1142);
        goto LABEL_1352;
      case -15446:
        v1143 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1143]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 visibleFunctionTableForKey:*((void *)v1143 + 1)]);
        [v12 setVertexVisibleFunctionTable:v18 atBufferIndex:*((void *)v1143 + 2)];
        goto LABEL_1064;
      case -15445:
        v1144 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1144]);
        v623 = **(apr_pool_t ***)(a1 + 152);
        v1145 = apr_palloc(v623, 8LL * *((void *)v1144 + 2));
        v1146 = GTTraceFunc_argumentBytesWithMap(a2, v1144[24], v4);
        if (*((void *)v1144 + 2))
        {
          v1147 = v1146;
          v1148 = 0LL;
          do
          {
            v1145[v1148] = [v5 visibleFunctionTableForKey:*(void *)&v1147[8 * v1148]];
            ++v1148;
            v1149 = *((void *)v1144 + 2);
          }

          while (v1149 > v1148);
        }

        else
        {
          v1149 = 0LL;
        }

        objc_msgSend(v106, "setVertexVisibleFunctionTables:withBufferRange:", v1145, *((void *)v1144 + 1), v1149);
LABEL_1352:
        v1531 = v623;
        goto LABEL_1390;
      case -15444:
        v930 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v930]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v930 + 2)]);
        v931 = objc_claimAutoreleasedReturnValue([v12 fragmentFunctionHandleWithFunction:v18]);
        goto LABEL_895;
      case -15443:
        v997 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v997]);
        v1150 = (uint64_t (*)(void))MakeMTLIntersectionFunctionTableDescriptor;
        v1151 = GTTraceFunc_argumentBytesWithMap(a2, v997[16], v4);
        v1152 = v1150(v1151);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1152);
        v1008 = [v106 newFragmentIntersectionFunctionTableWithDescriptor:v108];
        goto LABEL_886;
      case -15442:
        v997 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v997]);
        v1153 = (uint64_t (*)(void))MakeMTLIntersectionFunctionTableDescriptor;
        v1154 = GTTraceFunc_argumentBytesWithMap(a2, v997[16], v4);
        v1155 = v1153(v1154);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1155);
        v1008 = [v106 newTileIntersectionFunctionTableWithDescriptor:v108];
        goto LABEL_886;
      case -15441:
        v997 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v997]);
        v1156 = (uint64_t (*)(void))MakeMTLIntersectionFunctionTableDescriptor;
        v1157 = GTTraceFunc_argumentBytesWithMap(a2, v997[16], v4);
        v1158 = v1156(v1157);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1158);
        v1008 = [v106 newVertexIntersectionFunctionTableWithDescriptor:v108];
LABEL_886:
        v191 = v1008;
        v192 = *((void *)v997 + 1);
        if (!v1008) {
          goto LABEL_1425;
        }
        [v5 setIntersectionFunctionTable:v1008 forKey:v192];
        goto LABEL_1427;
      case -15440:
        v992 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v992]);
        v1159 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptor;
        v1160 = GTTraceFunc_argumentBytesWithMap(a2, v992[16], v4);
        v1161 = v1159(v1160);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1161);
        v996 = [v106 newVisibleFunctionTableFromFragmentStageWithDescriptor:v108];
        goto LABEL_891;
      case -15439:
        v992 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v992]);
        v1162 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptor;
        v1163 = GTTraceFunc_argumentBytesWithMap(a2, v992[16], v4);
        v1164 = v1162(v1163);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1164);
        v996 = [v106 newVisibleFunctionTableFromTileStageWithDescriptor:v108];
        goto LABEL_891;
      case -15438:
        v992 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v992]);
        v1165 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptor;
        v1166 = GTTraceFunc_argumentBytesWithMap(a2, v992[16], v4);
        v1167 = v1165(v1166);
        v108 = (id)objc_claimAutoreleasedReturnValue(v1167);
        v996 = [v106 newVisibleFunctionTableFromVertexStageWithDescriptor:v108];
LABEL_891:
        v191 = v996;
        v192 = *((void *)v992 + 1);
        if (!v996) {
          goto LABEL_1425;
        }
        [v5 setVisibleFunctionTable:v996 forKey:v192];
        goto LABEL_1427;
      case -15437:
        v930 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v930]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v930 + 2)]);
        v931 = objc_claimAutoreleasedReturnValue([v12 tileFunctionHandleWithFunction:v18]);
        goto LABEL_895;
      case -15436:
        v930 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*(void *)v930]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 functionForKey:*((void *)v930 + 2)]);
        v931 = objc_claimAutoreleasedReturnValue([v12 vertexFunctionHandleWithFunction:v18]);
LABEL_895:
        v93 = (id)v931;
        v743 = *((void *)v930 + 1);
        if (!v931) {
          goto LABEL_990;
        }
        [v5 setFunctionHandle:v931 forKey:v743];
        goto LABEL_1063;
      case -15435:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v1168 = GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4);
        v1169 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        MTLStitchedLibraryDescriptor = MakeMTLStitchedLibraryDescriptor((uint64_t)v1168, v1169);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLStitchedLibraryDescriptor);

        v1659 = 0LL;
        v225 = [v60 newLibraryWithDescriptor:v204 error:&v1659];
        v766 = v1659;
        goto LABEL_912;
      case -15434:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v1171 = GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4);
        v1172 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        MTLStitchedLibraryDescriptorSPI = MakeMTLStitchedLibraryDescriptorSPI((uint64_t)v1171, v1172);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLStitchedLibraryDescriptorSPI);

        v1658 = 0LL;
        v225 = [v60 newLibraryWithDescriptorSPI:v204 error:&v1658];
        v766 = v1658;
        goto LABEL_912;
      case -15430:
        v843 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v843]);
        v844 = objc_msgSend( v106,  "newFunctionWithGLCoreIR:functionType:",  GTTraceFunc_argumentBytesWithMap(a2, v843[24], v4),  *((void *)v843 + 2));
        goto LABEL_903;
      case -15429:
        v845 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v845]);
        v1174 = GTTraceFunc_argumentBlobWithMap(a2, v845[25], v4);
        if (v1174) {
          v847 = dispatch_data_create( (const void *)(v1174 + 16),  *(unsigned int *)(v1174 + 12),  0LL,  &__block_literal_global_2334);
        }
        else {
          v847 = 0LL;
        }
        v1530 = objc_msgSend( v106,  "newFunctionWithGLCoreIR:inputsDescription:functionType:",  GTTraceFunc_argumentBytesWithMap(a2, v845[24], v4),  v847,  *((void *)v845 + 2));
        goto LABEL_1357;
      case -15428:
        v843 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v843]);
        v844 = objc_msgSend( v106,  "newFunctionWithGLESIR:functionType:",  GTTraceFunc_argumentBytesWithMap(a2, v843[24], v4),  *((void *)v843 + 2));
LABEL_903:
        v108 = v844;
        v868 = *((void *)v843 + 1);
        if (!v844) {
          goto LABEL_1437;
        }
        goto LABEL_1290;
      case -15427:
        v845 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v845]);
        v1175 = GTTraceFunc_argumentBlobWithMap(a2, v845[25], v4);
        if (v1175) {
          v847 = dispatch_data_create( (const void *)(v1175 + 16),  *(unsigned int *)(v1175 + 12),  0LL,  &__block_literal_global_35_2335);
        }
        else {
          v847 = 0LL;
        }
        v1530 = objc_msgSend( v106,  "newFunctionWithGLESIR:inputsDescription:functionType:",  GTTraceFunc_argumentBytesWithMap(a2, v845[24], v4),  v847,  *((void *)v845 + 2));
LABEL_1357:
        v974 = v1530;
        v976 = *((void *)v845 + 1);
        if (v1530)
        {
          [v5 setFunction:v1530 forKey:v976];
        }

        else
        {
LABEL_1359:
          if (v976) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v976);
          }
        }

LABEL_1361:
        goto LABEL_1362;
      case -15426:
        v1176 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 binaryArchiveForKey:*(void *)v1176]);
        v1177 = GTTraceFunc_argumentBytesWithMap(a2, v1176[20], v4);
        v1178 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1179 = MakeMTLStitchedLibraryDescriptor((uint64_t)v1177, v1178);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1179);

        v1715 = 0LL;
        [v60 addLibraryWithDescriptor:v204 error:&v1715];
        v6 = v1715;
        goto LABEL_1398;
      case -15425:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v1180 = GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4);
        v1181 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1182 = MakeMTLStitchedLibraryDescriptor((uint64_t)v1180, v1181);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1182);

        v1660 = 0LL;
        v225 = [v60 newLibraryWithDescriptor:v204 error:&v1660];
        v766 = v1660;
        goto LABEL_912;
      case -15421:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v1183 = GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4);
        v1184 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1185 = MakeMTLStitchedLibraryDescriptor((uint64_t)v1183, v1184);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1185);

        v1657 = 0LL;
        v225 = [v60 newLibraryWithStitchedDescriptor:v204 error:&v1657];
        v766 = v1657;
        goto LABEL_912;
      case -15420:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v1186 = GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4);
        v1187 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1188 = MakeMTLStitchedLibraryDescriptor((uint64_t)v1186, v1187);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1188);

        v1656 = 0LL;
        v225 = [v60 newLibraryWithStitchedDescriptor:v204 error:&v1656];
        v766 = v1656;
        goto LABEL_912;
      case -15419:
        v758 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v758]);
        v1189 = GTTraceFunc_argumentBytesWithMap(a2, v758[24], v4);
        v1190 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
        v1191 = MakeMTLStitchedLibraryDescriptorSPI((uint64_t)v1189, v1190);
        v204 = (id)objc_claimAutoreleasedReturnValue(v1191);

        v1655 = 0LL;
        v225 = [v60 newLibraryWithStitchedDescriptorSPI:v204 error:&v1655];
        v766 = v1655;
LABEL_912:
        v6 = v766;
LABEL_913:
        v509 = *((void *)v758 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setLibrary:v225 forKey:v509];
        goto LABEL_1397;
      case -15416:
        v1192 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1193 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1192]);
        v12 = v1193;
        v1194 = *((void *)v1192 + 3);
        v1605 = *(_OWORD *)(v1192 + 8);
        v1606 = v1194;
        v1195 = *((void *)v1192 + 6);
        v1603 = *((_OWORD *)v1192 + 2);
        v1604 = v1195;
        v1196 = *((void *)v1192 + 9);
        v1601 = *(_OWORD *)(v1192 + 56);
        v1602 = v1196;
        v1197 = &v1605;
        v1198 = &v1603;
        v1199 = &v1601;
        goto LABEL_1092;
      case -15415:
        v1200 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1200]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1200 + 1)]);
        v1201 = *((void *)v1200 + 2);
        v1202 = *((void *)v1200 + 5);
        v1599 = *(_OWORD *)(v1200 + 24);
        v1600 = v1202;
        v1203 = *((void *)v1200 + 8);
        v1597 = *((_OWORD *)v1200 + 3);
        v1598 = v1203;
        [v12 drawMeshThreadgroupsWithIndirectBuffer:v18 indirectBufferOffset:v1201 threadsPerObjectThreadgroup:&v1599 threadsPerMeshThreadgroup:&v1597];
        goto LABEL_1064;
      case -15414:
        v1204 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1205 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1204]);
        v12 = v1205;
        v1206 = *((void *)v1204 + 3);
        v1595 = *(_OWORD *)(v1204 + 8);
        v1596 = v1206;
        v1207 = *((void *)v1204 + 6);
        v1593 = *((_OWORD *)v1204 + 2);
        v1594 = v1207;
        v1208 = *((void *)v1204 + 9);
        v1591 = *(_OWORD *)(v1204 + 56);
        v1592 = v1208;
        v1209 = &v1595;
        v1210 = &v1593;
        v1211 = &v1591;
        goto LABEL_1094;
      case -15410:
        v1212 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1212]);
        v802 = (void *)objc_claimAutoreleasedReturnValue([v5 resourceGroupSPIForKey:*((void *)v1212 + 1)]);
        v1213 = GTTraceFunc_argumentBytesWithMap(a2, v1212[32], v4);
        objc_msgSend( v56,  "encodeDashboardFinalizeForResourceGroup:dashboard:values:indices:count:",  v802,  *((void *)v1212 + 2),  v1213,  GTTraceFunc_argumentBytesWithMap(a2, v1212[33], v4),  *((void *)v1212 + 3));
        goto LABEL_1054;
      case -15406:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v1214 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        MTLMeshRenderPipelineDescriptor = _MakeMTLMeshRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptor);

        v1650 = 0LL;
        v225 = [v60 newRenderPipelineStateWithMeshDescriptor:v204 error:&v1650];
        v226 = v1650;
        goto LABEL_923;
      case -15405:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[24], v4);
        v1216 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v1217 = _MakeMTLMeshRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v1217);

        v1649 = 0LL;
        v225 = [v60 newRenderPipelineStateWithMeshDescriptor:v204 error:&v1649];
        v226 = v1649;
        goto LABEL_923;
      case -15404:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[32], v4);
        v1218 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v1219 = _MakeMTLMeshRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v1219);

        v1220 = *((void *)v222 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1648 = 0LL;
        v225 = [v60 newRenderPipelineStateWithMeshDescriptor:v204 options:v1220 reflection:0 error:&v1648];
        v226 = v1648;
        goto LABEL_923;
      case -15403:
        v222 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v222]);
        GTTraceFunc_argumentBytesWithMap(a2, v222[32], v4);
        v1221 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineDescriptorMap]);
        v1222 = _MakeMTLMeshRenderPipelineDescriptor();
        v204 = (id)objc_claimAutoreleasedReturnValue(v1222);

        v1223 = *((void *)v222 + 2) & 0xFFFFFFFFFFFFFFFBLL;
        v1647 = 0LL;
        v225 = [v60 newRenderPipelineStateWithMeshDescriptor:v204 options:v1223 reflection:0 error:&v1647];
        v226 = v1647;
LABEL_923:
        v6 = v226;
        v509 = *((void *)v222 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setRenderPipelineState:v225 forKey:v509];
        goto LABEL_1397;
      case -15401:
        v1224 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1225 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1224]);
        goto LABEL_1096;
      case -15400:
        v1226 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1226]);
        [v12 setMeshBufferOffset:*((void *)v1226 + 1) atIndex:*((void *)v1226 + 2)];
        break;
      case -15399:
        v1227 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1227]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1228 = GTTraceFunc_argumentBytesWithMap(a2, v1227[24], v4);
        if (*((void *)v1227 + 2))
        {
          v1229 = v1228;
          v1230 = 0LL;
          do
          {
            v1231 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v1229[8 * v1230]]);
            v1232 = *(void **)&buf[8 * v1230];
            *(void *)&buf[8 * v1230] = v1231;

            ++v1230;
          }

          while (*((void *)v1227 + 2) > v1230);
        }

        objc_msgSend( v106,  "setMeshBuffers:offsets:withRange:",  buf,  GTTraceFunc_argumentBytesWithMap(a2, v1227[25], v4),  *((void *)v1227 + 1),  *((void *)v1227 + 2));
        for (i10 = 240LL; i10 != -8; i10 -= 8LL)

        goto LABEL_1429;
      case -15398:
        v1234 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1234]);
        objc_msgSend( v56,  "setMeshBytes:length:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v1234[24], v4),  *((void *)v1234 + 1),  *((void *)v1234 + 2));
        goto LABEL_1090;
      case -15397:
        v1235 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1235]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v1235 + 1)]);
        [v12 setMeshSamplerState:v18 atIndex:*((void *)v1235 + 2)];
        goto LABEL_1064;
      case -15396:
        v1236 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1236]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v1236 + 1)]);
        LODWORD(v1237) = *((_DWORD *)v1236 + 6);
        LODWORD(v1238) = *((_DWORD *)v1236 + 7);
        [v12 setMeshSamplerState:v18 lodMinClamp:*((void *)v1236 + 2) lodMaxClamp:v1237 atIndex:v1238];
        goto LABEL_1064;
      case -15395:
        v1239 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1239]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1240 = GTTraceFunc_argumentBytesWithMap(a2, v1239[24], v4);
        if (*((void *)v1239 + 2))
        {
          v1241 = v1240;
          v1242 = 0LL;
          do
          {
            v1243 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v1241[8 * v1242]]);
            v1244 = *(void **)&buf[8 * v1242];
            *(void *)&buf[8 * v1242] = v1243;

            ++v1242;
          }

          while (*((void *)v1239 + 2) > v1242);
        }

        v1245 = GTTraceFunc_argumentBytesWithMap(a2, v1239[25], v4);
        objc_msgSend( v106,  "setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  buf,  v1245,  GTTraceFunc_argumentBytesWithMap(a2, v1239[26], v4),  *((void *)v1239 + 1),  *((void *)v1239 + 2));
        for (i11 = 120LL; i11 != -8; i11 -= 8LL)

        goto LABEL_1429;
      case -15394:
        v1247 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1247]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1248 = GTTraceFunc_argumentBytesWithMap(a2, v1247[24], v4);
        if (*((void *)v1247 + 2))
        {
          v1249 = v1248;
          v1250 = 0LL;
          do
          {
            v1251 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v1249[8 * v1250]]);
            v1252 = *(void **)&buf[8 * v1250];
            *(void *)&buf[8 * v1250] = v1251;

            ++v1250;
            v1253 = *((void *)v1247 + 2);
          }

          while (v1253 > v1250);
        }

        else
        {
          v1253 = 0LL;
        }

        objc_msgSend(v106, "setMeshSamplerStates:withRange:", buf, *((void *)v1247 + 1), v1253);
        for (i12 = 120LL; i12 != -8; i12 -= 8LL)

        goto LABEL_1429;
      case -15393:
        v1254 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1254]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1254 + 1)]);
        [v12 setMeshTexture:v18 atIndex:*((void *)v1254 + 2)];
        goto LABEL_1064;
      case -15392:
        v1255 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1255]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1256 = GTTraceFunc_argumentBytesWithMap(a2, v1255[24], v4);
        if (*((void *)v1255 + 2))
        {
          v1257 = v1256;
          v1258 = 0LL;
          do
          {
            v1259 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v1257[8 * v1258]]);
            v1260 = *(void **)&buf[8 * v1258];
            *(void *)&buf[8 * v1258] = v1259;

            ++v1258;
            v1261 = *((void *)v1255 + 2);
          }

          while (v1261 > v1258);
        }

        else
        {
          v1261 = 0LL;
        }

        objc_msgSend(v106, "setMeshTextures:withRange:", buf, *((void *)v1255 + 1), v1261);
        for (i13 = 240LL; i13 != -8; i13 -= 8LL)

        goto LABEL_1429;
      case -15391:
        v1262 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1263 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1262]);
        goto LABEL_1098;
      case -15390:
        v1264 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1264]);
        [v12 setObjectBufferOffset:*((void *)v1264 + 1) atIndex:*((void *)v1264 + 2)];
        break;
      case -15389:
        v1265 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1265]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1266 = GTTraceFunc_argumentBytesWithMap(a2, v1265[24], v4);
        if (*((void *)v1265 + 2))
        {
          v1267 = v1266;
          v1268 = 0LL;
          do
          {
            v1269 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v1267[8 * v1268]]);
            v1270 = *(void **)&buf[8 * v1268];
            *(void *)&buf[8 * v1268] = v1269;

            ++v1268;
          }

          while (*((void *)v1265 + 2) > v1268);
        }

        objc_msgSend( v106,  "setObjectBuffers:offsets:withRange:",  buf,  GTTraceFunc_argumentBytesWithMap(a2, v1265[25], v4),  *((void *)v1265 + 1),  *((void *)v1265 + 2));
        for (i14 = 240LL; i14 != -8; i14 -= 8LL)

        goto LABEL_1429;
      case -15388:
        v1272 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1272]);
        objc_msgSend( v56,  "setObjectBytes:length:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v1272[24], v4),  *((void *)v1272 + 1),  *((void *)v1272 + 2));
        goto LABEL_1090;
      case -15387:
        v1273 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1273]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v1273 + 1)]);
        [v12 setObjectSamplerState:v18 atIndex:*((void *)v1273 + 2)];
        goto LABEL_1064;
      case -15386:
        v1274 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1274]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*((void *)v1274 + 1)]);
        LODWORD(v1275) = *((_DWORD *)v1274 + 6);
        LODWORD(v1276) = *((_DWORD *)v1274 + 7);
        [v12 setObjectSamplerState:v18 lodMinClamp:*((void *)v1274 + 2) lodMaxClamp:v1275 atIndex:v1276];
        goto LABEL_1064;
      case -15385:
        v1277 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1277]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1278 = GTTraceFunc_argumentBytesWithMap(a2, v1277[24], v4);
        if (*((void *)v1277 + 2))
        {
          v1279 = v1278;
          v1280 = 0LL;
          do
          {
            v1281 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v1279[8 * v1280]]);
            v1282 = *(void **)&buf[8 * v1280];
            *(void *)&buf[8 * v1280] = v1281;

            ++v1280;
          }

          while (*((void *)v1277 + 2) > v1280);
        }

        v1283 = GTTraceFunc_argumentBytesWithMap(a2, v1277[25], v4);
        objc_msgSend( v106,  "setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  buf,  v1283,  GTTraceFunc_argumentBytesWithMap(a2, v1277[26], v4),  *((void *)v1277 + 1),  *((void *)v1277 + 2));
        for (i15 = 120LL; i15 != -8; i15 -= 8LL)

        goto LABEL_1429;
      case -15384:
        v1285 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1285]);
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1286 = GTTraceFunc_argumentBytesWithMap(a2, v1285[24], v4);
        if (*((void *)v1285 + 2))
        {
          v1287 = v1286;
          v1288 = 0LL;
          do
          {
            v1289 = objc_claimAutoreleasedReturnValue([v5 samplerStateForKey:*(void *)&v1287[8 * v1288]]);
            v1290 = *(void **)&buf[8 * v1288];
            *(void *)&buf[8 * v1288] = v1289;

            ++v1288;
            v1291 = *((void *)v1285 + 2);
          }

          while (v1291 > v1288);
        }

        else
        {
          v1291 = 0LL;
        }

        objc_msgSend(v106, "setObjectSamplerStates:withRange:", buf, *((void *)v1285 + 1), v1291);
        for (i16 = 120LL; i16 != -8; i16 -= 8LL)

        goto LABEL_1429;
      case -15383:
        v1292 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1292]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1292 + 1)]);
        [v12 setObjectTexture:v18 atIndex:*((void *)v1292 + 2)];
        goto LABEL_1064;
      case -15382:
        v1293 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1293]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1294 = GTTraceFunc_argumentBytesWithMap(a2, v1293[24], v4);
        if (*((void *)v1293 + 2))
        {
          v1295 = v1294;
          v1296 = 0LL;
          do
          {
            v1297 = objc_claimAutoreleasedReturnValue([v5 textureForKey:*(void *)&v1295[8 * v1296]]);
            v1298 = *(void **)&buf[8 * v1296];
            *(void *)&buf[8 * v1296] = v1297;

            ++v1296;
            v1299 = *((void *)v1293 + 2);
          }

          while (v1299 > v1296);
        }

        else
        {
          v1299 = 0LL;
        }

        objc_msgSend(v106, "setObjectTextures:withRange:", buf, *((void *)v1293 + 1), v1299);
        for (i17 = 240LL; i17 != -8; i17 -= 8LL)

        goto LABEL_1429;
      case -15381:
        v1300 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1301 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1300]);
        goto LABEL_1100;
      case -15366:
        v1302 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1302]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1302 + 1)]);
        v1077 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1302 + 2)]);
        v1084 = (void *)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1302 + 3)]);
        v1303 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v1302[48], v4);
        v1087 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1304 = MakeMTLAccelerationStructureDescriptor(v1303, v1087);
        v1089 = (void *)objc_claimAutoreleasedReturnValue(v1304);
        [v106 refitAccelerationStructure:v243 descriptor:v1089 destination:v1077 scratchBuffer:v1084 scratchBufferOffset:*((void *)v1302 + 4) options:*((void *)v1302 + 5)];
LABEL_979:

        goto LABEL_1313;
      case -15365:
        v1305 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1305]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1305 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1305 + 2)]);
        [v12 writeAccelerationStructureSerializationData:v18 toBuffer:v93 offset:*((void *)v1305 + 3)];
        goto LABEL_1063;
      case -15364:
        v1306 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1306]);
        v1307 = GTTraceFunc_argumentBytesWithMap(a2, v1306[16], v4);
        v1308 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructurePassDescriptorMap]);
        MTLAccelerationStructurePassDescriptor = MakeMTLAccelerationStructurePassDescriptor((uint64_t)v1307, v1308);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLAccelerationStructurePassDescriptor);

        v121 = (id)objc_claimAutoreleasedReturnValue([v106 accelerationStructureCommandEncoderWithDescriptor:v108]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          v1310 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"functionIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v121 insertDebugSignpost:v1310];
        }

        v123 = *((void *)v1306 + 1);
        if (v121)
        {
          [v5 setAccelerationStructureCommandEncoder:v121 forKey:v123];
        }

        else
        {
LABEL_1302:
          if (v123) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v123);
          }
        }

LABEL_1304:
        goto LABEL_1428;
      case -15363:
        v1311 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1311]);
        v243 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1311 + 1)]);
        v1312 = GTTraceFunc_argumentBytesWithMap(a2, v1311[17], v4);
        v1313 = (uint64_t *)(v1312 + 8);
        v1314 = *(_DWORD *)v1312;
        v1315 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1316 = MakeNSArray(v1313, v1314, v1315);
        v913 = (void *)objc_claimAutoreleasedReturnValue(v1316);

        v1317 = GTTraceFunc_argumentBytesWithMap(a2, v1311[16], v4);
        v1318 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v1311[18], v4);
        v1319 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1320 = MakeMTLAccelerationStructureDescriptor(v1318, v1319);
        v1321 = (void *)objc_claimAutoreleasedReturnValue(v1320);
        [v106 deserializeInstanceAccelerationStructure:v243 fromBytes:v1317 primitiveAccelerationStructures:v913 withDescriptor:v1321];

LABEL_1311:
LABEL_1312:

LABEL_1313:
        goto LABEL_1429;
      case -15362:
        v1322 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1322]);
        v847 = (dispatch_data_t)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1322 + 1)]);
        v1323 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v1322[17], v4);
        v1324 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1325 = MakeMTLAccelerationStructureDescriptor(v1323, v1324);
        v901 = (void *)objc_claimAutoreleasedReturnValue(v1325);

        objc_msgSend( v106,  "deserializePrimitiveAccelerationStructure:fromBytes:withDescriptor:",  v847,  GTTraceFunc_argumentBytesWithMap(a2, v1322[16], v4),  v901);
LABEL_987:

LABEL_1362:
        goto LABEL_1429;
      case -15359:
        v1326 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1326]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1326 + 2)]);
        v93 = [v12 newAccelerationStructureWithBuffer:v18 offset:*((void *)v1326 + 3) resourceIndex:*((void *)v1326 + 4)];
        v743 = *((void *)v1326 + 1);
        if (v93)
        {
          [v5 setAccelerationStructure:v93 forKey:v743];
        }

        else
        {
LABEL_990:
          if (v743) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v743);
          }
        }

        goto LABEL_1063;
      case -15358:
        v1327 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1327]);
        v1328 = GTTraceFunc_argumentBytesWithMap(a2, v1327[24], v4);
        MTLAccelerationStructureAllocationDescriptor = MakeMTLAccelerationStructureAllocationDescriptor((uint64_t)v1328);
        v108 = (id)objc_claimAutoreleasedReturnValue(MTLAccelerationStructureAllocationDescriptor);
        v191 = [v106 newAccelerationStructureWithSize:*((void *)v1327 + 2) withDescriptor:v108];
        v192 = *((void *)v1327 + 1);
        if (!v191) {
          goto LABEL_1425;
        }
        v1330 = v5;
        v1331 = v191;
        goto LABEL_1424;
      case -15356:
        v1332 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v1332]);
        v191 = (id)objc_claimAutoreleasedReturnValue([v106 device]);
        v1333 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v1332[16], v4);
        v1334 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
        v1335 = MakeMTLAccelerationStructureDescriptor(v1333, v1334);
        v1336 = (void *)objc_claimAutoreleasedReturnValue(v1335);
        v1337 = [v191 heapAccelerationStructureSizeAndAlignWithDescriptor:v1336];

        v1338 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v1332 + 1), *a2);
        if ((id)v1338[23] != v1337)
        {
          if (s_logUsingOsLog)
          {
            v1339 = gt_default_log();
            v1340 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1339);
            if (os_log_type_enabled(v1340, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( &dword_0,  v1340,  OS_LOG_TYPE_ERROR,  "warning: Acceleration structure size mismatch during replay",  buf,  2u);
            }
          }

          else
          {
            v1548 = __stderrp;
            v1549 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: Acceleration structure size mismatch during replay"));
            fprintf(v1548, "%s\n", (const char *)[v1549 UTF8String]);
          }
        }

        if ((~(_DWORD)GT_SUPPORT_0 & 0x180000) != 0)
        {
          if ((GT_SUPPORT_0 & 0x100000) != 0)
          {
            v1550 = [v106 newAccelerationStructureWithSize:v1337 resourceIndex:v1338[19]];
          }

          else if ((GT_SUPPORT_0 & 0x80000) != 0)
          {
            v1550 = [v106 newAccelerationStructureWithSize:v1337 offset:*((unsigned int *)v1338 + 20)];
          }

          else
          {
            v1550 = [v106 newAccelerationStructureWithSize:v1337];
          }
        }

        else
        {
          v1550 = [v106 newAccelerationStructureWithSize:v1337 offset:*((unsigned int *)v1338 + 20) resourceIndex:v1338[19]];
        }

        v108 = v1550;
        v192 = *((void *)v1332 + 1);
        if (v1550)
        {
          v1330 = v5;
          v1331 = v108;
LABEL_1424:
          [v1330 setAccelerationStructure:v1331 forKey:v192];
        }

        else
        {
LABEL_1425:
          if (v192) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v192);
          }
        }

LABEL_1427:
        goto LABEL_1428;
      case -15355:
        v932 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1341 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v932]);
        v106 = v1341;
        if ((GT_SUPPORT_0 & 0x100000) != 0)
        {
          v934 = (void *)objc_claimAutoreleasedReturnValue([v1341 device]);
          v1478 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v932[24], v4);
          v1479 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
          v1480 = MakeMTLAccelerationStructureDescriptor(v1478, v1479);
          v1481 = (void *)objc_claimAutoreleasedReturnValue(v1480);
          v1482 = [v934 heapAccelerationStructureSizeAndAlignWithDescriptor:v1481];

          v1483 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v932 + 1), *a2);
          if ((id)v1483[23] != v1482)
          {
            if (s_logUsingOsLog)
            {
              v1484 = gt_default_log();
              v1485 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1484);
              if (os_log_type_enabled(v1485, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_error_impl( &dword_0,  v1485,  OS_LOG_TYPE_ERROR,  "warning: Acceleration structure size mismatch during replay",  buf,  2u);
              }
            }

            else
            {
              v1551 = __stderrp;
              v1552 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: Acceleration structure size mismatch during replay"));
              fprintf(v1551, "%s\n", (const char *)[v1552 UTF8String]);
            }
          }

          v108 = [v106 newAccelerationStructureWithSize:v1482 offset:*((void *)v932 + 2) resourceIndex:v1483[19]];
        }

        else
        {
          v1342 = (unsigned __int8 *)GTTraceFunc_argumentBytesWithMap(a2, v932[24], v4);
          v934 = (void *)objc_claimAutoreleasedReturnValue([v5 resources]);
          v1343 = MakeMTLAccelerationStructureDescriptor(v1342, v934);
          v936 = (void *)objc_claimAutoreleasedReturnValue(v1343);
          v937 = [v106 newAccelerationStructureWithDescriptor:v936 offset:*((void *)v932 + 2)];
LABEL_1001:
          v108 = v937;
        }

LABEL_1435:
        v868 = *((void *)v932 + 1);
        if (v108)
        {
          [v5 setAccelerationStructure:v108 forKey:v868];
        }

        else
        {
LABEL_1437:
          if (v868) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v868);
          }
        }

LABEL_1428:
LABEL_1429:
        goto LABEL_1430;
      case -15354:
        v938 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v938]);
        v1344 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v938 + 1), *a2);
        if ((~(_DWORD)GT_SUPPORT_0 & 0x180000) == 0)
        {
          v1345 = *((void *)v938 + 2);
          v1346 = *((unsigned int *)v1344 + 20);
          goto LABEL_1173;
        }

        v939 = *((void *)v938 + 2);
        if ((GT_SUPPORT_0 & 0x100000) != 0)
        {
LABEL_1171:
          v1486 = [v12 newAccelerationStructureWithSize:v939 resourceIndex:v1344[19]];
          goto LABEL_1416;
        }

        if ((GT_SUPPORT_0 & 0x80000) == 0)
        {
LABEL_1170:
          v1486 = [v12 newAccelerationStructureWithSize:v939];
          goto LABEL_1416;
        }

        v1347 = *((unsigned int *)v1344 + 20);
        goto LABEL_1415;
      case -15353:
        v938 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v938]);
        if ((GT_SUPPORT_0 & 0x100000) != 0)
        {
          v1344 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v938 + 1), *a2);
          v1345 = *((void *)v938 + 2);
          v1346 = *((void *)v938 + 3);
LABEL_1173:
          v1486 = [v12 newAccelerationStructureWithSize:v1345 offset:v1346 resourceIndex:v1344[19]];
        }

        else
        {
          v939 = *((void *)v938 + 2);
          v1347 = *((void *)v938 + 3);
LABEL_1415:
          v1486 = [v12 newAccelerationStructureWithSize:v939 offset:v1347];
        }

LABEL_1416:
        v1470 = v1486;
        v1471 = *((void *)v938 + 1);
        if (v1486)
        {
          [v5 setAccelerationStructure:v1486 forKey:v1471];
        }

        else
        {
LABEL_1418:
          if (v1471) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v1471);
          }
        }

LABEL_1420:
        break;
      case -15352:
        v1043 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v1043]);
        v1348 = [v12 newAccelerationStructureWithSize:*((void *)v1043 + 2) offset:*((void *)v1043 + 3) resourceIndex:*((void *)v1043 + 4)];
        goto LABEL_1009;
      case -15351:
        v1043 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1044 = (void *)objc_claimAutoreleasedReturnValue([v5 heapForKey:*(void *)v1043]);
LABEL_1008:
        v12 = v1044;
        v1348 = [v1044 newAccelerationStructureWithSize:*((void *)v1043 + 2) resourceIndex:*((void *)v1043 + 3)];
LABEL_1009:
        v18 = v1348;
        v19 = *((void *)v1043 + 1);
        if (!v1348) {
          goto LABEL_1050;
        }
        [v5 setAccelerationStructure:v1348 forKey:v19];
        goto LABEL_1064;
      case -15350:
        v1349 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1349]);
        v1350 = (unsigned int *)GTTraceFunc_argumentBytesWithMap(a2, v1349[24], v4);
        MTLIOCommandQueueDescriptor = MakeMTLIOCommandQueueDescriptor(v1350);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLIOCommandQueueDescriptor);
        v1661 = 0LL;
        v225 = [v60 newIOCommandQueueWithDescriptor:v204 error:&v1661];
        v6 = v1661;
        v509 = *((void *)v1349 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setIOCommandQueue:v225 forKey:v509];
        goto LABEL_1397;
      case -15343:
        v1352 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1352]);
        [v5 removeIOCommandBufferForKey:*(void *)v1352];
        [v12 commit];
        break;
      case -15342:
        v1353 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1353]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1353 + 1)]);
        [v12 copyStatusToBuffer:v18 offset:*((void *)v1353 + 2)];
        goto LABEL_1064;
      case -15341:
        objc_msgSend( v5,  "removeIOCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15340:
        v690 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v690]);
        v691 = objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*((void *)v690 + 1)]);
LABEL_1017:
        v18 = (id)v691;
        [v12 encodeSignalEvent:v691 value:*((void *)v690 + 2)];
        goto LABEL_1064;
      case -15339:
        v688 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v688]);
        v689 = objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*((void *)v688 + 1)]);
LABEL_1019:
        v18 = (id)v689;
        [v12 encodeWaitForEvent:v689 value:*((void *)v688 + 2)];
        goto LABEL_1064;
      case -15336:
        v1354 = objc_msgSend( v5,  "iOCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1354);
        [v14 tryCancel];
        goto LABEL_1041;
      case -15335:
        v1355 = objc_msgSend( v5,  "iOCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v114 = (void *)objc_claimAutoreleasedReturnValue(v1355);
LABEL_1022:
        v14 = v114;
        [v114 waitUntilCompleted];
        goto LABEL_1041;
      case -15333:
        v1356 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandQueueForKey:*(void *)v1356]);
        v1357 = objc_claimAutoreleasedReturnValue([v12 commandBuffer]);
        goto LABEL_1046;
      case -15332:
        objc_msgSend( v5,  "removeIOCommandQueueForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15331:
        objc_msgSend( v5,  "removeIOScratchBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15329:
        objc_msgSend( v5,  "removeIOScratchBufferAllocatorForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15325:
        v1358 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1359 = (void *)objc_claimAutoreleasedReturnValue([v5 eventForKey:*(void *)v1358]);
        goto LABEL_1030;
      case -15324:
        v1358 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1359 = (void *)objc_claimAutoreleasedReturnValue([v5 lateEvalEventForKey:*(void *)v1358]);
        goto LABEL_1030;
      case -15321:
        v1358 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1359 = (void *)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*(void *)v1358]);
LABEL_1030:
        v12 = v1359;
        [v1359 setEnableBarrier:*((_DWORD *)v1358 + 2) != 0];
        break;
      case -15320:
        objc_msgSend( v5,  "removeDeadlineProfileForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15317:
        v1360 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1360]);
        v18 = [v12 newProfileWithExecutionSize:*((void *)v1360 + 2)];
        v19 = *((void *)v1360 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setDeadlineProfile:v18 forKey:v19];
        goto LABEL_1064;
      case -15315:
        v1361 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1361]);
        [v12 sparseTileSizeInBytesForSparsePageSize:*((void *)v1361 + 2)];
        break;
      case -15314:
        v1362 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1362]);
        [v12 sparseTileSizeWithTextureType:*((void *)v1362 + 4) pixelFormat:*((void *)v1362 + 5) sampleCount:*((void *)v1362 + 6) sparsePageSize:*((void *)v1362 + 7)];
        break;
      case -15313:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15312:
        v1363 = objc_msgSend( v5,  "iOCommandBufferForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1363);
        [v14 enqueue];
        goto LABEL_1041;
      case -15311:
        v1364 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1364]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1364 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 iOHandleForKey:*((void *)v1364 + 4)]);
        [v12 loadBuffer:v18 offset:*((void *)v1364 + 2) size:*((void *)v1364 + 3) sourceHandle:v93 sourceHandleOffset:*((void *)v1364 + 5)];
        goto LABEL_1063;
      case -15310:
        v1365 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v14 = (id)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1365]);
        v75 = (void *)objc_claimAutoreleasedReturnValue([v5 textureForKey:*((void *)v1365 + 1)]);
        v76 = (void *)objc_claimAutoreleasedReturnValue([v5 iOHandleForKey:*((void *)v1365 + 12)]);
        v1366 = *((void *)v1365 + 2);
        v1367 = *((void *)v1365 + 3);
        v1587 = *((_OWORD *)v1365 + 2);
        v1368 = *((void *)v1365 + 7);
        v1588 = *((void *)v1365 + 6);
        v1369 = *((void *)v1365 + 8);
        v1370 = *((void *)v1365 + 11);
        v1585 = *(_OWORD *)(v1365 + 72);
        v1586 = v1370;
        [v14 loadTexture:v75 slice:v1366 level:v1367 size:&v1587 sourceBytesPerRow:v1368 sourceBytesPerImage:v1369 destinationOrigin:&v1585 sourceHandle:v76 sourceHandleOffset:*((void *)v1365 + 13)];
LABEL_1040:

        goto LABEL_1041;
      case -15309:
        v1371 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1371]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*((void *)v1371 + 1)]);
        [v12 signalEvent:v18 value:*((void *)v1371 + 2)];
        goto LABEL_1064;
      case -15308:
        v1372 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1372]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*((void *)v1372 + 1)]);
        [v12 waitForEvent:v18 value:*((void *)v1372 + 2)];
        goto LABEL_1064;
      case -15307:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandQueueForKey:*(void *)v72]);
        goto LABEL_1057;
      case -15306:
        v1356 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandQueueForKey:*(void *)v1356]);
        v1357 = objc_claimAutoreleasedReturnValue([v12 commandBufferWithUnretainedReferences]);
LABEL_1046:
        v18 = (id)v1357;
        v19 = *((void *)v1356 + 1);
        if (!v1357) {
          goto LABEL_1050;
        }
        [v5 setIOCommandBuffer:v1357 forKey:v19];
        goto LABEL_1064;
      case -15299:
        v1373 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 iOScratchBufferAllocatorForKey:*(void *)v1373]);
        v18 = [v12 newScratchBufferWithMinimumSize:*((void *)v1373 + 2)];
        v19 = *((void *)v1373 + 1);
        if (!v18) {
          goto LABEL_1050;
        }
        [v5 setIOScratchBuffer:v18 forKey:v19];
        goto LABEL_1064;
      case -15297:
        v1374 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1374]);
        v1375 = *(_OWORD *)(v1374 + 8);
        v1609 = *((void *)v1374 + 3);
        v1376 = *((_OWORD *)v1374 + 3);
        v1607[0] = *((_OWORD *)v1374 + 2);
        v1607[1] = v1376;
        v1607[2] = *((_OWORD *)v1374 + 4);
        v1608 = v1375;
        [v12 dispatchThreadsPerTile:&v1608 inRegion:v1607 withRenderTargetArrayIndex:*((unsigned int *)v1374 + 20)];
        break;
      case -15294:
        v1377 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 iOCommandBufferForKey:*(void *)v1377]);
        v802 = (void *)objc_claimAutoreleasedReturnValue([v5 iOHandleForKey:*((void *)v1377 + 2)]);
        objc_msgSend( v56,  "loadBytes:size:sourceHandle:sourceHandleOffset:",  GTTraceFunc_argumentBytesWithMap(a2, v1377[32], v4),  *((void *)v1377 + 1),  v802,  *((void *)v1377 + 3));
LABEL_1054:

        goto LABEL_1090;
      case -15291:
        v1378 = objc_msgSend( v5,  "iOCommandQueueForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1378);
        [v14 enqueueBarrier];
        goto LABEL_1041;
      case -15290:
        v72 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v73 = (void *)objc_claimAutoreleasedReturnValue([v5 iOHandleForKey:*(void *)v72]);
LABEL_1057:
        v106 = v73;
        if (v72[8])
        {
          v1379 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  GTTraceFunc_argumentBytesWithMap(a2, v72[8], v4));
          v571 = (void *)objc_claimAutoreleasedReturnValue(v1379);
          [v106 setLabel:v571];
LABEL_1059:
        }

        else
        {
          [v73 setLabel:0];
        }

        goto LABEL_1429;
      case -15289:
        objc_msgSend( v5,  "removeIOHandleForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15287:
        v1380 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 accelerationStructureCommandEncoderForKey:*(void *)v1380]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 accelerationStructureForKey:*((void *)v1380 + 1)]);
        v93 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1380 + 2)]);
        [v12 writeAccelerationStructureTraversalDepth:v18 toBuffer:v93 offset:*((void *)v1380 + 3)];
LABEL_1063:

        goto LABEL_1064;
      case -15284:
        v1381 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1381]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1381 + 1)]);
        [v12 setBuffer:v18 offset:*((void *)v1381 + 2) attributeStride:*((void *)v1381 + 3) atIndex:*((void *)v1381 + 4)];
        goto LABEL_1064;
      case -15283:
        v1382 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1382]);
        [v12 setBufferOffset:*((void *)v1382 + 1) attributeStride:*((void *)v1382 + 2) atIndex:*((void *)v1382 + 3)];
        break;
      case -15282:
        v1383 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1383]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1384 = GTTraceFunc_argumentBytesWithMap(a2, v1383[24], v4);
        if (*((void *)v1383 + 2))
        {
          v1385 = v1384;
          v1386 = 0LL;
          do
          {
            v1387 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v1385[8 * v1386]]);
            v1388 = *(void **)&buf[8 * v1386];
            *(void *)&buf[8 * v1386] = v1387;

            ++v1386;
          }

          while (*((void *)v1383 + 2) > v1386);
        }

        v1389 = GTTraceFunc_argumentBytesWithMap(a2, v1383[25], v4);
        objc_msgSend( v106,  "setBuffers:offsets:attributeStrides:withRange:",  buf,  v1389,  GTTraceFunc_argumentBytesWithMap(a2, v1383[26], v4),  *((void *)v1383 + 1),  *((void *)v1383 + 2));
        for (i18 = 240LL; i18 != -8; i18 -= 8LL)

        goto LABEL_1429;
      case -15281:
        v1391 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1391]);
        objc_msgSend( v56,  "setBytes:length:attributeStride:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v1391[32], v4),  *((void *)v1391 + 1),  *((void *)v1391 + 2),  *((void *)v1391 + 3));
        goto LABEL_1090;
      case -15280:
        v1392 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1392]);
        [v12 setThreadgroupDistributionMode:*((void *)v1392 + 1)];
        break;
      case -15279:
        v1393 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1393]);
        [v12 setThreadgroupDistributionModeWithClusterGroupIndex:*((unsigned int *)v1393 + 2)];
        break;
      case -15278:
        v1394 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*(void *)v1394]);
        [v12 setThreadgroupPackingDisabled:*((_DWORD *)v1394 + 2) != 0];
        break;
      case -15277:
        v1395 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectComputeCommandForKey:*(void *)v1395]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1395 + 1)]);
        [v12 setKernelBuffer:v18 offset:*((void *)v1395 + 2) attributeStride:*((void *)v1395 + 3) atIndex:*((void *)v1395 + 4)];
        goto LABEL_1064;
      case -15276:
        v1396 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1397 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v1396]);
        goto LABEL_1081;
      case -15275:
        v1396 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1397 = objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1396]);
LABEL_1081:
        v12 = (void *)v1397;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1396 + 1)]);
        [v12 setVertexBuffer:v18 offset:*((void *)v1396 + 2) attributeStride:*((void *)v1396 + 3) atIndex:*((void *)v1396 + 4)];
        goto LABEL_1064;
      case -15274:
        v1398 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1398]);
        [v12 setVertexBufferOffset:*((void *)v1398 + 1) attributeStride:*((void *)v1398 + 2) atIndex:*((void *)v1398 + 3)];
        break;
      case -15273:
        v1399 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1399]);
        v1735 = 0LL;
        v1734 = 0u;
        v1733 = 0u;
        v1732 = 0u;
        v1731 = 0u;
        v1730 = 0u;
        v1729 = 0u;
        v1728 = 0u;
        v1727 = 0u;
        v1726 = 0u;
        v1725 = 0u;
        v1724 = 0u;
        v1723 = 0u;
        v1722 = 0u;
        v1721 = 0u;
        *(_OWORD *)buf = 0u;
        v1400 = GTTraceFunc_argumentBytesWithMap(a2, v1399[24], v4);
        if (*((void *)v1399 + 2))
        {
          v1401 = v1400;
          v1402 = 0LL;
          do
          {
            v1403 = objc_claimAutoreleasedReturnValue([v5 bufferForKey:*(void *)&v1401[8 * v1402]]);
            v1404 = *(void **)&buf[8 * v1402];
            *(void *)&buf[8 * v1402] = v1403;

            ++v1402;
          }

          while (*((void *)v1399 + 2) > v1402);
        }

        v1405 = GTTraceFunc_argumentBytesWithMap(a2, v1399[25], v4);
        objc_msgSend( v106,  "setVertexBuffers:offsets:attributeStrides:withRange:",  buf,  v1405,  GTTraceFunc_argumentBytesWithMap(a2, v1399[26], v4),  *((void *)v1399 + 1),  *((void *)v1399 + 2));
        for (i19 = 240LL; i19 != -8; i19 -= 8LL)

        goto LABEL_1429;
      case -15272:
        v1407 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v56 = (void *)objc_claimAutoreleasedReturnValue([v5 renderCommandEncoderForKey:*(void *)v1407]);
        objc_msgSend( v56,  "setVertexBytes:length:attributeStride:atIndex:",  GTTraceFunc_argumentBytesWithMap(a2, v1407[32], v4),  *((void *)v1407 + 1),  *((void *)v1407 + 2),  *((void *)v1407 + 3));
        goto LABEL_1090;
      case -15266:
        v1408 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1193 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v1408]);
        v12 = v1193;
        v1409 = *((void *)v1408 + 3);
        v1635 = *(_OWORD *)(v1408 + 8);
        v1636 = v1409;
        v1410 = *((void *)v1408 + 6);
        v1633 = *((_OWORD *)v1408 + 2);
        v1634 = v1410;
        v1411 = *((void *)v1408 + 9);
        v1631 = *(_OWORD *)(v1408 + 56);
        v1632 = v1411;
        v1197 = &v1635;
        v1198 = &v1633;
        v1199 = &v1631;
LABEL_1092:
        [v1193 drawMeshThreadgroups:v1197 threadsPerObjectThreadgroup:v1198 threadsPerMeshThreadgroup:v1199];
        break;
      case -15265:
        v1412 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1205 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v1412]);
        v12 = v1205;
        v1413 = *((void *)v1412 + 3);
        v1629 = *(_OWORD *)(v1412 + 8);
        v1630 = v1413;
        v1414 = *((void *)v1412 + 6);
        v1627 = *((_OWORD *)v1412 + 2);
        v1628 = v1414;
        v1415 = *((void *)v1412 + 9);
        v1625 = *(_OWORD *)(v1412 + 56);
        v1626 = v1415;
        v1209 = &v1629;
        v1210 = &v1627;
        v1211 = &v1625;
LABEL_1094:
        [v1205 drawMeshThreads:v1209 threadsPerObjectThreadgroup:v1210 threadsPerMeshThreadgroup:v1211];
        break;
      case -15264:
        v1224 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1225 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v1224]);
LABEL_1096:
        v12 = (void *)v1225;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1224 + 1)]);
        [v12 setMeshBuffer:v18 offset:*((void *)v1224 + 2) atIndex:*((void *)v1224 + 3)];
        goto LABEL_1064;
      case -15263:
        v1262 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1263 = objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v1262]);
LABEL_1098:
        v12 = (void *)v1263;
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 bufferForKey:*((void *)v1262 + 1)]);
        [v12 setObjectBuffer:v18 offset:*((void *)v1262 + 2) atIndex:*((void *)v1262 + 3)];
        goto LABEL_1064;
      case -15262:
        v1300 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v1301 = (void *)objc_claimAutoreleasedReturnValue([v5 indirectRenderCommandForKey:*(void *)v1300]);
LABEL_1100:
        v12 = v1301;
        [v1301 setObjectThreadgroupMemoryLength:*((void *)v1300 + 1) atIndex:*((void *)v1300 + 2)];
        break;
      case -15254:
        v1416 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1416]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*((void *)v1416 + 1)]);
        [v12 useResidencySet:v33];
        goto LABEL_1131;
      case -15253:
        v1417 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1417]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v1418 = apr_palloc(v632, 8LL * *((void *)v1417 + 1));
        v1419 = GTTraceFunc_argumentBytesWithMap(a2, v1417[16], v4);
        if (*((void *)v1417 + 1))
        {
          v1420 = v1419;
          v1421 = 0LL;
          do
          {
            v1418[v1421] = [v5 residencySetForKey:*(void *)&v1420[8 * v1421]];
            ++v1421;
            v1422 = *((void *)v1417 + 1);
          }

          while (v1422 > v1421);
        }

        else
        {
          v1422 = 0LL;
        }

        [v106 useResidencySets:v1418 count:v1422];
        goto LABEL_1389;
      case -15252:
        v1423 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v1423]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*((void *)v1423 + 1)]);
        [v12 addResidencySet:v33];
        goto LABEL_1131;
      case -15251:
        v1424 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v1424]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v1425 = apr_palloc(v632, 8LL * *((void *)v1424 + 1));
        v1426 = GTTraceFunc_argumentBytesWithMap(a2, v1424[16], v4);
        if (*((void *)v1424 + 1))
        {
          v1427 = v1426;
          v1428 = 0LL;
          do
          {
            v1425[v1428] = [v5 residencySetForKey:*(void *)&v1427[8 * v1428]];
            ++v1428;
            v1429 = *((void *)v1424 + 1);
          }

          while (v1429 > v1428);
        }

        else
        {
          v1429 = 0LL;
        }

        [v106 addResidencySets:v1425 count:v1429];
        goto LABEL_1389;
      case -15250:
        v1430 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v1430]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*((void *)v1430 + 1)]);
        [v12 removeResidencySet:v33];
        goto LABEL_1131;
      case -15249:
        v1431 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 commandQueueForKey:*(void *)v1431]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v1432 = apr_palloc(v632, 8LL * *((void *)v1431 + 1));
        v1433 = GTTraceFunc_argumentBytesWithMap(a2, v1431[16], v4);
        if (*((void *)v1431 + 1))
        {
          v1434 = v1433;
          v1435 = 0LL;
          do
          {
            v1432[v1435] = [v5 residencySetForKey:*(void *)&v1434[8 * v1435]];
            ++v1435;
            v1436 = *((void *)v1431 + 1);
          }

          while (v1436 > v1435);
        }

        else
        {
          v1436 = 0LL;
        }

        [v106 removeResidencySets:v1432 count:v1436];
        goto LABEL_1389;
      case -15246:
        v1437 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1437]);
        [v12 setWritableHeapsEnabled:*((_DWORD *)v1437 + 2) != 0];
        break;
      case -15245:
        v1438 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 deviceForKey:*(void *)v1438]);
        v1439 = GTTraceFunc_argumentBytesWithMap(a2, v1438[24], v4);
        MTLResidencySetDescriptor = MakeMTLResidencySetDescriptor((uint64_t)v1439);
        v204 = (id)objc_claimAutoreleasedReturnValue(MTLResidencySetDescriptor);
        v1642 = 0LL;
        v225 = [v60 newResidencySetWithDescriptor:v204 error:&v1642];
        v6 = v1642;
        v509 = *((void *)v1438 + 1);
        if (!v225) {
          goto LABEL_1395;
        }
        [v5 setResidencySet:v225 forKey:v509];
        goto LABEL_1397;
      case -15231:
        objc_msgSend( v5,  "removeResidencySetForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        goto LABEL_1430;
      case -15230:
        v1441 = objc_msgSend( v5,  "residencySetForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1441);
        [v14 endResidency];
        goto LABEL_1041;
      case -15223:
        v1442 = objc_msgSend( v5,  "residencySetForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1442);
        [v14 requestResidency];
        goto LABEL_1041;
      case -15220:
        v1443 = objc_msgSend( v5,  "residencySetForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1443);
        [v14 commit];
        goto LABEL_1041;
      case -15217:
        v1444 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 commandBufferForKey:*(void *)v1444]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v5 sharedEventForKey:*((void *)v1444 + 1)]);
        [v12 encodeSignalEventScheduled:v18 value:*((void *)v1444 + 2)];
        goto LABEL_1064;
      case -15212:
        v1445 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*(void *)v1445]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 allocationForKey:*((void *)v1445 + 1)]);
        [v12 addAllocation:v33];
        goto LABEL_1131;
      case -15211:
        v1446 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*(void *)v1446]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v1447 = apr_palloc(v632, 8LL * *((void *)v1446 + 1));
        v1448 = GTTraceFunc_argumentBytesWithMap(a2, v1446[16], v4);
        if (*((void *)v1446 + 1))
        {
          v1449 = v1448;
          v1450 = 0LL;
          do
          {
            v1447[v1450] = [v5 allocationForKey:*(void *)&v1449[8 * v1450]];
            ++v1450;
            v1451 = *((void *)v1446 + 1);
          }

          while (v1451 > v1450);
        }

        else
        {
          v1451 = 0LL;
        }

        [v106 addAllocations:v1447 count:v1451];
        goto LABEL_1389;
      case -15208:
        v1452 = objc_msgSend( v5,  "residencySetForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4));
        v14 = (id)objc_claimAutoreleasedReturnValue(v1452);
        [v14 removeAllAllocations];
LABEL_1041:

        goto LABEL_1430;
      case -15207:
        v1453 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*(void *)v1453]);
        v33 = (void *)objc_claimAutoreleasedReturnValue([v5 allocationForKey:*((void *)v1453 + 1)]);
        [v12 removeAllocation:v33];
        goto LABEL_1131;
      case -15206:
        v1454 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v106 = (void *)objc_claimAutoreleasedReturnValue([v5 residencySetForKey:*(void *)v1454]);
        v632 = **(apr_pool_t ***)(a1 + 152);
        v1455 = apr_palloc(v632, 8LL * *((void *)v1454 + 1));
        v1456 = GTTraceFunc_argumentBytesWithMap(a2, v1454[16], v4);
        if (*((void *)v1454 + 1))
        {
          v1457 = v1456;
          v1458 = 0LL;
          do
          {
            v1455[v1458] = [v5 allocationForKey:*(void *)&v1457[8 * v1458]];
            ++v1458;
            v1459 = *((void *)v1454 + 1);
          }

          while (v1459 > v1458);
        }

        else
        {
          v1459 = 0LL;
        }

        [v106 removeAllocations:v1455 count:v1459];
LABEL_1389:
        v1531 = v632;
LABEL_1390:
        apr_pool_clear(v1531);
        goto LABEL_1429;
      default:
        switch(v7)
        {
          case -10240:
            v1460 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
            v1461 = *((void *)v1460 + 1);
            *(void *)buf = 22LL;
            *(void *)&buf[8] = v1461;
            *(void *)&v1721 = 0LL;
            *((void *)&v1721 + 1) = GTTraceFunc_argumentBytesWithMap(a2, v1460[32], v4);
            v1722 = *((_OWORD *)v1460 + 1);
            GTMTLReplayController_restoreMTLBufferContents(a1, buf);
            goto LABEL_1430;
          case -10239:
            v1462 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
            v12 = (void *)objc_claimAutoreleasedReturnValue([v5 defaultDevice]);
            [v5 setDevice:v12 forKey:*(void *)v1462];
            goto LABEL_1065;
          case -10238:
          case -10236:
            goto LABEL_9;
          case -10237:
            goto LABEL_24;
          default:
            goto LABEL_1431;
        }

        goto LABEL_1431;
    }

LABEL_1065:
LABEL_1430:
    v6 = 0LL;
    goto LABEL_1431;
  }

  if (v7 > -7168)
  {
    switch(v7)
    {
      case -7167:
        v28 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 drawableForKey:*(void *)v28]);
        v18 = (id)objc_claimAutoreleasedReturnValue([v12 texture]);
        v19 = *((void *)v28 + 1);
        if (v18)
        {
          [v5 setTexture:v18 forKey:v19];
        }

        else
        {
LABEL_1050:
          if (v19) {
            GTMTLReplay_dispatchFailedToSet((uint64_t)a2, v19);
          }
        }

        goto LABEL_1064;
      case -7166:
        v29 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v29]);
        if ((dword_5B9DE4 & 0x100000) == 0
          || (v30 = *(uint64_t **)(*(void *)a1 + 40LL),
              (v31 = GTMTLSMContext_getObject(*v30, *((void *)v29 + 1), *a2)) == 0LL)
          || (DrawableTexture = GTMTLSMContext_getDrawableTexture(*v30, (uint64_t)v31, *a2)) == 0
          || !*(void *)(DrawableTexture + 176)
          || (v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "nextDrawableWithTextureResourceIndex:"))) == 0)
        {
          v33 = (void *)objc_claimAutoreleasedReturnValue([v12 nextDrawable]);
        }

        [v5 setDrawable:v33 forKey:*((void *)v29 + 1)];
LABEL_1131:

        goto LABEL_1065;
      case -7165:
        v34 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v34]);
        [v12 setPixelFormat:*((void *)v34 + 1)];
        goto LABEL_1065;
      case -7164:
        v35 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v35]);
        objc_msgSend(v12, "setDrawableSize:", *((double *)v35 + 1), *((double *)v35 + 2));
        goto LABEL_1065;
      case -7163:
        v36 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 defaultDevice]);
        [v5 setDevice:v12 forKey:*((void *)v36 + 1)];
        v18 = objc_alloc_init((Class)[v5 layerClass]);
        [v18 setDevice:v12];
        [v5 setLayer:v18 forKey:*(void *)v36];
LABEL_1064:

        goto LABEL_1065;
      case -7162:
        v37 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v38 = *((double *)v37 + 1);
        v39 = *((double *)v37 + 2);
        v40 = *((double *)v37 + 3);
        v41 = *((double *)v37 + 4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v37]);
        objc_msgSend(v12, "setBounds:", v38, v39, v40, v41);
        [v12 setContentsScale:*((double *)v37 + 5)];
        goto LABEL_1065;
      case -7160:
        v42 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v42]);
        [v12 setFramebufferOnly:*((_DWORD *)v42 + 2) != 0];
        goto LABEL_1065;
      case -7159:
        v43 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        v44 = *((double *)v43 + 1);
        v45 = *((double *)v43 + 2);
        v46 = *((double *)v43 + 3);
        v47 = *((double *)v43 + 4);
        v48 = *((double *)v43 + 6);
        v49 = *((double *)v43 + 7);
        v51 = *((double *)v43 + 8);
        v50 = *((double *)v43 + 9);
        v52 = *((void *)v43 + 10);
        v53 = *((int *)v43 + 24);
        v1718[0] = @"styleMask";
        v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v52));
        v1719[0] = v54;
        v1718[1] = @"windowLevel";
        v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v53));
        v1719[1] = v55;
        v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v1719,  v1718,  2LL));

        v57 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v43]);
        objc_msgSend(v57, "setBounds:", v44, v45, v46, v47);
        [v57 setContentsScale:*((double *)v43 + 5)];
        objc_msgSend(v5, "setContentRect:windowRect:properties:", v56, v44, v45, v46, v47, v48, v49, v51, v50);

LABEL_1090:
        goto LABEL_1430;
      case -7158:
      case -7157:
      case -7156:
        v8 = *(void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
LABEL_7:
        [v5 presentDrawableWithKey:v8];
        goto LABEL_1430;
      case -7155:
        objc_msgSend( v5,  "setInterfaceOrientation:",  *((int *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4) + 2));
        goto LABEL_1430;
      case -7153:
        v58 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
        if (!v58[8]) {
          goto LABEL_1430;
        }
        v59 = v58;
        v60 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v58]);
        v61 = GTTraceFunc_argumentBlobWithMap(a2, v59[8], v4);
        if (v61)
        {
          v62 = v61 + 16;
          v63 = *(unsigned int *)(v61 + 12);
        }

        else
        {
          v62 = 0LL;
          v63 = 0LL;
        }

        v204 = (id)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  v62,  v63,  0LL));
        *(void *)buf = 200LL;
        v1583 = 0LL;
        v1547 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  v204,  0LL,  buf,  &v1583));
        v6 = v1583;
        v225 = v1547;
        [v60 setColorspace:CGColorSpaceCreateWithPropertyList(v225)];
LABEL_1397:

        goto LABEL_1398;
      default:
        goto LABEL_1431;
    }
  }

  if (v7 != -10157)
  {
    if (v7 == -8183)
    {
      v70 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
      v71 = v70 + 8;
      v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v70]);
      memmove(__dst, v71, 0x80uLL);
      [v12 setTransform:__dst];
    }

    else
    {
      if (v7 != -8181) {
        goto LABEL_1431;
      }
      v11 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
      v12 = (void *)objc_claimAutoreleasedReturnValue([v5 layerForKey:*(void *)v11]);
      objc_msgSend(v12, "setAnchorPoint:", *((double *)v11 + 1), *((double *)v11 + 2));
    }

    goto LABEL_1065;
  }

  v64 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), v4);
  v60 = (void *)objc_claimAutoreleasedReturnValue([v5 libraryForKey:*((void *)v64 + 1)]);
  v65 = GTTraceFunc_argumentBytesWithMap(a2, v64[16], v4);
  v66 = (void *)objc_claimAutoreleasedReturnValue([v5 functionMap]);
  v67 = MakeMTLFunctionDescriptor((uint64_t)v65, v66);
  v68 = (void *)objc_claimAutoreleasedReturnValue(v67);
  v1557 = 0LL;
  v69 = [v60 newFunctionWithDescriptor:v68 error:&v1557];
  v6 = v1557;

LABEL_1339:
  v204 = v69;
LABEL_1398:

  if (v6)
  {
    v1536 = *((unsigned int *)a2 + 2);
    if (GetFuncEnumAsString(*((_DWORD *)a2 + 2)))
    {
      v1537 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
      v1538 = PrettifyFenumString(v1537);
      v1539 = (id)objc_claimAutoreleasedReturnValue(v1538);
      v1540 = 0LL;
    }

    else
    {
      v1539 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%x",  v1536));
      v1540 = v1539;
      v1537 = v1539;
    }

    v1717[0] = v6;
    v1716[0] = NSUnderlyingErrorKey;
    v1716[1] = NSLocalizedDescriptionKey;
    v1541 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Call to %@ returned an error.",  v1539));
    v1717[1] = v1541;
    v1716[2] = NSLocalizedFailureReasonErrorKey;
    v1542 = (void *)objc_claimAutoreleasedReturnValue([v6 localizedDescription]);
    v1717[2] = v1542;
    v1717[3] = v1537;
    v1716[3] = @"GTErrorKeyFenum";
    v1716[4] = @"GTErrorKeyFunctionIndex";
    v1543 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *a2));
    v1717[4] = v1543;
    v1544 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v1717,  v1716,  5LL));

    NSError = MakeNSError(151, v1544);
    v1546 = (id)objc_claimAutoreleasedReturnValue(NSError);
    GTMTLReplay_handleNSError(v1546);
  }

LABEL_1431:
}

id _MakeMTLTextureDescriptor()
{
  uint64_t MTLTextureDescriptor = MakeMTLTextureDescriptor();
  v1 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptor);
  unint64_t v2 = (unint64_t)[v1 resourceOptions];
  if ((dword_5B9DE4 & 0x40000) != 0) {
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFCFFLL;
  }
  else {
    unint64_t v3 = v2;
  }
  [v1 setResourceOptions:v3];
  return v1;
}

id _MakeMTLComputePipelineDescriptor()
{
  uint64_t MTLComputePipelineDescriptor = MakeMTLComputePipelineDescriptor();
  v1 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptor);
  [v1 setBinaryArchives:insertBinaryArchives];
  return v1;
}

id _MakeMTLRenderPipelineDescriptor()
{
  uint64_t MTLRenderPipelineDescriptor = MakeMTLRenderPipelineDescriptor();
  v1 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptor);
  [v1 setBinaryArchives:insertBinaryArchives];
  return v1;
}

id _MakeMTLMeshRenderPipelineDescriptor()
{
  uint64_t MTLMeshRenderPipelineDescriptor = MakeMTLMeshRenderPipelineDescriptor();
  v1 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptor);
  [v1 setBinaryArchives:insertBinaryArchives];
  return v1;
}

id _MakeMTLTileRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  MTLTileRenderPipelineDescriptor = MakeMTLTileRenderPipelineDescriptor(a1, a2);
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);
  [v3 setBinaryArchives:insertBinaryArchives];
  return v3;
}

id NewCommandBuffer(void *a1)
{
  if (g_commandBufferDescriptor) {
    v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "commandBufferWithDescriptor:"));
  }
  else {
    v1 = (void *)objc_claimAutoreleasedReturnValue([a1 commandBuffer]);
  }
  return v1;
}

id MTLDevice_newBufferWithBytes_length_options(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = **(void **)a1;
  v7 = *(apr_pool_t ***)(a1 + 152);
  uint64_t v8 = *(void *)(*(void *)a1 + 16LL);
  id v9 = *(id *)(a1 + 8);
  v10 = (void *)objc_claimAutoreleasedReturnValue([v9 deviceForKey:*(void *)a3]);
  p = *v7;
  v11 = GTTraceFunc_argumentBytesWithMap(a2, *(unsigned __int8 *)(a3 + 40), v8);
  FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename(v6, v11);
  uint64_t v13 = *(void *)(a3 + 24);
  unint64_t v14 = v13 & 0xFFFFFFFFFFEFFFFFLL;
  if ((v13 & 0xF0) == 0x20
    || (uint64_t v15 = (uint64_t)FileWithFilename, v16 = FileWithFilename[4], (v16 & 2) == 0) && (v13 & 0xF) == 1)
  {
    id v17 = [v10 newBufferWithLength:*(void *)(a3 + 16) options:v14];
    uint64_t v18 = *(void *)(a3 + 16);
    v33 = v10;
    id v19 = v9;
    id v20 = *(id *)(a1 + 24);
    v21 = (void *)objc_claimAutoreleasedReturnValue([v20 bufferWithLength:v18 alignment:1]);
    v22 = GTTraceFunc_argumentBytesWithMap(a2, *(unsigned __int8 *)(a3 + 40), v8);
    GTCaptureArchive_fillBuffer(v6, v7, v22, (char *)[v21 contents], *(void *)(a3 + 16), 0);
    v23 = (void *)objc_claimAutoreleasedReturnValue([v20 blitCommandEncoder]);

    v24 = (void *)objc_claimAutoreleasedReturnValue([v21 heapBuffer]);
    objc_msgSend( v23,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v24,  objc_msgSend(v21, "heapLocation"),  v17,  0,  *(void *)(a3 + 16));

    id v9 = v19;
    v10 = v33;
  }

  else
  {
    if ((v16 & 2) != 0)
    {
      v25 = p;
      id v17 = objc_msgSend( v10,  "newBufferWithBytes:length:options:",  GTCaptureArchive_mapDataSeperateFile(v6, FileWithFilename, p, 0),  *(void *)(a3 + 16),  v14);
      goto LABEL_6;
    }

    id v27 = [v10 newBufferWithLength:*(void *)(a3 + 16) options:v14];
    v28 = v10;
    id v29 = v9;
    uint64_t v30 = *(void *)(a1 + 152);
    id v17 = v27;
    id v31 = [v17 contents];
    uint64_t v32 = v30;
    id v9 = v29;
    v10 = v28;
    GTCaptureArchive_fillBufferCompressedDeflate(v6, v32, v15, v31, *(void *)(a3 + 16), 0LL);
  }

  v25 = p;
LABEL_6:
  apr_pool_clear(v25);

  return v17;
}

id _MakeIOSurface(uint64_t a1, void *a2)
{
  id v65 = a2;
  uint64_t v68 = a1;
  if (*(void *)(a1 + 104))
  {
    unint64_t v3 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  *(void *)(a1 + 104),  *(void *)(a1 + 112),  0LL);
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSDictionary, v4);
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSArray, v6);
    uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSString, v8);
    uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSNumber, v10);
    uint64_t v64 = v7;
    a1 = v68;
    uint64_t v13 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v5,  v64,  v9,  v11,  objc_opt_class(&OBJC_CLASS___NSData, v12),  0LL);
    unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v14,  v3,  0LL));
    v66 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:kIOSurfaceCreationProperties]);
  }

  else
  {
    v66 = 0LL;
  }

  unsigned int v16 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)a1));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v16, "setObject:forKeyedSubscript:", v17, @"address");

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 92)));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v18,  IOSurfacePropertyKeyWidth);

  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 94)));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v19,  IOSurfacePropertyKeyHeight);

  id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 84)));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v20,  IOSurfacePropertyKeyPixelFormat);

  if (!*(_BYTE *)(a1 + 102))
  {
    v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 96)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v21,  IOSurfacePropertyKeyBytesPerElement);

    v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 80)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v22,  IOSurfacePropertyKeyBytesPerRow);

    v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 98)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v23,  IOSurfacePropertyKeyElementWidth);

    v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *(unsigned __int16 *)(a1 + 100)));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v24,  IOSurfacePropertyKeyElementHeight);
  }

  v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 8)));
  v67 = v16;
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v25,  IOSurfacePropertyKeyAllocSize);

  v26 = v66;
  if (v66)
  {
    v84[0] = IOSurfacePropertyKeyAllocSize;
    v84[1] = IOSurfacePropertyKeyWidth;
    v84[2] = IOSurfacePropertyKeyHeight;
    v84[3] = IOSurfacePropertyKeyBytesPerElement;
    v84[4] = IOSurfacePropertyKeyBytesPerRow;
    v84[5] = IOSurfacePropertyKeyElementWidth;
    v84[6] = IOSurfacePropertyKeyElementHeight;
    v84[7] = IOSurfacePropertyKeyPixelFormat;
    v84[8] = @"IOSurfaceAddress";
    v84[9] = @"IOSurfaceProtectionOptions";
    id v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v84, 10LL));
    __int128 v77 = 0u;
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    id v28 = v66;
    id v29 = [v28 countByEnumeratingWithState:&v77 objects:v83 count:16];
    if (v29)
    {
      id v30 = v29;
      uint64_t v31 = *(void *)v78;
      do
      {
        for (i = 0LL; i != v30; i = (char *)i + 1)
        {
          if (*(void *)v78 != v31) {
            objc_enumerationMutation(v28);
          }
          uint64_t v33 = *(void *)(*((void *)&v77 + 1) + 8LL * (void)i);
          if (([v27 containsObject:v33] & 1) == 0)
          {
            v34 = (void *)objc_claimAutoreleasedReturnValue([v28 objectForKeyedSubscript:v33]);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v67, "setObject:forKeyedSubscript:", v34, v33);
          }
        }

        id v30 = [v28 countByEnumeratingWithState:&v77 objects:v83 count:16];
      }

      while (v30);
    }
  }

  uint64_t v35 = v68;
  if (*(_BYTE *)(v68 + 102))
  {
    v82[0] = IOSurfacePropertyKeyPlaneWidth;
    v82[1] = IOSurfacePropertyKeyPlaneHeight;
    v82[2] = IOSurfacePropertyKeyPlaneBytesPerElement;
    v82[3] = IOSurfacePropertyKeyPlaneBytesPerRow;
    v82[4] = IOSurfacePropertyKeyPlaneElementWidth;
    v82[5] = IOSurfacePropertyKeyPlaneElementHeight;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v82, 6LL));
    v69 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(unsigned __int8 *)(v68 + 102));
    v72 = (void *)objc_claimAutoreleasedReturnValue([v66 objectForKeyedSubscript:IOSurfacePropertyKeyPlaneInfo]);
    v37 = &CATransform3DIdentity_ptr;
    if (*(_BYTE *)(v68 + 102))
    {
      unint64_t v38 = 0LL;
      uint64_t v71 = 0LL;
      do
      {
        uint64_t v39 = v35 + 16 * v38;
        int v40 = *(unsigned __int16 *)(v39 + 22);
        int v41 = *(_DWORD *)(v39 + 16);
        v42 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        v43 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedShort:]( (id)v37[280],  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v39 + 20)));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v43,  IOSurfacePropertyKeyPlaneWidth);

        v44 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedShort:]( (id)v37[280],  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v39 + 22)));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v44,  IOSurfacePropertyKeyPlaneHeight);

        v45 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedShort:]( (id)v37[280],  "numberWithUnsignedShort:",  *(unsigned __int16 *)(v39 + 24)));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v45,  IOSurfacePropertyKeyPlaneBytesPerElement);

        v46 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedInt:]( (id)v37[280],  "numberWithUnsignedInt:",  *(unsigned int *)(v39 + 16)));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v46,  IOSurfacePropertyKeyPlaneBytesPerRow);

        if (*(_WORD *)(v39 + 26))
        {
          v47 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D numberWithUnsignedShort:]((id)v37[280], "numberWithUnsignedShort:"));
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v47,  IOSurfacePropertyKeyPlaneElementWidth);
        }

        if (*(_WORD *)(v39 + 28))
        {
          v48 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D numberWithUnsignedShort:]((id)v37[280], "numberWithUnsignedShort:"));
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v48,  IOSurfacePropertyKeyPlaneElementHeight);
        }

        uint64_t v49 = (v41 * v40);
        v50 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D numberWithUnsignedInteger:]((id)v37[280], "numberWithUnsignedInteger:", v71));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v50,  IOSurfacePropertyKeyPlaneOffset);

        v51 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D numberWithUnsignedInteger:]((id)v37[280], "numberWithUnsignedInteger:", v49));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v42,  "setObject:forKeyedSubscript:",  v51,  IOSurfacePropertyKeyPlaneSize);

        if (v72)
        {
          uint64_t v70 = v49;
          __int128 v75 = 0u;
          __int128 v76 = 0u;
          __int128 v73 = 0u;
          __int128 v74 = 0u;
          v52 = (void *)objc_claimAutoreleasedReturnValue([v72 objectAtIndexedSubscript:v38]);
          id v53 = [v52 countByEnumeratingWithState:&v73 objects:v81 count:16];
          if (v53)
          {
            id v54 = v53;
            uint64_t v55 = *(void *)v74;
            do
            {
              for (j = 0LL; j != v54; j = (char *)j + 1)
              {
                if (*(void *)v74 != v55) {
                  objc_enumerationMutation(v52);
                }
                uint64_t v57 = *(void *)(*((void *)&v73 + 1) + 8LL * (void)j);
                if (([v36 containsObject:v57] & 1) == 0)
                {
                  v58 = (void *)objc_claimAutoreleasedReturnValue([v72 objectAtIndexedSubscript:v38]);
                  v59 = (void *)objc_claimAutoreleasedReturnValue([v58 objectForKeyedSubscript:v57]);
                  -[NSMutableDictionary setObject:forKeyedSubscript:](v42, "setObject:forKeyedSubscript:", v59, v57);
                }
              }

              id v54 = [v52 countByEnumeratingWithState:&v73 objects:v81 count:16];
            }

            while (v54);
          }

          uint64_t v35 = v68;
          v37 = &CATransform3DIdentity_ptr;
          uint64_t v49 = v70;
        }

        id v60 = -[NSMutableDictionary copy](v42, "copy");
        -[NSMutableArray addObject:](v69, "addObject:", v60);

        v71 += v49;
        ++v38;
      }

      while (v38 < *(unsigned __int8 *)(v35 + 102));
    }

    id v61 = -[NSMutableArray copy](v69, "copy");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v67,  "setObject:forKeyedSubscript:",  v61,  IOSurfacePropertyKeyPlaneInfo);

    v26 = v66;
  }

  v62 = (void *)objc_claimAutoreleasedReturnValue([v65 iosurfaceForProperties:v67]);
  return v62;
}

NSMutableArray *MakeNSArray(uint64_t *a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
  if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = *a1++;
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v8));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v9]);
      -[NSMutableArray addObject:](v6, "addObject:", v10);

      --v7;
    }

    while (v7);
  }

  return v6;
}

id NewLibraryWithFile(void *a1, uint64_t a2, char *a3, char *a4, int a5, uint64_t a6, void *a7)
{
  id v13 = a1;
  unint64_t v14 = *(void **)(a2 + 144);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a6));
  id v16 = (id)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v15]);

  if (!v16)
  {
    if (a3)
    {
      id v17 = *(void **)(a2 + 128);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a6));
      id v19 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:v18]);

      if (v19)
      {
        id v20 = MTLDevice_newLibraryWithFile(v13, (uint64_t)v19, a7);
        v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      }

      else
      {
        v22 = **(void ***)a2;
        uint64_t v23 = *(void *)(a2 + 152);
        FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename((uint64_t)v22, a3);
        if (a5)
        {
          if (a4) {
            v25 = a4;
          }
          else {
            v25 = a3;
          }
          id v26 = GTMTLReplayController_dumpLibrary(a2, a3, v25);
          dispatch_data_t v27 = (dispatch_data_t)objc_claimAutoreleasedReturnValue(v26);
          id v28 = MTLDevice_newLibraryWithFile(v13, (uint64_t)v27, a7);
          uint64_t v29 = objc_claimAutoreleasedReturnValue(v28);
        }

        else
        {
          id v30 = FileWithFilename;
          if ((FileWithFilename[4] & 2) != 0)
          {
            v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *v22));
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
            v36 = (void *)objc_claimAutoreleasedReturnValue([v34 stringByAppendingPathComponent:v35]);

            v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v36));
            id v38 = MTLDevice_newLibraryWithFile(v13, (uint64_t)v37, a7);
            v21 = (void *)objc_claimAutoreleasedReturnValue(v38);

            goto LABEL_15;
          }

          size_t v31 = *FileWithFilename;
          uint64_t v32 = malloc(v31);
          GTCaptureArchive_fillBufferCompressedDeflate((uint64_t)v22, v23, (uint64_t)v30, v32, v31, 0LL);
          dispatch_data_t v27 = dispatch_data_create(v32, *v30, 0LL, _dispatch_data_destructor_free);
          id v33 = MTLDevice_newLibraryWithData(v13, (uint64_t)v27, a7);
          uint64_t v29 = objc_claimAutoreleasedReturnValue(v33);
        }

        v21 = (void *)v29;
      }

MTLCompileOptions *_MakeMTLCompileOptions(uint64_t a1, void *a2)
{
  if (a1)
  {
    MTLCompileOptions = MakeMTLCompileOptions(a1, a2);
    unint64_t v3 = (MTLCompileOptions *)objc_claimAutoreleasedReturnValue(MTLCompileOptions);
  }

  else
  {
    unint64_t v3 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  }

  uint64_t v4 = v3;
  -[MTLCompileOptions setDebuggingEnabled:](v3, "setDebuggingEnabled:", 1LL);
  return v4;
}

id NewLibraryWithSource(uint64_t a1, void *a2, char *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a4;
  uint64_t v11 = StringFromArchive(**(void ***)a1, *(void *)(a1 + 152), a3);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  if ([v10 libraryType] == (char *)&dword_0 + 1)
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v10 installName]);
    unsigned int v14 = [v13 hasPrefix:@"/"];

    if (v14)
    {
      uint64_t v15 = *(void **)(a1 + 22568);
      id v16 = (void *)objc_claimAutoreleasedReturnValue([v10 installName]);
      id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 substringFromIndex:1]);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v15 URLByAppendingPathComponent:v17]);

      id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 path]);
      [v10 setInstallName:v19];
    }
  }

  id v25 = 0LL;
  id v20 = [v9 newLibraryWithSource:v12 options:v10 error:&v25];
  id v21 = v25;
  v22 = v21;
  if (a5) {
    *a5 = v21;
  }
  id v23 = ValidateLibrary(v20);
  objc_claimAutoreleasedReturnValue(v23);

  return v20;
}

void GTMTLReplay_dispatchFailedToSet(uint64_t a1, uint64_t a2)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a1, 64LL));
  unint64_t v3 = (void *)funcMap;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
  [v3 setObject:v5 forKeyedSubscript:v4];
}

void GTMTLReplay_dispatchFailedToGet(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v4 = (void *)funcMap;
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1));
    id v27 = (id)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v5]);

    if (v27) {
      uint64_t v6 = [v27 bytes];
    }
    else {
      uint64_t v6 = 0LL;
    }
    uint64_t v7 = (void *)failureMap;
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1));
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

    if (v9)
    {
      id v10 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( NSNumber,  "numberWithInt:",  [v9 integerValue] + 1));
      uint64_t v11 = (void *)failureMap;
      uint64_t v12 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  a1));
      [v11 setObject:v10 forKeyedSubscript:v12];
    }

    else
    {
      id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", 1LL));
      unsigned int v14 = (void *)failureMap;
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1));
      [v14 setObject:v13 forKeyedSubscript:v15];

      if (v6)
      {
        unsigned int v16 = GetFuncEnumConstructorType(v6[2]) - 1;
        if (v16 > 0x55) {
          id v17 = "Unknown";
        }
        else {
          id v17 = (&off_5901A8)[v16];
        }
        id v10 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v17));
        FuncEnumAsString = GetFuncEnumAsString(v6[2]);
      }

      else
      {
        id v10 = 0LL;
        FuncEnumAsString = 0LL;
      }

      uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  v19,  @"GTErrorKeyTraceStreamID");

      if (a2) {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"GTErrorKeyResourceUnused");
      }
      if (v6)
      {
        id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v6));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  v20,  @"GTErrorKeyFunctionIndex");
      }

      if (FuncEnumAsString)
      {
        id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  FuncEnumAsString));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  v21,  @"GTErrorKeyFenum");
      }

      if (!v10
        || (-[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  v10,  @"GTErrorKeyReceiverType"),  -[__CFString isEqualToString:](v10, "isEqualToString:", @"Unknown")))
      {

        id v10 = @"Metal object";
      }

      if (FuncEnumAsString)
      {
        v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  FuncEnumAsString));
        id v23 = PrettifyFenumString(v22);
        v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
        id v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ creation failed when calling %@.",  v10,  v24));
      }

      else
      {
        id v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ creation failed.",  v10));
      }

      -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  v25,  NSLocalizedDescriptionKey);
      id v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"com.apple.gputools.MTLReplayer",  150LL,  v12));
      GTMTLReplay_handleNSError(v26);
    }
  }

uint64_t GetEnvDefault(const char *a1, uint64_t a2)
{
  unint64_t v3 = getenv(a1);
  if (v3) {
    return strtol(v3, 0LL, 0);
  }
  else {
    return a2;
  }
}

id GTApplePMPPerfStateControl::EnableConsistentPerfState(GTApplePMPPerfStateControl *this, uint64_t a2)
{
  if (a2 <= 2)
  {
    int v3 = a2;
    id v5 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, a2);
    *((_DWORD *)this + 3) = v3;
    uint64_t v6 = *(void *)this;
    uint64_t v7 = operator new(0x28uLL);
    *uint64_t v7 = 0u;
    v7[1] = 0u;
    *((void *)v7 + 4) = v6;
    unsigned int v8 = *((_DWORD *)this + 452);
    if (v8)
    {
      char v9 = 0;
      unint64_t v10 = 0LL;
      uint64_t v11 = this;
      do
      {
        uint64_t v12 = *((void *)v11 + 5);
        if (v12)
        {
          id v13 = (uint64_t *)((char *)this + 56 * v10 + 8 * *((unsigned int *)this + 3) + 24);
          unsigned int v14 = v13;
        }

        else
        {
          id v13 = (uint64_t *)((char *)v11 + 56);
          unsigned int v14 = (uint64_t *)((char *)v11 + 64);
        }

        uint64_t v15 = *v14;
        *((void *)v7 + (v10 >> 4)) |= *v13 << (v9 & 0x3C);
        *((void *)v7 + (v10 >> 4) + 2) |= v15 << (v9 & 0x3C);
        if (v12 && *((void *)v11 + 2))
        {
          unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v11 + *((unsigned int *)this + 3) + 3)));
          [v5 setObject:v16 forKeyedSubscript:*((void *)v11 + 2)];

          unsigned int v8 = *((_DWORD *)this + 452);
        }

        ++v10;
        uint64_t v11 = (GTApplePMPPerfStateControl *)((char *)v11 + 56);
        v9 += 4;
      }

      while (v10 < v8);
    }

    GTApplePMPPerfStateControl::SetDVFSContraints(this, 0);
    else {
      id v2 = [v5 copy];
    }
    operator delete(v7);
  }

  else
  {
    id v2 = 0LL;
  }

  return v2;
}

void sub_FA428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTApplePMPPerfStateControl::SetDVFSContraints(GTApplePMPPerfStateControl *this, int a2)
{
  if (!*((_DWORD *)this + 454))
  {
    uint64_t v2 = 0LL;
    input[0] = 2LL;
    input[1] = 0LL;
    if (a2) {
      uint64_t v3 = 1LL;
    }
    else {
      uint64_t v3 = 2LL;
    }
    input[2] = 0LL;
    input[3] = v3;
    if ((a2 & 1) == 0) {
      uint64_t v2 = *(void *)this;
    }
    input[4] = v2;
    uint64_t v4 = IOConnectCallMethod(*((_DWORD *)this + 2), 6u, input, 5u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
    uint64_t v5 = v4;
    if ((_DWORD)v4)
    {
      uint64_t v6 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", mach_error_string(v4));
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to send PM command (0x%x - %@)",  v5,  v7));

      char v9 = __stdoutp;
      int v10 = g_runningInCI;
      id v11 = v8;
      uint64_t v12 = (const char *)[v11 UTF8String];
      id v13 = "#CI_ERROR# ";
      if (!v10) {
        id v13 = "";
      }
      fprintf(v9, "%s%s %u: %s\n", v13, "IOReturn GTApplePMPPerfStateControl::SetDVFSContraints(BOOL)", 328, v12);
      id v14 = v11;
      GTMTLReplay_handleError( 101,  (uint64_t)[v14 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm",  (uint64_t)"SetDVFSContraints",  328,  2);
    }
  }

void sub_FA5EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTApplePMPPerfStateControl::SetDVFSStates(GTApplePMPPerfStateControl *this, uint64_t *input)
{
  mach_port_t v3 = *((_DWORD *)this + 2);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = IOConnectCallMethod(v3, *((_DWORD *)this + 459), input, 5u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  uint64_t v5 = v4;
  if ((_DWORD)v4)
  {
    uint64_t v6 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", mach_error_string(v4));
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"_setDVFSStates (0x%x - %@)",  v5,  v7));

    char v9 = __stdoutp;
    int v10 = g_runningInCI;
    id v11 = v8;
    uint64_t v12 = (const char *)[v11 UTF8String];
    id v13 = "#CI_ERROR# ";
    if (!v10) {
      id v13 = "";
    }
    fprintf( v9,  "%s%s %u: %s\n",  v13,  "IOReturn GTApplePMPPerfStateControl::SetDVFSStates(uint64_t *, uint32_t)",  306,  v12);
    id v14 = v11;
    GTMTLReplay_handleError( 101,  (uint64_t)[v14 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm",  (uint64_t)"SetDVFSStates",  306,  2);
  }

  return v5;
}

void sub_FA758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTApplePMPPerfStateControl::DisableConsistentPerfState(GTApplePMPPerfStateControl *this)
{
  if (*((_DWORD *)this + 3) != 3)
  {
    uint64_t v2 = operator new(0x28uLL);
    mach_port_t v3 = v2;
    *uint64_t v2 = 0u;
    v2[1] = 0u;
    *((void *)v2 + 4) = 0LL;
    uint64_t v4 = *((unsigned int *)this + 452);
    if (*((_DWORD *)this + 452))
    {
      uint64_t v5 = 0LL;
      uint64_t v6 = 0LL;
      uint64_t v7 = (uint64_t *)((char *)this + 64);
      do
      {
        *((void *)v2 + (v6 >> 4)) |= *(v7 - 1) << (v5 & 0x3C);
        uint64_t v8 = *v7;
        v7 += 7;
        *((void *)v2 + (v6++ >> 4) + 2) |= v8 << (v5 & 0x3C);
        v5 += 4LL;
      }

      while (v4 != v6);
    }

    *((_DWORD *)this + 3) = 3;
    GTApplePMPPerfStateControl::SetDVFSStates(this, (uint64_t *)v2);
    GTApplePMPPerfStateControl::SetDVFSContraints(this, 1);
    operator delete(v3);
  }

void sub_FA834(_Unwind_Exception *a1)
{
}

void GTApplePMPPerfStateControl::Close(GTApplePMPPerfStateControl *this)
{
  io_connect_t v2 = *((_DWORD *)this + 2);
  if (v2)
  {
    IOServiceClose(v2);
    *((_DWORD *)this + 2) = 0;
    if (g_runningInCI)
    {
      id v5 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%u Connection Closed",  mach_task_self_));
      mach_port_t v3 = (void *)objc_claimAutoreleasedReturnValue( [v5 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

      uint64_t v4 = __stdoutp;
      id v6 = v3;
      fprintf(v4, "#CI-INFO# %s\n", (const char *)[v6 UTF8String]);
    }
  }

void sub_FA91C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id GTMTLReplayController_getResizeRenderPipelineState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = *(void **)(a1 + 152);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:"));
  id v8 = (id)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v7]);

  if (!v8)
  {
    id v9 = *(id *)(a1 + 80);
    int v10 = v9;
    int v11 = *(_DWORD *)(a2 + 8);
    uint64_t v12 = 10LL;
    uint64_t v13 = 90LL;
    if ((v11 & 0x800010) == 0x10) {
      uint64_t v13 = a3;
    }
    if ((v11 & 0x40) == 0) {
      uint64_t v12 = v13;
    }
    if ((v11 & 0x20) != 0) {
      uint64_t v14 = 55LL;
    }
    else {
      uint64_t v14 = v12;
    }
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v9 colorAttachments]);
    unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue([v15 objectAtIndexedSubscript:0]);
    [v16 setPixelFormat:v14];

    int v17 = *(_DWORD *)(a2 + 8);
    uint64_t v18 = (void *)(a1 + 88);
    if ((v17 & 0x40000) != 0) {
      uint64_t v18 = (void *)(a1 + 104);
    }
    if ((v17 & 0x80000) != 0) {
      uint64_t v18 = (void *)(a1 + 96);
    }
    if ((v17 & 0x40) != 0) {
      uint64_t v18 = (void *)(a1 + 120);
    }
    if ((v17 & 0x20) != 0) {
      id v19 = (void *)(a1 + 112);
    }
    else {
      id v19 = v18;
    }
    [v10 setFragmentFunction:*v19];
    id v20 = (void *)objc_claimAutoreleasedReturnValue([v10 fragmentFunction]);
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 device]);

    id v26 = 0LL;
    id v8 = [v21 newRenderPipelineStateWithDescriptor:v10 error:&v26];
    id v22 = v26;
    id v23 = *(void **)(a1 + 152);
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", a3));
    [v23 setObject:v8 forKeyedSubscript:v24];
  }

  return v8;
}

id GTMTLReplayController_resizeTexture( void *a1, uint64_t a2, void *a3, void *a4, unint64_t a5, unint64_t a6, void **a7)
{
  id v13 = a3;
  id v14 = a4;
  id v15 = a1;
  unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue([v14 device]);
  id v17 = [v14 pixelFormat];
  GTMTLPixelFormatGetInfoForDevice((uint64_t)v47, (uint64_t)v16, (uint64_t)v17);
  uint64_t v18 = 10LL;
  uint64_t v19 = 90LL;
  if ((DWORD2(v47[0]) & 0x800010) == 0x10) {
    uint64_t v19 = (uint64_t)v17;
  }
  if ((BYTE8(v47[0]) & 0x40) == 0) {
    uint64_t v18 = v19;
  }
  if ((BYTE8(v47[0]) & 0x20) != 0) {
    uint64_t v20 = 55LL;
  }
  else {
    uint64_t v20 = v18;
  }
  unint64_t v43 = a6;
  id v21 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( &OBJC_CLASS___MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  v20,  a5,  a6,  0LL));
  [v21 setUsage:5];
  [v21 setResourceOptions:32];
  [v21 setAllowGPUOptimizedContents:0];
  id v46 = 0LL;
  id v22 = [v15 newTextureWithDescriptor:v21 error:&v46];

  id v23 = v46;
  v24 = v23;
  if (v22)
  {
    id v38 = v23;
    int v40 = v16;
    __int128 v51 = 0u;
    __int128 v52 = 0u;
    uint64_t v53 = 0LL;
    __int128 v55 = 0u;
    __int128 v50 = 0u;
    int v49 = 1065353216;
    LODWORD(v51) = 1065353216;
    DWORD1(v52) = 1065353216;
    int v54 = 1065353216;
    id v25 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
    id v26 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v25, "colorAttachments"));
    id v27 = v13;
    id v28 = (void *)objc_claimAutoreleasedReturnValue([v26 objectAtIndexedSubscript:0]);
    [v28 setTexture:v22];

    v42 = v27;
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v27 renderCommandEncoderWithDescriptor:v25]);
    id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"ResizeTexture"));
    [v29 setLabel:v30];

    v44[0] = v47[0];
    v44[1] = v47[1];
    v44[2] = v47[2];
    uint64_t v45 = v48;
    id ResizeRenderPipelineState = GTMTLReplayController_getResizeRenderPipelineState(a2, (uint64_t)v44, (uint64_t)v17);
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(ResizeRenderPipelineState);
    [v29 setRenderPipelineState:v32];

    [v29 setVertexBuffer:*(void *)(a2 + 144) offset:0 atIndex:0];
    [v29 setVertexBuffer:*(void *)(a2 + 144) offset:96 atIndex:1];
    else {
      id v33 = (void *)(a2 + 128);
    }
    objc_msgSend(v29, "setFragmentSamplerState:atIndex:", *v33, 0, v38, v40);
    [v29 setFragmentTexture:v14 atIndex:0];
    [v29 setFragmentBytes:&v49 length:80 atIndex:0];
    [v29 drawPrimitives:3 vertexStart:0 vertexCount:6];
    [v29 endEncoding];
    id v34 = v22;

    unsigned int v16 = v41;
    id v13 = v42;
    v24 = v39;
  }

  else
  {
    if (v23)
    {
      NSErrorUserInfoKey v56 = NSUnderlyingErrorKey;
      id v57 = v23;
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v57,  &v56,  1LL));
    }

    else
    {
      uint64_t v35 = 0LL;
    }

    GTMTLReplay_fillError(a7, 101, v35);
    if (a7) {
      v36 = *a7;
    }
    else {
      v36 = 0LL;
    }
    GTMTLReplay_handleNSError(v36);
  }

  return v22;
}

NSMutableArray *GTMTLReplayClient_retrieveTexturesForResize(id *a1, void *a2, void *a3, int a4, void **a5)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a1[1];
  id v11 = a1[3];
  id v80 = a1[2];
  v85 = (void *)objc_claimAutoreleasedReturnValue([v10 defaultDevice]);
  id v78 = [v85 maxTextureWidth2D];
  __int128 v101 = 0uLL;
  __int128 v79 = objc_alloc_init(&OBJC_CLASS___MTLTextureDescriptor);
  -[MTLTextureDescriptor setResourceOptions:](v79, "setResourceOptions:", 32LL);
  id v12 = [v9 count];
  id v13 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  -[uint32_t count](v8, "count"));
  id v14 = v13;
  id v15 = &CATransform3DIdentity_ptr;
  id v86 = v12;
  if (!v12)
  {
    id v60 = v9;
    v81 = 0LL;
LABEL_77:
    v66 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D stringWithFormat:]( (id)v15[288],  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"TextureBlit"));
    v67 = (void *)objc_claimAutoreleasedReturnValue([v11 commandBuffer]);
    [v67 setLabel:v66];

    [v11 commitCommandBuffer];
    uint64_t v68 = v14;
    goto LABEL_89;
  }

  __int128 v73 = a5;
  __int128 v74 = v10;
  __int128 v76 = v11;
  __int128 v77 = v8;
  v81 = 0LL;
  v82 = v13;
  uint64_t v16 = 0LL;
  id v83 = v9;
  id v17 = v9;
  while (1)
  {
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:v16]);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[uint32_t objectAtIndexedSubscript:](v8, "objectAtIndexedSubscript:", v16));
    uint64_t v20 = (uint32_t *)[v18 pixelFormat];
    id v21 = (void *)objc_claimAutoreleasedReturnValue( [v19 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"]);
    id v22 = (int *)[v21 unsignedIntegerValue];

    if (v20 == &stru_B8.reserved3) {
      break;
    }
    uint64_t PlanePixelFormat = GetPlanePixelFormat((uint64_t)v20, 0LL);
    uint64_t v23 = (uint64_t)v20;
    if (!PlanePixelFormat) {
      goto LABEL_9;
    }
    -[NSMutableArray addObject:](v14, "addObject:", v18);
LABEL_69:

    if (v86 == (id)++v16)
    {
      id v60 = v17;
      if (v81) {
        GTMTLReplay_commitCommandBuffer(v81);
      }
      else {
        v81 = 0LL;
      }
      id v10 = v74;
      id v11 = v76;
      id v15 = &CATransform3DIdentity_ptr;
      goto LABEL_77;
    }
  }

  uint64_t v23 = 260LL;
LABEL_9:
  v92 = (uint32_t *)v23;
  id v25 = v8;
  unsigned __int8 v26 = [v18 usage];
  BOOL v27 = (v26 & 1) == 0LL;
  id v28 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:@"DependencyGraphRequestedTextureLevel"]);
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:@"DependencyGraphRequestedTextureSlice"]);
  v93 = v28;
  id v91 = [v28 unsignedIntegerValue];
  v88 = v29;
  id v89 = [v29 unsignedIntegerValue];
  int v30 = 0;
  id v8 = v25;
  size_t v31 = v92;
  switch((unint64_t)[v18 textureType])
  {
    case 0uLL:
    case 1uLL:
    case 7uLL:
    case 9uLL:
      int v30 = 0;
      if (v20 != v92)
      {
        BOOL v27 = 1;
        goto LABEL_23;
      }

      int v90 = 0;
      goto LABEL_31;
    case 2uLL:
      int v30 = 0;
      if (v93 || v20 != v92) {
        goto LABEL_23;
      }
      goto LABEL_28;
    case 3uLL:
    case 5uLL:
    case 6uLL:
      goto LABEL_23;
    case 4uLL:
    case 8uLL:
      if ((v26 & 1) != 0) {
        BOOL v27 = 0;
      }
      else {
        BOOL v27 = a4;
      }
      if (!a4 || v20 == v92)
      {
        int v30 = a4;
LABEL_28:
        int v90 = 0;
        if ((v30 & 1) == 0 && !v27)
        {
          id v33 = v18;
          id v14 = v82;
          id v17 = v83;
          id v34 = v89;
          id v35 = v91;
          goto LABEL_64;
        }
      }

      else
      {
        int v30 = 1;
LABEL_23:
        unsigned __int8 v32 = [v18 usage];
        int v90 = 1;
        if ((v30 & 1) == 0 && (v32 & 0x10) != 0 && !v27)
        {
          id v33 = v18;
          id v14 = v82;
          id v17 = v83;
          id v34 = v89;
          id v35 = v91;
          goto LABEL_62;
        }
      }

void GTMTLReplayClient_resizeResolution(unint64_t *a1, void *a2, unint64_t *a3)
{
  id v5 = a2;
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"width"]);
  id v7 = [v6 unsignedIntegerValue];
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"height"]);
  id v9 = [v8 unsignedIntegerValue];

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"format"]);
  id v11 = [v10 unsignedIntegerValue];

  unint64_t v12 = *a3;
  unint64_t v13 = a3[1];
  unint64_t v14 = *a3;
  unint64_t v15 = v13;
  if (*a3 < (unint64_t)v7 && v13 < (unint64_t)v9 && v11)
  {
    float v16 = (float)(unint64_t)v7 / (float)v12;
    unint64_t v14 = (unint64_t)(float)(v16 * (float)v12);
    unint64_t v15 = (unint64_t)(float)(v16 * (float)v13);
  }

  if (v14 <= (unint64_t)v7)
  {
    goto LABEL_11;
  }

  if (!v11) {
    goto LABEL_17;
  }
  if (v15 > (unint64_t)v9)
  {
LABEL_11:
    float v20 = (float)(unint64_t)v9 / (float)v13;
    float v18 = v20 * (float)v12;
    float v19 = v20 * (float)v13;
    if (v18 > (float)(unint64_t)v7)
    {
      float v21 = (float)(unint64_t)v7 / v18;
      float v18 = v18 * v21;
      float v19 = v19 * v21;
    }

    goto LABEL_13;
  }

  float v17 = (float)(unint64_t)v7 / (float)v14;
  float v18 = v17 * (float)v14;
  float v19 = v17 * (float)v15;
LABEL_13:
  unint64_t v14 = (unint64_t)v18;
  unint64_t v15 = (unint64_t)v19;
  if (v15 <= 0x10) {
    unint64_t v15 = 16LL;
  }
LABEL_17:
  if (v7) {
    unint64_t v12 = v14;
  }
  if (v9) {
    unint64_t v13 = v15;
  }
  *a1 = v12;
  a1[1] = v13;
  a1[2] = 1LL;
}

void sub_FBA54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___GTAccelerationStructureServerSession;
  -[_Unwind_Exception dealloc](&a9, "dealloc");
  _Unwind_Resume(a1);
}

void GTMTLReplayWireframeRenderer_initWithDevice(uint64_t a1, void *a2)
{
  *(void *)(a1 + 48) = 1LL;
  id v3 = a2;
  id v4 = GTMTLReplayController_defaultLibrary(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  id v6 = [v5 newFunctionWithName:@"wireframeCreationFragment"];
  [v6 setLabel:@"wireframeCreationFragment"];
  id v7 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v6;
  id v8 = v6;

  *(void *)(a1 + 16) = 10LL;
  id v9 = [v5 newFunctionWithName:@"createOutlineTexture"];
  id v59 = 0LL;
  id v10 = [v3 newComputePipelineStateWithFunction:v9 error:&v59];
  id v11 = v59;
  unint64_t v12 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v10;

  id v13 = [v5 newFunctionWithName:@"createOutlineTextureMS"];
  id v58 = v11;
  id v14 = [v3 newComputePipelineStateWithFunction:v13 error:&v58];
  id v15 = v58;

  float v16 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v14;

  float v17 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  float v18 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v17;

  float v19 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  float v20 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v19;

  id v21 = [v5 newFunctionWithName:@"passthoughVertex"];
  [*(id *)(a1 + 80) setVertexFunction:v21];

  id v22 = [v5 newFunctionWithName:@"fragmentShader"];
  uint64_t v23 = *(void **)(a1 + 88);
  *(void *)(a1 + 88) = v22;

  id v24 = [v5 newFunctionWithName:@"fragmentShaderUint"];
  id v25 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v24;

  id v26 = [v5 newFunctionWithName:@"fragmentShaderSint"];
  BOOL v27 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = v26;

  id v28 = [v5 newFunctionWithName:@"depthShader"];
  uint64_t v29 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = v28;

  id v30 = [v5 newFunctionWithName:@"stencilShader"];
  size_t v31 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = v30;

  unsigned __int8 v32 = objc_alloc_init(&OBJC_CLASS___MTLSamplerDescriptor);
  -[MTLSamplerDescriptor setMinFilter:](v32, "setMinFilter:", 0LL);
  -[MTLSamplerDescriptor setMagFilter:](v32, "setMagFilter:", 0LL);
  -[MTLSamplerDescriptor setMipFilter:](v32, "setMipFilter:", 0LL);
  id v33 = [v3 newSamplerStateWithDescriptor:v32];
  id v34 = *(void **)(a1 + 128);
  *(void *)(a1 + 128) = v33;

  -[MTLSamplerDescriptor setMinFilter:](v32, "setMinFilter:", 1LL);
  -[MTLSamplerDescriptor setMagFilter:](v32, "setMagFilter:", 1LL);
  -[MTLSamplerDescriptor setMipFilter:](v32, "setMipFilter:", 2LL);
  id v35 = [v3 newSamplerStateWithDescriptor:v32];
  id v36 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = v35;

  uint64_t v37 = objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( &OBJC_CLASS___MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  10LL,  128LL,  128LL,  0LL));
  id v38 = *(id *)a1;
  *(void *)a1 = v37;

  [*(id *)a1 setUsage:21];
  [*(id *)a1 setResourceOptions:32];
  uint64_t v39 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
  id v40 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v39;

  uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) colorAttachments]);
  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 objectAtIndexedSubscript:0]);

  [v42 setLoadAction:2];
  objc_msgSend(v42, "setClearColor:", 0.0, 0.0, 0.0, 0.0);
  id v43 = [v3 newBufferWithBytes:&GTMTLReplayWireframeRenderer_initWithDevice_posData length:144 options:0];
  v44 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = v43;

  id v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 80) vertexDescriptor]);
  char v46 = (void *)objc_claimAutoreleasedReturnValue([v45 attributes]);
  v47 = (void *)objc_claimAutoreleasedReturnValue([v46 objectAtIndexedSubscript:0]);
  [v47 setFormat:31];

  uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v45 attributes]);
  int v49 = (void *)objc_claimAutoreleasedReturnValue([v48 objectAtIndexedSubscript:1]);
  [v49 setFormat:29];

  __int128 v50 = (void *)objc_claimAutoreleasedReturnValue([v45 attributes]);
  __int128 v51 = (void *)objc_claimAutoreleasedReturnValue([v50 objectAtIndexedSubscript:1]);
  [v51 setBufferIndex:1];

  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v45 layouts]);
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v52 objectAtIndexedSubscript:0]);
  [v53 setStride:16];

  int v54 = (void *)objc_claimAutoreleasedReturnValue([v45 layouts]);
  __int128 v55 = (void *)objc_claimAutoreleasedReturnValue([v54 objectAtIndexedSubscript:1]);
  [v55 setStride:8];

  id v56 = [v3 newBufferWithLength:0x2000000 options:0];
  id v57 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = v56;
}

id GTMTLReplayController_generateWireframeTexture( uint64_t a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4, void **a5)
{
  int v6 = (int)a4;
  id v9 = (_DWORD *)(a1 + 22480);
  apr_pool_create_ex(&newpool, 0LL, 0LL, a4);
  uint64_t v71 = *(void *)a1;
  id v72 = *(id *)(a1 + 8);
  uint64_t v10 = *(void *)(*(void *)a1 + 120LL);
  unint64_t v11 = (*v9 - 1);
  if (v11 >= *(int *)(v10 + 12))
  {
    GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
    if (a5) {
      float v17 = *a5;
    }
    else {
      float v17 = 0LL;
    }
  }

  else
  {
    uint64_t v12 = GTMTLReplayController_renderPassDescriptor(a1);
    if (v12)
    {
      uint64_t v13 = v12;
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v72 renderPassDescriptorMap]);
      MTLRenderPassDescriptor = MakeMTLRenderPassDescriptor(v13, v14);
      float v16 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

      if (!v16)
      {
        GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
        if (a5) {
          float v18 = *a5;
        }
        else {
          float v18 = 0LL;
        }
        GTMTLReplay_handleNSError(v18);
LABEL_40:

        goto LABEL_41;
      }

      if ((GT_SUPPORT_0 & 0x80) != 0)
      {
        [*(id *)(a2 + 8) setRenderTargetArrayLength:*(unsigned __int16 *)(v13 + 806)];
        unsigned int v19 = *(unsigned __int16 *)(v13 + 806);
        if (v19 <= 1) {
          unsigned int v19 = 1;
        }
        unsigned int v69 = v19;
        if ((GT_SUPPORT_0 & 0x100) == 0) {
          goto LABEL_19;
        }
      }

      else
      {
        unsigned int v69 = 1;
        if ((GT_SUPPORT_0 & 0x100) == 0) {
          goto LABEL_19;
        }
      }

      float v20 = (void *)objc_claimAutoreleasedReturnValue([v72 rasterizationRateMapForKey:*(void *)(v13 + 784)]);
      [*(id *)(a2 + 8) setRasterizationRateMap:v20];

      [v16 setRasterizationRateMap:0];
LABEL_19:
      id v21 = (void *)objc_claimAutoreleasedReturnValue([v72 defaultDevice]);
      unsigned __int8 v22 = [v16 validate:v21 width:&v79 height:v80];

      if ((v22 & 1) != 0)
      {

        v66 = (void *)a2;
        uint64_t v23 = *(void *)(v10 + 24) + (v11 << 6);
        unsigned int v24 = *(_DWORD *)(v23 + 8);
        int v25 = IsFuncEnumDrawCall(v24);
        memcpy(__dst, (const void *)(a1 + 11368), sizeof(__dst));
        if ((v24 & 0xFFFFFFFC) == 0xFFFFC1A4) {
          int v26 = 1;
        }
        else {
          int v26 = v25;
        }
        int v68 = v26;
        if ((v24 & 0xFFFFFFFC) == 0xFFFFC1A4)
        {
          p = **(apr_pool_t ***)(a1 + 152);
          GTMTLSMContext_indirectCommandBufferResources((uint64_t)v76, *(_DWORD ***)(v71 + 40), *(void *)v23, p);
          GetExecuteCommandsInBufferArgs((uint64_t)v74, v23, *(void *)(v71 + 16));
          Object = GTMTLSMContext_getObject(**(void **)(v71 + 40), v74[0], *(void *)v23);
          if (!Object)
          {
            GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
            if (a5) {
              uint64_t v37 = *a5;
            }
            else {
              uint64_t v37 = 0LL;
            }
LABEL_49:
            GTMTLReplay_handleNSError(v37);
            goto LABEL_41;
          }

          GTMTLCreateIndirectCommandEncoder((uint64_t)v75, Object[13]);
          uint64_t v77 = v74[3] + v75[13] * v9[1];
          uint64_t v64 = v77;
          GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)__dst, v75, v77, v76);
          unsigned int v24 = *(_DWORD *)(v23 + 8);
        }

        uint64_t v29 = *(void *)(a1 + 19912);
        if (v24 >> 2 == 1073737833 && !*(_BYTE *)(v75[0] + 11LL)) {
          uint64_t v29 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(v76[3], *(void *)(v64 + v75[2]));
        }
        id v30 = GTMTLSMContext_getObject(**(void **)(v71 + 40), v29, *(void *)v23);
        if (v30)
        {
          size_t v31 = v30;
          if ((v68 & v6) == 1)
          {
            uint64_t v32 = v30[6];
            id v33 = v66;
            if (v32) {
              unint64_t v34 = *(void *)(v32 + 1272);
            }
            else {
              unint64_t v34 = 1LL;
            }
            uint64_t v38 = v30[9];
            if (v38) {
              unint64_t v34 = *(unsigned __int8 *)(v38 + 508);
            }
          }

          else
          {
            unint64_t v34 = 1LL;
            id v33 = v66;
          }

          uint64_t v39 = (id *)(v33 + 4);
          uint64_t v40 = 5LL;
          if (a3 == 1) {
            uint64_t v40 = 4LL;
          }
          else {
            uint64_t v39 = (id *)(v33 + 5);
          }
          location = v39;
          id v41 = (id)v33[v40];
          v67 = (void *)objc_claimAutoreleasedReturnValue([v72 defaultDevice]);
          uint64_t v42 = v41;
          if (!v41) {
            goto LABEL_64;
          }
          id v43 = [v41 width];
          BOOL v44 = v43 == v79;
          uint64_t v42 = v41;
          if (!v44
            || (id v45 = [v41 height], v44 = v45 == v80[0], v42 = v41, !v44)
            || (v44 = [v41 arrayLength] == (id)v69, uint64_t v42 = v41, !v44)
            || (v44 = [v41 sampleCount] == (id)v34, uint64_t v42 = v41, !v44))
          {
LABEL_64:

            char v46 = (void *)objc_claimAutoreleasedReturnValue([(id)v33[1] colorAttachments]);
            v47 = (void *)objc_claimAutoreleasedReturnValue([v46 objectAtIndexedSubscript:0]);
            [v47 setTexture:0];

            uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([(id)v33[1] colorAttachments]);
            int v49 = (void *)objc_claimAutoreleasedReturnValue([v48 objectAtIndexedSubscript:0]);
            [v49 setResolveTexture:0];

            [(id)*v33 setWidth:v79];
            [(id)*v33 setHeight:v80[0]];
            uint64_t v50 = 2LL;
            if (v69 > 1) {
              uint64_t v50 = 3LL;
            }
            uint64_t v51 = 4LL;
            if (v69 > 1) {
              uint64_t v51 = 8LL;
            }
            if (v34 <= 1) {
              uint64_t v52 = v50;
            }
            else {
              uint64_t v52 = v51;
            }
            [(id)*v33 setTextureType:v52];
            v33[6] = v34;
            [(id)*v33 setArrayLength:v69];
            [(id)*v33 setSampleCount:v34];
            id v53 = [v67 newTextureWithDescriptor:*v33];
            id v41 = v53;
            if (!v53)
            {
              v82 = @"GTErrorKeyMTLTextureDescriptor";
              id v59 = SerializeMTLTextureDescriptorToDictionary((void *)*v33);
              id v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
              id v83 = v60;
              id v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v83,  &v82,  1LL));

              GTMTLReplay_fillError(a5, 101, v61);
              if (a5) {
                v62 = *a5;
              }
              else {
                v62 = 0LL;
              }
              GTMTLReplay_handleNSError(v62);

              v63 = 0LL;
              id v35 = 0LL;
LABEL_81:

              goto LABEL_42;
            }

            objc_storeStrong(location, v53);
            int v54 = (void *)objc_claimAutoreleasedReturnValue([(id)v33[1] colorAttachments]);
            __int128 v55 = (void *)objc_claimAutoreleasedReturnValue([v54 objectAtIndexedSubscript:0]);
            [v55 setStoreAction:1];
          }

          id v56 = (void *)objc_claimAutoreleasedReturnValue([(id)v33[1] colorAttachments]);
          id v57 = (void *)objc_claimAutoreleasedReturnValue([v56 objectAtIndexedSubscript:0]);
          [v57 setTexture:v41];

          if ((v68 & 1) != 0)
          {
            id v58 = (char *)&loc_FC5EC
                + 4
                * byte_314630[GTMTLSMRenderPipelineState_renderPipelineDescriptorType( *(uint64_t **)(v71 + 40),  v31)];
            __asm { BR              X10 }
          }

          id v35 = v41;
          v63 = v35;
          goto LABEL_81;
        }

        GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
        if (a5) {
          uint64_t v37 = *a5;
        }
        else {
          uint64_t v37 = 0LL;
        }
        goto LABEL_49;
      }

      GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
      if (a5) {
        id v28 = *a5;
      }
      else {
        id v28 = 0LL;
      }
      GTMTLReplay_handleNSError(v28);
      goto LABEL_40;
    }

    GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
    if (a5) {
      float v17 = *a5;
    }
    else {
      float v17 = 0LL;
    }
  }

  GTMTLReplay_handleNSError(v17);
LABEL_41:
  id v35 = 0LL;
LABEL_42:

  apr_pool_destroy(newpool);
  return v35;
}

void sub_FCDC8(_Unwind_Exception *a1)
{
}

void *GroupBuilder_getCommandEncoder(int a1, void *a2, unint64_t a3)
{
  InclusiveRange = GroupBuilder_findInclusiveRange(a1, a2, a3);
  while (InclusiveRange)
  {
    if (IsFuncEnumCreateCommandEncoder(*((_DWORD *)InclusiveRange + 7))) {
      break;
    }
    uint64_t v4 = *((unsigned int *)InclusiveRange + 4);
    if ((_DWORD)v4) {
      InclusiveRange -= 4 * v4;
    }
    else {
      InclusiveRange = 0LL;
    }
  }

  return InclusiveRange;
}

id GTMTLReplayController_generateOutlineTexture(uint64_t a1, id *a2, void **a3)
{
  id v41 = 0LL;
  id v6 = GTMTLReplayController_generateWireframeTexture( a1,  (uint64_t)a2,  0LL,  (apr_allocator_t *)((char *)&dword_0 + 1),  &v41);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  id v8 = v41;
  id v9 = v8;
  if (!v7)
  {
    if (v8)
    {
      NSErrorUserInfoKey v44 = NSUnderlyingErrorKey;
      id v45 = v8;
      id v10 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v45,  &v44,  1LL));
    }

    else
    {
      id v10 = 0LL;
    }

    GTMTLReplay_fillError(a3, 101, v10);
    if (a3) {
      id v33 = *a3;
    }
    else {
      id v33 = 0LL;
    }
    GTMTLReplay_handleNSError(v33);
    id v13 = 0LL;
    goto LABEL_30;
  }

  id v10 = [*a2 copy];
  [v10 setUsage:18];
  if ((unint64_t)[v7 sampleCount] >= 2)
  {
    [v10 setSampleCount:1];
    if ([v7 textureType] == &dword_4)
    {
      uint64_t v11 = 2LL;
LABEL_9:
      [v10 setTextureType:v11];
      goto LABEL_10;
    }

    if ([v7 textureType] == &dword_8)
    {
      uint64_t v11 = 3LL;
      goto LABEL_9;
    }
  }

void sub_FD5D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_FDA30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>>>::__deallocate_node( void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      io_connect_t v2 = (void *)*v1;
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(v1 + 3));
      operator delete(v1);
      uint64_t v1 = v2;
    }

    while (v2);
  }

void sub_FE6C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, char a10)
{
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }

void sub_FE7F0(_Unwind_Exception *a1)
{
  id v3 = v2;

  _Unwind_Resume(a1);
}

void sub_FEB1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_FED08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_FF298( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, void **a23)
{
  a23 = (void **)&a17;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&a23);

  a23 = (void **)&a20;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&a23);
  _Unwind_Resume(a1);
}

void sub_FF948( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void **a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  a35 = (void **)&a53;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&a35);
  std::deque<unsigned int>::~deque[abi:nn180100](v53 - 224);
  std::deque<unsigned int>::~deque[abi:nn180100](v53 - 176);
  std::deque<ProfileEvent>::~deque[abi:nn180100]((void *)(v53 - 128));
  _Unwind_Resume(a1);
}

void sub_FFAF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t *a10)
{
  if (a10)
  {
    std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelperImpl>::reset[abi:nn180100](a10, 0LL);
    operator delete(a10);
  }

  _Unwind_Resume(a1);
}

LABEL_248:
            ++v196[3];
LABEL_249:
            if ((v252[31] & 0x80000000) != 0) {
              operator delete(*(void **)&v252[8]);
            }
            self = v240;
            std::string::basic_string[abi:nn180100]<0>( v252, (char *)[v203 UTF8String]);
            -[DYPMTLShaderProfilerHelper _setupShaderBinaryInfo:withBinaryKey:andNumDraws:]( v240,  "_setupShaderBinaryInfo:withBinaryKey:andNumDraws:",  v201,  v252,  v238);
            if ((v252[23] & 0x80000000) != 0) {
              operator delete(*(void **)v252);
            }
          }

          v195 = [obj countByEnumeratingWithState:&v243 objects:v254 count:16];
        }

        while (v195);
      }
    }

LABEL_266:
    v143 = v234 + 1;
  }

  objc_autoreleasePoolPop(context);
}

void sub_101054( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45)
{
  _Unwind_Resume(a1);
}

LABEL_43:
  ++*((void *)self + 55);
LABEL_44:
  v574 = *((_DWORD *)v16 + 5);
  v434 = (char *)self + 496;
  *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)self + 496,  v574,  &v574)
  + 5) = v14;
  size_t v31 = 0x1FFFFFFFFFFFFFFFLL;
  while (1)
  {
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([*((id *)self + 21) objectAtIndexedSubscript:v437]);
    id v33 = [v32 count];
    unint64_t v34 = v574;
    id v35 = (unint64_t)v33 > v574;

    if (v35) {
      break;
    }
    id v36 = objc_autoreleasePoolPush();
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 21) objectAtIndexedSubscript:v437]);
    uint64_t v39 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v38);
    [v37 addObject:v39];

    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 22) objectAtIndexedSubscript:v437]);
    uint64_t v42 = (void *)objc_opt_new(&OBJC_CLASS___NSData, v41);
    [v40 addObject:v42];

    id v43 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 23) objectAtIndexedSubscript:v437]);
    id v45 = (void *)objc_opt_new(&OBJC_CLASS___NSData, v44);
    [v43 addObject:v45];

    char v46 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 24) objectAtIndexedSubscript:v437]);
    uint64_t v48 = (void *)objc_opt_new(&OBJC_CLASS___NSData, v47);
    [v46 addObject:v48];

    objc_autoreleasePoolPop(v36);
    int v49 = *((void *)val + 25);
    uint64_t v50 = operator new(0x18uLL);
    uint64_t v51 = v50;
    void *v50 = 0LL;
    v50[1] = 0LL;
    v50[2] = 0LL;
    v559 = (void **)v50;
    uint64_t v52 = v49 + 24LL * v437;
    __int128 v55 = *(void **)(v52 + 8);
    uint64_t v53 = v52 + 8;
    int v54 = v55;
    id v57 = (unint64_t *)(v53 + 8);
    id v56 = *(void *)(v53 + 8);
    if ((unint64_t)v55 >= v56)
    {
      id v59 = (void *)(v49 + 24LL * v437);
      id v60 = ((uint64_t)v54 - *v59) >> 3;
      id v61 = v56 - *v59;
      v62 = v61 >> 2;
      else {
        v63 = v62;
      }
      v583 = (void (*)(uint64_t))(v53 + 8);
      if (v63) {
        v63 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v63);
      }
      else {
        uint64_t v64 = 0LL;
      }
      id v65 = (void *)(v63 + 8 * v60);
      v66 = v63 + 8 * v64;
      *((void *)&v582 + 1) = v66;
      v559 = 0LL;
      *id v65 = v51;
      id v58 = v65 + 1;
      *(void *)&v582 = v65 + 1;
      v67 = *(void **)v53;
      int v68 = (void *)*v59;
      if (*(void *)v53 == *v59)
      {
        uint64_t v70 = *(void **)v53;
      }

      else
      {
        do
        {
          unsigned int v69 = *--v67;
          void *v67 = 0LL;
          *--id v65 = v69;
        }

        while (v67 != v68);
        uint64_t v70 = (void *)*v59;
        v67 = *(void **)v53;
        v66 = *((void *)&v582 + 1);
        id v58 = (void *)v582;
      }

      void *v59 = v65;
      *(void *)&__x[2] = v70;
      *(void *)uint64_t v53 = v58;
      *(void *)&v582 = v67;
      uint64_t v71 = *v57;
      *id v57 = v66;
      *((void *)&v582 + 1) = v71;
      *(void *)__x = v70;
      std::__split_buffer<std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>>::~__split_buffer((uint64_t)__x);
    }

    else
    {
      v559 = 0LL;
      *int v54 = v50;
      id v58 = v54 + 1;
    }

    *(void *)uint64_t v53 = v58;
    std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>::reset[abi:nn180100](&v559, 0LL);
    id v72 = *((void *)val + 31);
    __int128 v73 = operator new(0x18uLL);
    __int128 v74 = v73;
    *__int128 v73 = 0LL;
    v73[1] = 0LL;
    v73[2] = 0LL;
    __int128 v75 = v72 + 24LL * v437;
    id v78 = *(void **)(v75 + 8);
    __int128 v76 = v75 + 8;
    uint64_t v77 = v78;
    id v80 = (unint64_t *)(v76 + 8);
    id v79 = *(void *)(v76 + 8);
    if ((unint64_t)v78 >= v79)
    {
      v82 = (void *)(v72 + 24LL * v437);
      id v83 = ((uint64_t)v77 - *v82) >> 3;
      v84 = v79 - *v82;
      v85 = v84 >> 2;
      else {
        id v86 = v85;
      }
      v583 = (void (*)(uint64_t))(v76 + 8);
      if (v86) {
        id v86 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v86);
      }
      else {
        v87 = 0LL;
      }
      v88 = (void *)(v86 + 8 * v83);
      id v89 = v86 + 8 * v87;
      *((void *)&v582 + 1) = v89;
      void *v88 = v74;
      v81 = v88 + 1;
      *(void *)&v582 = v88 + 1;
      int v90 = *(void **)v76;
      id v91 = (void *)*v82;
      if (*(void *)v76 == *v82)
      {
        v93 = *(void **)v76;
      }

      else
      {
        do
        {
          v92 = *--v90;
          *int v90 = 0LL;
          *--v88 = v92;
        }

        while (v90 != v91);
        v93 = (void *)*v82;
        int v90 = *(void **)v76;
        id v89 = *((void *)&v582 + 1);
        v81 = (void *)v582;
      }

      CFStringRef v82 = v88;
      *(void *)&__x[2] = v93;
      *(void *)__int128 v76 = v81;
      *(void *)&v582 = v90;
      v94 = *v80;
      *id v80 = v89;
      *((void *)&v582 + 1) = v94;
      *(void *)__x = v93;
      std::__split_buffer<std::unique_ptr<std::vector<double>>>::~__split_buffer((uint64_t)__x);
    }

    else
    {
      *uint64_t v77 = v73;
      v81 = v77 + 1;
    }

    *(void *)__int128 v76 = v81;
    id v95 = *((void *)val + 34);
    v96 = operator new(0x18uLL);
    id v97 = v96;
    void *v96 = 0LL;
    v96[1] = 0LL;
    v96[2] = 0LL;
    uint64_t v98 = v95 + 24LL * v437;
    __int128 v101 = *(void **)(v98 + 8);
    __int128 v99 = v98 + 8;
    uint64_t v100 = v101;
    v103 = (unint64_t *)(v99 + 8);
    v102 = *(void *)(v99 + 8);
    if ((unint64_t)v101 >= v102)
    {
      v105 = (void *)(v95 + 24LL * v437);
      NSErrorUserInfoKey v106 = ((uint64_t)v100 - *v105) >> 3;
      id v107 = v102 - *v105;
      v108 = v107 >> 2;
      else {
        v109 = v108;
      }
      v583 = (void (*)(uint64_t))(v99 + 8);
      if (v109) {
        v109 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v109);
      }
      else {
        v110 = 0LL;
      }
      v111 = (void *)(v109 + 8 * v106);
      v112 = v109 + 8 * v110;
      *((void *)&v582 + 1) = v112;
      *v111 = v97;
      v104 = v111 + 1;
      *(void *)&v582 = v111 + 1;
      v113 = *(void **)v99;
      v114 = (void *)*v105;
      if (*(void *)v99 == *v105)
      {
        v116 = *(void **)v99;
      }

      else
      {
        do
        {
          v115 = *--v113;
          *v113 = 0LL;
          *--v111 = v115;
        }

        while (v113 != v114);
        v116 = (void *)*v105;
        v113 = *(void **)v99;
        v112 = *((void *)&v582 + 1);
        v104 = (void *)v582;
      }

      void *v105 = v111;
      *(void *)&__x[2] = v116;
      *(void *)__int128 v99 = v104;
      *(void *)&v582 = v113;
      v117 = *v103;
      void *v103 = v112;
      *((void *)&v582 + 1) = v117;
      *(void *)__x = v116;
      std::__split_buffer<std::unique_ptr<std::vector<double>>>::~__split_buffer((uint64_t)__x);
    }

    else
    {
      *uint64_t v100 = v96;
      v104 = v100 + 1;
    }

    *(void *)__int128 v99 = v104;
    v118 = *((void *)val + 28);
    v119 = operator new(0x18uLL);
    v120 = v119;
    *v119 = 0LL;
    v119[1] = 0LL;
    v119[2] = 0LL;
    v559 = (void **)v119;
    v121 = v118 + 24LL * v437;
    v124 = *(void **)(v121 + 8);
    v122 = v121 + 8;
    v123 = v124;
    v126 = (unint64_t *)(v122 + 8);
    v125 = *(void *)(v122 + 8);
    if ((unint64_t)v124 >= v125)
    {
      v129 = (void *)(v118 + 24LL * v437);
      v130 = ((uint64_t)v123 - *v129) >> 3;
      v131 = v125 - *v129;
      v132 = v131 >> 2;
      else {
        v133 = v132;
      }
      v583 = (void (*)(uint64_t))(v122 + 8);
      if (v133) {
        v133 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v133);
      }
      else {
        v134 = 0LL;
      }
      v135 = (void *)(v133 + 8 * v130);
      v136 = v133 + 8 * v134;
      *((void *)&v582 + 1) = v136;
      v559 = 0LL;
      *v135 = v120;
      v127 = v135 + 1;
      *(void *)&v582 = v135 + 1;
      v137 = *(void **)v122;
      v138 = (void *)*v129;
      if (*(void *)v122 == *v129)
      {
        v140 = *(void **)v122;
        v128 = v437;
      }

      else
      {
        v128 = v437;
        do
        {
          v139 = *--v137;
          *v137 = 0LL;
          *--v135 = v139;
        }

        while (v137 != v138);
        v140 = (void *)*v129;
        v137 = *(void **)v122;
        v136 = *((void *)&v582 + 1);
        v127 = (void *)v582;
      }

      *v129 = v135;
      *(void *)&__x[2] = v140;
      *(void *)v122 = v127;
      *(void *)&v582 = v137;
      v141 = *v126;
      *v126 = v136;
      *((void *)&v582 + 1) = v141;
      *(void *)__x = v140;
      std::__split_buffer<std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>>::~__split_buffer((uint64_t)__x);
    }

    else
    {
      v559 = 0LL;
      *v123 = v119;
      v127 = v123 + 1;
      v128 = v437;
    }

    *(void *)v122 = v127;
    std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::reset[abi:nn180100](&v559);
    v142 = *(void *)(*((void *)val + 28) + 24LL * v128 + 8);
    v143 = *(char ***)(v142 - 8);
    v145 = *v143;
    v144 = (uint64_t)v143[1];
    v146 = v144 - (void)*v143;
    v147 = 0xCCCCCCCCCCCCCCCDLL * (v146 >> 3);
    if (v147 > 2)
    {
      if (v146 != 120)
      {
        v171 = v145 + 120;
        v143[1] = v171;
      }
    }

    else
    {
      v148 = v143[2];
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v148[-v144] >> 3) >= 3 - v147)
      {
        v172 = v144 + 40 * (3 - v147);
        do
        {
          *(_OWORD *)v144 = 0uLL;
          *(_OWORD *)(v144 + 16) = 0uLL;
          *(_DWORD *)(v144 + 32) = 1065353216;
          v144 += 40LL;
        }

        while (v144 != v172);
        v143[1] = (char *)v172;
        goto LABEL_145;
      }

      v149 = 0xCCCCCCCCCCCCCCCDLL * ((v148 - v145) >> 3);
      v150 = 2 * v149;
      if (2 * v149 <= 3) {
        v150 = 3LL;
      }
      if (v149 >= 0x333333333333333LL) {
        v151 = 0x666666666666666LL;
      }
      else {
        v151 = v150;
      }
      v152 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v151);
      v154 = &v152[40 * v147];
      v155 = v152 + 120;
      v156 = v154 + 32;
      v157 = v147 - 3;
      do
      {
        *((_OWORD *)v156 - 2) = 0uLL;
        *((_OWORD *)v156 - 1) = 0uLL;
        *v156 = 1065353216;
        v156 += 10;
      }

      while (!__CFADD__(v157++, 1LL));
      v159 = &v152[40 * v153];
      v161 = *v143;
      v160 = v143[1];
      if (v160 == *v143)
      {
        *v143 = v154;
        v143[1] = v155;
        v143[2] = v159;
        if (v160) {
          goto LABEL_144;
        }
      }

      else
      {
        v162 = 0LL;
        do
        {
          v163 = &v154[v162];
          v164 = &v160[v162];
          v165 = *(void *)&v160[v162 - 40];
          *((void *)v164 - 5) = 0LL;
          *((void *)v163 - 5) = v165;
          *((void *)v163 - 4) = *(void *)&v160[v162 - 32];
          *((void *)v164 - 4) = 0LL;
          v166 = *(void *)&v160[v162 - 24];
          *(void *)&v154[v162 - 24] = v166;
          v167 = *(void *)&v160[v162 - 16];
          *((void *)v163 - 2) = v167;
          *((_DWORD *)v163 - 2) = *(_DWORD *)&v160[v162 - 8];
          if (v167)
          {
            v168 = *(void *)(v166 + 8);
            v169 = *((void *)v163 - 4);
            if ((v169 & (v169 - 1)) != 0)
            {
              if (v168 >= v169) {
                v168 %= v169;
              }
            }

            else
            {
              v168 &= v169 - 1;
            }

            *(void *)(v165 + 8 * v168) = &v154[v162 - 24];
            *(void *)&v160[v162 - 24] = 0LL;
            *(void *)&v160[v162 - 16] = 0LL;
          }

          v162 -= 40LL;
        }

        while (&v160[v162] != v161);
        v170 = *v143;
        v160 = v143[1];
        *v143 = &v154[v162];
        v143[1] = v155;
        v143[2] = v159;
        if (v160 != v170)
        {
          do
            v160 = (char *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(v160 - 40));
          while (v160 != v170);
          v160 = v170;
        }

        if (v160) {
LABEL_144:
        }
          operator delete(v160);
      }
    }

  ++*(void *)(a1 + 24);
  return i;
}

    if (!v12) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  id v57 = a3;
  id v13 = a3;
  id v14 = objc_claimAutoreleasedReturnValue([v58 objectAtIndexedSubscript:a3]);
  id v15 = [v14 bytes];

  while (1)
  {
    float v16 = (void *)objc_claimAutoreleasedReturnValue([v58 objectAtIndexedSubscript:v13]);
    id v17 = [v16 length] >> 3;

    if (v17 <= v11)
    {
      uint64_t v11 = 0LL;
      v63 = v10;
      uint64_t v64 = v9;
      a3 = v57 + 1;
      v62 = v12;
      goto LABEL_2;
    }

    if (v15[v11] == *(void *)(*(void *)(a1 + 488) + 352LL)) {
      break;
    }
LABEL_22:
    ++v11;
  }

  if (v10 >= v9)
  {
    uint64_t v18 = ((char *)v10 - (char *)v12) >> 3;
    unint64_t v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61)
    {
      v63 = v10;
      uint64_t v64 = v9;
      v62 = v12;
      abort();
    }

    if (v9 - v12 > v19) {
      unint64_t v19 = v9 - v12;
    }
    else {
      id v20 = v19;
    }
    id v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v20);
    unint64_t v23 = (unsigned int *)&v21[8 * v18];
    void *v23 = v57;
    v23[1] = v11;
    unint64_t v24 = v23;
    while (v10 != v12)
    {
      unint64_t v25 = *((void *)v10 - 1);
      v10 -= 2;
      *((void *)v24 - 1) = v25;
      v24 -= 2;
    }

    id v9 = (unsigned int *)&v21[8 * v22];
    id v10 = v23 + 2;
    if (v12) {
      operator delete(v12);
    }
    uint64_t v12 = v24;
  }

  else
  {
    void *v10 = v57;
    v10[1] = v11;
    v10 += 2;
  }

  if (v8 != 1)
  {
    id v8 = 1;
    goto LABEL_22;
  }

  uint64_t v64 = v9;
  v62 = v12;
  id v26 = *((void *)v12 + 1);
  *(void *)(a5 + 4) = v26;
  if (*v12 != (_DWORD)v26)
  {
    id v33 = objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:"));
    unint64_t v34 = (char *)[v33 bytes];
    id v35 = v12[1];
    id v36 = ((unint64_t)[v33 length] >> 3) - v12[1];
    __dst = 0LL;
    id v61 = 0LL;
    __p = 0LL;
    std::vector<unsigned long long>::reserve(&__p, v12[3] + v36);
    std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>( &__p,  (char *)__dst,  &v34[8 * v35],  &v34[8 * v35 + 8 * v36],  v36);
    uint64_t v37 = objc_claimAutoreleasedReturnValue([v58 objectAtIndexedSubscript:v12[2]]);
    unint64_t v38 = (char *)[v37 bytes];

    std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>( &__p,  (char *)__dst,  v38,  &v38[8 * v12[3]],  v12[3]);
    uint64_t v39 = *(char **)(a5 + 80);
    *(void *)(a5 + 88) = v39;
    uint64_t v40 = (char *)__p;
    id v41 = __dst;
    uint64_t v42 = *(_OWORD *)__p;
    id v43 = *((_OWORD *)__p + 1);
    NSErrorUserInfoKey v44 = *((_OWORD *)__p + 3);
    *(_OWORD *)(a5 + 48) = *((_OWORD *)__p + 2);
    *(_OWORD *)(a5 + 64) = v44;
    *(_OWORD *)(a5 + 16) = v42;
    *(_OWORD *)(a5 + 32) = v43;
    id v45 = v40 + 64;
    char v46 = v41 - (v40 + 64);
    v47 = v46 >> 3;
    uint64_t v48 = *(void *)(a5 + 96);
    if (v46 >> 3 > (unint64_t)((v48 - (uint64_t)v39) >> 3))
    {
      if (v39)
      {
        *(void *)(a5 + 88) = v39;
        operator delete(v39);
        uint64_t v48 = 0LL;
        *(void *)(a5 + 80) = 0LL;
        *(void *)(a5 + 88) = 0LL;
        *(void *)(a5 + 96) = 0LL;
      }

      if (v46 < 0) {
        abort();
      }
      int v49 = v48 >> 2;
      if (v48 >> 2 <= v47) {
        int v49 = v46 >> 3;
      }
      else {
        uint64_t v50 = v49;
      }
      std::vector<unsigned long>::__vallocate[abi:nn180100]((void *)(a5 + 80), v50);
      uint64_t v39 = *(char **)(a5 + 88);
    }

    if (v41 != v45) {
      memmove(v39, v45, v46);
    }
    *(void *)(a5 + 88) = &v39[8 * v47];
    uint64_t v40 = (char *)__p;
    if (__p)
    {
LABEL_42:
      __dst = v40;
      operator delete(v40);
    }

    goto LABEL_43;
  }

  uint64_t v27 = objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectAtIndexedSubscript:"));
  id v28 = (char *)[v27 bytes] + 8 * v12[1];

  *(void *)(a5 + 88) = *(void *)(a5 + 80);
  id v29 = *((_OWORD *)v28 + 3);
  size_t v31 = *(_OWORD *)v28;
  id v30 = *((_OWORD *)v28 + 1);
  *(_OWORD *)(a5 + 48) = *((_OWORD *)v28 + 2);
  *(_OWORD *)(a5 + 64) = v29;
  *(_OWORD *)(a5 + 16) = v31;
  *(_OWORD *)(a5 + 32) = v30;
  std::vector<unsigned long long>::reserve((void **)(a5 + 80), v12[3] - v12[1] - 8);
  uint64_t v32 = v12[3] - v12[1] - 8;
  std::vector<unsigned long long>::__assign_with_size[abi:nn180100]<unsigned long long *,unsigned long long *>( (char *)(a5 + 80),  v28 + 64,  (uint64_t)&v28[8 * v32 + 64],  v32);
  if (v12) {
    goto LABEL_26;
  }
LABEL_27:
}

    if (a1 == v10) {
      return result;
    }
    return 0LL;
  }

  if (a1 > -15496)
  {
    if (a1 <= -15232)
    {
      if ((a1 + 15341) > 0x34 || ((1LL << (a1 - 19)) & 0x10000000201601LL) == 0)
      {
        id v6 = a1 + 15495;
        if (v6 > 6 || ((1 << v6) & 0x43) == 0) {
          return 0LL;
        }
      }

      return result;
    }

    if (a1 <= -7162)
    {
      if (a1 == -15231) {
        return result;
      }
      id v10 = -10206;
    }

    else
    {
      if (a1 == -7161 || a1 == -6652) {
        return result;
      }
      id v10 = -6139;
    }

    goto LABEL_43;
  }

  if (a1 <= -15686)
  {
    id v3 = a1 + 15801;
    if (v3 <= 0x3B)
    {
      uint64_t v4 = 1LL << v3;
      id v5 = 0x800000100000801LL;
      goto LABEL_29;
    }

    return 0LL;
  }

  id v8 = a1 + 15610;
  if (v8 > 0x2A) {
    return 0LL;
  }
  uint64_t v4 = 1LL << v8;
  id v5 = 0x40000000021LL;
LABEL_29:
  if ((v4 & v5) == 0) {
    return 0LL;
  }
  return result;
}

  id v10 = 0;
  size_t v31 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
LABEL_44:
  if (a3) {
    goto LABEL_45;
  }
LABEL_46:
  a2[2] += 32LL;
}

LABEL_145:
    v173 = 0LL;
    v174 = 0LL;
    do
    {
      v175 = **(void **)(v142 - 8);
      if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(*(void *)(v142 - 8) + 8LL) - v175) >> 3) <= v174) {
        abort();
      }
      v176 = v175 + v173;
      v177 = *(void *)(v175 + v173 + 8);
      if (v177) {
        v178 = (float)*(unint64_t *)(v176 + 24) / (float)v177;
      }
      else {
        v178 = 0.0;
      }
      v179 = fmaxf(v178, 0.3);
      *(float *)(v176 + 32) = v179;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v176,  vcvtps_u32_f32((float)*((unsigned int *)val + 26) / v179));
      ++v174;
      v173 += 40LL;
    }

    while (v173 != 120);
    self = val;
    for (i = (void *)*((void *)val + 4); i; i = (void *)*i)
    {
      v181 = *(void *)(i[3] + 16LL) + 24LL * v437;
      v183 = (unint64_t **)(v181 + 8);
      v182 = *(unint64_t **)(v181 + 8);
      v184 = *(void *)(v181 + 16);
      if ((unint64_t)v182 >= v184)
      {
        v186 = *(unint64_t **)v181;
        v187 = ((uint64_t)v182 - *(void *)v181) >> 3;
        v188 = v187 + 1;
        v189 = v184 - (void)v186;
        if (v189 >> 2 > v188) {
          v188 = v189 >> 2;
        }
        else {
          v190 = v188;
        }
        if (v190)
        {
          if (v190 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          v191 = (char *)operator new(8 * v190);
          v182 = *v183;
          v186 = *(unint64_t **)v181;
        }

        else
        {
          v191 = 0LL;
        }

        v192 = (unint64_t *)&v191[8 * v187];
        *v192 = 0LL;
        v185 = v192 + 1;
        if (v182 != v186)
        {
          do
          {
            --v192;
            v193 = atomic_load(--v182);
            atomic_store(v193, v192);
          }

          while (v182 != v186);
          v186 = *(unint64_t **)v181;
        }

        *(void *)v181 = v192;
        *v183 = v185;
        *(void *)(v181 + 16) = &v191[8 * v190];
        if (v186) {
          operator delete(v186);
        }
      }

      else
      {
        *v182 = 0LL;
        v185 = v182 + 1;
      }

      self = val;
      *v183 = v185;
    }
  }

  v449 = (id)objc_claimAutoreleasedReturnValue([v433 objectForKeyedSubscript:@"limiter data"]);
  v194 = (unint64_t)[v449 length];
  v461 = v449;
  v432 = [v461 bytes];
  v195 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 22) objectAtIndexedSubscript:v437]);
  [v195 setObject:v461 atIndexedSubscript:v34];

  v196 = (void **)operator new(0x18uLL);
  *v196 = 0LL;
  v196[1] = 0LL;
  v196[2] = 0LL;
  v197 = (v194 >> 3) + 1;
  if ((v194 >> 3) != -1)
  {
    v198 = (char *)operator new(24 * v197);
    *v196 = v198;
    v196[2] = &v198[24 * v197];
    bzero(v198, 24 * ((24 * v197 - 24) / 0x18uLL) + 24);
    v196[1] = &v198[24 * ((24 * v197 - 24) / 0x18uLL) + 24];
  }

  v199 = (void ***)(*(void *)(*((void *)val + 25) + 24LL * v437) + 8 * v34);
  *(void *)__x = 0LL;
  std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>::reset[abi:nn180100](v199, v196);
  std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>::reset[abi:nn180100]((void ***)__x, 0LL);
  v200 = *((void *)a10 + 3);
  v201 = operator new(0x18uLL);
  v202 = v201;
  *v201 = 0LL;
  v201[1] = 0LL;
  v201[2] = 0LL;
  if (v200)
  {
    std::vector<unsigned long>::__vallocate[abi:nn180100](v201, v200);
    v203 = (char *)v202[1];
    bzero(v203, 8 * v200);
    v202[1] = &v203[8 * v200];
  }

  v204 = *(void *)(*((void *)val + 31) + 24LL * v437);
  v205 = *(void ***)(v204 + 8 * v34);
  *(void *)(v204 + 8 * v34) = v202;
  if (v205) {
    std::default_delete<std::vector<double>>::operator()[abi:nn180100](v205);
  }
  v206 = *((void *)a10 + 3);
  v207 = operator new(0x18uLL);
  v208 = v207;
  *v207 = 0LL;
  v207[1] = 0LL;
  v207[2] = 0LL;
  if (v206)
  {
    std::vector<unsigned long>::__vallocate[abi:nn180100](v207, v206);
    v209 = (char *)v208[1];
    bzero(v209, 8 * v206);
    v208[1] = &v209[8 * v206];
  }

  v210 = *(void *)(*((void *)val + 34) + 24LL * v437);
  v211 = *(void ***)(v210 + 8 * v34);
  *(void *)(v210 + 8 * v34) = v208;
  if (v211) {
    std::default_delete<std::vector<double>>::operator()[abi:nn180100](v211);
  }
  v212 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 21) objectAtIndexedSubscript:v437]);
  v213 = objc_claimAutoreleasedReturnValue([v212 objectAtIndexedSubscript:v34]);
  v214 = (void *)v576[5];
  v576[5] = v213;

  v215 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 20) perRingPerFrameLimiterData]);
  v216 = v215 == 0LL;

  if (v216)
  {
    v218 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v217);
    [*((id *)val + 20) setPerRingPerFrameLimiterData:v218];
  }

  v219 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 20) perRingPerFrameLimiterData]);
  v220 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v437));
  v221 = (void *)objc_claimAutoreleasedReturnValue([v219 objectForKeyedSubscript:v220]);
  v222 = v221 == 0LL;

  if (v222)
  {
    v224 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v223);
    v225 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 20) perRingPerFrameLimiterData]);
    v226 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v437));
    [v225 setObject:v224 forKeyedSubscript:v226];
  }

  v227 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 22) objectAtIndexedSubscript:v437]);
  [v227 setObject:v461 atIndexedSubscript:v34];

  v228 = (void *)objc_claimAutoreleasedReturnValue([v433 objectForKeyedSubscript:@"limiter time stamps"]);
  v229 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 23) objectAtIndexedSubscript:v437]);
  [v229 setObject:v228 atIndexedSubscript:v34];

  v230 = (void *)objc_claimAutoreleasedReturnValue([v433 objectForKeyedSubscript:@"shader timeline data"]);
  v231 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 24) objectAtIndexedSubscript:v437]);
  [v231 setObject:v230 atIndexedSubscript:v34];

  v232 = (void *)objc_claimAutoreleasedReturnValue([v433 objectForKeyedSubscript:@"limiter counter list"]);
  v233 = v232;
  if (!*((void *)val + 61) && v232)
  {
    objc_storeStrong((id *)val + 61, v232);
    v234 = (void *)*((void *)val + 57);
    *((void *)val + 57) = &off_5A0088;

    v235 = [*((id *)val + 57) count];
    size_t v31 = (uint64_t)val + 464;
    __x[0] = 0;
    std::vector<unsigned int>::resize( (std::vector<unsigned int> *)((char *)val + 464),  (std::vector<unsigned int>::size_type)v235,  __x);
    v570 = 0u;
    v571 = 0u;
    v572 = 0u;
    v573 = 0u;
    v236 = v233;
    v237 = [v236 countByEnumeratingWithState:&v570 objects:v586 count:16];
    if (v237)
    {
      v238 = 0;
      v239 = *(void *)v571;
      do
      {
        for (j = 0LL; j != v237; j = (char *)j + 1)
        {
          if (*(void *)v571 != v239) {
            objc_enumerationMutation(v236);
          }
          v241 = (void *)objc_claimAutoreleasedReturnValue( [*((id *)val + 57) objectForKeyedSubscript:*(void *)(*((void *)&v570 + 1) + 8 * (void)j)]);
          v242 = [v241 unsignedIntValue];

          *(_DWORD *)(*(void *)v31 + 4LL * v242) = v238 + (_DWORD)j;
        }

        v237 = [v236 countByEnumeratingWithState:&v570 objects:v586 count:16];
        v238 += (int)j;
      }

      while (v237);
    }
  }

  std::mutex::unlock(v455);
  if (!v576[5]) {
    goto LABEL_449;
  }
  v568[0] = 0LL;
  v568[1] = v568;
  v568[2] = 0x2020000000LL;
  v569 = 0;
  v428 = *(void *)(*(void *)(*((void *)val + 34) + 24LL * v437) + 8 * v34);
  v429 = *(void *)(*(void *)(*((void *)val + 31) + 24LL * v437) + 8 * v34);
  v462 = *(void **)(*(void *)(*((void *)val + 28) + 24LL * v437) + 8 * v34);
  else {
    v243 = 1LL;
  }
  v559 = 0LL;
  v560 = &v559;
  v561 = 0x4812000000LL;
  v562 = __Block_byref_object_copy__500;
  v563 = __Block_byref_object_dispose__501;
  v564 = "";
  v565 = 0LL;
  v567 = 0LL;
  v566 = 0LL;
  if (v243)
  {
    if (v243 > 0x666666666666666LL) {
      abort();
    }
    v244 = (char *)operator new(40 * v243);
    v245 = &v244[40 * v243];
    v565 = v244;
    v567 = v245;
    do
    {
      *(_OWORD *)v244 = 0uLL;
      *((_OWORD *)v244 + 1) = 0uLL;
      *((_DWORD *)v244 + 8) = 1065353216;
      v244 += 40;
    }

    while (v244 != v245);
    v566 = v245;
  }

  v550 = 0LL;
  v551 = &v550;
  v552 = 0x4812000000LL;
  v553 = __Block_byref_object_copy__503;
  v554 = __Block_byref_object_dispose__504;
  v555 = "";
  v246 = (char *)operator new(0x78uLL);
  v247 = 0LL;
  *(void *)__x = v246;
  *(void *)&v582 = v246 + 120;
  do
  {
    v248 = &v246[v247];
    *(_OWORD *)v248 = 0uLL;
    *((_OWORD *)v248 + 1) = 0uLL;
    *((_DWORD *)v248 + 8) = 1065353216;
    v247 += 40LL;
  }

  while (v247 != 120);
  *(void *)&__x[2] = v246 + 120;
  v557 = 0LL;
  v558 = 0LL;
  v556 = 0LL;
  v450 = (char *)v243;
  if (!v243)
  {
    v541 = __x;
    std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v541);
    goto LABEL_267;
  }

  v556 = operator new(24 * v243);
  v557 = v556;
  v443 = &v556[3 * v243];
  v558 = v443;
  v249 = v556;
  while (2)
  {
    *v249 = 0LL;
    v249[1] = 0LL;
    v249[2] = 0LL;
    v250 = *(void *)__x;
    v456 = *(std::mutex **)&__x[2];
    if (*(void *)&__x[2] == *(void *)__x) {
      goto LABEL_254;
    }
    v251 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)&__x[2] - *(void *)__x) >> 3);
    if (v251 > 0x666666666666666LL) {
      abort();
    }
    v252 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v251);
    *v249 = v252;
    v249[1] = v252;
    v445 = v249;
    v249[2] = &v252[40 * v253];
    v254 = (uint64_t)v252;
    while (2)
    {
      *(_OWORD *)v254 = 0u;
      *(_OWORD *)(v254 + 16) = 0u;
      *(_DWORD *)(v254 + 32) = *(_DWORD *)(v250 + 32);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v254,  *(void *)(v250 + 8));
      v255 = *(uint64_t **)(v250 + 16);
      if (v255)
      {
        v256 = (void *)(v254 + 16);
        do
        {
          v257 = *((unsigned int *)v255 + 4);
          v258 = *(void *)(v254 + 8);
          if (v258)
          {
            v259 = (uint8x8_t)vcnt_s8((int8x8_t)v258);
            v259.i16[0] = vaddlv_u8(v259);
            if (v259.u32[0] > 1uLL)
            {
              size_t v31 = *((unsigned int *)v255 + 4);
              if (v258 <= v257) {
                size_t v31 = v257 % v258;
              }
            }

            else
            {
              size_t v31 = ((_DWORD)v258 - 1) & v257;
            }

            v260 = *(uint64_t ***)(*(void *)v254 + 8 * v31);
            if (v260)
            {
              for (k = *v260; k; k = (uint64_t *)*k)
              {
                v262 = k[1];
                if (v262 == v257)
                {
                  if (*((_DWORD *)k + 4) == (_DWORD)v257) {
                    goto LABEL_251;
                  }
                }

                else
                {
                  if (v259.u32[0] > 1uLL)
                  {
                    if (v262 >= v258) {
                      v262 %= v258;
                    }
                  }

                  else
                  {
                    v262 &= v258 - 1;
                  }

                  if (v262 != v31) {
                    break;
                  }
                }
              }
            }
          }

          v263 = operator new(0x28uLL);
          *v263 = 0LL;
          v263[1] = v257;
          v264 = *((_OWORD *)v255 + 1);
          v263[4] = v255[4];
          *((_OWORD *)v263 + 1) = v264;
          v265 = (float)(unint64_t)(*(void *)(v254 + 24) + 1LL);
          v266 = *(float *)(v254 + 32);
          if (!v258 || (float)(v266 * (float)v258) < v265)
          {
            v267 = (v258 & (v258 - 1)) != 0;
            if (v258 < 3) {
              v267 = 1LL;
            }
            v268 = v267 | (2 * v258);
            v269 = vcvtps_u32_f32(v265 / v266);
            if (v268 <= v269) {
              v270 = v269;
            }
            else {
              v270 = v268;
            }
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v254,  v270);
            v258 = *(void *)(v254 + 8);
            if ((v258 & (v258 - 1)) != 0)
            {
              if (v258 <= v257) {
                size_t v31 = v257 % v258;
              }
              else {
                size_t v31 = v257;
              }
            }

            else
            {
              size_t v31 = ((_DWORD)v258 - 1) & v257;
            }
          }

          v271 = *(void *)v254;
          v272 = *(void **)(*(void *)v254 + 8 * v31);
          if (v272)
          {
            *v263 = *v272;
          }

          else
          {
            *v263 = *v256;
            *v256 = v263;
            *(void *)(v271 + 8 * v31) = v256;
            if (!*v263) {
              goto LABEL_250;
            }
            v273 = *(void *)(*v263 + 8LL);
            if ((v258 & (v258 - 1)) != 0)
            {
              if (v273 >= v258) {
                v273 %= v258;
              }
            }

            else
            {
              v273 &= v258 - 1;
            }

            v272 = (void *)(*(void *)v254 + 8 * v273);
          }

          *v272 = v263;
LABEL_250:
          ++*(void *)(v254 + 24);
LABEL_251:
          v255 = (uint64_t *)*v255;
        }

        while (v255);
      }

      v250 += 40LL;
      v254 += 40LL;
      if ((std::mutex *)v250 != v456) {
        continue;
      }
      break;
    }

    v249 = v445;
    v445[1] = v254;
LABEL_254:
    v249 += 3;
    if (v249 != v443) {
      continue;
    }
    break;
  }

  v557 = v443;
  v541 = __x;
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v541);
  v274 = 0LL;
  v275 = 0;
  v243 = (unint64_t)v450;
  do
  {
    v276 = (uint64_t)&v560[6][5 * v274];
    v277 = *(void *)(v276 + 8);
    if (v277) {
      v278 = (float)*(unint64_t *)(v276 + 24) / (float)v277;
    }
    else {
      v278 = 0.0;
    }
    *(float *)(v276 + 32) = fmaxf(v278, 0.3);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)&v560[6][5 * v274],  vcvtps_u32_f32(512.0 / *(float *)&v560[6][5 * v274 + 4]));
    for (m = 0LL; m != 120; m += 40LL)
    {
      v280 = *(void *)(v551[6] + 24 * v274) + m;
      v281 = *(void *)(v280 + 8);
      if (v281) {
        v282 = (float)*(unint64_t *)(v280 + 24) / (float)v281;
      }
      else {
        v282 = 0.0;
      }
      *(float *)(v280 + 32) = fmaxf(v282, 0.3);
      v283 = *(void *)(v551[6] + 24 * v274) + m;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v283,  vcvtps_u32_f32((float)*((unsigned int *)val + 26) / *(float *)(v283 + 32)));
    }

    v274 = ++v275;
  }

  while ((unint64_t)v450 > v275);
LABEL_267:
  v541 = 0LL;
  v542 = &v541;
  v543 = 0x4812000000LL;
  v544 = __Block_byref_object_copy__506;
  v545 = __Block_byref_object_dispose__507;
  v546 = "";
  v547 = 0LL;
  v549 = 0LL;
  v548 = 0LL;
  v534 = 0LL;
  v535 = &v534;
  v536 = 0x4812000000LL;
  v537 = __Block_byref_object_copy__509;
  v538 = __Block_byref_object_dispose__510;
  v539 = "";
  memset(v540, 0, sizeof(v540));
  if (v243)
  {
    v284 = (char *)operator new(24 * v243);
    bzero(v284, 24 * ((24 * v243 - 24) / 0x18) + 24);
    v547 = v284;
    v548 = &v284[24 * ((24 * v243 - 24) / 0x18) + 24];
    v549 = &v284[24 * v243];
  }

  std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::resize((uint64_t)v540, v243);
  v532 = 0LL;
  v531 = 0LL;
  v533 = 0LL;
  std::vector<std::pair<unsigned int,unsigned int>>::reserve(&v531, v243);
  v285 = 0LL;
  v286 = a9 - a8 + 1;
  v287 = v533;
  v288 = v532;
  v289 = (unsigned int *)v531;
  v457 = a4 >> 4;
  v290 = v457 / v243;
  v438 = v286;
  while (v285 < (char *)[v439 count] - 1)
  {
    std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::resize((uint64_t)&v542[6][6 * (void)v285], v286);
    std::vector<ShaderProfilerUSCSampleInfo>::reserve((void **)(v535[6] + 24LL * (void)v285), v290);
    v291 = (void *)objc_claimAutoreleasedReturnValue([v439 objectAtIndexedSubscript:v285]);
    v292 = [v291 unsignedIntValue];
    v293 = (void *)objc_claimAutoreleasedReturnValue([v439 objectAtIndexedSubscript:++v285]);
    v294 = [v293 unsignedIntValue];
    v295 = v294;
    if (v288 >= (unsigned int *)v287)
    {
      v296 = ((char *)v288 - (char *)v289) >> 3;
      v297 = v296 + 1;
      if ((unint64_t)(v296 + 1) >> 61)
      {
        v531 = v289;
        abort();
      }

      else {
        v298 = v297;
      }
      v299 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v298);
      v301 = (unsigned int *)&v299[8 * v296];
      *v301 = v292;
      v301[1] = v295;
      v302 = v301;
      while (v288 != v289)
      {
        v303 = *((void *)v288 - 1);
        v288 -= 2;
        *((void *)v302 - 1) = v303;
        v302 -= 2;
      }

      v287 = &v299[8 * v300];
      v288 = v301 + 2;
      if (v289) {
        operator delete(v289);
      }
      v289 = v302;
    }

    else
    {
      *v288 = v292;
      v288[1] = v294;
      v288 += 2;
    }

    v286 = a9 - a8 + 1;
  }

  v533 = v287;
  v532 = v288;
  v531 = v289;
  v524 = 0LL;
  v525 = &v524;
  v526 = 0x4812000000LL;
  v527 = __Block_byref_object_copy__509;
  v528 = __Block_byref_object_dispose__510;
  v529 = "";
  memset(v530, 0, sizeof(v530));
  v515 = 0LL;
  v516 = (void **)&v515;
  v517 = 0x4812000000LL;
  v518 = __Block_byref_object_copy__513;
  v519 = __Block_byref_object_dispose__514;
  v520 = "";
  v521 = 0LL;
  v523 = 0LL;
  v522 = 0LL;
  std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::resize((uint64_t)v530, v286);
  std::vector<ShaderProfilerUSCSampleInfo>::reserve(v516 + 6, v457);
  v513[0] = 0LL;
  v513[1] = v513;
  v513[2] = 0x2020000000LL;
  v514 = 1;
  objc_initWeak(&location, val);
  v435 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v304);
  if (v450)
  {
    v305 = 0LL;
    v306 = v574;
    do
    {
      v500[0] = _NSConcreteStackBlock;
      v500[1] = 3321888768LL;
      v500[2] = __214__DYPMTLShaderProfilerHelper_evaluateStreamingSamples_withUSCSampleNum_withProgramAddressLUT_targetIndex_forRingBufferIndex_withMinEncoderIndex_withMaxEncoderIndex_withEncoderIdToEncoderIndexMap_withProfilingData___block_invoke;
      v500[3] = &unk_58EA98;
      objc_copyWeak(v501, &location);
      v507 = v306;
      v508 = v437;
      v500[4] = val;
      v501[1] = v305;
      v509 = a6;
      v503 = 0LL;
      v504 = 0LL;
      __p = 0LL;
      std::vector<std::pair<unsigned int,unsigned int>>::__init_with_size[abi:nn180100]<std::pair<unsigned int,unsigned int>*,std::pair<unsigned int,unsigned int>*>( &__p,  (uint64_t *)v289,  (uint64_t *)v288,  ((char *)v288 - (char *)v289) >> 3);
      v506 = a10;
      v510 = a9;
      v511 = a8;
      v500[5] = v568;
      v500[6] = &v534;
      v505 = a3;
      v500[7] = &v541;
      v307 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v500));
      [*((id *)val + 92) addOperation:v307];
      [v435 addDependency:v307];
      v498[0] = _NSConcreteStackBlock;
      v498[1] = 3221225472LL;
      v498[2] = __214__DYPMTLShaderProfilerHelper_evaluateStreamingSamples_withUSCSampleNum_withProgramAddressLUT_targetIndex_forRingBufferIndex_withMinEncoderIndex_withMaxEncoderIndex_withEncoderIdToEncoderIndexMap_withProfilingData___block_invoke_524;
      v498[3] = &unk_58EAD0;
      v499 = v438;
      v498[4] = v513;
      v498[5] = &v524;
      v498[10] = v450;
      v498[6] = &v541;
      v498[7] = &v515;
      v498[9] = v305;
      v498[8] = &v534;
      v308 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v498));
      [v308 addDependency:v307];
      [*((id *)val + 93) addOperation:v308];
      [v435 addDependency:v308];

      if (__p)
      {
        v503 = __p;
        operator delete(__p);
      }

      objc_destroyWeak(v501);
      ++v305;
    }

    while (v450 != v305);
  }

  [*((id *)val + 92) addOperation:v435];
  [v435 waitUntilFinished];
  v309 = (unint64_t)v450;
  if (-[DYPMTLShaderProfilerHelper dumpInstructions](val, "dumpInstructions"))
  {
    v310 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v434,  v574,  &v574);
    snprintf( (char *)__x,  0x80uLL,  "/tmp/com.apple.gputools.profiling/shaderProfilerResults/Frames/%u/%u/processedStreamingSamples.txt",  *((_DWORD *)v310 + 5),  v437);
    v311 = fopen((const char *)__x, "wt");
    fwrite( "SampleIdx PC ProgramStart Encoder Draw Limiter Idx Duration Cost costFactor sampleFactor\n",  0x59uLL,  1uLL,  v311);
  }

  else
  {
    v311 = 0LL;
  }

  v496 = 0LL;
  v430 = v311;
  std::string::basic_string[abi:nn180100]<0>(&__s, "");
  v313 = (uint64_t *)v525[6];
  for (n = (uint64_t *)v525[7];
        v313 != n;
        v312 = std::__introsort<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *,false>( v315,  v316,  v318,  1,  v312))
  {
    v315 = *v313;
    v316 = (double *)v313[1];
    v313 += 3;
    v317 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v316 - v315) >> 3));
    else {
      v318 = v317;
    }
  }

  v319 = *((_DWORD *)val + 26);
  v431 = [*((id *)val + 61) count];
  v495 = 0LL;
  memset(v494, 0, sizeof(v494));
  v492 = 0LL;
  v491 = 0LL;
  v493 = 0LL;
  std::vector<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo>::reserve( &v491,  4 * v319);
  v320 = a8;
  v441 = v319;
  LODWORD(v481) = a8;
  if (a9 >= a8)
  {
    v442 = 0;
    v321 = a8;
    do
    {
      v322 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)a5,  v321,  &v481);
      v323 = (unsigned __int8 **)v322[3];
      v452 = (unsigned __int8 **)v322[4];
      if (v323 != v452)
      {
        v324 = 0;
        do
        {
          v325 = *v323;
          v326 = **v323;
          if (v326 == 98)
          {
            v326 = v325[40];
            v327 = *((void *)v325 + 4);
          }

          else
          {
            v327 = -1LL;
          }

          if (v326 == 101)
          {
            v326 = 5;
            v328 = -2147483643;
          }

          else if (v326 == 100)
          {
            v328 = -2147483548;
            v326 = 4;
          }

          else
          {
            v328 = *((_DWORD *)v325 + 1) % v441;
          }

          HIDWORD(v494[0]) = *((void *)v325 + 1);
          v329 = (uint64_t *)(v525[6] + 24LL * (v481 - v320));
          v330 = *v329;
          v331 = v329[1];
          v332 = v331 - *v329;
          if (v332)
          {
            v444 = (int)v481;
            v446 = v328;
            v448 = v327;
            v458 = v324;
            v333 = 0xCCCCCCCCCCCCCCCDLL * (v332 >> 3);
            v334 = v330;
            do
            {
              v335 = v334 + 40 * (v333 >> 1);
              v336 = USCSampleComparator::operator()(v335, (uint64_t)v494);
              if (v336) {
                v333 += ~(v333 >> 1);
              }
              else {
                v333 >>= 1;
              }
              if (v336) {
                v334 = v335 + 40;
              }
            }

            while (v333);
            v309 = (unint64_t)v450;
            if (v331 == v334)
            {
              v320 = a8;
            }

            else
            {
              HIDWORD(v494[0]) = *((void *)v325 + 2);
              if (v331 == v330)
              {
                v338 = v330;
              }

              else
              {
                v337 = 0xCCCCCCCCCCCCCCCDLL * ((v331 - v330) >> 3);
                v338 = v330;
                do
                {
                  if (USCSampleComparator::operator()((uint64_t)v494, v338 + 40 * (v337 >> 1)))
                  {
                    v337 >>= 1;
                  }

                  else
                  {
                    v338 += 40 * (v337 >> 1) + 40;
                    v337 += ~(v337 >> 1);
                  }
                }

                while (v337);
              }

              v339 = -858993459 * ((unint64_t)(v334 - v330) >> 3);
              v340 = -858993459 * ((unint64_t)(v338 - v330) >> 3);
              if (v339 == v340)
              {
                v320 = a8;
              }

              else
              {
                v341 = v492;
                if ((unint64_t)v492 >= v493)
                {
                  v344 = 0xCCCCCCCCCCCCCCCDLL * (((_BYTE *)v492 - (_BYTE *)v491) >> 3);
                  v345 = v344 + 1;
                  else {
                    v346 = v345;
                  }
                  std::__split_buffer<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo>::__split_buffer( __x,  v346,  v344,  (uint64_t)&v493);
                  v347 = (_DWORD *)v582;
                  *(void *)v582 = v448;
                  v347[2] = v444;
                  v347[3] = v458;
                  v347[4] = v446;
                  v347[5] = v326;
                  v347[6] = v339;
                  v347[7] = v340;
                  v347[8] = v442;
                  v342 = v347 + 10;
                  *(void *)&v582 = v347 + 10;
                  v348 = v492;
                  v349 = (char *)v491;
                  v350 = *(char **)&__x[2];
                  if (v492 == v491)
                  {
                    v349 = (char *)v492;
                  }

                  else
                  {
                    v351 = (char *)v492;
                    do
                    {
                      v352 = *(_OWORD *)(v351 - 40);
                      v353 = *(_OWORD *)(v351 - 24);
                      *((void *)v350 - 1) = *((void *)v351 - 1);
                      *(_OWORD *)(v350 - 24) = v353;
                      *(_OWORD *)(v350 - 40) = v352;
                      v350 -= 40;
                      v351 -= 40;
                    }

                    while (v351 != v349);
                    v342 = (void *)v582;
                  }

                  v491 = v350;
                  v492 = v342;
                  v354 = v493;
                  v493 = *((void *)&v582 + 1);
                  *(void *)&v582 = v348;
                  *((void *)&v582 + 1) = v354;
                  *(void *)&__x[2] = v349;
                  *(void *)__x = v349;
                  if (v348 != v349) {
                    *(void *)&v582 = &v348[-40LL - 40 * ((v348 - v349 - 40) / 0x28uLL)];
                  }
                  if (v349) {
                    operator delete(v349);
                  }
                  v343 = v442;
                }

                else
                {
                  *(void *)v492 = v448;
                  v341[2] = v444;
                  v341[3] = v458;
                  v341[4] = v446;
                  v341[5] = v326;
                  v341[6] = v339;
                  v341[7] = v340;
                  v342 = v341 + 10;
                  v343 = v442;
                  v341[8] = v442;
                }

                v492 = v342;
                v442 = v343 - v339 + v340;
                v320 = a8;
              }
            }

            v324 = v458;
          }

          else
          {
            v320 = a8;
          }

          ++v324;
          ++v323;
        }

        while (v323 != v452);
        v321 = v481;
      }

      LODWORD(v481) = ++v321;
    }

    while (v321 <= a9);
  }

  else
  {
    v442 = 0;
  }

  v489 = 0LL;
  v488 = 0LL;
  v490 = 0LL;
  if (v309)
  {
    v355 = (void **)operator new(24 * v309);
    v488 = v355;
    v490 = &v355[3 * v309];
    v356 = 24 * ((24 * v309 - 24) / 0x18) + 24;
    bzero(v355, v356);
    v489 = (void **)((char *)v355 + v356);
    do
    {
      std::vector<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo>::reserve( v355,  0xAAAAAAAAAAAAAAABLL * (v489 - v488));
      v355 += 3;
      v356 -= 24LL;
    }

    while (v356);
  }

  v357 = (char *)v491;
  v358 = (char *)v492;
  if (v491 != v492)
  {
    v359 = 0;
    v360 = 0;
    v361 = (v309 + v442 - 1) / v309;
    do
    {
      v363 = *((_DWORD *)v357 + 6);
      v362 = *((_DWORD *)v357 + 7);
      v364 = v362 - v363;
      if (v362 - v363 + v359 <= v361)
      {
        std::vector<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo>::emplace_back<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo&>( &v488[3 * v360],  (__int128 *)v357);
        if (*((_DWORD *)v357 + 7) - *((_DWORD *)v357 + 6) + v359 == (_DWORD)v361)
        {
          ++v360;
          v359 = 0;
        }

        else
        {
          v359 += *((_DWORD *)v357 + 7) - *((_DWORD *)v357 + 6);
        }
      }

      else if (v362 != v363)
      {
        v365 = 0;
        do
        {
          else {
            v366 = v364 - v365;
          }
          v582 = *((_OWORD *)v357 + 1);
          v583 = (void (*)(uint64_t))*((void *)v357 + 4);
          *(_OWORD *)__x = *(_OWORD *)v357;
          DWORD2(v582) += v365;
          HIDWORD(v582) = DWORD2(v582) + v366;
          LODWORD(v583) = (_DWORD)v583 + v365;
          std::vector<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo>::emplace_back<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo&>( &v488[3 * v360],  (__int128 *)__x);
          v365 += v366;
          if (v366 + v359 == (_DWORD)v361)
          {
            ++v360;
            v359 = 0;
          }

          else
          {
            v359 += v366;
          }
        }

        while (v365 < v364);
      }

      v357 += 40;
    }

    while (v357 != v358);
  }

  v367 = v442;
  v368 = objc_autoreleasePoolPush();
  v369 = (void *)v576[5];
  v370 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v442));
  [v369 setArray:v370];

  if (v442)
  {
    do
    {
      v372 = (void *)v576[5];
      v373 = (void *)objc_opt_new(&OBJC_CLASS___InstructionPCStatInfoClass, v371);
      [v372 addObject:v373];

      --v367;
    }

    while (v367);
  }

  objc_autoreleasePoolPop(v368);
  *(void *)__x = 0LL;
  *(void *)&__x[2] = __x;
  *(void *)&v582 = 0x4812000000LL;
  *((void *)&v582 + 1) = __Block_byref_object_copy__528;
  v583 = __Block_byref_object_dispose__529;
  v584 = "";
  memset(v585, 0, 24);
  v481 = 0LL;
  v482 = &v481;
  v483 = 0x4812000000LL;
  v484 = __Block_byref_object_copy__528;
  v485 = __Block_byref_object_dispose__529;
  v486 = "";
  memset(v487, 0, sizeof(v487));
  std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::resize((uint64_t)v585, 0xAAAAAAAAAAAAAAABLL * (v489 - v488));
  std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::resize( (uint64_t)(v482 + 6),  0xAAAAAAAAAAAAAAABLL * (v489 - v488));
  v480[0] = _NSConcreteStackBlock;
  v480[1] = 3221225472LL;
  v480[2] = __214__DYPMTLShaderProfilerHelper_evaluateStreamingSamples_withUSCSampleNum_withProgramAddressLUT_targetIndex_forRingBufferIndex_withMinEncoderIndex_withMaxEncoderIndex_withEncoderIdToEncoderIndexMap_withProfilingData___block_invoke_532;
  v480[3] = &unk_58EAF8;
  v480[4] = __x;
  v480[5] = &v481;
  v480[6] = v429;
  v480[7] = v428;
  v374 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v480));
  v375 = v488;
  v376 = v489;
  v454 = v374;
  if (v488 != v489)
  {
    v377 = 0;
    v378 = v574;
    do
    {
      std::vector<double>::resize((char **)(*(void *)(*(void *)&__x[2] + 48LL) + 24LL * v377), v438);
      std::vector<double>::resize((char **)&v482[6][3 * v377], v438);
      v467[0] = _NSConcreteStackBlock;
      v467[1] = 3321888768LL;
      v467[2] = __214__DYPMTLShaderProfilerHelper_evaluateStreamingSamples_withUSCSampleNum_withProgramAddressLUT_targetIndex_forRingBufferIndex_withMinEncoderIndex_withMaxEncoderIndex_withEncoderIdToEncoderIndexMap_withProfilingData___block_invoke_2;
      v467[3] = &unk_58EB20;
      objc_copyWeak(v468, &location);
      v467[4] = &v559;
      v467[5] = &v550;
      v468[1] = v375;
      v468[2] = a5;
      v473 = v377;
      v474 = v441;
      v468[3] = (char *)val + 80;
      v468[4] = v496;
      else {
        v469 = __s;
      }
      v470 = (char *)val + 56;
      v471 = v432;
      v475 = a8;
      v476 = v431;
      v477 = v437;
      v478 = v378;
      v467[6] = &v524;
      v467[7] = &v575;
      v472 = v430;
      v479 = v438;
      v467[8] = __x;
      v467[9] = &v481;
      v379 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v467));
      [v374 addDependency:v379];
      [*((id *)val + 92) addOperation:v379];

      objc_destroyWeak(v468);
      v375 += 3;
      ++v377;
    }

    while (v375 != v376);
  }

  v380 = val;
  [*((id *)val + 92) addOperation:v374];
  [v374 waitUntilFinished];
  v459 = (std::mutex *)v574;
  v382 = v516[6];
  v383 = v516[7];
  if (v382 != v383)
  {
    v384 = *(uint64_t **)(*(void *)(*((void *)val + 25) + 24LL * v437) + 8LL * v574);
    do
    {
      LODWORD(v381) = v382[2];
      v385 = (double)(unint64_t)v381;
      if (!v382[5])
      {
        v386 = v382[1];
        if (v386 != -1)
        {
          -[DYPMTLShaderProfilerHelper _latencyAdjustmentWithLimiterData:forIndex:withLimiterTypeIndexMap:]( v380,  "_latencyAdjustmentWithLimiterData:forIndex:withLimiterTypeIndexMap:",  v432,  v386 * v431,  (char *)val + 464);
          v385 = *(double *)&v381 * v385;
        }
      }

      v387 = *v384;
      v388 = v382[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v384[1] - *v384) >> 3) > v388)
      {
        v389 = (double **)(v387 + 24LL * v388);
        v391 = (void **)(v389 + 1);
        v390 = v389[1];
        v392 = *v389;
        if (*v389 == v390) {
          goto LABEL_401;
        }
        v393 = *v389;
        while (*(_DWORD *)v393 != *v382)
        {
          v393 += 2;
          if (v393 == v390) {
            goto LABEL_401;
          }
        }

        if (v393 == v390)
        {
LABEL_401:
          v394 = v387 + 24LL * v388;
          v397 = *(void *)(v394 + 16);
          v396 = (void *)(v394 + 16);
          v395 = v397;
          if ((unint64_t)v390 >= v397)
          {
            v399 = ((char *)v390 - (char *)v392) >> 4;
            v400 = v395 - (void)v392;
            v401 = v400 >> 3;
            else {
              v402 = v401;
            }
            v403 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v402);
            v405 = (double *)&v403[16 * v399];
            *(_DWORD *)v405 = *v382;
            v405[1] = v385;
            v406 = (double *)*v391;
            v407 = (char *)*v389;
            v408 = v405;
            if (*v391 != *v389)
            {
              do
              {
                v381 = *((_OWORD *)v406 - 1);
                *((_OWORD *)v408 - 1) = v381;
                v408 -= 2;
                v406 -= 2;
              }

              while (v406 != (double *)v407);
              v406 = *v389;
            }

            *v389 = v408;
            v398 = v405 + 2;
            *v391 = v405 + 2;
            *v396 = &v403[16 * v404];
            if (v406) {
              operator delete(v406);
            }
          }

          else
          {
            *(_DWORD *)v390 = *v382;
            v390[1] = v385;
            v398 = v390 + 2;
          }

          *v391 = v398;
        }

        else
        {
          *(double *)&v381 = v385 + v393[1];
          *((void *)v393 + 1) = v381;
        }

        v380 = val;
      }

      v382 += 10;
    }

    while (v382 != v383);
  }

  v409 = (std::mutex *)((char *)v380 + 600);
  std::mutex::lock((std::mutex *)((char *)v380 + 600));
  if (v450)
  {
    v410 = 0LL;
    for (ii = 0; ii < (unint64_t)v450; v410 = ++ii)
    {
      for (jj = v560[6][5 * v410 + 2]; jj; jj = (void *)*jj)
      {
        v413 = jj[2];
        if (v413)
        {
          v414 = (int32x2_t *)(jj + 5);
          v415 = v413 + 24;
          while (1)
          {
            v414 = (int32x2_t *)*v414;
            if (!v414) {
              break;
            }
            v416 = (int32x2_t *)std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( v415,  v414[2].u32[0],  &v414[2]);
            v416[3] = vadd_s32(v416[3], v414[3]);
            std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>( (void **)&v416[4],  *(char **)&v416[5],  *(char **)&v414[4],  *(char **)&v414[5],  (uint64_t)(*(void *)&v414[5] - *(void *)&v414[4]) >> 3);
          }
        }
      }
    }
  }

  std::mutex::lock((std::mutex *)((char *)val + 664));
  v417 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 23) objectAtIndexedSubscript:v437]);
  v418 = (void *)objc_claimAutoreleasedReturnValue([v417 objectAtIndexedSubscript:v459]);
  BufferView<unsigned long long>::BufferView(v466, v418);

  if (v450)
  {
    v419 = 0LL;
    for (kk = 0; kk < (unint64_t)v450; v419 = ++kk)
    {
      for (mm = 0LL; mm != 3; ++mm)
      {
        for (nn = *(uint64_t **)(*(void *)(v551[6] + 24 * v419) + 40 * mm + 16); nn; nn = (uint64_t *)*nn)
        {
          v423 = (void *)(*v462 + 40 * mm);
          v424 = *((_DWORD *)nn + 4);
          v425 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v423,  v424);
          v426 = v466[0][nn[3]];
          v427 = v466[0][nn[4]];
          if (v425)
          {
            v425[3] = (uint64_t)v426;
            v425[4] = (uint64_t)v427;
          }

          else
          {
            v463 = v424;
            v464 = v426;
            v465 = v427;
            std::__hash_table<std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::pair<unsigned long long,unsigned long long>>>( (uint64_t)v423,  v424,  (uint64_t)&v463);
          }
        }
      }
    }
  }

  std::mutex::unlock((std::mutex *)((char *)val + 664));
  std::mutex::unlock(v409);

  _Block_object_dispose(&v481, 8);
  v466[0] = (void **)v487;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](v466);
  _Block_object_dispose(__x, 8);
  v481 = (void **)v585;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v481);
  std::vector<std::vector<-[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]::ThreadRangeInfo>>::~vector[abi:nn180100]((void **)&v488);
  if (v491)
  {
    v492 = v491;
    operator delete(v491);
  }

  objc_destroyWeak(&location);
  _Block_object_dispose(v513, 8);
  _Block_object_dispose(&v515, 8);
  if (v521)
  {
    v522 = v521;
    operator delete(v521);
  }

  _Block_object_dispose(&v524, 8);
  *(void *)__x = v530;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)__x);
  if (v531) {
    operator delete(v531);
  }
  _Block_object_dispose(&v534, 8);
  *(void *)__x = v540;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)__x);
  _Block_object_dispose(&v541, 8);
  *(void *)__x = &v547;
  std::vector<std::vector<std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)__x);
  _Block_object_dispose(&v550, 8);
  *(void *)__x = &v556;
  std::vector<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)__x);
  _Block_object_dispose(&v559, 8);
  *(void *)__x = &v565;
  std::vector<std::unordered_map<long,std::unordered_map<unsigned int,DrawDurationInfo>>>::__destroy_vector::operator()[abi:nn180100]((void ***)__x);
  _Block_object_dispose(v568, 8);
LABEL_449:

  _Block_object_dispose(&v575, 8);
LABEL_450:
}

void sub_103F14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, std::mutex *a41)
{
  _Block_object_dispose(&STACK[0x670], 8);
  _Unwind_Resume(a1);
}

void sub_104834( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
}

void sub_104EE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  _Unwind_Resume(a1);
}

void sub_105344( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a10;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&a16);
  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_1059C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_105BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_106B5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, id *location, id *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  objc_destroyWeak(v60);
  _Block_object_dispose(&a60, 8);
  std::vector<std::vector<-[DYPMTLShaderProfilerHelper adjustHWBiasAndFinalizeResult]::ClauseInfo>>::~vector[abi:nn180100](a14);
  std::vector<-[DYPMTLShaderProfilerHelper adjustHWBiasAndFinalizeResult]::ClauseInfo>::~vector[abi:nn180100]((void **)(v63 - 224));
  std::__hash_table<std::__hash_value_type<std::string,BinaryInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BinaryInfo>>>::~__hash_table(v63 - 192);

  objc_destroyWeak((id *)(v63 - 152));
  _Unwind_Resume(a1);
}

LABEL_65:
        ;
      }

      while (v89 != v80);
    }

    v92 = 0LL;
    v93 = v448;
    v94 = v77;
    do
    {
      id v95 = *v93;
      v93 = (uint64_t *)((char *)v93 + 4);
      v96 = (FILE *)((char *)&v92->_p + 1);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = __227__DYPMTLShaderProfilerHelper_generateTargetSamplesForResult_withProgramAddressLUT_withBatchIndexMin_withProgramAddressList_withUSCSampleBuffer_withUSCSampleNum_withBatchIDToEncoderIndex_andEncoderIndexToBatchIdMap_targetIndex___block_invoke_558;
      block[3] = &unk_58EBF8;
      v547 = (int)v92;
      v548 = v95;
      v552 = v73;
      v549 = a8;
      v550 = a11;
      block[4] = v443;
      block[5] = &v573;
      block[6] = &v564;
      block[7] = v553;
      v551 = a5;
      block[10] = a10;
      block[11] = v78;
      block[12] = v94;
      block[9] = a7;
      block[8] = &v557;
      dispatch_group_async(group, queue, block);
      v92 = v96;
    }

    while (v452 != v96);
    dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
    uint64_t v98 = 0LL;
    a7 = (void *)(&stru_20 + 8);
    __int128 v99 = a5;
    do
    {
      v449 = v98;
      uint64_t v100 = (unint64_t *)(v558[6] + 24 * v98);
      id v78 = *v100;
      __int128 v101 = v100[1];
      while (v78 != v101)
      {
        v102 = (void **)&v582[3 * (*(_DWORD *)v78 - v99)];
        v104 = v102 + 1;
        v103 = (char *)v102[1];
        v105 = (char *)v102[2];
        if (v103 >= v105)
        {
          v108 = 0xCCCCCCCCCCCCCCCDLL * ((v103 - (_BYTE *)*v102) >> 3);
          v109 = v108 + 1;
          if (v108 + 1 > 0x666666666666666LL) {
            abort();
          }
          v110 = 0xCCCCCCCCCCCCCCCDLL * ((v105 - (_BYTE *)*v102) >> 3);
          if (2 * v110 > v109) {
            v109 = 2 * v110;
          }
          if (v110 >= 0x333333333333333LL) {
            v111 = 0x666666666666666LL;
          }
          else {
            v111 = v109;
          }
          if (v111) {
            v111 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v111);
          }
          else {
            v112 = 0LL;
          }
          v113 = v111 + 40 * v108;
          id v97 = *(_OWORD *)v78;
          v114 = *(_OWORD *)(v78 + 16);
          *(void *)(v113 + 32) = *(void *)(v78 + 32);
          *(_OWORD *)v113 = v97;
          *(_OWORD *)(v113 + 16) = v114;
          v115 = (char *)*v104;
          v116 = (char *)*v102;
          v117 = v113;
          if (*v104 != *v102)
          {
            do
            {
              id v97 = *(_OWORD *)(v115 - 40);
              v118 = *(_OWORD *)(v115 - 24);
              *(void *)(v117 - 8) = *((void *)v115 - 1);
              *(_OWORD *)(v117 - 24) = v118;
              *(_OWORD *)(v117 - 40) = v97;
              v117 -= 40LL;
              v115 -= 40;
            }

            while (v115 != v116);
            v115 = (char *)*v102;
          }

          CFStringRef v102 = (void *)v117;
          id v107 = (void *)(v113 + 40);
          CFStringRef v104 = (void *)(v113 + 40);
          v102[2] = (void *)(v111 + 40 * v112);
          if (v115) {
            operator delete(v115);
          }
          __int128 v99 = a5;
        }

        else
        {
          id v97 = *(_OWORD *)v78;
          NSErrorUserInfoKey v106 = *(_OWORD *)(v78 + 16);
          *((void *)v103 + 4) = *(void *)(v78 + 32);
          *(_OWORD *)v103 = v97;
          *((_OWORD *)v103 + 1) = v106;
          id v107 = v103 + 40;
        }

        CFStringRef v104 = v107;
        v78 += 40LL;
      }

      uint64_t v98 = v449 + 1;
      id v80 = (unint64_t)v452;
    }

    while ((FILE *)(v449 + 1) != v452);
  }

  else
  {
    *id v86 = a8;
    dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  }

  v119 = v582;
  for (i = (uint64_t)v583;
        v119 != (uint64_t *)i;
        *(double *)&id v97 = std::__introsort<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *,false>( v121,  v122,  v124,  1,  *(double *)&v97))
  {
    v121 = *v119;
    v122 = (double *)v119[1];
    v119 += 3;
    v123 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v122 - v121) >> 3));
    else {
      v124 = v123;
    }
  }

  v125 = 8LL * v458;
  if (v458)
  {
    v126 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v458);
    bzero(v126, v125);
    v435 = (unsigned int *)v126;
    v433 = (unsigned int *)&v126[8 * v458];
  }

  else
  {
    v435 = 0LL;
    v433 = 0LL;
  }

  v537 = 0LL;
  v538 = &v537;
  v539 = 0x4812000000LL;
  v540 = __Block_byref_object_copy__560;
  v541 = __Block_byref_object_dispose__561;
  v542 = "";
  v543 = 0LL;
  v545 = 0LL;
  v544 = 0LL;
  if ((_DWORD)v80)
  {
    v127 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v80);
    v543 = v127;
    v545 = &v127[24 * v128];
    bzero(v127, 24 * ((24 * (unint64_t)v80 - 24) / 0x18) + 24);
    v544 = &v127[24 * ((24 * (unint64_t)v80 - 24) / 0x18) + 24];
    v434 = (char *)v443 + 752;
    if (*((_BYTE *)v443 + 752))
    {
      for (j = 0LL; j != v80; ++j)
      {
        v130 = v538[6];
        v131 = (char **)(v130 + 24 * j);
        v133 = v131 + 1;
        v132 = v131[1];
        v134 = *v131;
        id v78 = (v132 - *v131) >> 3;
        if (v458 <= v78)
        {
          if (v458 < v78) {
            *v133 = &v134[8 * v458];
          }
        }

        else
        {
          v135 = v130 + 24 * j;
          v137 = *(void *)(v135 + 16);
          a7 = (unint64_t *)(v135 + 16);
          v136 = v137;
          if (v458 - v78 <= (v137 - (uint64_t)v132) >> 3)
          {
            v149 = &v132[8 * (v458 - v78)];
            v150 = v125 - 8 * v78;
            do
            {
              *(void *)v132 = 0LL;
              v132 += 8;
              v150 -= 8LL;
            }

            while (v150);
            *v133 = v149;
          }

          else
          {
            v138 = v136 - (void)v134;
            v139 = (v136 - (uint64_t)v134) >> 2;
            if (v139 <= v458) {
              v139 = v458;
            }
            if (v138 >= 0x7FFFFFFFFFFFFFF8LL) {
              v140 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v140 = v139;
            }
            v141 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v140);
            v143 = &v141[8 * v78];
            v144 = v125 - 8 * v78;
            v145 = v143;
            do
            {
              *(void *)v145 = 0LL;
              v145 += 8;
              v144 -= 8LL;
            }

            while (v144);
            v146 = *v133;
            v147 = *v131;
            if (*v133 != *v131)
            {
              do
              {
                v148 = *((void *)v146 - 1);
                v146 -= 8;
                *((void *)v143 - 1) = v148;
                v143 -= 8;
              }

              while (v146 != v147);
              v146 = *v131;
            }

            *v131 = v143;
            *v133 = &v141[8 * v458];
            *a7 = (unint64_t)&v141[8 * v142];
            if (v146) {
              operator delete(v146);
            }
          }
        }
      }
    }
  }

  else
  {
    v434 = (char *)v443 + 752;
  }

  v528 = 0LL;
  v529 = &v528;
  v530 = 0x4812000000LL;
  v531 = __Block_byref_object_copy__563;
  v532 = __Block_byref_object_dispose__564;
  v533 = "";
  v534 = 0LL;
  v536 = 0LL;
  v535 = 0LL;
  if ((_DWORD)v80)
  {
    v151 = (char *)operator new(24 * v80);
    bzero(v151, 24 * ((24 * v80 - 24) / 0x18) + 24);
    v534 = v151;
    v535 = &v151[24 * ((24 * v80 - 24) / 0x18) + 24];
    v536 = &v151[24 * v80];
  }

  v442 = dispatch_group_create();

  v519 = 0LL;
  v520 = &v519;
  v521 = 0x4812000000LL;
  v522 = __Block_byref_object_copy__566;
  v523 = __Block_byref_object_dispose__567;
  v524 = "";
  v525 = 0LL;
  v527 = 0LL;
  v526 = 0LL;
  v152 = (int)v452;
  if (*v434 && (_DWORD)v452)
  {
    v153 = (char *)operator new(40LL * (void)v452);
    v154 = v153;
    do
    {
      *(_OWORD *)v154 = 0uLL;
      *((_OWORD *)v154 + 1) = 0uLL;
      *((_DWORD *)v154 + 8) = 1065353216;
      v154 += 40;
    }

    while (v154 != &v153[40 * v452]);
    v525 = v153;
    v526 = &v153[40 * v452];
    v527 = v526;
  }

  v510 = 0LL;
  v511 = &v510;
  v512 = 0x4812000000LL;
  v513 = __Block_byref_object_copy__569;
  v514 = __Block_byref_object_dispose__570;
  v515 = "";
  v516 = 0LL;
  v518 = 0LL;
  v517 = 0LL;
  if ((_DWORD)v452)
  {
    v155 = (char *)operator new(40LL * (void)v452);
    v156 = v155;
    do
    {
      *(_OWORD *)v156 = 0uLL;
      *((_OWORD *)v156 + 1) = 0uLL;
      *((_DWORD *)v156 + 8) = 1065353216;
      v156 += 40;
    }

    while (v156 != &v155[40 * v452]);
    v516 = v155;
    v517 = &v155[40 * v452];
    v518 = v517;
  }

  v501 = 0LL;
  v502 = &v501;
  v503 = 0x4812000000LL;
  v504 = __Block_byref_object_copy__572;
  v505 = __Block_byref_object_dispose__573;
  v506 = "";
  v507 = 0LL;
  v509 = 0LL;
  v508 = 0LL;
  if ((_DWORD)v452)
  {
    v157 = (char *)operator new(40LL * (void)v452);
    v158 = v157;
    do
    {
      *(_OWORD *)v158 = 0uLL;
      *((_OWORD *)v158 + 1) = 0uLL;
      *((_DWORD *)v158 + 8) = 1065353216;
      v158 += 40;
    }

    while (v158 != &v157[40 * v452]);
    v507 = v157;
    v508 = &v157[40 * v452];
    v509 = v508;
  }

  v499 = 0LL;
  v498 = 0LL;
  v500 = 0LL;
  std::vector<unsigned long long>::reserve((void **)&v498, 0xAAAAAAAAAAAAAAABLL * (v583 - v582));
  v159 = (uint64_t)v583;
  v160 = (uint64_t)v582;
  v161 = v498;
  if (v583 != v582)
  {
    v162 = 0LL;
    v163 = v500;
    do
    {
      if (*(void *)(v160 + 24 * v162) != *(void *)(v160 + 24 * v162 + 8))
      {
        a7 = v499;
        if ((unint64_t)v499 >= v163)
        {
          v164 = v499 - v161;
          v165 = v164 + 1;
          else {
            v166 = v165;
          }
          if (v166) {
            v166 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v166);
          }
          else {
            v167 = 0LL;
          }
          v168 = (unint64_t *)(v166 + 8 * v164);
          *v168 = v162;
          id v78 = (unint64_t)(v168 + 1);
          while (a7 != v161)
          {
            v169 = *--a7;
            *--v168 = v169;
          }

          v163 = v166 + 8 * v167;
          v498 = v168;
          v499 = (unint64_t *)v78;
          v500 = v163;
          if (v161) {
            operator delete(v161);
          }
          v161 = v168;
          v152 = (int)v452;
        }

        else
        {
          *v499 = v162;
          id v78 = (unint64_t)++a7;
        }

        v499 = (unint64_t *)v78;
        v159 = (uint64_t)v583;
        v160 = (uint64_t)v582;
      }

      ++v162;
    }

    while (v162 < 0xAAAAAAAAAAAAAAABLL * ((v159 - v160) >> 3));
    v161 = v498;
  }

  if (v152)
  {
    v170 = 0;
    v439 = v499;
    a7 = v491;
    __lena = (char *)v499 - (char *)v161;
    id v78 = v499 - v161;
    groupa = (dispatch_group_t)((unint64_t)((char *)v499 - (char *)v161) >> 3);
    v171 = groupa / v452;
    do
    {
      v172 = v170 + 1;
      v484[0] = _NSConcreteStackBlock;
      v484[1] = 3321888768LL;
      v484[2] = __227__DYPMTLShaderProfilerHelper_generateTargetSamplesForResult_withProgramAddressLUT_withBatchIndexMin_withProgramAddressList_withUSCSampleBuffer_withUSCSampleNum_withBatchIDToEncoderIndex_andEncoderIndexToBatchIdMap_targetIndex___block_invoke_575;
      v484[3] = &unk_58EC20;
      if (v170 - (_DWORD)v452 == -1) {
        v173 = (int)groupa;
      }
      else {
        v173 = (v170 + 1) * v171;
      }
      v493 = v170 * v171;
      v494 = v173;
      v486 = 0LL;
      v487 = 0LL;
      v485 = 0LL;
      if (v439 != v161)
      {
        if ((__lena & 0x8000000000000000LL) != 0) {
          abort();
        }
        v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v78);
        v485 = v174;
        v486 = v174;
        v487 = &v174[8 * v175];
        memmove(v174, v161, __lena);
        v486 = &v174[8 * v78];
      }

      v495 = v458;
      v488 = a4;
      v484[5] = &v586;
      std::pair<ShaderBinaryInfo * {__strong},std::string>::pair[abi:nn180100](v489, (uint64_t)&v593);
      memset(v491, 0, sizeof(v491));
      std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__init_with_size[abi:nn180100]<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>*,std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>*>( v491,  v596,  (uint64_t *)v597,  0xAAAAAAAAAAAAAAABLL * (((_BYTE *)v597 - (_BYTE *)v596) >> 3));
      v484[6] = &v510;
      v496 = v170;
      v497 = a11;
      memset(v492, 0, sizeof(v492));
      std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::__init_with_size[abi:nn180100]<std::vector<ShaderProfilerUSCSampleInfo>*,std::vector<ShaderProfilerUSCSampleInfo>*>( v492,  (uint64_t)v582,  (uint64_t)v583,  0xAAAAAAAAAAAAAAABLL * (v583 - v582));
      v484[7] = &v528;
      v484[4] = v443;
      v484[8] = &v519;
      v484[9] = &v537;
      v484[10] = &v501;
      dispatch_group_async(v442, queue, v484);
      *(void *)v601 = v492;
      std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
      *(void *)v601 = v491;
      std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
      if (v490 < 0) {
        operator delete(v489[1]);
      }

      if (v485)
      {
        v486 = (char *)v485;
        operator delete(v485);
      }

      ++v170;
    }

    while (v172 != (_DWORD)v452);
  }

  dispatch_group_wait(v442, 0xFFFFFFFFFFFFFFFFLL);
  v176 = v529[6];
  for (k = v529[7]; v176 != k; v176 += 24LL)
  {
    v178 = *(void *)v176;
    v179 = *(void *)(v176 + 8);
    while (v178 != v179)
    {
      v180 = (void *)objc_claimAutoreleasedReturnValue([*(id *)v178 uscSamples]);
      v181 = v180 == 0LL;

      if (v181)
      {
        v183 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableData, v182);
        [*(id *)v178 setUscSamples:v183];
      }

      v184 = (void *)objc_claimAutoreleasedReturnValue([*(id *)v178 uscSamples]);
      [v184 appendBytes:*(void *)(v178 + 8) length:*(void *)(v178 + 16) - *(void *)(v178 + 8)];

      v178 += 32LL;
    }
  }

  if (*v434)
  {
    if (v458)
    {
      for (m = 0LL; m != v458; ++m)
      {
        v186 = &v435[2 * m];
        v186[1] = m;
        if ((_DWORD)v452)
        {
          v187 = 0LL;
          v188 = *v186;
          do
          {
            v188 += *(_DWORD *)(*(void *)(v538[6] + v187) + 8 * m);
            *v186 = v188;
            v187 += 24LL;
          }

          while (24LL * (void)v452 != v187);
        }
      }
    }

    v481 = 0u;
    v482 = 0u;
    v483 = 1.0;
    v189 = v520[6];
    v440 = v520[7];
    if (v189 != v440)
    {
      while (1)
      {
        v444 = v189;
        v190 = *(uint64_t **)(v189 + 16);
        if (v190) {
          break;
        }
LABEL_326:
        v189 = v444 + 40;
        if (v444 + 40 == v440) {
          goto LABEL_327;
        }
      }

      while (1)
      {
        v191 = std::unordered_map<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::find[abi:nn180100]( &v481,  (uint64_t)(v190 + 2));
        if (!v191) {
          break;
        }
        v192 = (uint64_t *)v190[7];
        if (v192)
        {
          v176 = (unint64_t)v191;
          v193 = (uint64_t *)(v191 + 40);
          v194 = v191 + 56;
          while (1)
          {
            v195 = *((unsigned int *)v192 + 4);
            v196 = (int32x2_t *)std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v193,  *((_DWORD *)v192 + 4));
            if (!v196) {
              break;
            }
            v196[3] = vadd_s32(v196[3], (int32x2_t)v192[3]);
            v196[5].i32[1] += *((_DWORD *)v192 + 11);
LABEL_235:
            v192 = (uint64_t *)*v192;
            if (!v192) {
              goto LABEL_325;
            }
          }

          a7 = *(unint64_t **)(v176 + 48);
          if (a7)
          {
            v197 = (uint8x8_t)vcnt_s8((int8x8_t)a7);
            v197.i16[0] = vaddlv_u8(v197);
            if (v197.u32[0] > 1uLL)
            {
              id v78 = v195;
            }

            else
            {
              id v78 = ((_DWORD)a7 - 1) & v195;
            }

            v198 = *(uint64_t ***)(*v193 + 8 * v78);
            if (v198)
            {
              for (n = *v198; n; n = (uint64_t *)*n)
              {
                v200 = n[1];
                if (v200 == v195)
                {
                  if (*((_DWORD *)n + 4) == (_DWORD)v195) {
                    goto LABEL_235;
                  }
                }

                else
                {
                  if (v197.u32[0] > 1uLL)
                  {
                  }

                  else
                  {
                    v200 &= (unint64_t)a7 - 1;
                  }

                  if (v200 != v78) {
                    break;
                  }
                }
              }
            }
          }

          v201 = operator new(0x30uLL);
          *v201 = 0LL;
          v201[1] = v195;
          v202 = *((_OWORD *)v192 + 2);
          *((_OWORD *)v201 + 1) = *((_OWORD *)v192 + 1);
          *((_OWORD *)v201 + 2) = v202;
          v203 = (float)(unint64_t)(*(void *)(v176 + 64) + 1LL);
          v204 = *(float *)(v176 + 72);
          if (!a7 || (float)(v204 * (float)(unint64_t)a7) < v203)
          {
            v205 = ((unint64_t)a7 & ((unint64_t)a7 - 1)) != 0;
            v206 = v205 | (2LL * (void)a7);
            v207 = vcvtps_u32_f32(v203 / v204);
            if (v206 <= v207) {
              v208 = v207;
            }
            else {
              v208 = v206;
            }
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)v193,  v208);
            a7 = *(unint64_t **)(v176 + 48);
            if (((unint64_t)a7 & ((unint64_t)a7 - 1)) != 0)
            {
              else {
                id v78 = v195;
              }
            }

            else
            {
              id v78 = ((_DWORD)a7 - 1) & v195;
            }
          }

          v209 = *v193;
          v210 = *(void **)(*v193 + 8 * v78);
          if (v210)
          {
            *v201 = *v210;
          }

          else
          {
            *v201 = *v194;
            *v194 = v201;
            *(void *)(v209 + 8 * v78) = v194;
            if (!*v201)
            {
LABEL_234:
              ++*(void *)(v176 + 64);
              goto LABEL_235;
            }

            v211 = *(void *)(*v201 + 8LL);
            if (((unint64_t)a7 & ((unint64_t)a7 - 1)) != 0)
            {
            }

            else
            {
              v211 &= (unint64_t)a7 - 1;
            }

            v210 = (void *)(*v193 + 8 * v211);
          }

          *v210 = v201;
          goto LABEL_234;
        }

    if (v45) {
      CFRelease(v45);
    }

    if (v67)
    {
      int v68 = (void *)objc_claimAutoreleasedReturnValue([v67 objectForKeyedSubscript:@"DerivedCounterScript"]);
      unsigned int v69 = [v68 length] == 0;

      if (v69)
      {
        v113 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Derived counter script missing"));
        v114 = __stdoutp;
        if (g_runningInCI) {
          v115 = "#CI_ERROR# ";
        }
        else {
          v115 = "";
        }
        v116 = v113;
        fprintf( v114,  "%s%s %u: %s\n",  v115,  "NSDictionary *DYMTLReplayFrameProfiler_loadAnalysis(__strong id<MTLDevice>)",  1141,  (const char *)[v116 UTF8String]);
        v82 = v116;
        GTMTLReplay_handleError( 101,  (uint64_t)[v82 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"DYMTLReplayFrameProfiler_loadAnalysis",  1141,  1);
      }

      else
      {
        uint64_t v70 = (id)objc_claimAutoreleasedReturnValue([v67 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
        uint64_t v71 = v70;
        if (g_runningInCI)
        {
          id v72 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"%d counters found",  [v70 count]));
          __int128 v73 = (void *)objc_claimAutoreleasedReturnValue( [v72 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

          __int128 v74 = __stdoutp;
          __int128 v75 = v73;
          fprintf(v74, "#CI-INFO# %s\n", (const char *)[v75 UTF8String]);

          if (![v71 count])
          {
            __int128 v76 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No derivedCounterInfoResult counters present!"));
            uint64_t v77 = __stdoutp;
            if (g_runningInCI) {
              id v78 = "#CI_ERROR# ";
            }
            else {
              id v78 = "";
            }
            id v79 = v76;
            fprintf( v77,  "%s%s %u: %s\n",  v78,  "void debugDumpCounterDictionary(NSDictionary *__strong)",  962,  (const char *)[v79 UTF8String]);
            id v80 = v79;
            GTMTLReplay_handleError( 101,  (uint64_t)[v80 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"debugDumpCounterDictionary",  962,  1);
          }

          if (g_runningValidationCI)
          {
            v81 = (void *)objc_claimAutoreleasedReturnValue([v71 objectForKeyedSubscript:@"DerivedCounters"]);
            [v81 enumerateKeysAndObjectsUsingBlock:&__block_literal_global_136];
          }
        }

        v82 = (id)objc_claimAutoreleasedReturnValue([v67 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
        if (verifyCounterDictionary(v82))
        {
          v148[0] = @"DerivedCounterDictionary";
          v146[0] = @"Version";
          id v83 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v82, "objectForKeyedSubscript:"));
          v146[1] = @"DerivedCounters";
          v147[0] = v83;
          v144 = @"GPUToolsGPUTime";
          v145 = &off_5A02E0;
          v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v145,  &v144,  1LL));
          v147[1] = v84;
          v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v147,  v146,  2LL));
          v148[1] = @"DerivedCounterScript";
          v149[0] = v85;
          v149[1] = @"\nfunction GPUToolsGPUTime()\n{\n   return MTLStat_nSec\n}\n";
          v121 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v149,  v148,  2LL));

          id v86 = GTMTLReplayClient_mergeDerivedCounterInfo(v67, v121);
          v123 = (void *)objc_claimAutoreleasedReturnValue(v86);

          v87 = (void *)objc_claimAutoreleasedReturnValue([v123 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
          v125 = v82;
          obja = v87;
          if (g_runningInCI)
          {
            v88 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Validating merged derived counters"));
            id v89 = (void *)objc_claimAutoreleasedReturnValue( [v88 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            int v90 = __stdoutp;
            id v91 = v89;
            fprintf(v90, "#CI-INFO# %s\n", (const char *)[v91 UTF8String]);
          }

          v92 = (void *)objc_claimAutoreleasedReturnValue([obja objectForKeyedSubscript:@"DerivedCounters"]);
          v142 = 0u;
          v143 = 0u;
          v140 = 0u;
          v141 = 0u;
          v93 = (void *)objc_claimAutoreleasedReturnValue([v125 objectForKeyedSubscript:@"DerivedCounters"]);
          v94 = [v93 countByEnumeratingWithState:&v140 objects:v153 count:16];
          if (v94)
          {
            id v95 = *(void *)v141;
            do
            {
              for (j = 0LL; j != v94; j = (char *)j + 1)
              {
                if (*(void *)v141 != v95) {
                  objc_enumerationMutation(v93);
                }
                id v97 = *(void *)(*((void *)&v140 + 1) + 8LL * (void)j);
                uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue([v92 objectForKeyedSubscript:v97]);
                __int128 v99 = v98 == 0LL;

                if (v99)
                {
                  uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Counter %@ is missing from merged counter list",  v97));
                  __int128 v101 = __stdoutp;
                  if (g_runningInCI) {
                    v102 = "#CI_ERROR# ";
                  }
                  else {
                    v102 = "";
                  }
                  v103 = v100;
                  fprintf( v101,  "%s%s %u: %s\n",  v102,  "void validateMergeDerivedCounterInfo(NSDictionary *__strong, NSDictionary *__strong)",  950,  (const char *)[v103 UTF8String]);
                  v104 = v103;
                  GTMTLReplay_handleError( 101,  (uint64_t)[v104 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"validateMergeDerivedCounterInfo",  950,  1);
                }
              }

              v94 = [v93 countByEnumeratingWithState:&v140 objects:v153 count:16];
            }

            while (v94);
          }

          v82 = [v123 mutableCopy];
          [v82 setObject:v131 forKeyedSubscript:@"MetalPluginName"];
          if (v129)
          {
            if (g_runningInCI)
            {
              v105 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Configuration Variables: %@",  v129));
              NSErrorUserInfoKey v106 = (void *)objc_claimAutoreleasedReturnValue( [v105 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

              id v107 = __stdoutp;
              v108 = v106;
              fprintf(v107, "#CI-INFO# %s\n", (const char *)[v108 UTF8String]);
            }

            [v82 setObject:v129 forKeyedSubscript:@"DerivedCounterConfigurationVariables"];
          }

          id v30 = [v82 copy];
          v67 = v123;
          goto LABEL_106;
        }
      }
    }

    else
    {
      v109 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to load any derived counters"));
      v110 = __stdoutp;
      if (g_runningInCI) {
        v111 = "#CI_ERROR# ";
      }
      else {
        v111 = "";
      }
      v112 = v109;
      fprintf( v110,  "%s%s %u: %s\n",  v111,  "NSDictionary *DYMTLReplayFrameProfiler_loadAnalysis(__strong id<MTLDevice>)",  1135,  (const char *)[v112 UTF8String]);
      v82 = v112;
      GTMTLReplay_handleError( 101,  (uint64_t)[v82 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"DYMTLReplayFrameProfiler_loadAnalysis",  1135,  1);
      v67 = 0LL;
    }

    id v30 = &__NSDictionary0__struct;
LABEL_106:

    goto LABEL_107;
  }

  id v10 = (void *)v9;
  uint64_t v11 = CFGetTypeID(v9);
  if (v11 == CFStringGetTypeID())
  {
    uint64_t v12 = v10;
    id v13 = v12;
LABEL_13:
    CFRelease(v12);
    goto LABEL_33;
  }

  if (v11 == CFArrayGetTypeID())
  {
    unint64_t v22 = v10;
    unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSPredicate predicateWithFormat:]( &OBJC_CLASS___NSPredicate,  "predicateWithFormat:",  @"NOT (self BEGINSWITH 'autocorr')"));
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v22 filteredArrayUsingPredicate:v23]);

    id v13 = (id)objc_claimAutoreleasedReturnValue([v24 firstObject]);
    if (v13)
    {
      uint64_t v12 = v22;
      goto LABEL_13;
    }
  }

  unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to determine statisticsName"));
  id v26 = __stdoutp;
  if (g_runningInCI) {
    uint64_t v27 = "#CI_ERROR# ";
  }
  else {
    uint64_t v27 = "";
  }
  id v28 = v25;
  fprintf( v26,  "%s%s %u: %s\n",  v27,  "NSDictionary *DYMTLReplayFrameProfiler_loadAnalysis(__strong id<MTLDevice>)",  1013,  (const char *)[v28 UTF8String]);
  id v29 = v28;
  GTMTLReplay_handleError( 101,  (uint64_t)[v29 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"DYMTLReplayFrameProfiler_loadAnalysis",  1013,  1);

  CFRelease(v10);
LABEL_18:
  id v30 = &__NSDictionary0__struct;
LABEL_107:

  return v30;
}

          *(void *)(a1 + 24) = *a2;
          return;
        }

LABEL_325:
        v190 = (uint64_t *)*v190;
        if (!v190) {
          goto LABEL_326;
        }
      }

      v212 = *((char *)v190 + 39);
      if (v212 >= 0) {
        v213 = v190 + 2;
      }
      else {
        v213 = (uint64_t *)v190[2];
      }
      if (v212 >= 0) {
        v214 = *((unsigned __int8 *)v190 + 39);
      }
      else {
        v214 = v190[3];
      }
      v215 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v213, v214);
      v216 = (unint64_t *)v215;
      v217 = *((void *)&v481 + 1);
      if (*((void *)&v481 + 1))
      {
        v218 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v481 + 8));
        v218.i16[0] = vaddlv_u8(v218);
        v176 = v218.u32[0];
        if (v218.u32[0] > 1uLL)
        {
          a7 = (unint64_t *)v215;
          if (v215 >= *((void *)&v481 + 1)) {
            a7 = (unint64_t *)(v215 % *((void *)&v481 + 1));
          }
        }

        else
        {
          a7 = (unint64_t *)((*((void *)&v481 + 1) - 1LL) & v215);
        }

        v219 = *(unsigned __int8 ***)(v481 + 8LL * (void)a7);
        if (v219)
        {
          for (ii = *v219; ii; ii = *(unsigned __int8 **)ii)
          {
            v221 = *((void *)ii + 1);
            if ((unint64_t *)v221 == v216)
            {
            }

            else
            {
              if (v176 > 1)
              {
                if (v221 >= v217) {
                  v221 %= v217;
                }
              }

              else
              {
                v221 &= v217 - 1;
              }
            }
          }
        }
      }

      v222 = (char *)operator new(0x50uLL);
      *(void *)v601 = v222;
      *(void *)&v601[8] = &v482;
      v601[16] = 0;
      *(void *)v222 = 0LL;
      *((void *)v222 + 1) = v216;
      v223 = (std::string *)(v222 + 16);
      if (*((char *)v190 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(v223, (const std::string::value_type *)v190[2], v190[3]);
      }

      else
      {
        v224 = *((_OWORD *)v190 + 1);
        *((void *)v222 + 4) = v190[4];
        *(_OWORD *)&v223->__r_.__value_.__l.__data_ = v224;
      }

      v453 = (unint64_t)v216;
      v459 = a7;
      __lenb = v217;
      *(_OWORD *)(v222 + 40) = 0u;
      v225 = (uint64_t *)(v222 + 40);
      *(_OWORD *)(v222 + 56) = 0u;
      *((_DWORD *)v222 + 18) = *((_DWORD *)v190 + 18);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)(v222 + 40),  v190[6]);
      a7 = (unint64_t *)v190[7];
      if (a7)
      {
        v226 = v222 + 56;
        v227 = *((void *)v222 + 6);
        do
        {
          id v78 = (unint64_t)(a7 + 2);
          v228 = *((unsigned int *)a7 + 4);
          if (v227)
          {
            v229 = (uint8x8_t)vcnt_s8((int8x8_t)v227);
            v229.i16[0] = vaddlv_u8(v229);
            if (v229.u32[0] > 1uLL)
            {
              v176 = *((unsigned int *)a7 + 4);
              if (v227 <= v228) {
                v176 = v228 % v227;
              }
            }

            else
            {
              v176 = ((_DWORD)v227 - 1) & v228;
            }

            v230 = *(uint64_t ***)(*v225 + 8 * v176);
            if (v230)
            {
              for (jj = *v230; jj; jj = (uint64_t *)*jj)
              {
                v232 = jj[1];
                if (v232 == v228)
                {
                  if (*((_DWORD *)jj + 4) == (_DWORD)v228) {
                    goto LABEL_302;
                  }
                }

                else
                {
                  if (v229.u32[0] > 1uLL)
                  {
                    if (v232 >= v227) {
                      v232 %= v227;
                    }
                  }

                  else
                  {
                    v232 &= v227 - 1;
                  }

                  if (v232 != v176) {
                    break;
                  }
                }
              }
            }
          }

          v233 = operator new(0x30uLL);
          *v233 = 0LL;
          v233[1] = v228;
          v234 = *((_OWORD *)a7 + 2);
          *((_OWORD *)v233 + 1) = *(_OWORD *)v78;
          *((_OWORD *)v233 + 2) = v234;
          v235 = (float)(unint64_t)(*((void *)v222 + 8) + 1LL);
          v236 = *((float *)v222 + 18);
          if (!v227 || (float)(v236 * (float)v227) < v235)
          {
            v237 = (v227 & (v227 - 1)) != 0;
            if (v227 < 3) {
              v237 = 1LL;
            }
            v238 = v237 | (2 * v227);
            v239 = vcvtps_u32_f32(v235 / v236);
            if (v238 <= v239) {
              v240 = v239;
            }
            else {
              v240 = v238;
            }
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)(v222 + 40),  v240);
            v227 = *((void *)v222 + 6);
            if ((v227 & (v227 - 1)) != 0)
            {
              if (v227 <= v228) {
                v176 = v228 % v227;
              }
              else {
                v176 = v228;
              }
            }

            else
            {
              v176 = ((_DWORD)v227 - 1) & v228;
            }
          }

          v241 = *v225;
          v242 = *(void **)(*v225 + 8 * v176);
          if (v242)
          {
            *v233 = *v242;
          }

          else
          {
            *v233 = *v226;
            *v226 = v233;
            *(void *)(v241 + 8 * v176) = v226;
            if (!*v233) {
              goto LABEL_301;
            }
            v243 = *(void *)(*v233 + 8LL);
            if ((v227 & (v227 - 1)) != 0)
            {
              if (v243 >= v227) {
                v243 %= v227;
              }
            }

            else
            {
              v243 &= v227 - 1;
            }

            v242 = (void *)(*v225 + 8 * v243);
          }

          *v242 = v233;
LABEL_301:
          ++*((void *)v222 + 8);
LABEL_302:
          a7 = (unint64_t *)*a7;
        }

        while (a7);
      }

      v601[16] = 1;
      v244 = (float)(unint64_t)(*((void *)&v482 + 1) + 1LL);
      v246 = (unint64_t)v459;
      v245 = __lenb;
      if (!__lenb || (float)(v483 * (float)__lenb) < v244)
      {
        v247 = (__lenb & (__lenb - 1)) != 0;
        if (__lenb < 3) {
          v247 = 1LL;
        }
        v248 = v247 | (2 * __lenb);
        v249 = vcvtps_u32_f32(v244 / v483);
        if (v248 <= v249) {
          v250 = v249;
        }
        else {
          v250 = v248;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)&v481,  v250);
        v245 = *((void *)&v481 + 1);
        if ((*((void *)&v481 + 1) & (*((void *)&v481 + 1) - 1LL)) != 0)
        {
          if (v453 >= *((void *)&v481 + 1)) {
            v246 = v453 % *((void *)&v481 + 1);
          }
          else {
            v246 = v453;
          }
        }

        else
        {
          v246 = (*((void *)&v481 + 1) - 1LL) & v453;
        }
      }

      v251 = v481;
      v252 = *(void **)(v481 + 8 * v246);
      if (v252)
      {
        *(void *)v222 = *v252;
      }

      else
      {
        *(void *)v222 = v482;
        *(void *)&v482 = v222;
        *(void *)(v251 + 8 * v246) = &v482;
        if (!*(void *)v222)
        {
LABEL_324:
          *(void *)v601 = 0LL;
          ++*((void *)&v482 + 1);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,void *>>>>::reset[abi:nn180100]((uint64_t)v601);
          goto LABEL_325;
        }

        v253 = *(void *)(*(void *)v222 + 8LL);
        if ((v245 & (v245 - 1)) != 0)
        {
          if (v253 >= v245) {
            v253 %= v245;
          }
        }

        else
        {
          v253 &= v245 - 1;
        }

        v252 = (void *)(v481 + 8 * v253);
      }

      *v252 = v222;
      goto LABEL_324;
    }

LABEL_327:
    v478 = 0u;
    v479 = 0u;
    v480 = 1.0;
    p_lbfsize = (FILE *)v502[6];
    v454 = (FILE *)v502[7];
    if (p_lbfsize != v454)
    {
      v255 = 0.0;
      while (1)
      {
        v460 = p_lbfsize;
        v256 = *(uint64_t **)&p_lbfsize->_flags;
        if (v256) {
          break;
        }
LABEL_413:
        p_lbfsize = (FILE *)&v460->_lbfsize;
      }

      while (1)
      {
        v257 = *((char *)v256 + 39);
        if (v257 >= 0) {
          v258 = (unint64_t)(v256 + 2);
        }
        else {
          v258 = v256[2];
        }
        if (v257 >= 0) {
          v259 = *((unsigned __int8 *)v256 + 39);
        }
        else {
          v259 = v256[3];
        }
        v260 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v258, v259);
        v261 = *((void *)&v478 + 1);
        if (!*((void *)&v478 + 1))
        {
          v266 = v256 + 5;
          v267 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v258, v259);
          goto LABEL_371;
        }

        v262 = v260;
        v263 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v478 + 8));
        v263.i16[0] = vaddlv_u8(v263);
        v264 = v263.u32[0];
        if (v263.u32[0] > 1uLL)
        {
          v265 = v260;
          if (v260 >= *((void *)&v478 + 1)) {
            v265 = v260 % *((void *)&v478 + 1);
          }
        }

        else
        {
          v265 = (*((void *)&v478 + 1) - 1LL) & v260;
        }

        v268 = *(void ***)(v478 + 8 * v265);
        if (v268)
        {
          v269 = (char *)*v268;
          if (*v268)
          {
            while (1)
            {
              v270 = *((void *)v269 + 1);
              if (v270 == v262)
              {
                if (std::equal_to<std::string>::operator()[abi:nn180100]( (unsigned __int8 *)v269 + 16,  (unsigned __int8 *)v256 + 16))
                {
                  v302 = 0;
                  goto LABEL_397;
                }
              }

              else
              {
                if (v264 > 1)
                {
                  if (v270 >= v261) {
                    v270 %= v261;
                  }
                }

                else
                {
                  v270 &= v261 - 1;
                }

                if (v270 != v265)
                {
LABEL_353:
                  v266 = v256 + 5;
                  v267 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v258, v259);
                  if (!v261) {
                    goto LABEL_371;
                  }
                  goto LABEL_356;
                }
              }

              v269 = *(char **)v269;
              if (!v269) {
                goto LABEL_353;
              }
            }
          }
        }

        v266 = v256 + 5;
        v267 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v258, v259);
LABEL_356:
        v271 = (uint8x8_t)vcnt_s8((int8x8_t)v261);
        v271.i16[0] = vaddlv_u8(v271);
        v272 = v271.u32[0];
        if (v271.u32[0] > 1uLL)
        {
          v258 = v267;
          if (v267 >= v261) {
            v258 = v267 % v261;
          }
        }

        else
        {
          v258 = (v261 - 1) & v267;
        }

        v273 = *(void ***)(v478 + 8 * v258);
        if (v273)
        {
          v269 = (char *)*v273;
          if (*v273)
          {
            do
            {
              v274 = *((void *)v269 + 1);
              if (v274 == v267)
              {
                if (std::equal_to<std::string>::operator()[abi:nn180100]( (unsigned __int8 *)v269 + 16,  (unsigned __int8 *)v256 + 16))
                {
                  v302 = 1;
                  goto LABEL_397;
                }
              }

              else
              {
                if (v272 > 1)
                {
                  if (v274 >= v261) {
                    v274 %= v261;
                  }
                }

                else
                {
                  v274 &= v261 - 1;
                }

                if (v274 != v258) {
                  break;
                }
              }

              v269 = *(char **)v269;
            }

            while (v269);
          }
        }

LABEL_371:
        v269 = (char *)operator new(0x58uLL);
        *(void *)v601 = v269;
        *(void *)&v601[8] = &v479;
        v601[16] = 0;
        *(void *)v269 = 0LL;
        *((void *)v269 + 1) = v267;
        v275 = (std::string *)(v269 + 16);
        if (*((char *)v256 + 39) < 0)
        {
          std::string::__init_copy_ctor_external(v275, (const std::string::value_type *)v256[2], v256[3]);
        }

        else
        {
          v276 = *((_OWORD *)v256 + 1);
          *((void *)v269 + 4) = v256[4];
          *(_OWORD *)&v275->__r_.__value_.__l.__data_ = v276;
        }

        *(_OWORD *)(v269 + 40) = *v266;
        *((void *)v269 + 8) = 0LL;
        *((void *)v269 + 9) = 0LL;
        *((void *)v269 + 7) = 0LL;
        *(_OWORD *)(v269 + 56) = *(_OWORD *)(v256 + 7);
        *((void *)v269 + 9) = v256[9];
        v256[7] = 0LL;
        v256[8] = 0LL;
        v256[9] = 0LL;
        *((void *)v269 + 10) = v256[10];
        v601[16] = 1;
        v277 = (float)(unint64_t)(*((void *)&v479 + 1) + 1LL);
        if (!v261 || (float)(v480 * (float)v261) < v277)
        {
          v278 = v261 < 3 || (v261 & (v261 - 1)) != 0;
          v279 = v278 | (2 * v261);
          v280 = vcvtps_u32_f32(v277 / v480);
          if (v279 <= v280) {
            v281 = v280;
          }
          else {
            v281 = v279;
          }
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)&v478,  v281);
          v261 = *((void *)&v478 + 1);
          if ((*((void *)&v478 + 1) & (*((void *)&v478 + 1) - 1LL)) != 0)
          {
            if (v267 >= *((void *)&v478 + 1)) {
              v258 = v267 % *((void *)&v478 + 1);
            }
            else {
              v258 = v267;
            }
          }

          else
          {
            v258 = (*((void *)&v478 + 1) - 1LL) & v267;
          }
        }

        v282 = v478;
        v283 = *(void **)(v478 + 8 * v258);
        if (v283)
        {
          *(void *)v269 = *v283;
        }

        else
        {
          *(void *)v269 = v479;
          *(void *)&v479 = v269;
          *(void *)(v282 + 8 * v258) = &v479;
          if (!*(void *)v269) {
            goto LABEL_396;
          }
          v284 = *(void *)(*(void *)v269 + 8LL);
          if ((v261 & (v261 - 1)) != 0)
          {
            if (v284 >= v261) {
              v284 %= v261;
            }
          }

          else
          {
            v284 &= v261 - 1;
          }

          v283 = (void *)(v478 + 8 * v284);
        }

        *v283 = v269;
LABEL_396:
        *(void *)v601 = 0LL;
        ++*((void *)&v479 + 1);
        std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BinaryInfo>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BinaryInfo>,void *>>>>::reset[abi:nn180100]((uint64_t)v601);
        v302 = 1;
LABEL_397:
        v285 = v256[7];
        v286 = v256[8];
        v287 = 0x6DB6DB6DB6DB6DB7LL * ((v286 - v285) >> 3);
        v288 = *((void *)v269 + 7);
        if (v287 == 0x6DB6DB6DB6DB6DB7LL * ((*((void *)v269 + 8) - v288) >> 3) && v286 != v285)
        {
          v290 = 0LL;
          if (v287 <= 1) {
            v287 = 1LL;
          }
          do
          {
            v291 = (uint64_t *)(v288 + 56 * v290);
            *((_DWORD *)v291 + 8) += *(_DWORD *)(v285 + 56 * v290 + 32);
            v292 = *v291;
            v293 = v291[1] - *v291;
            if (v293)
            {
              v295 = *(float64x2_t *)(v291 + 5);
              v294 = (float64x2_t *)(v291 + 5);
              v296 = v295;
              v297 = v293 / 24;
              v298 = *(float64x2_t *)(v269 + 40);
              v299 = (float64x2_t *)(*(void *)(v285 + 56 * v290) + 8LL);
              v300 = (float64x2_t *)(v292 + 8);
              do
              {
                if ((v302 & 1) == 0)
                {
                  LODWORD(v300[-1].f64[1]) += LODWORD(v299[-1].f64[1]);
                  *v300 = vaddq_f64(*v299, *v300);
                }

                v301 = *v299;
                v299 = (float64x2_t *)((char *)v299 + 24);
                v296 = vaddq_f64(v301, v296);
                v298 = vaddq_f64(v301, v298);
                v255 = v255 + v301.f64[1];
                v300 = (float64x2_t *)((char *)v300 + 24);
                --v297;
              }

              while (v297);
              *v294 = v296;
              *(float64x2_t *)(v269 + 40) = v298;
            }

            ++v290;
          }

          while (v290 != v287);
        }

        v256 = (uint64_t *)*v256;
        if (!v256) {
          goto LABEL_413;
        }
      }
    }

    v255 = 0.0;
LABEL_416:
    v303 = fopen("/tmp/com.apple.gputools.profiling/shaderProfilerResults/bblCostInfo.txt", "wt");
    std::string::basic_string[abi:nn180100]<0>( v601,  "Binary 0x%s : Num Basic Blocks = %u : Total Cost = %.4f %% Weight = %.4f\n\n");
    std::string::basic_string[abi:nn180100]<0>( v469,  "Index   PC  NumInst  Mean Occurences  Total Original Cost Total Cost  Block Weight %%\n");
    std::string::basic_string[abi:nn180100]<0>(v599, "%d      0x%x %4d %10u  %15.2f %15.2f %15.4f\n\n");
    std::string::basic_string[abi:nn180100]<0>(&v475, "%d      0x%x %15u %15.4f %15.4f %15.5f\n");
    p = (unsigned __int8 *)v479;
    if ((void)v479)
    {
      do
      {
        v305 = p + 16;
        v306 = (GPUToolsPlatformLLVMShaderProfilerHelperImpl **)*((void *)p + 10);
        TargetClauseAnalysis = GPUToolsPlatformLLVMShaderProfilerHelperImpl::GetTargetClauseAnalysis(*v306);
        if (v601[23] >= 0) {
          v308 = v601;
        }
        else {
          v308 = *(const char **)v601;
        }
        v309 = *TargetClauseAnalysis;
        fprintf( v303,  v308,  v305,  0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*((void *)p + 8) - *((void *)p + 7)) >> 3),  *((void *)p + 6),  *((double *)p + 6) * 100.0 / v255);
        v310 = (unsigned int **)*((void *)p + 7);
        v455 = (FILE *)p;
        v461 = (unsigned int **)*((void *)p + 8);
        if (v310 != v461)
        {
          v311 = 0LL;
          v312 = (void *)(v309 + 160);
          do
          {
            v313 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v312,  *((_DWORD *)v310 + 6));
            if (v313)
            {
              v314 = v313;
              if ((SBYTE7(v470) & 0x80u) == 0) {
                v315 = v469;
              }
              else {
                v315 = (void **)v469[0];
              }
              fputs((const char *)v315, v303);
              if (v600 >= 0) {
                v316 = (const char *)v599;
              }
              else {
                v316 = (const char *)v599[0];
              }
              __lenc = v311;
              fprintf( v303,  v316,  v311,  v314[3],  0xAAAAAAAAAAAAAAABLL * (((char *)v310[1] - (char *)*v310) >> 3),  *((unsigned int *)v310 + 8),  v310[5],  v310[6],  *((double *)v310 + 6) * 100.0 / v255);
              v317 = *v310;
              v318 = v310[1];
              if (*v310 != v318)
              {
                v319 = 0;
                do
                {
                  v320 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v312,  *((_DWORD *)v310 + 6) + v319);
                  if (v320)
                  {
                    v321 = v320[3];
                    GPUToolsPlatformLLVMShaderProfilerHelper::ShaderInstructionInfoFromBinary( (void ***)&v472,  (uint64_t)*v306,  v321,  v321 + *((unsigned int *)v320 + 8));
                    if (v472 != v473)
                    {
                      v322 = &v472->__r_.__value_.__s.__data_[8];
                      if (v472[1].__r_.__value_.__s.__data_[7] < 0) {
                        v322 = *(const char **)v322;
                      }
                      fprintf(v303, "%s\n", v322);
                      if (SHIBYTE(v477) >= 0) {
                        fprintf( v303,  (const char *)&v475,  (*((_DWORD *)v310 + 6) + v319),  v321,  *v317,  *((void *)v317 + 1),  *((void *)v317 + 2),  *((double *)v317 + 2) * 100.0 / v255);
                      }
                      else {
                        fprintf( v303,  (const char *)v475,  (*((_DWORD *)v310 + 6) + v319),  v321,  *v317,  *((void *)v317 + 1),  *((void *)v317 + 2),  *((double *)v317 + 2) * 100.0 / v255);
                      }
                      ++v319;
                    }

                    v468.__r_.__value_.__r.__words[0] = (std::string::size_type)&v472;
                    std::vector<InstructionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v468);
                  }

                  v317 += 6;
                }

                while (v317 != v318);
              }

              v311 = (__lenc + 1);
              fputc(10, v303);
            }

            v310 += 7;
          }

          while (v310 != v461);
        }

        fputc(10, v303);
        p = v455->_p;
      }

      while (v455->_p);
    }

    fclose(v303);
    if (SHIBYTE(v477) < 0) {
      operator delete(v475);
    }
    if (SHIBYTE(v600) < 0) {
      operator delete(v599[0]);
    }
    if (SBYTE7(v470) < 0) {
      operator delete(v469[0]);
    }
    if ((v601[23] & 0x80000000) != 0) {
      operator delete(*(void **)v601);
    }
    *(_OWORD *)v469 = 0u;
    v470 = 0u;
    v471 = 1065353216;
    v323 = v511[6];
    v324 = v511[7];
    while (v323 != v324)
    {
      for (kk = *(void **)(v323 + 16); kk; kk = (void *)*kk)
      {
        if (!std::unordered_map<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::find[abi:nn180100]( v469,  (uint64_t)(kk + 2))) {
          std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>( (uint64_t)v469,  (uint64_t)(kk + 2),  (uint64_t)(kk + 2),  kk + 5);
        }
      }

      v323 += 40LL;
    }

    v326 = *((void *)&v482 + 1);
    v476 = 0LL;
    v477 = 0LL;
    v475 = 0LL;
    if (*((void *)&v482 + 1))
    {
      if (*((void *)&v482 + 1) >= 0xAAAAAAAAAAAAAABuLL) {
        abort();
      }
      v327 = (char *)operator new(24LL * *((void *)&v482 + 1));
      v475 = v327;
      v477 = &v327[24 * v326];
      bzero(v327, 24 * ((24 * v326 - 24) / 0x18) + 24);
      v476 = &v327[24 * ((24 * v326 - 24) / 0x18) + 24];
      v462 = (unsigned int *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v326);
      bzero(v462, 4 * v326);
      v328 = *((void *)&v482 + 1);
      if (*((void *)&v482 + 1))
      {
        if (*((void *)&v482 + 1) >> 62) {
          abort();
        }
        v326 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(*((unint64_t *)&v482 + 1));
        bzero((void *)v326, 4 * v328);
      }

      else
      {
        v326 = 0LL;
      }
    }

    else
    {
      v462 = 0LL;
    }

    __lend = v326;
    v329 = (void *)v482;
    if ((void)v482)
    {
      v330 = 0;
      v331 = 0;
      do
      {
        v332 = v330;
        v333 = (char *)v475;
        v334 = (uint64_t *)((char *)v475 + 24 * v330);
        v335 = v334 + 2;
        v336 = *((void *)v329 + 8);
        v337 = *v334;
        v456 = (FILE *)v329;
        if (0x6DB6DB6DB6DB6DB7LL * ((v334[2] - *v334) >> 2) < v336)
        {
          if (v336 > 0x924924924924924LL) {
            abort();
          }
          v338 = (char *)v475 + 24 * v330;
          v341 = *((void *)v338 + 1);
          v339 = (void **)(v338 + 8);
          v340 = v341;
          v342 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ClauseData>>(v336);
          v344 = (char *)*v339;
          v345 = (char *)*v334;
          v346 = &v342[28 * ((v341 - v337) / 28)];
          if (*v339 != (void *)*v334)
          {
            do
            {
              v347 = *(_OWORD *)(v344 - 28);
              *((_OWORD *)v346 - 1) = *((_OWORD *)v344 - 1);
              *(_OWORD *)(v346 - 28) = v347;
              v346 -= 28;
              v344 -= 28;
            }

            while (v344 != v345);
            v344 = (char *)*v334;
          }

          *v334 = (uint64_t)v346;
          *v339 = &v342[28 * ((v340 - v337) / 28)];
          *v335 = &v342[28 * v343];
          v329 = v456;
          if (v344) {
            operator delete(v344);
          }
        }

        v348 = (uint64_t *)*((void *)v329 + 7);
        v349 = &v333[24 * v332];
        v352 = (_OWORD *)*((void *)v349 + 1);
        v350 = (void **)(v349 + 8);
        for (mm = v352; v348; v348 = (uint64_t *)*v348)
        {
          v353 = (__int128 *)((char *)v348 + 20);
          if ((unint64_t)mm >= *v335)
          {
            v355 = 0x6DB6DB6DB6DB6DB7LL * (((uint64_t)mm - *v334) >> 2);
            v356 = v355 + 1;
            if (0xDB6DB6DB6DB6DB6ELL * ((*v335 - *v334) >> 2) > v356) {
              v356 = 0xDB6DB6DB6DB6DB6ELL * ((*v335 - *v334) >> 2);
            }
            else {
              v357 = v356;
            }
            if (v357) {
              v357 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ClauseData>>(v357);
            }
            else {
              v358 = 0LL;
            }
            v359 = (_OWORD *)(v357 + 28 * v355);
            v360 = *v353;
            *(_OWORD *)((char *)v359 + 12) = *((_OWORD *)v348 + 2);
            *v359 = v360;
            v361 = (char *)*v350;
            v362 = (char *)*v334;
            v363 = v359;
            if (*v350 != (void *)*v334)
            {
              do
              {
                v364 = *(_OWORD *)(v361 - 28);
                *(v363 - 1) = *((_OWORD *)v361 - 1);
                *(_OWORD *)((char *)v363 - 28) = v364;
                v363 = (_OWORD *)((char *)v363 - 28);
                v361 -= 28;
              }

              while (v361 != v362);
              v361 = (char *)*v334;
            }

            *v334 = (uint64_t)v363;
            mm = (_OWORD *)((char *)v359 + 28);
            *v350 = (char *)v359 + 28;
            *v335 = v357 + 28 * v358;
            if (v361) {
              operator delete(v361);
            }
          }

          else
          {
            v354 = *v353;
            *(_OWORD *)((char *)mm + 12) = *((_OWORD *)v348 + 2);
            *mm = v354;
            mm = (_OWORD *)((char *)mm + 28);
          }

          *v350 = mm;
          v331 += *((_DWORD *)v348 + 7);
          v462[v332] += *((_DWORD *)v348 + 6);
          *(_DWORD *)(__lend + 4 * v332) += *((_DWORD *)v348 + 7);
        }

        v365 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7LL * (((uint64_t)mm - *v334) >> 2));
        if (mm == (_OWORD *)*v334) {
          v366 = 0LL;
        }
        else {
          v366 = v365;
        }
        std::__introsort<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *,false>( *v334,  (unsigned int *)mm,  v366,  1);
        v330 = v332 + 1;
        v329 = v456->_p;
      }

      while (v456->_p);
    }

    else
    {
      v331 = 0;
    }

    std::string::basic_string[abi:nn180100]<0>(v601, "%u%u");
    std::string::basic_string[abi:nn180100]<0>(&v602, "");
    std::string::basic_string[abi:nn180100]<0>(&v605, "%s%s%u%u%.2f");
    std::string::basic_string[abi:nn180100]<0>(v608, "");
    v472 = 0LL;
    v473 = 0LL;
    p_data = 0LL;
    v472 = (std::string *)operator new(0x60uLL);
    v473 = v472;
    p_data = (void **)&v472[4].__r_.__value_.__l.__data_;
    v367 = 0LL;
    v473 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>( (__int128 *)v601,  &v609,  v472);
    do
    {
      if (SHIBYTE(v608[v367 + 2]) < 0) {
        operator delete((void *)v608[v367]);
      }
      v367 -= 3LL;
    }

    while (v367 != -12);
    v368 = (void *)objc_claimAutoreleasedReturnValue(-[DYPMTLShaderProfilerHelper _costHeaders](v443, "_costHeaders"));
    if (v368)
    {
      v369 = 0LL;
      for (nn = 0LL; nn != 3; ++nn)
      {
        v371 = objc_claimAutoreleasedReturnValue([v368 objectAtIndexedSubscript:nn]);
        v372 = (const std::string::value_type *)[v371 UTF8String];
        std::string::assign(&v472[v369], v372);

        ++v369;
      }
    }

    v373 = fopen("/tmp/com.apple.gputools.profiling/shaderProfilerResults/segLikeCost.txt", "wt");
    v374 = fopen("/tmp/com.apple.gputools.profiling/shaderProfilerResults/segLikeCostOnly.txt", "wt");
    v375 = v472;
    v376 = (int *)v574[6];
    v377 = (int *)v574[7];
    if (v376 == v377)
    {
      v378 = 0LL;
    }

    else
    {
      LODWORD(v378) = 0;
      do
      {
        v379 = *v376++;
        v378 = (v379 + v378);
      }

      while (v376 != v377);
    }

    v380 = (int *)v565[6];
    v381 = (int *)v565[7];
    if (v380 == v381)
    {
      v382 = 0LL;
    }

    else
    {
      LODWORD(v382) = 0;
      do
      {
        v383 = *v380++;
        v382 = (v383 + v382);
      }

      while (v380 != v381);
    }

    v445 = v368;
    fprintf(v373, (const char *)v375, v378, v382);
    v384 = (const char *)&v472[1];
    fputs(v384, v374);
    v385 = v482;
    v457 = v374;
    if ((void)v482)
    {
      v386 = 0;
      v387 = (double)v331;
      do
      {
        v388 = (const char *)&v472[2];
        v389 = (uint64_t *)(v385 + 16);
        v390 = v385 + 16;
        v391 = v386;
        v447 = v386;
        v432 = *(unsigned int *)(__lend + 4LL * v386);
        fprintf( v373,  v388,  off_58EC50[*(unsigned int *)(*((void *)v475 + 3 * v386) + 20LL)],  v390,  v462[v386],  v432,  (double)v432 * 100.0 / v387);
        v392 = (const char *)&v472[2];
        v393 = v385 + 16;
        fprintf( v374,  v392,  off_58EC50[*(unsigned int *)(*((void *)v475 + 3 * v391) + 20LL)],  v393,  v462[v391],  *(unsigned int *)(__lend + 4 * v391),  (double)*(unsigned int *)(__lend + 4 * v391) * 100.0 / v387);
        v394 = (const char *)&v472[1];
        v450 = (uint64_t *)v385;
        fputs(v394, v373);
        v395 = (char *)v475 + 24 * v391;
        v397 = *(unsigned int **)v395;
        v396 = (unsigned int *)*((void *)v395 + 1);
        if (*(unsigned int **)v395 != v396)
        {
          do
          {
            v398 = v397[1];
            v399 = v397[2];
            v400 = (double)v399 / (double)v398;
            if (!v398) {
              v400 = 0.0;
            }
            fprintf( v373,  "0x%0.8x %6u %10u %10u %10u %10.2g %10u %10.2g\n",  *v397,  *v397,  v397[3],  v398,  v397[6],  v400,  v397[2],  (double)v399 * 100.0 / v387);
            v401 = v397[1];
            v402 = v397[2];
            v403 = (double)v402 / (double)v401;
            if (!v401) {
              v403 = 0.0;
            }
            fprintf( v374,  "0x%0.8x %6u %10u %10u %10u %10.2g %10u %10.2g\n",  *v397,  *v397,  v397[3],  v401,  v397[6],  v403,  v397[2],  (double)v402 * 100.0 / v387);
            v404 = (GPUToolsPlatformLLVMShaderProfilerHelperImpl **)*((void *)std::unordered_map<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::find[abi:nn180100]( v469,  (uint64_t)v389)
                                                                    + 5);
            v405 = GPUToolsPlatformLLVMShaderProfilerHelperImpl::GetTargetClauseAnalysis(*v404);
            v406 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( (void *)(*v405 + 56LL),  *v397);
            if (v406) {
              v407 = *((unsigned int *)v406 + 6);
            }
            else {
              v407 = 0xFFFFFFFFLL;
            }
            v408 = *v404;
            v599[0] = 0LL;
            v599[1] = 0LL;
            v600 = 0LL;
            *(_DWORD *)&v601[8] = 0;
            v604 = 0;
            v605 = 0LL;
            v606 = 1;
            v602 = 0LL;
            v603 = 0LL;
            *(void *)&v601[16] = 0LL;
            v607 = (std::string *)v599;
            llvm::raw_ostream::SetUnbuffered((llvm::raw_ostream *)v601);
            v409 = (uint64_t **)GPUToolsPlatformLLVMShaderProfilerHelperImpl::GetTargetClauseAnalysis(v408);
            v411 = **v409;
            if (0x2E8BA2E8BA2E8BA3LL * (((*v409)[1] - v411) >> 3) > v407)
            {
              v412 = (uint64_t *)(v411 + 88LL * *(void *)((*v409)[3] + 48LL * v407));
              GPUToolsPlatformLLVMShaderProfilerHelperImpl::_DumpInstructionsToOStream( v408,  (llvm::raw_ostream *)v601,  *v412,  v412[1] + *v412,  v410);
            }

            v413 = v607;
            if ((char)v607->__r_.__value_.__s.__size_ < 0)
            {
              v415 = (const std::string::value_type *)v607->__r_.__value_.__r.__words[0];
              size = v607->__r_.__value_.__l.__size_;
            }

            else
            {
              size = v607->__r_.__value_.__s.__size_;
              v415 = (const std::string::value_type *)v607;
            }

            v468.__r_.__value_.__s.__data_[0] = 9;
            v416 = std::remove[abi:nn180100]<std::__wrap_iter<char *>,char>( v415,  (unsigned __int8 *)&v415[size],  (unsigned __int8 *)&v468);
            if ((char)v413->__r_.__value_.__s.__size_ < 0)
            {
              v418 = v413->__r_.__value_.__r.__words[0];
              v417 = (char *)(v413->__r_.__value_.__r.__words[0] + v413->__r_.__value_.__l.__size_);
            }

            else
            {
              v417 = (char *)v413 + v413->__r_.__value_.__s.__size_;
              v418 = (std::string::size_type)v413;
            }

            std::string::erase(v413, (std::string::size_type)&v416[-v418], v417 - (char *)v416);
            if ((char)v607->__r_.__value_.__s.__size_ < 0) {
              std::string::__init_copy_ctor_external( &v468,  v607->__r_.__value_.__l.__data_,  v607->__r_.__value_.__l.__size_);
            }
            else {
              v468 = *v607;
            }
            llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)v601);
            if (SHIBYTE(v600) < 0) {
              operator delete(v599[0]);
            }
            v419 = (char)v468.__r_.__value_.__s.__size_;
            v420 = (void *)v468.__r_.__value_.__r.__words[0];
            if ((v468.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              v421 = &v468;
            }
            else {
              v421 = (std::string *)v468.__r_.__value_.__r.__words[0];
            }
            fputs((const char *)v421, v373);
            fputc(10, v373);
            if (v419 < 0) {
              operator delete(v420);
            }
            v397 += 7;
            v374 = v457;
          }

          while (v397 != v396);
        }

        v386 = v447 + 1;
        v385 = *v450;
      }

      while (*v450);
    }

    if (v373) {
      fclose(v373);
    }
    v422 = 126 - 2 * __clz(((char *)v433 - (char *)v435) >> 3);
    v423 = (char *)v433 - (char *)v435;
    if (v433 == v435) {
      v424 = 0LL;
    }
    else {
      v424 = v422;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>( (unint64_t)v435,  v433,  v424,  1);
    fwrite("\nDraw Call Costs\n", 0x11uLL, 1uLL, v374);
    fprintf(v374, "Idx   drawIdx  function vertex key  fragment key  Cost    %%Weight\n");
    v425 = (void *)__lend;
    if ((int)((unint64_t)v423 >> 3) >= 1)
    {
      v426 = 0LL;
      else {
        v427 = (int)(v423 >> 3);
      }
      v428 = v435;
      do
      {
        v429 = (void *)objc_claimAutoreleasedReturnValue([v451 drawCallInfoList]);
        v430 = (id *)objc_claimAutoreleasedReturnValue([v429 objectAtIndexedSubscript:v426]);

        fprintf( v457,  "%d : %8u %8u   0x%s   0x%s    0x%s : %8u  : %4.2f\n",  v426,  [v430 drawCallIndex],  objc_msgSend(v430, "functionIndex"),  (const char *)objc_msgSend(v430[1], "UTF8String"),  (const char *)objc_msgSend(v430[2], "UTF8String"),  (const char *)objc_msgSend(v430[3], "UTF8String"),  *v428,  (double)*v428 * 100.0 / (double)v331);
        v425 = (void *)__lend;
        v368 = v445;
        ++v426;
        v428 += 2;
      }

      while (v427 != v426);
    }

    if (v457) {
      fclose(v457);
    }

    *(void *)v601 = &v472;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
    if (v425) {
      operator delete(v425);
    }
    if (v462) {
      operator delete(v462);
    }
    *(void *)v601 = &v475;
    std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
    std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::__deallocate_node((void *)v470);
    v431 = v469[0];
    v469[0] = 0LL;
    if (v431) {
      operator delete(v431);
    }
    std::__hash_table<std::__hash_value_type<std::string,BinaryInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BinaryInfo>>>::~__hash_table((uint64_t)&v478);
    std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>>>::~__hash_table((uint64_t)&v481);
    v161 = v498;
  }

  if (v161)
  {
    v499 = v161;
    operator delete(v161);
  }

  _Block_object_dispose(&v501, 8);
  *(void *)v601 = &v507;
  std::vector<std::unordered_map<std::string,BinaryInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  _Block_object_dispose(&v510, 8);
  *(void *)v601 = &v516;
  std::vector<std::unordered_map<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  _Block_object_dispose(&v519, 8);
  *(void *)v601 = &v525;
  std::vector<std::unordered_map<std::string,std::unordered_map<unsigned int,ClauseData>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  _Block_object_dispose(&v528, 8);
  *(void *)v601 = &v534;
  std::vector<std::vector<InstructionPCInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  _Block_object_dispose(&v537, 8);
  *(void *)v601 = &v543;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  if (v435) {
    operator delete(v435);
  }
  if (v448) {
    operator delete(v448);
  }

  _Block_object_dispose(v553, 8);
  if (v554)
  {
    v555 = v554;
    operator delete(v554);
  }

  _Block_object_dispose(&v557, 8);
  *(void *)v601 = v563;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  _Block_object_dispose(&v564, 8);
  if (v570)
  {
    v571 = (char *)v570;
    operator delete(v570);
  }

  _Block_object_dispose(&v573, 8);
  if (v579)
  {
    v580 = (char *)v579;
    operator delete(v579);
  }

  *(void *)v601 = &v582;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
  _Block_object_dispose(&v586, 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>>>::~__hash_table((uint64_t)&v590[8]);
  if (v595 < 0) {
    operator delete(v594);
  }

  *(void *)v601 = &v596;
  std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v601);
}

void sub_109BE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, void *a37, uint64_t a38, void *a39, uint64_t a40, void *a41, void *a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(void *)(v65 - 232) = &a56;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v65 - 232));
  std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::~__hash_table((uint64_t)&a47);
  std::__hash_table<std::__hash_value_type<std::string,BinaryInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BinaryInfo>>>::~__hash_table((uint64_t)&a59);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>>>::~__hash_table((uint64_t)&a65);
  if (STACK[0x2C8]) {
    operator delete((void *)STACK[0x2C8]);
  }
  _Block_object_dispose(&STACK[0x2E0], 8);
  a65 = a21;
  std::vector<std::unordered_map<std::string,BinaryInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a65);
  _Block_object_dispose(&STACK[0x328], 8);
  STACK[0x2E0] = a22;
  std::vector<std::unordered_map<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x2E0]);
  _Block_object_dispose(&STACK[0x370], 8);
  STACK[0x328] = a23;
  std::vector<std::unordered_map<std::string,std::unordered_map<unsigned int,ClauseData>>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x328]);
  _Block_object_dispose(&STACK[0x3B8], 8);
  STACK[0x370] = a24;
  std::vector<std::vector<InstructionPCInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x370]);
  _Block_object_dispose(&STACK[0x400], 8);
  STACK[0x3B8] = a25;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x3B8]);
  if (a28) {
    operator delete(a28);
  }
  if (a37) {
    operator delete(a37);
  }

  _Block_object_dispose(&STACK[0x4D0], 8);
  v67 = (void *)STACK[0x500];
  if (STACK[0x500])
  {
    STACK[0x508] = (unint64_t)v67;
    operator delete(v67);
  }

  _Block_object_dispose(&STACK[0x518], 8);
  STACK[0x4D0] = a19;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x4D0]);
  _Block_object_dispose(&STACK[0x560], 8);
  int v68 = (void *)STACK[0x590];
  if (STACK[0x590])
  {
    STACK[0x598] = (unint64_t)v68;
    operator delete(v68);
  }

  _Block_object_dispose(&STACK[0x5A8], 8);
  unsigned int v69 = (void *)STACK[0x5D8];
  if (STACK[0x5D8])
  {
    STACK[0x5E0] = (unint64_t)v69;
    operator delete(v69);
  }

  STACK[0x5A8] = (unint64_t)&STACK[0x5F0];
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x5A8]);
  _Block_object_dispose(&STACK[0x630], 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>>>::~__hash_table(a20);
  if (SLOBYTE(STACK[0x6A7]) < 0) {
    operator delete((void *)STACK[0x690]);
  }

  STACK[0x630] = (unint64_t)&STACK[0x6A8];
  std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x630]);

  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::unique_ptr<std::vector<double>>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  io_connect_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        id v6 = v4;
        std::vector<std::unique_ptr<std::vector<double>>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::~__hash_table( uint64_t a1)
{
  io_connect_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<long,std::unique_ptr<ShaderBinaryStatsInfo>>,std::__unordered_map_hasher<long,std::__hash_value_type<long,std::unique_ptr<ShaderBinaryStatsInfo>>,std::hash<long>,std::equal_to<long>,true>,std::__unordered_map_equal<long,std::__hash_value_type<long,std::unique_ptr<ShaderBinaryStatsInfo>>,std::equal_to<long>,std::hash<long>,true>,std::allocator<std::__hash_value_type<long,std::unique_ptr<ShaderBinaryStatsInfo>>>>::__deallocate_node( void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      io_connect_t v2 = (void *)*v1;
      id v3 = (id *)v1[3];
      v1[3] = 0LL;
      if (v3) {
        std::default_delete<ShaderBinaryStatsInfo>::operator()[abi:nn180100](v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }

    while (v2);
  }

void std::default_delete<ShaderBinaryStatsInfo>::operator()[abi:nn180100](id *a1)
{
  io_connect_t v2 = a1 + 2;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete(a1);
}

void std::vector<std::pair<ShaderBinaryStatsInfo *,std::string>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  io_connect_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 4;
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>>>::~__hash_table( uint64_t a1)
{
  io_connect_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      id v3 = (void **)*v2;
      operator delete(v2);
      io_connect_t v2 = v3;
    }

    while (v3);
  }

  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::__deallocate_node( void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      io_connect_t v2 = (void *)*v1;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,0>((uint64_t)(v1 + 2));
      operator delete(v1);
      uint64_t v1 = v2;
    }

    while (v2);
  }

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,0>( uint64_t a1)
{
  io_connect_t v2 = *(uint64_t **)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;
  if (v2)
  {
    std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelperImpl>::reset[abi:nn180100](v2, 0LL);
    operator delete(v2);
  }

void std::vector<std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  io_connect_t v2 = (void ***)**a1;
  if (v2)
  {
    uint64_t v4 = (void ***)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>::reset[abi:nn180100](--v4, 0LL);
      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>::reset[abi:nn180100]( void ***a1, void **a2)
{
  io_connect_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    id v3 = (char *)*v2;
    if (*v2)
    {
      uint64_t v4 = (char *)v2[1];
      id v5 = *v2;
      if (v4 != v3)
      {
        id v6 = (char *)v2[1];
        do
        {
          id v8 = (void *)*((void *)v6 - 3);
          v6 -= 24;
          id v7 = v8;
          if (v8)
          {
            *((void *)v4 - 2) = v7;
            operator delete(v7);
          }

          uint64_t v4 = v6;
        }

        while (v6 != v3);
        id v5 = *v2;
      }

      v2[1] = v3;
      operator delete(v5);
    }

    operator delete(v2);
  }

void std::vector<std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  io_connect_t v2 = (void ***)**a1;
  if (v2)
  {
    uint64_t v4 = (void ***)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::reset[abi:nn180100](--v4);
      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::reset[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  *a1 = 0LL;
  if (v1)
  {
    io_connect_t v2 = v1;
    std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v2);
    operator delete(v1);
  }

void std::vector<std::unique_ptr<std::vector<double>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  io_connect_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        id v7 = (void **)*--v4;
        id v6 = v7;
        *uint64_t v4 = 0LL;
        if (v7) {
          std::default_delete<std::vector<double>>::operator()[abi:nn180100](v6);
        }
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::default_delete<std::vector<double>>::operator()[abi:nn180100](void **__p)
{
  io_connect_t v2 = *__p;
  if (v2)
  {
    __p[1] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t std::pair<ShaderBinaryInfo * {__strong},std::string>::~pair(uint64_t a1)
{
  return a1;
}

uint64_t __Block_byref_object_copy__549(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0LL;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0LL;
  uint64_t v5 = a2[8];
  id v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }

    else
    {
      v7 &= v8 - 1;
    }

    *(void *)(v2 + 8 * v7) = result + 64;
    *id v3 = 0LL;
    v3[1] = 0LL;
  }

  return result;
}

uint64_t __Block_byref_object_dispose__550(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>>>::~__hash_table(a1 + 48);
}

LABEL_59:
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v9 >= v14) {
        id v3 = v9 % v14;
      }
      else {
        id v3 = v9;
      }
    }

    else
    {
      id v3 = (v14 - 1) & v9;
    }
  }

  uint64_t v39 = *(void **)(*(void *)(v10 + 48) + 8 * v3);
  uint64_t v40 = v46[0];
  if (v39)
  {
    *(void *)v46[0] = *v39;
LABEL_72:
    *uint64_t v39 = v40;
    goto LABEL_73;
  }

  *(void *)v46[0] = *(void *)(v10 + 64);
  *(void *)(v10 + 64) = v40;
  *(void *)(*(void *)(v10 + 48) + 8 * v3) = v20;
  if (*(void *)v40)
  {
    id v41 = *(void *)(*(void *)v40 + 8LL);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v41 >= v14) {
        v41 %= v14;
      }
    }

    else
    {
      v41 &= v14 - 1;
    }

    uint64_t v39 = (void *)(*(void *)(v10 + 48) + 8 * v41);
    goto LABEL_72;
  }

          uint64_t v77 = apr_palloc(p, 8uLL);
          *uint64_t v77 = *v104;
          apr_hash_set(ht, v77, 8LL, v61);
          id v78 = (void *)objc_claimAutoreleasedReturnValue([v108 bufferForKey:*v104]);
          id v29 = v100;
          id v79 = (void *)objc_claimAutoreleasedReturnValue([v100 blitCommandEncoder]);
          id v80 = (void *)objc_claimAutoreleasedReturnValue([v103 heapBuffer]);
          objc_msgSend( v79,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v80,  objc_msgSend(v103, "heapLocation"),  v78,  v104[3],  v104[4]);

          char v46 = v93;
          apr_pool_clear(*v93);

          p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___MTLResource + 32);
          uint64_t v50 = v97;
          int v49 = v98;
          id v45 = v95;
        }

        v81 = p_class_meths[321];
        v82 = v81;
        if (v45 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v81))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl( &dword_0,  v82,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-6-high",  (const char *)&unk_3189BB,  buf,  2u);
        }

        v52 += v112;

        objc_autoreleasePoolPop(v111);
        ++v51;
      }

      while (v51 != v50);
    }

    v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"CompareAndRestoreResourcesFromArchive"));
    v88 = (void *)objc_claimAutoreleasedReturnValue([v29 commandBuffer]);
    [v88 setLabel:v87];

    [v29 commitCommandBufferWithLog:v91];
    id v89 = p_class_meths[321];
    int v90 = v89;
    if (v45 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled(v89))
    {
      *(_DWORD *)buf = 134217984;
      v114 = v52;
      _os_signpost_emit_with_name_impl( &dword_0,  v90,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-2-restore",  "%{xcode:size-in-bytes}zu",  buf,  0xCu);
    }

    [v91 leaveActivity];
    goto LABEL_77;
  }

  if (!*(_DWORD *)a2)
  {
    unint64_t v8 = *(uint64_t **)(a2 + 8);
    id v9 = *(unsigned int *)(a2 + 4);
    id v10 = v6;
    uint64_t v11 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
    v110 = v10;
    [v10 enterRestoreResources:v8 count:v9];
    uint64_t v12 = a1[3];
    id v13 = g_signpostLog;
    id v14 = (os_log_s *)v13;
    id v15 = v11 - 1;
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v13))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v114) = v9;
      _os_signpost_emit_with_name_impl( &dword_0,  v14,  OS_SIGNPOST_INTERVAL_BEGIN,  v11,  "Replayer-2-restore",  "RestoreResourceFromArchive x%d",  buf,  8u);
    }

    __int128 v99 = v12;
    v92 = v7;

    if ((int)v9 < 1)
    {
      float v16 = 0LL;
    }

    else
    {
      float v16 = 0LL;
      do
      {
        id v17 = objc_autoreleasePoolPush();
        uint64_t v18 = RequestSize((uint64_t)v8);
        unint64_t v19 = &_os_log_disabled;
        if (v15 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)&_os_log_disabled))
        {
          id v20 = v8[1];
          id v21 = v8[3];
          *(_DWORD *)buf = 134218498;
          v114 = v20;
          v115 = 2048;
          v116 = v18;
          v117 = 2082;
          v118 = v21;
          _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)&_os_log_disabled,  OS_SIGNPOST_INTERVAL_BEGIN,  v11,  "Replayer-6-high",  "%llu. %{xcode:size-in-bytes}zu %{public}s",  buf,  0x20u);
        }

        unint64_t v22 = *v8;
        if (*v8 == 86)
        {
          GTMTLReplayController_restoreIOSurfaceData_length_forPlane((uint64_t)a1, (uint64_t)v8);
        }

        else if (v22 == 80)
        {
          GTMTLReplayController_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)a1,  (uint64_t)v8);
        }

        else if (v22 == 22)
        {
          GTMTLReplayController_restoreMTLBufferContents((uint64_t)a1, v8);
        }

        unint64_t v23 = g_signpostLog;
        unint64_t v24 = (os_log_s *)v23;
        if (v15 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v23))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl( &dword_0,  v24,  OS_SIGNPOST_INTERVAL_END,  v11,  "Replayer-6-high",  (const char *)&unk_3189BB,  buf,  2u);
        }

        v16 += v18;

        objc_autoreleasePoolPop(v17);
        v8 += 8;
        --v9;
      }

      while (v9);
    }

    id v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"RestoreResourcesFromArchive"));
    id v29 = v99;
    v84 = (void *)objc_claimAutoreleasedReturnValue([v99 commandBuffer]);
    [v84 setLabel:v83];

    [v99 commitCommandBufferWithLog:v110];
    v85 = g_signpostLog;
    id v86 = (os_log_s *)v85;
    if (v15 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v85))
    {
      *(_DWORD *)buf = 134217984;
      v114 = v16;
      _os_signpost_emit_with_name_impl( &dword_0,  v86,  OS_SIGNPOST_INTERVAL_END,  v11,  "Replayer-2-restore",  "%{xcode:size-in-bytes}zu",  buf,  0xCu);
    }

    [v110 leaveActivity];
LABEL_77:
    unint64_t v7 = v92;
  }
}

void sub_10AEB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)va1);
  std::pair<ShaderBinaryInfo * {__strong},std::string>::~pair((uint64_t)va);

  _Unwind_Resume(a1);
}

void std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::resize(uint64_t a1, unint64_t a2)
{
  id v3 = *(void **)a1;
  uint64_t v4 = *(void **)(a1 + 8);
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *(void *)a1) >> 3);
  unint64_t v6 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v4) >> 3) >= v6)
    {
      size_t v28 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(*(void **)(a1 + 8), v28);
      *(void *)(a1 + 8) = (char *)v4 + v28;
      return;
    }

    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (uint64_t)v3) >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x555555555555555LL) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v10);
    uint64_t v12 = &v11[24 * v5];
    id v14 = &v11[24 * v13];
    size_t v15 = 24 * ((24 * v6 - 24) / 0x18) + 24;
    bzero(v12, v15);
    float v16 = &v12[v15];
    uint64_t v18 = *(void **)a1;
    id v17 = *(void **)(a1 + 8);
    if (v17 == *(void **)a1)
    {
      *(void *)a1 = v12;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (!v17) {
        return;
      }
    }

    else
    {
      do
      {
        *((void *)v12 - 3) = 0LL;
        *((void *)v12 - 2) = 0LL;
        v12 -= 24;
        *((void *)v12 + 2) = 0LL;
        __int128 v19 = *(_OWORD *)(v17 - 3);
        v17 -= 3;
        *(_OWORD *)uint64_t v12 = v19;
        *((void *)v12 + 2) = v17[2];
        *id v17 = 0LL;
        v17[1] = 0LL;
        v17[2] = 0LL;
      }

      while (v17 != v18);
      id v20 = *(void **)a1;
      id v17 = *(void **)(a1 + 8);
      *(void *)a1 = v12;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (v17 != v20)
      {
        id v21 = v17;
        do
        {
          unint64_t v23 = (void *)*(v21 - 3);
          v21 -= 3;
          unint64_t v22 = v23;
          if (v23)
          {
            *(v17 - 2) = v22;
            operator delete(v22);
          }

          id v17 = v21;
        }

        while (v21 != v20);
        id v17 = v20;
      }

      if (!v17) {
        return;
      }
    }

    operator delete(v17);
    return;
  }

  if (a2 < v5)
  {
    unint64_t v24 = &v3[3 * a2];
    if (v4 != v24)
    {
      unint64_t v25 = *(void **)(a1 + 8);
      do
      {
        uint64_t v27 = (void *)*(v25 - 3);
        v25 -= 3;
        id v26 = v27;
        if (v27)
        {
          *(v4 - 2) = v26;
          operator delete(v26);
        }

        uint64_t v4 = v25;
      }

      while (v25 != v24);
    }

    *(void *)(a1 + 8) = v24;
  }

__n128 __Block_byref_object_copy__552(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__553(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

__n128 __Block_byref_object_copy__509(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__510(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__513(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__514(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void std::vector<ShaderProfilerUSCSampleInfo>::reserve(void **a1, unint64_t a2)
{
  if (0xCCCCCCCCCCCCCCCDLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0x666666666666667LL) {
      abort();
    }
    uint64_t v3 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 40;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(a2);
    unint64_t v5 = &v4[40 * v3];
    uint64_t v7 = &v4[40 * v6];
    uint64_t v9 = (char *)*a1;
    unint64_t v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        __int128 v11 = *(_OWORD *)(v8 - 40);
        __int128 v12 = *(_OWORD *)(v8 - 24);
        *((void *)v10 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v12;
        *(_OWORD *)(v10 - 40) = v11;
        v10 -= 40;
        v8 -= 40;
      }

      while (v8 != v9);
      unint64_t v8 = (char *)*a1;
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void sub_10B880( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>( unint64_t a1)
{
  if (a1 >= 0x666666666666667LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(40 * a1);
}

double std::__introsort<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *,false>( uint64_t a1, double *a2, uint64_t a3, char a4, double result)
{
LABEL_1:
  uint64_t v9 = (uint64_t)(a2 - 5);
  uint64_t v10 = (uint64_t)(a2 - 10);
  uint64_t v11 = (uint64_t)(a2 - 15);
  v191 = a2 - 4;
  unint64_t v193 = (unint64_t)a2;
  unint64_t i = a1;
  while (2)
  {
    a1 = i;
    uint64_t v13 = (uint64_t)a2 - i;
    uint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)a2 - i) >> 3);
    switch(v14)
    {
      case 0LL:
      case 1LL:
        return result;
      case 2LL:
        if (USCSampleComparator::operator()(v9, a1))
        {
          uint64_t v207 = *(void *)(a1 + 32);
          __int128 v197 = *(_OWORD *)a1;
          __int128 v202 = *(_OWORD *)(a1 + 16);
          __int128 v92 = *(_OWORD *)v9;
          __int128 v93 = *(_OWORD *)(v9 + 16);
          *(void *)(a1 + 32) = *(void *)(v9 + 32);
          *(_OWORD *)a1 = v92;
          *(_OWORD *)(a1 + 16) = v93;
          __n128 result = *(double *)&v197;
          *(void *)(v9 + 32) = v207;
          *(_OWORD *)uint64_t v9 = v197;
          *(_OWORD *)(v9 + 16) = v202;
        }

        return result;
      case 3LL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  v9);
        return result;
      case 4LL:
        *(void *)&__n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  a1 + 80,  v9).n128_u64[0];
        return result;
      case 5LL:
        *(void *)&__n128 result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  a1 + 80,  a1 + 120,  v9).n128_u64[0];
        return result;
      default:
        if (v13 > 959)
        {
          if (!a3)
          {
            if ((double *)a1 != a2)
            {
              int64_t v115 = (unint64_t)(v14 - 2) >> 1;
              int64_t v192 = v115;
              do
              {
                int64_t v116 = v115;
                if (v192 >= v115)
                {
                  uint64_t v117 = (2 * v115) | 1;
                  uint64_t v118 = a1 + 40 * v117;
                  if (2 * v115 + 2 < v14 && USCSampleComparator::operator()(a1 + 40 * v117, v118 + 40))
                  {
                    v118 += 40LL;
                    uint64_t v117 = 2 * v116 + 2;
                  }

                  uint64_t v119 = a1 + 40 * v116;
                  a2 = (double *)v193;
                  if (!USCSampleComparator::operator()(v118, v119))
                  {
                    uint64_t v120 = *(void *)v119;
                    unsigned int v121 = *(_DWORD *)(v119 + 12);
                    unsigned int v187 = *(_DWORD *)(v119 + 8);
                    uint64_t v184 = *(void *)(v119 + 16);
                    unint64_t v185 = *(void *)(v119 + 24);
                    uint64_t v122 = *(void *)(v119 + 32);
                    uint64_t v123 = *(void *)(v118 + 32);
                    __int128 v124 = *(_OWORD *)(v118 + 16);
                    *(_OWORD *)uint64_t v119 = *(_OWORD *)v118;
                    *(_OWORD *)(v119 + 16) = v124;
                    *(void *)(v119 + 32) = v123;
                    if (v192 >= v117)
                    {
                      unsigned int v188 = v122;
                      unsigned int v186 = v120;
                      uint64_t v189 = v120;
                      uint64_t v190 = v122;
                      while (1)
                      {
                        uint64_t v125 = v118;
                        uint64_t v126 = 2 * v117;
                        uint64_t v117 = (2 * v117) | 1;
                        uint64_t v118 = a1 + 40 * v117;
                        uint64_t v127 = v126 + 2;
                        if (v126 + 2 < v14)
                        {
                          BOOL v128 = USCSampleComparator::operator()(a1 + 40 * v117, v118 + 40);
                          uint64_t v120 = v189;
                          uint64_t v122 = v190;
                          if (v128)
                          {
                            v118 += 40LL;
                            uint64_t v117 = v127;
                          }
                        }

                        unsigned int v129 = *(_DWORD *)(v118 + 12);
                        BOOL v130 = v129 >= v121;
                        if (v129 == v121)
                        {
                          unsigned int v131 = *(_DWORD *)(v118 + 32);
                          BOOL v130 = v131 >= v188;
                          if (v131 == v188)
                          {
                            BOOL v130 = *(_DWORD *)v118 >= v186;
                            if (*(_DWORD *)v118 == v186)
                            {
                              unsigned int v132 = *(_DWORD *)(v118 + 8);
                              BOOL v130 = v132 >= v187;
                              if (v132 == v187) {
                                BOOL v130 = *(void *)(v118 + 24) >= v185;
                              }
                            }
                          }
                        }

                        if (!v130) {
                          break;
                        }
                        __int128 v133 = *(_OWORD *)v118;
                        __int128 v134 = *(_OWORD *)(v118 + 16);
                        *(void *)(v125 + 32) = *(void *)(v118 + 32);
                        *(_OWORD *)uint64_t v125 = v133;
                        *(_OWORD *)(v125 + 16) = v134;
                        if (v192 < v117) {
                          goto LABEL_177;
                        }
                      }

                      uint64_t v118 = v125;
                    }

__n128 __Block_byref_object_copy__560(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__561(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__563(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__564(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<InstructionPCInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__566(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__567(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<std::string,std::unordered_map<unsigned int,ClauseData>>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__569(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__570(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__572(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__573(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<std::string,BinaryInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

LABEL_227:
              v27 += 40;
              if (v27 == v38) {
                goto LABEL_228;
              }
            }

            unsigned int v40 = *(void *)(v36[3] + 48LL * v39 + 8LL * *((unsigned int *)v27 + 8));
            BOOL v41 = *v36;
            uint64_t v42 = *v36 + 88 * v40 + 24;
            unint64_t v43 = v323;
            __int128 v44 = std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( v42,  v323,  &v323);
            __int128 v45 = *((_DWORD *)v44 + 7) + *((_DWORD *)v27 + 2);
            ++*((_DWORD *)v44 + 6);
            *((_DWORD *)v44 + 7) = v45;
            unsigned int v46 = std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( v42,  v43,  &v323);
            BOOL v47 = v46;
            unsigned int v48 = ((*(void *)(*(void *)(*(void *)(*(void *)(v2 + 56) + 8LL) + 48LL)
                                            + 24LL * *(unsigned int *)(v2 + 212)
                                            + 8)
                                - *(void *)(*(void *)(*(void *)(*(void *)(v2 + 56) + 8LL) + 48LL)
                                            + 24LL * *(unsigned int *)(v2 + 212))) >> 5);
            unsigned int v50 = (char *)*((void *)v46 + 5);
            unsigned int v49 = *((void *)v46 + 6);
            if ((unint64_t)v50 >= v49)
            {
              __int128 v55 = (char *)*((void *)v46 + 4);
              BOOL v56 = (v50 - v55) >> 3;
              unsigned int v57 = v56 + 1;
              unsigned int v58 = v49 - (void)v55;
              if (v58 >> 2 > v57) {
                unsigned int v57 = v58 >> 2;
              }
              unint64_t v59 = (unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8LL;
              uint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
              if (!v59) {
                uint64_t v60 = v57;
              }
              if (v60)
              {
                uint64_t v60 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v60);
                __int128 v55 = (char *)*((void *)v47 + 4);
                unsigned int v50 = (char *)*((void *)v47 + 5);
              }

              else
              {
                uint64_t v61 = 0LL;
              }

              unsigned int v62 = (void *)(v60 + 8 * v56);
              void *v62 = v48;
              BOOL v51 = v62 + 1;
              while (v50 != v55)
              {
                unsigned int v63 = *((void *)v50 - 1);
                v50 -= 8;
                *--unsigned int v62 = v63;
              }

              *((void *)v47 + 4) = v62;
              *((void *)v47 + 5) = v51;
              *((void *)v47 + 6) = v60 + 8 * v61;
              if (v55) {
                operator delete(v55);
              }
            }

            else
            {
              *(void *)unsigned int v50 = v48;
              BOOL v51 = v50 + 8;
            }

            *((void *)v47 + 5) = v51;
            unsigned int v64 = **TargetClauseAnalysis
                + 88LL * *(void *)((*TargetClauseAnalysis)[3] + 48LL * v39 + 8LL * *((unsigned int *)v27 + 8));
            unsigned int v66 = *(_BYTE **)(v64 + 64);
            BOOL v65 = *(_BYTE **)(v64 + 72);
            unsigned int v67 = v65 - v66;
            BOOL v68 = (v65 - v66) >> 4;
            v302 = v41;
            if (v65 == v66)
            {
              v313 = 0LL;
              __int128 v54 = 0;
              unsigned int v53 = 16 * v68;
            }

            else
            {
              if ((v67 & 0x8000000000000000LL) != 0) {
                abort();
              }
              unsigned int v69 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>((v65 - v66) >> 4);
              memmove(v69, v66, v67);
              unsigned int v70 = 0LL;
              __int128 v54 = 0;
              unsigned int v53 = (uint64_t)&v69[16 * v68];
              do
              {
                v54 += *(_DWORD *)&v69[v70 + 4];
                v70 += 16LL;
              }

              while (16 * v68 != v70);
              v313 = (unsigned int *)v69;
            }

            if (![*(id *)(v2 + 32) dumpInstructions])
            {
LABEL_172:
              if ([*(id *)(v2 + 32) dumpInstructions])
              {
                uint64_t v119 = v323;
                uint64_t v120 = *(void *)(*(void *)(*(void *)(*(void *)(v2 + 72) + 8LL) + 48LL)
                                 + 24LL * *(unsigned int *)(v2 + 212));
                *(_DWORD *)(v120 + 8LL * v323) += *((_DWORD *)v27 + 2);
                *(_DWORD *)(*(void *)(*(void *)(*(void *)(*(void *)(v2 + 72) + 8LL) + 48LL)
                                      + 24LL * *(unsigned int *)(v2 + 212))
                          + 8 * v119
                          + 4) = v119;
              }

              v304 = [*(id *)(v2 + 32) _computeSampleNormFactorForSample:v27 forProgramStartAddress:*(void *)(*(void *)v309 + 8) forProgramEndAddress:*(void *)(*(void *)v309 + 16)];
              uint64_t v123 = v121 + 1;
              uint64_t v122 = v121[1];
              uint64_t v125 = v121 + 2;
              __int128 v124 = (unint64_t)v121[2];
              if ((unint64_t)v122 < v124)
              {
                *(void *)uint64_t v122 = v311;
                *((void *)v122 + 1) = 0LL;
                *((void *)v122 + 2) = 0LL;
                *((void *)v122 + 3) = 0LL;
                uint64_t v126 = v122 + 32;
                *uint64_t v123 = v122 + 32;
LABEL_197:
                *uint64_t v123 = v126;
                uint64_t v139 = *(void *)(*(void *)(*(void *)(*(void *)(v2 + 56) + 8LL) + 48LL)
                uint64_t v140 = v53 - (void)v313;
                uint64_t v141 = *(void *)(v139 - 24);
                if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v139 - 8) - v141) >> 2) < (v53 - (uint64_t)v313) >> 4)
                {
                  if (v140 < 0) {
                    abort();
                  }
                  uint64_t v142 = *(void *)(v139 - 16);
                  uint64_t v143 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<DYMTLShaderProfilerProcessedUSCSample>>(v140 >> 4);
                  v146 = *(char **)(v139 - 24);
                  __int128 v145 = *(char **)(v139 - 16);
                  __int128 v147 = &v143[20 * ((v142 - v141) / 20)];
                  if (v145 != v146)
                  {
                    do
                    {
                      __int128 v148 = *(_OWORD *)(v145 - 20);
                      *((_DWORD *)v147 - 1) = *((_DWORD *)v145 - 1);
                      *(_OWORD *)(v147 - 20) = v148;
                      v147 -= 20;
                      v145 -= 20;
                    }

                    while (v145 != v146);
                    __int128 v145 = *(char **)(v139 - 24);
                  }

                  *(void *)(v139 - 24) = v147;
                  *(void *)(v139 - 16) = &v143[20 * ((v142 - v141) / 20)];
                  *(void *)(v139 - 8) = &v143[20 * v144];
                  if (v145) {
                    operator delete(v145);
                  }
                }

                if (v313 != (unsigned int *)v53)
                {
                  v149 = v54 * v304;
                  uint64_t v150 = v323;
                  unint64_t v151 = v313;
                  do
                  {
                    unint64_t v152 = v151[1] * *((_DWORD *)v27 + 2);
                    if (v152)
                    {
                      uint64_t v153 = *v151;
                      uint64_t v154 = *(unsigned int **)(v139 - 16);
                      unsigned int v155 = *(void *)(v139 - 8);
                      if ((unint64_t)v154 >= v155)
                      {
                        unint64_t v157 = *(void *)(v139 - 24);
                        uint64_t v158 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v154 - v157) >> 2);
                        uint64_t v159 = v158 + 1;
                        if (v158 + 1 > 0xCCCCCCCCCCCCCCCLL) {
                          abort();
                        }
                        __int128 v160 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v155 - v157) >> 2);
                        if (2 * v160 > v159) {
                          uint64_t v159 = 2 * v160;
                        }
                        if (v160 >= 0x666666666666666LL) {
                          uint64_t v161 = 0xCCCCCCCCCCCCCCCLL;
                        }
                        else {
                          uint64_t v161 = v159;
                        }
                        if (v161) {
                          uint64_t v161 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<DYMTLShaderProfilerProcessedUSCSample>>(v161);
                        }
                        else {
                          unint64_t v162 = 0LL;
                        }
                        unsigned int v163 = (unsigned int *)(v161 + 20 * v158);
                        *unsigned int v163 = v150;
                        v163[1] = v152;
                        v163[2] = v153;
                        v163[3] = v152;
                        v163[4] = v149;
                        unsigned int v165 = *(char **)(v139 - 24);
                        BOOL v164 = *(char **)(v139 - 16);
                        unsigned int v166 = v163;
                        if (v164 != v165)
                        {
                          do
                          {
                            __int128 v167 = *(_OWORD *)(v164 - 20);
                            *(v166 - 1) = *((_DWORD *)v164 - 1);
                            *(_OWORD *)(v166 - 5) = v167;
                            v166 -= 5;
                            v164 -= 20;
                          }

                          while (v164 != v165);
                          BOOL v164 = *(char **)(v139 - 24);
                        }

                        unsigned int v156 = v163 + 5;
                        *(void *)(v139 - 24) = v166;
                        *(void *)(v139 - 16) = v163 + 5;
                        *(void *)(v139 - 8) = v161 + 20 * v162;
                        if (v164) {
                          operator delete(v164);
                        }
                      }

                      else
                      {
                        *uint64_t v154 = v150;
                        v154[1] = v152;
                        v154[2] = v153;
                        v154[3] = v152;
                        unsigned int v156 = v154 + 5;
                        v154[4] = v149;
                      }

                      *(void *)(v139 - 16) = v156;
                    }

                    v151 += 4;
                  }

                  while (v151 != (unsigned int *)v53);
                }

                uint64_t v2 = a1;
                BOOL v38 = v307;
                if (v313) {
                  operator delete(v313);
                }
                goto LABEL_227;
              }

              uint64_t v127 = (v122 - *v121) >> 5;
              BOOL v128 = v124 - (void)*v121;
              unsigned int v129 = v128 >> 4;
              else {
                BOOL v130 = v129;
              }
              if (v130)
              {
                if (v130 >> 59) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                unsigned int v131 = (char *)operator new(32 * v130);
              }

              else
              {
                unsigned int v131 = 0LL;
              }

              unsigned int v132 = &v131[32 * v127];
              __int128 v133 = &v131[32 * v130];
              *(void *)unsigned int v132 = v311;
              *((void *)v132 + 1) = 0LL;
              *((void *)v132 + 2) = 0LL;
              *((void *)v132 + 3) = 0LL;
              uint64_t v126 = v132 + 32;
              __int128 v134 = *v123;
              int64_t v135 = *v121;
              if (*v123 == *v121)
              {
                *unsigned int v121 = v132;
                *uint64_t v123 = v126;
                *uint64_t v125 = v133;
              }

              else
              {
                v136 = v133;
                do
                {
                  uint64_t v137 = *((void *)v134 - 4);
                  v134 -= 32;
                  *(void *)__int128 v134 = 0LL;
                  *((void *)v132 - 4) = v137;
                  v132 -= 32;
                  *((void *)v132 + 2) = 0LL;
                  *((void *)v132 + 3) = 0LL;
                  *((void *)v132 + 1) = 0LL;
                  *(_OWORD *)(v132 + 8) = *(_OWORD *)(v134 + 8);
                  *((void *)v132 + 3) = *((void *)v134 + 3);
                  *((void *)v134 + 1) = 0LL;
                  *((void *)v134 + 2) = 0LL;
                  *((void *)v134 + 3) = 0LL;
                }

                while (v134 != v135);
                uint64_t v138 = *v121;
                __int128 v134 = *v123;
                *unsigned int v121 = v132;
                *uint64_t v123 = v126;
                *uint64_t v125 = v136;
                if (v134 != v138)
                {
                  uint64_t v2 = a1;
                  do
                  {
                    v134 -= 32;
                    std::allocator<InstructionPCInfo>::destroy[abi:nn180100]((uint64_t)v134);
                  }

                  while (v134 != v138);
                  __int128 v134 = v138;
LABEL_195:
                  if (v134) {
                    operator delete(v134);
                  }
                  goto LABEL_197;
                }
              }

              uint64_t v2 = a1;
              goto LABEL_195;
            }

            v291 = v40;
            unsigned int v71 = *(void *)(*(void *)(*(void *)(v2 + 64) + 8LL) + 48LL) + 40LL * *(unsigned int *)(v2 + 212);
            BOOL v72 = (char *)std::unordered_map<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::find[abi:nn180100]( (void *)v71,  v298);
            if (!v72)
            {
              v316 = 0u;
              v317 = 0u;
              v318 = 1065353216;
              if (*((char *)v294 + 31) < 0)
              {
                std::string::__init_copy_ctor_external( &v319,  (const std::string::value_type *)v294[1],  (std::string::size_type)v294[2]);
                unint64_t v75 = *((void *)&v316 + 1);
                __int128 v76 = v316;
                unsigned int v73 = *((void *)&v317 + 1);
                unsigned int v74 = v317;
                unsigned int v78 = v318;
              }

              else
              {
                unsigned int v73 = 0LL;
                unsigned int v74 = 0LL;
                unint64_t v75 = 0LL;
                __int128 v76 = 0LL;
                BOOL v77 = *(_OWORD *)v298;
                v319.__r_.__value_.__l.__cap_ = *(void *)(v298 + 16);
                *(_OWORD *)&v319.__r_.__value_.__l.__data_ = v77;
                unsigned int v78 = 1065353216;
              }

              v316 = 0uLL;
              v320[0] = v76;
              v320[1] = v75;
              v321[0] = v74;
              v321[1] = v73;
              v322 = v78;
              if (v73)
              {
                unsigned int v79 = *(void *)(v74 + 8);
                if ((v75 & (v75 - 1)) != 0)
                {
                  if (v79 >= v75) {
                    v79 %= v75;
                  }
                }

                else
                {
                  v79 &= v75 - 1;
                }

                *(void *)(v76 + 8 * v79) = v321;
                v317 = 0uLL;
              }

              if ((v319.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                __int128 v80 = &v319;
              }
              else {
                __int128 v80 = (std::string *)v319.__r_.__value_.__r.__words[0];
              }
              if ((v319.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                size = v319.__r_.__value_.__s.__size_;
              }
              else {
                size = v319.__r_.__value_.__l.__size_;
              }
              unsigned int v82 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v80, size);
              BOOL v83 = v82;
              unsigned int v84 = *(void *)(v71 + 8);
              if (v84)
              {
                unsigned int v85 = (uint8x8_t)vcnt_s8((int8x8_t)v84);
                v85.i16[0] = vaddlv_u8(v85);
                unsigned int v86 = v85.u32[0];
                if (v85.u32[0] > 1uLL)
                {
                  BOOL v87 = v82;
                  if (v82 >= v84) {
                    BOOL v87 = v82 % v84;
                  }
                }

                else
                {
                  BOOL v87 = (v84 - 1) & v82;
                }

                v296 = v87;
                unsigned int v88 = *(void ***)(*(void *)v71 + 8 * v87);
                if (v88)
                {
                  BOOL v72 = (char *)*v88;
                  if (*v88)
                  {
                    do
                    {
                      unsigned int v89 = *((void *)v72 + 1);
                      if (v89 == v83)
                      {
                        if (std::equal_to<std::string>::operator()[abi:nn180100]( (unsigned __int8 *)v72 + 16,  (unsigned __int8 *)&v319))
                        {
                          goto LABEL_128;
                        }
                      }

                      else
                      {
                        if (v86 > 1)
                        {
                          if (v89 >= v84) {
                            v89 %= v84;
                          }
                        }

                        else
                        {
                          v89 &= v84 - 1;
                        }

                        if (v89 != v296) {
                          break;
                        }
                      }

                      BOOL v72 = *(char **)v72;
                    }

                    while (v72);
                  }
                }
              }

              BOOL v72 = (char *)operator new(0x50uLL);
              v326[0] = v72;
              v326[1] = v71 + 16;
              *(void *)BOOL v72 = 0LL;
              *((void *)v72 + 1) = v83;
              *(std::string *)(v72 + 16) = v319;
              memset(&v319, 0, sizeof(v319));
              std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table( (uint64_t)(v72 + 40),  v320);
              v327 = 1;
              __int128 v90 = (float)(unint64_t)(*(void *)(v71 + 24) + 1LL);
              __int128 v91 = *(float *)(v71 + 32);
              if (!v84 || (float)(v91 * (float)v84) < v90)
              {
                __int128 v92 = (v84 & (v84 - 1)) != 0;
                if (v84 < 3) {
                  __int128 v92 = 1LL;
                }
                __int128 v93 = v92 | (2 * v84);
                uint64_t v94 = vcvtps_u32_f32(v90 / v91);
                if (v93 <= v94) {
                  id v95 = v94;
                }
                else {
                  id v95 = v93;
                }
                std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v71,  v95);
                unsigned int v84 = *(void *)(v71 + 8);
                if ((v84 & (v84 - 1)) == 0)
                {
                  BOOL v96 = (v84 - 1) & v83;
                  goto LABEL_117;
                }

                if (v83 >= v84)
                {
                  BOOL v96 = v83 % v84;
LABEL_117:
                  v296 = v96;
                }

                else
                {
                  v296 = v83;
                }
              }

              uint64_t v97 = *(void **)(*(void *)v71 + 8 * v296);
              if (v97)
              {
                *(void *)BOOL v72 = *v97;
                goto LABEL_126;
              }

              *(void *)BOOL v72 = *(void *)(v71 + 16);
              *(void *)(v71 + 16) = v72;
              *(void *)(*(void *)v71 + 8 * v296) = v71 + 16;
              if (*(void *)v72)
              {
                uint64_t v98 = *(void *)(*(void *)v72 + 8LL);
                if ((v84 & (v84 - 1)) != 0)
                {
                  if (v98 >= v84) {
                    v98 %= v84;
                  }
                }

                else
                {
                  v98 &= v84 - 1;
                }

                uint64_t v97 = (void *)(*(void *)v71 + 8 * v98);
LABEL_126:
                *uint64_t v97 = v72;
              }

              v326[0] = 0LL;
              ++*(void *)(v71 + 24);
              std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,void *>>>>::reset[abi:nn180100]((uint64_t)v326);
LABEL_128:
              std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v320);
              uint64_t v2 = a1;
              std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v316);
            }

            uint64_t v99 = (unint64_t)(v72 + 40);
            uint64_t v100 = *v313;
            unsigned int v101 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)v72 + 5,  *v313);
            if (v101)
            {
              unsigned int v102 = *((_DWORD *)v101 + 7);
              ++*((_DWORD *)v101 + 6);
              *((_DWORD *)v101 + 7) = v102 + *((_DWORD *)v27 + 2);
              *((_DWORD *)v101 + 11) += *((_DWORD *)v27 + 9);
              goto LABEL_172;
            }

            v296 = (uint64_t)(v72 + 40);
            v286 = *(_DWORD *)(v302 + 88 * v291 + 8);
            v303 = *((_DWORD *)v27 + 2);
            unint64_t v103 = *((void *)v72 + 6);
            if (v103)
            {
              uint64_t v104 = (uint8x8_t)vcnt_s8((int8x8_t)v103);
              v104.i16[0] = vaddlv_u8(v104);
              if (v104.u32[0] > 1uLL)
              {
                __int128 v105 = v100;
                if (v103 <= v100) {
                  __int128 v105 = v100 % v103;
                }
              }

              else
              {
                __int128 v105 = ((_DWORD)v103 - 1) & v100;
              }

              uint64_t v99 = v105;
              uint64_t v106 = *(uint64_t ***)(*(void *)v296 + 8 * v105);
              if (v106)
              {
                for (j = *v106; j; j = (uint64_t *)*j)
                {
                  uint64_t v108 = j[1];
                  if (v108 == v100)
                  {
                    if (*((_DWORD *)j + 4) == (_DWORD)v100) {
                      goto LABEL_171;
                    }
                  }

                  else
                  {
                    if (v104.u32[0] > 1uLL)
                    {
                      if (v108 >= v103) {
                        v108 %= v103;
                      }
                    }

                    else
                    {
                      v108 &= v103 - 1;
                    }

                    if (v108 != v105) {
                      break;
                    }
                  }
                }
              }
            }

            v109 = operator new(0x30uLL);
            _DWORD *v109 = 0LL;
            v109[1] = v100;
            *((_DWORD *)v109 + 4) = v100;
            *((_DWORD *)v109 + 5) = v100;
            *((_DWORD *)v109 + 6) = 1;
            *((_DWORD *)v109 + 7) = v303;
            *((_DWORD *)v109 + 8) = v67 >> 4;
            *((_DWORD *)v109 + 9) = v286;
            *((_DWORD *)v109 + 10) = v292;
            *((_DWORD *)v109 + 11) = v303 == 0;
            unsigned int v110 = (float)(unint64_t)(*((void *)v72 + 8) + 1LL);
            BOOL v111 = *((float *)v72 + 18);
            if (!v103 || (float)(v111 * (float)v103) < v110)
            {
              unsigned int v112 = (v103 & (v103 - 1)) != 0;
              if (v103 < 3) {
                unsigned int v112 = 1LL;
              }
              unsigned int v113 = v112 | (2 * v103);
              __int128 v114 = vcvtps_u32_f32(v110 / v111);
              if (v113 <= v114) {
                int64_t v115 = v114;
              }
              else {
                int64_t v115 = v113;
              }
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v296,  v115);
              unint64_t v103 = *((void *)v72 + 6);
              if ((v103 & (v103 - 1)) != 0)
              {
                if (v103 <= v100) {
                  uint64_t v99 = v100 % v103;
                }
                else {
                  uint64_t v99 = v100;
                }
              }

              else
              {
                uint64_t v99 = ((_DWORD)v103 - 1) & v100;
              }
            }

            int64_t v116 = *(void *)v296;
            uint64_t v117 = *(void **)(*(void *)v296 + 8 * v99);
            if (v117)
            {
              _DWORD *v109 = *v117;
            }

            else
            {
              _DWORD *v109 = *((void *)v72 + 7);
              *((void *)v72 + 7) = v109;
              *(void *)(v116 + 8 * v99) = v72 + 56;
              if (!*v109) {
                goto LABEL_170;
              }
              uint64_t v118 = *(void *)(*v109 + 8LL);
              if ((v103 & (v103 - 1)) != 0)
              {
                if (v118 >= v103) {
                  v118 %= v103;
                }
              }

              else
              {
                v118 &= v103 - 1;
              }

              uint64_t v117 = (void *)(*(void *)v296 + 8 * v118);
            }

            *uint64_t v117 = v109;
LABEL_170:
            ++*((void *)v72 + 8);
LABEL_171:
            uint64_t v2 = a1;
            goto LABEL_172;
          }
        }
      }

          __int128 v19 = (char *)v121;
          goto LABEL_228;
        }

LABEL_228:
      uint64_t v1 = v309 + 8;
    }

    while (v309 + 8 != v288);
    uint64_t v3 = *(unsigned int *)(v2 + 204);
LABEL_230:
    uint64_t v4 = v285 + 1;
  }

  while (v285 + 1 < v3);
LABEL_231:
  if (!*(_BYTE *)(*(void *)(v2 + 32) + 8LL))
  {
    BOOL v169 = *(uint64_t **)(*(void *)(*(void *)(*(void *)(v2 + 48) + 8LL) + 48LL)
    if (v169)
    {
      while (1)
      {
        v314 = (GPUToolsPlatformLLVMShaderProfilerHelperImpl **)v169[5];
        v170 = (TargetClauseAnalysis **)GPUToolsPlatformLLVMShaderProfilerHelperImpl::GetTargetClauseAnalysis(*v314);
        TargetBlocks = (uint64_t *)TargetClauseAnalysis::GetTargetBlocks(*v170);
        v290 = (uint64_t **)v169;
        unint64_t v174 = (uint64_t *)v169[2];
        uint64_t v173 = (__int128 *)(v169 + 2);
        unsigned int v172 = v174;
        v299 = v170;
        uint64_t v175 = *v170;
        unsigned int v176 = *(void *)(*(void *)(*(void *)(v2 + 80) + 8LL) + 48LL) + 40LL * *(unsigned int *)(v2 + 212);
        uint64_t v177 = *((char *)v173 + 23);
        if (v177 >= 0) {
          __int128 v178 = (uint64_t *)v173;
        }
        else {
          __int128 v178 = v172;
        }
        if (v177 >= 0) {
          unsigned int v179 = *((unsigned __int8 *)v173 + 23);
        }
        else {
          unsigned int v179 = *((void *)v173 + 1);
        }
        BOOL v180 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v178, v179);
        unsigned int v181 = v180;
        unsigned int v182 = *(void *)(v176 + 8);
        if (v182)
        {
          unsigned int v183 = (uint8x8_t)vcnt_s8((int8x8_t)v182);
          v183.i16[0] = vaddlv_u8(v183);
          uint64_t v184 = v183.u32[0];
          if (v183.u32[0] > 1uLL)
          {
            uint64_t v1 = v180;
            if (v180 >= v182) {
              uint64_t v1 = v180 % v182;
            }
          }

          else
          {
            uint64_t v1 = (v182 - 1) & v180;
          }

          unint64_t v185 = *(uint64_t ***)(*(void *)v176 + 8 * v1);
          if (v185)
          {
            unsigned int v186 = *v185;
            if (*v185)
            {
              while (1)
              {
                unsigned int v187 = v186[1];
                if (v187 == v181)
                {
                  if (std::equal_to<std::string>::operator()[abi:nn180100]( (unsigned __int8 *)v186 + 16,  (unsigned __int8 *)v173))
                  {
                    v295 = v186;
                    uint64_t v2 = a1;
                    goto LABEL_282;
                  }
                }

                else
                {
                  if (v184 > 1)
                  {
                    if (v187 >= v182) {
                      v187 %= v182;
                    }
                  }

                  else
                  {
                    v187 &= v182 - 1;
                  }

                  if (v187 != v1)
                  {
LABEL_256:
                    uint64_t v2 = a1;
                    break;
                  }
                }

                unsigned int v186 = (uint64_t *)*v186;
                if (!v186) {
                  goto LABEL_256;
                }
              }
            }
          }
        }

        unsigned int v188 = operator new(0x58uLL);
        v319.__r_.__value_.__r.__words[0] = (std::string::size_type)v188;
        v319.__r_.__value_.__l.__size_ = v176 + 16;
        v319.__r_.__value_.__s.__data_[16] = 0;
        *unsigned int v188 = 0LL;
        v188[1] = v181;
        v295 = v188;
        uint64_t v189 = (std::string *)(v188 + 2);
        if (*((char *)v290 + 39) < 0)
        {
          std::string::__init_copy_ctor_external( v189,  (const std::string::value_type *)v290[2],  (std::string::size_type)v290[3]);
        }

        else
        {
          uint64_t v190 = *v173;
          v189->__r_.__value_.__l.__cap_ = *((void *)v173 + 2);
          *(_OWORD *)&v189->__r_.__value_.__l.__data_ = v190;
        }

        v191 = v295;
        *(_OWORD *)(v295 + 9) = 0u;
        *(_OWORD *)(v295 + 7) = 0u;
        *(_OWORD *)(v295 + 5) = 0u;
        v319.__r_.__value_.__s.__data_[16] = 1;
        int64_t v192 = (float)(unint64_t)(*(void *)(v176 + 24) + 1LL);
        unint64_t v193 = *(float *)(v176 + 32);
        if (!v182 || (float)(v193 * (float)v182) < v192)
        {
          __int128 v194 = (v182 & (v182 - 1)) != 0;
          if (v182 < 3) {
            __int128 v194 = 1LL;
          }
          __int128 v195 = v194 | (2 * v182);
          __int128 v196 = vcvtps_u32_f32(v192 / v193);
          if (v195 <= v196) {
            __int128 v197 = v196;
          }
          else {
            __int128 v197 = v195;
          }
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v176,  v197);
          unsigned int v182 = *(void *)(v176 + 8);
          v191 = v295;
          if ((v182 & (v182 - 1)) != 0)
          {
            if (v181 >= v182) {
              uint64_t v1 = v181 % v182;
            }
            else {
              uint64_t v1 = v181;
            }
          }

          else
          {
            uint64_t v1 = (v182 - 1) & v181;
          }
        }

        __int128 v198 = *(void **)(*(void *)v176 + 8 * v1);
        if (v198) {
          break;
        }
        double *v191 = *(void *)(v176 + 16);
        *(void *)(v176 + 16) = v191;
        *(void *)(*(void *)v176 + 8 * v1) = v176 + 16;
        if (*v191)
        {
          __int128 v199 = *(void *)(*v191 + 8LL);
          if ((v182 & (v182 - 1)) != 0)
          {
            if (v199 >= v182) {
              v199 %= v182;
            }
          }

          else
          {
            v199 &= v182 - 1;
          }

          __int128 v198 = (void *)(*(void *)v176 + 8 * v199);
          goto LABEL_280;
        }

LABEL_281:
        v319.__r_.__value_.__r.__words[0] = 0LL;
        ++*(void *)(v176 + 24);
        std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BinaryInfo>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BinaryInfo>,void *>>>>::reset[abi:nn180100]((uint64_t)&v319);
LABEL_282:
        v295[10] = v314;
        __int128 v200 = TargetBlocks[1] - *TargetBlocks;
        __int128 v201 = v200 >> 7;
        __int128 v202 = v295[7];
        __int128 v203 = v295[8];
        uint64_t v204 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v203 - v202) >> 3);
        uint64_t v1 = (v200 >> 7) - v204;
        if (v200 >> 7 <= v204)
        {
          if (v200 >> 7 < v204)
          {
            v221 = v202 + 56 * v201;
            if (v203 != v221)
            {
              uint64_t v1 = v295[8];
              do
              {
                v223 = *(void **)(v1 - 56);
                v1 -= 56LL;
                v222 = v223;
                if (v223)
                {
                  *(void *)(v203 - 48) = v222;
                  operator delete(v222);
                }

                __int128 v203 = v1;
              }

              while (v1 != v221);
            }

            v295[8] = v221;
          }

          goto LABEL_311;
        }

        uint64_t v205 = v295[9];
        if (0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v205 - v203) >> 3) >= v1)
        {
          bzero((void *)v295[8], 56 * ((56 * v1 - 56) / 0x38) + 56);
          v295[8] = v203 + 56 * ((56 * v1 - 56) / 0x38) + 56;
        }

        else
        {
          if (v200 < 0) {
            abort();
          }
          uint64_t v206 = 0x6DB6DB6DB6DB6DB7LL * ((v205 - v202) >> 3);
          if (2 * v206 > v201) {
            __int128 v201 = 2 * v206;
          }
          if (v206 >= 0x249249249249249LL) {
            __int128 v201 = 0x492492492492492LL;
          }
          if (v201 > 0x492492492492492LL) {
LABEL_376:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          uint64_t v207 = 56 * v201;
          uint64_t v208 = (char *)operator new(56 * v201);
          v209 = &v208[56 * v204];
          v210 = &v208[v207];
          bzero(v209, 56 * ((56 * v1 - 56) / 0x38) + 56);
          v211 = &v209[56 * ((56 * v1 - 56) / 0x38) + 56];
          v213 = (char *)v295[7];
          v212 = (char *)v295[8];
          if (v212 != v213)
          {
            v214 = 0LL;
            do
            {
              v215 = &v209[v214];
              v216 = &v212[v214];
              *((void *)v215 - 7) = 0LL;
              *((void *)v215 - 6) = 0LL;
              *((void *)v215 - 5) = 0LL;
              *(_OWORD *)(v215 - 56) = *(_OWORD *)&v212[v214 - 56];
              *((void *)v215 - 5) = *(void *)&v212[v214 - 40];
              *((void *)v216 - 7) = 0LL;
              *((void *)v216 - 6) = 0LL;
              *((void *)v216 - 5) = 0LL;
              v217 = *(_OWORD *)&v212[v214 - 16];
              *((_OWORD *)v215 - 2) = *(_OWORD *)&v212[v214 - 32];
              *((_OWORD *)v215 - 1) = v217;
              v214 -= 56LL;
            }

            while (&v212[v214] != v213);
            uint64_t v1 = v295[7];
            v212 = (char *)v295[8];
            v295[7] = &v209[v214];
            v295[8] = v211;
            v295[9] = v210;
            if (v212 != (char *)v1)
            {
              v218 = v212;
              do
              {
                v220 = (void *)*((void *)v218 - 7);
                v218 -= 56;
                v219 = v220;
                if (v220)
                {
                  *((void *)v212 - 6) = v219;
                  operator delete(v219);
                }

                v212 = v218;
              }

              while (v218 != (char *)v1);
              v212 = (char *)v1;
            }

            if (!v212) {
              goto LABEL_311;
            }
LABEL_310:
            operator delete(v212);
            goto LABEL_311;
          }

          v295[7] = v209;
          v295[8] = v211;
          v295[9] = v210;
          if (v212) {
            goto LABEL_310;
          }
        }

LABEL_311:
        v224 = *TargetBlocks;
        v293 = TargetBlocks[1];
        if (*TargetBlocks != v293)
        {
          v225 = 0;
          do
          {
            v226 = v225;
            v227 = v295[7];
            v228 = (char **)(v227 + 56LL * v225);
            v310 = v228;
            if (objc_msgSend(*(id *)(v2 + 32), "dumpInstructions", v285))
            {
              v229 = *(_DWORD *)(v224 + 80);
              v230 = v227 + 56LL * v226;
              *(_DWORD *)(v230 + 24) = v229;
              uint64_t v1 = v230 + 24;
              v231 = *(_DWORD *)(v224 + 84);
              *(_DWORD *)(v1 + 4) = v231;
              v232 = (v231 - v229 + 1);
              v234 = *v228;
              v233 = v228[1];
              v235 = 0xAAAAAAAAAAAAAAABLL * ((v233 - *v228) >> 3);
              v236 = v232 - v235;
              if (v232 <= v235)
              {
                if (v232 < v235) {
                  v228[1] = &v234[24 * v232];
                }
              }

              else
              {
                v237 = v228[2];
                if (0xAAAAAAAAAAAAAAABLL * ((v237 - v233) >> 3) >= v236)
                {
                  v249 = &v233[24 * v236];
                  do
                  {
                    *(void *)v233 = 0LL;
                    *(_OWORD *)(v233 + 8) = xmmword_3183D0;
                    v233 += 24;
                  }

                  while (v233 != v249);
                  v228[1] = v249;
                }

                else
                {
                  v238 = 0xAAAAAAAAAAAAAAABLL * ((v237 - v234) >> 3);
                  v239 = 2 * v238;
                  if (2 * v238 <= v232) {
                    v239 = v232;
                  }
                  if (v238 >= 0x555555555555555LL) {
                    v240 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    v240 = v239;
                  }
                  if (v240 > 0xAAAAAAAAAAAAAAALL) {
                    goto LABEL_376;
                  }
                  v241 = (char *)operator new(24 * v240);
                  v242 = &v241[24 * v235];
                  v243 = &v241[24 * v232];
                  v244 = v242;
                  do
                  {
                    *(void *)v244 = 0LL;
                    *(_OWORD *)(v244 + 8) = xmmword_3183D0;
                    v244 += 24;
                  }

                  while (v244 != v243);
                  v246 = *v310;
                  v245 = v310[1];
                  if (v245 == *v310)
                  {
                    v248 = v310;
                  }

                  else
                  {
                    do
                    {
                      v247 = *(_OWORD *)(v245 - 24);
                      *((void *)v242 - 1) = *((void *)v245 - 1);
                      *(_OWORD *)(v242 - 24) = v247;
                      v242 -= 24;
                      v245 -= 24;
                    }

                    while (v245 != v246);
                    v248 = v310;
                    v245 = *v310;
                  }

                  *v248 = v242;
                  v248[1] = v243;
                  v248[2] = &v241[24 * v240];
                  v228 = v248;
                  if (v245) {
                    operator delete(v245);
                  }
                }
              }

              v250 = *(void **)(v224 + 56);
              if (v250)
              {
                v251 = *(_DWORD *)v1;
                v252 = *(_DWORD *)(v1 + 4);
                do
                {
                  if (v251 <= v252)
                  {
                    v253 = (int *)v250[3];
                    v254 = *v228;
                    v255 = v251;
                    do
                    {
                      v256 = *v253++;
                      *(_DWORD *)v254 += v256;
                      v254 += 24;
                      ++v255;
                    }

                    while (v255 <= v252);
                  }

                  v250 = (void *)*v250;
                }

                while (v250);
              }

              v257 = (int *)v228[1];
              if (*v228 == (char *)v257)
              {
                v258 = 0;
              }

              else
              {
                v258 = 0;
                v259 = (int *)*v228;
                do
                {
                  v260 = *v259;
                  v259 += 6;
                  v258 += v260;
                }

                while (v259 != v257);
              }

              *(_DWORD *)(v227 + 56LL * v226 + 32) = v258 / (0xAAAAAAAAAAAAAAABLL * (((char *)v257 - *v228) >> 3));
            }

            v297 = v226;
            v261 = *(void *)(v224 + 16);
            if (v261)
            {
              do
              {
                v301 = (uint64_t *)v261;
                v262 = *(void *)*v299
                     + 88LL * *(void *)(*((void *)*v299 + 3) + 48LL * *(unsigned int *)(v261 + 16));
                v263 = *(void *)(v262 + 40);
                if (v263)
                {
                  v305 = v262 + 24;
                  do
                  {
                    v308 = (uint64_t *)v263;
                    LODWORD(v319.__r_.__value_.__l.__data_) = *(_DWORD *)(v263 + 16);
                    data = v319.__r_.__value_.__l.__data_;
                    v265 = std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( v305,  v319.__r_.__value_.__l.__data_,  &v319);
                    v266 = (unint64_t *)*((void *)v265 + 4);
                    for (k = (unint64_t *)*((void *)v265 + 5); v266 != k; uint64_t v2 = a1)
                    {
                      v267 = *v266;
                      v268 = *(void *)(*(void *)(*(void *)(*(void *)(v2 + 56) + 8LL) + 48LL)
                      v269 = *(_DWORD **)(v268 + 8);
                      uint64_t v1 = *(void *)(v268 + 16);
                      while (v269 != (_DWORD *)v1)
                      {
                        v270 = v269[2];
                        v271 = *((void *)v175 + 17);
                        if (v270 < (*((void *)v175 + 18) - v271) >> 2)
                        {
                          v272 = *(unsigned int *)(v224 + 80);
                          if (v267 >= v272 && v267 <= *(unsigned int *)(v224 + 84))
                          {
                            v274 = *(_DWORD *)(v271 + 4 * v270);
                            v275 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)(v224 + 40),  data);
                            if (v275)
                            {
                              v276 = (v274 - v272);
                              v277 = v275[3];
                              if (v276 < (v275[4] - v277) >> 2)
                              {
                                v278 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)(v224 + 88),  data);
                                if (v278)
                                {
                                  LODWORD(v279) = *((_DWORD *)v278 + 5);
                                  LODWORD(v280) = *(_DWORD *)(v277 + 4 * v276);
                                  *(double *)&v281 = (double)v280;
                                  v282 = (double)v279 / *(double *)&v281;
                                  LODWORD(v281) = v269[1];
                                  v269[1] = (v282 * (double)v281);
                                  if ([*(id *)(a1 + 32) dumpInstructions])
                                  {
                                    LODWORD(v283) = v269[4];
                                    v284.i64[0] = v269[3];
                                    v284.i64[1] = v269[1];
                                    *(float64x2_t *)&(*v310)[24 * v276 + 8] = vaddq_f64( *(float64x2_t *)&(*v310)[24 * v276 + 8],  vdivq_f64( vcvtq_f64_u64(v284),  (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v283), 0)));
                                  }
                                }
                              }
                            }
                          }
                        }

                        v269 += 5;
                      }

                      ++v266;
                    }

                    v263 = *v308;
                  }

                  while (*v308);
                }

                v261 = *v301;
              }

              while (*v301);
            }

            v225 = v297 + 1;
            v224 += 128LL;
          }

          while (v224 != v293);
        }

        BOOL v169 = *v290;
        if (!*v290) {
          return;
        }
      }

      double *v191 = *v198;
LABEL_280:
      *__int128 v198 = v191;
      goto LABEL_281;
    }
  }

void sub_10E060( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37)
{
}

void *std::pair<ShaderBinaryInfo * {__strong},std::string>::pair[abi:nn180100](void *a1, uint64_t a2)
{
  *a1 = *(id *)a2;
  uint64_t v4 = (std::string *)(a1 + 1);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 8);
    a1[3] = *(void *)(a2 + 24);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v5;
  }

  return a1;
}

void sub_10E1C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__init_with_size[abi:nn180100]<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>*,std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>*>( void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__vallocate[abi:nn180100]( result,  a4);
    if (a2 == a3)
    {
      uint64_t v7 = (void *)v6[1];
    }

    else
    {
      uint64_t v7 = (void *)v6[1];
      do
      {
        *uint64_t v7 = 0LL;
        v7[1] = 0LL;
        v7[2] = 0LL;
        uint64_t v8 = *a2;
        uint64_t v9 = a2[1];
        uint64_t v10 = v9 - *a2;
        if (v9 != *a2)
        {
          if (v10 < 0) {
            abort();
          }
          __n128 result = std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v10 >> 5);
          *uint64_t v7 = result;
          v7[1] = result;
          v7[2] = &result[4 * v11];
          do
          {
            __int128 v12 = std::pair<ShaderBinaryInfo * {__strong},std::string>::pair[abi:nn180100](result, v8);
            v8 += 32LL;
            __n128 result = v12 + 4;
          }

          while (v8 != v9);
          v7[1] = result;
        }

        a2 += 3;
        v7 += 3;
      }

      while (a2 != a3);
    }

    v6[1] = v7;
  }

  return result;
}

void sub_10E29C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::__init_with_size[abi:nn180100]<std::vector<ShaderProfilerUSCSampleInfo>*,std::vector<ShaderProfilerUSCSampleInfo>*>( void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    __int128 v5 = result;
    __n128 result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a4);
    uint64_t v6 = result;
    *__int128 v5 = result;
    v5[1] = result;
    v5[2] = &result[3 * v7];
    if (a2 != a3)
    {
      uint64_t v17 = v5;
      unint64_t v8 = 0LL;
      do
      {
        uint64_t v9 = a2 + v8;
        uint64_t v10 = &v6[v8 / 8];
        void *v10 = 0LL;
        v10[1] = 0LL;
        v10[2] = 0LL;
        __int128 v12 = *(_BYTE **)(a2 + v8);
        uint64_t v11 = *(_BYTE **)(a2 + v8 + 8);
        int64_t v13 = v11 - v12;
        if (v11 != v12)
        {
          if (0xCCCCCCCCCCCCCCCDLL * (v13 >> 3) >= 0x666666666666667LL) {
            abort();
          }
          uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(0xCCCCCCCCCCCCCCCDLL * (v13 >> 3));
          unint64_t v15 = &v6[v8 / 8];
          *unint64_t v15 = v14;
          v10[1] = v14;
          v15[2] = &v14[40 * v16];
          __n128 result = memmove(v14, v12, v13);
          v10[1] = &v14[8 * (v13 >> 3)];
        }

        v8 += 24LL;
      }

      while (v9 + 24 != a3);
      uint64_t v6 = (void *)((char *)v6 + v8);
      __int128 v5 = v17;
    }

    v5[1] = v6;
  }

  return result;
}

void sub_10E3E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)(a9 + 8) = v9;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    __int128 v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (void **)v1[1];
      do
      {
        unint64_t v8 = *(v6 - 3);
        v6 -= 3;
        uint64_t v7 = v8;
        if (v8)
        {
          uint64_t v9 = (uint64_t)*(v4 - 2);
          uint64_t v10 = v7;
          if ((void *)v9 != v7)
          {
            do
            {
              v9 -= 32LL;
              std::allocator<std::pair<ShaderBinaryInfo * {__strong},std::string>>::destroy[abi:nn180100](v9);
            }

            while ((void *)v9 != v7);
            uint64_t v10 = *v6;
          }

          *(v4 - 2) = v7;
          operator delete(v10);
        }

        uint64_t v4 = v6;
      }

      while (v6 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::__emplace_unique_key_args<std::string,std::string const&,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    uint64_t v10 = (uint64_t *)a2;
  }
  else {
    uint64_t v10 = *(uint64_t **)a2;
  }
  if (v9 >= 0) {
    unint64_t v11 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v11 = *(void *)(a2 + 8);
  }
  unint64_t v12 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v10, v11);
  unint64_t v13 = v12;
  unint64_t v14 = *(void *)(a1 + 8);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    unint64_t v16 = v15.u32[0];
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v4 = v12;
      if (v12 >= v14) {
        unint64_t v4 = v12 % v14;
      }
    }

    else
    {
      unint64_t v4 = (v14 - 1) & v12;
    }

    uint64_t v17 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v17)
    {
      for (unint64_t i = *v17; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v19 = *((void *)i + 1);
        if (v19 == v13)
        {
        }

        else
        {
          if (v16 > 1)
          {
            if (v19 >= v14) {
              v19 %= v14;
            }
          }

          else
          {
            v19 &= v14 - 1;
          }

          if (v19 != v4) {
            break;
          }
        }
      }
    }
  }

  uint64_t v20 = (void *)(a1 + 16);
  unsigned int v21 = operator new(0x30uLL);
  v45[0] = v21;
  v45[1] = a1 + 16;
  char v46 = 0;
  void *v21 = 0LL;
  v21[1] = v13;
  unsigned int v22 = (std::string *)(v21 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)&v22->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v21[4] = *(void *)(a3 + 16);
  }

  uint64_t v23 = *a4;
  *a4 = 0LL;
  v21[5] = v23;
  char v46 = 1;
  float v24 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v25 = *(float *)(a1 + 32);
  if (!v14 || (float)(v25 * (float)v14) < v24)
  {
    BOOL v26 = 1LL;
    if (v14 >= 3) {
      BOOL v26 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v27 = v26 | (2 * v14);
    unint64_t v28 = vcvtps_u32_f32(v24 / v25);
    if (v27 <= v28) {
      int8x8_t prime = (int8x8_t)v28;
    }
    else {
      int8x8_t prime = (int8x8_t)v27;
    }
    if (*(void *)&prime == 1LL)
    {
      int8x8_t prime = (int8x8_t)2LL;
    }

    else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }

    unint64_t v14 = *(void *)(a1 + 8);
    if (*(void *)&prime > v14) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v14)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v14 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }

      else
      {
        uint64_t v38 = 1LL << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }

      if (*(void *)&prime <= v36) {
        int8x8_t prime = (int8x8_t)v36;
      }
      if (*(void *)&prime >= v14)
      {
        unint64_t v14 = *(void *)(a1 + 8);
      }

      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v30 = operator new(8LL * *(void *)&prime);
          unsigned int v31 = *(void **)a1;
          *(void *)a1 = v30;
          if (v31) {
            operator delete(v31);
          }
          uint64_t v32 = 0LL;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v32++) = 0LL;
          while (*(void *)&prime != v32);
          unsigned int v33 = (void *)*v20;
          if (*v20)
          {
            unint64_t v34 = v33[1];
            uint8x8_t v35 = (uint8x8_t)vcnt_s8(prime);
            v35.i16[0] = vaddlv_u8(v35);
            if (v35.u32[0] > 1uLL)
            {
              if (v34 >= *(void *)&prime) {
                v34 %= *(void *)&prime;
              }
            }

            else
            {
              v34 &= *(void *)&prime - 1LL;
            }

            *(void *)(*(void *)a1 + 8 * v34) = v20;
            unsigned int v39 = (void *)*v33;
            if (*v33)
            {
              do
              {
                unint64_t v40 = v39[1];
                if (v35.u32[0] > 1uLL)
                {
                  if (v40 >= *(void *)&prime) {
                    v40 %= *(void *)&prime;
                  }
                }

                else
                {
                  v40 &= *(void *)&prime - 1LL;
                }

                if (v40 != v34)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v40))
                  {
                    *(void *)(*(void *)a1 + 8 * v40) = v33;
                    goto LABEL_64;
                  }

                  void *v33 = *v39;
                  *unsigned int v39 = **(void **)(*(void *)a1 + 8 * v40);
                  **(void **)(*(void *)a1 + 8 * v40) = v39;
                  unsigned int v39 = v33;
                }

                unint64_t v40 = v34;
LABEL_64:
                unsigned int v33 = v39;
                unsigned int v39 = (void *)*v39;
                unint64_t v34 = v40;
              }

              while (v39);
            }
          }

          unint64_t v14 = (unint64_t)prime;
          goto LABEL_68;
        }

        __int128 v44 = *(void **)a1;
        *(void *)a1 = 0LL;
        if (v44) {
          operator delete(v44);
        }
        unint64_t v14 = 0LL;
        *(void *)(a1 + 8) = 0LL;
      }
    }

void sub_10E910(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<ClauseData>>(unint64_t a1)
{
  if (a1 >= 0x924924924924925LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(28 * a1);
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>( __int128 *a1, __int128 *a2, std::string *this)
{
  if (a1 != a2)
  {
    __int128 v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((void *)v5 + 1));
      }

      else
      {
        __int128 v6 = *v5;
        this->__r_.__value_.__l.__cap_ = *((void *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }

      __int128 v5 = (__int128 *)((char *)v5 + 24);
      ++this;
    }

    while (v5 != a2);
  }

  return this;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>( unint64_t result, unsigned int *a2, uint64_t a3, char a4)
{
  uint64_t v7 = (unsigned int *)result;
LABEL_2:
  unint64_t v8 = a2 - 2;
  unint64_t i = v7;
  while (2)
  {
    uint64_t v7 = i;
    uint64_t v10 = (char *)a2 - (char *)i;
    unint64_t v11 = ((char *)a2 - (char *)i) >> 3;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        unsigned int v46 = *v8;
        unsigned int v47 = *i;
        if (*v8 < *i || v47 >= v46 && *(a2 - 1) < i[1])
        {
          unsigned int *i = v46;
          *(a2 - 2) = v47;
          unsigned int v48 = i[1];
          i[1] = *(a2 - 1);
          *(a2 - 1) = v48;
        }

        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( i,  i + 2,  a2 - 2);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( i,  i + 2,  i + 4,  a2 - 2);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( i,  i + 2,  i + 4,  i + 6,  a2 - 2);
      default:
        if (v10 <= 191)
        {
          unsigned int v49 = i + 2;
          BOOL v51 = i == a2 || v49 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v51)
            {
              uint64_t v52 = 0LL;
              unsigned int v53 = i;
              do
              {
                __int128 v54 = v53;
                unsigned int v53 = v49;
                unsigned int v55 = v54[2];
                unsigned int v56 = *v54;
                if (v55 < *v54 || v56 >= v55 && v54[3] < v54[1])
                {
                  unsigned int v58 = v54[2];
                  unsigned int v57 = v54[3];
                  unsigned int v59 = v54[1];
                  v54[2] = v56;
                  v53[1] = v59;
                  uint64_t v60 = i;
                  if (v54 != i)
                  {
                    uint64_t v61 = v52;
                    do
                    {
                      unsigned int v62 = *(unsigned int *)((char *)i + v61 - 8);
                      if (v62 <= v58)
                      {
                        if (v62 < v58)
                        {
                          uint64_t v60 = v54;
                          goto LABEL_113;
                        }

                        uint64_t v60 = (unsigned int *)((char *)i + v61);
                        unsigned int v63 = *(unsigned int *)((char *)i + v61 - 4);
                        if (v63 <= v57) {
                          goto LABEL_113;
                        }
                      }

                      else
                      {
                        unsigned int v63 = *(unsigned int *)((char *)i + v61 - 4);
                      }

                      v54 -= 2;
                      unsigned int v64 = (unsigned int *)((char *)i + v61);
                      *unsigned int v64 = v62;
                      v64[1] = v63;
                      v61 -= 8LL;
                    }

                    while (v61);
                    uint64_t v60 = i;
                  }

uint64_t std::__hash_table<std::__hash_value_type<std::string,BinaryInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BinaryInfo>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,BinaryInfo>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_map<unsigned int,ClauseData>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<std::unordered_map<std::string,BinaryInfo>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<std::string,BinaryInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,BinaryInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,BinaryInfo>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::vector<std::unordered_map<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::vector<std::unordered_map<std::string,std::unordered_map<unsigned int,ClauseData>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::vector<std::vector<InstructionPCInfo>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    __int128 v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        __int128 v6 = v4;
        std::vector<InstructionPCInfo>::__destroy_vector::operator()[abi:nn180100](&v6);
      }

      while (v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,std::pair<ShaderBinaryInfo * {__strong},std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,std::pair<ShaderBinaryInfo * {__strong},std::string>>,0>( uint64_t a1)
{
}

void std::vector<InstructionPCInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 32LL;
        std::allocator<InstructionPCInfo>::destroy[abi:nn180100](v4);
      }

      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::allocator<InstructionPCInfo>::destroy[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_map<unsigned int,ClauseData>>,0>( uint64_t a1)
{
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,BinaryInfo>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = *(void **)(a1 + 40);
    if (v3 != v2)
    {
      uint64_t v5 = *(void *)(a1 + 48);
      do
      {
        uint64_t v7 = *(void **)(v5 - 56);
        v5 -= 56LL;
        __int128 v6 = v7;
        if (v7)
        {
          *(void *)(v3 - 48) = v6;
          operator delete(v6);
        }

        uint64_t v3 = v5;
      }

      while (v5 != v2);
      uint64_t v4 = *(void **)(a1 + 40);
    }

    *(void *)(a1 + 48) = v2;
    operator delete(v4);
  }

unsigned int *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *result;
  if (*a2 >= *result && (v4 < v3 || a2[1] >= result[1]))
  {
    unsigned int v7 = *a3;
    if (*a3 < v3 || v3 >= v7 && a3[1] < a2[1])
    {
      *a2 = v7;
      *a3 = v3;
      unint64_t v8 = a2 + 1;
      unsigned int v9 = a2[1];
      a2[1] = a3[1];
      a3[1] = v9;
      unsigned int v10 = *a2;
      unsigned int v11 = *result;
      if (*a2 < *result || v11 >= v10 && *v8 < result[1])
      {
        *result++ = v10;
        *a2 = v11;
LABEL_18:
        unsigned int v15 = *result;
        *__n128 result = *v8;
        *unint64_t v8 = v15;
      }
    }
  }

  else
  {
    unsigned int v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *result++ = v5;
      *a3 = v4;
      __int128 v6 = a3 + 1;
LABEL_17:
      unint64_t v8 = v6;
      goto LABEL_18;
    }

    *__n128 result = v3;
    *a2 = v4;
    unsigned int v12 = result[1];
    result[1] = a2[1];
    a2[1] = v12;
    unsigned int v13 = *a3;
    unsigned int v14 = *a2;
    if (*a3 < *a2 || v14 >= v13 && a3[1] < v12)
    {
      *a2 = v13;
      *a3 = v14;
      __int128 v6 = a3 + 1;
      __n128 result = a2 + 1;
      goto LABEL_17;
    }
  }

  return result;
}

unsigned int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( a1,  a2,  a3);
  unsigned int v9 = *a4;
  unsigned int v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    unsigned int v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    unsigned int v12 = *a3;
    unsigned int v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      unsigned int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      unsigned int v15 = *a2;
      unsigned int v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        unsigned int v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }

  return result;
}

unsigned int *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( a1,  a2,  a3,  a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    unsigned int v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unsigned int v14 = *a4;
    unsigned int v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      unsigned int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      unsigned int v17 = *a3;
      unsigned int v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        unsigned int v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        unsigned int v20 = *a2;
        unsigned int v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          unsigned int v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      unsigned int v6 = *(a2 - 2);
      unsigned int v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unsigned int v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }

      return result;
    case 3LL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( a1,  a1 + 2,  a2 - 2);
      return 1LL;
    case 4LL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( a1,  a1 + 2,  a1 + 4,  a2 - 2);
      return 1LL;
    case 5LL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( a1,  a1 + 2,  a1 + 4,  a1 + 6,  a2 - 2);
      return 1LL;
    default:
      unsigned int v9 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( a1,  a1 + 2,  a1 + 4);
      unsigned int v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  do
  {
    unsigned int v13 = *v9;
    if (*v10 >= *v9 && (v13 < *v10 || v10[1] >= v9[1])) {
      goto LABEL_22;
    }
    unsigned int v14 = *v10;
    unsigned int v15 = v10[1];
    unsigned int *v10 = v13;
    v10[1] = v9[1];
    unsigned int v16 = a1;
    if (v9 == a1) {
      goto LABEL_21;
    }
    uint64_t v17 = v11;
    while (1)
    {
      unsigned int v18 = (char *)a1 + v17;
      unsigned int v19 = *(unsigned int *)((char *)a1 + v17 + 8);
      if (v19 <= v14) {
        break;
      }
      unsigned int v20 = *((_DWORD *)v18 + 3);
LABEL_18:
      v9 -= 2;
      *((_DWORD *)v18 + 4) = v19;
      *(unsigned int *)((char *)a1 + v17 + 20) = v20;
      v17 -= 8LL;
      if (v17 == -16)
      {
        unsigned int v16 = a1;
        goto LABEL_21;
      }
    }

    if (v19 < v14)
    {
      unsigned int v16 = v9;
      goto LABEL_21;
    }

    unsigned int v20 = *(unsigned int *)((char *)a1 + v17 + 12);
    if (v20 > v15) {
      goto LABEL_18;
    }
    unsigned int v16 = (unsigned int *)((char *)a1 + v17 + 16);
LABEL_21:
    *unsigned int v16 = v14;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_22:
    unsigned int v9 = v10;
    v11 += 8LL;
    v10 += 2;
  }

  while (v10 != a2);
  return 1LL;
}

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( uint64_t a1, int *a2, uint64_t a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = a2[5];
  BOOL v5 = *a2 < *(_DWORD *)a1;
  if (*a2 == *(_DWORD *)a1) {
    BOOL v5 = v4 < *(_DWORD *)(a1 + 20);
  }
  BOOL v6 = *(_DWORD *)(a3 + 20) < v4;
  BOOL v7 = *(_DWORD *)a3 == v3;
  BOOL v8 = *(_DWORD *)a3 < v3;
  if (v7) {
    BOOL v8 = v6;
  }
  if (v5)
  {
    if (v8)
    {
      *(_OWORD *)uint64_t v17 = *(_OWORD *)a1;
      *(_OWORD *)&v17[12] = *(_OWORD *)(a1 + 12);
      __int128 v9 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 12) = v9;
LABEL_17:
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v17[12];
      __n128 result = *(__n128 *)v17;
      *(_OWORD *)a3 = *(_OWORD *)v17;
      return result;
    }

    *(_OWORD *)unsigned int v20 = *(_OWORD *)a1;
    *(_OWORD *)&v20[12] = *(_OWORD *)(a1 + 12);
    __int128 v14 = *(_OWORD *)(a2 + 3);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 12) = v14;
    *(_OWORD *)(a2 + 3) = *(_OWORD *)&v20[12];
    __n128 result = *(__n128 *)v20;
    *(_OWORD *)a2 = *(_OWORD *)v20;
    BOOL v15 = *(_DWORD *)a3 < *a2;
    if (*(_DWORD *)a3 == *a2) {
      BOOL v15 = *(_DWORD *)(a3 + 20) < a2[5];
    }
    if (v15)
    {
      *(_OWORD *)uint64_t v17 = *(_OWORD *)a2;
      *(_OWORD *)&v17[12] = *(_OWORD *)(a2 + 3);
      __int128 v16 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 3) = v16;
      goto LABEL_17;
    }
  }

  else if (v8)
  {
    *(_OWORD *)unsigned int v18 = *(_OWORD *)a2;
    *(_OWORD *)&v18[12] = *(_OWORD *)(a2 + 3);
    __int128 v10 = *(_OWORD *)(a3 + 12);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)(a2 + 3) = v10;
    *(_OWORD *)(a3 + 12) = *(_OWORD *)&v18[12];
    __n128 result = *(__n128 *)v18;
    *(_OWORD *)a3 = *(_OWORD *)v18;
    BOOL v12 = *a2 < *(_DWORD *)a1;
    if (*a2 == *(_DWORD *)a1) {
      BOOL v12 = a2[5] < *(_DWORD *)(a1 + 20);
    }
    if (v12)
    {
      *(_OWORD *)unsigned int v19 = *(_OWORD *)a1;
      *(_OWORD *)&v19[12] = *(_OWORD *)(a1 + 12);
      __int128 v13 = *(_OWORD *)(a2 + 3);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 12) = v13;
      *(_OWORD *)(a2 + 3) = *(_OWORD *)&v19[12];
      __n128 result = *(__n128 *)v19;
      *(_OWORD *)a2 = *(_OWORD *)v19;
    }
  }

  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( a1,  (int *)a2,  a3).n128_u64[0];
  BOOL v9 = *(_DWORD *)a4 < *(_DWORD *)a3;
  if (*(_DWORD *)a4 == *(_DWORD *)a3) {
    BOOL v9 = *(_DWORD *)(a4 + 20) < *(_DWORD *)(a3 + 20);
  }
  if (v9)
  {
    *(_OWORD *)BOOL v15 = *(_OWORD *)a3;
    *(_OWORD *)&v15[12] = *(_OWORD *)(a3 + 12);
    __int128 v10 = *(_OWORD *)(a4 + 12);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 12) = v10;
    *(_OWORD *)(a4 + 12) = *(_OWORD *)&v15[12];
    __n128 result = *(__n128 *)v15;
    *(_OWORD *)a4 = *(_OWORD *)v15;
    BOOL v11 = *(_DWORD *)a3 < *(_DWORD *)a2;
    if (*(_DWORD *)a3 == *(_DWORD *)a2) {
      BOOL v11 = *(_DWORD *)(a3 + 20) < *(_DWORD *)(a2 + 20);
    }
    if (v11)
    {
      *(_OWORD *)__int128 v16 = *(_OWORD *)a2;
      *(_OWORD *)&v16[12] = *(_OWORD *)(a2 + 12);
      __int128 v12 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v12;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v16[12];
      __n128 result = *(__n128 *)v16;
      *(_OWORD *)a3 = *(_OWORD *)v16;
      BOOL v13 = *(_DWORD *)a2 < *(_DWORD *)a1;
      if (*(_DWORD *)a2 == *(_DWORD *)a1) {
        BOOL v13 = *(_DWORD *)(a2 + 20) < *(_DWORD *)(a1 + 20);
      }
      if (v13)
      {
        *(_OWORD *)uint64_t v17 = *(_OWORD *)a1;
        *(_OWORD *)&v17[12] = *(_OWORD *)(a1 + 12);
        __int128 v14 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v14;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v17[12];
        __n128 result = *(__n128 *)v17;
        *(_OWORD *)a2 = *(_OWORD *)v17;
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7LL * ((a2 - a1) >> 2);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      BOOL v7 = (_OWORD *)(a2 - 28);
      unsigned int v6 = *(_DWORD *)(a2 - 28);
      BOOL v8 = v6 == *(_DWORD *)a1;
      BOOL v9 = v6 < *(_DWORD *)a1;
      if (v8) {
        BOOL v9 = *(_DWORD *)(a2 - 8) < *(_DWORD *)(a1 + 20);
      }
      if (v9)
      {
        *(_OWORD *)unsigned int v41 = *(_OWORD *)a1;
        *(_OWORD *)&v41[12] = *(_OWORD *)(a1 + 12);
        __int128 v10 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *v7;
        *(_OWORD *)(a1 + 12) = v10;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v41[12];
        *BOOL v7 = *(_OWORD *)v41;
      }

      return result;
    case 3LL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( a1,  (int *)(a1 + 28),  a2 - 28);
      return 1LL;
    case 4LL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( a1,  a1 + 28,  a1 + 56,  a2 - 28);
      return 1LL;
    case 5LL:
      unsigned int v25 = (_OWORD *)(a1 + 28);
      unsigned int v26 = (_OWORD *)(a1 + 56);
      unint64_t v27 = (_OWORD *)(a1 + 84);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( a1,  a1 + 28,  a1 + 56,  a1 + 84);
      unsigned int v29 = *(_DWORD *)(a2 - 28);
      uint64_t v28 = a2 - 28;
      unsigned int v30 = *(_DWORD *)(a1 + 84);
      BOOL v31 = v29 < v30;
      if (v29 == v30) {
        BOOL v31 = *(_DWORD *)(v28 + 20) < *(_DWORD *)(a1 + 104);
      }
      if (v31)
      {
        *(_OWORD *)unsigned int v43 = *v27;
        *(_OWORD *)&v43[12] = *(_OWORD *)(a1 + 96);
        __int128 v32 = *(_OWORD *)(v28 + 12);
        *unint64_t v27 = *(_OWORD *)v28;
        *(_OWORD *)(a1 + 96) = v32;
        *(_OWORD *)(v28 + 12) = *(_OWORD *)&v43[12];
        *(_OWORD *)uint64_t v28 = *(_OWORD *)v43;
        unsigned int v33 = *(_DWORD *)(a1 + 84);
        unsigned int v34 = *(_DWORD *)(a1 + 56);
        BOOL v8 = v33 == v34;
        BOOL v35 = v33 < v34;
        if (v8) {
          BOOL v35 = *(_DWORD *)(a1 + 104) < *(_DWORD *)(a1 + 76);
        }
        if (v35)
        {
          *(_OWORD *)unsigned int v44 = *v26;
          *(_OWORD *)&v44[12] = *(_OWORD *)(a1 + 68);
          _OWORD *v26 = *v27;
          *(_OWORD *)(a1 + 68) = *(_OWORD *)(a1 + 96);
          *unint64_t v27 = *(_OWORD *)v44;
          *(_OWORD *)(a1 + 96) = *(_OWORD *)&v44[12];
          unsigned int v36 = *(_DWORD *)(a1 + 56);
          unsigned int v37 = *(_DWORD *)(a1 + 28);
          BOOL v8 = v36 == v37;
          BOOL v38 = v36 < v37;
          if (v8) {
            BOOL v38 = *(_DWORD *)(a1 + 76) < *(_DWORD *)(a1 + 48);
          }
          if (v38)
          {
            *(_OWORD *)BOOL v45 = *v25;
            *(_OWORD *)&v45[12] = *(_OWORD *)(a1 + 40);
            _OWORD *v25 = *v26;
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 68);
            _OWORD *v26 = *(_OWORD *)v45;
            *(_OWORD *)(a1 + 68) = *(_OWORD *)&v45[12];
            unsigned int v39 = *(_DWORD *)(a1 + 28);
            BOOL v8 = v39 == *(_DWORD *)a1;
            BOOL v40 = v39 < *(_DWORD *)a1;
            if (v8) {
              BOOL v40 = *(_DWORD *)(a1 + 48) < *(_DWORD *)(a1 + 20);
            }
            if (v40)
            {
              *(_OWORD *)unsigned int v46 = *(_OWORD *)a1;
              *(_OWORD *)&v46[12] = *(_OWORD *)(a1 + 12);
              *(_OWORD *)a1 = *v25;
              *(_OWORD *)(a1 + 12) = *(_OWORD *)(a1 + 40);
              _OWORD *v25 = *(_OWORD *)v46;
              *(_OWORD *)(a1 + 40) = *(_OWORD *)&v46[12];
            }
          }
        }
      }

      return 1LL;
    default:
      BOOL v11 = (_DWORD *)(a1 + 56);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper generateTargetSamplesForResult:withProgramAddressLUT:withBatchIndexMin:withProgramAddressList:withUSCSampleBuffer:withUSCSampleNum:withBatchIDToEncoderIndex:andEncoderIndexToBatchIdMap:targetIndex:]::$_6 &,ClauseData *>( a1,  (int *)(a1 + 28),  a1 + 56);
      uint64_t v12 = a1 + 84;
      if (a1 + 84 == a2) {
        return 1LL;
      }
      uint64_t v13 = 0LL;
      int v14 = 0;
      break;
  }

  while (1)
  {
    unsigned int v15 = *(_DWORD *)v12;
    unsigned int v16 = *(_DWORD *)(v12 + 20);
    BOOL v17 = *(_DWORD *)v12 < *v11;
    if (*(_DWORD *)v12 == *v11) {
      BOOL v17 = v16 < v11[5];
    }
    if (v17)
    {
      __int128 v42 = *(_OWORD *)(v12 + 4);
      int v18 = *(_DWORD *)(v12 + 24);
      uint64_t v19 = v13;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        *(_OWORD *)(v20 + 84) = *(_OWORD *)(a1 + v19 + 56);
        *(_OWORD *)(v20 + 96) = *(_OWORD *)(a1 + v19 + 68);
        if (v19 == -56) {
          break;
        }
        unsigned int v21 = *(_DWORD *)(v20 + 28);
        BOOL v22 = v16 < *(_DWORD *)(v20 + 48);
        BOOL v8 = v15 == v21;
        BOOL v23 = v15 < v21;
        if (!v8) {
          BOOL v22 = v23;
        }
        v19 -= 28LL;
        if (!v22)
        {
          uint64_t v24 = a1 + v19 + 84;
          goto LABEL_19;
        }
      }

      uint64_t v24 = a1;
LABEL_19:
      *(_DWORD *)uint64_t v24 = v15;
      *(_OWORD *)(v24 + 4) = v42;
      *(_DWORD *)(v24 + 20) = v16;
      *(_DWORD *)(v24 + 24) = v18;
      if (++v14 == 8) {
        return v12 + 28 == a2;
      }
    }

    BOOL v11 = (_DWORD *)v12;
    v13 += 28LL;
    v12 += 28LL;
    if (v12 == a2) {
      return 1LL;
    }
  }

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BinaryInfo>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BinaryInfo>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,BinaryInfo>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_map<unsigned int,ClauseData>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_map<unsigned int,ClauseData>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

void std::allocator<std::pair<ShaderBinaryInfo * {__strong},std::string>>::destroy[abi:nn180100](uint64_t a1)
{
}

char *std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__vallocate[abi:nn180100]( void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t v3 = 3 * a2;
  BOOL result = (char *)operator new(24 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v3];
  return result;
}

void *__copy_helper_block_ea8_88c39_ZTSNSt3__16vectorImNS_9allocatorImEEEE120c106_ZTSNSt3__14pairIU8__strongP16ShaderBinaryInfoNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEE152c146_ZTSNSt3__16vectorINS0_INS_4pairIU8__strongP16ShaderBinaryInfoNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEENS8_ISB_EEEENS8_ISD_EEEE176c86_ZTSNSt3__16vectorINS0_I27ShaderProfilerUSCSampleInfoNS_9allocatorIS1_EEEENS2_IS4_EEEE( void *a1, uint64_t a2)
{
  a1[11] = 0LL;
  a1[12] = 0LL;
  a1[13] = 0LL;
  BOOL v5 = *(_BYTE **)(a2 + 88);
  uint64_t v4 = *(_BYTE **)(a2 + 96);
  int64_t v6 = v4 - v5;
  if (v4 != v5)
  {
    std::vector<unsigned long>::__vallocate[abi:nn180100](a1 + 11, v6 >> 3);
    BOOL v7 = (char *)a1[12];
    memmove(v7, v5, v6);
    a1[12] = &v7[v6];
  }

  std::pair<ShaderBinaryInfo * {__strong},std::string>::pair[abi:nn180100](a1 + 15, a2 + 120);
  a1[19] = 0LL;
  a1[20] = 0LL;
  a1[21] = 0LL;
  std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__init_with_size[abi:nn180100]<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>*,std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>*>( a1 + 19,  *(uint64_t **)(a2 + 152),  *(uint64_t **)(a2 + 160),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 160) - *(void *)(a2 + 152)) >> 3));
  a1[22] = 0LL;
  a1[23] = 0LL;
  a1[24] = 0LL;
  return std::vector<std::vector<ShaderProfilerUSCSampleInfo>>::__init_with_size[abi:nn180100]<std::vector<ShaderProfilerUSCSampleInfo>*,std::vector<ShaderProfilerUSCSampleInfo>*>( a1 + 22,  *(void *)(a2 + 176),  *(void *)(a2 + 184),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 184) - *(void *)(a2 + 176)) >> 3));
}

void sub_111154(_Unwind_Exception *a1, uint64_t a2, ...)
{
  int64_t v6 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 96) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_88c39_ZTSNSt3__16vectorImNS_9allocatorImEEEE120c106_ZTSNSt3__14pairIU8__strongP16ShaderBinaryInfoNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEE152c146_ZTSNSt3__16vectorINS0_INS_4pairIU8__strongP16ShaderBinaryInfoNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEENS8_ISB_EEEENS8_ISD_EEEE176c86_ZTSNSt3__16vectorINS0_I27ShaderProfilerUSCSampleInfoNS_9allocatorIS1_EEEENS2_IS4_EEEE( uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 152);
  uint64_t v4 = (void **)(a1 + 176);
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v4);
  uint64_t v4 = v2;
  std::vector<std::vector<std::pair<ShaderBinaryInfo * {__strong},std::string>>>::__destroy_vector::operator()[abi:nn180100](&v4);

  uint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    *(void *)(a1 + 96) = v3;
    operator delete(v3);
  }

char *std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    BOOL v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      __int128 v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          __int128 v10 = *(char **)v10;
        }

        while (v10);
      }
    }
  }

  __int128 v10 = (char *)operator new(0x38uLL);
  *(void *)__int128 v10 = 0LL;
  *((void *)v10 + 1) = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *(void *)__int128 v10 = *v19;
LABEL_38:
    *uint64_t v19 = v10;
    goto LABEL_39;
  }

  *(void *)__int128 v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*(void *)v10)
  {
    unint64_t v20 = *(void *)(*(void *)v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_111414(_Unwind_Exception *a1)
{
}

uint64_t std::pair<std::string,std::unordered_map<unsigned int,ClauseData>>::~pair(uint64_t a1)
{
  return a1;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<DYMTLShaderProfilerProcessedUSCSample>>( unint64_t a1)
{
  if (a1 >= 0xCCCCCCCCCCCCCCDLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(20 * a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,DrawDurationInfo>,void *>>>::operator()[abi:nn180100]( char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (void *)__p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

BOOL USCSampleComparator::operator()(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 12);
  unsigned int v3 = *(_DWORD *)(a2 + 12);
  BOOL v4 = v2 >= v3;
  if (v2 == v3)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 32);
    unsigned int v6 = *(_DWORD *)(a2 + 32);
    BOOL v4 = v5 >= v6;
    if (v5 == v6)
    {
      BOOL v4 = *(_DWORD *)a1 >= *(_DWORD *)a2;
      if (*(_DWORD *)a1 == *(_DWORD *)a2)
      {
        unsigned int v7 = *(_DWORD *)(a1 + 8);
        unsigned int v8 = *(_DWORD *)(a2 + 8);
        BOOL v4 = v7 >= v8;
        if (v7 == v8) {
          BOOL v4 = *(void *)(a1 + 24) >= *(void *)(a2 + 24);
        }
      }
    }
  }

  return !v4;
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = USCSampleComparator::operator()(a2, a1);
  BOOL result = USCSampleComparator::operator()(a3, a2);
  if (v6)
  {
    if (result)
    {
      __int128 v8 = *(_OWORD *)a1;
      __int128 v9 = *(_OWORD *)(a1 + 16);
      uint64_t v10 = *(void *)(a1 + 32);
      uint64_t v11 = *(void *)(a3 + 32);
      __int128 v12 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 16) = v12;
      *(void *)(a1 + 32) = v11;
    }

    else
    {
      __int128 v23 = *(_OWORD *)a1;
      __int128 v24 = *(_OWORD *)(a1 + 16);
      uint64_t v25 = *(void *)(a1 + 32);
      uint64_t v26 = *(void *)(a2 + 32);
      __int128 v27 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v27;
      *(void *)(a1 + 32) = v26;
      *(void *)(a2 + 32) = v25;
      *(_OWORD *)a2 = v23;
      *(_OWORD *)(a2 + 16) = v24;
      BOOL result = USCSampleComparator::operator()(a3, a2);
      if (!result) {
        return result;
      }
      __int128 v8 = *(_OWORD *)a2;
      __int128 v9 = *(_OWORD *)(a2 + 16);
      uint64_t v10 = *(void *)(a2 + 32);
      uint64_t v28 = *(void *)(a3 + 32);
      __int128 v29 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v29;
      *(void *)(a2 + 32) = v28;
    }

    *(void *)(a3 + 32) = v10;
    *(_OWORD *)a3 = v8;
    *(_OWORD *)(a3 + 16) = v9;
  }

  else if (result)
  {
    __int128 v13 = *(_OWORD *)a2;
    __int128 v14 = *(_OWORD *)(a2 + 16);
    uint64_t v15 = *(void *)(a2 + 32);
    uint64_t v16 = *(void *)(a3 + 32);
    __int128 v17 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)(a2 + 16) = v17;
    *(void *)(a2 + 32) = v16;
    *(void *)(a3 + 32) = v15;
    *(_OWORD *)a3 = v13;
    *(_OWORD *)(a3 + 16) = v14;
    BOOL result = USCSampleComparator::operator()(a2, a1);
    if (result)
    {
      __int128 v18 = *(_OWORD *)a1;
      __int128 v19 = *(_OWORD *)(a1 + 16);
      uint64_t v20 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a2 + 32);
      __int128 v22 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v22;
      *(void *)(a1 + 32) = v21;
      *(void *)(a2 + 32) = v20;
      *(_OWORD *)a2 = v18;
      *(_OWORD *)(a2 + 16) = v19;
    }
  }

  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (USCSampleComparator::operator()(a4, a3))
  {
    __int128 v9 = *(_OWORD *)a3;
    __int128 v10 = *(_OWORD *)(a3 + 16);
    uint64_t v11 = *(void *)(a3 + 32);
    uint64_t v12 = *(void *)(a4 + 32);
    __int128 v13 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v13;
    *(void *)(a3 + 32) = v12;
    *(void *)(a4 + 32) = v11;
    *(_OWORD *)a4 = v9;
    *(_OWORD *)(a4 + 16) = v10;
    if (USCSampleComparator::operator()(a3, a2))
    {
      __n128 v14 = *(__n128 *)a2;
      __int128 v15 = *(_OWORD *)(a2 + 16);
      uint64_t v16 = *(void *)(a2 + 32);
      uint64_t v17 = *(void *)(a3 + 32);
      __int128 v18 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v18;
      *(void *)(a2 + 32) = v17;
      *(void *)(a3 + 32) = v16;
      *(__n128 *)a3 = v14;
      *(_OWORD *)(a3 + 16) = v15;
      if (USCSampleComparator::operator()(a2, a1))
      {
        __n128 result = *(__n128 *)a1;
        __int128 v19 = *(_OWORD *)(a1 + 16);
        uint64_t v20 = *(void *)(a1 + 32);
        uint64_t v21 = *(void *)(a2 + 32);
        __int128 v22 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v22;
        *(void *)(a1 + 32) = v21;
        *(void *)(a2 + 32) = v20;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v19;
      }
    }
  }

  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (USCSampleComparator::operator()(a5, a4))
  {
    __int128 v11 = *(_OWORD *)a4;
    __int128 v12 = *(_OWORD *)(a4 + 16);
    uint64_t v13 = *(void *)(a4 + 32);
    uint64_t v14 = *(void *)(a5 + 32);
    __int128 v15 = *(_OWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)(a4 + 16) = v15;
    *(void *)(a4 + 32) = v14;
    *(void *)(a5 + 32) = v13;
    *(_OWORD *)a5 = v11;
    *(_OWORD *)(a5 + 16) = v12;
    if (USCSampleComparator::operator()(a4, a3))
    {
      __int128 v16 = *(_OWORD *)a3;
      __int128 v17 = *(_OWORD *)(a3 + 16);
      uint64_t v18 = *(void *)(a3 + 32);
      uint64_t v19 = *(void *)(a4 + 32);
      __int128 v20 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v20;
      *(void *)(a3 + 32) = v19;
      *(void *)(a4 + 32) = v18;
      *(_OWORD *)a4 = v16;
      *(_OWORD *)(a4 + 16) = v17;
      if (USCSampleComparator::operator()(a3, a2))
      {
        __n128 v21 = *(__n128 *)a2;
        __int128 v22 = *(_OWORD *)(a2 + 16);
        uint64_t v23 = *(void *)(a2 + 32);
        uint64_t v24 = *(void *)(a3 + 32);
        __int128 v25 = *(_OWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 16) = v25;
        *(void *)(a2 + 32) = v24;
        *(void *)(a3 + 32) = v23;
        *(__n128 *)a3 = v21;
        *(_OWORD *)(a3 + 16) = v22;
        if (USCSampleComparator::operator()(a2, a1))
        {
          __n128 result = *(__n128 *)a1;
          __int128 v26 = *(_OWORD *)(a1 + 16);
          uint64_t v27 = *(void *)(a1 + 32);
          uint64_t v28 = *(void *)(a2 + 32);
          __int128 v29 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v29;
          *(void *)(a1 + 32) = v28;
          *(void *)(a2 + 32) = v27;
          *(__n128 *)a2 = result;
          *(_OWORD *)(a2 + 16) = v26;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = a2 - 40;
      if (!USCSampleComparator::operator()(a2 - 40, a1)) {
        return 1LL;
      }
      __int128 v7 = *(_OWORD *)a1;
      __int128 v8 = *(_OWORD *)(a1 + 16);
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)(v6 + 32);
      __int128 v11 = *(_OWORD *)(v6 + 16);
      *(_OWORD *)a1 = *(_OWORD *)v6;
      *(_OWORD *)(a1 + 16) = v11;
      *(void *)(a1 + 32) = v10;
      *(void *)(v6 + 32) = v9;
      BOOL result = 1LL;
      *(_OWORD *)uint64_t v6 = v7;
      *(_OWORD *)(v6 + 16) = v8;
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  a2 - 40);
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  a1 + 80,  a2 - 40);
      return 1LL;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  a1 + 80,  a1 + 120,  a2 - 40);
      return 1LL;
    default:
      uint64_t v12 = a1 + 80;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  a1 + 40,  a1 + 80);
      uint64_t v13 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1LL;
      }
      uint64_t v14 = 0LL;
      int v15 = 0;
      break;
  }

  while (2)
  {
    if (!USCSampleComparator::operator()(v13, v12)) {
      goto LABEL_20;
    }
    uint64_t v16 = *(void *)v13;
    unsigned int v17 = *(_DWORD *)(v13 + 8);
    unsigned int v18 = *(_DWORD *)(v13 + 12);
    uint64_t v20 = *(void *)(v13 + 16);
    unint64_t v19 = *(void *)(v13 + 24);
    uint64_t v21 = *(void *)(v13 + 32);
    __int128 v22 = *(_OWORD *)(v12 + 16);
    *(_OWORD *)uint64_t v13 = *(_OWORD *)v12;
    *(_OWORD *)(v13 + 16) = v22;
    uint64_t v23 = a1;
    *(void *)(v13 + 32) = *(void *)(v12 + 32);
    if (v12 == a1) {
      goto LABEL_19;
    }
    uint64_t v24 = v14;
    while (1)
    {
      uint64_t v25 = a1 + v24;
      __int128 v26 = (_DWORD *)(a1 + v24 + 40);
      unsigned int v27 = *(_DWORD *)(a1 + v24 + 52);
      BOOL v28 = v18 >= v27;
      if (v18 == v27)
      {
        unsigned int v29 = *(_DWORD *)(v25 + 72);
        BOOL v28 = v21 >= v29;
        if ((_DWORD)v21 == v29)
        {
          BOOL v28 = v16 >= *v26;
          if ((_DWORD)v16 == *v26)
          {
            unsigned int v30 = *(_DWORD *)(a1 + v24 + 48);
            BOOL v28 = v17 >= v30;
            if (v17 == v30)
            {
              if (v19 >= *(void *)(a1 + v24 + 64))
              {
                uint64_t v23 = a1 + v24 + 80;
                goto LABEL_19;
              }

              goto LABEL_16;
            }
          }
        }
      }

      if (v28) {
        break;
      }
LABEL_16:
      v12 -= 40LL;
      __int128 v31 = *(_OWORD *)(a1 + v24 + 56);
      *(_OWORD *)(v25 + 80) = *(_OWORD *)v26;
      *(_OWORD *)(v25 + 96) = v31;
      *(void *)(v25 + 112) = *(void *)(a1 + v24 + 72);
      v24 -= 40LL;
      if (v24 == -80)
      {
        uint64_t v23 = a1;
        goto LABEL_19;
      }
    }

    uint64_t v23 = v12;
LABEL_19:
    *(void *)uint64_t v23 = v16;
    *(_DWORD *)(v23 + 8) = v17;
    *(_DWORD *)(v23 + 12) = v18;
    *(void *)(v23 + 16) = v20;
    *(void *)(v23 + 24) = v19;
    ++v15;
    *(void *)(v23 + 32) = v21;
    if (v15 != 8)
    {
LABEL_20:
      uint64_t v12 = v13;
      v14 += 40LL;
      v13 += 40LL;
      if (v13 == a2) {
        return 1LL;
      }
      continue;
    }

    return v13 + 40 == a2;
  }

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,std::pair<ShaderBinaryInfo * {__strong},std::string>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

uint64_t std::__split_buffer<std::pair<ShaderBinaryInfo * {__strong},std::string>>::~__split_buffer( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    std::allocator<std::pair<ShaderBinaryInfo * {__strong},std::string>>::destroy[abi:nn180100](i - 32);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 __Block_byref_object_copy__545(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void **__Block_byref_object_dispose__546(uint64_t a1)
{
  return std::vector<std::vector<-[DYPMTLShaderProfilerHelper adjustHWBiasAndFinalizeResult]::ClauseInfo>>::~vector[abi:nn180100]((void **)(a1 + 48));
}

void sub_11204C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void sub_112144( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_112580( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
}

void sub_1126D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_112718( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_112768( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_112914( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_112B14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
}

void std::vector<double>::resize(char **a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    unint64_t v19 = &v3[8 * a2];
    goto LABEL_15;
  }

  unint64_t v6 = a2 - v5;
  __int128 v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    unint64_t v19 = &v4[8 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }

  if (a2 >> 61) {
    abort();
  }
  uint64_t v8 = v7 - v3;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  else {
    unint64_t v10 = v9;
  }
  __int128 v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v10);
  uint64_t v12 = *a1;
  uint64_t v13 = a1[1];
  uint64_t v14 = &v11[8 * v5];
  uint64_t v16 = &v11[8 * v15];
  bzero(v14, 8 * v6);
  unsigned int v17 = &v14[8 * v6];
  while (v13 != v12)
  {
    uint64_t v18 = *((void *)v13 - 1);
    v13 -= 8;
    *((void *)v14 - 1) = v18;
    v14 -= 8;
  }

  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12) {
    operator delete(v12);
  }
}

_OWORD *std::vector<std::pair<unsigned long long,unsigned long long>>::__init_with_size[abi:nn180100]<std::pair<unsigned long long,unsigned long long>*,std::pair<unsigned long long,unsigned long long>*>( _OWORD *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 60) {
      abort();
    }
    unint64_t v6 = result;
    __n128 result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(a4);
    *unint64_t v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      __int128 v8 = *a2++;
      *result++ = v8;
    }

    v6[1] = result;
  }

  return result;
}

uint64_t __Block_byref_object_copy__2952(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__2953(uint64_t a1)
{
}

uint64_t std::__split_buffer<std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>>::~__split_buffer( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>::reset[abi:nn180100]( (void ***)(i - 8),  0LL);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<std::vector<double>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    unint64_t v4 = *(void ***)(i - 8);
    *(void *)(i - 8) = 0LL;
    if (v4) {
      std::default_delete<std::vector<double>>::operator()[abi:nn180100](v4);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>>::~__split_buffer( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::reset[abi:nn180100]((void ***)(i - 8));
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

__n128 __Block_byref_object_copy__500(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__501(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<long,std::unordered_map<unsigned int,DrawDurationInfo>>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__503(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__504(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__506(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__507(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

LABEL_127:
  ProfileEventHelper::~ProfileEventHelper((ProfileEventHelper *)&v105);
}

void sub_11385C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,void *__p,uint64_t a63)
{
  _Unwind_Resume(a1);
}

void *std::vector<std::pair<unsigned int,unsigned int>>::__init_with_size[abi:nn180100]<std::pair<unsigned int,unsigned int>*,std::pair<unsigned int,unsigned int>*>( void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 61) {
      abort();
    }
    unint64_t v6 = result;
    __n128 result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(a4);
    *unint64_t v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      *result++ = v8;
    }

    v6[1] = result;
  }

  return result;
}

__n128 __Block_byref_object_copy__528(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__529(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

LABEL_193:
      uint64_t v1 = v169;
      unint64_t v5 = v163;
      __int128 v22 = v164;
LABEL_194:
      v26 += 10;
      unsigned int v27 = (v27 + 1);
      if (v26 == v168) {
        goto LABEL_36;
      }
    }

    *(void *)unsigned int v49 = *v60;
    uint64_t v1 = v169;
LABEL_113:
    *uint64_t v60 = v49;
    goto LABEL_114;
  }

      pool_high = HIDWORD(v172->pool);
      BOOL v88 = v679;
      unsigned int v69 = v645;
      unint64_t v75 = v653;
      if (IsFuncEnumGPUCommandCall(pool_high) || (pool_high & 0xFFFFFFFC) == 0xFFFFC1A4)
      {
        BOOL v88 = v679;
        *(void *)apr_array_push(*((apr_array_header_t **)v682 + 16)) = v164;
        goto LABEL_196;
      }

        unint64_t v107 = GTShaderProfilerLLVMTargetClauseAnalysis::addString((uint64_t)v88, (__int128 *)v425);
        llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)v452);
        if ((v425[23] & 0x80000000) != 0) {
          operator delete(*(void **)v425);
        }
      }

      v402 = v107;
      v399 = (*(uint64_t (**)(void, unint64_t *))(**(void **)(v88[31] + 88LL) + 56LL))( *(void *)(v88[31] + 88LL),  v103);
      LODWORD(v4) = (*(uint64_t (**)(void, unint64_t *))(**(void **)(v88[31] + 88LL) + 64LL))( *(void *)(v88[31] + 88LL),  v103);
      BOOL v111 = *v103;
      unsigned int v112 = v103[2];
      unsigned int v113 = (*(uint64_t (**)(void, unint64_t *))(**(void **)(v88[31] + 88LL) + 72LL))( *(void *)(v88[31] + 88LL),  v103);
      int64_t v115 = v88[3];
      __int128 v114 = v88[4];
      int64_t v116 = v88[7];
      if (v116)
      {
        uint64_t v117 = (uint8x8_t)vcnt_s8((int8x8_t)v116);
        v117.i16[0] = vaddlv_u8(v117);
        if (v117.u32[0] > 1uLL)
        {
          uint64_t v3 = v111;
          if (v111 >= v116) {
            uint64_t v3 = v111 % v116;
          }
        }

        else
        {
          uint64_t v3 = (v116 - 1) & v111;
        }

        uint64_t v118 = *(void ***)(*v409 + 8 * v3);
        if (v118)
        {
          for (uint64_t i = *v118; i; uint64_t i = (void *)*i)
          {
            uint64_t v120 = i[1];
            if (v120 == v111)
            {
              if (i[2] == v111)
              {
                uint64_t v142 = (_DWORD *)v88[4];
                goto LABEL_233;
              }
            }

            else
            {
              if (v117.u32[0] > 1uLL)
              {
                if (v120 >= v116) {
                  v120 %= v116;
                }
              }

              else
              {
                v120 &= v116 - 1;
              }

              if (v120 != v3) {
                break;
              }
            }
          }
        }
      }

      uint64_t i = operator new(0x20uLL);
      unsigned int *i = 0LL;
      i[1] = v111;
      i[2] = v111;
      i[3] = 0LL;
      unsigned int v121 = (float)(unint64_t)(v88[9] + 1LL);
      uint64_t v122 = *((float *)v88 + 20);
      if (!v116 || (float)(v122 * (float)v116) < v121)
      {
        uint64_t v123 = (v116 & (v116 - 1)) != 0;
        if (v116 < 3) {
          uint64_t v123 = 1LL;
        }
        __int128 v124 = v123 | (2 * v116);
        uint64_t v125 = vcvtps_u32_f32(v121 / v122);
        if (v124 <= v125) {
          uint64_t v126 = v125;
        }
        else {
          uint64_t v126 = v124;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)v409,  v126);
        int64_t v116 = v88[7];
        if ((v116 & (v116 - 1)) != 0)
        {
          if (v111 >= v116) {
            uint64_t v3 = v111 % v116;
          }
          else {
            uint64_t v3 = v111;
          }
        }

        else
        {
          uint64_t v3 = (v116 - 1) & v111;
        }
      }

      uint64_t v127 = *v409;
      BOOL v128 = *(void **)(*v409 + 8 * v3);
      if (v128)
      {
        unsigned int *i = *v128;
      }

      else
      {
        unsigned int *i = *v384;
        *v384 = i;
        *(void *)(v127 + 8 * v3) = v384;
        if (!*i) {
          goto LABEL_232;
        }
        unsigned int v129 = *(void *)(*i + 8LL);
        if ((v116 & (v116 - 1)) != 0)
        {
          if (v129 >= v116) {
            v129 %= v116;
          }
        }

        else
        {
          v129 &= v116 - 1;
        }

        BOOL v128 = (void *)(*v409 + 8 * v129);
      }

      *BOOL v128 = i;
LABEL_232:
      ++v88[9];
      uint64_t v142 = (_DWORD *)v88[4];
LABEL_233:
      i[3] = 0x8E38E38E38E38E39LL * ((v114 - v115) >> 2);
      BOOL v130 = v88[5];
      if ((unint64_t)v142 >= v130)
      {
        unsigned int v132 = (_DWORD *)v88[3];
        __int128 v133 = 0x8E38E38E38E38E39LL * (v142 - v132) + 1;
        if (v133 > 0x71C71C71C71C71CLL) {
LABEL_626:
        }
          abort();
        __int128 v134 = 0x8E38E38E38E38E39LL * ((uint64_t)(v130 - (void)v132) >> 2);
        if (2 * v134 > v133) {
          __int128 v133 = 2 * v134;
        }
        if (v134 >= 0x38E38E38E38E38ELL) {
          int64_t v135 = 0x71C71C71C71C71CLL;
        }
        else {
          int64_t v135 = v133;
        }
        if (v135)
        {
          if (v135 > 0x71C71C71C71C71CLL) {
LABEL_627:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          v136 = (char *)operator new(36 * v135);
        }

        else
        {
          v136 = 0LL;
        }

        uint64_t v137 = &v136[4 * (v142 - v132)];
        *(_DWORD *)uint64_t v137 = v399;
        *((_DWORD *)v137 + 1) = (_DWORD)v4;
        *((void *)v137 + 1) = v111;
        *((void *)v137 + 2) = v112;
        *((_DWORD *)v137 + 6) = v406;
        *((_DWORD *)v137 + 7) = v402;
        v137[32] = v113;
        *(_WORD *)(v137 + 33) = 0;
        v137[35] = 0;
        uint64_t v138 = v137;
        if (v142 == v132)
        {
          uint64_t v92 = __s1;
          uint64_t v91 = v389;
        }

        else
        {
          uint64_t v92 = __s1;
          uint64_t v91 = v389;
          do
          {
            uint64_t v139 = *(_OWORD *)(v142 - 9);
            uint64_t v140 = *(_OWORD *)(v142 - 5);
            *((_DWORD *)v138 - 1) = *(v142 - 1);
            *(_OWORD *)(v138 - 20) = v140;
            *(_OWORD *)(v138 - 36) = v139;
            v138 -= 36;
            v142 -= 9;
          }

          while (v142 != v132);
          uint64_t v142 = (_DWORD *)v88[3];
        }

        unsigned int v131 = v137 + 36;
        v88[3] = v138;
        v88[4] = v137 + 36;
        v88[5] = &v136[36 * v135];
        if (v142) {
          operator delete(v142);
        }
        uint64_t v90 = v392;
      }

      else
      {
        *uint64_t v142 = v399;
        v142[1] = (_DWORD)v4;
        *((void *)v142 + 1) = v111;
        *((void *)v142 + 2) = v112;
        v142[6] = v406;
        v142[7] = v402;
        *((_BYTE *)v142 + 32) = v113;
        *(_WORD *)((char *)v142 + 33) = 0;
        unsigned int v131 = v142 + 9;
        *((_BYTE *)v142 + 35) = 0;
        uint64_t v90 = v392;
        uint64_t v92 = __s1;
        uint64_t v91 = v389;
      }

      v88[4] = v131;
      goto LABEL_254;
    }

  a3[10] += 96LL;
  return result;
}

void sub_114D04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        unint64_t v6 = v4;
        std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }

      while (v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::vector<std::unordered_map<long,std::unordered_map<unsigned int,DrawDurationInfo>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = (void *)*(v4 - 3);
        if (v6)
        {
          do
          {
            uint64_t v7 = (void *)*v6;
            std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::~__hash_table((uint64_t)(v6 + 3));
            operator delete(v6);
            unint64_t v6 = v7;
          }

          while (v7);
        }

        uint64_t v9 = (void *)*(v4 - 5);
        v4 -= 5;
        uint64_t v8 = v9;
        *unint64_t v4 = 0LL;
        if (v9) {
          operator delete(v8);
        }
      }

      while (v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::__hash_table<std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::pair<unsigned long long,unsigned long long>>>( uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = operator new(0x28uLL);
  *uint64_t v12 = 0LL;
  v12[1] = v6;
  *((_OWORD *)v12 + 1) = *(_OWORD *)a3;
  v12[4] = *(void *)(a3 + 16);
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *uint64_t v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }

  *uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_11511C(_Unwind_Exception *a1)
{
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::~__hash_table( uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      unint64_t v4 = (void *)v2[4];
      if (v4)
      {
        v2[5] = v4;
        operator delete(v4);
      }

      operator delete(v2);
      unsigned int v2 = v3;
    }

    while (v3);
  }

  unint64_t v5 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void __copy_helper_block_ea8_112c101_ZTSNSt3__14pairIP21ShaderBinaryStatsInfoNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEE( std::string *a1, uint64_t a2)
{
  a1[4].__r_.__value_.__l.__cap_ = *(void *)(a2 + 112);
  unsigned int v2 = a1 + 5;
  if (*(char *)(a2 + 143) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 120), *(void *)(a2 + 128));
  }

  else
  {
    __int128 v3 = *(_OWORD *)(a2 + 120);
    v2->__r_.__value_.__l.__cap_ = *(void *)(a2 + 136);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }

void __destroy_helper_block_ea8_112c101_ZTSNSt3__14pairIP21ShaderBinaryStatsInfoNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEE( uint64_t a1)
{
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<long,std::unordered_map<unsigned int,DrawDurationInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long,std::unordered_map<unsigned int,DrawDurationInfo>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }

void std::vector<ShaderProfilerUSCSampleInfo>::__insert_with_size[abi:nn180100]<std::__wrap_iter<ShaderProfilerUSCSampleInfo*>,std::__wrap_iter<ShaderProfilerUSCSampleInfo*>>( uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  unint64_t v6 = __src;
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - v10) >> 3)) < a5)
  {
    unint64_t v11 = *(char **)a1;
    unint64_t v12 = a5 - 0x3333333333333333LL * ((uint64_t)(v10 - *(void *)a1) >> 3);
    if (v12 > 0x666666666666666LL) {
      abort();
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((__dst - v11) >> 3);
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((v9 - (uint64_t)v11) >> 3);
    uint64_t v15 = 2 * v14;
    if (2 * v14 <= v12) {
      uint64_t v15 = v12;
    }
    if (v14 >= 0x333333333333333LL) {
      unint64_t v16 = 0x666666666666666LL;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v16);
    }
    else {
      uint64_t v17 = 0LL;
    }
    unint64_t v27 = v16 + 40 * v13;
    uint64_t v28 = 5 * a5;
    unsigned int v29 = (char *)(v27 + 40 * a5);
    uint64_t v30 = 8 * v28;
    unint64_t v31 = v27;
    do
    {
      __int128 v32 = *(_OWORD *)v6;
      __int128 v33 = *((_OWORD *)v6 + 1);
      *(void *)(v31 + 32) = *((void *)v6 + 4);
      *(_OWORD *)unint64_t v31 = v32;
      *(_OWORD *)(v31 + 16) = v33;
      v31 += 40LL;
      v6 += 40;
      v30 -= 40LL;
    }

    while (v30);
    unsigned int v34 = *(char **)a1;
    if (*(char **)a1 == __dst)
    {
      unint64_t v38 = v16 + 40 * v13;
    }

    else
    {
      BOOL v35 = __dst;
      do
      {
        __int128 v36 = *(_OWORD *)(v35 - 40);
        __int128 v37 = *(_OWORD *)(v35 - 24);
        unint64_t v38 = v27 - 40;
        *(void *)(v27 - 8) = *((void *)v35 - 1);
        *(_OWORD *)(v27 - 24) = v37;
        *(_OWORD *)(v27 - 40) = v36;
        v35 -= 40;
        v27 -= 40LL;
      }

      while (v35 != v34);
    }

    unint64_t v39 = v16 + 40 * v17;
    BOOL v40 = *(_BYTE **)(a1 + 8);
    uint64_t v41 = v40 - __dst;
    if (v40 != __dst) {
      memmove(v29, __dst, v40 - __dst);
    }
    __int128 v42 = *(char **)a1;
    *(void *)a1 = v38;
    *(void *)(a1 + 8) = &v29[v41];
    *(void *)(a1 + 16) = v39;
    if (v42) {
      operator delete(v42);
    }
    return;
  }

  uint64_t v18 = v10 - (void)__dst;
  if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (void)__dst) >> 3)) >= a5)
  {
    uint64_t v19 = &__src[40 * a5];
    unint64_t v21 = *(char **)(a1 + 8);
LABEL_17:
    __int128 v22 = &__dst[40 * a5];
    uint64_t v23 = &v21[-40 * a5];
    uint64_t v24 = v21;
    if ((unint64_t)v23 < v10)
    {
      uint64_t v24 = v21;
      do
      {
        __int128 v25 = *(_OWORD *)v23;
        __int128 v26 = *((_OWORD *)v23 + 1);
        *((void *)v24 + 4) = *((void *)v23 + 4);
        *(_OWORD *)uint64_t v24 = v25;
        *((_OWORD *)v24 + 1) = v26;
        v23 += 40;
        v24 += 40;
      }

      while ((unint64_t)v23 < v10);
    }

    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&__dst[40 * a5], __dst, v21 - v22);
    }
    if (v19 != v6) {
      memmove(__dst, v6, v19 - v6);
    }
    return;
  }

  uint64_t v19 = &__src[8 * ((uint64_t)(v10 - (void)__dst) >> 3)];
  int64_t v20 = a4 - v19;
  if (a4 != v19) {
    memmove(*(void **)(a1 + 8), &__src[8 * ((uint64_t)(v10 - (void)__dst) >> 3)], a4 - v19);
  }
  unint64_t v21 = (char *)(v10 + v20);
  *(void *)(a1 + 8) = v10 + v20;
  if (v18 >= 1) {
    goto LABEL_17;
  }
}

void *__copy_helper_block_ea8_80c53_ZTSNSt3__16vectorINS_4pairIjjEENS_9allocatorIS2_EEEE( uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  unsigned int v2 = (void *)(a1 + 80);
  v2[2] = 0LL;
  return std::vector<std::pair<unsigned int,unsigned int>>::__init_with_size[abi:nn180100]<std::pair<unsigned int,unsigned int>*,std::pair<unsigned int,unsigned int>*>( v2,  *(uint64_t **)(a2 + 80),  *(uint64_t **)(a2 + 88),  (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 3);
}

void __destroy_helper_block_ea8_80c53_ZTSNSt3__16vectorINS_4pairIjjEENS_9allocatorIS2_EEEE(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 88) = v2;
    operator delete(v2);
  }

void ProfileEventHelper::~ProfileEventHelper(ProfileEventHelper *this)
{
  unint64_t v4 = (void **)((char *)this + 432);
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&v4);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)this + 392);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)this + 352);
  std::deque<ProfileEvent>::~deque[abi:nn180100]((void *)this + 38);
  unsigned int v2 = (void *)*((void *)this + 35);
  if (v2)
  {
    *((void *)this + 36) = v2;
    operator delete(v2);
  }

  __int128 v3 = (void *)*((void *)this + 32);
  if (v3)
  {
    *((void *)this + 33) = v3;
    operator delete(v3);
  }

  std::deque<unsigned int>::~deque[abi:nn180100]((uint64_t)this + 200);
  std::deque<unsigned int>::~deque[abi:nn180100]((uint64_t)this + 152);
  std::deque<ProfileEvent>::~deque[abi:nn180100]((void *)this + 13);
  std::deque<ProfileEvent>::~deque[abi:nn180100]((void *)this + 7);
  std::deque<ProfileEvent>::~deque[abi:nn180100]((void *)this + 1);
}

void ProfileEventHelper::ProcessQueue(ProfileEventHelper *this)
{
  unsigned int v2 = (void **)*((void *)this + 14);
  uint64_t v3 = *((void *)this + 15);
  *((void *)this + 18) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *((void *)this + 15);
      unsigned int v2 = (void **)(*((void *)this + 14) + 8LL);
      *((void *)this + 14) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 512LL;
  }

  *((void *)this + 17) = v6;
LABEL_8:
  unsigned int v7 = *(_DWORD *)this;
  std::deque<unsigned int>::push_front((char **)this + 19, (_DWORD *)this + 124);
  std::deque<unsigned int>::push_front((char **)this + 25, (_DWORD *)this + 125);
  std::deque<ProfileEvent>::operator=((void *)this + 7, (void *)this + 1);
  uint64_t v9 = *((void *)this + 12);
  if (v9)
  {
    unint64_t v10 = (char *)this + 456;
    unint64_t v11 = (char *)this + 352;
    do
    {
      ++*(_DWORD *)this;
      uint64_t v12 = *(void *)(*(void *)(*((void *)this + 8) + ((*((void *)this + 11) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                      + 8 * (*((void *)this + 11) & 0x1FFLL));
      ++*((void *)this + 11);
      *((void *)this + 12) = v9 - 1;
      std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 56);
      if (v12 >> 28)
      {
        unsigned int v13 = v12 >> 28;
        unsigned int v14 = (v12 >> 28) - 3;
        if (v14 >= 6)
        {
          if (v13 == 2)
          {
            for (uint64_t i = (void *)*((void *)this + 54); i != *((void **)this + 55); i += 3)
            {
              __int128 v26 = (_DWORD *)*i;
              if (*i != i[1] && *v26 >> 28 == 1)
              {
                std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)v11,  v26[1],  v26[1]);
                *(_DWORD *)void *i = *(_DWORD *)*i & 0xFFFFFFF | 0x20000000;
                *(_DWORD *)(*i + 4LL) = *(_DWORD *)this;
                break;
              }
            }
          }

          else if (v13 == 1)
          {
            uint64_t v19 = *(unsigned int *)this;
            unsigned int v18 = *((_DWORD *)this + 1);
            *((_DWORD *)this + 1) = v18 + 1;
            int64_t v20 = (void **)(*((void *)this + 54) + 24LL * v18);
            __int128 v22 = v20 + 1;
            unint64_t v21 = (unint64_t *)v20[1];
            unint64_t v23 = (unint64_t)v20[2];
            if ((unint64_t)v21 >= v23)
            {
              uint64_t v27 = ((char *)v21 - (_BYTE *)*v20) >> 3;
              if ((unint64_t)(v27 + 1) >> 61) {
LABEL_110:
              }
                abort();
              uint64_t v28 = v23 - (void)*v20;
              uint64_t v29 = v28 >> 2;
              else {
                unint64_t v30 = v29;
              }
              if (v30) {
                unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v30);
              }
              else {
                uint64_t v31 = 0LL;
              }
              __int128 v32 = (unint64_t *)(v30 + 8 * v27);
              *__int128 v32 = v12 | (unint64_t)(v19 << 32);
              uint64_t v24 = v32 + 1;
              __int128 v33 = (char *)*v22;
              unsigned int v34 = (char *)*v20;
              if (*v22 == *v20)
              {
                unint64_t v10 = (char *)this + 456;
              }

              else
              {
                unint64_t v10 = (char *)this + 456;
                do
                {
                  unint64_t v35 = *((void *)v33 - 1);
                  v33 -= 8;
                  *--__int128 v32 = v35;
                }

                while (v33 != v34);
                __int128 v33 = (char *)*v20;
              }

              *int64_t v20 = v32;
              char *v22 = v24;
              v20[2] = (void *)(v30 + 8 * v31);
              if (v33) {
                operator delete(v33);
              }
            }

            else
            {
              unint64_t *v21 = v12 | (unint64_t)(v19 << 32);
              uint64_t v24 = v21 + 1;
              unint64_t v10 = (char *)this + 456;
            }

            unint64_t v11 = (char *)this + 352;
            char *v22 = v24;
          }
        }

        else
        {
          uint64_t v15 = (void *)(*((void *)this + 54) + 24LL * v14);
          if (*v15 == v15[1])
          {
            std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)v11,  *(_DWORD *)this,  *(_DWORD *)this);
          }

          else
          {
            int v16 = *(_DWORD *)(*v15 + 4LL);
            LODWORD(v103) = v12 >> 28;
            *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v10,  v13,  &v103)
            + 5) = v16;
            uint64_t v17 = *((void *)this + 54) + 24LL * v14;
            *(void *)(v17 + 8) -= 8LL;
          }
        }
      }

      uint64_t v9 = *((void *)this + 12);
    }

    while (v9);
  }

  uint64_t v36 = 0LL;
  unint64_t v100 = (int64x2_t *)((char *)this + 104);
  do
  {
    __int128 v37 = (void *)(*((void *)this + 54) + v36);
    if (*v37 != v37[1]) {
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)this + 352,  *(_DWORD *)(*v37 + 4LL),  *(_DWORD *)(*v37 + 4LL));
    }
    v36 += 24LL;
  }

  while (v36 != 144);
  unint64_t v38 = *((void *)this + 35);
  *((void *)this + 36) = v38;
  *((_DWORD *)this + 1) = 0;
  uint64_t v39 = *((void *)this + 6);
  if (v39)
  {
    uint64_t v40 = 0LL;
    int v41 = 0;
    unint64_t v101 = (char *)this + 392;
    while (1)
    {
      unint64_t v42 = *((void *)this + 5);
      ++v7;
      uint64_t v103 = *(void *)(*(void *)(*((void *)this + 2) + ((v42 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v42 & 0x1FF));
      unsigned int v43 = v103;
      *((void *)this + 5) = v42 + 1;
      *((void *)this + 6) = v39 - 1;
      std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 8);
      if ((v43 & 0xF0000000) == 0x10000000)
      {
        ++*((_DWORD *)this + 1);
        if (!std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)this + 44,  v7)) {
          goto LABEL_63;
        }
      }

      else if (v43 >> 28 {
             && !std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)this + 44,  v7))
      }
      {
        if ((v43 & 0xF0000000) == 0x20000000 && *((_DWORD *)this + 1) == 6)
        {
          LODWORD(v103) = v43 & 0xFFFFFFF | 0x80000000;
          unsigned int v43 = v103;
        }

LABEL_63:
        unint64_t v45 = *((void *)this + 18);
        uint64_t v44 = v43 & 0xFFFFFFF;
        if (v45) {
          v41 += (v44 - v40) / v45;
        }
        int v102 = v43 & 0xFFFFFFF;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v101,  v43 & 0xFFFFFFF,  &v102)
        + 5) = v41;
        unsigned int v46 = v43 >> 28;
        unsigned int v47 = (v43 >> 28) - 3;
        if (v47 >= 6)
        {
          if (v46 - 1 <= 1)
          {
            HIDWORD(v103) = v7;
            std::deque<ProfileEvent>::emplace_back<ProfileEvent&>(v100, &v103);
          }
        }

        else
        {
          unsigned int v48 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)this + 57,  v46);
          if (v48)
          {
            uint64_t v49 = *((void *)this + 14);
            if (*((void *)this + 15) != v49)
            {
              unint64_t v50 = *((void *)this + 17);
              BOOL v51 = (char **)(v49 + 8 * (v50 >> 9));
              uint64_t v52 = *v51;
              unsigned int v53 = &(*v51)[8 * (v50 & 0x1FF)];
              uint64_t v54 = *(void *)(v49 + (((*((void *)this + 18) + v50) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                  + 8 * ((*((void *)this + 18) + v50) & 0x1FF);
              if (v53 != (char *)v54)
              {
                while (*((_DWORD *)v53 + 1) != *((_DWORD *)v48 + 5))
                {
                  v53 += 8;
                  if (v53 - v52 == 4096)
                  {
                    unsigned int v55 = v51[1];
                    ++v51;
                    uint64_t v52 = v55;
                    unsigned int v53 = v55;
                  }
                }

                unsigned int v56 = *(_DWORD *)v53;
                std::deque<ProfileEvent>::erase(v100, (char *)v51, (uint64_t)v53);
                int v102 = v56 & 0xFFFFFFF;
                int v57 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v101,  v56 & 0xFFFFFFF,  &v102)
                      + 5);
                int v102 = v44;
                unsigned int v58 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v101,  v44,  &v102);
                unint64_t v59 = *((void *)this + 24);
                uint64_t v60 = (*((unsigned int *)this + 125) | (v59 << 36)) & 0x3000000FFFLL;
                if (v59 < 2 || (unint64_t v61 = *((void *)this + 30), v61 < 2))
                {
                  int v65 = 0;
                  int v62 = 0;
                }

                else
                {
                  int v62 = 0;
                  uint64_t v63 = *((void *)this + 23);
                  uint64_t v64 = *((void *)this + 20);
                  uint64_t v66 = *((void *)this + 29);
                  uint64_t v67 = *((void *)this + 26);
                  v60 |= (unint64_t)(*(_DWORD *)(*(void *)(v67
                  if (v59 >= 3 && v61 != 2)
                  {
                    v60 |= (unint64_t)(*(_DWORD *)(*(void *)(v67
                  }
                }

                int v68 = *((_DWORD *)v58 + 5) - v57;
                int v70 = *((_DWORD *)this + 62);
                int v69 = *((_DWORD *)this + 63);
                int v71 = *((_DWORD *)this + 124);
                if (v70 == -1) {
                  BOOL v72 = v56 >> 28 == 2;
                }
                else {
                  BOOL v72 = v62;
                }
                unint64_t v73 = *((void *)this + 36);
                unint64_t v74 = *((void *)this + 37);
                if (v73 >= v74)
                {
                  uint64_t v76 = *((void *)this + 35);
                  unint64_t v77 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v73 - v76) >> 3);
                  unint64_t v78 = v77 + 1;
                  if (v77 + 1 > 0x666666666666666LL) {
                    goto LABEL_110;
                  }
                  unint64_t v79 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v74 - v76) >> 3);
                  if (2 * v79 > v78) {
                    unint64_t v78 = 2 * v79;
                  }
                  if (v79 >= 0x333333333333333LL) {
                    unint64_t v80 = 0x666666666666666LL;
                  }
                  else {
                    unint64_t v80 = v78;
                  }
                  if (v80)
                  {
                    uint64_t v99 = v60;
                    int v97 = v68;
                    int v98 = v65;
                    BOOL v95 = v72;
                    int v96 = *((_DWORD *)this + 124);
                    int v94 = *((_DWORD *)this + 63);
                    unint64_t v80 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v80);
                    int v69 = v94;
                    BOOL v72 = v95;
                    int v71 = v96;
                    int v68 = v97;
                    int v65 = v98;
                    uint64_t v60 = v99;
                  }

                  else
                  {
                    uint64_t v81 = 0LL;
                  }

                  unint64_t v82 = v80 + 40 * v77;
                  *(_DWORD *)unint64_t v82 = v70;
                  *(_DWORD *)(v82 + 4) = v69;
                  *(_DWORD *)(v82 + 8) = v68;
                  *(_DWORD *)(v82 + 12) = v71;
                  *(_DWORD *)(v82 + 16) = v65;
                  *(_DWORD *)(v82 + 20) = v72;
                  *(void *)(v82 + 24) = v60;
                  *(_DWORD *)(v82 + 32) = v47;
                  *(_DWORD *)(v82 + 36) = 0;
                  unsigned int v84 = (char *)*((void *)this + 35);
                  unsigned int v83 = (char *)*((void *)this + 36);
                  unint64_t v85 = v82;
                  if (v83 != v84)
                  {
                    do
                    {
                      __int128 v8 = *(_OWORD *)(v83 - 40);
                      __int128 v86 = *(_OWORD *)(v83 - 24);
                      *(void *)(v85 - 8) = *((void *)v83 - 1);
                      *(_OWORD *)(v85 - 24) = v86;
                      *(_OWORD *)(v85 - 40) = v8;
                      v85 -= 40LL;
                      v83 -= 40;
                    }

                    while (v83 != v84);
                    unsigned int v83 = (char *)*((void *)this + 35);
                  }

                  unint64_t v75 = v82 + 40;
                  *((void *)this + 35) = v85;
                  *((void *)this + 36) = v82 + 40;
                  *((void *)this + 37) = v80 + 40 * v81;
                  if (v83) {
                    operator delete(v83);
                  }
                }

                else
                {
                  *(_DWORD *)unint64_t v73 = v70;
                  *(_DWORD *)(v73 + 4) = v69;
                  *(_DWORD *)(v73 + 8) = v68;
                  *(_DWORD *)(v73 + 12) = v71;
                  *(_DWORD *)(v73 + 16) = v65;
                  *(_DWORD *)(v73 + 20) = v72;
                  *(void *)(v73 + 24) = v60;
                  unint64_t v75 = v73 + 40;
                  *(_DWORD *)(v73 + 32) = v47;
                  *(_DWORD *)(v73 + 36) = 0;
                }

                *((void *)this + 36) = v75;
              }
            }
          }
        }

        goto LABEL_58;
      }

      uint64_t v44 = v40;
LABEL_58:
      uint64_t v39 = *((void *)this + 6);
      uint64_t v40 = v44;
      if (!v39)
      {
        uint64_t v87 = *((void *)this + 35);
        unint64_t v38 = *((void *)this + 36);
        goto LABEL_103;
      }
    }
  }

  uint64_t v87 = v38;
LABEL_103:
  unint64_t v88 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v38 - v87) >> 3));
  if (v38 == v87) {
    uint64_t v89 = 0LL;
  }
  else {
    uint64_t v89 = v88;
  }
  std::__introsort<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*,false>( v87,  v38,  v89,  1,  *(double *)&v8);
  uint64_t v90 = (char *)*((void *)this + 35);
  uint64_t v91 = (char *)*((void *)this + 36);
  if (v90 != v91)
  {
    int v92 = 0;
    uint64_t v93 = *((void *)this + 35);
    do
    {
      *(_DWORD *)(v93 + 32) = v92++;
      v93 += 40LL;
    }

    while ((char *)v93 != v91);
  }

  std::vector<ShaderProfilerUSCSampleInfo>::__insert_with_size[abi:nn180100]<std::__wrap_iter<ShaderProfilerUSCSampleInfo*>,std::__wrap_iter<ShaderProfilerUSCSampleInfo*>>( (uint64_t)this + 256,  *((char **)this + 33),  v90,  v91,  0xCCCCCCCCCCCCCCCDLL * ((v91 - v90) >> 3));
}

            a2 *= 2;
            return a2;
          }
        }

        if (a1 <= 1815162993) {
          break;
        }
        if (a1 != 1882468912)
        {
          if (a1 == 1815162994) {
            goto LABEL_67;
          }
          unint64_t v4 = 1815491698;
LABEL_56:
          if (a1 != v4) {
            return 0;
          }
LABEL_68:
          a2 *= 8;
          return a2;
        }
      }

      if (a1 <= 1380411456) {
        break;
      }
      if (a1 != 1751527984)
      {
        if (a1 == 1380411457) {
          goto LABEL_68;
        }
        uint64_t v6 = 1667838256;
LABEL_66:
        if (a1 == v6) {
          goto LABEL_67;
        }
        return 0;
      }
    }

    if (a1 <= 846624101)
    {
      if (a1 > 828584239)
      {
        if (a1 > 843264103)
        {
          if (a1 == 843264104 || a1 == 843264310) {
            goto LABEL_67;
          }
          if (a1 != 845361456) {
            return 0;
          }
          uint64_t v5 = 2 * a2 + 2;
        }

        else
        {
          if (a1 != 828584240)
          {
            if (a1 == 843264056) {
              goto LABEL_63;
            }
            unint64_t v4 = 843264102;
            goto LABEL_56;
          }

          uint64_t v5 = a2 + 2;
        }

        return (2 * ((2863311531u * (unint64_t)v5) >> 32)) & 0xFFFFFFFC;
      }

      if (a1 > 826486885)
      {
        if (a1 == 826486886) {
          goto LABEL_67;
        }
        if (a1 == 826486888) {
          goto LABEL_63;
        }
        uint64_t v3 = 826487094;
LABEL_62:
        if (a1 == v3) {
          goto LABEL_63;
        }
        return 0;
      }

      if (a1 == 24)
      {
        a2 *= 3;
        return a2;
      }

      if (a1 == 32) {
        goto LABEL_67;
      }
      unsigned int v2 = 826486840;
LABEL_46:
      if (a1 == v2) {
        return a2;
      }
      return 0;
    }

    if (a1 > 1094862673) {
      break;
    }
    if (a1 > 875704437)
    {
      if (a1 != 875704438 && a1 != 875836518 && a1 != 875836534) {
        return 0;
      }
    }

    else
    {
      if (a1 == 846624102 || a1 == 846624121) {
        goto LABEL_63;
      }
      if (a1 != 875704422) {
        return 0;
      }
    }

    a1 = 826486840;
  }

  if (a1 <= 1278226533)
  {
    if (a1 == 1094862674 || a1 == 1111970369) {
      goto LABEL_67;
    }
    unsigned int v2 = 1278226488;
    goto LABEL_46;
  }

  if (a1 > 1278226741)
  {
    if (a1 == 1278226742) {
      goto LABEL_63;
    }
    uint64_t v6 = 1380401729;
    goto LABEL_66;
  }

  if (a1 != 1278226534)
  {
    uint64_t v3 = 1278226536;
    goto LABEL_62;
  }

void ProfileEventHelper::ProcessQueueLegacy(ProfileEventHelper *this)
{
  unsigned int v2 = (void **)*((void *)this + 14);
  uint64_t v3 = *((void *)this + 15);
  *((void *)this + 18) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *((void *)this + 15);
      unsigned int v2 = (void **)(*((void *)this + 14) + 8LL);
      *((void *)this + 14) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 512LL;
  }

  *((void *)this + 17) = v6;
LABEL_8:
  std::deque<unsigned int>::push_front((char **)this + 19, (_DWORD *)this + 124);
  std::deque<unsigned int>::push_front((char **)this + 25, (_DWORD *)this + 125);
  std::deque<ProfileEvent>::operator=((void *)this + 7, (void *)this + 1);
  *(_DWORD *)this = 0;
  for (uint64_t i = *((void *)this + 12); i; uint64_t i = *((void *)this + 12))
  {
    ++*(_DWORD *)this;
    unint64_t v8 = *((void *)this + 11);
    uint64_t v70 = *(void *)(*(void *)(*((void *)this + 8) + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF));
    unsigned int v9 = v70;
    *((void *)this + 11) = v8 + 1;
    *((void *)this + 12) = i - 1;
    std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 56);
    if (v9 >> 28)
    {
      switch(v9 >> 28)
      {
        case 1u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
          HIDWORD(v70) = *(_DWORD *)this;
          std::deque<ProfileEvent>::emplace_back<ProfileEvent&>((void *)this + 38, &v70);
          break;
        case 2u:
          uint64_t v10 = *((void *)this + 39);
          if (*((void *)this + 40) != v10)
          {
            unint64_t v11 = *((void *)this + 42);
            uint64_t v12 = (int **)(v10 + 8 * (v11 >> 9));
            unsigned int v13 = *v12;
            unsigned int v14 = &(*v12)[2 * (v11 & 0x1FF)];
            uint64_t v15 = *(void *)(v10 + (((*((void *)this + 43) + v11) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                + 8 * ((*((void *)this + 43) + v11) & 0x1FF);
            while (v14 != (int *)v15)
            {
              if (*v14 >> 28 == 1)
              {
                std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)this + 352,  v14[1],  v14[1]);
                *unsigned int v14 = *v14 & 0xFFFFFFF | 0x20000000;
                goto LABEL_12;
              }

              v14 += 2;
              if ((char *)v14 - (char *)v13 == 4096)
              {
                int v16 = v12[1];
                ++v12;
                unsigned int v13 = v16;
                unsigned int v14 = v16;
              }
            }
          }

          break;
        case 3u:
          uint64_t v17 = *((void *)this + 43);
          if (v17)
          {
            ++*((void *)this + 42);
            *((void *)this + 43) = v17 - 1;
            std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 304);
          }

          break;
        default:
          continue;
      }
    }

void std::deque<ProfileEvent>::emplace_back<unsigned int &,unsigned int &>( void *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[1];
  uint64_t v8 = ((v6 - v7) << 6) - 1;
  if (v6 == v7) {
    uint64_t v8 = 0LL;
  }
  unint64_t v9 = a1[5] + a1[4];
  if (v8 == v9)
  {
    std::deque<ProfileEvent>::__add_back_capacity(a1);
    uint64_t v7 = a1[1];
    unint64_t v9 = a1[5] + a1[4];
  }

  uint64_t v10 = (int *)(*(void *)(v7 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF));
  int *v10 = *a2 & 0xFFFFFFF | (*a3 << 28);
  v10[1] = -1;
  ++a1[5];
}

void std::deque<ProfileEvent>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    a1[4] = v4;
    uint64_t v5 = (void *)a1[1];
    uint64_t v6 = (char *)a1[2];
    uint64_t v9 = *v5;
    uint64_t v7 = (char *)(v5 + 1);
    uint64_t v8 = v9;
    a1[1] = v7;
    if (v6 != (char *)a1[3])
    {
LABEL_31:
      *(void *)uint64_t v6 = v8;
      a1[2] += 8LL;
      return;
    }

    uint64_t v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      else {
        unint64_t v28 = (uint64_t)&v6[-*a1] >> 2;
      }
      uint64_t v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v28);
      unsigned int v30 = &v29[8 * (v28 >> 2)];
      __int128 v32 = &v29[8 * v31];
      unint64_t v33 = (uint64_t *)a1[1];
      uint64_t v6 = v30;
      uint64_t v34 = a1[2] - (void)v33;
      if (v34)
      {
        uint64_t v6 = &v30[v34 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v35 = 8 * (v34 >> 3);
        int v36 = &v29[8 * (v28 >> 2)];
        do
        {
          uint64_t v37 = *v33++;
          *(void *)int v36 = v37;
          v36 += 8;
          v35 -= 8LL;
        }

        while (v35);
      }

      goto LABEL_28;
    }

void sub_1166C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::deque<unsigned int>::push_front(char **a1, _DWORD *a2)
{
  unint64_t v4 = (unint64_t)a1[4];
  if (!v4)
  {
    uint64_t v5 = a1[1];
    uint64_t v6 = a1[2];
    uint64_t v7 = ((v6 - v5) << 7) - 1;
    if (v6 == v5) {
      uint64_t v7 = 0LL;
    }
    if ((unint64_t)(v7 - (void)a1[5]) < 0x400)
    {
      uint64_t v8 = a1[3];
      uint64_t v9 = *a1;
      uint64_t v10 = v8 - *a1;
      if (v6 - v5 >= (unint64_t)v10)
      {
        if (v8 == v9) {
          unint64_t v11 = 1LL;
        }
        else {
          unint64_t v11 = v10 >> 2;
        }
        uint64_t v47 = a1 + 3;
        int v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v11);
        uint64_t v44 = v43;
        uint64_t v45 = v43;
        BOOL v46 = &v43[8 * v12];
        uint64_t v42 = operator new(0x1000uLL);
        std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v43, &v42);
        uint64_t v14 = (uint64_t *)a1[1];
        uint64_t v13 = a1[2];
        uint64_t v15 = v45;
        while (v14 != (uint64_t *)v13)
        {
          if (v15 == v46)
          {
            uint64_t v17 = v43;
            uint64_t v16 = v44;
            if (v44 <= v43)
            {
              if (v15 == v43) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v15 - v43) >> 2;
              }
              uint64_t v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v23);
              uint64_t v27 = v15 - v16;
              BOOL v26 = v15 == v16;
              uint64_t v15 = &v24[8 * (v23 >> 2)];
              if (!v26)
              {
                uint64_t v15 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                uint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v16;
                  v16 += 8;
                  *(void *)uint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              int v43 = v24;
              uint64_t v44 = &v24[8 * (v23 >> 2)];
              uint64_t v45 = v15;
              BOOL v46 = &v24[8 * v25];
              if (v17) {
                operator delete(v17);
              }
            }

            else
            {
              uint64_t v18 = (v44 - v43) >> 3;
              if (v18 >= -1) {
                uint64_t v19 = v18 + 1;
              }
              else {
                uint64_t v19 = v18 + 2;
              }
              unint64_t v20 = &v44[-8 * (v19 >> 1)];
              int64_t v21 = v15 - v44;
              if (v15 != v44)
              {
                memmove(&v44[-8 * (v19 >> 1)], v44, v15 - v44);
                uint64_t v15 = v16;
              }

              uint64_t v22 = &v15[-8 * (v19 >> 1)];
              uint64_t v15 = &v20[v21];
              uint64_t v44 = v22;
              uint64_t v45 = &v20[v21];
            }
          }

          uint64_t v31 = *v14++;
          *(void *)uint64_t v15 = v31;
          uint64_t v15 = v45 + 8;
          v45 += 8;
          uint64_t v13 = a1[2];
        }

        __int128 v32 = *a1;
        unint64_t v33 = v44;
        *a1 = v43;
        a1[1] = v33;
        uint64_t v34 = v46;
        a1[2] = v15;
        a1[3] = v34;
        if (v15 - v33 == 8) {
          uint64_t v35 = 512LL;
        }
        else {
          uint64_t v35 = (uint64_t)(a1[4] + 1024);
        }
        a1[4] = (char *)v35;
        if (v32) {
          operator delete(v32);
        }
      }

      else
      {
        if (v5 == v9)
        {
          int v43 = (char *)operator new(0x1000uLL);
          std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(a1, &v43);
          int v36 = a1[2];
          int v43 = (char *)*((void *)v36 - 1);
          a1[2] = v36 - 8;
        }

        else
        {
          int v43 = (char *)operator new(0x1000uLL);
        }

        std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)a1, &v43);
        if (a1[2] - a1[1] == 8) {
          uint64_t v37 = 512LL;
        }
        else {
          uint64_t v37 = (uint64_t)(a1[4] + 1024);
        }
        a1[4] = (char *)v37;
      }
    }

    else
    {
      a1[4] = (_BYTE *)(&stru_3D8 + 40);
      int v43 = (char *)*((void *)v6 - 1);
      a1[2] = v6 - 8;
      std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)a1, &v43);
    }

    unint64_t v4 = (unint64_t)a1[4];
  }

  uint64_t v38 = a1[1];
  int v39 = &v38[8 * (v4 >> 10)];
  if (a1[2] == v38) {
    uint64_t v40 = 0LL;
  }
  else {
    uint64_t v40 = *(void *)v39 + 4 * (v4 & 0x3FF);
  }
  if (v40 == *(void *)v39) {
    uint64_t v40 = *((void *)v39 - 1) + 4096LL;
  }
  *(_DWORD *)(v40 - 4) = *a2;
  uint64_t v41 = (uint64_t)(a1[5] + 1);
  a1[4] = (char *)(v4 - 1);
  a1[5] = (char *)v41;
}

void sub_1169CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::deque<ProfileEvent>::operator=(void *a1, void *a2)
{
  if (a1 == a2) {
    return a1;
  }
  unint64_t v3 = a2[4];
  uint64_t v4 = a2[1];
  uint64_t v5 = (char *)(v4 + 8 * (v3 >> 9));
  if (a2[2] == v4)
  {
    uint64_t v6 = 0LL;
    uint64_t v9 = 0LL;
    uint64_t v8 = (char *)(v4 + 8 * ((a2[5] + v3) >> 9));
  }

  else
  {
    uint64_t v6 = (_BYTE *)(*(void *)v5 + 8 * (a2[4] & 0x1FFLL));
    unint64_t v7 = a2[5] + v3;
    uint64_t v8 = (char *)(v4 + 8 * (v7 >> 9));
    uint64_t v9 = *(void *)v8 + 8 * (v7 & 0x1FF);
  }

  if ((_BYTE *)v9 == v6)
  {
    unint64_t v10 = 0LL;
  }

  else
  {
    unint64_t v10 = ((v9 - *(void *)v8) >> 3) + ((v8 - v5) << 6) - ((uint64_t)&v6[-*(void *)v5] >> 3);
    unint64_t v11 = a1[5];
    if (v11 < v10)
    {
      uint64_t v13 = std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>::operator+[abi:nn180100]( v5,  (uint64_t)v6,  v11);
      uint64_t v14 = v12;
      uint64_t v15 = a1[1];
      if (a1[2] == v15) {
        uint64_t v16 = 0LL;
      }
      else {
        uint64_t v16 = *(void *)(v15 + 8LL * (a1[4] >> 9)) + 8 * (a1[4] & 0x1FFLL);
      }
      uint64_t v29 = (char *)(v15 + 8LL * (a1[4] >> 9));
      uint64_t v30 = v16;
      std::__for_each_segment[abi:nn180100]<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>>>( (uint64_t *)v5,  v6,  v13,  v12,  (uint64_t)&v29);
      std::deque<ProfileEvent>::__append_with_size[abi:nn180100]<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>>( a1,  v13,  v14,  v10 - a1[5]);
      return a1;
    }
  }

  uint64_t v17 = a1[1];
  uint64_t v18 = (char *)(v17 + 8LL * (a1[4] >> 9));
  if (a1[2] == v17) {
    uint64_t v19 = 0LL;
  }
  else {
    uint64_t v19 = *(void *)v18 + 8 * (a1[4] & 0x1FFLL);
  }
  unint64_t v20 = std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>::operator+[abi:nn180100]( v5,  (uint64_t)v6,  v10);
  uint64_t v29 = v18;
  uint64_t v30 = v19;
  std::__for_each_segment[abi:nn180100]<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>>>( (uint64_t *)v5,  v6,  v20,  v21,  (uint64_t)&v29);
  uint64_t v22 = a1[5];
  unint64_t v23 = a1[4] + v22;
  uint64_t v24 = a1[1];
  uint64_t v25 = (char *)(v24 + 8 * (v23 >> 9));
  if (a1[2] == v24) {
    uint64_t v26 = 0LL;
  }
  else {
    uint64_t v26 = *(void *)v25 + 8 * (v23 & 0x1FF);
  }
  if (v26 != v30)
  {
    uint64_t v27 = ((v26 - *(void *)v25) >> 3) + ((v25 - v29) << 6) - ((v30 - *(void *)v29) >> 3);
    if (v27 >= 1)
    {
      a1[5] = v22 - v27;
      while (std::deque<ProfileEvent>::__maybe_remove_back_spare[abi:nn180100](a1))
        ;
    }
  }

  return a1;
}

void std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100](uint64_t a1)
{
  if (*(void *)(a1 + 32) >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 512LL;
  }

void std::deque<ProfileEvent>::emplace_back<ProfileEvent&>(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = ((v4 - v5) << 6) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<ProfileEvent>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  *(void *)(*(void *)(v5 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v7 & 0x1FF)) = *a2;
  ++a1[5];
}

void *std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>::operator+[abi:nn180100]( void *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3 + ((a2 - *result) >> 3);
    if (v3 < 1) {
      result -= (unint64_t)(511 - v3) >> 9;
    }
    else {
      result += (unint64_t)v3 >> 9;
    }
  }

  return result;
}

double std::__for_each_segment[abi:nn180100]<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>>>( uint64_t *a1, _BYTE *a2, uint64_t *a3, _BYTE *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v19 = *(void **)a5;
    unint64_t v20 = *(char **)(a5 + 8);
    uint64_t v18 = a4;
  }

  else
  {
    uint64_t v8 = a1 + 1;
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,ProfileEvent const*,ProfileEvent const*,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>,0>( &v22,  a2,  (_BYTE *)(*a1 + 4096),  *(void **)a5,  *(char **)(a5 + 8));
    *(_OWORD *)a5 = v23;
    uint64_t v9 = *(void **)a5;
    for (uint64_t i = *(char **)(a5 + 8); v8 != a3; ++v8)
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = *v8;
      uint64_t v13 = (char *)*v9;
      while (1)
      {
        uint64_t v14 = v13 - i + 4096;
        if ((4096 - 8 * v11) >> 3 >= v14 >> 3) {
          uint64_t v15 = v14 >> 3;
        }
        else {
          uint64_t v15 = (4096 - 8 * v11) >> 3;
        }
        if (v15) {
          memmove(i, (const void *)(v12 + 8 * v11), 8 * v15);
        }
        v11 += v15;
        if (v11 == 512) {
          break;
        }
        uint64_t v16 = (char *)v9[1];
        ++v9;
        uint64_t v13 = v16;
        uint64_t i = v16;
      }

      i += 8 * v15;
      if ((char *)(*v9 + 4096LL) == i)
      {
        uint64_t v17 = (char *)v9[1];
        ++v9;
        uint64_t i = v17;
      }

      *(void *)a5 = v9;
      *(void *)(a5 + 8) = i;
    }

    a2 = (_BYTE *)*a3;
    uint64_t v18 = a4;
    uint64_t v19 = v9;
    unint64_t v20 = i;
  }

  std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,ProfileEvent const*,ProfileEvent const*,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>,0>( &v22,  a2,  v18,  v19,  v20);
  double result = *(double *)&v23;
  *(_OWORD *)a5 = v23;
  return result;
}

char *std::deque<ProfileEvent>::__append_with_size[abi:nn180100]<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>>( void *a1, void *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = (char *)a1[1];
  uint64_t v9 = (char *)a1[2];
  uint64_t v10 = v9 - v8;
  if (v9 == v8) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v12 = a1[4];
  uint64_t v13 = a1[5];
  unint64_t v14 = v13 + v12;
  unint64_t v15 = v11 - (v13 + v12);
  BOOL v16 = a4 >= v15;
  unint64_t v17 = a4 - v15;
  if (v17 != 0 && v16)
  {
    if (v9 == v8) {
      unint64_t v18 = v17 + 1;
    }
    else {
      unint64_t v18 = v17;
    }
    unint64_t v19 = v18 >> 9;
    if ((v18 & 0x1FF) != 0) {
      ++v19;
    }
    if (v19 >= v12 >> 9) {
      unint64_t v20 = v12 >> 9;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v19 <= v12 >> 9)
    {
      for (a1[4] = v12 - (v20 << 9); v20; --v20)
      {
        uint64_t v27 = (void *)a1[1];
        uint64_t v30 = *v27;
        uint64_t v28 = (char *)(v27 + 1);
        uint64_t v29 = v30;
        a1[1] = v28;
        if (v9 == (char *)a1[3])
        {
          uint64_t v31 = (uint64_t)&v28[-*a1];
          if ((unint64_t)v28 <= *a1)
          {
            else {
              unint64_t v39 = (uint64_t)&v9[-*a1] >> 2;
            }
            uint64_t v40 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v39);
            uint64_t v42 = &v40[8 * (v39 >> 2)];
            int v43 = (uint64_t *)a1[1];
            uint64_t v9 = v42;
            uint64_t v44 = a1[2] - (void)v43;
            if (v44)
            {
              uint64_t v9 = &v42[v44 & 0xFFFFFFFFFFFFFFF8LL];
              uint64_t v45 = 8 * (v44 >> 3);
              BOOL v46 = &v40[8 * (v39 >> 2)];
              do
              {
                uint64_t v47 = *v43++;
                *(void *)BOOL v46 = v47;
                v46 += 8;
                v45 -= 8LL;
              }

              while (v45);
            }

            unint64_t v48 = (char *)*a1;
            *a1 = v40;
            a1[1] = v42;
            a1[2] = v9;
            a1[3] = &v40[8 * v41];
            if (v48)
            {
              operator delete(v48);
              uint64_t v9 = (char *)a1[2];
            }
          }

          else
          {
            uint64_t v32 = v31 >> 3;
            BOOL v33 = v31 >> 3 < -1;
            uint64_t v34 = (v31 >> 3) + 2;
            if (v33) {
              uint64_t v35 = v34;
            }
            else {
              uint64_t v35 = v32 + 1;
            }
            int v36 = &v28[-8 * (v35 >> 1)];
            int64_t v37 = v9 - v28;
            if (v9 != v28)
            {
              memmove(&v28[-8 * (v35 >> 1)], v28, v9 - v28);
              uint64_t v9 = (char *)a1[1];
            }

            uint64_t v38 = &v9[-8 * (v35 >> 1)];
            uint64_t v9 = &v36[v37];
            a1[1] = v38;
            a1[2] = &v36[v37];
          }
        }

        *(void *)uint64_t v9 = v29;
        uint64_t v9 = (char *)(a1[2] + 8LL);
        a1[2] = v9;
      }
    }

    else
    {
      unint64_t v21 = v19 - v20;
      uint64_t v22 = a1[3] - *a1;
      if (v21 <= (v22 >> 3) - (v10 >> 3))
      {
        if (v21)
        {
          while (a1[3] != a1[2])
          {
            *(void *)&__int128 v106 = operator new(0x1000uLL);
            std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(a1, &v106);
            if (!--v21)
            {
              uint64_t v9 = (char *)a1[2];
              goto LABEL_78;
            }
          }

          for (uint64_t i = 0LL; i != v21; ++i)
          {
            *(void *)&__int128 v106 = operator new(0x1000uLL);
            std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)a1, &v106);
            uint64_t v9 = (char *)a1[2];
            else {
              uint64_t v71 = 512LL;
            }
            uint64_t v72 = v71 + a1[4];
            a1[4] = v72;
          }

          v20 += v21;
        }

        else
        {
LABEL_78:
          uint64_t v72 = a1[4];
        }

        for (a1[4] = v72 - (v20 << 9); v20; --v20)
        {
          unint64_t v73 = (void *)a1[1];
          uint64_t v76 = *v73;
          unint64_t v74 = (char *)(v73 + 1);
          uint64_t v75 = v76;
          a1[1] = v74;
          if (v9 == (char *)a1[3])
          {
            uint64_t v77 = (uint64_t)&v74[-*a1];
            if ((unint64_t)v74 <= *a1)
            {
              else {
                unint64_t v84 = (uint64_t)&v9[-*a1] >> 2;
              }
              unint64_t v85 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v84);
              uint64_t v87 = &v85[8 * (v84 >> 2)];
              unint64_t v88 = (uint64_t *)a1[1];
              uint64_t v9 = v87;
              uint64_t v89 = a1[2] - (void)v88;
              if (v89)
              {
                uint64_t v9 = &v87[v89 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v90 = 8 * (v89 >> 3);
                uint64_t v91 = &v85[8 * (v84 >> 2)];
                do
                {
                  uint64_t v92 = *v88++;
                  *(void *)uint64_t v91 = v92;
                  v91 += 8;
                  v90 -= 8LL;
                }

                while (v90);
              }

              uint64_t v93 = (char *)*a1;
              *a1 = v85;
              a1[1] = v87;
              a1[2] = v9;
              a1[3] = &v85[8 * v86];
              if (v93)
              {
                operator delete(v93);
                uint64_t v9 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v78 = v77 >> 3;
              BOOL v33 = v77 >> 3 < -1;
              uint64_t v79 = (v77 >> 3) + 2;
              if (v33) {
                uint64_t v80 = v79;
              }
              else {
                uint64_t v80 = v78 + 1;
              }
              uint64_t v81 = &v74[-8 * (v80 >> 1)];
              int64_t v82 = v9 - v74;
              if (v9 != v74)
              {
                memmove(&v74[-8 * (v80 >> 1)], v74, v9 - v74);
                uint64_t v9 = (char *)a1[1];
              }

              unsigned int v83 = &v9[-8 * (v80 >> 1)];
              uint64_t v9 = &v81[v82];
              a1[1] = v83;
              a1[2] = &v81[v82];
            }
          }

          *(void *)uint64_t v9 = v75;
          uint64_t v9 = (char *)(a1[2] + 8LL);
          a1[2] = v9;
        }
      }

      else
      {
        uint64_t v23 = v10 >> 3;
        if (v22 >> 2 <= v21 + (v10 >> 3)) {
          unint64_t v24 = v21 + v23;
        }
        else {
          unint64_t v24 = v22 >> 2;
        }
        unint64_t v25 = v23 - v20;
        unsigned int v108 = a1 + 3;
        if (v24) {
          unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v24);
        }
        else {
          uint64_t v26 = 0LL;
        }
        *(void *)&__int128 v106 = v24;
        *((void *)&v106 + 1) = v24 + 8 * v25;
        *(void *)&__int128 v107 = *((void *)&v106 + 1);
        *((void *)&v107 + 1) = v24 + 8 * v26;
        do
        {
          unsigned int v105 = operator new(0x1000uLL);
          std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v106, &v105);
          --v21;
        }

        while (v21);
        uint64_t v103 = v20 << 9;
        uint64_t v104 = v4;
        if (v20)
        {
          __int128 v49 = (void *)a1[1];
          __int128 v50 = (char *)v107;
          do
          {
            if (v50 == *((char **)&v107 + 1))
            {
              unint64_t v51 = (char *)*((void *)&v106 + 1);
              unint64_t v52 = (void *)v106;
              if (*((void *)&v106 + 1) <= (unint64_t)v106)
              {
                else {
                  unint64_t v58 = (uint64_t)&v50[-v106] >> 2;
                }
                unint64_t v59 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v58);
                uint64_t v62 = v50 - v51;
                BOOL v61 = v50 == v51;
                __int128 v50 = &v59[8 * (v58 >> 2)];
                if (!v61)
                {
                  __int128 v50 = &v59[8 * (v58 >> 2) + (v62 & 0xFFFFFFFFFFFFFFF8LL)];
                  uint64_t v63 = 8 * (v62 >> 3);
                  BOOL v64 = &v59[8 * (v58 >> 2)];
                  do
                  {
                    uint64_t v65 = *(void *)v51;
                    v51 += 8;
                    *(void *)BOOL v64 = v65;
                    v64 += 8;
                    v63 -= 8LL;
                  }

                  while (v63);
                }

                *(void *)&__int128 v106 = v59;
                *((void *)&v106 + 1) = &v59[8 * (v58 >> 2)];
                *(void *)&__int128 v107 = v50;
                *((void *)&v107 + 1) = &v59[8 * v60];
                if (v52) {
                  operator delete(v52);
                }
              }

              else
              {
                uint64_t v53 = (uint64_t)(*((void *)&v106 + 1) - v106) >> 3;
                if (v53 >= -1) {
                  uint64_t v54 = v53 + 1;
                }
                else {
                  uint64_t v54 = v53 + 2;
                }
                uint64_t v55 = *((void *)&v106 + 1) - 8 * (v54 >> 1);
                uint64_t v56 = &v50[-*((void *)&v106 + 1)];
                if (v50 != *((char **)&v106 + 1))
                {
                  memmove( (void *)(*((void *)&v106 + 1) - 8 * (v54 >> 1)),  *((const void **)&v106 + 1),  (size_t)&v50[-*((void *)&v106 + 1)]);
                  __int128 v50 = v51;
                }

                unint64_t v57 = &v50[-8 * (v54 >> 1)];
                __int128 v50 = &v56[v55];
                *((void *)&v106 + 1) = v57;
                *(void *)&__int128 v107 = &v56[v55];
              }
            }

            *(void *)__int128 v50 = *v49;
            __int128 v50 = (char *)(v107 + 8);
            *(void *)&__int128 v107 = v107 + 8;
            __int128 v49 = (void *)(a1[1] + 8LL);
            a1[1] = v49;
            --v20;
          }

          while (v20);
        }

        int v66 = (void *)a1[2];
        uint64_t v4 = v104;
        while (v66 != (void *)a1[1])
          std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)&v106, --v66);
        __int128 v69 = v106;
        __int128 v68 = v107;
        *(void *)&__int128 v106 = *a1;
        uint64_t v67 = (void *)v106;
        *((void *)&v106 + 1) = v66;
        *(_OWORD *)a1 = v69;
        *((_OWORD *)a1 + 1) = v68;
        a1[4] -= v103;
        if (v67)
        {
          operator delete(v67);
          uint64_t v9 = (char *)a1[2];
        }

        else
        {
          uint64_t v9 = (char *)v68;
        }
      }
    }

    uint64_t v13 = a1[5];
    uint64_t v8 = (char *)a1[1];
    unint64_t v14 = a1[4] + v13;
  }

  int v94 = &v8[8 * (v14 >> 9)];
  if (v9 == v8) {
    uint64_t v95 = 0LL;
  }
  else {
    uint64_t v95 = *(void *)v94 + 8 * (v14 & 0x1FF);
  }
  double result = (char *)std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>::operator+[abi:nn180100]( v94,  v95,  v4);
  while (v95 != v97)
  {
    int v98 = (void *)(v94 == result ? v97 : *(void *)v94 + 4096LL);
    if ((void *)v95 == v98)
    {
      int v98 = (void *)v95;
    }

    else
    {
      uint64_t v99 = (void *)v95;
      do
      {
        uint64_t v100 = *a3++;
        *v99++ = v100;
        if ((char *)a3 - *a2 == "PrivateFrameworks/GPUToolsTransport.framework/GPUToolsTransport")
        {
          unint64_t v101 = (uint64_t *)a2[1];
          ++a2;
          a3 = v101;
        }
      }

      while (v99 != v98);
      uint64_t v13 = a1[5];
    }

    v13 += ((uint64_t)v98 - v95) >> 3;
    a1[5] = v13;
    if (v94 == result) {
      break;
    }
    uint64_t v102 = *((void *)v94 + 1);
    v94 += 8;
    uint64_t v95 = v102;
  }

  return result;
}

void sub_117434( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::deque<ProfileEvent>::__maybe_remove_back_spare[abi:nn180100](void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v1 = a1[2];
  if (v1 == v2) {
    uint64_t v3 = 0LL;
  }
  else {
    uint64_t v3 = ((v1 - v2) << 6) - 1;
  }
  unint64_t v4 = v3 - (a1[5] + a1[4]);
  if (v4 >= 0x400)
  {
    operator delete(*(void **)(v1 - 8));
    a1[2] -= 8LL;
  }

  return v4 > 0x3FF;
}

void *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,ProfileEvent const*,ProfileEvent const*,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>,0>( void *result, _BYTE *__src, _BYTE *a3, void *a4, char *__dst)
{
  uint64_t v6 = a4;
  uint64_t v8 = result;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      if ((a3 - v9) >> 3 >= v11 >> 3) {
        uint64_t v12 = v11 >> 3;
      }
      else {
        uint64_t v12 = (a3 - v9) >> 3;
      }
      if (v12) {
        double result = memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)v6[1];
      ++v6;
      uint64_t v10 = v13;
      __dst = v13;
    }

    __dst += 8 * v12;
    if ((char *)(*v6 + 4096LL) == __dst)
    {
      unint64_t v14 = (char *)v6[1];
      ++v6;
      __dst = v14;
    }
  }

  *uint64_t v8 = a3;
  v8[1] = v6;
  v8[2] = __dst;
  return result;
}

void std::deque<ProfileEvent>::erase(int64x2_t *a1, char *a2, uint64_t a3)
{
  uint64_t v4 = a1->i64[1];
  uint64_t v5 = a1[1].i64[0];
  uint64_t v6 = (char *)(v4 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  if (v5 == v4) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = *(void *)v6 + 8 * (a1[2].i64[0] & 0x1FF);
  }
  if (v7 == a3) {
    unint64_t v8 = 0LL;
  }
  else {
    unint64_t v8 = ((a3 - *(void *)a2) >> 3) + ((a2 - v6) << 6) - ((v7 - *(void *)v6) >> 3);
  }
  uint64_t v9 = (char **)std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>::operator+[abi:nn180100]( v6,  v7,  v8);
  uint64_t v11 = v9;
  uint64_t v12 = v10;
  uint64_t v13 = a1[2].i64[1];
  uint64_t v14 = v10 - *v9;
  uint64_t v15 = v14 >> 3;
  if (v8 <= (unint64_t)(v13 - 1) >> 1)
  {
    if (v14 < -7)
    {
      unint64_t v18 = &v9[-((unint64_t)(510 - v15) >> 9)];
      unint64_t v19 = &(*v18)[8 * (~(510 - (_WORD)v15) & 0x1FF)];
    }

    else
    {
      unint64_t v18 = &v9[(unint64_t)(v15 + 1) >> 9];
      unint64_t v19 = &(*v18)[8 * (((_WORD)v15 + 1) & 0x1FF)];
    }

    if (v6 == (char *)v9)
    {
      int v36 = (char *)v7;
      uint64_t v35 = v12;
    }

    else
    {
      std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<ProfileEvent *,std::__deque_iterator<ProfileEvent,ProfileEvent *,ProfileEvent&,ProfileEvent **,long,512l>,0>( &v50,  *v9,  v10,  v18,  v19);
      unint64_t v25 = v51;
      uint64_t v26 = v52;
      uint64_t v27 = (char *)(v11 - 1);
      if (v11 - 1 != (char **)v6)
      {
        uint64_t v28 = *v51;
        do
        {
          uint64_t v29 = *(_BYTE **)v27;
          uint64_t v30 = (char *)(*(void *)v27 + 4096LL);
          while (1)
          {
            uint64_t v31 = v26 - v28;
            if ((v30 - v29) >> 3 >= v31 >> 3) {
              uint64_t v32 = v31 >> 3;
            }
            else {
              uint64_t v32 = (v30 - v29) >> 3;
            }
            v30 -= 8 * v32;
            v26 -= 8 * v32;
            if (v32) {
              memmove(v26, v30, 8 * v32);
            }
            if (v30 == v29) {
              break;
            }
            BOOL v33 = *--v25;
            uint64_t v28 = v33;
            uint64_t v26 = v33 + 4096;
          }

          uint64_t v28 = *v25;
          if (*v25 + 4096 == v26)
          {
            uint64_t v34 = v25[1];
            ++v25;
            uint64_t v28 = v34;
            uint64_t v26 = v34;
          }

          v27 -= 8;
        }

        while (v27 != v6);
      }

      uint64_t v35 = (char *)(*(void *)v6 + 4096LL);
      int v36 = (char *)v7;
      unint64_t v18 = v25;
      unint64_t v19 = v26;
    }

    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<ProfileEvent *,std::__deque_iterator<ProfileEvent,ProfileEvent *,ProfileEvent&,ProfileEvent **,long,512l>,0>( &v50,  v36,  v35,  v18,  v19);
    a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_313890);
    std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)a1);
  }

  else
  {
    if (v14 < -7)
    {
      unint64_t v20 = 510 - v15;
      __int16 v16 = ~(_WORD)v20;
      unint64_t v17 = &v9[-(v20 >> 9)];
    }

    else
    {
      __int16 v16 = v15 + 1;
      unint64_t v17 = &v9[(unint64_t)(v15 + 1) >> 9];
    }

    unint64_t v21 = &(*v17)[8 * (v16 & 0x1FF)];
    unint64_t v22 = a1[2].i64[0] + v13;
    uint64_t v23 = (char **)(v4 + 8 * (v22 >> 9));
    if (v5 == v4) {
      uint64_t v24 = 0LL;
    }
    else {
      uint64_t v24 = (uint64_t)&(*v23)[8 * (v22 & 0x1FF)];
    }
    if (v17 == v23)
    {
      uint64_t v47 = (_BYTE *)v24;
      unint64_t v48 = v9;
      __int128 v49 = v12;
    }

    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,ProfileEvent const*,ProfileEvent const*,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>,0>( &v50,  v21,  *v17 + 4096,  v9,  v12);
      int64_t v37 = v51;
      uint64_t v38 = v52;
      unint64_t v39 = v17 + 1;
      if (v17 + 1 != v23)
      {
        uint64_t v40 = *v51;
        do
        {
          uint64_t v41 = 0LL;
          uint64_t v42 = *v39;
          while (1)
          {
            uint64_t v43 = v40 - v38 + 4096;
            if ((4096 - 8 * v41) >> 3 >= v43 >> 3) {
              uint64_t v44 = v43 >> 3;
            }
            else {
              uint64_t v44 = (4096 - 8 * v41) >> 3;
            }
            if (v44) {
              memmove(v38, &v42[8 * v41], 8 * v44);
            }
            v41 += v44;
            if (v41 == 512) {
              break;
            }
            uint64_t v45 = v37[1];
            ++v37;
            uint64_t v40 = v45;
            uint64_t v38 = v45;
          }

          v38 += 8 * v44;
          uint64_t v40 = *v37;
          if (*v37 + 4096 == v38)
          {
            BOOL v46 = v37[1];
            ++v37;
            uint64_t v40 = v46;
            uint64_t v38 = v46;
          }

          ++v39;
        }

        while (v39 != v23);
      }

      unint64_t v21 = *v23;
      uint64_t v47 = (_BYTE *)v24;
      unint64_t v48 = v37;
      __int128 v49 = v38;
    }

    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,ProfileEvent const*,ProfileEvent const*,std::__deque_iterator<ProfileEvent,ProfileEvent*,ProfileEvent&,ProfileEvent**,long,512l>,0>( &v50,  v21,  v47,  v48,  v49);
    --a1[2].i64[1];
    std::deque<ProfileEvent>::__maybe_remove_back_spare[abi:nn180100](a1);
  }

double std::__introsort<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*,false>( uint64_t a1, unint64_t a2, uint64_t a3, char a4, double result)
{
LABEL_1:
  uint64_t v9 = (__int128 *)(a2 - 40);
  unint64_t v10 = a1;
  while (2)
  {
    a1 = v10;
    uint64_t v11 = a2 - v10;
    uint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
    switch(v12)
    {
      case 0LL:
      case 1LL:
        return result;
      case 2LL:
        if (*(_DWORD *)(a2 - 8) < *(_DWORD *)(v10 + 32))
        {
          uint64_t v134 = *(void *)(v10 + 32);
          __int128 v119 = *(_OWORD *)v10;
          __int128 v127 = *(_OWORD *)(v10 + 16);
          __int128 v53 = *v9;
          __int128 v54 = *(_OWORD *)(a2 - 24);
          *(void *)(v10 + 32) = *(void *)(a2 - 8);
          *(_OWORD *)unint64_t v10 = v53;
          *(_OWORD *)(v10 + 16) = v54;
          double result = *(double *)&v119;
          *(void *)(a2 - 8) = v134;
          *uint64_t v9 = v119;
          *(_OWORD *)(a2 - 24) = v127;
        }

        return result;
      case 3LL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)v10,  (__int128 *)(v10 + 40),  (__int128 *)(a2 - 40));
        return result;
      case 4LL:
        *(void *)&double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( v10,  v10 + 40,  v10 + 80,  a2 - 40).n128_u64[0];
        return result;
      case 5LL:
        *(void *)&double result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( v10,  v10 + 40,  v10 + 80,  v10 + 120,  a2 - 40).n128_u64[0];
        return result;
      default:
        if (v11 <= 959)
        {
          uint64_t v55 = (_OWORD *)(v10 + 40);
          BOOL v57 = v10 == a2 || v55 == (_OWORD *)a2;
          if ((a4 & 1) != 0)
          {
            if (!v57)
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = (_DWORD *)v10;
              do
              {
                uint64_t v60 = v55;
                unsigned int v61 = v59[18];
                if (v61 < v59[8])
                {
                  __int128 v120 = *v60;
                  __int128 v128 = v60[1];
                  int v62 = v59[19];
                  uint64_t v63 = v58;
                  while (1)
                  {
                    uint64_t v64 = v10 + v63;
                    __int128 v65 = *(_OWORD *)(v10 + v63 + 16);
                    *(_OWORD *)(v64 + 40) = *(_OWORD *)(v10 + v63);
                    *(_OWORD *)(v64 + 56) = v65;
                    *(void *)(v64 + 72) = *(void *)(v10 + v63 + 32);
                    if (!v63) {
                      break;
                    }
                    v63 -= 40LL;
                    if (v61 >= *(_DWORD *)(v64 - 8))
                    {
                      uint64_t v66 = v10 + v63 + 40;
                      goto LABEL_74;
                    }
                  }

                  uint64_t v66 = v10;
LABEL_74:
                  double result = *(double *)&v120;
                  *(_OWORD *)uint64_t v66 = v120;
                  *(_OWORD *)(v66 + 16) = v128;
                  *(_DWORD *)(v66 + 32) = v61;
                  *(_DWORD *)(v66 + 36) = v62;
                }

                uint64_t v55 = (_OWORD *)((char *)v60 + 40);
                v58 += 40LL;
                unint64_t v59 = v60;
              }

              while ((_OWORD *)((char *)v60 + 40) != (_OWORD *)a2);
            }
          }

          else if (!v57)
          {
            do
            {
              unsigned int v105 = v55;
              unsigned int v106 = *(_DWORD *)(a1 + 72);
              if (v106 < *(_DWORD *)(a1 + 32))
              {
                __int128 v123 = *v55;
                __int128 v131 = v55[1];
                int v107 = *(_DWORD *)(a1 + 76);
                unsigned int v108 = v105;
                do
                {
                  __int128 v109 = *(_OWORD *)((char *)v108 - 24);
                  *unsigned int v108 = *(_OWORD *)((char *)v108 - 40);
                  v108[1] = v109;
                  *((void *)v108 + 4) = *((void *)v108 - 1);
                  unsigned int v110 = *((_DWORD *)v108 - 12);
                  unsigned int v108 = (_OWORD *)((char *)v108 - 40);
                }

                while (v106 < v110);
                double result = *(double *)&v123;
                *unsigned int v108 = v123;
                v108[1] = v131;
                *((_DWORD *)v108 + 8) = v106;
                *((_DWORD *)v108 + 9) = v107;
              }

              uint64_t v55 = (_OWORD *)((char *)v105 + 40);
              a1 = (uint64_t)v105;
            }

            while ((_OWORD *)((char *)v105 + 40) != (_OWORD *)a2);
          }

          return result;
        }

        if (!a3)
        {
          if (v10 != a2)
          {
            int64_t v67 = (unint64_t)(v12 - 2) >> 1;
            int64_t v68 = v67;
            do
            {
              int64_t v69 = v68;
              if (v67 >= v68)
              {
                uint64_t v70 = (2 * v68) | 1;
                unint64_t v71 = v10 + 40 * v70;
                if (2 * v69 + 2 < v12)
                {
                  unsigned int v72 = *(_DWORD *)(v10 + 40 * v70 + 32);
                  unsigned int v73 = *(_DWORD *)(v71 + 72);
                  v71 += 40LL * (v72 < v73);
                  if (v72 < v73) {
                    uint64_t v70 = 2 * v69 + 2;
                  }
                }

                unsigned int v74 = *(_DWORD *)(v10 + 40 * v69 + 32);
                if (*(_DWORD *)(v71 + 32) >= v74)
                {
                  unint64_t v75 = v10 + 40 * v69;
                  __int128 v121 = *(_OWORD *)v75;
                  __int128 v129 = *(_OWORD *)(v75 + 16);
                  int v76 = *(_DWORD *)(v75 + 36);
                  do
                  {
                    unint64_t v77 = v75;
                    unint64_t v75 = v71;
                    __int128 v78 = *(_OWORD *)v71;
                    __int128 v79 = *(_OWORD *)(v71 + 16);
                    *(void *)(v77 + 32) = *(void *)(v71 + 32);
                    *(_OWORD *)unint64_t v77 = v78;
                    *(_OWORD *)(v77 + 16) = v79;
                    if (v67 < v70) {
                      break;
                    }
                    uint64_t v80 = (2 * v70) | 1;
                    unint64_t v71 = v10 + 40 * v80;
                    uint64_t v81 = 2 * v70 + 2;
                    if (v81 < v12)
                    {
                      unsigned int v82 = *(_DWORD *)(v10 + 40 * v80 + 32);
                      unsigned int v83 = *(_DWORD *)(v71 + 72);
                      v71 += 40LL * (v82 < v83);
                      if (v82 < v83) {
                        uint64_t v80 = v81;
                      }
                    }

                    uint64_t v70 = v80;
                  }

                  while (*(_DWORD *)(v71 + 32) >= v74);
                  *(_OWORD *)unint64_t v75 = v121;
                  *(_OWORD *)(v75 + 16) = v129;
                  *(_DWORD *)(v75 + 32) = v74;
                  *(_DWORD *)(v75 + 36) = v76;
                }
              }

              int64_t v68 = v69 - 1;
            }

            while (v69);
            int64_t v84 = v11 / 0x28uLL;
            do
            {
              uint64_t v85 = 0LL;
              uint64_t v135 = *(void *)(v10 + 32);
              __int128 v122 = *(_OWORD *)v10;
              __int128 v130 = *(_OWORD *)(v10 + 16);
              unint64_t v86 = v10;
              do
              {
                uint64_t v87 = v85 + 1;
                unint64_t v88 = v86 + 40 * (v85 + 1);
                uint64_t v89 = (2 * v85) | 1;
                uint64_t v90 = 2 * v85 + 2;
                if (v90 < v84)
                {
                  unsigned int v91 = *(_DWORD *)(v86 + 40 * v87 + 32);
                  unsigned int v92 = *(_DWORD *)(v88 + 72);
                  v88 += 40LL * (v91 < v92);
                  if (v91 < v92) {
                    uint64_t v89 = v90;
                  }
                }

                __int128 v93 = *(_OWORD *)v88;
                __int128 v94 = *(_OWORD *)(v88 + 16);
                *(void *)(v86 + 32) = *(void *)(v88 + 32);
                *(_OWORD *)unint64_t v86 = v93;
                *(_OWORD *)(v86 + 16) = v94;
                unint64_t v86 = v88;
                uint64_t v85 = v89;
              }

              while (v89 <= (uint64_t)((unint64_t)(v84 - 2) >> 1));
              a2 -= 40LL;
              if (v88 == a2)
              {
                double result = *(double *)&v122;
                *(void *)(v88 + 32) = v135;
                *(_OWORD *)unint64_t v88 = v122;
                *(_OWORD *)(v88 + 16) = v130;
              }

              else
              {
                __int128 v95 = *(_OWORD *)a2;
                __int128 v96 = *(_OWORD *)(a2 + 16);
                *(void *)(v88 + 32) = *(void *)(a2 + 32);
                *(_OWORD *)unint64_t v88 = v95;
                *(_OWORD *)(v88 + 16) = v96;
                double result = *(double *)&v122;
                *(void *)(a2 + 32) = v135;
                *(_OWORD *)a2 = v122;
                *(_OWORD *)(a2 + 16) = v130;
                uint64_t v97 = v88 - v10 + 40;
                if (v97 >= 41)
                {
                  unint64_t v98 = (unint64_t)(-2 - 0x3333333333333333LL * (v97 >> 3)) >> 1;
                  unsigned int v99 = *(_DWORD *)(v88 + 32);
                  if (*(_DWORD *)(v10 + 40 * v98 + 32) < v99)
                  {
                    __int128 v113 = *(_OWORD *)v88;
                    __int128 v116 = *(_OWORD *)(v88 + 16);
                    int v100 = *(_DWORD *)(v88 + 36);
                    do
                    {
                      unint64_t v101 = v88;
                      unint64_t v88 = v10 + 40 * v98;
                      __int128 v102 = *(_OWORD *)v88;
                      __int128 v103 = *(_OWORD *)(v88 + 16);
                      *(void *)(v101 + 32) = *(void *)(v88 + 32);
                      *(_OWORD *)unint64_t v101 = v102;
                      *(_OWORD *)(v101 + 16) = v103;
                      if (!v98) {
                        break;
                      }
                      unint64_t v98 = (v98 - 1) >> 1;
                    }

                    while (*(_DWORD *)(v10 + 40 * v98 + 32) < v99);
                    double result = *(double *)&v113;
                    *(_OWORD *)unint64_t v88 = v113;
                    *(_OWORD *)(v88 + 16) = v116;
                    *(_DWORD *)(v88 + 32) = v99;
                    *(_DWORD *)(v88 + 36) = v100;
                  }
                }
              }
            }

            while (v84-- > 2);
          }

          return result;
        }

        unint64_t v13 = (unint64_t)v12 >> 1;
        unint64_t v14 = v10 + 40 * ((unint64_t)v12 >> 1);
        if ((unint64_t)v11 < 0x1401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)v14,  (__int128 *)a1,  (__int128 *)(a2 - 40));
        }

        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)a1,  (__int128 *)v14,  (__int128 *)(a2 - 40));
          uint64_t v15 = 5 * v13;
          __int16 v16 = (__int128 *)(a1 + 40 * v13 - 40);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)(a1 + 40),  v16,  (__int128 *)(a2 - 80));
          unint64_t v17 = (__int128 *)(a1 + 40 + 8 * v15);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)(a1 + 80),  v17,  (__int128 *)(a2 - 120));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( v16,  (__int128 *)v14,  v17);
          uint64_t v132 = *(void *)(a1 + 32);
          __int128 v117 = *(_OWORD *)a1;
          __int128 v124 = *(_OWORD *)(a1 + 16);
          __int128 v18 = *(_OWORD *)v14;
          __int128 v19 = *(_OWORD *)(v14 + 16);
          *(void *)(a1 + 32) = *(void *)(v14 + 32);
          *(_OWORD *)a1 = v18;
          *(_OWORD *)(a1 + 16) = v19;
          *(void *)(v14 + 32) = v132;
          *(_OWORD *)unint64_t v14 = v117;
          *(_OWORD *)(v14 + 16) = v124;
        }

        --a3;
        if ((a4 & 1) == 0 && *(_DWORD *)(a1 - 8) >= *(_DWORD *)(a1 + 32))
        {
          __int128 v112 = *(_OWORD *)a1;
          __int128 v115 = *(_OWORD *)(a1 + 16);
          double result = *(double *)(a1 + 32);
          if (LODWORD(result) >= *(_DWORD *)(a2 - 8))
          {
            unint64_t v41 = a1 + 40;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= a2) {
                break;
              }
              unsigned int v42 = *(_DWORD *)(v41 + 32);
              v41 += 40LL;
            }

            while (LODWORD(result) >= v42);
          }

          else
          {
            uint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 40;
              unsigned int v40 = *(_DWORD *)(v39 + 72);
              v39 += 40LL;
            }

            while (LODWORD(result) >= v40);
          }

          unint64_t v43 = a2;
          if (v10 < a2)
          {
            unint64_t v44 = a2;
            do
            {
              unint64_t v43 = v44 - 40;
              unsigned int v45 = *(_DWORD *)(v44 - 8);
              v44 -= 40LL;
            }

            while (LODWORD(result) < v45);
          }

          while (v10 < v43)
          {
            uint64_t v133 = *(void *)(v10 + 32);
            __int128 v118 = *(_OWORD *)v10;
            __int128 v126 = *(_OWORD *)(v10 + 16);
            __int128 v46 = *(_OWORD *)v43;
            __int128 v47 = *(_OWORD *)(v43 + 16);
            *(void *)(v10 + 32) = *(void *)(v43 + 32);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(void *)(v43 + 32) = v133;
            *(_OWORD *)unint64_t v43 = v118;
            *(_OWORD *)(v43 + 16) = v126;
            do
            {
              unsigned int v48 = *(_DWORD *)(v10 + 72);
              v10 += 40LL;
            }

            while (LODWORD(result) >= v48);
            do
            {
              unsigned int v49 = *(_DWORD *)(v43 - 8);
              v43 -= 40LL;
            }

            while (LODWORD(result) < v49);
          }

          uint64_t v50 = (__int128 *)(v10 - 40);
          if (v10 - 40 != a1)
          {
            __int128 v51 = *v50;
            __int128 v52 = *(_OWORD *)(v10 - 24);
            *(void *)(a1 + 32) = *(void *)(v10 - 8);
            *(_OWORD *)a1 = v51;
            *(_OWORD *)(a1 + 16) = v52;
          }

          a4 = 0;
          __int128 *v50 = v112;
          *(_OWORD *)(v10 - 24) = v115;
          *(double *)(v10 - 8) = result;
          continue;
        }

        __int128 v111 = *(_OWORD *)a1;
        __int128 v114 = *(_OWORD *)(a1 + 16);
        uint64_t v20 = *(void *)(a1 + 32);
        unint64_t v21 = a1;
        do
        {
          unint64_t v22 = v21;
          v21 += 40LL;
        }

        while (*(_DWORD *)(v22 + 72) < v20);
        unint64_t v23 = a2;
        if (v22 == a1)
        {
          unint64_t v26 = a2;
          while (v21 < v26)
          {
            unint64_t v24 = v26 - 40;
            unsigned int v27 = *(_DWORD *)(v26 - 8);
            v26 -= 40LL;
          }

          unint64_t v24 = v26;
        }

        else
        {
          do
          {
            unint64_t v24 = v23 - 40;
            unsigned int v25 = *(_DWORD *)(v23 - 8);
            v23 -= 40LL;
          }

          while (v25 >= v20);
        }

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( __int128 *result, __int128 *a2, __int128 *a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 8);
  unsigned int v4 = *((_DWORD *)a3 + 8);
  if (v3 >= *((_DWORD *)result + 8))
  {
    if (v4 < v3)
    {
      __int128 v10 = *a2;
      __int128 v11 = a2[1];
      uint64_t v12 = *((void *)a2 + 4);
      uint64_t v13 = *((void *)a3 + 4);
      __int128 v14 = a3[1];
      *a2 = *a3;
      a2[1] = v14;
      *((void *)a2 + 4) = v13;
      *((void *)a3 + 4) = v12;
      *a3 = v10;
      a3[1] = v11;
      if (*((_DWORD *)a2 + 8) < *((_DWORD *)result + 8))
      {
        __int128 v15 = *result;
        __int128 v16 = result[1];
        uint64_t v17 = *((void *)result + 4);
        uint64_t v18 = *((void *)a2 + 4);
        __int128 v19 = a2[1];
        *double result = *a2;
        result[1] = v19;
        *((void *)result + 4) = v18;
        *((void *)a2 + 4) = v17;
        *a2 = v15;
        a2[1] = v16;
      }
    }
  }

  else
  {
    if (v4 >= v3)
    {
      __int128 v20 = *result;
      __int128 v21 = result[1];
      uint64_t v22 = *((void *)result + 4);
      uint64_t v23 = *((void *)a2 + 4);
      __int128 v24 = a2[1];
      *double result = *a2;
      result[1] = v24;
      *((void *)result + 4) = v23;
      *((void *)a2 + 4) = v22;
      *a2 = v20;
      a2[1] = v21;
      if (*((_DWORD *)a3 + 8) >= *((_DWORD *)a2 + 8)) {
        return result;
      }
      __int128 v5 = *a2;
      __int128 v6 = a2[1];
      uint64_t v7 = *((void *)a2 + 4);
      uint64_t v25 = *((void *)a3 + 4);
      __int128 v26 = a3[1];
      *a2 = *a3;
      a2[1] = v26;
      *((void *)a2 + 4) = v25;
    }

    else
    {
      __int128 v5 = *result;
      __int128 v6 = result[1];
      uint64_t v7 = *((void *)result + 4);
      uint64_t v8 = *((void *)a3 + 4);
      __int128 v9 = a3[1];
      *double result = *a3;
      result[1] = v9;
      *((void *)result + 4) = v8;
    }

    *((void *)a3 + 4) = v7;
    *a3 = v5;
    a3[1] = v6;
  }

  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 32) < *(_DWORD *)(a3 + 32))
  {
    __n128 result = *(__n128 *)a3;
    __int128 v9 = *(_OWORD *)(a3 + 16);
    uint64_t v10 = *(void *)(a3 + 32);
    uint64_t v11 = *(void *)(a4 + 32);
    __int128 v12 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v12;
    *(void *)(a3 + 32) = v11;
    *(void *)(a4 + 32) = v10;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v9;
    if (*(_DWORD *)(a3 + 32) < *(_DWORD *)(a2 + 32))
    {
      __n128 result = *(__n128 *)a2;
      __int128 v13 = *(_OWORD *)(a2 + 16);
      uint64_t v14 = *(void *)(a2 + 32);
      uint64_t v15 = *(void *)(a3 + 32);
      __int128 v16 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v16;
      *(void *)(a2 + 32) = v15;
      *(void *)(a3 + 32) = v14;
      *(__n128 *)a3 = result;
      *(_OWORD *)(a3 + 16) = v13;
      if (*(_DWORD *)(a2 + 32) < *(_DWORD *)(a1 + 32))
      {
        __n128 result = *(__n128 *)a1;
        __int128 v17 = *(_OWORD *)(a1 + 16);
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(void *)(a2 + 32);
        __int128 v20 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v20;
        *(void *)(a1 + 32) = v19;
        *(void *)(a2 + 32) = v18;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v17;
      }
    }
  }

  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  a2,  a3,  a4).n128_u64[0];
  if (*(_DWORD *)(a5 + 32) < *(_DWORD *)(a4 + 32))
  {
    __n128 result = *(__n128 *)a4;
    __int128 v11 = *(_OWORD *)(a4 + 16);
    uint64_t v12 = *(void *)(a4 + 32);
    uint64_t v13 = *(void *)(a5 + 32);
    __int128 v14 = *(_OWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)(a4 + 16) = v14;
    *(void *)(a4 + 32) = v13;
    *(void *)(a5 + 32) = v12;
    *(__n128 *)a5 = result;
    *(_OWORD *)(a5 + 16) = v11;
    if (*(_DWORD *)(a4 + 32) < *(_DWORD *)(a3 + 32))
    {
      __n128 result = *(__n128 *)a3;
      __int128 v15 = *(_OWORD *)(a3 + 16);
      uint64_t v16 = *(void *)(a3 + 32);
      uint64_t v17 = *(void *)(a4 + 32);
      __int128 v18 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v18;
      *(void *)(a3 + 32) = v17;
      *(void *)(a4 + 32) = v16;
      *(__n128 *)a4 = result;
      *(_OWORD *)(a4 + 16) = v15;
      if (*(_DWORD *)(a3 + 32) < *(_DWORD *)(a2 + 32))
      {
        __n128 result = *(__n128 *)a2;
        __int128 v19 = *(_OWORD *)(a2 + 16);
        uint64_t v20 = *(void *)(a2 + 32);
        uint64_t v21 = *(void *)(a3 + 32);
        __int128 v22 = *(_OWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 16) = v22;
        *(void *)(a2 + 32) = v21;
        *(void *)(a3 + 32) = v20;
        *(__n128 *)a3 = result;
        *(_OWORD *)(a3 + 16) = v19;
        if (*(_DWORD *)(a2 + 32) < *(_DWORD *)(a1 + 32))
        {
          __n128 result = *(__n128 *)a1;
          __int128 v23 = *(_OWORD *)(a1 + 16);
          uint64_t v24 = *(void *)(a1 + 32);
          uint64_t v25 = *(void *)(a2 + 32);
          __int128 v26 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 16) = v26;
          *(void *)(a1 + 32) = v25;
          *(void *)(a2 + 32) = v24;
          *(__n128 *)a2 = result;
          *(_OWORD *)(a2 + 16) = v23;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(_DWORD *)(a2 - 8) < *(_DWORD *)(a1 + 32))
      {
        __int128 v6 = *(_OWORD *)a1;
        __int128 v7 = *(_OWORD *)(a1 + 16);
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a2 - 8);
        __int128 v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(void *)(a1 + 32) = v9;
        *(void *)(a2 - 8) = v8;
        *(_OWORD *)(a2 - 24) = v7;
        *(_OWORD *)(a2 - 40) = v6;
      }

      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)a1,  (__int128 *)(a1 + 40),  (__int128 *)(a2 - 40));
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  a1 + 40,  a1 + 80,  a2 - 40);
      return 1LL;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  a1 + 40,  a1 + 80,  a1 + 120,  a2 - 40);
      return 1LL;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)a1,  (__int128 *)(a1 + 40),  (__int128 *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1LL;
      }
      uint64_t v13 = 0LL;
      int v14 = 0;
      break;
  }

  while (1)
  {
    unsigned int v15 = *(_DWORD *)(v12 + 32);
    if (v15 < *(_DWORD *)(v11 + 32))
    {
      __int128 v21 = *(_OWORD *)v12;
      __int128 v22 = *(_OWORD *)(v12 + 16);
      int v16 = *(_DWORD *)(v12 + 36);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        __int128 v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(void *)(v18 + 152) = *(void *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40LL;
        if (v15 >= *(_DWORD *)(v18 + 72))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }

      uint64_t v20 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v20 = v21;
      *(_OWORD *)(v20 + 16) = v22;
      *(_DWORD *)(v20 + 32) = v15;
      *(_DWORD *)(v20 + 36) = v16;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }

    uint64_t v11 = v12;
    v13 += 40LL;
    v12 += 40LL;
    if (v12 == a2) {
      return 1LL;
    }
  }

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<ProfileEvent *,std::__deque_iterator<ProfileEvent,ProfileEvent *,ProfileEvent&,ProfileEvent **,long,512l>,0>( void *result, char *a2, char *a3, void *a4, char *a5)
{
  __int128 v6 = a4;
  uint64_t v8 = result;
  if (a2 == a3)
  {
    uint64_t v9 = a2;
  }

  else
  {
    uint64_t v9 = a3;
    uint64_t v10 = *a4;
    uint64_t v11 = a3;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a5[-v10];
      if ((v11 - a2) >> 3 >= v12 >> 3) {
        uint64_t v13 = v12 >> 3;
      }
      else {
        uint64_t v13 = (v11 - a2) >> 3;
      }
      v11 -= 8 * v13;
      a5 -= 8 * v13;
      if (v13) {
        BOOL result = memmove(a5, v11, 8 * v13);
      }
      if (v11 == a2) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a5 = (char *)(v14 + 4096);
    }

    if ((char *)(*v6 + 4096LL) == a5)
    {
      unsigned int v15 = (char *)v6[1];
      ++v6;
      a5 = v15;
    }
  }

  *uint64_t v8 = v9;
  v8[1] = v6;
  v8[2] = a5;
  return result;
}

void std::vector<std::vector<ProfileEvent>>::resize(uint64_t a1)
{
  unsigned int v3 = *(void **)a1;
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v4 = (uint64_t)v2 - *(void *)a1;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 3);
  if (v5 <= 0x11)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v2) >> 3) >= 18 - v5)
    {
      bzero(*(void **)(a1 + 8), 24 * ((408 - v4) / 0x18uLL) + 24);
      *(void *)(a1 + 8) = &v2[3 * ((408 - v4) / 0x18uLL) + 3];
      return;
    }

    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)v3) >> 3);
    unint64_t v8 = 0x5555555555555556LL * ((v6 - (uint64_t)v3) >> 3);
    if (v8 <= 0x12) {
      unint64_t v8 = 18LL;
    }
    if (v7 >= 0x555555555555555LL) {
      unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v10 = 3 * v9;
    uint64_t v11 = (char *)operator new(24 * v9);
    uint64_t v12 = &v11[8 * (v4 >> 3)];
    uint64_t v13 = &v11[8 * v10];
    size_t v14 = 24 * ((408 - v4) / 0x18uLL) + 24;
    bzero(v12, v14);
    unsigned int v15 = &v12[v14];
    if (v2 == v3)
    {
      *(void *)a1 = v12;
      *(void *)(a1 + 8) = v15;
      *(void *)(a1 + 16) = v13;
      if (!v2) {
        return;
      }
    }

    else
    {
      do
      {
        int v16 = v12;
        *((void *)v12 - 1) = 0LL;
        __int128 v17 = *(_OWORD *)(v2 - 3);
        v2 -= 3;
        *(_OWORD *)(v12 - 24) = v17;
        v12 -= 24;
        *((void *)v16 - 1) = v2[2];
        *uint64_t v2 = 0LL;
        v2[1] = 0LL;
        v2[2] = 0LL;
      }

      while (v2 != v3);
      uint64_t v18 = *(void **)a1;
      uint64_t v2 = *(void **)(a1 + 8);
      *(void *)a1 = v12;
      *(void *)(a1 + 8) = v15;
      *(void *)(a1 + 16) = v13;
      if (v2 != v18)
      {
        __int128 v19 = v2;
        do
        {
          __int128 v21 = (void *)*(v19 - 3);
          v19 -= 3;
          uint64_t v20 = v21;
          if (v21)
          {
            *(v2 - 2) = v20;
            operator delete(v20);
          }

          uint64_t v2 = v19;
        }

        while (v19 != v18);
        uint64_t v2 = v18;
      }

      if (!v2) {
        return;
      }
    }

    operator delete(v2);
    return;
  }

  if (v4 != 432)
  {
    __int128 v22 = v3 + 54;
    if (v2 != v3 + 54)
    {
      __int128 v23 = *(void **)(a1 + 8);
      do
      {
        uint64_t v25 = (void *)*(v23 - 3);
        v23 -= 3;
        uint64_t v24 = v25;
        if (v25)
        {
          *(v2 - 2) = v24;
          operator delete(v24);
        }

        uint64_t v2 = v23;
      }

      while (v23 != v22);
    }

    *(void *)(a1 + 8) = v22;
  }

void std::vector<std::vector<std::unique_ptr<std::vector<double>>>>::resize(char **a1, unint64_t a2)
{
  uint64_t v4 = *a1;
  unsigned int v3 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v6 = a2 - v5;
  if (a2 > v5)
  {
    unint64_t v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3) >= v6)
    {
      bzero(a1[1], 24 * ((24 * v6 - 24) / 0x18) + 24);
      a1[1] = &v3[24 * ((24 * v6 - 24) / 0x18) + 24];
      return;
    }

    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x555555555555555LL) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v11 = 3 * v10;
    uint64_t v12 = (char *)operator new(24 * v10);
    uint64_t v13 = &v12[24 * v5];
    size_t v14 = &v12[8 * v11];
    size_t v15 = 24 * ((24 * v6 - 24) / 0x18) + 24;
    bzero(v13, v15);
    int v16 = &v13[v15];
    if (v3 == v4)
    {
      *a1 = v13;
      a1[1] = v16;
      a1[2] = v14;
      if (!v3) {
        return;
      }
    }

    else
    {
      do
      {
        __int128 v17 = v13;
        *((void *)v13 - 1) = 0LL;
        __int128 v18 = *(_OWORD *)(v3 - 24);
        v3 -= 24;
        *(_OWORD *)(v13 - 24) = v18;
        v13 -= 24;
        *((void *)v17 - 1) = *((void *)v3 + 2);
        *(void *)unsigned int v3 = 0LL;
        *((void *)v3 + 1) = 0LL;
        *((void *)v3 + 2) = 0LL;
      }

      while (v3 != v4);
      __int128 v19 = *a1;
      unsigned int v3 = a1[1];
      *a1 = v13;
      a1[1] = v16;
      a1[2] = v14;
      if (v3 != v19)
      {
        do
        {
          v3 -= 24;
          __int128 v21 = (void **)v3;
          std::vector<std::unique_ptr<std::vector<double>>>::__destroy_vector::operator()[abi:nn180100](&v21);
        }

        while (v3 != v19);
        unsigned int v3 = v19;
      }

      if (!v3) {
        return;
      }
    }

    operator delete(v3);
    return;
  }

  if (a2 < v5)
  {
    uint64_t v20 = &v4[24 * a2];
    while (v3 != v20)
    {
      v3 -= 24;
      __int128 v21 = (void **)v3;
      std::vector<std::unique_ptr<std::vector<double>>>::__destroy_vector::operator()[abi:nn180100](&v21);
    }

    a1[1] = v20;
  }

int64x2_t *std::vector<std::unique_ptr<std::vector<double>>>::reserve(int64x2_t *result)
{
  uint64_t v1 = result[1].i64[0];
  uint64_t v2 = (char *)result->i64[0];
  if ((unint64_t)(v1 - result->i64[0]) <= 0x9F)
  {
    unsigned int v3 = result;
    uint64_t v4 = (char *)result->i64[1];
    uint64_t v13 = result + 1;
    unint64_t v5 = (char *)operator new(0xA0uLL);
    unint64_t v6 = &v5[(v4 - v2) & 0xFFFFFFFFFFFFFFF8LL];
    if (v4 == v2)
    {
      int64x2_t v9 = vdupq_n_s64((unint64_t)v4);
      unint64_t v7 = &v5[(v4 - v2) & 0xFFFFFFFFFFFFFFF8LL];
    }

    else
    {
      unint64_t v7 = &v5[(v4 - v2) & 0xFFFFFFFFFFFFFFF8LL];
      do
      {
        uint64_t v8 = *((void *)v4 - 1);
        v4 -= 8;
        *(void *)uint64_t v4 = 0LL;
        *((void *)v7 - 1) = v8;
        v7 -= 8;
      }

      while (v4 != v2);
      int64x2_t v9 = *v3;
      uint64_t v1 = v3[1].i64[0];
    }

    v3->i64[0] = (uint64_t)v7;
    v3->i64[1] = (uint64_t)v6;
    int64x2_t v11 = v9;
    v3[1].i64[0] = (uint64_t)(v5 + 160);
    uint64_t v12 = v1;
    uint64_t v10 = v9.i64[0];
    return (int64x2_t *)std::__split_buffer<std::unique_ptr<std::vector<double>>>::~__split_buffer((uint64_t)&v10);
  }

  return result;
}

LABEL_81:
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v29 <= v11) {
        unint64_t v5 = v11 % v29;
      }
      else {
        unint64_t v5 = v11;
      }
    }

    else
    {
      unint64_t v5 = (v29 - 1) & v11;
    }
  }

  __int128 v51 = *a4;
  __int128 v52 = *(void **)(*a4 + 8 * v5);
  if (v52)
  {
    char *i = *v52;
LABEL_94:
    char *v52 = i;
    goto LABEL_95;
  }

  char *i = *v33;
  char *v33 = i;
  *(void *)(v51 + 8 * v5) = v33;
  if (*i)
  {
    __int128 v53 = *(void *)(*i + 8LL);
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v53 >= v29) {
        v53 %= v29;
      }
    }

    else
    {
      v53 &= v29 - 1;
    }

    __int128 v52 = (void *)(*a4 + 8 * v53);
    goto LABEL_94;
  }

      if (++v19 >= v135) {
        goto LABEL_82;
      }
    }

    __int128 v22 = 0LL;
    while (1)
    {
      grc_enable_str = (char *)agxps_counter_get_grc_enable_str(*(void *)(v129.i64[0] + 8 * v22));
      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", grc_enable_str));
      if ([v24 isEqualToString:@"C444B68E04C1CF9E9C5216C15B1C3904605D5CA532A21B510E59CB9AFEE553E3"])
      {
        uint64_t v25 = 1;
      }

      else
      {
        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  grc_enable_str));
        uint64_t v25 = [v26 isEqualToString:@"004461E8D695B050A2073DC949CCDE4089182A897EA18AEEA2485923F3A19B19"];
      }

      if (!byte_5B9768)
      {
        unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  grc_enable_str));
        unsigned int v34 = [v33 isEqualToString:@"_b08194796a2cb35a8699c8d23b129c582951d9d1941fbc8e36dbaafa02d474e7"];

        if ((v34 & 1) != 0) {
          goto LABEL_80;
        }
        if (!byte_5B9768)
        {
LABEL_65:
          __int128 v29 = agxps_counter_deobfuscate_name(grc_enable_str);
          *(void *)&v133[0] = v29;
          if (*v29) {
            uint64_t v30 = v25;
          }
          else {
            uint64_t v30 = 1;
          }
          if ((v30 & 1) == 0)
          {
            std::string::basic_string[abi:nn180100]<0>(&v153, v29);
            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>( (uint64_t)&v146,  (uint64_t)&v153,  (uint64_t)&v153);
            if (SHIBYTE(v153.__end_) < 0) {
              operator delete(v153.__first_);
            }
            __int128 v31 = (std::string *)*((void *)v21 + 6);
            if ((unint64_t)v31 >= *((void *)v21 + 7))
            {
              __int128 v32 = std::vector<std::string>::__emplace_back_slow_path<char const*&>( (std::__split_buffer<std::string>::pointer *)v21 + 5,  (char **)v133);
            }

            else
            {
              std::string::basic_string[abi:nn180100]<0>(*((void **)v21 + 6), v29);
              __int128 v32 = v31 + 1;
              *((void *)v21 + 6) = v31 + 1;
            }

            *((void *)v21 + 6) = v32;
            if (v124)
            {
              std::string::basic_string[abi:nn180100]<0>(&v153, v29);
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>( (uint64_t)&v143,  (uint64_t)&v153,  (uint64_t)&v153);
              if (SHIBYTE(v153.__end_) < 0) {
                operator delete(v153.__first_);
              }
            }
          }

          goto LABEL_80;
        }
      }

      unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", grc_enable_str));
      unint64_t v28 = [v27 isEqualToString:@"_6c6b4958950feeff7717076797af362e443d3c99b08053bcf8ca2d302a9f67a6"];

      if ((v28 & 1) == 0) {
        goto LABEL_65;
      }
LABEL_80:
    }
  }

                BOOL v57 = v54 | (unint64_t)(v56 << 32);
LABEL_82:
                uint64_t v58 = v53 + 64;
                while (v53 && (*(_BYTE *)(v58 + ((uint64_t)(HIDWORD(v57) - (int)v57) << 6) + 15) & 8) != 0)
                {
                  unint64_t v59 = v58 + ((uint64_t)(HIDWORD(v57) - (int)v57) << 6);
                  if ((IsFuncEnumEndEncoding(*(_DWORD *)(v59 + 8)) & 1) != 0)
                  {
                    uint64_t v81 = &v92;
                    unsigned int v82 = v98;
                    unsigned int v83 = 0;
                    int64_t v84 = 0;
                    uint64_t v63 = *(void *)v59;
                    uint64_t v64 = &v81;
                    __int128 v65 = a1;
                    uint64_t v66 = v52;
                    goto LABEL_112;
                  }

                  GTResourceTrackerProcessResourceUse(a1, v59, *(void *)v59);
                  if (IsFuncEnumCreateCommandEncoder(*(_DWORD *)(v59 + 8)))
                  {
                    bzero(&v81, 0x2B90uLL);
                    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v81, (uint64_t *)v59, a1[1]);
                    renderCommandEncoder_processStreamWithDescriptor(a1, v52, (uint64_t)&v81);
                  }

                  else
                  {
                    GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v87, (uint64_t *)v59, a1[1]);
                  }

                  uint64_t v60 = atomic_load((unsigned int *)(v53 + 4));
                  unsigned int v61 = v57 + (v60 >> 6);
                  int v62 = (HIDWORD(v57) + 1);
                  BOOL v57 = (v62 << 32) | v57;
                  if ((_DWORD)v62 == v61 - 1)
                  {
                    BOOL v57 = (v62 << 32) | v62;
                    __int128 v53 = *(void *)(v53 + 40);
                    goto LABEL_82;
                  }
                }

                return;
              }
            }
          }
        }

        else
        {
          bzero(&v87, 0x2B90uLL);
          unsigned int v33 = 0LL;
        }

        uint64_t v35 = 0LL;
        goto LABEL_74;
      }

      if (v77 != 74)
      {
        if (v77 != 82) {
          return;
        }
LABEL_35:
        computeCommandEncoder_processStream(a1, v78);
        return;
      }
    }

    defaultCommandEncoder_processStream(a1, v78);
    return;
  }

  if (v4 != -20457 && v4 != -20474)
  {
    GTResourceTrackerProcessResourceUse(a1, a2, *(void *)a2);
    return;
  }

  int v16 = GTTraceFunc_targetContext(a2, a1[1]);
  FuncEnumReceiverType = GetFuncEnumReceiverType(*(_DWORD *)(a2 + 8));
  if (FuncEnumReceiverType == 40)
  {
    __int128 v18 = *(void *)a2;
    uint64_t v25 = *a1;
    *(void *)&uint64_t v87 = v16;
    __int128 v26 = *(void *)(*find_entry(v25, &v87, 8uLL, 0LL) + 32LL);
    uint64_t v87 = 0u;
    unint64_t v88 = 0LL;
    uint64_t v97 = 0LL;
    __int128 v96 = 0u;
    __int128 v95 = 0u;
    __int128 v94 = 0u;
    __int128 v93 = 0u;
    unsigned int v92 = 0u;
    unsigned int v91 = 0u;
    uint64_t v90 = 0u;
    LODWORD(v87) = 40;
    uint64_t v89 = -1LL;
    unsigned int v27 = *(void *)(v26 + 32);
    if (v27)
    {
      unint64_t v28 = 0;
      while (1)
      {
        __int128 v29 = atomic_load((unsigned int *)(v27 + 4));
        uint64_t v30 = v28 + (v29 >> 6) - 1;
        unsigned int v27 = *(void *)(v27 + 40);
        unint64_t v28 = v30;
        if (!v27)
        {
          unint64_t v28 = v30;
          goto LABEL_59;
        }
      }
    }

    else
    {
      unint64_t v28 = 0;
    }

    uint64_t v30 = 0LL;
LABEL_59:
    unint64_t v43 = v28 | (unint64_t)(v30 << 32);
LABEL_60:
    unint64_t v44 = v27 + 64;
    while (v27)
    {
      unsigned int v45 = (uint64_t *)(v44 + ((uint64_t)(HIDWORD(v43) - (int)v43) << 6));
      if (*v45 > v18) {
        break;
      }
      GTMTLFXSMTemporalScaler_processTraceFuncWithMap((uint64_t)&v87, a1[1], v45);
      __int128 v46 = atomic_load((unsigned int *)(v27 + 4));
      __int128 v47 = v43 + (v46 >> 6);
      unsigned int v48 = (HIDWORD(v43) + 1);
      unint64_t v43 = (v48 << 32) | v43;
      if ((_DWORD)v48 == v47 - 1)
      {
        unint64_t v43 = (v48 << 32) | v48;
        unsigned int v27 = *(void *)(v27 + 40);
        goto LABEL_60;
      }
    }

    GTResourceTrackerUsingResource(a1[2], 40, (uint64_t)v16, *a1, a1[1]);
    GTResourceTrackerResourceRead(a1, 80, v92, v18);
    GTResourceTrackerResourceRead(a1, 80, *((uint64_t *)&v92 + 1), v18);
    GTResourceTrackerResourceRead(a1, 80, v93, v18);
    GTResourceTrackerResourceRead(a1, 80, *((uint64_t *)&v93 + 1), v18);
    unsigned int v42 = v94;
  }

  else
  {
    if (FuncEnumReceiverType != 39) {
      return;
    }
    __int128 v18 = *(void *)a2;
    __int128 v19 = *a1;
    *(void *)&uint64_t v87 = v16;
    uint64_t v20 = *(void *)(*find_entry(v19, &v87, 8uLL, 0LL) + 32LL);
    uint64_t v87 = 0u;
    unint64_t v88 = 0LL;
    __int128 v93 = 0u;
    unsigned int v92 = 0u;
    unsigned int v91 = 0u;
    uint64_t v90 = 0u;
    LODWORD(v87) = 39;
    uint64_t v89 = -1LL;
    __int128 v21 = *(void *)(v20 + 32);
    if (v21)
    {
      __int128 v22 = 0;
      while (1)
      {
        __int128 v23 = atomic_load((unsigned int *)(v21 + 4));
        uint64_t v24 = v22 + (v23 >> 6) - 1;
        __int128 v21 = *(void *)(v21 + 40);
        __int128 v22 = v24;
        if (!v21)
        {
          __int128 v22 = v24;
          goto LABEL_49;
        }
      }
    }

    else
    {
      __int128 v22 = 0;
    }

    uint64_t v24 = 0LL;
LABEL_49:
    __int128 v36 = v22 | (unint64_t)(v24 << 32);
LABEL_50:
    __int128 v37 = v21 + 64;
    while (v21)
    {
      BOOL v38 = (uint64_t *)(v37 + ((uint64_t)(HIDWORD(v36) - (int)v36) << 6));
      if (*v38 > v18) {
        break;
      }
      GTMTLFXSMSpatialScaler_processTraceFuncWithMap((char *)&v87, a1[1], v38);
      uint64_t v39 = atomic_load((unsigned int *)(v21 + 4));
      unsigned int v40 = v36 + (v39 >> 6);
      unint64_t v41 = (HIDWORD(v36) + 1);
      __int128 v36 = (v41 << 32) | v36;
      if ((_DWORD)v41 == v40 - 1)
      {
        __int128 v36 = (v41 << 32) | v41;
        __int128 v21 = *(void *)(v21 + 40);
        goto LABEL_50;
      }
    }

    GTResourceTrackerUsingResource(a1[2], 39, (uint64_t)v16, *a1, a1[1]);
    GTResourceTrackerResourceRead(a1, 80, v92, v18);
    unsigned int v42 = *((void *)&v92 + 1);
  }

  unsigned int v49 = tracker_resource_get(a1, 80, v42, v18);
  if (v49) {
    v49[4] = v18;
  }
  GTResourceTrackerUsingResource(a1[2], 41, *((uint64_t *)&v91 + 1), *a1, a1[1]);
}

      ++*(void *)(v35 + 64);
      *(void *)&uint64_t v39 = 0LL;
LABEL_82:
      if ((void)v39) {
        operator delete((void *)v39);
      }
      uint64_t v58 = *v102;
      unint64_t v59 = *(void *)(v35 + 48);
      if (v59)
      {
        uint64_t v60 = (uint8x8_t)vcnt_s8((int8x8_t)v59);
        v60.i16[0] = vaddlv_u8(v60);
        if (v60.u32[0] > 1uLL)
        {
          BOOL v38 = *v102;
          if (v59 <= v58) {
            BOOL v38 = v58 % v59;
          }
        }

        else
        {
          BOOL v38 = ((_DWORD)v59 - 1) & v58;
        }

        unsigned int v61 = *(void ***)(*v41 + 8 * v38);
        if (v61)
        {
          int v62 = *v61;
          if (*v61)
          {
            do
            {
              uint64_t v63 = v62[1];
              if (v63 == v58)
              {
                if (*((_DWORD *)v62 + 4) == (_DWORD)v58) {
                  goto LABEL_122;
                }
              }

              else
              {
                if (v60.u32[0] > 1uLL)
                {
                  if (v63 >= v59) {
                    v63 %= v59;
                  }
                }

                else
                {
                  v63 &= v59 - 1;
                }

                if (v63 != v38) {
                  break;
                }
              }

              int v62 = (void *)*v62;
            }

            while (v62);
          }
        }
      }

      int v62 = operator new(0x30uLL);
      void *v62 = 0LL;
      v62[1] = v58;
      *((_DWORD *)v62 + 4) = *v102;
      v62[4] = 0LL;
      v62[5] = 0LL;
      v62[3] = 0LL;
      uint64_t v64 = (float)(unint64_t)(*(void *)(v35 + 64) + 1LL);
      __int128 v65 = *(float *)(v35 + 72);
      if (!v59 || (float)(v65 * (float)v59) < v64)
      {
        uint64_t v66 = (v59 & (v59 - 1)) != 0;
        if (v59 < 3) {
          uint64_t v66 = 1LL;
        }
        int64_t v67 = v66 | (2 * v59);
        int64_t v68 = vcvtps_u32_f32(v64 / v65);
        if (v67 <= v68) {
          int64_t v69 = v68;
        }
        else {
          int64_t v69 = v67;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v35 + 40,  v69);
        unint64_t v59 = *(void *)(v35 + 48);
        if ((v59 & (v59 - 1)) != 0)
        {
          if (v59 <= v58) {
            BOOL v38 = v58 % v59;
          }
          else {
            BOOL v38 = v58;
          }
        }

        else
        {
          BOOL v38 = ((_DWORD)v59 - 1) & v58;
        }
      }

      uint64_t v70 = *v41;
      unint64_t v71 = *(void **)(*v41 + 8 * v38);
      if (v71)
      {
        void *v62 = *v71;
LABEL_120:
        *unint64_t v71 = v62;
        goto LABEL_121;
      }

      void *v62 = *(void *)(v35 + 56);
      *(void *)(v35 + 56) = v62;
      *(void *)(v70 + 8 * v38) = v35 + 56;
      if (*v62)
      {
        unsigned int v72 = *(void *)(*v62 + 8LL);
        if ((v59 & (v59 - 1)) != 0)
        {
          if (v72 >= v59) {
            v72 %= v59;
          }
        }

        else
        {
          v72 &= v59 - 1;
        }

        unint64_t v71 = (void *)(*v41 + 8 * v72);
        goto LABEL_120;
      }

      if (a4)
      {
        if (v18 > a3)
        {
          unsigned int v40 = *a4;
          __int128 v46 = 0u;
          __int128 v47 = 0u;
          unint64_t v43 = v40;
          unint64_t v44 = 500;
          unsigned int v45 = "offset <= length";
          GTError_addError(a4, (uint64_t)&v43);
        }
      }

      return;
  }

LABEL_95:
  ++a4[3];
LABEL_96:
  uint64_t v13 = v56;
LABEL_97:
  __int128 v17 = i[3];
LABEL_98:

  return v17;
}

        if (++v35 == v34) {
          goto LABEL_96;
        }
      }
    }

    unsigned int v27 = 0LL;
LABEL_99:
    uint64_t v70 = g_signpostLog;
    unint64_t v71 = (os_log_s *)v70;
    if (v135 >= 0xFFFFFFFFFFFFFFFELL)
    {

      unsigned int v72 = g_signpostLog;
    }

    else
    {
      if (os_signpost_enabled((os_log_t)v70))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v71,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
      }

      unsigned int v72 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v72))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v72,  OS_SIGNPOST_INTERVAL_BEGIN,  spid,  "Replayer-1-serial",  "FillDirtyRangesInOptimizedBuffer",  buf,  2u);
      }
    }

    unsigned int v73 = v148;
    uint64_t v133 = (void *)objc_claimAutoreleasedReturnValue([v148[1] defaultDevice]);
    unsigned int v74 = arr;
    if (v27)
    {
      unint64_t v75 = [v133 newBufferWithLength:v27 options:288];
      int v76 = v148[2817];
      v148[2817] = v75;

      unsigned int v73 = v148;
      unsigned int v74 = arr;
    }

    if (v74->nelts >= 1)
    {
      unint64_t v77 = 0LL;
      BOOL v169 = 0LL;
      while (1)
      {
        uint64_t v137 = v77;
        v170 = *(void *)&v74->elts[8 * v77];
        __int128 v78 = *find_entry((uint64_t)v139, &v170, 8uLL, 0LL);
        __int128 v144 = v78 ? *(void *)(v78 + 32) : 0LL;
        __int128 v79 = *find_entry((uint64_t)ht, &v170, 8uLL, 0LL);
        uint64_t v80 = v79 ? *(void *)(v79 + 32) : 0LL;
        uint64_t v81 = apr_array_make(v140, *(_DWORD *)(v80 + 12), 48);
        unsigned int v82 = (apr_hash_t *)v73[2818];
        unsigned int v83 = apr_palloc(v140, 8uLL);
        *unsigned int v83 = v170;
        unsigned int v163 = v81;
        apr_hash_set(v82, v83, 8LL, v81);
        uint64_t v150 = *(void *)(v80 + 24);
        int64_t v84 = *(unsigned int *)(v80 + 12);
        unint64_t v151 = v73[2817];
        uint64_t v142 = **v73;
        __int128 v147 = (apr_pool_t **)v73[19];
        uint64_t v143 = v73[3];
        v146 = v84;
LABEL_183:

        unsigned int v73 = v148;
        [v148[3] commitCommandBuffer];
        unint64_t v77 = v137 + 1;
        unsigned int v74 = arr;
        if (v137 + 1 >= arr->nelts) {
          goto LABEL_184;
        }
      }

      unint64_t v152 = 0LL;
      while (1)
      {
        context = objc_autoreleasePoolPush();
        uint64_t v85 = v150 + (v152 << 6);
        if (*(void *)v85 == 80LL) {
          break;
        }
        if (*(void *)v85 == 22LL)
        {
          if (v144)
          {
            entry = find_entry(v144, (_BYTE *)(v150 + (v152 << 6) + 8), 8uLL, 0LL);
            if (*entry) {
              uint64_t v87 = *(void *)(*entry + 32LL);
            }
            else {
              uint64_t v87 = 0LL;
            }
            if (*(_DWORD *)(v87 + 12))
            {
              uint64_t v104 = v150 + (v152 << 6);
              BOOL v164 = (uint64_t *)objc_claimAutoreleasedReturnValue([v143 bufferWithLength:*(void *)(v104 + 40) alignment:1]);
              GTCaptureArchive_fillBuffer( v142,  v147,  *(char **)(v104 + 24),  (char *)[v164 contents],  *(void *)(v104 + 40),  0);
              if (*(int *)(v87 + 12) >= 1)
              {
                unsigned int v105 = 0LL;
                unsigned int v106 = 0LL;
                do
                {
                  BOOL v169 = FillBufferWithBufferBlitOperation( (uint64_t)v148,  v85,  v164,  *(void *)(*(void *)(v87 + 24) + v105),  *(void *)(*(void *)(v87 + 24) + v105 + 8),  v151,  v169,  v163);
                  ++v106;
                  v105 += 16LL;
                }

                while (v106 < *(int *)(v87 + 12));
              }

void sub_119064(_Unwind_Exception *a1, void *a2, ...)
{
  operator delete(v4);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,void *>>>::operator()[abi:nn180100]( char a1, void **__p)
{
  if (a1)
  {
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long,std::unique_ptr<ShaderBinaryStatsInfo>>,void *>>>::operator()[abi:nn180100]( char a1, void *__p)
{
  if (a1)
  {
    unsigned int v3 = (id *)__p[3];
    __p[3] = 0LL;
    if (v3) {
      std::default_delete<ShaderBinaryStatsInfo>::operator()[abi:nn180100](v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t std::__split_buffer<std::pair<ShaderBinaryStatsInfo *,std::string>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 32;
      *(void *)(a1 + 16) = v2 - 32;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v4 = *(void *)(a1 + 16);
      }

      uint64_t v2 = v4;
    }

    while (v4 != v3);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::deque<ProfileEvent>::deque(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  unint64_t v7 = (char *)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    uint64_t v8 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }

  else
  {
    uint64_t v8 = (uint64_t *)(*(void *)v7 + 8 * (v4 & 0x1FF));
    unint64_t v9 = a2[5] + v4;
    uint64_t v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = *(void *)v10 + 8 * (v9 & 0x1FF);
  }

  else {
    unint64_t v12 = ((v11 - *(void *)v10) >> 3) + ((v10 - v7) << 6) - (((uint64_t)v8 - *(void *)v7) >> 3);
  }
  std::deque<ProfileEvent>::__append_with_size[abi:nn180100]<std::__deque_iterator<ProfileEvent,ProfileEvent const*,ProfileEvent const&,ProfileEvent const* const*,long,512l>>( (void *)a1,  v7,  v8,  v12);
  return a1;
}

void sub_119298(_Unwind_Exception *a1)
{
}

LABEL_6:
      unint64_t v4 = a2[5];
    }

    while (v4);
  }

  while (*((void *)&v78 + 1))
  {
    unint64_t v12 = *(_DWORD *)(*(void *)(*((void *)&v76 + 1) + (((unint64_t)v78 >> 6) & 0x3FFFFFFFFFFFFF8LL))
                    + 8 * (v78 & 0x1FF)
                    + 4);
    *(void *)&__int128 v78 = v78 + 1;
    --*((void *)&v78 + 1);
    if ((unint64_t)v78 >= 0x400)
    {
      operator delete(**((void ***)&v76 + 1));
      *((void *)&v76 + 1) += 8LL;
      *(void *)&__int128 v78 = v78 - 512;
    }

    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)v74,  v12,  v12);
  }

  unsigned int v73 = 0u;
  memset(v72, 0, sizeof(v72));
  memset(v70, 0, sizeof(v70));
  unint64_t v71 = 1056964608;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)v70,  0x24uLL);
  uint64_t v13 = *(void **)(a1 + 32);
  size_t v14 = v13[5];
  if (v14)
  {
    size_t v15 = 0;
    int v16 = 0LL;
    __int128 v17 = 0;
    __int128 v18 = 0;
    do
    {
      __int128 v19 = v13[4];
      ++v15;
      int64_t v69 = *(void *)(*(void *)(v13[1] + ((v19 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v19 & 0x1FF));
      uint64_t v20 = v69;
      v13[4] = v19 + 1;
      v13[5] = v14 - 1;
      std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)v13);
      if (v20 >> 28
        && !std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v74,  v15))
      {
        __int128 v21 = v20 & 0xFFFFFFF;
        if (*((void *)&v73 + 1)) {
          v17 += (unint64_t)(v21 - v16) / *((void *)&v73 + 1);
        }
        int64_t v68 = v20 & 0xFFFFFFF;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v70,  v20 & 0xFFFFFFF,  &v68)
        + 5) = v17;
        __int128 v22 = v20 >> 28;
        if (v20 >> 28 <= 7)
        {
          if (((1 << v22) & 0xF6) != 0)
          {
            std::deque<ProfileEvent>::emplace_back<ProfileEvent&>(v72, &v69);
          }

          else if (v22 == 3 && *((void *)&v73 + 1))
          {
            *(void *)&unsigned int v73 = v73 + 1;
            --*((void *)&v73 + 1);
            if ((unint64_t)v73 >= 0x400)
            {
              operator delete(**((void ***)&v72[0] + 1));
              *((void *)&v72[0] + 1) += 8LL;
              *(void *)&unsigned int v73 = v73 - 512;
            }

            uint64_t v24 = v23 & 0xFFFFFFF;
            int64_t v68 = v23 & 0xFFFFFFF;
            uint64_t v25 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v70,  v23 & 0xFFFFFFF,  &v68)
                  + 5);
            int64_t v68 = v21;
            __int128 v26 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v70,  v21,  &v68);
            unsigned int v27 = *(char ***)a1;
            unint64_t v28 = *(void *)(*(void *)a1 + 40LL);
            if (v28 < 2 || (__int128 v29 = *(void **)(a1 + 16), v30 = v29[5], v30 <= 1))
            {
              int64_t v67 = (**(unsigned int **)(a1 + 24) | (v28 << 36)) & 0x3000000FFFLL;
              uint64_t v66 = 0;
              __int128 v31 = 0;
            }

            else
            {
              __int128 v31 = 0;
              __int128 v32 = v27[4];
              unsigned int v33 = v27[1];
              unsigned int v34 = v29[4];
              uint64_t v35 = v29[1];
              __int128 v36 = (**(unsigned int **)(a1 + 24) | (v28 << 36)) & 0x3000000FFFLL | ((unint64_t)(*(_DWORD *)(*(void *)(v35 + (((unint64_t)(v34 + 1) >> 7) & 0x1FFFFFFFFFFFFF8LL)) + 4 * ((v34 + 1) & 0x3FF)) & 0xFFF) << 12);
              uint64_t v66 = *(_DWORD *)(*(void *)&v33[((unint64_t)(v32 + 1) >> 7) & 0x1FFFFFFFFFFFFF8LL]
                              + 4 * ((unint64_t)(v32 + 1) & 0x3FF));
              if (v28 >= 3 && v30 != 2)
              {
                __int128 v31 = *(_DWORD *)(*(void *)&v33[((unint64_t)(v32 + 2) >> 7) & 0x1FFFFFFFFFFFFF8LL]
                                + 4 * ((unint64_t)(v32 + 2) & 0x3FF));
                v36 |= (unint64_t)(*(_DWORD *)(*(void *)(v35
              }

              int64_t v67 = v36;
            }

            __int128 v37 = *((_DWORD *)v26 + 5) - v25;
            BOOL v38 = **(_DWORD **)(a1 + 40);
            uint64_t v39 = **(_DWORD **)(a1 + 48);
            unsigned int v40 = **(_DWORD **)(a1 + 8);
            if (v38 == -1) {
              unint64_t v41 = v23 >> 28 == 2;
            }
            else {
              unint64_t v41 = v31;
            }
            unsigned int v42 = *(void ***)(a1 + 64);
            unsigned int v45 = (v24 == 4095 || (_DWORD)v21 == 4095) && *(_BYTE *)(**(void **)(a1 + 56) + 752LL) != 0;
            __int128 v46 = (char *)v42[1];
            __int128 v47 = (char *)v42[2];
            if (v46 >= v47)
            {
              uint64_t v63 = v45;
              uint64_t v64 = v41;
              unsigned int v49 = **(_DWORD **)(a1 + 48);
              uint64_t v50 = **(_DWORD **)(a1 + 8);
              __int128 v65 = v18;
              __int128 v51 = 0xCCCCCCCCCCCCCCCDLL * ((v46 - (_BYTE *)*v42) >> 3);
              __int128 v52 = v51 + 1;
              if (v51 + 1 > 0x666666666666666LL) {
                abort();
              }
              __int128 v53 = 0xCCCCCCCCCCCCCCCDLL * ((v47 - (_BYTE *)*v42) >> 3);
              if (2 * v53 > v52) {
                __int128 v52 = 2 * v53;
              }
              if (v53 >= 0x333333333333333LL) {
                __int128 v54 = 0x666666666666666LL;
              }
              else {
                __int128 v54 = v52;
              }
              if (v54) {
                __int128 v54 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v54);
              }
              else {
                uint64_t v55 = 0LL;
              }
              uint64_t v56 = v54 + 40 * v51;
              *(_DWORD *)uint64_t v56 = v38;
              *(_DWORD *)(v56 + 4) = v49;
              *(_DWORD *)(v56 + 8) = v37;
              *(_DWORD *)(v56 + 12) = v50;
              __int128 v18 = v65;
              *(_DWORD *)(v56 + 16) = v66;
              *(_DWORD *)(v56 + 20) = v64;
              *(void *)(v56 + 24) = v67;
              *(_DWORD *)(v56 + 32) = v65;
              *(_DWORD *)(v56 + 36) = v63;
              uint64_t v58 = (char *)*v42;
              BOOL v57 = (char *)v42[1];
              unint64_t v59 = (char *)v56;
              if (v57 != *v42)
              {
                do
                {
                  uint64_t v60 = *(_OWORD *)(v57 - 40);
                  unsigned int v61 = *(_OWORD *)(v57 - 24);
                  *((void *)v59 - 1) = *((void *)v57 - 1);
                  *(_OWORD *)(v59 - 24) = v61;
                  *(_OWORD *)(v59 - 40) = v60;
                  v59 -= 40;
                  v57 -= 40;
                }

                while (v57 != v58);
                BOOL v57 = (char *)*v42;
              }

              unsigned int v48 = (void *)(v56 + 40);
              char *v42 = v59;
              v42[1] = (void *)(v56 + 40);
              v42[2] = (void *)(v54 + 40 * v55);
              if (v57) {
                operator delete(v57);
              }
            }

            else
            {
              *(_DWORD *)__int128 v46 = v38;
              *((_DWORD *)v46 + 1) = v39;
              *((_DWORD *)v46 + 2) = v37;
              *((_DWORD *)v46 + 3) = v40;
              *((_DWORD *)v46 + 4) = v66;
              *((_DWORD *)v46 + 5) = v41;
              *((void *)v46 + 3) = v67;
              unsigned int v48 = v46 + 40;
              *((_DWORD *)v46 + 8) = v18;
              *((_DWORD *)v46 + 9) = v45;
            }

            v42[1] = v48;
            ++v18;
          }
        }
      }

      else
      {
        __int128 v21 = v16;
      }

      uint64_t v13 = *(void **)(a1 + 32);
      size_t v14 = v13[5];
      int v16 = v21;
    }

    while (v14);
  }

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v70);
  std::deque<ProfileEvent>::~deque[abi:nn180100](v72);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v74);
  return std::deque<ProfileEvent>::~deque[abi:nn180100](&v76);
}

void sub_119940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_11A31C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  if (v23) {
    operator delete(v23);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a17);
  std::deque<ProfileEvent>::~deque[abi:nn180100](&a23);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v24 - 128);
  _Unwind_Resume(a1);
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper _processTracePackets:forRenderIndex:andGenerateSampleList:forTargetIndex:forLimiterIndex:]::$_1::operator() const(std::queue<ProfileEvent>)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(_DWORD *)(a2 - 8) < *(_DWORD *)(a1 + 32))
      {
        __int128 v6 = *(_OWORD *)a1;
        __int128 v7 = *(_OWORD *)(a1 + 16);
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a2 - 8);
        __int128 v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(void *)(a1 + 32) = v9;
        *(void *)(a2 - 8) = v8;
        *(_OWORD *)(a2 - 24) = v7;
        *(_OWORD *)(a2 - 40) = v6;
      }

      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)a1,  (__int128 *)(a1 + 40),  (__int128 *)(a2 - 40));
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  a1 + 40,  a1 + 80,  a2 - 40);
      return 1LL;
    case 5uLL:
      __int128 v21 = (__int128 *)(a1 + 40);
      __int128 v22 = (__int128 *)(a1 + 80);
      __int128 v23 = (__int128 *)(a1 + 120);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  a1 + 40,  a1 + 80,  a1 + 120);
      if (*(_DWORD *)(a2 - 8) >= *(_DWORD *)(a1 + 152)) {
        return 1LL;
      }
      __int128 v24 = *v23;
      __int128 v25 = *(_OWORD *)(a1 + 136);
      uint64_t v26 = *(void *)(a1 + 152);
      uint64_t v27 = *(void *)(a2 - 8);
      __int128 v28 = *(_OWORD *)(a2 - 24);
      __int128 *v23 = *(_OWORD *)(a2 - 40);
      *(_OWORD *)(a1 + 136) = v28;
      *(void *)(a1 + 152) = v27;
      *(void *)(a2 - 8) = v26;
      *(_OWORD *)(a2 - 24) = v25;
      *(_OWORD *)(a2 - 40) = v24;
      if (*(_DWORD *)(a1 + 152) >= *(_DWORD *)(a1 + 112)) {
        return 1LL;
      }
      uint64_t v29 = *(void *)(a1 + 112);
      __int128 v31 = *v22;
      __int128 v30 = *(_OWORD *)(a1 + 96);
      __int128 v32 = *(_OWORD *)(a1 + 136);
      __int128 *v22 = *v23;
      *(_OWORD *)(a1 + 96) = v32;
      *(void *)(a1 + 112) = *(void *)(a1 + 152);
      __int128 *v23 = v31;
      *(_OWORD *)(a1 + 136) = v30;
      *(void *)(a1 + 152) = v29;
      if (*(_DWORD *)(a1 + 112) >= *(_DWORD *)(a1 + 72)) {
        return 1LL;
      }
      uint64_t v33 = *(void *)(a1 + 72);
      __int128 v35 = *v21;
      __int128 v34 = *(_OWORD *)(a1 + 56);
      __int128 v36 = *(_OWORD *)(a1 + 96);
      __int128 *v21 = *v22;
      *(_OWORD *)(a1 + 56) = v36;
      *(void *)(a1 + 72) = *(void *)(a1 + 112);
      __int128 *v22 = v35;
      *(_OWORD *)(a1 + 96) = v34;
      *(void *)(a1 + 112) = v33;
      if (*(_DWORD *)(a1 + 72) >= *(_DWORD *)(a1 + 32)) {
        return 1LL;
      }
      uint64_t v37 = *(void *)(a1 + 32);
      __int128 v39 = *(_OWORD *)a1;
      __int128 v38 = *(_OWORD *)(a1 + 16);
      __int128 v40 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)a1 = *v21;
      *(_OWORD *)(a1 + 16) = v40;
      *(void *)(a1 + 32) = *(void *)(a1 + 72);
      __int128 *v21 = v39;
      *(_OWORD *)(a1 + 56) = v38;
      BOOL result = 1LL;
      *(void *)(a1 + 72) = v37;
      return result;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( (__int128 *)a1,  (__int128 *)(a1 + 40),  (__int128 *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1LL;
      }
      uint64_t v13 = 0LL;
      int v14 = 0;
      break;
  }

  while (1)
  {
    unsigned int v15 = *(_DWORD *)(v12 + 32);
    if (v15 < *(_DWORD *)(v11 + 32))
    {
      __int128 v41 = *(_OWORD *)v12;
      __int128 v42 = *(_OWORD *)(v12 + 16);
      int v16 = *(_DWORD *)(v12 + 36);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        __int128 v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(void *)(v18 + 152) = *(void *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40LL;
        if (v15 >= *(_DWORD *)(v18 + 72))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_13;
        }
      }

      uint64_t v20 = a1;
LABEL_13:
      *(_OWORD *)uint64_t v20 = v41;
      *(_OWORD *)(v20 + 16) = v42;
      *(_DWORD *)(v20 + 32) = v15;
      *(_DWORD *)(v20 + 36) = v16;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }

    uint64_t v11 = v12;
    v13 += 40LL;
    v12 += 40LL;
    if (v12 == a2) {
      return 1LL;
    }
  }

GTMTLReplayRasterMapQuery *GTMTLReplayClient_queryRasterMap(uint64_t a1, uint64_t a2, void **a3)
{
  if (a1)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) rasterizationRateMapForKey:a2]);
    unint64_t v4 = v3;
    if (v3)
    {
      [v3 screenSize];
      [v4 physicalGranularity];
    }

    else
    {
      uint64_t v34 = 0LL;
      uint64_t v35 = 0LL;
      uint64_t v36 = 0LL;
      __int128 v32 = 0uLL;
      uint64_t v33 = 0LL;
    }

    __int128 v7 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v4 layerCount]);
    if ([v4 layerCount])
    {
      unint64_t v8 = 0LL;
      do
      {
        if (v4)
        {
          [v4 physicalSizeForLayer:v8];
        }

        else
        {
          __int128 v30 = 0uLL;
          uint64_t v31 = 0LL;
        }

        uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if ((void)v30)
        {
          unint64_t v12 = 0LL;
          do
          {
            *(float *)&double v10 = (float)v12;
            LODWORD(v11) = 0;
            objc_msgSend(v4, "mapPhysicalToScreenCoordinates:forLayer:", v8, v10, v11);
            uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:"));
            -[NSMutableArray addObject:](v9, "addObject:", v13);

            v12 += v32;
          }

          while (v12 < (unint64_t)v30);
        }

        int v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v34));
        -[NSMutableArray addObject:](v9, "addObject:", v14);

        unsigned int v15 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if (*((void *)&v30 + 1))
        {
          unint64_t v18 = 0LL;
          do
          {
            *(float *)&double v17 = (float)v18;
            LODWORD(v16) = 0;
            objc_msgSend(v4, "mapPhysicalToScreenCoordinates:forLayer:", v8, v16, v17);
            LODWORD(v20) = v19;
            __int128 v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v20));
            -[NSMutableArray addObject:](v15, "addObject:", v21);

            v18 += *((void *)&v32 + 1);
          }

          while (v18 < *((void *)&v30 + 1));
        }

        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v35));
        -[NSMutableArray addObject:](v15, "addObject:", v22);

        __int128 v23 = objc_alloc_init(&OBJC_CLASS___GTMTLReplayRasterMapLayerQuery);
        __int128 v28 = v30;
        uint64_t v29 = 0LL;
        -[GTMTLReplayRasterMapLayerQuery setSize:](v23, "setSize:", &v28);
        -[GTMTLReplayRasterMapLayerQuery setHorizontalLogicalCoordinatesAtPhysicalTileBoundaries:]( v23,  "setHorizontalLogicalCoordinatesAtPhysicalTileBoundaries:",  v9);
        -[GTMTLReplayRasterMapLayerQuery setVerticalLogicalCoordinatesAtPhysicalTileBoundaries:]( v23,  "setVerticalLogicalCoordinatesAtPhysicalTileBoundaries:",  v15);
        -[NSMutableArray setObject:atIndexedSubscript:](v7, "setObject:atIndexedSubscript:", v23, v8);

        ++v8;
      }

      while (v8 < (unint64_t)[v4 layerCount]);
    }

    __int128 v24 = objc_alloc_init(&OBJC_CLASS___GTMTLReplayRasterMapQuery);
    __int128 v26 = v32;
    uint64_t v27 = v33;
    -[GTMTLReplayRasterMapQuery setPhysicalGranularity:](v24, "setPhysicalGranularity:", &v26);
    -[GTMTLReplayRasterMapQuery setLayers:](v24, "setLayers:", v7);
  }

  else
  {
    NSErrorUserInfoKey v37 = NSLocalizedDescriptionKey;
    __int128 v38 = @"Raster map query failed: controller not initialized";
    unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v38,  &v37,  1LL));
    GTMTLReplay_fillError(a3, 101, v4);
    if (a3) {
      __int128 v6 = *a3;
    }
    else {
      __int128 v6 = 0LL;
    }
    GTMTLReplay_handleNSError(v6);
    __int128 v24 = 0LL;
  }

  return v24;
}

void *HarvestResourceObject(id *a1, apr_pool_t *a2, void *a3, unsigned int ***a4, void **a5)
{
  id v7 = a3;
  [(id)g_activityLog enterHarvestResourceObjectWithAttributes:v7];
  v423 = v7;
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"requestID"]);
  id v413 = [v8 unsignedLongLongValue];

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"streamref"]);
  uint64_t v414 = (uint64_t)[v9 unsignedLongLongValue];

  double v10 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"type"]);
  id v11 = [v10 unsignedIntValue];

  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"object"]);
  obuint64_t j = (char *)[v12 unsignedLongLongValue];

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"functionIndex"]);
  unsigned int v14 = [v13 unsignedIntValue];

  unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"functionIndex"]);
  unint64_t v16 = (unint64_t)[v15 unsignedLongLongValue];

  v417 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"resolution"]);
  v416 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"objectThreadgroupRange"]);
  [(*a4)[2] appendBytes:"MTSP" length:8];
  __int128 v460 = 0u;
  __int128 v461 = 0u;
  __int128 v462 = 0u;
  DWORD2(v460) = 7;
  LODWORD(v461) = 2;
  DYTraceEncode_InternalData((uint64_t)&v460, **a4);
  double v17 = **a4;
  uint64_t v18 = *v17;
  if ((*((_BYTE *)v17 + 33) & 0x10) != 0)
  {
    double v20 = **a4;
    uint64_t v19 = *v17;
    do
    {
      double v20 = (unsigned int *)((char *)v20 + v18);
      uint64_t v18 = *v20;
      v19 += v18;
    }

    while ((*((_BYTE *)v20 + 33) & 0x20) == 0);
  }

  else
  {
    uint64_t v19 = *v17;
  }

  [(*a4)[2] appendBytes:v17 length:v19];
  uint64_t v21 = HIDWORD(v16);
  __int128 v22 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    LODWORD(v504[0]) = 67109120;
    DWORD1(v504[0]) = v14;
    _os_signpost_emit_with_name_impl( &dword_0,  v22,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "debugFuncStop %u",  (uint8_t *)v504,  8u);
  }

  GTMTLReplayController_debugSubCommandStop((uint64_t)a1, v14, v21);
  __int128 v23 = a1 + 2810;
  __int128 v24 = (os_log_s *)g_signpostLog;
  if (os_signpost_enabled((os_log_t)g_signpostLog))
  {
    LOWORD(v504[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v24,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)v504,  2u);
  }

  if ((int)v11 > 21)
  {
    if ((_DWORD)v11 != 22)
    {
      if ((_DWORD)v11 != 24)
      {
        if ((_DWORD)v11 == 39)
        {
          ht = (apr_hash_t *)a1[1];
          AliasStreaunint64_t m = (uint64_t *)GetAliasStream(*((void *)*a1 + 3), (uint64_t)obj, *((void *)*a1 + 10) + v14 - 1LL);
          if (AliasStream) {
            uint64_t v27 = *AliasStream;
          }
          else {
            uint64_t v27 = 0LL;
          }
          if (s_logUsingOsLog)
          {
            id v37 = gt_tagged_log(1uLL);
            __int128 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              LODWORD(v504[0]) = 134217984;
              *(void *)((char *)v504 + 4) = v27;
              _os_log_impl( &dword_0,  v38,  OS_LOG_TYPE_INFO,  "Harvesting rasterization rate map %llu",  (uint8_t *)v504,  0xCu);
            }
          }

          else
          {
            uint64_t v63 = __stdoutp;
            __int128 v38 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting rasterization rate map %llu", v27));
            fprintf(v63, "%s\n", (const char *)-[os_log_s UTF8String](v38, "UTF8String"));
          }

          RasterMap = GTMTLReplayClient_queryRasterMap((uint64_t)a1, v27, a5);
          __int128 v65 = (void *)objc_claimAutoreleasedReturnValue(RasterMap);
          if (!v65)
          {
            GTMTLReplay_fillError(a5, 101, &__NSDictionary0__struct);
            if (a5) {
              unint64_t v88 = *a5;
            }
            else {
              unint64_t v88 = 0LL;
            }
            GTMTLReplay_handleNSError(v88);
            uint64_t v36 = 0LL;
            goto LABEL_238;
          }

          pa = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          __int128 v440 = 0u;
          __int128 v441 = 0u;
          __int128 v438 = 0u;
          __int128 v439 = 0u;
          v408 = v65;
          uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v65 layers]);
          id v67 = [v66 countByEnumeratingWithState:&v438 objects:v471 count:16];
          if (v67)
          {
            uint64_t v68 = *(void *)v439;
            id obja = v66;
            do
            {
              for (uint64_t i = 0LL; i != v67; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v439 != v68) {
                  objc_enumerationMutation(obja);
                }
                uint64_t v70 = *(void **)(*((void *)&v438 + 1) + 8LL * (void)i);
                v469[0] = @"RasterizationRateLayerPhysicalSize";
                if (v70)
                {
                  [v70 size];
                  uint64_t v71 = v435;
                }

                else
                {
                  uint64_t v71 = 0LL;
                  uint64_t v435 = 0LL;
                  uint64_t v436 = 0LL;
                  uint64_t v437 = 0LL;
                }

                unsigned int v72 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v71));
                v468[0] = v72;
                if (v70)
                {
                  [v70 size];
                  uint64_t v73 = v433;
                }

                else
                {
                  uint64_t v73 = 0LL;
                  v432[10] = 0LL;
                  uint64_t v433 = 0LL;
                  uint64_t v434 = 0LL;
                }

                unsigned int v74 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v73));
                v468[1] = v74;
                unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v468,  2LL));
                v470[0] = v75;
                v469[1] = @"RasterizationRateLayerHorizontalLogicalCoordinatesAtPhysicalTileBoundaries";
                int v76 = (void *)objc_claimAutoreleasedReturnValue([v70 horizontalLogicalCoordinatesAtPhysicalTileBoundaries]);
                v470[1] = v76;
                v469[2] = @"RasterizationRateLayerVerticalLogicalCoordinatesAtPhysicalTileBoundaries";
                unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue([v70 verticalLogicalCoordinatesAtPhysicalTileBoundaries]);
                v470[2] = v77;
                __int128 v78 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v470,  v469,  3LL));
                -[NSMutableArray addObject:](pa, "addObject:", v78);
              }

              uint64_t v66 = obja;
              id v67 = [obja countByEnumeratingWithState:&v438 objects:v471 count:16];
            }

            while (v67);
          }

          v466[0] = @"RasterizationRateMapPhysicalGranularity";
          [v408 physicalGranularity];
          __int128 v79 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v432[7]));
          v465[0] = v79;
          [v408 physicalGranularity];
          uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v432[5]));
          v465[1] = v80;
          [v408 physicalGranularity];
          uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v432[3]));
          v465[2] = v81;
          unsigned int v82 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v465,  3LL));
          v466[1] = @"RasterizationRateLayers";
          v467[0] = v82;
          v467[1] = pa;
          unsigned int v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v467,  v466,  2LL));
          v432[0] = 0LL;
          int64_t v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v83,  0LL,  v432));
          id v85 = v432[0];
          [a4[1] setObject:v84 forKeyedSubscript:@"MTLRasterizationRateMap-DerivedMetadata"];

          if (v85)
          {
            v463[0] = NSLocalizedDescriptionKey;
            v463[1] = NSUnderlyingErrorKey;
            v464[0] = @"Serializing MTLRasterizationRateMap-DerivedMetadata failed.";
            v464[1] = v85;
            id v86 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v464,  v463,  2LL));
            GTMTLReplay_fillError(a5, 101, v86);
            if (a5) {
              uint64_t v87 = *a5;
            }
            else {
              uint64_t v87 = 0LL;
            }
            GTMTLReplay_handleNSError(v87);

            goto LABEL_222;
          }

LABEL_211:
          uint64_t v36 = &dword_0 + 1;
LABEL_223:
          id v197 = v408;
LABEL_237:

LABEL_238:
          goto LABEL_239;
        }

        goto LABEL_34;
      }

      uint64_t v32 = v414;
      if (!v414)
      {
        uint64_t v33 = (uint64_t *)GetAliasStream(*((void *)*a1 + 3), (uint64_t)obj, *((void *)*a1 + 10) + v14 - 1LL);
        if (v33) {
          uint64_t v32 = *v33;
        }
        else {
          uint64_t v32 = 0LL;
        }
      }

      ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue([a1[1] indirectCommandBufferForKey:v32]);
      if (s_logUsingOsLog)
      {
        id v112 = gt_tagged_log(1uLL);
        __int128 v113 = (os_log_s *)objc_claimAutoreleasedReturnValue(v112);
        if (os_log_type_enabled(v113, OS_LOG_TYPE_INFO))
        {
          __int128 v114 = (void *)objc_claimAutoreleasedReturnValue(-[apr_hash_t label](ht, "label"));
          if (v114)
          {
            __int128 v24 = (os_log_s *) objc_claimAutoreleasedReturnValue(-[apr_hash_t label](ht, "label"));
            __int128 v115 = (const char *)-[os_log_s UTF8String](v24, "UTF8String");
          }

          else
          {
            __int128 v115 = "no label";
          }

          LODWORD(v504[0]) = 134218242;
          *(void *)((char *)v504 + 4) = v32;
          WORD6(v504[0]) = 2080;
          *(void *)((char *)v504 + 14) = v115;
          _os_log_impl( &dword_0,  v113,  OS_LOG_TYPE_INFO,  "Harvesting Indirect Command Buffer %llu (%s)",  (uint8_t *)v504,  0x16u);
          if (v114) {
        }
          }
      }

      else
      {
        __int128 v116 = __stdoutp;
        __int128 v113 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[apr_hash_t label](ht, "label"));
        if (v113)
        {
          a2 = (apr_pool_t *) objc_claimAutoreleasedReturnValue(-[apr_hash_t label](ht, "label"));
          __int128 v117 = (const char *)-[apr_pool_t UTF8String](a2, "UTF8String");
        }

        else
        {
          __int128 v117 = "no label";
        }

        id v118 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting Indirect Command Buffer %llu (%s)", v32, v117));
        fprintf(v116, "%s\n", (const char *)[v118 UTF8String]);

        if (v113) {
        else
        }
          __int128 v113 = 0LL;
      }

      uint64_t v202 = GTMTLSMContext_getObject(**((void **)*a1 + 5), v32, *((void *)*a1 + 10) + v14 - 1LL)[13];
      id v197 = (id)objc_claimAutoreleasedReturnValue(-[apr_hash_t device](ht, "device"));
      id v203 = -[apr_hash_t size](ht, "size");
      MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(v202);
      uint64_t v205 = (void *)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
      id v206 = [v197 newIndirectCommandBufferWithDescriptor:v205 maxCommandCount:v203 options:0];

      uint64_t v207 = (void *)objc_claimAutoreleasedReturnValue([a1[3] blitCommandEncoder]);
      objc_msgSend( v207,  "copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:",  ht,  0,  v203,  v206,  0);

      if (v414) {
        uint64_t v208 = (char *)v414;
      }
      else {
        uint64_t v208 = obj;
      }
      v209 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLIndirectCommandBuffer-0x%llx-Fetch",  v208));
      v472[0] = v206;
      v210 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v202, 24LL));
      v472[1] = v210;
      v211 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v472, 2LL));

      [a4[1] setObject:v211 forKeyedSubscript:v209];
      GTMTLCreateIndirectCommandEncoder((uint64_t)v504, v202);
      if (a4[2] && v413)
      {
        v212 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v413));
        [a4[2] setObject:v212 forKeyedSubscript:v209];
      }

      v443[0] = 0LL;
      v443[1] = v208;
      id v213 = v209;
      v443[2] = [v213 UTF8String];
      v443[3] = 0LL;
      v443[4] = *((void *)&v504[6] + 1) * (void)v203;
      DYTraceEncode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)v443, **a4);
      v214 = **a4;
      uint64_t v215 = *v214;
      if ((*((_BYTE *)v214 + 33) & 0x10) != 0)
      {
        v217 = **a4;
        uint64_t v216 = *v214;
        do
        {
          v217 = (unsigned int *)((char *)v217 + v215);
          uint64_t v215 = *v217;
          v216 += v215;
        }

        while ((*((_BYTE *)v217 + 33) & 0x20) == 0);
      }

      else
      {
        uint64_t v216 = *v214;
      }

      [(*a4)[2] appendBytes:v214 length:v216];

LABEL_236:
      uint64_t v36 = &dword_0 + 1;
      goto LABEL_237;
    }

    if (s_logUsingOsLog)
    {
      id v30 = gt_tagged_log(1uLL);
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        LOWORD(v504[0]) = 0;
        _os_log_impl(&dword_0, v31, OS_LOG_TYPE_INFO, "Harvesting threadgroup buffer", (uint8_t *)v504, 2u);
      }
    }

    else
    {
      __int128 v39 = __stdoutp;
      uint64_t v31 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting threadgroup buffer"));
      fprintf(v39, "%s\n", (const char *)-[os_log_s UTF8String](v31, "UTF8String"));
    }

    GTMTLReplayController_rewind((uint64_t)a1);
    GTMTLReplayController_debugSubCommand((unsigned int *)a1, v14, v21);
    if (*((_DWORD *)a1 + 2828) != 70) {
      goto LABEL_227;
    }
    __int128 v40 = obj + 1025;
    uint64_t v41 = (void)(obj + 1025) << 32;
    uint64_t v42 = *(unsigned int *)((char *)a1 + (v41 >> 30) + 22064);
    if (!(_DWORD)v42) {
      goto LABEL_227;
    }
    unint64_t v43 = (uint64_t **)*a1;
    unint64_t v44 = (apr_hash_t *)*((void *)*a1 + 10);
    uint64_t v45 = *v23;
    uint64_t v46 = *(unsigned int *)((char *)a1 + (v41 >> 30) + 22188);
    uint64_t v47 = GTMTLReplayController_renderPassDescriptor((uint64_t)a1);
    unint64_t v48 = *(unsigned __int16 *)(v47 + 814);
    if (!*(_WORD *)(v47 + 814) || (uint64_t v49 = v47, ht = v44, v50 = *(unsigned __int16 *)(v47 + 812), !*(_WORD *)(v47 + 812)))
    {
LABEL_227:
      id NSError = MakeNSError(101, &__NSDictionary0__struct);
      id v53 = (id)objc_claimAutoreleasedReturnValue(NSError);
      GTMTLReplay_handleNSError(v53);
      ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
      goto LABEL_228;
    }

    uint64_t v404 = v46;
    uint64_t v407 = v45;
    id v51 = a1[2808];
    id v52 = a1[2809];
    id v53 = a1[1];
    p = (apr_pool_t *)objc_claimAutoreleasedReturnValue([v53 defaultDevice]);
    id v415 = a1[3];
    __int128 v54 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v415,  "bufferWithLength:alignment:",  ((unint64_t)v51 + (v48 - 1))
                    / v48
                    * v42
                    * (((unint64_t)v52 + (v50 - 1))
                     / v50),
                      1LL));
    if (v54)
    {
      if ((GT_SUPPORT_0 & 1) != 0)
      {
        v411 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
        v505[0] = (apr_pool_t *)@"THREADGROUP_MEMORY_LENGTH";
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v42));
        *(void *)__dst = v55;
        v505[1] = (apr_pool_t *)@"THREADGROUP_MEMORY_INDEX";
        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v40));
        *(void *)&__dst[8] = v56;
        BOOL v57 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  __dst,  v505,  2LL));
        -[MTLCompileOptions setPreprocessorMacros:](v411, "setPreprocessorMacros:", v57);

        *(void *)&__int128 v487 = 0LL;
        id v58 = -[apr_pool_t newLibraryWithSource:options:error:]( p,  "newLibraryWithSource:options:error:",  @"#include <metal_stdlib>\nusing namespace metal;\n\nkernel void dumpThreadgroupData(uint2 threadgroupInGrid [[ threadgroup_position_in_grid ]],\n                                uint2 threadgroupsPerGrid [[ threadgroups_per_grid ]],\n                                device uint8_t* threadgroupBufferDump [[ buffer(0) ]],\n                                threadgroup uint8_t* threadgroupData [[ threadgroup(THREADGROUP_MEMORY_INDEX) ]])\n{\n   uint tileIndex = (threadgroupInGrid.y * threadgroupsPerGrid.x) + threadgroupInGrid.x;\n   uint offset = THREADGROUP_MEMORY_LENGTH * tileIndex;\n\n   for (int i = 0; i < THREADGROUP_MEMORY_LENGTH; i++)\n   {\n       threadgroupBufferDump[offset + i] = threadgroupData[i];\n   }\n}\n",
                v411,
                &v487);
        v402 = (apr_pool_t *)(id)v487;
        if (v58)
        {
          v400 = (NSString *)[v58 newFunctionWithName:@"dumpThreadgroupData"];
          if (v400)
          {
            unint64_t v59 = objc_alloc_init(&OBJC_CLASS___MTLTileRenderPipelineDescriptor);
            -[MTLTileRenderPipelineDescriptor setLabel:]( v59,  "setLabel:",  @"Tile Pipeline for dumping Threadgroup data");
            -[MTLTileRenderPipelineDescriptor setTileFunction:](v59, "setTileFunction:", v400);
            FillAttachmentPixelFormats(v49, v43[5], (unint64_t)ht + v407, v59);
            NSErrorUserInfoKey v522 = (NSErrorUserInfoKey)v402;
            id v60 = -[apr_pool_t newRenderPipelineStateWithTileDescriptor:error:]( p,  "newRenderPipelineStateWithTileDescriptor:error:",  v59,  &v522);
            unsigned int v61 = v522;

            if (v60)
            {
              int v62 = 0;
            }

            else
            {
              NSErrorUserInfoKey v521 = 0LL;
              GTMTLReplay_fillError(&v521, 101, &__NSDictionary0__struct);
              v370 = v521;
              GTMTLReplay_handleNSError(v370);
              ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));

              id v60 = 0LL;
              int v62 = 1;
            }

            v402 = (apr_pool_t *)v61;
          }

          else
          {
            NSErrorUserInfoKey v522 = 0LL;
            GTMTLReplay_fillError(&v522, 101, &__NSDictionary0__struct);
            unint64_t v59 = v522;
            GTMTLReplay_handleNSError(v59);
            ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
            id v60 = 0LL;
            int v62 = 1;
          }
        }

        else
        {
          NSErrorUserInfoKey v522 = 0LL;
          GTMTLReplay_fillError(&v522, 101, &__NSDictionary0__struct);
          v400 = v522;
          GTMTLReplay_handleNSError(v400);
          ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
          id v60 = 0LL;
          int v62 = 1;
        }

        if (v62) {
          goto LABEL_341;
        }
        v371 = (void *)objc_claimAutoreleasedReturnValue([v53 renderCommandEncoderForKey:a1[1415]]);
        [v371 pushDebugGroup:@"Dump Tile Threadgroup Data"];
        [v371 setRenderPipelineState:v60];
        v372 = (void *)objc_claimAutoreleasedReturnValue([v54 heapBuffer]);
        objc_msgSend(v371, "setTileBuffer:offset:atIndex:", v372, objc_msgSend(v54, "heapLocation"), 0);

        [v371 setThreadgroupMemoryLength:v42 offset:v404 atIndex:(int)v40];
        v504[0] = vdupq_n_s64(1uLL);
        *(void *)&v504[1] = 1LL;
        [v371 dispatchThreadsPerTile:v504];
        [v371 popDebugGroup];
      }

      ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue([v54 data]);
      goto LABEL_344;
    }

    id v282 = MakeNSError(101, &__NSDictionary0__struct);
    id v60 = (id)objc_claimAutoreleasedReturnValue(v282);
    GTMTLReplay_handleNSError(v60);
    ht = (apr_hash_t *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
LABEL_341:

LABEL_344:
LABEL_228:

    [a1[1] commitCommandBuffers];
    v275 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLBuffer-0x%llx-Fetch",  obj));
    [a4[1] setObject:ht forKeyedSubscript:v275];
    if (a4[2] && v413)
    {
      v276 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v413));
      [a4[2] setObject:v276 forKeyedSubscript:v275];
    }

    v442[0] = 0LL;
    v442[1] = obj;
    id v197 = v275;
    v442[2] = [v197 UTF8String];
    v442[3] = 0LL;
    v442[4] = -[apr_hash_t length](ht, "length");
    DYTraceEncode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)v442, **a4);
    v277 = **a4;
    uint64_t v278 = *v277;
    if ((*((_BYTE *)v277 + 33) & 0x10) != 0)
    {
      v280 = **a4;
      uint64_t v279 = *v277;
      do
      {
        v280 = (unsigned int *)((char *)v280 + v278);
        uint64_t v278 = *v280;
        v279 += v278;
      }

      while ((*((_BYTE *)v280 + 33) & 0x20) == 0);
    }

    else
    {
      uint64_t v279 = *v277;
    }

    [(*a4)[2] appendBytes:v277 length:v279];
    goto LABEL_236;
  }

  if ((_DWORD)v11 == 1)
  {
    if (obj == (char *)-3LL)
    {
      if (s_logUsingOsLog)
      {
        id v95 = gt_tagged_log(1uLL);
        __int128 v96 = (os_log_s *)objc_claimAutoreleasedReturnValue(v95);
        if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
        {
          LOWORD(v504[0]) = 0;
          _os_log_impl(&dword_0, v96, OS_LOG_TYPE_INFO, "Harvesting solid wireframe texture", (uint8_t *)v504, 2u);
        }
      }

      else
      {
        v224 = __stdoutp;
        __int128 v96 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting solid wireframe texture"));
        fprintf(v224, "%s\n", (const char *)-[os_log_s UTF8String](v96, "UTF8String"));
      }

      v458 = 0LL;
      v219 = &v458;
      id v225 = GTMTLReplayController_generateWireframeTexture( (uint64_t)a1,  (uint64_t)a2,  0LL,  (apr_allocator_t *)((char *)&dword_0 + 1),  &v458);
      uint64_t v221 = objc_claimAutoreleasedReturnValue(v225);
      goto LABEL_186;
    }

    if (obj == (char *)-2LL)
    {
      if (s_logUsingOsLog)
      {
        id v93 = gt_tagged_log(1uLL);
        __int128 v94 = (os_log_s *)objc_claimAutoreleasedReturnValue(v93);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_INFO))
        {
          LOWORD(v504[0]) = 0;
          _os_log_impl(&dword_0, v94, OS_LOG_TYPE_INFO, "Harvesting outline texture", (uint8_t *)v504, 2u);
        }
      }

      else
      {
        v222 = __stdoutp;
        __int128 v94 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting outline texture"));
        fprintf(v222, "%s\n", (const char *)-[os_log_s UTF8String](v94, "UTF8String"));
      }

      v457 = 0LL;
      v219 = &v457;
      id v223 = GTMTLReplayController_generateOutlineTexture((uint64_t)a1, (id *)a2, &v457);
      uint64_t v221 = objc_claimAutoreleasedReturnValue(v223);
      goto LABEL_186;
    }

    if (obj == (char *)-1LL)
    {
      if (s_logUsingOsLog)
      {
        id v34 = gt_tagged_log(1uLL);
        uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
        {
          LOWORD(v504[0]) = 0;
          _os_log_impl(&dword_0, v35, OS_LOG_TYPE_INFO, "Harvesting wireframe texture", (uint8_t *)v504, 2u);
        }
      }

      else
      {
        v218 = __stdoutp;
        uint64_t v35 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting wireframe texture"));
        fprintf(v218, "%s\n", (const char *)-[os_log_s UTF8String](v35, "UTF8String"));
      }

      v459 = 0LL;
      v219 = &v459;
      id v220 = GTMTLReplayController_generateWireframeTexture((uint64_t)a1, (uint64_t)a2, 1LL, 0LL, &v459);
      uint64_t v221 = objc_claimAutoreleasedReturnValue(v220);
LABEL_186:
      id v226 = (id)v221;
      id v227 = *v219;
LABEL_187:
      if (v226) {
        goto LABEL_188;
      }
      if (v227)
      {
        NSErrorUserInfoKey v485 = NSUnderlyingErrorKey;
        id v486 = v227;
        char v236 = 0;
        v237 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v486,  &v485,  1LL));
      }

      else
      {
        v237 = 0LL;
        char v236 = 1;
      }

      goto LABEL_271;
    }

    if ((unint64_t)obj < 0xFFFFFFFFFFFFFDFFLL)
    {
      uint64_t v187 = v414;
      if (!v414)
      {
        unsigned int v188 = (uint64_t *)GetAliasStream(*((void *)*a1 + 3), (uint64_t)obj, *((void *)*a1 + 10) + v14 - 1LL);
        if (v188) {
          uint64_t v187 = *v188;
        }
        else {
          uint64_t v187 = 0LL;
        }
      }

      id v296 = a1[5];
      v297 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v187));
      id v226 = (id)objc_claimAutoreleasedReturnValue([v296 objectForKeyedSubscript:v297]);

      if (!v226) {
        id v226 = (id)objc_claimAutoreleasedReturnValue([a1[1] textureForKey:v187]);
      }
      if (s_logUsingOsLog)
      {
        id v298 = gt_tagged_log(1uLL);
        v299 = (os_log_s *)objc_claimAutoreleasedReturnValue(v298);
        if (os_log_type_enabled(v299, OS_LOG_TYPE_INFO))
        {
          v300 = (void *)objc_claimAutoreleasedReturnValue([v226 label]);
          if (v300)
          {
            __int128 v24 = (os_log_s *) objc_claimAutoreleasedReturnValue([v226 label]);
            v301 = (const char *)-[os_log_s UTF8String](v24, "UTF8String");
          }

          else
          {
            v301 = "no label";
          }

          LODWORD(v504[0]) = 134218242;
          *(void *)((char *)v504 + 4) = v187;
          WORD6(v504[0]) = 2080;
          *(void *)((char *)v504 + 14) = v301;
          _os_log_impl(&dword_0, v299, OS_LOG_TYPE_INFO, "Harvesting texture %llu (%s)", (uint8_t *)v504, 0x16u);
          if (v300) {
        }
          }
      }

      else
      {
        v302 = __stdoutp;
        v299 = (os_log_s *)objc_claimAutoreleasedReturnValue([v226 label]);
        if (v299)
        {
          __int128 v23 = objc_claimAutoreleasedReturnValue([v226 label]);
          v303 = (const char *)[v23 UTF8String];
        }

        else
        {
          v303 = "no label";
        }

        id v304 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting texture %llu (%s)", v187, v303));
        fprintf(v302, "%s\n", (const char *)[v304 UTF8String]);

        if (v299) {
        else
        }
          v299 = 0LL;
      }

      v305 = (void *)objc_claimAutoreleasedReturnValue( [v423 objectForKeyedSubscript:@"DependencyGraphRequestedThumbnailTextureID"]);
      v306 = v305;
      if (v305) {
        obuint64_t j = (char *)[v305 unsignedLongLongValue];
      }

      id v227 = 0LL;
      if (v226)
      {
LABEL_188:
        v408 = v227;
        id v484 = v226;
        v228 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v484,  1LL));
        GTMTLReplayClient_waitForUntrackedWritesToComplete((uint64_t)a1, v228);

        id v229 = [v226 width];
        id v230 = [v226 height];
        *(void *)&v504[0] = v229;
        *((void *)&v504[0] + 1) = v230;
        *(void *)&v504[1] = 1LL;
        *(_OWORD *)v505 = v504[0];
        *(void *)&__int128 v506 = 1LL;
        GTMTLReplayClient_resizeResolution((unint64_t *)__dst, v417, (unint64_t *)v505);
        if ([v226 storageMode] == (char *)&dword_0 + 3)
        {
          v504[0] = *(_OWORD *)__dst;
          *(void *)&v504[1] = *(void *)&__dst[16];
          MTLTextureDescriptorFromTextureWithoutResourceIndex = MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(v226);
          v232 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorFromTextureWithoutResourceIndex);
          [v232 setWidth:*(void *)&v504[0]];
          [v232 setHeight:*((void *)&v504[0] + 1)];
          [v232 setDepth:*(void *)&v504[1]];
          [v232 setStorageMode:2];
          v233 = (void *)objc_claimAutoreleasedReturnValue([v226 device]);
          v234 = (apr_hash_t *)[v233 newTextureWithDescriptor:v232];

          if (!v234)
          {
            v482 = @"GTErrorKeyMTLTextureDescriptor";
            id v256 = SerializeMTLTextureDescriptorToDictionary(v232);
            v247 = (void *)objc_claimAutoreleasedReturnValue(v256);
            v483 = v247;
            v248 = (apr_hash_t *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v483,  &v482,  1LL));
            GTMTLReplay_fillError(a5, 102, v248);
            ht = 0LL;
LABEL_221:

            goto LABEL_222;
          }

          v235 = v234;
        }

        else
        {
          v235 = (apr_hash_t *)v226;
        }

        uint64_t v238 = *(void *)&v504[0] ^ *(void *)__dst | *((void *)&v504[0] + 1) ^ *(void *)&__dst[8] | *(void *)&v504[1] ^ *(void *)&__dst[16];
        ht = v235;
        if (-[apr_hash_t textureType](v235, "textureType") == &dword_4
          || -[apr_hash_t textureType](v235, "textureType") == &dword_8)
        {
          v239 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"resolveMultisampleTexture"]);
          v240 = v239;
          if (v239) {
            id v241 = v239;
          }
          else {
            id v241 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v238 != 0));
          }
          v242 = v241;

          int v243 = [v242 BOOLValue];
        }

        else
        {
          int v243 = 0;
        }

        if (v238 | v414)
        {
          v481 = v423;
          v244 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v481,  1LL));
          v480 = v235;
          v245 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v480,  1LL));
          v455 = 0LL;
          v246 = GTMTLReplayClient_retrieveTexturesForResize(a1, v244, v245, v243, &v455);
          v247 = (void *)objc_claimAutoreleasedReturnValue(v246);
          v232 = v455;

          if (v232)
          {
            NSErrorUserInfoKey v478 = NSUnderlyingErrorKey;
            v479 = v232;
            v248 = (apr_hash_t *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v479,  &v478,  1LL));
            GTMTLReplay_fillError(a5, 101, v248);
            if (a5) {
              v249 = *a5;
            }
            else {
              v249 = 0LL;
            }
            GTMTLReplay_handleNSError(v249);
            goto LABEL_221;
          }

          if (v238)
          {
            v257 = (void *)objc_claimAutoreleasedReturnValue([a1[1] defaultCommandQueue]);
            id v258 = InternalCommandBuffer(v257, @"ResizeTexture");
            v248 = (apr_hash_t *)objc_claimAutoreleasedReturnValue(v258);

            id v259 = a1[2];
            v260 = (void *)objc_claimAutoreleasedReturnValue([v247 objectAtIndexedSubscript:0]);
            v454 = 0LL;
            id v261 = GTMTLReplayController_resizeTexture( v259,  (uint64_t)a2,  v248,  v260,  *(unint64_t *)__dst,  *(unint64_t *)&__dst[8],  &v454);
            uint64_t v405 = objc_claimAutoreleasedReturnValue(v261);
            v232 = v454;

            if (v232)
            {
              NSErrorUserInfoKey v476 = NSUnderlyingErrorKey;
              v477 = v232;
              v262 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v477,  &v476,  1LL));
              GTMTLReplay_fillError(a5, 101, v262);
              if (a5) {
                v263 = *a5;
              }
              else {
                v263 = 0LL;
              }
              GTMTLReplay_handleNSError(v263);

              ht = (apr_hash_t *)v405;
              goto LABEL_221;
            }

            GTMTLReplay_commitCommandBuffer(v248);
          }

          else
          {
            v248 = ht;
            uint64_t v405 = objc_claimAutoreleasedReturnValue([v247 firstObject]);
          }

          if (v414)
          {
            v283 = (void *)objc_claimAutoreleasedReturnValue( [v423 objectForKeyedSubscript:@"DependencyGraphRequestedTextureLevel"]);
            id v284 = [v283 unsignedIntegerValue];

            v285 = (void *)objc_claimAutoreleasedReturnValue( [v423 objectForKeyedSubscript:@"DependencyGraphRequestedTextureSlice"]);
            id v286 = [v285 unsignedIntegerValue];

            v287 = (void *)objc_claimAutoreleasedReturnValue( [v423 objectForKeyedSubscript:@"DependencyGraphRequestedTextureDepthPlane"]);
            id v288 = [v287 unsignedIntegerValue];

            v289 = (void *)objc_claimAutoreleasedReturnValue( [v423 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"]);
            unint64_t v251 = (unint64_t)[v289 unsignedIntegerValue];

            if (v251 == 8)
            {
              unint64_t v251 = 0LL;
              id v290 = v413;
            }

            else
            {
              id v290 = v413;
              if (v251 == 9) {
                unint64_t v251 = 1LL;
              }
            }

            v250 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLTexture-0x%llx-%llx-%llu-%llu-%llu-%llu-Fetch",  v414,  v290,  v284,  v286,  v288,  v251));
            v235 = (apr_hash_t *)v405;
            obuint64_t j = (char *)v414;
          }

          else
          {
            v250 = 0LL;
            unint64_t v251 = -1LL;
            v235 = (apr_hash_t *)v405;
          }
        }

        else
        {
          v250 = 0LL;
          unint64_t v251 = -1LL;
        }

        id v252 = a1[3];
        v453 = 0LL;
        GTMTLReplayClient_harvestTexture((uint64_t)a2, v252, v235, (uint64_t)obj, a4, v251, v250, (uint64_t)v413, &v453);
        v253 = v453;
        ht = v235;
        if (!v253)
        {

          goto LABEL_211;
        }

        v254 = v253;
        NSErrorUserInfoKey v474 = NSUnderlyingErrorKey;
        v475 = v253;
        v255 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v475,  &v474,  1LL));
        GTMTLReplay_fillError(a5, 102, v255);

LABEL_222:
        uint64_t v36 = 0LL;
        goto LABEL_223;
      }

      char v236 = 1;
      v237 = 0LL;
LABEL_271:
      v307 = v237;
      GTMTLReplay_fillError(a5, 102, v237);
      ht = (apr_hash_t *)v227;
      uint64_t v36 = 0LL;
      id v197 = v307;
      if ((v236 & 1) != 0) {
        goto LABEL_238;
      }
      goto LABEL_237;
    }

    GTMTLReplayController_rewind((uint64_t)a1);
    GTMTLReplayController_debugSubCommand((unsigned int *)a1, v14, v21);
    v456 = 0LL;
    if (*((_DWORD *)a1 + 2828) != 70)
    {
      GTMTLReplay_fillError(&v456, 101, &__NSDictionary0__struct);
      GTMTLReplay_handleNSError(v456);
      id v226 = 0LL;
LABEL_353:
      id v227 = v456;
      [a1[1] commitCommandBuffers];
      goto LABEL_187;
    }

    uint64_t v97 = *(apr_pool_t **)a1[19];
    unint64_t v399 = *((void *)*a1 + 10) + *v23;
    v401 = (uint64_t **)*a1;
    uint64_t v98 = GTMTLSMContext_getObject(**((void **)*a1 + 5), (uint64_t)a1[2489], v399)[7];
    uint64_t v99 = *(void *)(v98 + 64);
    LODWORD(v100) = *(unsigned __int16 *)(v98 + 200);
    uint64_t v101 = 32LL;
    if (!*(_WORD *)(v98 + 200)) {
      uint64_t v101 = 56LL;
    }
    uint64_t v102 = *(void *)(v98 + v101);
    if (!*(_WORD *)(v98 + 200)) {
      LODWORD(v100) = *(unsigned __int16 *)(v98 + 202);
    }
    if (v99) {
      BOOL v103 = 1;
    }
    else {
      BOOL v103 = (_DWORD)v100 == 0;
    }
    if (!v103)
    {
      uint64_t v104 = 0LL;
      uint64_t v99 = v102;
      uint64_t v100 = v100;
      do
      {
        int v105 = *(unsigned __int8 *)(v99 + 16);
        if (v105 == 17)
        {
          if (*(_BYTE *)(v99 + 38) == 1) {
            goto LABEL_279;
          }
        }

        else if (v105 == 16)
        {
          uint64_t v99 = v102 + 56 * v104;
          goto LABEL_279;
        }

        v99 += 56LL;
        ++v104;
        --v100;
      }

      while (v100);
      uint64_t v99 = 0LL;
    }

LABEL_279:
    uint64_t v313 = (uint64_t)(obj + 513);
    int v314 = *(unsigned __int8 *)(v99 + 16);
    if (v314 == 17 || v314 == 16)
    {
      uint64_t v315 = *(void *)(v99 + 24);
      if (!v315) {
        uint64_t v315 = *(void *)(v99 + 8);
      }
    }

    else
    {
      uint64_t v315 = 0LL;
    }

    uint64_t v316 = *(unsigned int *)(v315 + 16);
    if ((_DWORD)v316)
    {
      uint64_t v317 = *(void *)(v315 + 8);
      do
      {
        countStructMember(v317);
        v317 += 32LL;
        --v316;
      }

      while (v316);
    }

    v318 = apr_array_make(v97, 8, 8);
    nameStructType1(v318, v315, v313);
    unint64_t v320 = v319;
    *(void *)&__dst[8] = v319;
    v322 = apr_array_pstrcat(v97, v318, v321);
    v323 = apr_psprintf(v97, v322, v313);
    *(void *)__dst = v323;
    id v406 = a1[1];
    htb = (apr_hash_t *)objc_claimAutoreleasedReturnValue([v406 defaultDevice]);
    v324 = objc_alloc_init(&OBJC_CLASS___MTLTextureDescriptor);
    v325 = v324;
    if ((_DWORD)v320)
    {
      -[MTLTextureDescriptor setTextureType:](v324, "setTextureType:", 3LL);
      -[MTLTextureDescriptor setArrayLength:](v325, "setArrayLength:", v320);
      uint64_t v326 = 19LL;
    }

    else
    {
      uint64_t v326 = 3LL;
    }

    -[MTLTextureDescriptor setUsage:](v325, "setUsage:", v326);
    -[MTLTextureDescriptor setWidth:](v325, "setWidth:", a1[2808]);
    -[MTLTextureDescriptor setHeight:](v325, "setHeight:", a1[2809]);
    if ((v320 & 0xFFFF00000000LL) != 0)
    {
      unint64_t v327 = HIDWORD(v320);
    }

    else if ((BYTE6(v320) - 3) > 0x35u)
    {
      LOWORD(v327) = 0;
    }

    else
    {
      LOWORD(v327) = word_317060[4 * (BYTE6(v320) - 3)];
    }

    -[MTLTextureDescriptor setPixelFormat:](v325, "setPixelFormat:", (unsigned __int16)v327);
    -[MTLTextureDescriptor setStorageMode:](v325, "setStorageMode:", 2LL);
    id v409 = -[apr_hash_t newTextureWithDescriptor:](htb, "newTextureWithDescriptor:", v325);
    if (!v409)
    {
      v505[0] = (apr_pool_t *)@"GTErrorKeyMTLTextureDescriptor";
      *(void *)&v504[0] = v325;
      v331 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v504,  v505,  1LL));
      GTMTLReplay_fillError(&v456, 101, v331);
      GTMTLReplay_handleNSError(v456);

LABEL_349:
      id v226 = 0LL;
      v373 = v409;
LABEL_352:

      goto LABEL_353;
    }

    v398 = v323;
    v403 = v97;

    if ((GT_SUPPORT_0 & 1) == 0)
    {
LABEL_351:
      apr_pool_clear(v403);
      v373 = v409;
      id v226 = v409;
      goto LABEL_352;
    }

    v328 = apr_array_make(v97, 8, 8);
    *(void *)apr_array_push(v328) = "#include <metal_stdlib>\n"
                                      "#include <metal_imageblocks>\n"
                                      "#include <simd/simd.h>\n"
                                      "using namespace metal;\n"
                                      "\n"
                                      "struct ImageblockMaster {\n";
    int v329 = *(unsigned __int8 *)(v99 + 16);
    pd = a2;
    if (v329 == 17 || v329 == 16)
    {
      uint64_t v330 = *(void *)(v99 + 24);
      if (!v330) {
        uint64_t v330 = *(void *)(v99 + 8);
      }
    }

    else
    {
      uint64_t v330 = 0LL;
    }

    v332 = apr_array_make(v97, 8, 8);
    if (*(_DWORD *)(v330 + 16))
    {
      v333 = v332;
      uint64_t v334 = 0LL;
      unint64_t v335 = 0LL;
      do
      {
        v333->uint64_t nelts = 0;
        processStructMember(v333, *(void *)(v330 + 8) + v334, 1LL, 0LL);
        v337 = apr_array_pstrcat(v328->pool, v333, v336);
        *(void *)apr_array_push(v328) = v337;
        ++v335;
        v334 += 32LL;
      }

      while (v335 < *(unsigned int *)(v330 + 16));
    }

    *(void *)apr_array_push(v328) = "};\n\n";
    int v338 = *(unsigned __int8 *)(v99 + 16);
    if (v338 == 16 || v338 == 17)
    {
      int v339 = *(unsigned __int8 *)(v99 + 37);
      unsigned int v340 = *(unsigned __int8 *)(v99 + 36);
      *(void *)apr_array_push(v328) = "kernel void dumpImageBlockData(imageblock<ImageblockMaster, imageblock_layout_ex"
                                        "plicit> imageBlock";
      a2 = pd;
      if (v339)
      {
        v341 = apr_array_push(v328);
        v342 = " [[ alias_implicit_imageblock ]]";
LABEL_317:
        void *v341 = v342;
        goto LABEL_318;
      }

      if (v340 <= 7)
      {
        *(void *)apr_array_push(v328) = " [[ alias_implicit_imageblock_color";
        v345 = apr_psprintf(v328->pool, "(%u)", v340);
        *(void *)apr_array_push(v328) = v345;
        v341 = apr_array_push(v328);
        v342 = " ]]";
        goto LABEL_317;
      }
    }

    else
    {
      *(void *)apr_array_push(v328) = "kernel void dumpImageBlockData(imageblock<ImageblockMaster, imageblock_layout_ex"
                                        "plicit> imageBlock";
      a2 = pd;
    }

LABEL_239:
  [(id)g_activityLog leaveActivity];
  return v36;
}

void sub_11EF6C(_Unwind_Exception *a1)
{
}

void GTMTLReplayClient_waitForUntrackedWritesToComplete(uint64_t a1, void *a2)
{
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  id v3 = a2;
  id v4 = [v3 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v10;
    while (2)
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v10 != v6) {
          objc_enumerationMutation(v3);
        }
        if (objc_msgSend(*(id *)(*((void *)&v9 + 1) + 8 * (void)i), "hazardTrackingMode", (void)v9) == (char *)&dword_0 + 1)
        {
          unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) defaultCommandQueue]);
          [v8 finish];

          goto LABEL_11;
        }
      }

      id v5 = [v3 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

id __HarvestResourceObject_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) length];
}

void __HarvestResourceObject_block_invoke_137(uint64_t a1)
{
}

void __HarvestResourceObject_block_invoke_2(uint64_t a1)
{
}

void __HarvestResourceObject_block_invoke_3(uint64_t a1)
{
}

void __HarvestResourceObject_block_invoke_4(uint64_t a1)
{
}

void __HarvestResourceObject_block_invoke_5(uint64_t a1)
{
}

void __HarvestResourceObject_block_invoke_6(uint64_t a1)
{
}

uint64_t GetPlanePixelFormat(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 > 539)
  {
    unint64_t v4 = a1 - 550;
    uint64_t v5 = 10LL;
    if (!a2) {
      uint64_t v5 = 554LL;
    }
    uint64_t v6 = 30LL;
    if (!a2) {
      uint64_t v6 = 10LL;
    }
    uint64_t v7 = 578LL;
    if (!a2) {
      uint64_t v7 = 576LL;
    }
    if (a1 != 543) {
      uint64_t v7 = 0LL;
    }
    if (a1 == 540) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = v7;
    }
    if (v4 >= 2) {
      return v8;
    }
    else {
      return v5;
    }
  }

  else
  {
    if (a1 <= 519)
    {
      if (a1 != 500 && a1 != 503) {
        return result;
      }
LABEL_22:
      if (a2) {
        return 30LL;
      }
      else {
        return 10LL;
      }
    }

    if (a1 == 520 || a1 == 523) {
      goto LABEL_22;
    }
  }

  return result;
}

void GTMTLReplayClient_harvestTexture( uint64_t a1, void *a2, void *a3, uint64_t a4, unsigned int ***a5, unint64_t a6, void *a7, uint64_t a8, void **a9)
{
  uint64_t v13 = a9;
  id v14 = a2;
  id v15 = a3;
  id v16 = a7;
  id v143 = (void *)objc_claimAutoreleasedReturnValue([v15 device]);
  id v17 = v15;
  id v18 = v14;
  if (v17)
  {
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v17 device]);
    double v20 = v17;
    if ([v17 storageMode] == (char *)&dword_0 + 3)
    {
      MTLTextureDescriptorFromTextureWithoutResourceIndex = MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(v17);
      double v20 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorFromTextureWithoutResourceIndex);
      [v20 setStorageMode:2];
      id v22 = [v19 newTextureWithDescriptor:v20];

      if (!v22)
      {
        id v192 = @"GTErrorKeyMTLTextureDescriptor";
        id v33 = SerializeMTLTextureDescriptorToDictionary(v20);
        id v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
        *(void *)&__int128 v177 = v34;
        id v27 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v177,  &v192,  1LL));

        GTMTLReplay_fillError(a9, 101, v27);
        if (a9) {
          uint64_t v35 = *a9;
        }
        else {
          uint64_t v35 = 0LL;
        }
        GTMTLReplay_handleNSError(v35);
        goto LABEL_24;
      }

      double v20 = v22;
    }

    if ([v20 isFramebufferOnly])
    {
      __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([v18 blitCommandEncoder]);

      if (v23) {
        [v18 commitCommandBuffer];
      }
      __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v18 resourcePool]);
      __int128 v25 = (void *)objc_claimAutoreleasedReturnValue([v18 commandBuffer]);
      *(void *)&__int128 v177 = 0LL;
      id v26 = GTMTLReplayController_resizeTexture( v24,  a1,  v25,  v20,  (unint64_t)[v20 width],  (unint64_t)objc_msgSend(v20, "height"),  (void **)&v177);
      id v27 = (id)objc_claimAutoreleasedReturnValue(v26);
      id v28 = (__CFString *)(id)v177;

      if (v28)
      {
        NSErrorUserInfoKey v189 = NSUnderlyingErrorKey;
        id v192 = v28;
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v192,  &v189,  1LL));
        uint64_t v13 = a9;
        GTMTLReplay_fillError(a9, 101, v29);
        if (a9) {
          id v30 = *a9;
        }
        else {
          id v30 = 0LL;
        }
        GTMTLReplay_handleNSError(v30);

LABEL_24:
        uint64_t v32 = 0LL;
        goto LABEL_25;
      }

      uint64_t v13 = a9;
    }

    else
    {
      id v27 = v20;
    }

    id v27 = v27;
    uint64_t v32 = v27;
LABEL_25:

    goto LABEL_26;
  }

  GTMTLReplay_fillError(a9, 101, &__NSDictionary0__struct);
  if (a9) {
    uint64_t v31 = *a9;
  }
  else {
    uint64_t v31 = 0LL;
  }
  GTMTLReplay_handleNSError(v31);
  uint64_t v32 = 0LL;
LABEL_26:

  uint64_t v36 = (char *)[v32 pixelFormat];
  id v142 = [v32 sampleCount];
  __int128 v175 = 0uLL;
  uint64_t v176 = 0LL;
  id v37 = (NSString *)[v32 width];
  id v38 = [v32 height];
  id v156 = [v32 depth];
  __int128 v194 = 0uLL;
  uint64_t v141 = (uint64_t)v36;
  GTMTLPixelFormatGetInfoForDevice((uint64_t)&v192, (uint64_t)v143, (uint64_t)v36);
  *(void *)&__int128 v194 = 0LL;
  if ((~v193 & 0x60) != 0)
  {
    if ((v193 & 0x2000) != 0) {
      *(void *)&__int128 v194 = 4LL;
    }
    uint64_t v39 = 1LL;
  }

  else
  {
    __int128 v194 = xmmword_318400;
    uint64_t v39 = 2LL;
  }

  uint64_t v147 = v39;
  __int128 v40 = v36;
  v191[0] = v36;
  v191[1] = v36;
  NSErrorUserInfoKey v189 = v37;
  v190[0] = v38;
  v190[1] = v156;
  v190[2] = v37;
  v190[3] = v38;
  v190[4] = v156;
  v188[0] = v17;
  id v41 = v188[0];
  v188[1] = v41;
  uint64_t PlanePixelFormat = GetPlanePixelFormat((uint64_t)v36, 0LL);
  __int128 v128 = v16;
  uint64_t v139 = v18;
  unint64_t v124 = v41;
  uint64_t v125 = v32;
  if (!PlanePixelFormat) {
    goto LABEL_60;
  }
  unint64_t v43 = v37;
  uint64_t v44 = PlanePixelFormat;
  uint64_t v45 = MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(v41);
  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
  id v152 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
  uint64_t v154 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  uint64_t v47 = 0LL;
  v48.i64[0] = (uint64_t)v43;
  v48.i64[1] = (uint64_t)v38;
  char v49 = 1;
  int8x16_t v158 = (int8x16_t)v48;
  int8x16_t v150 = (int8x16_t)vshrq_n_u64((uint64x2_t)vaddq_s64(v48, vdupq_n_s64(1uLL)), 1uLL);
  while (1)
  {
    v191[v47] = v44;
    if (v40 == (_BYTE *)&stru_1F8.addr + 7 || (int8x16_t v50 = v158, v40 == (_BYTE *)&stru_1F8.addr + 4))
    {
      if ((v49 & 1) != 0) {
        unint64_t v51 = -1LL;
      }
      else {
        unint64_t v51 = 0LL;
      }
      int8x16_t v50 = vbslq_s8((int8x16_t)vdupq_n_s64(v51), v158, v150);
    }

    id v52 = (int8x16_t *)&v190[3 * v47 - 1];
    int8x16_t *v52 = v50;
    v52[1].i64[0] = (uint64_t)v156;
    [v46 setWidth:v50.i64[0]];
    [v46 setHeight:v190[3 * v47]];
    [v46 setPixelFormat:v44];
    id v53 = [v143 newTextureWithDescriptor:v46];
    id v54 = v188[v47];
    v188[v47] = v53;

    if (!v53)
    {
      unsigned int v186 = @"GTErrorKeyMTLTextureDescriptor";
      id v63 = SerializeMTLTextureDescriptorToDictionary(v46);
      uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(v63);
      uint64_t v187 = v64;
      __int128 v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v187,  &v186,  1LL));

      GTMTLReplay_fillError(v13, 101, v65);
      if (v13) {
        uint64_t v66 = *v13;
      }
      else {
        uint64_t v66 = 0LL;
      }
      id v18 = v139;
      GTMTLReplay_handleNSError(v66);
      int v77 = 1;
      goto LABEL_58;
    }

    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v152, "colorAttachments"));
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v55 objectAtIndexedSubscript:v47]);
    [v56 setTexture:v53];

    BOOL v57 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v152, "colorAttachments"));
    id v58 = (void *)objc_claimAutoreleasedReturnValue([v57 objectAtIndexedSubscript:v47]);
    [v58 setLoadAction:0];

    unint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v152, "colorAttachments"));
    id v60 = (void *)objc_claimAutoreleasedReturnValue([v59 objectAtIndexedSubscript:v47]);
    [v60 setStoreAction:1];

    unsigned int v61 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor colorAttachments](v154, "colorAttachments"));
    int v62 = (void *)objc_claimAutoreleasedReturnValue([v61 objectAtIndexedSubscript:v47]);
    [v62 setPixelFormat:v44];

    if ((v49 & 1) == 0) {
      break;
    }
    __int128 v40 = (char *)v141;
    uint64_t v44 = GetPlanePixelFormat(v141, 1LL);
    char v49 = 0;
    uint64_t v47 = 1LL;
  }

  id v67 = GTMTLReplayController_defaultLibrary(v143);
  __int128 v65 = (void *)objc_claimAutoreleasedReturnValue(v67);
  id v68 = [v65 newFunctionWithName:@"Harvest2PVertex"];
  -[MTLRenderPipelineDescriptor setVertexFunction:](v154, "setVertexFunction:", v68);

  int64_t v69 = @"Harvest2PFragmentDownloadYCbCr";
  else {
    uint64_t v70 = @"Harvest2PFragmentDownload";
  }
  id v71 = [v65 newFunctionWithName:v70];
  -[MTLRenderPipelineDescriptor setFragmentFunction:](v154, "setFragmentFunction:", v71);

  id v174 = 0LL;
  id v72 = [v143 newRenderPipelineStateWithDescriptor:v154 error:&v174];
  id v73 = v174;
  if (v73)
  {
    unsigned int v74 = v73;
    NSErrorUserInfoKey v184 = NSUnderlyingErrorKey;
    id v185 = v73;
    unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v185,  &v184,  1LL));
    GTMTLReplay_fillError(v13, 101, v75);
    id v18 = v139;
    if (v13) {
      int v76 = *v13;
    }
    else {
      int v76 = 0LL;
    }
    GTMTLReplay_handleNSError(v76);

    int v77 = 1;
  }

  else
  {
    id v18 = v139;
    unint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v139 renderCommandEncoderWithDescriptor:v152]);
    [v75 setRenderPipelineState:v72];
    [v75 setFragmentTexture:v124 atIndex:0];
    [v75 drawPrimitives:3 vertexStart:0 vertexCount:3];
    int v77 = 0;
  }

LABEL_58:
  if (!v77)
  {
    uint64_t v147 = 2LL;
    uint64_t v32 = v125;
LABEL_60:
    id v126 = [v32 mipmapLevelCount];
    if ([v32 textureType] == (char *)&dword_4 + 1
      || [v32 textureType] == (char *)&dword_4 + 2)
    {
      uint64_t v130 = 6 * (void)[v32 arrayLength];
    }

    else
    {
      uint64_t v130 = (uint64_t)[v32 arrayLength];
    }

    unint64_t v79 = a6;
    unint64_t v80 = v147;
    if (v126)
    {
      uint64_t v149 = 0LL;
      size_t v129 = (48 * (_WORD)v147 + 279) & 0x300;
      do
      {
        uint64_t v81 = 0LL;
        uint64_t v82 = 0LL;
        uint64_t v83 = 0LL;
        uint64_t v84 = 0LL;
        uint64_t v85 = 0LL;
        unint64_t v136 = 1LL;
        uint64_t v137 = 0LL;
        id v86 = v190;
        uint64_t v138 = (48 * (_WORD)v147 + 279) & 0x300;
        do
        {
          if (v80 <= v79 || v79 == v81)
          {
            *(void *)&double v78 = GTMTLGetTextureLevelInfoForDeviceWithOptions( (uint64_t)&v177,  (uint64_t)v143,  v191[v81],  *(v86 - 1),  *v86,  v86[1],  (uint64_t)v142,  v149,  *((void *)&v194 + v81)).n128_u64[0];
            if (v81) {
              BOOL v87 = v79 == v81;
            }
            else {
              BOOL v87 = 1;
            }
            if (v87)
            {
              uint64_t v84 = v178;
              uint64_t v83 = *((void *)&v177 + 1);
              uint64_t v82 = v177;
            }

            v85 += v182;
            v137 += *((void *)&v182 + 1);
            v138 += v183;
            unint64_t v88 = v136;
            if (v136 <= *((void *)&v181 + 1)) {
              unint64_t v88 = *((void *)&v181 + 1);
            }
            unint64_t v136 = v88;
            unint64_t v80 = v147;
          }

          ++v81;
          v86 += 3;
        }

        while (v80 != v81);
        if (v130)
        {
          for (uint64_t i = 0LL; i != v130; ++i)
          {
            uint64_t v132 = v85;
            uint64_t v133 = v84;
            uint64_t v134 = v83;
            uint64_t v135 = v82;
            id v89 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "bufferWithLength:alignment:", v138, v136, v78));
            uint64_t v90 = [v89 contents];
            uint64_t v91 = (48 * (_WORD)v147 + 279) & 0x300;
            bzero(v90, v129);
            *(void *)uint64_t v90 = 0x63617074757265LL;
            v90[2] = 65538;
            v90[3] = v129;
            uint64_t v153 = v89;
            uint64_t v145 = (char *)[v89 heapLocation];
            __int128 v148 = (void *)objc_claimAutoreleasedReturnValue([v18 blitCommandEncoder]);
            v146 = v90;
            __int128 v144 = v90 + 6;
            unsigned int v92 = v188;
            id v93 = (uint64_t *)&v194;
            __int128 v94 = v191;
            id v95 = v190;
            unint64_t v96 = v79;
            unint64_t v97 = v147;
            uint64_t v98 = v147;
            do
            {
              if (v97 <= v79 || !v96)
              {
                uint64_t v159 = v91;
                uint64_t v99 = *v93;
                GTMTLGetTextureLevelInfoForDeviceWithOptions( (uint64_t)&v177,  (uint64_t)v143,  *v94,  *(v95 - 1),  *v95,  v95[1],  (uint64_t)v142,  v149,  *v93);
                uint64_t v100 = v178;
                __int128 v101 = v177;
                __int128 v155 = v182;
                __int128 v102 = v182;
                BOOL v103 = &v144[12 * *((void *)v146 + 2)];
                *(void *)BOOL v103 = v141;
                *(_OWORD *)(v103 + 2) = v101;
                *((void *)v103 + 3) = v100;
                *((_OWORD *)v103 + 2) = v102;
                ++*((void *)v146 + 2);
                id v157 = *v92;
                __int128 v172 = v101;
                uint64_t v173 = v100;
                uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue([v153 heapBuffer]);
                __int128 v170 = v175;
                uint64_t v171 = v176;
                objc_msgSend( v148,  "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destination BytesPerRow:destinationBytesPerImage:options:",  v157,  i,  v149,  &v170,  &v172,  v104,  &v145[v159],  v155,  v99);

                if ((v193 & 0x2000) != 0)
                {
                  int v105 = (void *)objc_claimAutoreleasedReturnValue([v139 commandBuffer]);
                  v160[0] = _NSConcreteStackBlock;
                  v160[1] = 3221225472LL;
                  v160[2] = __GTMTLReplayClient_harvestTexture_block_invoke;
                  v160[3] = &unk_58ECC0;
                  id v161 = v153;
                  uint64_t v162 = v159;
                  __int128 v167 = v181;
                  __int128 v168 = v182;
                  uint64_t v169 = v183;
                  __int128 v163 = v177;
                  __int128 v164 = v178;
                  __int128 v165 = v179;
                  __int128 v166 = v180;
                  [v105 addCompletedHandler:v160];
                }

                uint64_t v91 = v183 + v159;
                unint64_t v79 = a6;
                unint64_t v97 = v147;
              }

              ++v92;
              ++v93;
              --v96;
              ++v94;
              v95 += 3;
              --v98;
            }

            while (v98);
            id v16 = v128;
            if (v128)
            {
              id v106 = v128;
              uint64_t v107 = a8;
            }

            else
            {
              uint64_t v107 = a8;
              id v106 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLTexture-0x%llx-%llx-%llu-%llu-Fetch",  a4,  a8,  v149,  i));
            }

            uint64_t v83 = v134;
            uint64_t v82 = v135;
            uint64_t v85 = v132;
            uint64_t v84 = v133;
            uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v153 data]);
            [a5[1] setObject:v108 forKeyedSubscript:v106];

            if (v107 && a5[2])
            {
              uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v107));
              [a5[2] setObject:v109 forKeyedSubscript:v106];
            }

            id v110 = v106;
            __int128 v111 = (const char *)[v110 UTF8String];
            id v112 = **a5;
            *((void *)v112 + 1) = 0LL;
            *((void *)v112 + 2) = 0LL;
            *((void *)v112 + 3) = 0LL;
            *(void *)id v112 = 0xFFFFC09400000024LL;
            v112[8] = 0;
            strcpy((char *)v112 + 36, "C@6ulululU<b>ululul");
            *((void *)v112 + 7) = a4;
            *((void *)v112 + 8) = 0LL;
            *((void *)v112 + 9) = 0LL;
            *((void *)v112 + 10) = 0LL;
            *((void *)v112 + 11) = v135;
            *((void *)v112 + 12) = v134;
            *((void *)v112 + 13) = v133;
            *((void *)v112 + 14) = v149;
            *((void *)v112 + 15) = i;
            *id v112 = 128;
            AppendString(v111, (int *)v112);
            uint64_t v113 = *v112;
            uint64_t v114 = ((_DWORD)v113 + 3) & 0xFFFFFFFC;
            bzero((char *)v112 + v113, v114 - v113);
            *id v112 = v114;
            *(void *)((char *)v112 + v114) = v132;
            unsigned int v115 = *v112 + 8;
            *id v112 = v115;
            *(void *)((char *)v112 + v115) = v137;
            unsigned int v116 = *v112 + 8;
            *id v112 = v116;
            *(void *)((char *)v112 + v116) = v138;
            *v112 += 8;
            __int128 v117 = *a5;
            id v118 = **a5;
            v118[1] = -10236;
            __int128 v119 = v117[2];
            uint64_t v120 = *v118;
            if ((*((_BYTE *)v118 + 33) & 0x10) != 0)
            {
              uint64_t v121 = *v118;
              uint64_t v122 = v118;
              id v18 = v139;
              do
              {
                uint64_t v122 = (unsigned int *)((char *)v122 + v121);
                uint64_t v121 = *v122;
                v120 += v121;
              }

              while ((*((_BYTE *)v122 + 33) & 0x20) == 0);
            }

            else
            {
              id v18 = v139;
            }

            objc_msgSend(v119, "appendBytes:length:");
          }
        }

        ++v149;
        unint64_t v80 = v147;
      }

      while ((id)v149 != v126);
    }
  }

  for (uint64_t j = 1LL; j != -1; --j)
}

void AddAttachmentToArray(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v9 = a1;
  uint64_t v10 = *find_entry(a4, a2, 8uLL, 0LL);
  if (v10) {
    uint64_t v11 = *(void *)(v10 + 32);
  }
  else {
    uint64_t v11 = 0LL;
  }
  uint64_t v12 = *find_entry(a4, (_BYTE *)a2 + 8, 8uLL, 0LL);
  if (v12) {
    uint64_t v12 = *(void *)(v12 + 32);
  }
  if (v11 && (*(void *)(v11 + 32) & 0x8000000000000000LL) == 0)
  {
    uint64_t v23 = *a2;
    uint64_t v13 = *(void *)(*(void *)(*find_entry(a5, &v23, 8uLL, 0LL) + 32LL) + 8LL);
    v26[0] = @"DependencyGraphRequestedTextureID";
    id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v13));
    v27[0] = v14;
    v26[1] = @"DependencyGraphRequestedTextureAttachmentIndex";
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a3));
    v27[1] = v15;
    v26[2] = @"DependencyGraphRequestedTextureSlice";
    id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)a2 + 10)));
    v27[2] = v16;
    v26[3] = @"DependencyGraphRequestedTextureLevel";
    id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)a2 + 26)));
    v27[3] = v17;
    v26[4] = @"DependencyGraphRequestedTextureDepthPlane";
    id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)a2 + 9)));
    v27[4] = v18;
    uint64_t v19 = v27;
    double v20 = v26;
LABEL_12:
    id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v19,  v20,  5LL));
    [v9 addObject:v22];

    goto LABEL_13;
  }

  if (v12 && (*(void *)(v12 + 32) & 0x8000000000000000LL) == 0)
  {
    uint64_t v23 = a2[1];
    uint64_t v21 = *(void *)(*(void *)(*find_entry(a5, &v23, 8uLL, 0LL) + 32LL) + 8LL);
    v24[0] = @"DependencyGraphRequestedTextureID";
    id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v21));
    v25[0] = v14;
    v24[1] = @"DependencyGraphRequestedTextureAttachmentIndex";
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a3));
    v25[1] = v15;
    v24[2] = @"DependencyGraphRequestedTextureSlice";
    id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)a2 + 11)));
    v25[2] = v16;
    v24[3] = @"DependencyGraphRequestedTextureLevel";
    id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)a2 + 24)));
    v25[3] = v17;
    v24[4] = @"DependencyGraphRequestedTextureDepthPlane";
    id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)a2 + 8)));
    v25[4] = v18;
    uint64_t v19 = v25;
    double v20 = v24;
    goto LABEL_12;
  }

unint64_t GTMTLReplayHost_IsFuncEnumSampledEncoder(int a1, int a2, _BYTE *a3)
{
  if (!IsFuncEnumCreateCommandEncoder(a1))
  {
    if (a3)
    {
      unint64_t result = 0LL;
      *a3 = 0;
      return result;
    }

    return 0LL;
  }

  if (a2) {
    int v6 = -16286;
  }
  else {
    int v6 = -16351;
  }
  if (v6 == a1) {
    return 0LL;
  }
  int FuncEnumConstructorType = GetFuncEnumConstructorType(a1);
  else {
    return (0x21000000000811uLL >> (FuncEnumConstructorType - 17)) & 1;
  }
}

id GTMTLReplayHost_generateDerivedDataPayload(uint64_t a1, int a2)
{
  unint64_t v75 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  unint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  int v6 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v68 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  int64_t v69 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v71 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v70 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v67 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v66 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v7 = *(void *)(a1 + 112);
  unsigned int v74 = v4;
  id v72 = v6;
  if (*(int *)(v7 + 12) < 1)
  {
    uint64_t v56 = 0LL;
    goto LABEL_57;
  }

  uint64_t v64 = v5;
  uint64_t v65 = 0LL;
  uint64_t v8 = 0LL;
  int v9 = 0;
  uint64_t v76 = *(void *)(a1 + 120);
  uint64_t v61 = a1;
  int v73 = a2;
  do
  {
    uint64_t v10 = v9;
    uint64_t v11 = 32LL * v9;
    while (1)
    {
      uint64_t v12 = *(void *)(v7 + 24);
      uint64_t v13 = *(void *)(v12 + v11);
      uint64_t v14 = *(void *)(v76 + 24);
      uint64_t v15 = v14 + (v13 << 6);
      uint64_t v16 = v7;
      int v17 = *(_DWORD *)(v15 + 8);
      if (v17 != -10224) {
        break;
      }
      id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v8));
      -[NSMutableArray addObject:](v75, "addObject:", v18);

      uint64_t v8 = 0LL;
      ++v10;
      v11 += 32LL;
      uint64_t v7 = v16;
    }

    uint64_t v62 = v8;
    uint64_t v63 = v7;
    int FuncEnumConstructorType = GetFuncEnumConstructorType(v17);
    if (FuncEnumConstructorType == 51)
    {
      if ((*(_BYTE *)(v14 + (v13 << 6) + 15) & 0x40) == 0 || (uint64_t v24 = v12 + 32 * v10, *(_DWORD *)(v24 + 28) == -12543))
      {
        uint64_t v25 = *(int *)(v12 + 32 * v10 + 20);
        uint64_t v22 = 0LL;
        if ((int)v25 >= 1)
        {
          uint64_t v26 = v12 + 60;
          do
          {
            v22 += GTMTLReplayHost_IsFuncEnumSampledEncoder(*(_DWORD *)(v26 + v11), v73, 0LL);
            v26 += 32LL;
            --v25;
          }

          while (v25);
        }

        goto LABEL_36;
      }

      LODWORD(v10) = *(_DWORD *)(v24 + 20) + v10;
    }

    else
    {
      if (FuncEnumConstructorType == 25)
      {
        if ((*(_BYTE *)(v14 + (v13 << 6) + 15) & 0x40) == 0 || (uint64_t v20 = v12 + 32 * v10, *(_DWORD *)(v20 + 28) == -12544))
        {
          uint64_t v21 = *(int *)(v12 + 32 * v10 + 20);
          if ((int)v21 < 1)
          {
            uint64_t v22 = 0LL;
          }

          else
          {
            uint64_t v22 = 0LL;
            uint64_t v23 = v12 + 60;
            do
            {
              v22 += GTMTLReplayHost_IsFuncEnumSampledEncoder(*(_DWORD *)(v23 + v11), v73, 0LL);
              v23 += 32LL;
              --v21;
            }

            while (v21);
          }

LABEL_51:
    uint64_t v8 = v62;
    uint64_t v7 = v63;
LABEL_52:
    int v9 = v10 + 1;
  }

  while ((int)v10 + 1 < *(_DWORD *)(v7 + 12));
  if (v8)
  {
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:"));
    -[NSMutableArray addObject:](v75, "addObject:", v55);
  }

        [*((id *)v259 + 15) addObject:v52];
        if (v56) {
          operator delete(v56);
        }

        ++v49;
        v48 += 48LL;
        v50 += 16LL;
        if (v49 >= v287) {
          goto LABEL_54;
        }
      }

      uint64_t v63 = (double *)((char *)__p + v48);
      *(void *)((char *)__p + v48 + 8) = 0LL;
      uint64_t v64 = (char *)v55 - (char *)v56;
      uint64_t v65 = (double)v56[1] - (double)*v56;
      if (v65 < 0.0) {
        uint64_t v65 = 0.0;
      }
      v63[2] = v65;
      uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
      [v52 setObject:v66 atIndexedSubscript:0];

      if (v64 != 32) {
        goto LABEL_51;
      }
      id v67 = (double)v56[3] - (double)v56[2];
      if (v67 < 0.0) {
        id v67 = 0.0;
      }
      *(double *)((char *)__p + v48 + 24) = v67;
      id v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
      [v52 setObject:v60 atIndexedSubscript:1];
      goto LABEL_50;
    }

    if (a1 == v2) {
      return 4LL;
    }
    return 0LL;
  }

  if (a1 > 1278226535)
  {
    if (a1 > 1380401728)
    {
      if (a1 == 1380401729) {
        return 4LL;
      }
      if (a1 != 1380411457)
      {
        uint64_t v2 = 1667838256;
        goto LABEL_51;
      }

      return 8LL;
    }

    if (a1 == 1278226536) {
      return 2LL;
    }
    id v3 = 1278226742;
LABEL_57:
    if (a1 != v3) {
      return 0LL;
    }
    return 2LL;
  }

  if (a1 <= 1111970368)
  {
    if (a1 == 875836534) {
      return 0LL;
    }
    uint64_t v2 = 1094862674;
    goto LABEL_51;
  }

  if (a1 == 1111970369) {
    return 4LL;
  }
  if (a1 != 1278226488)
  {
    uint64_t v2 = 1278226534;
    goto LABEL_51;
  }

  return v1;
}

BOOL IsFuncEnumSampledCall(int a1, int a2)
{
  if ((IsFuncEnumDrawCall(a1) & 1) != 0) {
    return 1LL;
  }
  BOOL result = 1LL;
  if (a1 <= -16138)
  {
    if (a1 == -16327) {
      return result;
    }
    int v5 = -16220;
    goto LABEL_10;
  }

  if (((a1 + 16137) > 0x3B || ((1LL << (a1 + 9)) & 0xC00000000000001LL) == 0)
    && a1 != -15486)
  {
    int v5 = -15297;
LABEL_10:
    if (a1 != v5)
    {
      BOOL result = IsFuncEnumSampledBlitCall(a1);
      if (!result)
      {
        if (a2) {
          return IsFuncEnumSampledBlitCallAGX(a1);
        }
      }
    }
  }

  return result;
}

uint64_t RenderPassDescriptorContainsClear(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*(void *)(a1 + 680) && *(_BYTE *)(a1 + 697) == 2 || *(void *)(a1 + 728) && *(_BYTE *)(a1 + 745) == 2) {
    return 1LL;
  }
  uint64_t v2 = 0LL;
  uint64_t v1 = 1LL;
  while (!*(void *)(a1 + v2 + 8) || *(_BYTE *)(a1 + v2 + 25) != 2)
  {
    v2 += 64LL;
    if (v2 == 512) {
      return 0LL;
    }
  }

  return v1;
}

uint64_t SoftwareCounterForFunc(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  int v4 = *(_DWORD *)(a1 + 8);
  if (v4 <= -16219)
  {
    if (v4 == -16251) {
      goto LABEL_15;
    }
    if (v4 == -16249 || v4 == -16248) {
      return *((void *)GTTraceFunc_argumentBytesWithMap((void *)a1, *(unsigned __int8 *)(a1 + 13), a2) + 2);
    }
  }

  else
  {
    if (v4 <= -16148)
    {
      if (v4 != -16218)
      {
        if (v4 != -16217) {
          return result;
        }
        return *((void *)GTTraceFunc_argumentBytesWithMap((void *)a1, *(unsigned __int8 *)(a1 + 13), a2) + 2);
      }

uint64_t SoftwareCounterForIndirectCommand(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0LL;
  switch(*(void *)(a3 + a1))
  {
    case 1LL:
      uint64_t result = 0LL;
      break;
    case 2LL:
      uint64_t result = *(void *)(a3 + a2 + 8);
      break;
    case 4LL:
      uint64_t result = 0LL;
      break;
    case 8LL:
      uint64_t result = 0LL;
      break;
    default:
      return result;
  }

  return result;
}

id GTMTLReplayHost_collectSoftwareEncoderCounters(uint64_t a1, int a2)
{
  __int128 v40 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v4 = *(void *)(a1 + 112);
  int v5 = *(_DWORD *)(v4 + 12);
  if (v5 >= 1)
  {
    int v6 = 0;
    uint64_t v7 = *(void *)(a1 + 120);
    uint64_t v39 = *(void *)(a1 + 112);
    uint64_t v47 = v7;
    uint64_t v48 = *(void *)(a1 + 16);
    int v45 = a2;
    do
    {
      uint64_t v8 = *(void *)(v4 + 24);
      int v9 = (void *)(v8 + 32LL * v6);
      uint64_t v10 = *(void *)(v7 + 24) + (*v9 << 6);
      if (GTMTLReplayHost_IsFuncEnumSampledEncoder(*(_DWORD *)(v10 + 8), a2, 0LL))
      {
        uint64_t RenderPassDescriptor = GetRenderPassDescriptor((uint64_t *)v10, v48);
        uint64_t v12 = RenderPassDescriptorContainsClear(RenderPassDescriptor);
        int v13 = *(_DWORD *)v9;
        unint64_t v15 = v9[1];
        uint64_t v14 = v9 + 1;
        int v16 = v13 + 1;
        uint64_t v43 = v8;
        int v44 = v6;
        uint64_t v41 = v12;
        uint64_t v42 = v6;
        if (v15 <= v13 + 1)
        {
          uint64_t v19 = 0LL;
          uint64_t v18 = 0LL;
        }

        else
        {
          int v17 = v14;
          uint64_t v18 = 0LL;
          uint64_t v19 = 0LL;
          uint64_t v20 = v16;
          uint64_t v46 = v14;
          do
          {
            uint64_t v21 = *(void *)(v7 + 24) + (v20 << 6);
            unsigned int v22 = *(_DWORD *)(v21 + 8);
            if (IsFuncEnumSampledCall(v22, a2))
            {
              v18 += SoftwareCounterForFunc(v21, v48);
              v19 += v23;
            }

            else if (v22 >> 2 == 1073737833)
            {
              GetExecuteCommandsInBufferArgs((uint64_t)v49, v21, *(void *)(a1 + 16));
              Object = GTMTLSMContext_getObject(**(void **)(a1 + 40), v49[0], *(void *)v21);
              GTMTLCreateIndirectCommandEncoder((uint64_t)v52, Object[13]);
              uint64_t v25 = v50;
              if (v50)
              {
                uint64_t v26 = v51;
                uint64_t v28 = v52[12];
                uint64_t v27 = v52[13];
                uint64_t v29 = v52[1];
                uint64_t v30 = v49[1] << 32;
                do
                {
                  uint64_t v31 = v26 + v27 * (v30 >> 32);
                  if (*(void *)(v31 + v29))
                  {
                    v18 += SoftwareCounterForIndirectCommand(v29, v28, v31);
                    v19 += v32;
                  }

                  v30 += 0x100000000LL;
                  --v25;
                }

                while (v25);
              }

              a2 = v45;
              int v17 = v46;
              uint64_t v7 = v47;
            }

            uint64_t v20 = ++v16;
          }

          while (*v17 > (unint64_t)v16);
        }

        id v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v41,  v39));
        v53[0] = v33;
        uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v18));
        v53[1] = v34;
        uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v19));
        v53[2] = v35;
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v53, 3LL));
        -[NSMutableArray addObject:](v40, "addObject:", v36);

        uint64_t v7 = v47;
        int v6 = *(_DWORD *)(v43 + 32 * v42 + 20) + v44;
        uint64_t v4 = v39;
        int v5 = *(_DWORD *)(v39 + 12);
      }

      ++v6;
    }

    while (v6 < v5);
  }

  id v37 = -[NSMutableArray copy](v40, "copy", v39);

  return v37;
}

id GTMTLReplayHost_rawCounters(void *a1)
{
  id v1 = a1;
  uint64_t v2 = -[NSMutableSet initWithCapacity:]( [NSMutableSet alloc],  "initWithCapacity:",  [v1 count]);
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  id v3 = v1;
  id v16 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (v16)
  {
    uint64_t v15 = *(void *)v22;
    do
    {
      for (uint64_t i = 0LL; i != v16; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v22 != v15) {
          objc_enumerationMutation(v3);
        }
        int v5 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v3,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v21 + 1) + 8 * (void)i),  v15));
        __int128 v17 = 0u;
        __int128 v18 = 0u;
        __int128 v19 = 0u;
        __int128 v20 = 0u;
        int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"counters"]);
        id v7 = [v6 countByEnumeratingWithState:&v17 objects:v25 count:16];
        if (v7)
        {
          id v8 = v7;
          uint64_t v9 = *(void *)v18;
          do
          {
            for (uint64_t j = 0LL; j != v8; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v18 != v9) {
                objc_enumerationMutation(v6);
              }
              uint64_t v11 = *(void *)(*((void *)&v17 + 1) + 8LL * (void)j);
              uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v11]);

              if (!v12) {
                -[NSMutableSet addObject:](v2, "addObject:", v11);
              }
            }

            id v8 = [v6 countByEnumeratingWithState:&v17 objects:v25 count:16];
          }

          while (v8);
        }
      }

      id v16 = [v3 countByEnumeratingWithState:&v21 objects:v26 count:16];
    }

    while (v16);
  }

  int v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableSet allObjects](v2, "allObjects"));
  return v13;
}

NSMutableSet *GTMTLReplayHost_rawCountersToNormalizeSet(void *a1)
{
  id v1 = a1;
  uint64_t v2 = -[NSMutableSet initWithCapacity:]( [NSMutableSet alloc],  "initWithCapacity:",  [v1 count]);
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  id v3 = v1;
  id v4 = [v3 countByEnumeratingWithState:&v25 objects:v30 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v26;
    uint64_t v18 = *(void *)v26;
    do
    {
      id v7 = 0LL;
      id v19 = v5;
      do
      {
        if (*(void *)v26 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = (void *)objc_claimAutoreleasedReturnValue( [v3 objectForKeyedSubscript:*(void *)(*((void *)&v25 + 1) + 8 * (void)v7)]);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"subtype"]);
        if ([v9 isEqualToString:@"Normalize"])
        {
          __int128 v20 = v9;
          __int128 v23 = 0u;
          __int128 v24 = 0u;
          __int128 v21 = 0u;
          __int128 v22 = 0u;
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"counters"]);
          id v11 = [v10 countByEnumeratingWithState:&v21 objects:v29 count:16];
          if (v11)
          {
            id v12 = v11;
            uint64_t v13 = *(void *)v22;
            do
            {
              for (uint64_t i = 0LL; i != v12; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v22 != v13) {
                  objc_enumerationMutation(v10);
                }
                uint64_t v15 = *(void *)(*((void *)&v21 + 1) + 8LL * (void)i);
                id v16 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v15]);

                if (!v16) {
                  -[NSMutableSet addObject:](v2, "addObject:", v15);
                }
              }

              id v12 = [v10 countByEnumeratingWithState:&v21 objects:v29 count:16];
            }

            while (v12);
          }

          uint64_t v6 = v18;
          id v5 = v19;
          uint64_t v9 = v20;
        }

        id v7 = (char *)v7 + 1;
      }

      while (v7 != v5);
      id v5 = [v3 countByEnumeratingWithState:&v25 objects:v30 count:16];
    }

    while (v5);
  }

  return v2;
}

id GTMTLReplayHost_createPerCounterCommandData(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v3 count]);
  id v19 = v4;
  id v6 = [v4 count];
  if ([v3 count])
  {
    unint64_t v7 = 0LL;
    do
    {
      id v8 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v6);
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      id v9 = v19;
      id v10 = [v9 countByEnumeratingWithState:&v20 objects:v24 count:16];
      if (v10)
      {
        id v11 = v10;
        uint64_t v12 = *(void *)v21;
        do
        {
          uint64_t v13 = 0LL;
          do
          {
            if (*(void *)v21 != v12) {
              objc_enumerationMutation(v9);
            }
            uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v20 + 1) + 8 * (void)v13) objectAtIndexedSubscript:v7]);
            -[NSMutableArray addObject:](v8, "addObject:", v14);

            uint64_t v13 = (char *)v13 + 1;
          }

          while (v11 != v13);
          id v11 = [v9 countByEnumeratingWithState:&v20 objects:v24 count:16];
        }

        while (v11);
      }

      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v7]);
      id v16 = -[NSMutableArray copy](v8, "copy");
      -[NSMutableDictionary setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v16, v15);

      ++v7;
    }

    while (v7 < (unint64_t)[v3 count]);
  }

  id v17 = -[NSMutableDictionary copy](v5, "copy");

  return v17;
}

id GTMTLReplayClient_getThumbnailInfo( uint64_t a1, uint64_t a2, unint64_t *a3, int a4, void *a5, void *a6, uint64_t a7)
{
  LODWORD(v22) = a4;
  id v12 = a5;
  id v13 = a6;
  GTMTLSMContext_getTextureDescriptor(*(uint64_t **)(a2 + 40), a1, *a3, (uint64_t)v30);
  uint64_t v14 = *(void *)(a2 + 8);
  uint64_t v31 = a1;
  uint64_t v15 = *(void *)(*(void *)(*find_entry(v14, &v31, 8uLL, 0LL) + 32LL) + 8LL);
  v35[0] = &off_5A0910;
  v34[0] = @"type";
  v34[1] = @"object";
  id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v15));
  v35[1] = v16;
  v35[2] = v12;
  v34[2] = @"resolution";
  v34[3] = @"format";
  id v17 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  ResizeFormat(v30[17]));
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  v35[3] = v18;
  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v35,  v34,  4LL));

  __int128 v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v13 count]));
  __int128 v21 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:@"format"]);
  uint64_t v22 = (int)v22;
  InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(a7 + 12), *(void **)(a7 + 24), (int)v22);
  if (InclusiveRange)
  {
    __int128 v24 = InclusiveRange;
    while (GetFuncEnumConstructorType(*((_DWORD *)v24 + 7)) != 25)
    {
      uint64_t v25 = *((unsigned int *)v24 + 4);
      if ((_DWORD)v25) {
        v24 -= 4 * v25;
      }
      else {
        __int128 v24 = 0LL;
      }
      if (!v24) {
        goto LABEL_8;
      }
    }

    id v26 = [v19 mutableCopy];
    uint64_t v22 = v24[1];
  }

  else
  {
LABEL_8:
    id v26 = [v19 mutableCopy];
  }

  __int128 v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v22 + 1));
  [v26 setObject:v27 forKeyedSubscript:@"functionIndex"];

  [v26 setObject:v20 forKeyedSubscript:@"DependencyGraphRequestedThumbnailTextureID"];
  [v13 addObject:v26];

  v32[0] = @"object";
  v32[1] = @"format";
  v33[0] = v20;
  v33[1] = v21;
  __int128 v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v33,  v32,  2LL));

  return v28;
}

uint64_t ResizeFormat(uint64_t result)
{
  char v1 = result + 6;
  if (((1LL << v1) & 0x425) != 0) {
    return 252LL;
  }
  if (((1LL << v1) & 0x1808) != 0) {
    return 253LL;
  }
LABEL_6:
  uint64_t v2 = 10LL;
  uint64_t v3 = 90LL;
  if (result != 1) {
    uint64_t v2 = v3;
  }
  return result;
}

id GTMTLReplayClient_generateThumbnails(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v124 = a3;
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"attachments"]);
  __int128 v111 = v5;
  id v126 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"resolution"]);
  uint64_t v115 = a1[2];
  uint64_t v7 = a1[15];
  uint64_t v122 = a1;
  uint64_t v119 = a1[14];
  __int128 v137 = 0u;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  __int128 v140 = 0u;
  id v8 = v6;
  id v9 = [v8 countByEnumeratingWithState:&v137 objects:v150 count:16];
  if (v9)
  {
    id v10 = v9;
    unint64_t v11 = 0LL;
    uint64_t v12 = *(void *)v138;
    do
    {
      for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v138 != v12) {
          objc_enumerationMutation(v8);
        }
        id v14 = [&off_59FA40 indexOfObject:*(void *)(*((void *)&v137 + 1) + 8 * (void)i)];
        uint64_t v15 = 1LL << (char)v14;
        if (v14 == (id)0x7FFFFFFFFFFFFFFFLL) {
          uint64_t v15 = 0LL;
        }
        v11 |= v15;
      }

      id v10 = [v8 countByEnumeratingWithState:&v137 objects:v150 count:16];
    }

    while (v10);
  }

  else
  {
    unint64_t v11 = 0LL;
  }

  unsigned int v118 = [v8 containsObject:@"All"];
  uint64_t v123 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  size_t v129 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 8LL);
  uint64_t v16 = (uint64_t)v122;
  uint64_t v17 = v115;
  if (*(int *)(v7 + 12) >= 1)
  {
    unint64_t v18 = 0LL;
    id v19 = 0LL;
    id v110 = v135;
    id v112 = v8;
    uint64_t v120 = v7;
    while (1)
    {
      uint64_t v20 = *(void *)(v7 + 24);
      uint64_t v21 = v20 + (v18 << 6);
      __int128 v23 = (int *)(v21 + 8);
      int v22 = *(_DWORD *)(v21 + 8);
      if (v22 > -16134) {
        break;
      }
      if (v22 > -16360)
      {
        if (v22 != -16359 && v22 != -16358) {
          goto LABEL_38;
        }
        goto LABEL_32;
      }

      if (v22 == -20474)
      {
        uint64_t v32 = (uint64_t *)GTTraceFunc_argumentBytesWithMap( (void *)v21,  *(unsigned __int8 *)(v20 + (v18 << 6) + 13),  v17);
        Object = GTMTLSMContext_getObject(**(void **)(v16 + 40), *v32, *(void *)v21);
        if (Object)
        {
          uint64_t v27 = Object[9];
          goto LABEL_35;
        }
      }

      else if (v22 == -20457)
      {
        uint64_t v25 = (uint64_t *)GTTraceFunc_argumentBytesWithMap( (void *)v21,  *(unsigned __int8 *)(v20 + (v18 << 6) + 13),  v17);
        id v26 = GTMTLSMContext_getObject(**(void **)(v16 + 40), *v25, *(void *)v21);
        if (v26)
        {
          uint64_t v27 = v26[12];
LABEL_35:
          id ThumbnailInfo = GTMTLReplayClient_getThumbnailInfo(v27, v16, (unint64_t *)v21, v18, v126, v124, v119);
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(ThumbnailInfo);
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v18));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v123, "setObject:forKeyedSubscript:", v30, v31);

          goto LABEL_118;
        }
      }

LABEL_118:
    }

    if (v22 <= -7159)
    {
      if (v22 != -16133)
      {
        if (v22 == -15310)
        {
          uint64_t v27 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v21,  *(unsigned __int8 *)(v20 + (v18 << 6) + 13),  v17)
                + 1);
          if (v27) {
            goto LABEL_35;
          }
        }

        goto LABEL_38;
      }

              unsigned int v74 = __n;
              uint64_t v75 = __n < 0 || __n - (int)v70 <= 4;
              uint64_t v76 = !v75;
              if (__n >= -3 && v76 == 0)
              {
                if (__n <= 0)
                {
                  if (__s[0] != 48) {
                    *p_n_6++ = 46;
                  }
                  if (v74 < 0)
                  {
                    do
                    {
                      __n = v74 + 1;
                      *p_n_6++ = 48;
                      unsigned int v74 = __n;
                    }

                    while (__n < 0);
                  }

                  else
                  {
                    unsigned int v74 = 0;
                  }
                }

                if ((int)v70 >= 1)
                {
                  uint64_t v149 = 0LL;
                  do
                  {
                    *p_n_6 = __s[v149];
                    if ((_DWORD)v149 + 1 == __n)
                    {
                      p_n_6[1] = 46;
                      p_n_6 += 2;
                    }

                    else
                    {
                      ++p_n_6;
                    }

                    ++v149;
                  }

                  while ((v70 - 1) + 1LL != v149);
                  unsigned int v74 = __n;
                }

                if ((int)v70 < v74)
                {
                  do
                  {
                    int8x16_t v150 = p_n_6;
                    LODWORD(v70) = v70 + 1;
                    *p_n_6++ = 48;
                  }

                  while ((int)v70 < __n);
                  *p_n_6 = 46;
                  p_n_6 = v150 + 2;
                }
              }

              else
              {
                --__n;
                *p_n_6 = __s[0];
                uint64_t v78 = p_n_6 + 2;
                p_n_6[1] = 46;
                if ((int)v70 > 1)
                {
                  id v185 = v74;
                  memcpy(v78, &__s[1], (v70 - 1));
                  unsigned int v74 = v185;
                  uint64_t v78 = &p_n_6[(v70 - 2) + 3];
                }

                *uint64_t v78 = 101;
                if (v74 < 1)
                {
                  __n = 1 - v74;
                  uint64_t v79 = 45;
                }

                else
                {
                  uint64_t v79 = 43;
                }

                v78[1] = v79;
                __int128 v138 = __n;
                if (__n < 100)
                {
                  __int128 v139 = v78 + 2;
                }

                else
                {
                  __int128 v139 = v78 + 3;
                  v78[2] = __n / 0x64u + 48;
                  __int128 v138 = __n;
                }

                if (v138 >= 10)
                {
                  *v139++ = ((103 * (v138 % 0x64u)) >> 10) | 0x30;
                  __int128 v138 = __n;
                }

                *__int128 v139 = v138 % 10 + 48;
                p_n_6 = v139 + 1;
              }

              unint64_t v151 = p_n_6 - 1;
              if (*(p_n_6 - 1) != 46 || v16 != 0) {
                unint64_t v151 = p_n_6;
              }
              *unint64_t v151 = 0;
              uint64_t v153 = 32 * (v14 != 0);
              if (v15) {
                uint64_t v153 = 43;
              }
              if (__n_5[0] == 45) {
                uint64_t v99 = 45;
              }
              else {
                uint64_t v99 = v153;
              }
              if (__n_5[0] == 45) {
                uint64_t v7 = &__n_6;
              }
              else {
                uint64_t v7 = __n_5;
              }
              uint64_t v154 = strlen(v7);
              __int128 v195 = (_BYTE *)v154;
              if (v16)
              {
                __int128 v155 = v154;
                if (!strchr(v7, 46))
                {
                  __int128 v195 = (_BYTE *)(v155 + 1);
                  *(_WORD *)&v7[v155] = 46;
                }
              }

              BOOL v40 = flush_func;
              if (*fmt == 71)
              {
                id v156 = strchr(v7, 101);
                if (v156) {
                  *id v156 = 69;
                }
              }

              id v101 = endpos;
              LODWORD(v19) = v192;
              goto LABEL_408;
            }

            if (v36 != 88) {
              goto LABEL_139;
            }
LABEL_96:
            if (v32)
            {
              uint64_t v62 = (unint64_t *)v196;
              v196 += 8;
              uint64_t v63 = *v62;
              uint64_t v64 = "0123456789abcdef";
              if (*fmt == 88) {
                uint64_t v64 = "0123456789ABCDEF";
              }
              if (HIDWORD(v63))
              {
                uint64_t v7 = &v202[3];
                BOOL v40 = flush_func;
                do
                {
                  *--uint64_t v7 = v64[v63 & 0xF];
                  uint64_t v65 = v63 >= 0x10;
                  v63 >>= 4;
                }

                while (v65);
              }

              else
              {
                uint64_t v7 = &v202[3];
                BOOL v40 = flush_func;
                do
                {
                  *--uint64_t v7 = v64[v63 & 0xF];
                  uint64_t v65 = v63 >= 0x10;
                  LODWORD(v63) = v63 >> 4;
                }

                while (v65);
              }
            }

            else
            {
              unint64_t v102 = (unsigned int *)v196;
              v196 += 8;
              BOOL v103 = *v102;
              if ((_DWORD)v35) {
                BOOL v103 = (unsigned __int16)v103;
              }
              uint64_t v104 = "0123456789abcdef";
              if (*fmt == 88) {
                uint64_t v104 = "0123456789ABCDEF";
              }
              uint64_t v7 = &v202[3];
              uint64_t v187 = v103;
              do
              {
                *--uint64_t v7 = v104[v103 & 0xF];
                uint64_t v75 = v103 > 0xF;
                v103 >>= 4;
              }

              while (v75);
              BOOL v40 = flush_func;
            }

            unsigned __int16 v134 = (_BYTE *)(&v202[3] - v7);
            __int128 v195 = (_BYTE *)(&v202[3] - v7);
            if ((v17 & 1) == 0)
            {
              __int128 v137 = 511LL;
              if (v189 + 1 < 0x200) {
                __int128 v137 = v189;
              }
              while ((unint64_t)v134 < v137)
              {
                *--uint64_t v7 = 48;
                unsigned __int16 v134 = ++v195;
              }
            }

            LOBYTE(v35) = 0;
            if (v16 && v187)
            {
              LOBYTE(v35) = 0;
              LOBYTE(v16) = 0;
              uint64_t v135 = *fmt;
              *(v7 - 2) = 48;
              v7 -= 2;
              v7[1] = v135;
              uint64_t v136 = v195 + 2;
LABEL_301:
              __int128 v195 = v136;
            }

            else
            {
              LOBYTE(v16) = 0;
            }

            goto LABEL_318;
        }
      }

      break;
    }

    LOBYTE(v10) = *fmt;
  }

  while (!*fmt);
  if (v36 == 37)
  {
    LOBYTE(v35) = 0;
    LOBYTE(v16) = 0;
    LOBYTE(v83) = 37;
LABEL_142:
    v194[0] = v83;
    uint64_t v82 = 1LL;
LABEL_143:
    __int128 v195 = (_BYTE *)v82;
    uint64_t v7 = v194;
LABEL_144:
    unint64_t v18 = 32;
LABEL_304:
    BOOL v40 = flush_func;
LABEL_318:
    id v101 = endpos;
    goto LABEL_412;
  }

  if (v36 != 69)
  {
LABEL_139:
    LOBYTE(v35) = 0;
    LOBYTE(v16) = 0;
    v194[0] = 37;
    v194[1] = *fmt;
    uint64_t v82 = 2LL;
    goto LABEL_143;
  }

id _processThumbnailAttachments(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  id v26 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v6 count]);
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  obuint64_t j = v6;
  id v7 = [obj countByEnumeratingWithState:&v27 objects:v35 count:16];
  if (v7)
  {
    id v8 = v7;
    id v9 = 0LL;
    uint64_t v24 = *(void *)v28;
    uint64_t v25 = a3 + 1;
    do
    {
      id v10 = 0LL;
      unint64_t v11 = v9;
      do
      {
        if (*(void *)v28 != v24) {
          objc_enumerationMutation(obj);
        }
        uint64_t v12 = *(void **)(*((void *)&v27 + 1) + 8LL * (void)v10);
        id v13 = (void *)objc_claimAutoreleasedReturnValue( [v12 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"]);
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"format"]);
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v5 count]));
        v33[0] = @"object";
        v33[1] = @"format";
        v34[0] = v15;
        v34[1] = v14;
        id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v34,  v33,  2LL));

        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( &off_59FA40,  "objectAtIndexedSubscript:",  objc_msgSend(v13, "unsignedIntegerValue")));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v26, "setObject:forKeyedSubscript:", v9, v16);

        id v17 = [v12 mutableCopy];
        unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v25));
        [v17 setObject:v18 forKeyedSubscript:@"functionIndex"];

        [v17 setObject:v15 forKeyedSubscript:@"DependencyGraphRequestedThumbnailTextureID"];
        [v5 addObject:v17];

        id v10 = (char *)v10 + 1;
        unint64_t v11 = v9;
      }

      while (v8 != v10);
      id v8 = [obj countByEnumeratingWithState:&v27 objects:v35 count:16];
    }

    while (v8);
  }

  else
  {
    id v9 = 0LL;
  }

  id v19 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"object"]);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"format"]);
  v31[0] = @"object";
  v31[1] = @"format";
  v32[0] = v19;
  v32[1] = v20;
  v31[2] = @"target";
  void v32[2] = v26;
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v32,  v31,  3LL));

  return v21;
}

id GTMTLReplayClient_generateDependencyGraphThumbnails(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"DependencyGraphRequestedTexturesForThumbnail"]);
  BOOL v46 = v5;
  BOOL v57 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"resolution"]);
  char v49 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v7 count]);
  uint64_t v50 = v7;
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 allKeys]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 sortedArrayUsingSelector:"compare:"]);

  __int128 v79 = 0u;
  __int128 v80 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  obuint64_t j = v9;
  id v51 = [obj countByEnumeratingWithState:&v77 objects:v91 count:16];
  if (v51)
  {
    uint64_t v48 = *(void *)v78;
    uint64_t v55 = a1;
    uint64_t v56 = v6;
    do
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(void *)v78 != v48) {
          objc_enumerationMutation(obj);
        }
        uint64_t v53 = v10;
        unint64_t v11 = *(void **)(*((void *)&v77 + 1) + 8 * v10);
        uint64_t v12 = (char *)[v11 unsignedLongLongValue];
        uint64_t v52 = v11;
        id v13 = (void *)objc_claimAutoreleasedReturnValue([v50 objectForKeyedSubscript:v11]);
        id v60 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        __int128 v73 = 0u;
        __int128 v74 = 0u;
        __int128 v75 = 0u;
        __int128 v76 = 0u;
        id v54 = v13;
        id v62 = [v54 countByEnumeratingWithState:&v73 objects:v90 count:16];
        if (v62)
        {
          uint64_t v61 = *(void *)v74;
          id v58 = v12 + 1;
          unint64_t v59 = v12;
          do
          {
            for (uint64_t i = 0LL; i != v62; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v74 != v61) {
                objc_enumerationMutation(v54);
              }
              uint64_t v15 = *(void **)(*((void *)&v73 + 1) + 8LL * (void)i);
              uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"DependencyGraphRequestedTextureID"]);
              AliasStreaunint64_t m = (uint64_t *)GetAliasStream( *(void *)(a1 + 24),  (uint64_t)[v16 unsignedLongLongValue],  (unint64_t)&v12[*(void *)(a1 + 80)]);
              if (AliasStream) {
                uint64_t v18 = *AliasStream;
              }
              else {
                uint64_t v18 = 0LL;
              }
              GTMTLSMContext_getTextureDescriptor( *(uint64_t **)(a1 + 40),  v18,  (unint64_t)&v12[*(void *)(a1 + 80)],  (uint64_t)v70);
              if (v71)
              {
                uint64_t v19 = v72;
                if ((unint64_t)v72 - 261 >= 2)
                {
                  if (v72 == 1LL) {
                    uint64_t v19 = 10LL;
                  }
                }

                else
                {
                  uint64_t v19 = 253LL;
                }

                uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( [v15 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"]);
                uint64_t v64 = v24;
                if (v24 && (v19 == 260 || v19 == 255))
                {
                  uint64_t v25 = v6;
                  if ([v24 unsignedIntegerValue] == (char *)&dword_8 + 1)
                  {
                    unsigned __int16 v72 = 253;
                    uint64_t v19 = 253LL;
                  }
                }

                else
                {
                  uint64_t v25 = v6;
                }

                id v26 = [v15 mutableCopy];
                __int128 v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v25 count]));
                v87[0] = v27;
                v86[0] = @"DependencyGraphRequestedThumbnailTextureID";
                v86[1] = @"format";
                __int128 v28 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  ResizeFormat(v19));
                __int128 v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
                v87[1] = v29;
                __int128 v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v87,  v86,  2LL));
                [v26 addEntriesFromDictionary:v30];

                uint64_t v63 = v26;
                -[NSMutableArray addObject:](v60, "addObject:", v26);
                v84[0] = @"type";
                v84[1] = @"object";
                v85[0] = &off_5A0910;
                uint64_t v65 = v16;
                v85[1] = v16;
                v84[2] = @"functionIndex";
                uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v58));
                v85[2] = v31;
                v85[3] = v57;
                v84[3] = @"resolution";
                v84[4] = @"DependencyGraphRequestedThumbnailTextureID";
                v85[4] = v27;
                uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v85,  v84,  5LL));
                id v33 = [v32 mutableCopy];

                __int128 v68 = 0u;
                __int128 v69 = 0u;
                __int128 v66 = 0u;
                __int128 v67 = 0u;
                id v34 = [&off_59FA58 countByEnumeratingWithState:&v66 objects:v83 count:16];
                if (v34)
                {
                  id v35 = v34;
                  uint64_t v36 = *(void *)v67;
                  do
                  {
                    for (uint64_t j = 0LL; j != v35; uint64_t j = (char *)j + 1)
                    {
                      if (*(void *)v67 != v36) {
                        objc_enumerationMutation(&off_59FA58);
                      }
                      uint64_t v38 = *(void *)(*((void *)&v66 + 1) + 8LL * (void)j);
                      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v38]);
                      if (v39) {
                        [v33 setObject:v39 forKeyedSubscript:v38];
                      }
                    }

                    id v35 = [&off_59FA58 countByEnumeratingWithState:&v66 objects:v83 count:16];
                  }

                  while (v35);
                }

                id v6 = v56;
                [v56 addObject:v33];

                a1 = v55;
                uint64_t v12 = v59;
                id v23 = v64;
                uint64_t v16 = v65;
              }

              else
              {
                v89[0] = @"Failed to generate dependency graph thumbnail";
                v88[0] = NSLocalizedDescriptionKey;
                v88[1] = @"GTErrorKeyTraceStreamID";
                uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v18));
                v89[1] = v20;
                uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v89,  v88,  2LL));
                id NSError = MakeNSError(101, v21);
                id v23 = (id)objc_claimAutoreleasedReturnValue(NSError);

                GTMTLReplay_handleNSError(v23);
              }
            }

            id v62 = [v54 countByEnumeratingWithState:&v73 objects:v90 count:16];
          }

          while (v62);
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:](v49, "setObject:forKeyedSubscript:", v60, v52);
        uint64_t v10 = v53 + 1;
      }

      while ((id)(v53 + 1) != v51);
      id v51 = [obj countByEnumeratingWithState:&v77 objects:v91 count:16];
    }

    while (v51);
  }

  uint64_t v40 = *(void *)(a1 + 8);
  v70[0] = 1LL;
  uint64_t v41 = *(void *)(*(void *)(*find_entry(v40, v70, 8uLL, 0LL) + 32LL) + 8LL);
  v81[0] = @"device";
  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v41));
  v81[1] = @"object";
  v82[0] = v42;
  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithDictionary:",  v49));
  v82[1] = v43;
  int v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v82,  v81,  2LL));

  return v44;
}

void GTMTLReplayErrorHandling_initWithObserver(id obj)
{
}

id GTMTLReplay_dictionaryFromCommandBuffer(void *a1)
{
  id v1 = a1;
  __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([v1 error]);
  v109[0] = @"retainedReferences";
  uint64_t v2 = &CATransform3DIdentity_ptr;
  __int128 v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  [v1 retainedReferences]));
  v110[0] = v77;
  v109[1] = @"label";
  __int128 v76 = (void *)objc_claimAutoreleasedReturnValue([v1 label]);
  if (v76) {
    uint64_t v3 = objc_claimAutoreleasedReturnValue([v1 label]);
  }
  else {
    uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
  }
  __int128 v75 = (void *)v3;
  v110[1] = v3;
  v109[2] = @"kernelStartTime";
  [v1 kernelStartTime];
  __int128 v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  v110[2] = v74;
  v109[3] = @"kernelEndTime";
  [v1 kernelEndTime];
  __int128 v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  v110[3] = v73;
  v109[4] = @"GPUStartTime";
  [v1 GPUStartTime];
  unsigned __int16 v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  v110[4] = v72;
  v109[5] = @"GPUEndTime";
  [v1 GPUEndTime];
  int v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  v110[5] = v71;
  v109[6] = @"status";
  __int128 v79 = v1;
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 status]));
  v110[6] = v70;
  v109[7] = @"error";
  if (v78)
  {
    id v4 = v78;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 userInfo]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"MTLCommandBufferEncoderInfoErrorKey"]);

    __int128 v111 = @"domain";
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v4 domain]);
    uint64_t v122 = v7;
    id v112 = @"code";
    id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [v4 code]));
    uint64_t v123 = v8;
    uint64_t v113 = @"localizedDescription";
    uint64_t v9 = objc_claimAutoreleasedReturnValue([v4 localizedDescription]);
    uint64_t v10 = (void *)v9;
    uint64_t v124 = v9;
    unint64_t v114 = @"commandBufferEncoderInfo";
    if (v6)
    {
      uint64_t v97 = (void *)v9;
      id v99 = v8;
      id v101 = v7;
      BOOL v103 = v6;
      id v105 = v4;
      id v11 = v6;
      uint64_t v12 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v11 count]);
      __int128 v133 = 0u;
      __int128 v134 = 0u;
      __int128 v135 = 0u;
      __int128 v136 = 0u;
      obuint64_t j = v11;
      id v13 = [obj countByEnumeratingWithState:&v133 objects:&v141 count:16];
      if (v13)
      {
        id v14 = v13;
        uint64_t v15 = *(void *)v134;
        do
        {
          for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v134 != v15) {
              objc_enumerationMutation(obj);
            }
            id v17 = *(void **)(*((void *)&v133 + 1) + 8LL * (void)i);
            *(void *)&__int128 v137 = @"label";
            uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 label]);
            if (v18) {
              uint64_t v19 = objc_claimAutoreleasedReturnValue([v17 label]);
            }
            else {
              uint64_t v19 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
            }
            uint64_t v20 = (void *)v19;
            *(void *)&__int128 v145 = v19;
            *((void *)&v137 + 1) = @"debugSignposts";
            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v17 debugSignposts]);
            if (v21) {
              uint64_t v22 = objc_claimAutoreleasedReturnValue([v17 debugSignposts]);
            }
            else {
              uint64_t v22 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
            }
            id v23 = (void *)v22;
            *((void *)&v145 + 1) = v22;
            *(void *)&__int128 v138 = @"errorState";
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [v17 errorState]));
            *(void *)&__int128 v146 = v24;
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v145,  &v137,  3LL));
            -[NSMutableArray addObject:](v12, "addObject:", v25);
          }

          id v14 = [obj countByEnumeratingWithState:&v133 objects:&v141 count:16];
        }

        while (v14);
      }

      id v26 = -[NSMutableArray copy](v12, "copy");
      uint64_t v2 = &CATransform3DIdentity_ptr;
      id v6 = v103;
      id v4 = v105;
      id v8 = v99;
      id v7 = v101;
      uint64_t v10 = v97;
    }

    else
    {
      id v26 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }

    id v125 = v26;
    uint64_t v27 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v122,  &v111,  4LL));
  }

  else
  {
    uint64_t v27 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
  }

  __int128 v69 = (void *)v27;
  v110[7] = v27;
  v109[8] = @"errorOptions";
  __int128 v68 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedInteger:]( (id)v2[280],  "numberWithUnsignedInteger:",  [v79 errorOptions]));
  v110[8] = v68;
  v109[9] = @"logs";
  id v28 = (id)objc_claimAutoreleasedReturnValue([v79 logs]);
  uint64_t v82 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v137 = 0u;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  __int128 v140 = 0u;
  id v80 = v28;
  id v83 = [v80 countByEnumeratingWithState:&v137 objects:&v133 count:16];
  if (v83)
  {
    uint64_t v81 = *(void *)v138;
    do
    {
      uint64_t v29 = 0LL;
      do
      {
        if (*(void *)v138 != v81) {
          objc_enumerationMutation(v80);
        }
        __int128 v30 = *(void **)(*((void *)&v137 + 1) + 8 * v29);
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 function]);
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v30 buffer]);
        uint64_t v95 = v29;
        if ((objc_opt_respondsToSelector(v30, "encoderIdentifier") & 1) != 0) {
          uint64_t v33 = objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v30 performSelector:"encoderIdentifier"]));
        }
        else {
          uint64_t v33 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }
        id v98 = (void *)v33;
        if ((objc_opt_respondsToSelector(v30, "encoderLabel") & 1) != 0) {
          id v34 = [v30 performSelector:"encoderLabel"];
        }
        else {
          id v34 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }
        uint64_t v35 = (uint64_t)v34;
        uint64_t v93 = v34;
        __int128 v111 = @"type";
        unint64_t v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v30 type]));
        uint64_t v122 = v92;
        id v112 = @"encoderMethodIdentifier";
        unint64_t v91 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v30 encoderMethodIdentifier]));
        uint64_t v123 = v91;
        uint64_t v124 = v35;
        uint64_t v113 = @"encoderLabel";
        unint64_t v114 = @"encoderIdentifier";
        id v125 = v98;
        uint64_t v115 = @"function";
        uint64_t v94 = v31;
        unint64_t v96 = v32;
        if (v31)
        {
          id v36 = v31;
          *(void *)&__int128 v145 = @"label";
          int v37 = (void *)objc_claimAutoreleasedReturnValue([v36 label]);
          if (v37) {
            uint64_t v38 = objc_claimAutoreleasedReturnValue([v36 label]);
          }
          else {
            uint64_t v38 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
          }
          uint64_t v40 = (void *)v38;
          uint64_t v141 = v38;
          *((void *)&v145 + 1) = @"functionType";
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v36 functionType]));
          uint64_t v142 = (uint64_t)v41;
          *(void *)&__int128 v146 = @"name";
          uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v36 name]);
          id v143 = v42;
          uint64_t v39 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v141,  &v145,  3LL));

          uint64_t v32 = v96;
        }

        else
        {
          uint64_t v39 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }

        uint64_t v126 = v39;
        unsigned int v116 = @"logMessage";
        id v89 = (void *)objc_claimAutoreleasedReturnValue([v30 description]);
        if (v89) {
          uint64_t v43 = objc_claimAutoreleasedReturnValue([v30 description]);
        }
        else {
          uint64_t v43 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }
        unint64_t v88 = (void *)v43;
        uint64_t v127 = v43;
        __int128 v117 = @"addressSpace";
        BOOL v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v30 addressSpace]));
        uint64_t v128 = v87;
        unsigned int v118 = @"buffer";
        uint64_t v90 = (void *)v39;
        if (v32)
        {
          id v44 = v32;
          *(void *)&__int128 v145 = @"length";
          int v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v44 length]));
          uint64_t v141 = (uint64_t)v45;
          *((void *)&v145 + 1) = @"label";
          BOOL v46 = (void *)objc_claimAutoreleasedReturnValue([v44 label]);
          if (v46) {
            uint64_t v47 = objc_claimAutoreleasedReturnValue([v44 label]);
          }
          else {
            uint64_t v47 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
          }
          uint64_t v32 = (void *)v47;
          uint64_t v142 = v47;
          *(void *)&__int128 v146 = @"resourceOptions";
          char v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v44 resourceOptions]));
          id v143 = v49;
          *((void *)&v146 + 1) = @"allocatedSize";
          uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v44 allocatedSize]));
          __int128 v144 = v50;
          uint64_t v48 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v141,  &v145,  4LL));
        }

        else
        {
          uint64_t v48 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }

        id v86 = (void *)v48;
        uint64_t v129 = v48;
        uint64_t v119 = @"offset";
        uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [v30 offset]));
        uint64_t v130 = v85;
        uint64_t v120 = @"operation";
        uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v30 operation]));
        uint64_t v131 = v84;
        uint64_t v121 = @"errorStackTrace";
        id v51 = (id)objc_claimAutoreleasedReturnValue([v30 errorStackTrace]);
        uint64_t v104 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v51 count]);
        __int128 v145 = 0u;
        __int128 v146 = 0u;
        __int128 v147 = 0u;
        __int128 v148 = 0u;
        id v100 = v51;
        id v106 = [v100 countByEnumeratingWithState:&v145 objects:&v141 count:16];
        if (v106)
        {
          uint64_t v102 = *(void *)v146;
          do
          {
            for (uint64_t j = 0LL; j != v106; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v146 != v102) {
                objc_enumerationMutation(v100);
              }
              id v53 = *(id *)(*((void *)&v145 + 1) + 8LL * (void)j);
              v149[0] = @"functionName";
              uint64_t v54 = objc_claimAutoreleasedReturnValue([v53 functionName]);
              if (v54) {
                uint64_t v55 = objc_claimAutoreleasedReturnValue([v53 functionName]);
              }
              else {
                uint64_t v55 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
              }
              uint64_t v56 = (void *)v55;
              v150[0] = v55;
              v149[1] = @"URL";
              BOOL v57 = (void *)objc_claimAutoreleasedReturnValue([v53 URL]);
              id v58 = (void *)objc_claimAutoreleasedReturnValue([v57 path]);
              id obja = (id)v54;
              if (v58)
              {
                uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v53 URL]);
                unint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v32 path]);
              }

              else
              {
                unint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
              }

              v150[1] = v59;
              v149[2] = @"line";
              id v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v53 line]));
              v150[2] = v60;
              v149[3] = @"column";
              uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v53 column]));
              v150[3] = v61;
              id v62 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v150,  v149,  4LL));

              if (v58)
              {

                unint64_t v59 = v32;
              }

              -[NSMutableArray addObject:](v104, "addObject:", v62);
            }

            id v106 = [v100 countByEnumeratingWithState:&v145 objects:&v141 count:16];
          }

          while (v106);
        }

        id v63 = -[NSMutableArray copy](v104, "copy");
        id v132 = v63;
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v122,  &v111,  11LL));
        -[NSMutableArray addObject:](v82, "addObject:", v64);

        uint64_t v29 = v95 + 1;
      }

      while ((id)(v95 + 1) != v83);
      id v83 = [v80 countByEnumeratingWithState:&v137 objects:&v133 count:16];
    }

    while (v83);
  }

  id v65 = -[NSMutableArray copy](v82, "copy");
  v110[9] = v65;
  __int128 v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v110,  v109,  10LL));

  return v66;
}

void GTMTLReplay_handleError(int a1, uint64_t a2, char *__big, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = strstr(__big, "gputools");
  if (a6 > 15)
  {
    if (a6 > 63)
    {
      if (a6 == 64)
      {
        id v13 = "Access tracking";
        goto LABEL_16;
      }

      if (a6 == 128)
      {
        id v13 = "Post vertex";
        goto LABEL_16;
      }
    }

    else
    {
      if (a6 == 16)
      {
        id v13 = "Wireframe";
        goto LABEL_16;
      }

      if (a6 == 32)
      {
        id v13 = "Fetch resource";
LABEL_16:
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
        id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@: %@",  v15,  v16));

        goto LABEL_17;
      }
    }

id MakeNSError(int a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v24;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void *)(*((void *)&v23 + 1) + 8LL * (void)i);
        id v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", v10, (void)v23));
        -[NSMutableDictionary setObject:forKey:](v4, "setObject:forKey:", v11, v10);
      }

      id v7 = [v5 countByEnumeratingWithState:&v23 objects:v27 count:16];
    }

    while (v7);
  }

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSThread callStackSymbols](&OBJC_CLASS___NSThread, "callStackSymbols"));
  if (v12) {
    -[NSMutableDictionary setObject:forKey:](v4, "setObject:forKey:", v12, @"GTErrorKeyCallStack");
  }
  if (a1 == 100)
  {
LABEL_11:
    id v13 = (id)g_activityLog;
    if (!v13) {
      goto LABEL_26;
    }
    goto LABEL_19;
  }

  id v14 = pthread_self();
  pthread_rwlock_rdlock(&rwlock);
  uint64_t v15 = 0LL;
  uint64_t v16 = (pthread_t *)threadLocalLogs;
  while (!pthread_equal(v14, *v16))
  {
    ++v15;
    v16 += 2;
    if (v15 == 7)
    {
      id v13 = 0LL;
      goto LABEL_18;
    }
  }

  id v13 = (id)threadLocalLogs[2 * v15 + 1];
LABEL_18:
  pthread_rwlock_unlock(&rwlock);
  if (!v13)
  {
    label = dispatch_queue_get_label(0LL);
    if (strncmp(label, "gputools.MTLReplayer.serialQueue", 0x20uLL)) {
      goto LABEL_26;
    }
    goto LABEL_11;
  }

void GTMTLReplay_handleNSError(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue([v1 domain]);

  if (v2 != @"com.apple.gputools.MTLReplayer") {
    goto LABEL_10;
  }
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 userInfo]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:NSLocalizedDescriptionKey]);

  id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 userInfo]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:NSLocalizedFailureReasonErrorKey]);

  if (v4 && v6 != 0LL)
  {
LABEL_10:
    id v11 = v1;
    goto LABEL_11;
  }

  uint64_t v8 = objc_alloc(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v1 userInfo]);
  uint64_t v10 = -[NSMutableDictionary initWithDictionary:](v8, "initWithDictionary:", v9);

  if (!v4)
  {
    id v30 = v1;
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 domain]);
    unsigned int v32 = [v31 isEqualToString:@"com.apple.gputools.MTLReplayer"];

    if (v32)
    {
      uint64_t v33 = (char *)[v30 code];
      if (v33 == &stru_B8.segname[1])
      {
        uint64_t v35 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
        -[__CFString appendString:]( v35,  "appendString:",  @"The replayer encountered an error during command buffer");
        id v36 = (void *)objc_claimAutoreleasedReturnValue([v30 userInfo]);
        int v37 = (void *)objc_claimAutoreleasedReturnValue([v36 objectForKeyedSubscript:@"GTErrorKeyMTLCommandBuffer"]);
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKeyedSubscript:@"label"]);

        if (v38)
        {
          uint64_t v40 = objc_opt_class(&OBJC_CLASS___NSString, v39);
          if ((objc_opt_isKindOfClass(v38, v40) & 1) != 0) {
            -[__CFString appendFormat:](v35, "appendFormat:", @" %@", v38);
          }
        }

        -[__CFString appendString:](v35, "appendString:", @" execution.");
      }

      else
      {
        id v34 = @"The replayer encountered an internal error.";
        if (v33 != (_BYTE *)&stru_20.flags + 1) {
          id v34 = 0LL;
        }
        if (v33 == (_BYTE *)&stru_20.flags + 2) {
          uint64_t v35 = @"The replayer could not harvest a resource.";
        }
        else {
          uint64_t v35 = (__CFString *)v34;
        }
      }
    }

    else
    {
      uint64_t v35 = 0LL;
    }

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v35,  NSLocalizedDescriptionKey);
    if (v6) {
      goto LABEL_46;
    }
    goto LABEL_38;
  }

  if (!v6)
  {
LABEL_38:
    id v41 = v1;
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 domain]);
    unsigned int v43 = [v42 isEqualToString:@"com.apple.gputools.MTLReplayer"];

    if (v43 && [v41 code] == &stru_B8.segname[1])
    {
      id v44 = (void *)objc_claimAutoreleasedReturnValue([v41 userInfo]);
      int v45 = (void *)objc_claimAutoreleasedReturnValue([v44 objectForKeyedSubscript:@"GTErrorKeyMTLCommandBuffer"]);
      BOOL v46 = (void *)objc_claimAutoreleasedReturnValue([v45 objectForKeyedSubscript:@"error"]);

      uint64_t v48 = objc_opt_class(&OBJC_CLASS___NSDictionary, v47);
      if ((objc_opt_isKindOfClass(v46, v48) & 1) != 0) {
        char v49 = (void *)objc_claimAutoreleasedReturnValue([v46 objectForKeyedSubscript:@"localizedDescription"]);
      }
      else {
        char v49 = 0LL;
      }
    }

    else
    {
      char v49 = 0LL;
    }

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v49,  NSLocalizedFailureReasonErrorKey);
  }

LABEL_46:
  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v1 domain]);
  id v11 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( NSError,  "errorWithDomain:code:userInfo:",  v50,  [v1 code],  v10));

LABEL_11:
  id v12 = v11;
  if (v12)
  {
    id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v12 domain]);
    id v15 = [v12 code];
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v12 localizedDescription]);
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v12 localizedFailureReason]);
    -[NSMutableString appendFormat:]( v13,  "appendFormat:",  @"Replayer error\nDomain: %@\nCode: %d\nDescription: %@\nReason: %@\n",  v14,  v15,  v16,  v17);

    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v51 = 0u;
    __int128 v52 = 0u;
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v12 userInfo]);
    id v19 = [v18 countByEnumeratingWithState:&v51 objects:v57 count:16];
    if (v19)
    {
      id v20 = v19;
      uint64_t v21 = *(void *)v52;
      do
      {
        for (uint64_t i = 0LL; i != v20; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v52 != v21) {
            objc_enumerationMutation(v18);
          }
          uint64_t v23 = *(void *)(*((void *)&v51 + 1) + 8LL * (void)i);
          __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v12 userInfo]);
          __int128 v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:v23]);
          -[NSMutableString appendFormat:](v13, "appendFormat:", @"%@: %@\n", v23, v25);
        }

        id v20 = [v18 countByEnumeratingWithState:&v51 objects:v57 count:16];
      }

      while (v20);
    }

    if (s_logUsingOsLog)
    {
      id v26 = gt_default_log();
      uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      {
        id v28 = -[NSMutableString UTF8String](v13, "UTF8String");
        *(_DWORD *)buf = 136315138;
        id v56 = v28;
        _os_log_fault_impl(&dword_0, v27, OS_LOG_TYPE_FAULT, "fail: %s", buf, 0xCu);
      }
    }

    else
    {
      uint64_t v29 = __stderrp;
      uint64_t v27 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: %s", -[NSMutableString UTF8String]( v13, "UTF8String")));
      fprintf(v29, "%s\n", (const char *)-[os_log_s UTF8String](v27, "UTF8String"));
    }
  }

  [(id)_observer notifyError:v12];
}

      if (++v14 >= v12->nelts) {
        goto LABEL_47;
      }
    }

    __int128 v25 = a5[1];
    if (v21 != v25)
    {
      unsigned int v32 = *(uint64_t **)(v11 + 40);
      Object = a5;
      while (*(void *)(v15 + 120) != v25)
      {
        if (*(_DWORD *)Object == 29)
        {
          Object = GTMTLSMContext_getObject(*v32, Object[5], Object[2]);
          if (!Object || *(_DWORD *)Object != 29) {
            goto LABEL_46;
          }
        }

        else
        {
          if (*(_DWORD *)Object != 71) {
            goto LABEL_46;
          }
          Object = GTMTLSMContext_getObject(*v32, Object[5], Object[2]);
          if (!Object || *(_DWORD *)Object != 71) {
            goto LABEL_46;
          }
        }

        __int128 v25 = Object[1];
        if (*(void *)(v15 + 128) == v25) {
          break;
        }
      }
    }

    int v71 = *(id *)(a2 + 8);
    GetVisibleFunctionTableState((uint64_t)v80, v11, v15, v76, pa);
    id v26 = objc_alloc_init(&OBJC_CLASS___MTLVisibleFunctionTableDescriptor);
    -[MTLVisibleFunctionTableDescriptor setFunctionCount:](v26, "setFunctionCount:", **(void **)(v15 + 104));
    -[MTLVisibleFunctionTableDescriptor setResourceIndex:]( v26,  "setResourceIndex:",  *(void *)(*(void *)(v15 + 104) + 8LL));
    -[MTLVisibleFunctionTableDescriptor setForceResourceIndex:](v26, "setForceResourceIndex:", 1LL);
    if (*(void *)(v15 + 128))
    {
      uint64_t v27 = *(unsigned __int8 *)(v15 + 168);
      id v28 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( *(void *)(a3 + 40),  *(void *)(a3 + 48),  a5[1]);
      if (v28)
      {
        uint64_t v29 = (id)v28[3];
        if (v29)
        {
          __int128 v67 = v29;
          id v30 = [v29 newVisibleFunctionTableWithDescriptor:v26 stage:v27];
          if (v30)
          {
            uint64_t v31 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( *(void *)(a3 + 80),  *(void *)(a3 + 88),  v27);
            if (!v31) {
              abort();
            }
            SetupInstrumentedFunctionTable(v30, *(uint64_t **)(v11 + 40), (uint64_t)(v31 + 3), (uint64_t)v80, a5[1], v76);
          }

        *((_DWORD *)v15 + 2) = v32;
LABEL_47:

        objc_storeStrong((id *)(a1 + 184), obj);
        id v28 = 1LL;
        break;
      case 6uLL:
        __int128 v69 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"AmplificationID"));
        __int128 v66 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionX"));
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionY"));
        id v60 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionZ"));
        id v58 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionX"));
        id v63 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionY"));
        id v62 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionZ"));
        BOOL v46 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"ObjectThreadgroupPosX"));
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"ObjectThreadgroupPosY"));
        BOOL v57 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"ObjectThreadgroupPosZ"));
        *(void *)&uint64_t v48 = -1LL;
        *((void *)&v48 + 1) = -1LL;
        *(_OWORD *)(v15 + 12) = v48;
        *(_OWORD *)(v15 + 28) = v48;
        *(_OWORD *)(v15 + 44) = v48;
        *(void *)(v15 + 60) = -1LL;
        *((_DWORD *)v15 + 4) = [v66 unsignedIntValue];
        *((_DWORD *)v15 + 5) = [v21 unsignedIntValue];
        *((_DWORD *)v15 + 6) = [v60 unsignedIntValue];
        *((_DWORD *)v15 + 8) = [v58 unsignedIntValue];
        *((_DWORD *)v15 + 9) = [v63 unsignedIntValue];
        *((_DWORD *)v15 + 10) = [v62 unsignedIntValue];
        *((_DWORD *)v15 + 12) = [v46 unsignedIntValue];
        *((_DWORD *)v15 + 13) = [v47 unsignedIntValue];
        *((_DWORD *)v15 + 14) = [v57 unsignedIntValue];
        id v19 = v69;
        *((_DWORD *)v15 + 16) = [v69 unsignedIntValue];
        *((_DWORD *)v15 + 2) = 68;

        id v20 = v66;
        goto LABEL_47;
      default:
        GTMTLReplay_handleError( 101,  (uint64_t)"Unreachable",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m",  (uint64_t)"GTShaderDebuggerMakeTraceBuffer",  4779LL,  4LL);
        if (!a2) {
          goto LABEL_20;
        }
        id v26 = @"Error encountered while setting up GPU data buffer";
        goto LABEL_17;
    }
  }

  else
  {
    uint64_t v16 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to create GPU data buffer [%llu]",  v12));
    if (a2)
    {
      id v26 = v16;
LABEL_17:
      Error = GTShaderDebuggerMakeError(1u, v26, 0LL, 0LL, 0LL);
      id v28 = 0LL;
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }

    else
    {
LABEL_20:
      id v28 = 0LL;
    }
  }

  return v28;
}

    uint64_t v47 = *v33;
    uint64_t v48 = v33[4];
    char v49 = *((_BYTE *)v33 + 8);
    uint64_t v50 = *((unsigned __int8 *)v33 + 16);
    __int128 v51 = *((unsigned __int8 *)v33 + 24);
    __int128 v52 = *((_BYTE *)v33 + 40);
    __int128 v53 = *((unsigned __int8 *)v33 + 48);
    __int128 v54 = *((unsigned __int8 *)v33 + 56);
    uint64_t v55 = *((_BYTE *)v33 + 64);
    id v56 = *((_BYTE *)v33 + 72);
    BOOL v57 = v44;
    if (result)
    {
      uint64_t v94 = v44;
      id v98 = v49;
      uint64_t v102 = v46;
      id v106 = v43;
      id v58 = (uint64_t *)GetAliasStream2((uint64_t)result, v47);
      if (v58) {
        uint64_t v47 = *v58;
      }
      else {
        uint64_t v47 = 0LL;
      }
      unint64_t v59 = (uint64_t *)GetAliasStream2(v108, v48);
      if (v59) {
        uint64_t v48 = *v59;
      }
      else {
        uint64_t v48 = 0LL;
      }
      uint64_t result = (void *)v108;
      uint64_t v10 = v88;
      uint64_t v8 = v89;
      unsigned int v43 = v106;
      char v49 = v98;
      BOOL v46 = v102;
      BOOL v57 = v94;
    }

    __dst[90] = v48;
    __dst[91] = v47;
    LOWORD(__dst[92]) = v51;
    WORD1(__dst[92]) = v54;
    WORD2(__dst[92]) = v53;
    HIWORD(__dst[92]) = v50;
    LOBYTE(__dst[93]) = v49;
    BYTE1(__dst[93]) = v55;
    BYTE2(__dst[93]) = v52;
    BYTE3(__dst[93]) = v56;
    BYTE4(__dst[93]) = v43;
    BYTE5(__dst[93]) = v46;
    HIWORD(__dst[93]) = 0;
    __dst[94] = v57;
  }

void GTMTLReplay_handleUnderlyingNSError(void *a1, void *a2)
{
  id v7 = a2;
  id v3 = a1;
  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  [v4 setObject:v3 forKeyedSubscript:NSLocalizedDescriptionKey];

  if (v7) {
    [v4 setObject:v7 forKeyedSubscript:NSUnderlyingErrorKey];
  }
  id NSError = MakeNSError(101, v4);
  id v6 = (id)objc_claimAutoreleasedReturnValue(NSError);
  GTMTLReplay_handleNSError(v6);
}

void *GTMTLReplay_fillError(void *result, int a2, void *a3)
{
  if (result)
  {
    id v3 = result;
    id NSError = MakeNSError(a2, a3);
    uint64_t result = (id)objc_claimAutoreleasedReturnValue(NSError);
    *id v3 = result;
  }

  return result;
}

void GTMTLReplay_handleCommandBufferError(uint64_t a1)
{
  id v1 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"com.apple.gputools.MTLReplayer",  201LL,  a1));
  GTMTLReplay_handleNSError(v1);
}

void HandleCrashSignal(uint64_t a1)
{
  v11[0] = NSLocalizedDescriptionKey;
  uint64_t v2 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", strsignal(a1));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v11[1] = @"GTErrorKeyProcessSignal";
  v12[0] = v3;
  id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  sys_signame[(int)a1]));
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 uppercaseString]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"SIG%@", v5));
  v12[1] = v6;
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  2LL));
  id NSError = MakeNSError(100, v7);
  id v9 = (id)objc_claimAutoreleasedReturnValue(NSError);

  GTMTLReplay_handleNSError(v9);
  sigaction v10 = *(sigaction *)&oldHandlers[2 * (int)a1];
  sigaction(a1, &v10, 0LL);
  if (v10.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&dword_0 + 1))
  {
    if (v10.__sigaction_u.__sa_handler) {
      ((void (*)(uint64_t))v10.__sigaction_u.__sa_handler)(a1);
    }
    else {
      raise(a1);
    }
  }
}

id SerializeMTLTextureDescriptorToDictionary(void *a1)
{
  v19[0] = @"textureType";
  id v1 = a1;
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 textureType]));
  v20[0] = v18;
  v19[1] = @"pixelFormat";
  id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 pixelFormat]));
  v20[1] = v17;
  v19[2] = @"width";
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 width]));
  v20[2] = v16;
  v19[3] = @"height";
  id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 height]));
  v20[3] = v15;
  v19[4] = @"depth";
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 depth]));
  v20[4] = v14;
  v19[5] = @"mipmapLevelCount";
  id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 mipmapLevelCount]));
  v20[5] = v13;
  v19[6] = @"sampleCount";
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 sampleCount]));
  v20[6] = v2;
  v19[7] = @"arrayLength";
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 arrayLength]));
  v20[7] = v3;
  v19[8] = @"cpuCacheMode";
  id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 cpuCacheMode]));
  v20[8] = v4;
  v19[9] = @"storageMode";
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 storageMode]));
  v20[9] = v5;
  v19[10] = @"hazardTrackingMode";
  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 hazardTrackingMode]));
  v20[10] = v6;
  v19[11] = @"allowGPUOptimizedContents";
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  [v1 allowGPUOptimizedContents]));
  v20[11] = v7;
  v19[12] = @"usage";
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v1 usage]));
  v20[12] = v8;
  v19[13] = @"swizzleKey";
  id v9 = [v1 swizzleKey];

  sigaction v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v9));
  v20[13] = v10;
  id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v20,  v19,  14LL));

  return v11;
}

id GTAGXProfilingSupportHelper::RemappedCSV(GTAGXProfilingSupportHelper *this)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfFile:](&OBJC_CLASS___NSData, "dataWithContentsOfFile:", v2));

  return v3;
}

void sub_1252C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

std::string *RemappingCSVPath(std::string *a1)
{
  uint64_t v2 = (std::string *)std::string::basic_string[abi:nn180100]<0>(a1, "/Apple");
  std::string::append(v2, "Internal/");
  std::string::append(a1, "Library/");
  std::string::append(a1, "AGX/");
  std::string::append(a1, "AGXRawCounterMapping");
  return std::string::append(a1, ".csv");
}

void sub_125364(_Unwind_Exception *exception_object)
{
}

void GTAGXProfilingSupportHelper::Initialize(GTAGXProfilingSupportHelper *this, NSDictionary *a2)
{
  unsigned int v118 = this;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( -[GTAGXProfilingSupportHelper objectForKeyedSubscript:]( v118,  "objectForKeyedSubscript:",  @"gpu_gen"));
  int v3 = [v2 unsignedIntValue];

  id v4 = (void *)objc_claimAutoreleasedReturnValue( -[GTAGXProfilingSupportHelper objectForKeyedSubscript:]( v118,  "objectForKeyedSubscript:",  @"num_cores"));
  unsigned int v5 = [v4 unsignedIntValue];

  id v6 = (void *)objc_claimAutoreleasedReturnValue( -[GTAGXProfilingSupportHelper objectForKeyedSubscript:]( v118,  "objectForKeyedSubscript:",  @"num_mgpus"));
  unsigned int v7 = [v6 unsignedIntValue];

  switch(v7)
  {
    case 2u:
      int v8 = 4;
      break;
    case 8u:
      int v8 = 6;
      break;
    case 4u:
      int v8 = 5;
      break;
    default:
      if (v5 <= 6)
      {
        if (v5 <= 1) {
          int v8 = 1;
        }
        else {
          int v8 = 2;
        }
      }

      else
      {
        int v8 = 3;
      }

      break;
  }

  id v9 = (id)objc_claimAutoreleasedReturnValue( -[GTAGXProfilingSupportHelper objectForKeyedSubscript:]( v118,  "objectForKeyedSubscript:",  @"gpu_rev"));
  if ([v9 isEqualToString:@"A0"])
  {
    unsigned int v10 = 1;
  }

  else if ([v9 isEqualToString:@"A1"])
  {
    unsigned int v10 = 2;
  }

  else if ([v9 isEqualToString:@"B0"])
  {
    unsigned int v10 = 3;
  }

  else if ([v9 isEqualToString:@"B1"])
  {
    unsigned int v10 = 4;
  }

  else if ([v9 isEqualToString:@"C0"])
  {
    unsigned int v10 = 5;
  }

  else if ([v9 isEqualToString:@"C1"])
  {
    unsigned int v10 = 6;
  }

  else
  {
    unsigned int v10 = 5;
  }

  id v11 = agxps_gpu_create(v3, v8, v10);
  id v152 = agxps_derived_counter_gpu_descriptor_create(v3, v8, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  agxps_initialize();
  RemappingCSVPath(&v151);
  if ((v151.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    id v12 = &v151;
  }
  else {
    id v12 = (std::string *)v151.__r_.__value_.__r.__words[0];
  }
  agxps_load_counter_obfuscation_map((uint64_t)v12);
  std::string::basic_string[abi:nn180100]<0>(&v153, "MMU Limiter");
  std::string::basic_string[abi:nn180100]<0>(&v153.__end_cap_.__value_, "L2 Cache Limiter");
  std::string::basic_string[abi:nn180100]<0>(v154, "AF Bandwidth");
  uint64_t v13 = 0LL;
  memset(v149, 0, sizeof(v149));
  int v150 = 1065353216;
  do
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>( (uint64_t)v149,  (uint64_t)&v153 + v13,  (uint64_t)&v153 + v13);
    v13 += 24LL;
  }

  while (v13 != 72);
  for (uint64_t i = 0LL; i != -9; i -= 3LL)
  {
    if (SHIBYTE(v154[i + 2]) < 0) {
      operator delete((void *)v154[i]);
    }
  }

  __int128 v146 = 0u;
  *(_OWORD *)__int128 v147 = 0u;
  int v148 = 1065353216;
  __int128 v143 = 0u;
  *(_OWORD *)__int128 v144 = 0u;
  int v145 = 1065353216;
  __int128 v140 = 0u;
  *(_OWORD *)uint64_t v141 = 0u;
  int v142 = 1065353216;
  __int128 v137 = 0u;
  *(_OWORD *)__int128 v138 = 0u;
  int v139 = 1065353216;
  unint64_t v135 = 3735928559LL;
  uint64_t v136 = 1LL;
  int derived_counters = agxps_counter_group_get_derived_counters(v11, "One Pass", &v136, &v135);
  uint64_t v120 = v11;
  if (v3 > 16) {
    goto LABEL_35;
  }
  if (v3 == 16)
  {
    BOOL v17 = v8 != 2 || v10 > 2;
    goto LABEL_47;
  }

  if (v3 != 15) {
    goto LABEL_42;
  }
  if ((v8 - 4) >= 2)
  {
    if (v8 == 6)
    {
LABEL_35:
      char v16 = 1;
      goto LABEL_50;
    }

    if (v8 == 3)
    {
      BOOL v17 = v10 > 4;
      goto LABEL_47;
    }

LABEL_173:
                    if (v125 == v123)
                    {
                      id v99 = (std::string *)*((void *)v122 + 6);
                      if ((unint64_t)v99 >= *((void *)v122 + 7))
                      {
                        std::__split_buffer<std::string>::pointer v100 = std::vector<std::string>::__emplace_back_slow_path<char const*&>(v121, &v128);
                        id v101 = v122;
                      }

                      else
                      {
                        std::string::basic_string[abi:nn180100]<0>(*((void **)v122 + 6), v79);
                        std::__split_buffer<std::string>::pointer v100 = v99 + 1;
                        id v101 = v122;
                        *((void *)v122 + 6) = v99 + 1;
                      }

                      *((void *)v101 + 6) = v100;
                    }
                  }
                }
              }
            }
          }

          if (v129.i64[0] != v129.i64[1]) {
            std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_impl<char const*&,std::vector<std::string>>( (uint64_t *)&xmmword_5B96B0 + 1,  v44,  (uint64_t)&v129);
          }
          v153.__first_ = (std::__split_buffer<std::string>::pointer)&v129;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v153);
          int v37 = v120;
        }
      }
    }

    uint64_t v40 = v119 + 1;
  }

  while (v119 != 2);
  uint64_t v102 = *(void ***)v138;
  if (*(void *)v138)
  {
    while (1)
    {
      BOOL v103 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>( v146,  *((unint64_t *)&v146 + 1),  (uint64_t)(v102 + 2));
      uint64_t v104 = (void **)*v102;
      if (v103) {
        break;
      }
LABEL_213:
      uint64_t v102 = v104;
      if (!v104) {
        goto LABEL_214;
      }
    }

    unint64_t v105 = *((void *)&v137 + 1);
    unint64_t v106 = (unint64_t)v102[1];
    uint8x8_t v107 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v137 + 8));
    v107.i16[0] = vaddlv_u8(v107);
    if (v107.u32[0] > 1uLL)
    {
      if (v106 >= *((void *)&v137 + 1)) {
        v106 %= *((void *)&v137 + 1);
      }
    }

    else
    {
      v106 &= *((void *)&v137 + 1) - 1LL;
    }

    uint64_t v108 = *(int **)(v137 + 8 * v106);
    do
    {
      uint64_t v109 = v108;
      uint64_t v108 = *(int **)v108;
    }

    while (v108 != (int *)v102);
    if (v109 == v138) {
      goto LABEL_231;
    }
    unint64_t v110 = *((void *)v109 + 1);
    if (v107.u32[0] > 1uLL)
    {
      if (v110 >= *((void *)&v137 + 1)) {
        v110 %= *((void *)&v137 + 1);
      }
    }

    else
    {
      v110 &= *((void *)&v137 + 1) - 1LL;
    }

    __int128 v111 = *v102;
    if (v110 != v106)
    {
LABEL_231:
      if (v104)
      {
        unint64_t v112 = (unint64_t)v104[1];
        if (v107.u32[0] > 1uLL)
        {
          if (v112 >= *((void *)&v137 + 1)) {
            v112 %= *((void *)&v137 + 1);
          }
        }

        else
        {
          v112 &= *((void *)&v137 + 1) - 1LL;
        }

        __int128 v111 = *v102;
        if (v112 == v106) {
          goto LABEL_206;
        }
      }

      *(void *)(v137 + 8 * v106) = 0LL;
      __int128 v111 = *v102;
    }

    if (!v111)
    {
LABEL_212:
      *(void *)uint64_t v109 = v111;
      unsigned int *v102 = 0LL;
      --*(void *)&v138[2];
      std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100]( 1,  v102);
      goto LABEL_213;
    }

              unsigned __int8 v84 = v85 - 1;
              if (!v85)
              {
                uint64_t v115 = v10 / 0x18uLL;
                while (1)
                {
                  unint64_t v116 = 0LL;
                  __int128 v117 = *(_DWORD *)i;
                  unsigned int v118 = *(void *)(i + 8);
                  uint64_t v119 = *(void *)(i + 16);
                  uint64_t v120 = v115 - 2;
                  if (v115 < 2) {
                    uint64_t v120 = v115 - 1;
                  }
                  uint64_t v121 = v120 >> 1;
                  uint64_t v122 = i;
                  do
                  {
                    uint64_t result = v122;
                    v122 += 24 * v116 + 24;
                    uint64_t v123 = 2 * v116;
                    unint64_t v116 = (2 * v116) | 1;
                    uint64_t v124 = v123 + 2;
                    if (v124 < v115)
                    {
                      uint64_t v125 = *(_DWORD *)(v122 + 24);
                      if (*(_DWORD *)v122 < v125
                        || v125 >= *(_DWORD *)v122
                        && ((uint64_t v126 = *(void *)(v122 + 8), v127 = *(void *)(v122 + 32), v126 < v127)
                         || v127 >= v126 && *(void *)(v122 + 16) < *(void *)(v122 + 40)))
                      {
                        v122 += 24LL;
                        unint64_t v116 = v124;
                      }
                    }

                    *(_DWORD *)uint64_t result = *(_DWORD *)v122;
                    *(_OWORD *)(result + 8) = *(_OWORD *)(v122 + 8);
                  }

                  while (v116 <= v121);
                  if (v122 == a2 - 24)
                  {
                    *(_DWORD *)uint64_t v122 = v117;
                    *(void *)(v122 + 8) = v118;
                    *(void *)(v122 + 16) = v119;
                    goto LABEL_236;
                  }

                  *(_DWORD *)uint64_t v122 = *(_DWORD *)(a2 - 24);
                  *(_OWORD *)(v122 + 8) = *(_OWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 24) = v117;
                  *(void *)(a2 - 16) = v118;
                  *(void *)(a2 - 8) = v119;
                  uint64_t v128 = v122 - i + 24;
                  if (v128 < 25) {
                    goto LABEL_236;
                  }
                  int64x2_t v129 = 0xAAAAAAAAAAAAAAABLL * (v128 >> 3) - 2;
                  uint64_t v130 = v129 >> 1;
                  unint64_t v131 = i + 24 * (v129 >> 1);
                  uint64_t v132 = *(_DWORD *)v131;
                  __int128 v133 = *(_DWORD *)v122;
                  if (*(_DWORD *)v131 >= *(_DWORD *)v122)
                  {
                    if (v133 < v132) {
                      goto LABEL_236;
                    }
                    unint64_t v135 = *(void *)(v131 + 8);
                    int v134 = *(void *)(v122 + 8);
                    if (v135 >= v134)
                    {
                      if (v134 < v135) {
                        goto LABEL_236;
                      }
                      uint64_t result = *(void *)(v131 + 16);
                      if (result >= *(void *)(v122 + 16)) {
                        goto LABEL_236;
                      }
                    }
                  }

                  else
                  {
                    int v134 = *(void *)(v122 + 8);
                    unint64_t v135 = *(void *)(v131 + 8);
                  }

                  uint64_t result = *(void *)(v122 + 16);
                  *(_DWORD *)uint64_t v122 = v132;
                  uint64_t v136 = *(void *)(v131 + 16);
                  *(void *)(v122 + 8) = v135;
                  *(void *)(v122 + 16) = v136;
                  if (v129 < 2) {
                    goto LABEL_235;
                  }
                  while (1)
                  {
                    __int128 v137 = v131;
                    __int128 v138 = v130 - 1;
                    uint64_t v130 = (v130 - 1) >> 1;
                    unint64_t v131 = i + 24 * v130;
                    int v139 = *(_DWORD *)v131;
                    if (*(_DWORD *)v131 >= v133) {
                      break;
                    }
                    __int128 v140 = *(void *)(v131 + 8);
LABEL_232:
                    *(_DWORD *)__int128 v137 = v139;
                    uint64_t v141 = *(void *)(v131 + 16);
                    *(void *)(v137 + 8) = v140;
                    *(void *)(v137 + 16) = v141;
                    if (v138 <= 1) {
                      goto LABEL_235;
                    }
                  }

                  if (v133 >= v139)
                  {
                    __int128 v140 = *(void *)(v131 + 8);
                    if (v140 < v134 || v134 >= v140 && *(void *)(v131 + 16) < result) {
                      goto LABEL_232;
                    }
                  }

                  unint64_t v131 = v137;
LABEL_235:
                  *(_DWORD *)unint64_t v131 = v133;
                  *(void *)(v131 + 8) = v134;
                  *(void *)(v131 + 16) = result;
LABEL_236:
                  a2 -= 24LL;
                  if (v115-- <= 2) {
                    return result;
                  }
                }
              }
            }
          }

          id v12 = (unint64_t)v11 >> 1;
          uint64_t v13 = i + 24 * ((unint64_t)v11 >> 1);
          if ((unint64_t)v10 < 0xC01)
          {
            uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)(v7 + 24 * v12),  (int *)v7,  (int *)(a2 - 24));
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)v7,  (int *)(v7 + 24 * v12),  (int *)(a2 - 24));
            id v14 = 3 * v12;
            id v15 = (int *)(v7 + 24 * v12 - 24);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)(v7 + 24),  v15,  (int *)(a2 - 48));
            char v16 = (int *)(v7 + 24 + 8 * v14);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)(v7 + 48),  v16,  (int *)(a2 - 72));
            uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( v15,  (int *)v13,  v16);
            BOOL v17 = *(_DWORD *)v7;
            *(_DWORD *)unsigned int v7 = *(_DWORD *)v13;
            *(_DWORD *)uint64_t v13 = v17;
            int v18 = *(_OWORD *)(v7 + 8);
            *(_OWORD *)(v7 + 8) = *(_OWORD *)(v13 + 8);
            *(_OWORD *)(v13 + 8) = v18;
          }

          --a3;
          uint64_t v19 = *(_DWORD *)v7;
          if ((a4 & 1) == 0)
          {
            id v20 = *(_DWORD *)(v7 - 24);
            if (v20 >= v19)
            {
              if (v19 < v20)
              {
                uint64_t v22 = *(void *)(v7 + 8);
              }

              else
              {
                uint64_t v21 = *(void *)(v7 - 16);
                uint64_t v22 = *(void *)(v7 + 8);
                if (v21 < v22 || v22 >= v21 && *(void *)(v7 - 8) < *(void *)(v7 + 16)) {
                  goto LABEL_15;
                }
              }

              id v44 = *(void *)(v7 + 16);
              int v45 = *v8;
              if (v19 < *v8
                || v45 >= v19 && ((id v60 = *(void *)(a2 - 16), v22 < v60) || v60 >= v22 && v44 < *(void *)(a2 - 8)))
              {
                uint64_t i = v7;
                while (1)
                {
                  uint64_t v47 = *(_DWORD *)(i + 24);
                  i += 24LL;
                  BOOL v46 = v47;
                  if (v19 < v47) {
                    break;
                  }
                  if (v46 >= v19)
                  {
                    uint64_t v48 = *(void *)(i + 8);
                    if (v22 < v48 || v48 >= v22 && v44 < *(void *)(i + 16)) {
                      break;
                    }
                  }
                }
              }

              else
              {
                for (uint64_t i = v7 + 24; i < a2; i += 24LL)
                {
                  if (v19 < *(_DWORD *)i) {
                    break;
                  }
                  if (*(_DWORD *)i >= v19)
                  {
                    unint64_t v59 = *(void *)(i + 8);
                    if (v22 < v59 || v59 >= v22 && v44 < *(void *)(i + 16)) {
                      break;
                    }
                  }
                }
              }

              unint64_t j = a2;
              if (i < a2)
              {
                for (unint64_t j = a2 - 24; ; j -= 24LL)
                {
                  if (v19 >= v45)
                  {
                    if (v45 < v19) {
                      break;
                    }
                    uint64_t v50 = *(void *)(j + 8);
                    if (v22 >= v50 && (v50 < v22 || v44 >= *(void *)(j + 16))) {
                      break;
                    }
                  }

                  __int128 v51 = *(_DWORD *)(j - 24);
                  int v45 = v51;
                }
              }

              if (i < j)
              {
                int64x2_t v52 = *(_DWORD *)i;
                __int128 v53 = *(_DWORD *)j;
                do
                {
                  *(_DWORD *)uint64_t i = v53;
                  *(_DWORD *)unint64_t j = v52;
                  __int128 v54 = *(_OWORD *)(i + 8);
                  *(_OWORD *)(i + 8) = *(_OWORD *)(j + 8);
                  *(_OWORD *)(j + 8) = v54;
                  while (1)
                  {
                    uint64_t v55 = *(_DWORD *)(i + 24);
                    i += 24LL;
                    int64x2_t v52 = v55;
                    if (v19 < v55) {
                      break;
                    }
                    if (v52 >= v19)
                    {
                      id v56 = *(void *)(i + 8);
                      if (v22 < v56 || v56 >= v22 && v44 < *(void *)(i + 16)) {
                        break;
                      }
                    }
                  }

                  do
                  {
                    do
                    {
                      BOOL v57 = *(_DWORD *)(j - 24);
                      j -= 24LL;
                      __int128 v53 = v57;
                    }

                    while (v19 < v57);
                    if (v53 < v19) {
                      break;
                    }
                    unsigned __int8 v58 = *(void *)(j + 8);
                  }

                  while (v22 < v58 || v58 >= v22 && v44 < *(void *)(j + 16));
                }

                while (i < j);
              }

              if (i - 24 != v7)
              {
                *(_DWORD *)unsigned int v7 = *(_DWORD *)(i - 24);
                *(_OWORD *)(v7 + 8) = *(_OWORD *)(i - 16);
              }

              a4 = 0;
              *(_DWORD *)(i - 24) = v19;
              *(void *)(i - 16) = v22;
              *(void *)(i - 8) = v44;
              continue;
            }
          }

LABEL_206:
    unint64_t v113 = v111[1];
    if (v107.u32[0] > 1uLL)
    {
      if (v113 >= v105) {
        v113 %= v105;
      }
    }

    else
    {
      v113 &= v105 - 1;
    }

    if (v113 != v106)
    {
      *(void *)(v137 + 8 * v113) = v109;
      __int128 v111 = *v102;
    }

    goto LABEL_212;
  }

        unint64_t v35 = *((void *)&v178 + 1);
        unint64_t v112 = *(void *)(*(void *)(*find_entry((uint64_t)v195[1], (_BYTE *)&v178 + 8, 8uLL, 0LL) + 32LL) + 8LL);
        unint64_t v113 = *v38;
        unint64_t v114 = v151;
        uint64_t v115 = (v151 - v156) >> 5;
        if ((unint64_t)v151 >= v147)
        {
          uint64_t v120 = v115 + 1;
          else {
            __int128 v117 = v120;
          }
          if (v117) {
            __int128 v117 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v117);
          }
          else {
            unsigned int v118 = 0LL;
          }
          uint64_t v121 = (void *)(v117 + 32 * v115);
          *uint64_t v121 = v35;
          v121[1] = v112;
          v121[2] = v113;
          v121[3] = v115;
          uint64_t v122 = v156;
          uint64_t v126 = v151;
          if (v151 != v156)
          {
            uint64_t v127 = v117 + 32 * v115;
            do
            {
              uint64_t v128 = *((_OWORD *)v126 - 1);
              uint64_t v19 = (char *)(v127 - 32);
              *(_OWORD *)(v127 - 32) = *((_OWORD *)v126 - 2);
              *(_OWORD *)(v127 - 16) = v128;
              v126 -= 32;
              v127 -= 32LL;
            }

            while (v126 != v156);
LABEL_228:
            __int128 v147 = v117 + 32 * v118;
            std::string v151 = (char *)(v121 + 4);
            if (v122) {
              operator delete(v122);
            }
LABEL_230:
            id v15 = v145;
            goto LABEL_231;
          }

                a2 = v114 - 3;
              }

              while (v113-- > 2);
            }

            return result;
          }

          id v14 = (unint64_t)v13 >> 1;
          id v15 = (unint64_t *)(v7 + 24 * ((unint64_t)v13 >> 1));
          if ((unint64_t)v12 < 0xC01)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( (uint64_t)v15,  v7,  (uint64_t)v8);
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( v7,  (uint64_t)v15,  (uint64_t)v8);
            char v16 = 3 * v14;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( v7 + 24,  v7 + 8 * v16 - 24,  v9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( v7 + 48,  v7 + 24 + 8 * v16,  v10);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( v7 + 8 * v16 - 24,  (uint64_t)v15,  v7 + 24 + 8 * v16);
            BOOL v17 = *(void *)v7;
            *(void *)unsigned int v7 = *v15;
            *id v15 = v17;
            int v18 = *(void *)(v7 + 8);
            *(void *)(v7 + 8) = v15[1];
            v15[1] = v18;
            uint64_t v19 = *(void *)(v7 + 16);
            *(void *)(v7 + 16) = v15[2];
            v15[2] = v19;
          }

          --a3;
          a2 = (unint64_t *)v156;
          if ((a4 & 1) == 0)
          {
            uint64_t result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>( v7 - 24,  v7);
            if ((result & 1) == 0)
            {
              uint64_t v49 = *(void *)v7;
              uint64_t v50 = *(_DWORD *)(v7 + 8);
              __int128 v51 = *(_DWORD *)(v7 + 12);
              int64x2_t v52 = *(void *)(v7 + 16);
              __int128 v53 = *v8;
              if (*(void *)v7 < *v8
                || v53 >= v49
                && ((BOOL v76 = *(_DWORD *)(v156 - 16), v50 < v76)
                 || v76 >= v50
                 && ((__int128 v77 = *(_DWORD *)(v156 - 12), v51 < v77) || v77 >= v51 && v52 < *(void *)(v156 - 8))))
              {
                uint64_t i = v7;
                while (1)
                {
                  uint64_t v55 = *(void *)(i + 24);
                  i += 24LL;
                  __int128 v54 = v55;
                  if (v49 < v55) {
                    break;
                  }
                  if (v54 >= v49)
                  {
                    id v56 = *(_DWORD *)(i + 8);
                    if (v50 < v56) {
                      break;
                    }
                    if (v56 >= v50)
                    {
                      BOOL v57 = *(_DWORD *)(i + 12);
                      if (v51 < v57 || v57 >= v51 && v52 < *(void *)(i + 16)) {
                        break;
                      }
                    }
                  }
                }
              }

              else
              {
                for (uint64_t i = v7 + 24; i < v156; i += 24LL)
                {
                  if (v49 < *(void *)i) {
                    break;
                  }
                  if (*(void *)i >= v49)
                  {
                    __int128 v74 = *(_DWORD *)(i + 8);
                    if (v50 < v74) {
                      break;
                    }
                    if (v74 >= v50)
                    {
                      BOOL v75 = *(_DWORD *)(i + 12);
                      if (v51 < v75 || v75 >= v51 && v52 < *(void *)(i + 16)) {
                        break;
                      }
                    }
                  }
                }
              }

              unint64_t j = (void *)v156;
              if (i < v156)
              {
                for (unint64_t j = v8; ; j -= 3)
                {
                  if (v49 >= v53)
                  {
                    if (v53 < v49) {
                      break;
                    }
                    unint64_t v59 = *((_DWORD *)j + 2);
                    if (v50 >= v59)
                    {
                      if (v59 < v50) {
                        break;
                      }
                      id v60 = *((_DWORD *)j + 3);
                      if (v51 >= v60 && (v60 < v51 || v52 >= j[2])) {
                        break;
                      }
                    }
                  }

                  uint64_t v61 = *(j - 3);
                  __int128 v53 = v61;
                }
              }

              if (i < (unint64_t)j)
              {
                unsigned __int8 v62 = *(void *)i;
                id v63 = *j;
                do
                {
                  *(void *)uint64_t i = v63;
                  void *j = v62;
                  uint64_t v64 = *(void *)(i + 16);
                  *(void *)(i + 16) = j[2];
                  j[2] = v64;
                  std::__split_buffer<std::string>::pointer v65 = *(void *)(i + 24);
                  i += 24LL;
                  unsigned __int8 v62 = v65;
                  int v66 = *(_DWORD *)(i - 16);
                  *(_DWORD *)(i - 16) = *((_DWORD *)j + 2);
                  *((_DWORD *)j + 2) = v66;
                  __int128 v67 = *(_DWORD *)(i - 12);
                  *(_DWORD *)(i - 12) = *((_DWORD *)j + 3);
                  *((_DWORD *)j + 3) = v67;
                  while (v49 >= v62)
                  {
                    if (v62 >= v49)
                    {
                      uint64_t v68 = *(_DWORD *)(i + 8);
                      if (v50 < v68) {
                        break;
                      }
                      if (v68 >= v50)
                      {
                        __int128 v69 = *(_DWORD *)(i + 12);
                        if (v51 < v69 || v69 >= v51 && v52 < *(void *)(i + 16)) {
                          break;
                        }
                      }
                    }

                    int v70 = *(void *)(i + 24);
                    i += 24LL;
                    unsigned __int8 v62 = v70;
                  }

                  while (1)
                  {
                    do
                    {
                      int v71 = *(j - 3);
                      j -= 3;
                      id v63 = v71;
                    }

                    while (v49 < v71);
                    if (v63 < v49) {
                      break;
                    }
                    int v72 = *((_DWORD *)j + 2);
                    if (v50 >= v72)
                    {
                      if (v72 < v50) {
                        break;
                      }
                      int v73 = *((_DWORD *)j + 3);
                      if (v51 >= v73 && (v73 < v51 || v52 >= j[2])) {
                        break;
                      }
                    }
                  }
                }

                while (i < (unint64_t)j);
              }

              if (i - 24 != v7)
              {
                *(void *)unsigned int v7 = *(void *)(i - 24);
                *(_DWORD *)(v7 + 8) = *(_DWORD *)(i - 16);
                *(_DWORD *)(v7 + 12) = *(_DWORD *)(i - 12);
                *(void *)(v7 + 16) = *(void *)(i - 8);
              }

              a4 = 0;
              *(void *)(i - 24) = v49;
              *(_DWORD *)(i - 16) = v50;
              *(_DWORD *)(i - 12) = v51;
              *(void *)(i - 8) = v52;
              continue;
            }
          }

          id v20 = *(void *)v7;
          uint64_t v21 = *(_DWORD *)(v7 + 8);
          uint64_t v22 = *(_DWORD *)(v7 + 12);
          uint64_t v23 = v7 + 24;
          __int128 v24 = *(void *)(v7 + 16);
          while (1)
          {
            unsigned __int8 v25 = *(void *)v23;
            if (*(void *)v23 >= v20)
            {
              if (v20 < v25) {
                break;
              }
              id v26 = *(_DWORD *)(v23 + 8);
              if (v26 >= v21)
              {
                if (v21 < v26) {
                  break;
                }
                uint64_t v27 = *(_DWORD *)(v23 + 12);
                if (v27 >= v22 && (v22 < v27 || *(void *)(v23 + 16) >= v24)) {
                  break;
                }
              }
            }

            v23 += 24LL;
          }

          if (v23 - 24 == v7)
          {
            unint64_t k = (void *)v156;
            if (v23 < v156)
            {
              uint64_t v33 = *v8;
              unint64_t k = v8;
              if (*v8 >= v20)
              {
                unint64_t k = v8;
                do
                {
                  if (v20 >= v33)
                  {
                    unsigned __int8 v34 = *((_DWORD *)k + 2);
                    if (v34 < v21) {
                      break;
                    }
                    if (v21 >= v34)
                    {
                      unint64_t v35 = *((_DWORD *)k + 3);
                      if (v35 < v22 || v22 >= v35 && k[2] < v24) {
                        break;
                      }
                    }
                  }

                  id v36 = *(k - 3);
                  k -= 3;
                  uint64_t v33 = v36;
                }

                while (v36 >= v20);
              }
            }
          }

          else
          {
            unsigned __int8 v28 = *v8;
            for (unint64_t k = v8; v28 >= v20; k -= 3)
            {
              if (v20 >= v28)
              {
                char v30 = *((_DWORD *)k + 2);
                if (v30 < v21) {
                  break;
                }
                if (v21 >= v30)
                {
                  uint64_t v31 = *((_DWORD *)k + 3);
                  if (v31 < v22 || v22 >= v31 && k[2] < v24) {
                    break;
                  }
                }
              }

              std::__split_buffer<std::string>::pointer v32 = *(k - 3);
              unsigned __int8 v28 = v32;
            }
          }

          uint64_t i = v23;
          if (v23 < (unint64_t)k)
          {
            int v37 = *k;
            uint64_t i = v23;
            unint64_t v38 = (unint64_t)k;
            do
            {
              *(void *)uint64_t i = v37;
              *(void *)unint64_t v38 = v25;
              uint64_t v39 = *(_DWORD *)(i + 8);
              *(_DWORD *)(i + 8) = *(_DWORD *)(v38 + 8);
              *(_DWORD *)(v38 + 8) = v39;
              uint64_t v40 = *(_DWORD *)(i + 12);
              *(_DWORD *)(i + 12) = *(_DWORD *)(v38 + 12);
              *(_DWORD *)(v38 + 12) = v40;
              int v41 = *(void *)(i + 16);
              *(void *)(i + 16) = *(void *)(v38 + 16);
              *(void *)(v38 + 16) = v41;
              while (1)
              {
                do
                {
                  int v42 = *(void *)(i + 24);
                  i += 24LL;
                  unsigned __int8 v25 = v42;
                }

                while (v42 < v20);
                if (v20 < v25) {
                  break;
                }
                unsigned int v43 = *(_DWORD *)(i + 8);
                if (v43 >= v21)
                {
                  if (v21 < v43) {
                    break;
                  }
                  id v44 = *(_DWORD *)(i + 12);
                  if (v44 >= v22 && (v22 < v44 || *(void *)(i + 16) >= v24)) {
                    break;
                  }
                }
              }

              while (1)
              {
                int v45 = *(void *)(v38 - 24);
                v38 -= 24LL;
                int v37 = v45;
                if (v45 < v20) {
                  break;
                }
                if (v20 >= v37)
                {
                  BOOL v46 = *(_DWORD *)(v38 + 8);
                  if (v46 < v21) {
                    break;
                  }
                  if (v21 >= v46)
                  {
                    uint64_t v47 = *(_DWORD *)(v38 + 12);
                    if (v47 < v22 || v22 >= v47 && *(void *)(v38 + 16) < v24) {
                      break;
                    }
                  }
                }
              }
            }

            while (i < v38);
          }

          if (i - 24 != v7)
          {
            *(void *)unsigned int v7 = *(void *)(i - 24);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(i - 16);
            *(_DWORD *)(v7 + 12) = *(_DWORD *)(i - 12);
            *(void *)(v7 + 16) = *(void *)(i - 8);
          }

          *(void *)(i - 24) = v20;
          *(_DWORD *)(i - 16) = v21;
          *(_DWORD *)(i - 12) = v22;
          *(void *)(i - 8) = v24;
          if (v23 < (unint64_t)k)
          {
LABEL_64:
            uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *,false>( v7,  i - 24,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          uint64_t v48 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( v7,  i - 24);
          uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long> *>( i,  v156);
          if (!(_DWORD)result)
          {
            if (v48) {
              continue;
            }
            goto LABEL_64;
          }

          a2 = (unint64_t *)(i - 24);
          if (v48) {
            return result;
          }
          goto LABEL_2;
        }

        char v80 = v7 + 24;
        __int128 v82 = (unint64_t *)v7 == a2 || v80 == (void)a2;
        if ((a4 & 1) == 0)
        {
          if (!v82)
          {
            do
            {
              uint64_t v136 = (unint64_t *)v80;
              uint64_t result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>( v80,  v7);
              if ((_DWORD)result)
              {
                __int128 v137 = *v136;
                __int128 v138 = *(_DWORD *)(v7 + 32);
                int v139 = *(_DWORD *)(v7 + 36);
                __int128 v140 = *(void *)(v7 + 40);
                uint64_t v141 = *(void *)v7;
                while (1)
                {
                  do
                  {
                    int v142 = v7;
                    __int128 v143 = v141;
                    __int128 v144 = *(void *)(v7 - 24);
                    v7 -= 24LL;
                    uint64_t v141 = v144;
                    *(void *)(v7 + 48) = v143;
                    int v145 = *(_DWORD *)(v7 + 36);
                    *(_DWORD *)(v7 + 56) = *(_DWORD *)(v7 + 32);
                    *(_DWORD *)(v7 + 60) = v145;
                    *(void *)(v7 + 64) = *(void *)(v7 + 40);
                  }

                  while (v137 < v144);
                  if (v141 < v137) {
                    break;
                  }
                  __int128 v146 = *(_DWORD *)(v142 - 16);
                  if (v138 >= v146)
                  {
                    if (v146 < v138) {
                      break;
                    }
                    __int128 v147 = *(_DWORD *)(v142 - 12);
                    if (v139 >= v147 && (v147 < v139 || v140 >= *(void *)(v142 - 8))) {
                      break;
                    }
                  }
                }

                *(void *)int v142 = v137;
                *(_DWORD *)(v142 + 8) = v138;
                *(_DWORD *)(v142 + 12) = v139;
                *(void *)(v142 + 16) = v140;
              }

              char v80 = (uint64_t)(v136 + 3);
              unsigned int v7 = (uint64_t)v136;
            }

            while (v136 + 3 != a2);
          }

          return result;
        }

        if (v82) {
          return result;
        }
        id v83 = 0LL;
        unsigned __int8 v84 = v7;
        do
        {
          uint64_t v85 = v80;
          uint64_t result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>,std::tuple<unsigned long long,unsigned int,unsigned int,unsigned long long>>( v80,  v84);
          if (!(_DWORD)result) {
            goto LABEL_155;
          }
          unint64_t v86 = *(_DWORD *)(v84 + 32);
          unint64_t v87 = *(_DWORD *)(v84 + 36);
          unint64_t v88 = *(void *)(v84 + 40);
          unint64_t v90 = *(void *)(v84 + 16);
          uint64_t v89 = *(void *)(v84 + 24);
          *(void *)(v84 + 24) = *(void *)v84;
          *(_DWORD *)(v85 + 8) = *(_DWORD *)(v84 + 8);
          *(_DWORD *)(v85 + 12) = *(_DWORD *)(v84 + 12);
          *(void *)(v85 + 16) = v90;
          __int128 v91 = v7;
          if (v84 == v7) {
            goto LABEL_154;
          }
          uint64_t v92 = v83;
          while (1)
          {
            uint64_t v93 = *(void *)(v7 + v92 - 24);
            if (v89 < v93)
            {
              unint64_t v94 = *(_DWORD *)(v7 + v92 - 16);
              goto LABEL_151;
            }

            if (v93 < v89) {
              goto LABEL_153;
            }
            unint64_t v94 = *(_DWORD *)(v7 + v92 - 16);
            if (v86 >= v94)
            {
              if (v94 < v86) {
                goto LABEL_153;
              }
              __int128 v95 = *(_DWORD *)(v7 + v92 - 12);
              if (v87 >= v95) {
                break;
              }
            }

LABEL_214:
  if (*(void *)v141)
  {
    unint64_t v114 = 0LL;
    uint64_t v115 = *(void **)v141;
    do
    {
      ++v114;
      uint64_t v115 = (void *)*v115;
    }

    while (v115);
  }

  else
  {
    unint64_t v114 = 0LL;
  }

  std::vector<std::string>::__assign_with_size[abi:nn180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>( &qword_5B96F8,  *(void **)v141,  v114);
  if (*(void *)v138)
  {
    unint64_t v116 = 0LL;
    __int128 v117 = *(void **)v138;
    do
    {
      ++v116;
      __int128 v117 = (void *)*v117;
    }

    while (v117);
  }

  else
  {
    unint64_t v116 = 0LL;
  }

  std::vector<std::string>::__assign_with_size[abi:nn180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>( (uint64_t *)&xmmword_5B9710,  *(void **)v138,  v116);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v133);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v137);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v140);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v143);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v146);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v149);
}

void sub_126264( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_impl<char const*&,std::vector<std::string>>( uint64_t *a1, char *a2, uint64_t a3)
{
  id v6 = a1 + 2;
  unsigned int v7 = (char *)operator new(0x40uLL);
  v44[0] = v7;
  v44[1] = v6;
  char v45 = 0;
  *(void *)unsigned int v7 = 0LL;
  *((void *)v7 + 1) = 0LL;
  std::string::basic_string[abi:nn180100]<0>((void *)v7 + 2, a2);
  *(_OWORD *)(v7 + 40) = *(_OWORD *)a3;
  *((void *)v7 + 7) = *(void *)(a3 + 16);
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  *(void *)a3 = 0LL;
  char v45 = 1;
  int v8 = v7[39];
  if (v8 >= 0) {
    id v9 = (uint64_t *)(v7 + 16);
  }
  else {
    id v9 = (uint64_t *)*((void *)v7 + 2);
  }
  if (v8 >= 0) {
    unint64_t v10 = v7[39];
  }
  else {
    unint64_t v10 = *((void *)v7 + 3);
  }
  *((void *)v7 + 1) = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v9, v10);
  unint64_t v11 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v9, v10);
  *((void *)v7 + 1) = v11;
  unint64_t v12 = a1[1];
  if (!v12) {
    goto LABEL_23;
  }
  unint64_t v13 = v11;
  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
  v14.i16[0] = vaddlv_u8(v14);
  unint64_t v15 = v14.u32[0];
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v16 = v11;
    if (v12 <= v11) {
      unint64_t v16 = v11 % v12;
    }
  }

  else
  {
    unint64_t v16 = (v12 - 1) & v11;
  }

  BOOL v17 = *(void ***)(*a1 + 8 * v16);
  if (!v17 || (int v18 = (char *)*v17) == 0LL)
  {
LABEL_23:
    float v20 = (float)(unint64_t)(a1[3] + 1);
    float v21 = *((float *)a1 + 8);
    if (!v12 || (float)(v21 * (float)v12) < v20)
    {
      BOOL v22 = 1LL;
      if (v12 >= 3) {
        BOOL v22 = (v12 & (v12 - 1)) != 0;
      }
      unint64_t v23 = v22 | (2 * v12);
      unint64_t v24 = vcvtps_u32_f32(v20 / v21);
      if (v23 <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      else {
        int8x8_t prime = (int8x8_t)v23;
      }
      if (*(void *)&prime == 1LL)
      {
        int8x8_t prime = (int8x8_t)2LL;
      }

      else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v12 = a1[1];
      }

      if (*(void *)&prime > v12) {
        goto LABEL_91;
      }
      if (*(void *)&prime >= v12) {
        goto LABEL_64;
      }
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }

      else
      {
        uint64_t v34 = 1LL << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }

      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = a1[1];
        goto LABEL_64;
      }

      if (prime)
      {
LABEL_91:
        if (*(void *)&prime >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        id v26 = operator new(8LL * *(void *)&prime);
        uint64_t v27 = (void *)*a1;
        *a1 = (uint64_t)v26;
        if (v27) {
          operator delete(v27);
        }
        uint64_t v28 = 0LL;
        a1[1] = (uint64_t)prime;
        do
          *(void *)(*a1 + 8 * v28++) = 0LL;
        while (*(void *)&prime != v28);
        uint64_t v29 = (void *)*v6;
        if (*v6)
        {
          unint64_t v30 = v29[1];
          uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
          v31.i16[0] = vaddlv_u8(v31);
          if (v31.u32[0] > 1uLL)
          {
            if (v30 >= *(void *)&prime) {
              v30 %= *(void *)&prime;
            }
          }

          else
          {
            v30 &= *(void *)&prime - 1LL;
          }

          *(void *)(*a1 + 8 * v30) = v6;
          unint64_t v35 = (void *)*v29;
          if (*v29)
          {
            do
            {
              unint64_t v36 = v35[1];
              if (v31.u32[0] > 1uLL)
              {
                if (v36 >= *(void *)&prime) {
                  v36 %= *(void *)&prime;
                }
              }

              else
              {
                v36 &= *(void *)&prime - 1LL;
              }

              if (v36 != v30)
              {
                if (!*(void *)(*a1 + 8 * v36))
                {
                  *(void *)(*a1 + 8 * v36) = v29;
                  goto LABEL_60;
                }

                *uint64_t v29 = *v35;
                *unint64_t v35 = **(void **)(*a1 + 8 * v36);
                **(void **)(*a1 + 8 * v36) = v35;
                unint64_t v35 = v29;
              }

              unint64_t v36 = v30;
LABEL_60:
              uint64_t v29 = v35;
              unint64_t v35 = (void *)*v35;
              unint64_t v30 = v36;
            }

            while (v35);
          }
        }

        unint64_t v12 = (unint64_t)prime;
      }

      else
      {
        unsigned int v43 = (void *)*a1;
        *a1 = 0LL;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v12 = 0LL;
        a1[1] = 0LL;
      }
    }

void sub_12696C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    int v8 = (uint64_t *)a2;
  }
  else {
    int v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }

    unint64_t v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
        }

        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }

          else
          {
            v17 &= v12 - 1;
          }

          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }

  int v18 = operator new(0x28uLL);
  *int v18 = 0LL;
  v18[1] = v11;
  *((_OWORD *)v18 + 1) = *(_OWORD *)a3;
  v18[4] = *(void *)(a3 + 16);
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v20 = *(float *)(a1 + 32);
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    BOOL v21 = 1LL;
    if (v12 >= 3) {
      BOOL v21 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v12);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v24);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }

  uint64_t v25 = *(void *)a1;
  id v26 = *(void **)(*(void *)a1 + 8 * v3);
  if (v26)
  {
    *int v18 = *v26;
LABEL_44:
    void *v26 = v18;
    goto LABEL_45;
  }

  *int v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v25 + 8 * v3) = a1 + 16;
  if (*v18)
  {
    unint64_t v27 = *(void *)(*v18 + 8LL);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v27 >= v12) {
        v27 %= v12;
      }
    }

    else
    {
      v27 &= v12 - 1;
    }

    id v26 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_44;
  }

void sub_126BBC(_Unwind_Exception *a1)
{
}

std::__split_buffer<std::string>::pointer std::vector<std::string>::__emplace_back_slow_path<char const*&>( std::__split_buffer<std::string>::pointer *a1, char **a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((char *)a1[1] - (char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  id v6 = (std::allocator<std::string> *)(a1 + 2);
  else {
    unint64_t v7 = v3;
  }
  v18.__end_cap_.__value_ = v6;
  if (v7) {
    unint64_t v7 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v7);
  }
  else {
    uint64_t v8 = 0LL;
  }
  v18.__first_ = (std::__split_buffer<std::string>::pointer)v7;
  v18.__begin_ = (std::__split_buffer<std::string>::pointer)(v7 + 24 * v2);
  v18.__end_ = v18.__begin_;
  v18.__end_cap_.__value_ = (std::string *)(v7 + 24 * v8);
  std::string::basic_string[abi:nn180100]<0>(v18.__begin_->__r_.__value_.__r.__words, *a2);
  std::__split_buffer<std::string>::pointer v10 = *a1;
  unint64_t v9 = (unint64_t)a1[1];
  std::__split_buffer<std::string>::pointer begin = v18.__begin_;
  std::__split_buffer<std::string>::pointer v11 = v18.__begin_;
  if ((std::__split_buffer<std::string>::pointer)v9 == *a1)
  {
    int64x2_t v14 = vdupq_n_s64(v9);
  }

  else
  {
    do
    {
      __int128 v13 = *(_OWORD *)(v9 - 24);
      begin[-1].__r_.__value_.__l.__cap_ = *(void *)(v9 - 8);
      *(_OWORD *)&begin[-1].__r_.__value_.__l.__data_ = v13;
      --begin;
      *(void *)(v9 - 16) = 0LL;
      *(void *)(v9 - 8) = 0LL;
      *(void *)(v9 - 24) = 0LL;
      v9 -= 24LL;
    }

    while ((std::__split_buffer<std::string>::pointer)v9 != v10);
    int64x2_t v14 = *(int64x2_t *)a1;
  }

  std::__split_buffer<std::string>::pointer v15 = v11 + 1;
  *a1 = begin;
  a1[1] = v11 + 1;
  *(int64x2_t *)&v18.__begin_ = v14;
  unint64_t v16 = a1[2];
  a1[2] = v18.__end_cap_.__value_;
  v18.__end_cap_.__value_ = v16;
  v18.__first_ = (std::__split_buffer<std::string>::pointer)v14.i64[0];
  std::__split_buffer<std::string>::~__split_buffer(&v18);
  return v15;
}

void sub_126D0C( _Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void std::vector<std::string>::__assign_with_size[abi:nn180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>( uint64_t *a1, void *a2, unint64_t a3)
{
  uint64_t v4 = (uint64_t)a2;
  uint64_t v6 = a1[2];
  unint64_t v7 = (std::string *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - *a1) >> 3) < a3)
  {
    if (v7)
    {
      std::vector<std::string>::__clear[abi:nn180100](a1);
      operator delete((void *)*a1);
      uint64_t v6 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a3 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_30;
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a3) {
      uint64_t v9 = a3;
    }
    unint64_t v10 = v8 >= 0x555555555555555LL ? 0xAAAAAAAAAAAAAAALL : v9;
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
LABEL_30:
    }
      abort();
    std::__split_buffer<std::string>::pointer v11 = (std::string *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v10);
    *a1 = (uint64_t)v11;
    a1[1] = (uint64_t)v11;
    a1[2] = (uint64_t)&v11[v12];
    __int128 v13 = std::__uninitialized_allocator_copy_impl[abi:nn180100]<std::allocator<std::string>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::string*>( (uint64_t *)v4,  v11);
LABEL_21:
    a1[1] = (uint64_t)v13;
    return;
  }

  int64x2_t v14 = (std::string *)a1[1];
  unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((char *)v14 - (char *)v7) >> 3);
  if (v15 < a3)
  {
    if ((char *)v14 - (char *)v7 >= 1)
    {
      unint64_t v16 = v15 + 1;
      unint64_t v17 = a2;
      do
      {
        unint64_t v17 = (void *)*v17;
        --v16;
      }

      while (v16 > 1);
      if (v17 != a2)
      {
        do
        {
          std::string::operator=(v7, (const std::string *)(v4 + 16));
          uint64_t v4 = *(void *)v4;
          ++v7;
        }

        while ((void *)v4 != v17);
        int64x2_t v14 = (std::string *)a1[1];
      }

      uint64_t v4 = (uint64_t)v17;
    }

    __int128 v13 = std::__uninitialized_allocator_copy_impl[abi:nn180100]<std::allocator<std::string>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::string*>( (uint64_t *)v4,  v14);
    goto LABEL_21;
  }

  if (a2)
  {
    do
    {
      std::string::operator=(v7, (const std::string *)(v4 + 16));
      uint64_t v4 = *(void *)v4;
      ++v7;
    }

    while (v4);
    int64x2_t v14 = (std::string *)a1[1];
  }

  while (v14 != v7)
  {
    --v14;
  }

  a1[1] = (uint64_t)v7;
}

void sub_126EC4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_126ECC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::pointer begin = this->__begin_;
  std::__split_buffer<std::string>::pointer end = this->__end_;
  if (end != begin)
  {
    do
    {
      std::__split_buffer<std::string>::pointer v4 = end - 1;
      this->__end_ = end - 1;
      if ((char)end[-1].__r_.__value_.__s.__size_ < 0)
      {
        operator delete(v4->__r_.__value_.__l.__data_);
        std::__split_buffer<std::string>::pointer v4 = this->__end_;
      }

      std::__split_buffer<std::string>::pointer end = v4;
    }

    while (v4 != begin);
  }

  if (this->__first_) {
    operator delete(this->__first_);
  }
}

std::string *std::__uninitialized_allocator_copy_impl[abi:nn180100]<std::allocator<std::string>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::string*>( uint64_t *a1, std::string *this)
{
  if (a1)
  {
    unint64_t v3 = a1;
    do
    {
      if (*((char *)v3 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(this, (const std::string::value_type *)v3[2], v3[3]);
      }

      else
      {
        __int128 v4 = *((_OWORD *)v3 + 1);
        this->__r_.__value_.__l.__cap_ = v3[4];
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
      }

      unint64_t v3 = (uint64_t *)*v3;
      ++this;
    }

    while (v3);
  }

  return this;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

uint64_t *GTAGXProfilingSupportHelper::GetCountersForDerivedCounter(uint64_t a1)
{
  uint64_t v1 = (unsigned __int8 *)a1;
  unint64_t v2 = *(void *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    unint64_t v3 = *(unsigned __int8 *)(a1 + 23);
  }

  else
  {
    a1 = *(void *)a1;
    unint64_t v3 = v2;
  }

  unint64_t v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v3);
  unint64_t v5 = *((void *)&xmmword_5B9740 + 1);
  if (!*((void *)&xmmword_5B9740 + 1)) {
    goto LABEL_21;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_5B9740 + 8));
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *((void *)&xmmword_5B9740 + 1)) {
      unint64_t v9 = v4 % *((void *)&xmmword_5B9740 + 1);
    }
  }

  else
  {
    unint64_t v9 = (*((void *)&xmmword_5B9740 + 1) - 1LL) & v4;
  }

  unint64_t v10 = *(unsigned __int8 ***)(xmmword_5B9740 + 8 * v9);
  if (v10)
  {
    for (uint64_t i = *v10; i; uint64_t i = *(unsigned __int8 **)i)
    {
      unint64_t v12 = *((void *)i + 1);
      if (v6 == v12)
      {
        if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, v1)) {
          break;
        }
      }

      else
      {
        if (v8 > 1)
        {
          if (v12 >= v5) {
            v12 %= v5;
          }
        }

        else
        {
          v12 &= v5 - 1;
        }

        if (v12 != v9) {
          goto LABEL_21;
        }
      }
    }
  }

  else
  {
LABEL_21:
    uint64_t i = 0LL;
  }

  if (i) {
    return (uint64_t *)(i + 40);
  }
  else {
    return 0LL;
  }
}

void llvm::function_ref<llvm::Optional<std::string> ()(llvm::StringRef)>::callback_fn<llvm::$_0>( _BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

id GTShaderDebuggerMDSerializerError(unsigned int a1, NSString *a2)
{
  unint64_t v3 = a2;
  unint64_t v4 = v3;
  if (v3) {
    unint64_t v5 = (const __CFString *)v3;
  }
  else {
    unint64_t v5 = &stru_591D98;
  }
  NSErrorUserInfoKey v9 = NSLocalizedDescriptionKey;
  unint64_t v10 = v5;
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v10,  &v9,  1LL));
  uint8x8_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"GTShaderDebuggerMDSerializerErrorDomain",  a1,  v6));

  return v7;
}

void sub_1271D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<llvm::Module>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (llvm::Module **)**a1;
  if (v2)
  {
    unint64_t v4 = (llvm::Module **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<llvm::Module>::reset[abi:nn180100](--v4);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

char **llvm::SmallVector<llvm::SMFixIt,4u>::~SmallVector(char **a1)
{
  unint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v3)
  {
    uint64_t v4 = 40 * v3;
    do
    {
      if (v2[v4 - 1] < 0) {
        operator delete(*(void **)&v2[v4 - 24]);
      }
      v4 -= 40LL;
    }

    while (v4);
    unint64_t v2 = *a1;
  }

  return a1;
}

void std::unique_ptr<llvm::Module>::reset[abi:nn180100](llvm::Module **a1)
{
  unint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2)
  {
    llvm::Module::~Module(v2);
    operator delete(v3);
  }

apr_array_header_t *GetQueueForRef(apr_pool_t **a1, uint64_t a2)
{
  uint64_t v8 = a2;
  uint64_t v3 = *find_entry((uint64_t)a1, &v8, 8uLL, 0LL);
  if (!v3 || (uint64_t v4 = *(apr_array_header_t **)(v3 + 32)) == 0LL)
  {
    unint64_t v5 = *a1;
    uint64_t v4 = apr_array_make(*a1, 4, 8);
    unint64_t v6 = apr_palloc(v5, 8uLL);
    *unint64_t v6 = v8;
    apr_hash_set((apr_hash_t *)a1, v6, 8LL, v4);
  }

  return v4;
}

void GTMTLReplayController_restoreMTLBufferContents(uint64_t a1, void *a2)
{
  uint64_t v4 = **(void **)a1;
  unint64_t v5 = *(apr_pool_t ***)(a1 + 152);
  unint64_t v6 = (char *)a2[3];
  id v7 = *(id *)(a1 + 8);
  id v16 = v7;
  if (*a2 == 50LL)
  {
    uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 bufferForHeapKey:a2[1]]);
  }

  else
  {
    if (*a2 != 22LL)
    {
      NSErrorUserInfoKey v9 = 0LL;
      goto LABEL_7;
    }

    uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 bufferForKey:a2[1]]);
  }

  NSErrorUserInfoKey v9 = (void *)v8;
LABEL_7:
  uint64_t v10 = a2[5];
  id v11 = *(id *)(a1 + 24);
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 bufferWithLength:v10 alignment:1]);
  GTCaptureArchive_fillBuffer(v4, v5, v6, (char *)[v12 contents], a2[5], 0);
  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v11 blitCommandEncoder]);
  int64x2_t v14 = (void *)objc_claimAutoreleasedReturnValue([v12 heapBuffer]);
  objc_msgSend( v13,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v14,  objc_msgSend(v12, "heapLocation"),  v9,  a2[4],  a2[5]);

  unint64_t v15 = *v5;
  apr_pool_clear(v15);
}

void GTMTLReplayController_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(void **)a1;
  unint64_t v5 = *(apr_pool_t ***)(a1 + 152);
  id v6 = *(id *)(a1 + 8);
  id v7 = v6;
  uint64_t v100 = a2;
  if (!*(void *)(a2 + 8))
  {
    id NSError = MakeNSError(101, &__NSDictionary0__struct);
    id v9 = (id)objc_claimAutoreleasedReturnValue(NSError);
    GTMTLReplay_handleNSError(v9);
    goto LABEL_65;
  }

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "textureForKey:"));
  id v9 = v8;
  if (!v8)
  {
    id v14 = MakeNSError(101, &__NSDictionary0__struct);
    id v15 = (id)objc_claimAutoreleasedReturnValue(v14);
    GTMTLReplay_handleNSError(v15);
    goto LABEL_64;
  }

  uint64_t v10 = objc_claimAutoreleasedReturnValue([v8 device]);
  id v11 = (char *)[v9 pixelFormat];
  id v96 = [v9 sampleCount];
  id v99 = (void *)v10;
  GTMTLPixelFormatGetInfoForDevice((uint64_t)v112, v10, (uint64_t)v11);
  *(void *)&__int128 v118 = 0LL;
  id v83 = v7;
  if ((~v113 & 0x60) != 0)
  {
    if ((v113 & 0x2000) != 0)
    {
      uint64_t v12 = 4LL;
      *(void *)&__int128 v118 = 4LL;
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    uint64_t v91 = 1LL;
  }

  else
  {
    __int128 v118 = xmmword_318400;
    uint64_t v91 = 2LL;
    uint64_t v12 = 1LL;
  }

  uint64_t v88 = *(unsigned __int16 *)(v100 + 36);
  uint64_t v87 = *(unsigned __int16 *)(v100 + 38);
  uint64_t v86 = *(unsigned __int16 *)(v100 + 40);
  uint64_t v16 = *(unsigned __int16 *)(v100 + 42);
  uint64_t v17 = *(unsigned __int16 *)(v100 + 44);
  uint64_t v89 = *(unsigned __int16 *)(v100 + 46);
  GTMTLGetTextureLevelInfoForDeviceWithOptions((uint64_t)v105, v10, (uint64_t)v11, v16, v17, v89, (uint64_t)v96, 0LL, v12);
  size_t v18 = *(unsigned int *)GTCaptureArchive_getFileWithFilename(v4, *(char **)(v100 + 24));
  id v85 = *(id *)(a1 + 24);
  float v19 = (void *)objc_claimAutoreleasedReturnValue([v85 bufferWithLength:v18 alignment:v108]);
  GTCaptureArchive_fillBuffer(v4, v5, *(char **)(v100 + 24), (char *)[v19 contents], v18, 0);
  float v20 = (int *)[v19 contents];
  id v98 = v19;
  id v21 = [v19 length];
  if (v20) {
    BOOL v22 = (unint64_t)v21 >= 0x10;
  }
  else {
    BOOL v22 = 0;
  }
  if (v22 && *(void *)v20 == 0x63617074757265LL)
  {
    if (*((_WORD *)v20 + 4) == 1) {
      uint64_t v23 = v20[3] + 16LL;
    }
    else {
      uint64_t v23 = v20[3];
    }
  }

  else
  {
    float v20 = 0LL;
    uint64_t v23 = 0LL;
  }

  id v15 = v99;
  if ((v113 & 0x2000) != 0
    && ((*(_BYTE *)(*(void *)a1 + 272LL) & 1) != 0 || strncmp(*(const char **)(v100 + 24), "MTLTexture-", 0xBuLL)))
  {
    size_t v24 = (char *)[v98 contents] + v23;
    apr_size_t v25 = size;
    id v26 = (char *)apr_palloc(*v5, size);
    if ((int)v107 >= 1)
    {
      uint64_t v27 = 0LL;
      uint64_t v28 = v107;
      int v29 = v106;
      uint64_t v30 = v106;
      uint64_t v31 = 8LL * (int)v106;
      unint64_t v32 = v26;
      do
      {
        if (v29 >= 1)
        {
          uint64_t v33 = 0LL;
          do
          {
            uint64_t v34 = *(void *)&vorr_s8( (int8x8_t)vshl_n_s32((int32x2_t)__PAIR64__(v33, v27), 8uLL),  vand_s8((int8x8_t)__PAIR64__(v33, v27), (int8x8_t)0xFFFF0000FFFFLL)) & 0xFF00FF00FF00FFLL;
            unint64_t v35 = *(void *)&vorr_s8((int8x8_t)vshl_n_s32((int32x2_t)v34, 4uLL), (int8x8_t)v34) & 0xFF0FFF0FFF0FFF0FLL;
            int8x8_t v36 = vand_s8( vorr_s8((int8x8_t)vshl_n_s32((int32x2_t)v35, 2uLL), (int8x8_t)v35),  (int8x8_t)0x3333333333333333LL);
            int8x8_t v37 = (int8x8_t)vshl_u32((uint32x2_t)v36, (uint32x2_t)0x200000001LL);
            v36.i32[1] *= 2;
            int32x2_t v38 = (int32x2_t)vand_s8(vorr_s8(v37, v36), (int8x8_t)0xAAAAAAAA55555555LL);
            *(void *)&v32[8 * v33++] = *(void *)&v24[8
                                                       * vorr_s8((int8x8_t)v38, (int8x8_t)vdup_lane_s32(v38, 1)).i32[0]];
          }

          while (v30 != v33);
        }

        ++v27;
        v32 += v31;
      }

      while (v27 != v28);
    }

    memcpy(v24, v26, v25);
  }

  uint64_t v81 = v5;
  id v82 = v9;
  v117[0] = v11;
  v117[1] = v11;
  v116[0] = v16;
  v116[1] = v17;
  v116[2] = v89;
  v116[3] = v16;
  v116[4] = v17;
  v116[5] = v89;
  id v114 = v9;
  id v97 = v114;
  id v115 = v97;
  uint64_t v93 = v20;
  uint64_t PlanePixelFormat = GetPlanePixelFormat((uint64_t)v11, 0LL);
  if (PlanePixelFormat)
  {
    MTLTextureDescriptorFromTextureWithoutResourceIndex = MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(v97);
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorFromTextureWithoutResourceIndex);
    uint64_t v41 = 0LL;
    v42.i64[0] = v16;
    v42.i64[1] = v17;
    char v43 = 1;
    int8x16_t v94 = (int8x16_t)v42;
    int8x16_t v92 = (int8x16_t)vshrq_n_u64((uint64x2_t)vaddq_s64(v42, vdupq_n_s64(1uLL)), 1uLL);
    uint64_t v44 = PlanePixelFormat;
    while (1)
    {
      v117[v41] = v44;
      if (v11 == (_BYTE *)&stru_1F8.addr + 7 || (int8x16_t v45 = v94, v11 == (_BYTE *)&stru_1F8.addr + 4))
      {
        if ((v43 & 1) != 0) {
          unint64_t v46 = -1LL;
        }
        else {
          unint64_t v46 = 0LL;
        }
        int8x16_t v45 = vbslq_s8((int8x16_t)vdupq_n_s64(v46), v94, v92);
      }

      uint64_t v47 = (int8x16_t *)&v116[3 * v41];
      int8x16_t *v47 = v45;
      v47[1].i64[0] = v89;
      [v40 setWidth:v45.i64[0]];
      [v40 setHeight:v116[3 * v41 + 1]];
      [v40 setPixelFormat:v44];
      id v48 = [v99 newTextureWithDescriptor:v40];
      uint64_t v49 = *(&v114 + v41);
      *(&v114 + v41) = v48;

      if ((v43 & 1) == 0) {
        break;
      }
      uint64_t v44 = GetPlanePixelFormat((uint64_t)v11, 1LL);
      char v43 = 0;
      uint64_t v41 = 1LL;
    }

    uint64_t v91 = 2LL;
    float v20 = v93;
  }

  __int128 v95 = (void *)objc_claimAutoreleasedReturnValue([v85 blitCommandEncoder]);
  unint64_t v50 = 0LL;
  __int128 v51 = (uint64_t *)(v20 + 16);
  int64x2_t v52 = v116;
  unint64_t v90 = v11;
  do
  {
    uint64_t v53 = *((void *)&v118 + v50);
    *(void *)&double v54 = GTMTLGetTextureLevelInfoForDeviceWithOptions( (uint64_t)v105,  (uint64_t)v15,  v117[v50],  *v52,  v52[1],  v52[2],  (uint64_t)v96,  0LL,  v53).n128_u64[0];
    if (v20 && *((_WORD *)v20 + 5) == 1 && *((void *)v20 + 2) >= v50)
    {
      uint64_t v55 = *(v51 - 1);
      uint64_t v56 = *v51;
    }

    else
    {
      uint64_t v55 = *(unsigned int *)(v100 + 48);
      uint64_t v56 = *(unsigned int *)(v100 + 52);
    }

    BOOL v57 = (char *)objc_msgSend(v97, "textureType", v54);
    if (v57 != (_BYTE *)&dword_4 + 3)
    {
      if (!v55) {
LABEL_48:
      }
        uint64_t v55 = v109;
      uint64_t v56 = v107 * v55;
      goto LABEL_56;
    }

    if (!v55) {
      uint64_t v55 = v109;
    }
    if (!v56) {
      uint64_t v56 = v55 * v107;
    }
LABEL_56:
    unsigned __int8 v58 = (void *)objc_claimAutoreleasedReturnValue([v98 heapBuffer]);
    unint64_t v59 = (char *)[v98 heapLocation];
    uint64_t v60 = (uint64_t)*(&v114 + v50);
    uint64_t v61 = *(unsigned __int16 *)(v100 + 32);
    uint64_t v62 = *(unsigned __int16 *)(v100 + 34);
    __int128 v103 = *(_OWORD *)v52;
    uint64_t v104 = v52[2];
    v102[0] = v88;
    v102[1] = v87;
    v102[2] = v86;
    [v95 copyFromBuffer:v58 sourceOffset:&v59[v23] sourceBytesPerRow:v55 sourceBytesPerImage:v56 sourceSize:&v103 toTexture:v60 destinationSlice:v61 destinatio nLevel:v62 destinationOrigin:v102 options:v53];

    v23 += v111;
    ++v50;
    v51 += 6;
    v52 += 3;
    id v15 = v99;
    float v20 = v93;
  }

  while (v91 != v50);
  if (PlanePixelFormat)
  {
    id v63 = GTMTLReplayController_defaultLibrary(v99);
    uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(v63);
    std::__split_buffer<std::string>::pointer v65 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
    int v66 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor colorAttachments](v65, "colorAttachments"));
    __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v66 objectAtIndexedSubscript:0]);
    [v67 setPixelFormat:v90];

    id v68 = [v64 newFunctionWithName:@"Harvest2PVertexForDownloader"];
    -[MTLRenderPipelineDescriptor setVertexFunction:](v65, "setVertexFunction:", v68);

    id v69 = [v64 newFunctionWithName:@"Harvest2PFragmentUpload"];
    -[MTLRenderPipelineDescriptor setFragmentFunction:](v65, "setFragmentFunction:", v69);

    id v101 = 0LL;
    id v70 = [v99 newRenderPipelineStateWithDescriptor:v65 error:&v101];
    id v71 = v101;
    int v72 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
    int v73 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v72, "colorAttachments"));
    __int128 v74 = (void *)objc_claimAutoreleasedReturnValue([v73 objectAtIndexedSubscript:0]);
    [v74 setTexture:v97];

    id v15 = v99;
    BOOL v75 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v72, "colorAttachments"));
    BOOL v76 = (void *)objc_claimAutoreleasedReturnValue([v75 objectAtIndexedSubscript:0]);
    [v76 setLoadAction:0];

    __int128 v77 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v72, "colorAttachments"));
    unsigned __int8 v78 = (void *)objc_claimAutoreleasedReturnValue([v77 objectAtIndexedSubscript:0]);
    [v78 setStoreAction:1];

    __int128 v79 = (void *)objc_claimAutoreleasedReturnValue([v85 renderCommandEncoderWithDescriptor:v72]);
    [v79 setRenderPipelineState:v70];
    [v79 setFragmentTexture:v114 atIndex:0];
    [v79 setFragmentTexture:v115 atIndex:1];

    [v79 drawPrimitives:3 vertexStart:0 vertexCount:3];
  }

  apr_pool_clear(*v81);

  uint64_t v80 = 8LL;
  id v9 = v82;
  do
  {

    v80 -= 8LL;
  }

  while (v80 != -8);

  id v7 = v83;
LABEL_64:

LABEL_65:
}

char *GTMTLReplayController_makeDataSource(const char *a1, apr_pool_t *a2)
{
  uint64_t v4 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v4))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = a1;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v4,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "LoadArchive %{public}s",  buf,  0xCu);
  }

  bzero(buf, 0x400uLL);
  unint64_t v5 = realpath_DARWIN_EXTSN(a1, buf);
  if (v5) {
    id v6 = v5;
  }
  else {
    id v6 = a1;
  }
  id v7 = gt_filepath_merge(v6, "index", a2);
  int v8 = open(v7, 0);
  pool = a2;
  if (v8 < 0) {
    goto LABEL_25;
  }
  int v9 = v8;
  fstat(v8, &v696);
  uint64_t v10 = apr_palloc(a2, v696.st_size);
  uint64_t v11 = 0LL;
  st_apr_size_t size = v696.st_size;
  do
  {
    else {
      size_t v13 = st_size - v11;
    }
    ssize_t v14 = read(v9, (char *)v10 + v11, v13);
    if (v14 == -1) {
      ssize_t v15 = 0LL;
    }
    else {
      ssize_t v15 = v14;
    }
    v11 += v15;
  }

  while (v14 != -1 && v11 != st_size);
  close(v9);
  if (v696.st_size < 0x14uLL
    || *(_DWORD *)v10 != 1667851384
    || *((_DWORD *)v10 + 1)
    || (uint64_t v17 = *((unsigned int *)v10 + 2), v696.st_size - 20 < (unint64_t)(12 * v17))
    || (uint64_t v18 = (uint64_t)v10 + 12 * v17 + 20,
        uint64_t v19 = *((unsigned int *)v10 + 3),
        v696.st_size - (12 * (unint64_t)v17 + 20) < 24 * v19)
    || (uint64_t v20 = v18 + 24LL * v19,
        uint64_t v21 = *((unsigned int *)v10 + 4),
        (unint64_t)v10 + v696.st_size - v20 < 2 * v21))
  {
LABEL_25:
    uint64_t v22 = 0LL;
  }

  else
  {
    v609 = a1;
    v610 = apr_array_make(a2, v21, 8);
    uint64_t v611 = *((unsigned int *)v10 + 4);
    if ((_DWORD)v611)
    {
      unint64_t v612 = 0LL;
      v613 = (char *)v10 + v696.st_size;
      unint64_t v614 = v20 + 2 * v611;
      while ((unint64_t)v613 > v614)
      {
        *(void *)apr_array_push(v610) = v614;
        v614 += *(unsigned __int16 *)(v20 + 2 * v612++);
      }

      uint64_t v22 = 0LL;
      a1 = v609;
      a2 = pool;
    }

    else
    {
LABEL_729:
      a2 = pool;
      v615 = gt_filepath_merge(v6, "store0", pool);
      int v616 = open(v615, 0);
      if (v616 < 0)
      {
        uint64_t v22 = 0LL;
        a1 = v609;
      }

      else
      {
        int v617 = v616;
        fstat(v616, &v695);
        v618 = mmap(0LL, v695.st_size, 1, 2, v617, 0LL);
        off_t v619 = v695.st_size;
        close(v617);
        v620 = apr_palloc(pool, 0x70uLL);
        v621 = v620;
        if (v620)
        {
          v620[5] = 0u;
          v620[6] = 0u;
          v620[3] = 0u;
          v620[4] = 0u;
          v620[1] = 0u;
          v620[2] = 0u;
          _OWORD *v620 = 0u;
        }

        *(void *)v620 = apr_pstrdup(pool, v6);
        v621[1] = pool;
        v621[2] = v10;
        v621[3] = v696.st_size;
        v621[4] = (char *)v10 + 20;
        v621[5] = v18;
        v621[6] = v610;
        v621[7] = v10[1];
        v621[8] = v618;
        v621[9] = v619;
        v621[10] = apr_array_make(pool, 4, 24);
        v621[11] = apr_hash_make(pool);
        a1 = v609;
        uint64_t v22 = (uint64_t)v621;
        if (!apr_pool_create_ex(v690, pool, 0LL, v622))
        {
          v624 = v621 + 12;
          v625 = v690[0];
          v626 = gt_filepath_merge(v6, "metadata", v690[0]);
          int v627 = open(v626, 0);
          if (v627 < 0)
          {
            void *v624 = 0LL;
            *(void *)(v22 + 104) = 0LL;
          }

          else
          {
            int v628 = v627;
            fstat(v627, &v695);
            v629 = (const UInt8 *)apr_palloc(v625, v695.st_size);
            uint64_t v630 = 0LL;
            off_t v631 = v695.st_size;
            do
            {
              else {
                size_t v632 = v631 - v630;
              }
              ssize_t v633 = read(v628, (void *)&v629[v630], v632);
              if (v633 == -1) {
                ssize_t v634 = 0LL;
              }
              else {
                ssize_t v634 = v633;
              }
              v630 += v634;
            }

            while (v633 != -1 && v630 != v631);
            close(v628);
            v636 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v629, v695.st_size, kCFAllocatorNull);
            CFErrorRef error = 0LL;
            v637 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v636, 0LL, 0LL, &error);
            CFRelease(v636);
            if (error)
            {
              void *v624 = 0LL;
              v624[1] = 0LL;
            }

            else
            {
              Value = (const __CFString *)CFDictionaryGetValue(v637, @"(uuid)");
              if (Value)
              {
                v639 = CFUUIDCreateFromString(kCFAllocatorDefault, Value);
                *(CFUUIDBytes *)(v22 + 96) = CFUUIDGetUUIDBytes(v639);
                CFRelease(v639);
              }

              else
              {
                void *v624 = 0LL;
                v624[1] = 0LL;
              }
            }

            CFRelease(v637);
          }

          apr_pool_destroy(v625);
        }

        apr_pool_cleanup_register( pool,  (const void *)v22,  (apr_status_t (__cdecl *)(void *))GTCaptureArchive_cleanup,  v623);
      }
    }
  }

  uint64_t v23 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v23))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v23,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
  }

  if (!v22) {
    return 0LL;
  }
  apr_pool_create_ex(&newpool, a2, 0LL, v24);
  apr_size_t v25 = newpool;
  *(void *)&v695.st_dev = v22;
  v695.__darwin_ino64_t st_ino = (__darwin_ino64_t)GTCaptureArchiveDecompressor_create(newpool);
  apr_pool_create_ex((apr_pool_t **)buf, 0LL, 0LL, v26);
  uint64_t v27 = *(apr_pool_t **)buf;
  uint64_t v28 = (pthread_mutex_t *)apr_palloc(*(apr_pool_t **)buf, 0x200uLL);
  uint64_t v29 = (uint64_t)v28;
  if (v28)
  {
    *(_OWORD *)&v28[7].__opaque[24] = 0u;
    *(_OWORD *)&v28[7].__opaque[40] = 0u;
    *(_OWORD *)&v28[7].__sig = 0u;
    *(_OWORD *)&v28[7].__opaque[8] = 0u;
    *(_OWORD *)&v28[6].__opaque[24] = 0u;
    *(_OWORD *)&v28[6].__opaque[40] = 0u;
    *(_OWORD *)&v28[6].__sig = 0u;
    *(_OWORD *)&v28[6].__opaque[8] = 0u;
    *(_OWORD *)&v28[5].__opaque[24] = 0u;
    *(_OWORD *)&v28[5].__opaque[40] = 0u;
    *(_OWORD *)&v28[5].__sig = 0u;
    *(_OWORD *)&v28[5].__opaque[8] = 0u;
    *(_OWORD *)&v28[4].__opaque[24] = 0u;
    *(_OWORD *)&v28[4].__opaque[40] = 0u;
    *(_OWORD *)&v28[4].__sig = 0u;
    *(_OWORD *)&v28[4].__opaque[8] = 0u;
    *(_OWORD *)&v28[3].__opaque[24] = 0u;
    *(_OWORD *)&v28[3].__opaque[40] = 0u;
    *(_OWORD *)&v28[3].__sig = 0u;
    *(_OWORD *)&v28[3].__opaque[8] = 0u;
    *(_OWORD *)&v28[2].__opaque[24] = 0u;
    *(_OWORD *)&v28[2].__opaque[40] = 0u;
    *(_OWORD *)&v28[2].__sig = 0u;
    *(_OWORD *)&v28[2].__opaque[8] = 0u;
    *(_OWORD *)&v28[1].__opaque[24] = 0u;
    *(_OWORD *)&v28[1].__opaque[40] = 0u;
    *(_OWORD *)&v28[1].__sig = 0u;
    *(_OWORD *)&v28[1].__opaque[8] = 0u;
    *(_OWORD *)&v28->__opaque[24] = 0u;
    *(_OWORD *)&v28->__opaque[40] = 0u;
    *(_OWORD *)&v28->__sig = 0u;
    *(_OWORD *)&v28->__opaque[8] = 0u;
  }

  pthread_mutex_init(v28, 0LL);
  *(void *)(v29 + 88) = apr_hash_make(v27);
  vm_address_t v30 = GTCoreAlloc(0x148uLL);
  pthread_mutex_init((pthread_mutex_t *)(v30 + 264), 0LL);
  *(void *)(v29 + 64) = v30;
  *(void *)(v29 + 112) = GTTraceContext_openStream(v29, 0LL);
  atomic_store(0, (unsigned __int8 *)(v29 + 120));
  atomic_store(0, (unsigned int *)(v29 + 104));
  *(void *)&v695.st_uid = v29;
  *(void *)&v695.st_rdev = apr_hash_make(a2);
  v695.st_atimespec.tv_sec = (__darwin_time_t)apr_hash_make(a2);
  v695.st_atimespec.uint64_t tv_nsec = (uint64_t)a2;
  memset(&v695.st_mtimespec, 0, 48);
  __darwin_ino64_t st_ino = v695.st_ino;
  uint64_t v656 = *(void *)&v695.st_uid;
  uint64_t v31 = (char *)apr_palloc(a2, 0x118uLL);
  if (v31)
  {
    *(_OWORD *)(v31 + 8) = 0u;
    *(_OWORD *)(v31 + 248) = 0u;
    *(_OWORD *)(v31 + 264) = 0u;
    *(_OWORD *)(v31 + 216) = 0u;
    *(_OWORD *)(v31 + 232) = 0u;
    *(_OWORD *)(v31 + 184) = 0u;
    *(_OWORD *)(v31 + 200) = 0u;
    *(_OWORD *)(v31 + 152) = 0u;
    *(_OWORD *)(v31 + 168) = 0u;
    *(_OWORD *)(v31 + 120) = 0u;
    *(_OWORD *)(v31 + 136) = 0u;
    *(_OWORD *)(v31 + 88) = 0u;
    *(_OWORD *)(v31 + 104) = 0u;
    *(_OWORD *)(v31 + 56) = 0u;
    *(_OWORD *)(v31 + 72) = 0u;
    *(_OWORD *)(v31 + 24) = 0u;
    *(_OWORD *)(v31 + 40) = 0u;
  }

  *(void *)uint64_t v31 = v22;
  v682 = v31;
  *(_OWORD *)(v31 + 24) = *(_OWORD *)&v695.st_rdev;
  unint64_t v32 = apr_array_make(a2, 128, 64);
  atomic_store(1u, (unsigned int *)(*(void *)&v695.st_uid + 104LL));
  apr_pool_create_ex(&p, v25, 0LL, v33);
  uint64_t v34 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v34))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v34,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "SortArchiveStrings",  buf,  2u);
  }

  unint64_t v35 = apr_array_copy(p, *(const apr_array_header_t **)(v22 + 48));
  qsort(v35->elts, v35->nelts, v35->elt_size, (int (__cdecl *)(const void *, const void *))GTCaptureArchive_strcmp);
  int8x8_t v36 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v36))
  {
    int nelts = v35->nelts;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = nelts;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v36,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "x%d",  buf,  8u);
  }

  v640 = a1;

  int32x2_t v38 = apr_array_make(v25, 4, 8);
  GTCaptureArchive_filenamesWithPrefix(v35->nelts, (const char **)v35->elts, "startup", v38);
  GTCaptureArchive_filenamesWithPrefix(v35->nelts, (const char **)v35->elts, "device-resources", v38);
  if ((dword_5B9DE4 & 0x800) == 0) {
    GTCaptureArchive_filenamesWithPrefix(v35->nelts, (const char **)v35->elts, "unused-device-resources", v38);
  }
  uint64_t v39 = v682;
  v664 = v32;
  arr = (apr_array_header_t *)v22;
  if (v38->nelts >= 1)
  {
    uint64_t v40 = 0LL;
    v659 = (apr_hash_t *)v38;
    while (1)
    {
      uint64_t v41 = *(char **)&v38->elts[8 * v40];
      int64x2_t v42 = p;
      char v43 = GTCaptureArchive_mapData(v22, st_ino, v41, p);
      unint64_t v45 = v44;
      int v678 = strncmp(v41, "unused-device-resources", 0x17uLL);
      __int16 v46 = dword_5B9DE4;
      uint64_t v47 = apr_array_make(v42, 16, 8);
      id v48 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v48))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v41;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v45;
        _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v48,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "ReadTrace %{public}s (%{xcode:size-in-bytes}zu)",  buf,  0x16u);
      }

      unint64_t v49 = atomic_load((unint64_t *)(*(void *)&v695.st_uid + 72LL));
      v672 = (apr_hash_t *)v49;
      if (v45 >= 9) {
        break;
      }
LABEL_67:
      uint64_t v39 = v682;
      unint64_t v32 = v664;
      if (v47->nelts)
      {
        unint64_t v61 = 0LL;
        do
          AddResourceRestoreRequest(v664, (uint64_t)&v695, *(void *)&v47->elts[8 * v61++], 0xFFFFFFFFFFFFFFFFLL);
        while (v61 < v47->nelts);
      }

      uint64_t v62 = g_signpostLog;
      uint64_t v22 = (uint64_t)arr;
      int32x2_t v38 = (apr_array_header_t *)v659;
      if (os_signpost_enabled((os_log_t)v62))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v62,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
      }

      apr_pool_clear(p);
      if (!v678)
      {
        unint64_t v63 = atomic_load((unint64_t *)(*(void *)&v695.st_uid + 72LL));
        *((void *)v682 + 8) = v672;
        *((void *)v682 + 9) = v63 - (void)v672;
      }
    }

    BOOL v50 = (v678 | v46 & 0x400) != 0;
    unint64_t v51 = 8LL;
    while (1)
    {
      int64x2_t v52 = (unsigned int *)((char *)v43 + v51);
      GTTraceFbufToFunc(&v695, (char *)v43 + v51);
      int v53 = *(unsigned int *)((char *)v43 + v51 + 4);
      if (v53 <= -10241)
      {
        if (v53 == -16313 || v53 == -16236 || v53 == -16234)
        {
LABEL_60:
          if (v50) {
            *(void *)apr_array_push(v47) = v52;
          }
        }
      }

      else
      {
        unsigned int v54 = v53 + 10240;
        BOOL v310 = v54 > 0x32;
        uint64_t v55 = (1LL << v54) & 0x440000020011DLL;
        if (!v310 && v55 != 0) {
          goto LABEL_60;
        }
      }

      uint64_t v59 = *v52;
      if ((*((_BYTE *)v52 + 33) & 0x10) != 0)
      {
        uint64_t v60 = *v52;
        do
        {
          int64x2_t v52 = (unsigned int *)((char *)v52 + v59);
          uint64_t v59 = *v52;
          v60 += v59;
        }

        while ((*((_BYTE *)v52 + 33) & 0x20) == 0);
      }

      else
      {
        uint64_t v60 = *v52;
      }

      v51 += v60;
      if (v51 >= v45) {
        goto LABEL_67;
      }
    }
  }

LABEL_272:
            *(void *)&buf[16] = 0LL;
            *(void *)&buf[24] = 0LL;
            __int128 v698 = 0uLL;
            *(_DWORD *)buf = v690[0];
            *(_DWORD *)&uint8_t buf[4] = 500;
            *(void *)&buf[8] = "!apr_is_empty_array(builder->stack)";
            GTError_addError((int *)v690, (uint64_t)buf);
LABEL_273:
            __int128 v172 = v679;
            goto LABEL_193;
          }
        }

        else if (v144 == -16361 || v144 == -16202 || v144 == -15908)
        {
          goto LABEL_263;
        }

        __int128 v198 = v692;
        if (!v692) {
          goto LABEL_272;
        }
LABEL_268:
        int v200 = v198->nelts;
        if (!v200) {
          goto LABEL_272;
        }
        if (!IsFuncEnumPopDebugGroup(v144)
          || (v201 = IsFuncEnumPushDebugGroup(*(_DWORD *)&v198->elts[8 * v200 - 4]), __int128 v172 = v679, v201))
        {
          GroupBuilder_popGroup((uint64_t)v690, v164);
          goto LABEL_273;
        }
      }

                  ssize_t v14 = v1220;
                  id v206 = atomic_load((unsigned int *)(v50 + 4));
                  uint64_t v207 = v193 + (v206 >> 6);
                  uint64_t v208 = (HIDWORD(v193) + 1);
                  int v193 = (v208 << 32) | v193;
                  if ((_DWORD)v208 == v207 - 1)
                  {
                    int v193 = (v208 << 32) | v208;
                    BOOL v50 = *(void *)(v50 + 40);
                    continue;
                  }

                  goto LABEL_259;
                }

                uint64_t v205 = GTTraceFunc_argumentBytesWithMap( v196,  *(unsigned __int8 *)(v194 + ((uint64_t)v195 << 6) + 13),  v1239);
                *((void *)&v204 + 1) = *((void *)&v1202 + 1);
                *(void *)&uint64_t v204 = *((void *)v205 + 1);
              }

              v1202 = v204;
              goto LABEL_272;
            }

            ssize_t v14 = v1220;
            if (v1235 > v197) {
              goto LABEL_1211;
            }
            v209 = (char *)apr_palloc(p, 0x58uLL);
            v210 = v209;
            *(_DWORD *)v209 = 75;
            *((_DWORD *)v209 + 1) = v1156;
            *((void *)v209 + 1) = v1169;
            unsigned int v211 = v209 + 8;
            *((void *)v209 + 2) = v1183;
            *((void *)v209 + 3) = -1LL;
          }

          else
          {
            v209 = (char *)apr_palloc(p, 0x58uLL);
            v210 = v209;
            *(_DWORD *)v209 = 75;
            *((_DWORD *)v209 + 1) = v1156;
            *((void *)v209 + 1) = v1169;
            unsigned int v211 = v209 + 8;
            char v197 = -1LL;
            *((void *)v209 + 2) = v1183;
            *((void *)v209 + 3) = -1LL;
          }

          break;
        }

        *((void *)v209 + 4) = 0LL;
        *((void *)v209 + 5) = v1138;
        *((void *)v209 + 6) = v191;
        *((void *)v209 + 7) = v192;
        *((_OWORD *)v209 + 4) = v1202;
        *((void *)v209 + 10) = v1124;
        goto LABEL_826;
      case 3:
        if (!GTMTLSMBuilder_streamIntersectionRange(v1235, v1236, v37)) {
          goto LABEL_1211;
        }
        memset(&__src[7], 0, 304);
        memset(&__src[2], 0, 64);
        memset(__src, 0, 24);
        LODWORD(__src[0]) = 71;
        *((void *)&__src[1] + 1) = -1LL;
        __src[6] = 0xFFFFFFFFFFFFFFFFLL;
        ++HIDWORD(v1240);
        unsigned int v54 = *(void *)(v37 + 32);
        if (v54)
        {
          uint64_t v55 = 0;
          while (1)
          {
            uint64_t v56 = atomic_load((unsigned int *)(v54 + 4));
            BOOL v57 = v55 + (v56 >> 6) - 1;
            unsigned int v54 = *(void *)(v54 + 40);
            uint64_t v55 = v57;
            if (!v54)
            {
              uint64_t v55 = v57;
              goto LABEL_278;
            }
          }
        }

        else
        {
          uint64_t v55 = 0;
        }

        BOOL v57 = 0LL;
LABEL_278:
        int v212 = v55 | (unint64_t)(v57 << 32);
        while (2)
        {
          id v213 = v54 + 64;
LABEL_280:
          if (!v54
            || (*(_BYTE *)(v213 + ((uint64_t)(HIDWORD(v212) - (int)v212) << 6) + 15) & 8) == 0
            || (signed int v214 = v213 + ((uint64_t)(HIDWORD(v212) - (int)v212) << 6),
                BOOL v215 = *(void *)v214,
                *(void *)v214 >= v1236 + v1235))
          {
            v219 = apr_palloc(p, 0x1A0uLL);
            memcpy(v219, __src, 0x1A0uLL);
            goto LABEL_936;
          }

          if (*(_DWORD *)(v214 + 8) != -16242)
          {
            GTMTLSMRenderPipelineState_processTraceFuncWithMap((char *)__src, v1239, (uint64_t *)v214);
            uint64_t v216 = atomic_load((unsigned int *)(v54 + 4));
            int v217 = v212 + (v216 >> 6);
            unint64_t v218 = (HIDWORD(v212) + 1);
            int v212 = (v218 << 32) | v212;
            if ((_DWORD)v218 == v217 - 1)
            {
              int v212 = (v218 << 32) | v218;
              unsigned int v54 = *(void *)(v54 + 40);
              continue;
            }

            goto LABEL_280;
          }

          break;
        }

        ssize_t v14 = v1220;
        if (v1235 > v215) {
          goto LABEL_1211;
        }
        v219 = apr_palloc(p, 0x1A0uLL);
        memcpy(v219, __src, 0x1A0uLL);
        goto LABEL_1226;
      case 4:
        if (!GTMTLSMBuilder_streamIntersectionRange(v1235, v1236, v37)) {
          goto LABEL_1211;
        }
        memset(__src, 0, 24);
        memset(&__src[7], 0, 88);
        memset(&__src[2], 0, 64);
        LODWORD(__src[0]) = 29;
        *((void *)&__src[1] + 1) = -1LL;
        __src[6] = 0xFFFFFFFFFFFFFFFFLL;
        LODWORD(v1241) = v1241 + 1;
        unsigned __int8 v58 = *(void *)(v37 + 32);
        if (v58)
        {
          uint64_t v59 = 0;
          while (1)
          {
            uint64_t v60 = atomic_load((unsigned int *)(v58 + 4));
            unint64_t v61 = v59 + (v60 >> 6) - 1;
            unsigned __int8 v58 = *(void *)(v58 + 40);
            uint64_t v59 = v61;
            if (!v58)
            {
              uint64_t v59 = v61;
              goto LABEL_289;
            }
          }
        }

        else
        {
          uint64_t v59 = 0;
        }

        unint64_t v61 = 0LL;
LABEL_289:
        uint64_t v220 = v59 | (unint64_t)(v61 << 32);
        while (2)
        {
          uint64_t v221 = v58 + 64;
LABEL_291:
          if (!v58
            || (*(_BYTE *)(v221 + ((uint64_t)(HIDWORD(v220) - (int)v220) << 6) + 15) & 8) == 0
            || (unint64_t v222 = v221 + ((uint64_t)(HIDWORD(v220) - (int)v220) << 6),
                BOOL v215 = *(void *)v222,
                *(void *)v222 >= v1236 + v1235))
          {
            v219 = apr_palloc(p, 0xC8uLL);
            void *v219 = __src[0];
            id v226 = __src[4];
            int v228 = __src[1];
            unsigned int v227 = __src[2];
            v219[3] = __src[3];
            v219[4] = v226;
            v219[1] = v228;
            v219[2] = v227;
            uint64_t v229 = __src[8];
            char v231 = __src[5];
            id v230 = __src[6];
            v219[7] = __src[7];
            v219[8] = v229;
            v219[5] = v231;
            v219[6] = v230;
            unint64_t v232 = *(void *)&__src[12];
            unsigned int v233 = __src[11];
            v234 = __src[9];
            v219[10] = __src[10];
            v219[11] = v233;
            v219[9] = v234;
            *((void *)v219 + 24) = v232;
            goto LABEL_936;
          }

          if (*(_DWORD *)(v222 + 8) != -16321)
          {
            GTMTLSMComputePipelineState_processTraceFuncWithMap((char *)__src, v1239, (uint64_t *)v222);
            id v223 = atomic_load((unsigned int *)(v58 + 4));
            v224 = v220 + (v223 >> 6);
            unint64_t v225 = (HIDWORD(v220) + 1);
            uint64_t v220 = (v225 << 32) | v220;
            if ((_DWORD)v225 == v224 - 1)
            {
              uint64_t v220 = (v225 << 32) | v225;
              unsigned __int8 v58 = *(void *)(v58 + 40);
              continue;
            }

            goto LABEL_291;
          }

          break;
        }

        ssize_t v14 = v1220;
        if (v1235 > v215) {
          goto LABEL_1211;
        }
        v219 = apr_palloc(p, 0xC8uLL);
        void *v219 = __src[0];
        v945 = __src[4];
        v947 = __src[1];
        v946 = __src[2];
        v219[3] = __src[3];
        v219[4] = v945;
        v219[1] = v947;
        v219[2] = v946;
        v948 = __src[8];
        v950 = __src[5];
        v949 = __src[6];
        v219[7] = __src[7];
        v219[8] = v948;
        v219[5] = v950;
        v219[6] = v949;
        v951 = *(void *)&__src[12];
        v952 = __src[11];
        v953 = __src[9];
        v219[10] = __src[10];
        v219[11] = v952;
        v219[9] = v953;
        *((void *)v219 + 24) = v951;
        goto LABEL_1226;
      case 5:
        if (!GTMTLSMBuilder_streamIntersectionRange(v1235, v1236, v37)) {
          goto LABEL_1211;
        }
        BYTE2(__src[0]) = 0;
        LOWORD(__src[0]) = 0;
        ++DWORD1(v1241);
        uint64_t v62 = *(void *)(v37 + 32);
        if (v62)
        {
          unint64_t v63 = 0;
          while (1)
          {
            unint64_t v64 = atomic_load((unsigned int *)(v62 + 4));
            uint64_t v65 = v63 + (v64 >> 6) - 1;
            uint64_t v62 = *(void *)(v62 + 40);
            unint64_t v63 = v65;
            if (!v62)
            {
              unint64_t v63 = v65;
              goto LABEL_300;
            }
          }
        }

        else
        {
          unint64_t v63 = 0;
        }

        uint64_t v65 = 0LL;
LABEL_300:
        v235 = 0;
        v1094 = 0LL;
        v1098 = 0LL;
        v1103 = 0LL;
        v1139 = 0LL;
        v1083 = 0LL;
        v1086 = 0LL;
        v1157 = 0;
        v1203 = 0;
        v1090 = 0;
        v1077 = 0;
        v1110 = 0LL;
        v1170 = 0LL;
        v1184 = 0LL;
        v1117 = 0;
        unint64_t v236 = v63 | (unint64_t)(v65 << 32);
        v1125 = 2;
        v1080 = -1LL;
        v1074 = -1LL;
        while (2)
        {
          unint64_t v237 = v62 + 64;
LABEL_302:
          if (v62)
          {
            uint64_t v238 = HIDWORD(v236) - v236;
            if ((*(_BYTE *)(v237 + ((uint64_t)(HIDWORD(v236) - (int)v236) << 6) + 15) & 8) != 0)
            {
              v239 = v238;
              __int128 v240 = v237 + ((uint64_t)v238 << 6);
              __int128 v241 = *(void *)v240;
              if (*(void *)v240 < v1236 + v1235)
              {
                __int128 v242 = *(_DWORD *)(v240 + 8);
                if (v242 == -15925 || v242 == -15919)
                {
                  if (v1235 <= v241)
                  {
                    uint64_t v244 = apr_palloc(p, 0x90uLL);
                    *(_DWORD *)uint64_t v244 = 57;
                    *((_DWORD *)v244 + 1) = v235;
                    v244[1] = v1094;
                    v244[2] = v1103;
                    v244[3] = v1080;
                    v244[4] = 0LL;
                    v244[5] = v1098;
                    v244[6] = 0LL;
                    v244[7] = v1139;
                    v244[8] = v1074;
                    v244[9] = v1083;
                    *((_DWORD *)v244 + 20) = 0;
                    *((_DWORD *)v244 + 21) = v1157;
                    *((_DWORD *)v244 + 22) = v1203;
                    *((_DWORD *)v244 + 23) = 0;
                    *((_WORD *)v244 + 48) = v1090;
                    *((_WORD *)v244 + 49) = v1125;
                    *((_BYTE *)v244 + 100) = v1077;
                    *((_BYTE *)v244 + 103) = BYTE2(__src[0]);
                    *(_WORD *)((char *)v244 + 101) = __src[0];
                    v244[13] = v1110;
                    v244[14] = v1086;
                    v244[15] = v1184;
                    v244[16] = v1170;
                    v244[17] = v1117;
                    v245 = *find_entry((uint64_t)ht, (_BYTE *)v244 + 8, 8uLL, 0LL);
                    if (v245) {
                      v245 = *(void *)(v245 + 32);
                    }
                    v244[4] = v245;
                    apr_hash_set(ht, v244 + 1, 8LL, v244);
                    v244[3] = v241;
                    __int128 v242 = *(_DWORD *)(v240 + 8);
                    unint64_t v237 = v62 + 64;
                  }
                }

                else if (v242 == -15923)
                {
                  if (v1235 <= v241)
                  {
                    v992 = apr_palloc(p, 0x90uLL);
                    *(_DWORD *)v992 = 57;
                    *((_DWORD *)v992 + 1) = v235;
                    v992[1] = v1094;
                    v992[2] = v1103;
                    v992[3] = v1080;
                    v992[4] = 0LL;
                    v992[5] = v1098;
                    v992[6] = 0LL;
                    v992[7] = v1139;
                    v992[8] = v1074;
                    v992[9] = v1083;
                    *((_DWORD *)v992 + 20) = 0;
                    *((_DWORD *)v992 + 21) = v1157;
                    *((_DWORD *)v992 + 22) = v1203;
                    *((_DWORD *)v992 + 23) = 0;
                    *((_WORD *)v992 + 48) = v1090;
                    *((_WORD *)v992 + 49) = v1125;
                    *((_BYTE *)v992 + 100) = v1077;
                    *((_BYTE *)v992 + 103) = BYTE2(__src[0]);
                    *(_WORD *)((char *)v992 + 101) = __src[0];
                    v992[13] = v1110;
                    v992[14] = v1086;
                    v992[15] = v1184;
                    v992[16] = v1170;
                    v992[17] = v1117;
                    v993 = *find_entry((uint64_t)ht, (_BYTE *)v992 + 8, 8uLL, 0LL);
                    if (v993) {
                      v993 = *(void *)(v993 + 32);
                    }
                    v992[4] = v993;
                    apr_hash_set(ht, v992 + 1, 8LL, v992);
                    v992[3] = v241;
                  }

                  goto LABEL_1211;
                }

                unint64_t v246 = v1239;
                if (v242 > -10219)
                {
                  if (v242 <= -10210)
                  {
                    v247 = HIDWORD(v236);
                    if (v242 == -10218)
                    {
                      v1184 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                              + 1);
                    }

                    else if (v242 == -10215)
                    {
                      v1157 = *((_DWORD *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                              + 2);
                    }
                  }

                  else
                  {
                    v247 = HIDWORD(v236);
                    switch(v242)
                    {
                      case -10209:
                        v1074 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                                + 1);
                        break;
                      case -10202:
                        v1139 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                                + 1);
                        break;
                      case -10166:
                        v1170 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                                + 1);
                        break;
                    }
                  }
                }

                else
                {
                  v247 = HIDWORD(v236);
                  switch(v242)
                  {
                    case -15925:
                      uint64_t v248 = GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239);
                      v1083 = GTTraceFunc_argumentBytesWithMap((void *)v240, v248[8], v246);
                      break;
                    case -15924:
                      v1203 = *((_DWORD *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                              + 2);
                      break;
                    case -15923:
                      v1080 = *(void *)v240;
                      break;
                    case -15922:
                    case -15921:
                      break;
                    case -15920:
                      id v252 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v240,  *(unsigned __int8 *)(v237 + (v239 << 6) + 13),  v1239)
                             + 2);
                      v253 = v1125;
                      if (v252 != 1) {
                        v253 = v252;
                      }
                      v1125 = v253;
                      break;
                    case -15919:
                      v1077 = 1;
                      break;
                    default:
                      if (v242 == -15972 || v242 == -15969)
                      {
                        uint64_t v249 = v237 + (v239 << 6);
                        int v250 = GTTraceFunc_argumentBytesWithMap((void *)v240, *(unsigned __int8 *)(v249 + 13), v1239);
                        v235 = *(_DWORD *)HIDWORD(v236);
                        v1094 = *((void *)v250 + 1);
                        v1098 = *(void *)v250;
                        v1103 = *(void *)v240;
                        v1110 = GTTraceFunc_argumentBytesWithMap((void *)v240, v250[32], v246);
                        v1117 = *((_DWORD *)v250 + 4);
                        v1090 = *((_WORD *)v250 + 12);
                        unint64_t v251 = GTTraceFunc_argumentBytesWithMap((void *)v240, *(unsigned __int8 *)(v249 + 14), v246);
                        if (v251)
                        {
                          v1139 = *(void *)v251;
                          v1157 = *((_DWORD *)v251 + 2);
                          v1203 = *((_DWORD *)v251 + 4);
                          v1086 = v251;
                          v1170 = *((void *)v251 + 6);
                          v1184 = *((void *)v251 + 3);
                        }

                        else
                        {
                          v1086 = 0LL;
                        }

                        unint64_t v237 = v62 + 64;
                      }

                      v247 = HIDWORD(v236);
                      break;
                  }
                }

                v254 = atomic_load((unsigned int *)(v62 + 4));
                uint64_t v255 = v236 + (v254 >> 6);
                uint64_t v256 = (v247 + 1);
                unint64_t v236 = (v256 << 32) | v236;
                if ((_DWORD)v256 == v255 - 1)
                {
                  unint64_t v236 = (v256 << 32) | v256;
                  uint64_t v62 = *(void *)(v62 + 40);
                  continue;
                }

                goto LABEL_302;
              }
            }
          }

          break;
        }

        v257 = apr_palloc(p, 0x90uLL);
        *(_DWORD *)v257 = 57;
        *((_DWORD *)v257 + 1) = v235;
        v257[1] = v1094;
        v257[2] = v1103;
        v257[3] = v1080;
        v257[4] = 0LL;
        v257[5] = v1098;
        v257[6] = 0LL;
        v257[7] = v1139;
        v257[8] = v1074;
        v257[9] = v1083;
        *((_DWORD *)v257 + 20) = 0;
        *((_DWORD *)v257 + 21) = v1157;
        *((_DWORD *)v257 + 22) = v1203;
        *((_DWORD *)v257 + 23) = 0;
        *((_WORD *)v257 + 48) = v1090;
        *((_WORD *)v257 + 49) = v1125;
        *((_BYTE *)v257 + 100) = v1077;
        *((_BYTE *)v257 + 103) = BYTE2(__src[0]);
        *(_WORD *)((char *)v257 + 101) = __src[0];
        v257[13] = v1110;
        v257[14] = v1086;
        v257[15] = v1184;
        v257[16] = v1170;
        v257[17] = v1117;
        id v258 = *find_entry((uint64_t)ht, (_BYTE *)v257 + 8, 8uLL, 0LL);
        if (v258) {
          id v258 = *(void *)(v258 + 32);
        }
        v257[4] = v258;
        apr_hash_set(ht, v257 + 1, 8LL, v257);
        v257[3] = -1LL;
        goto LABEL_1211;
      case 6:
        if (!GTMTLSMBuilder_streamIntersectionRange(v1235, v1236, v37)) {
          goto LABEL_1211;
        }
        ++DWORD2(v1241);
        memset(__src, 0, 24);
        memset(&__src[2], 0, 144);
        LODWORD(__src[0]) = 83;
        *((void *)&__src[1] + 1) = -1LL;
        int v66 = *(void *)(v37 + 32);
        if (v66)
        {
          __int128 v67 = 0;
          while (1)
          {
            id v68 = atomic_load((unsigned int *)(v66 + 4));
            id v69 = v67 + (v68 >> 6) - 1;
            int v66 = *(void *)(v66 + 40);
            __int128 v67 = v69;
            if (!v66)
            {
              __int128 v67 = v69;
              goto LABEL_349;
            }
          }
        }

        else
        {
          __int128 v67 = 0;
        }

        id v69 = 0LL;
LABEL_349:
        id v259 = v67 | (unint64_t)(v69 << 32);
        while (2)
        {
          v260 = v66 + 64;
LABEL_351:
          if (v66)
          {
            if ((*(_BYTE *)(v260 + ((uint64_t)(HIDWORD(v259) - (int)v259) << 6) + 15) & 8) != 0)
            {
              uint64_t v261 = v260 + ((uint64_t)(HIDWORD(v259) - (int)v259) << 6);
              uint64_t v262 = *(void *)v261;
              if (*(void *)v261 < v1236 + v1235)
              {
                uint64_t v263 = *(_DWORD *)(v261 + 8);
                if (v263 > -15600)
                {
                  if (v263 != -15596 && v263 != -15599) {
                    goto LABEL_366;
                  }
                  goto LABEL_361;
                }

                if (v263 == -15607)
                {
LABEL_361:
                  if (v1235 <= v262)
                  {
                    v265 = apr_palloc(p, 0xB0uLL);
                    uint64_t v267 = __src[1];
                    uint64_t v266 = __src[2];
                    *(_OWORD *)v265 = __src[0];
                    *((_OWORD *)v265 + 1) = v267;
                    *((_OWORD *)v265 + 2) = v266;
                    v268 = __src[6];
                    v270 = __src[3];
                    uint64_t v269 = __src[4];
                    *((_OWORD *)v265 + 5) = __src[5];
                    *((_OWORD *)v265 + 6) = v268;
                    *((_OWORD *)v265 + 3) = v270;
                    *((_OWORD *)v265 + 4) = v269;
                    uint64_t v271 = __src[10];
                    uint64_t v273 = __src[7];
                    uint64_t v272 = __src[8];
                    *((_OWORD *)v265 + 9) = __src[9];
                    *((_OWORD *)v265 + 10) = v271;
                    *((_OWORD *)v265 + 7) = v273;
                    *((_OWORD *)v265 + 8) = v272;
                    uint64_t v274 = *find_entry((uint64_t)ht, (_BYTE *)v265 + 8, 8uLL, 0LL);
                    if (v274) {
                      uint64_t v274 = *(void *)(v274 + 32);
                    }
                    v265[4] = v274;
                    apr_hash_set(ht, v265 + 1, 8LL, v265);
                    v265[3] = v262;
                  }

LABEL_197:
      if (pool_high == -15597)
      {
        *(void *)buf = *(void *)&v88[1].nelts;
        *(void *)&v696.st_dev = 16LL;
        AppendString_10195((const char **)&buf[8], (uint64_t)&v88[1].pool + 4, (uint64_t *)&v696.st_dev);
        uint64_t DeviceObjectStreamRef = GetDeviceObjectStreamRef((uint64_t)&v695, *(uint64_t *)buf);
        uint64_t v176 = apr_palloc(*(apr_pool_t **)v73, 8uLL);
        *uint64_t v176 = DeviceObjectStreamRef;
        apr_hash_set(v73, v176, 8LL, &RecordVisibleFunctionTableMutation_sValue);
        int v66 = pool;
      }

      else
      {
        int v66 = pool;
        if (pool_high != -15598) {
          goto LABEL_202;
        }
        uint64_t v173 = GetDeviceObjectStreamRef((uint64_t)&v695, *(void *)&v88[1].nelts);
        id v174 = apr_palloc(*(apr_pool_t **)v73, 8uLL);
        *id v174 = v173;
        apr_hash_set(v73, v174, 8LL, &RecordVisibleFunctionTableMutation_sValue);
      }

      int pool_high = HIDWORD(v88->pool);
LABEL_202:
      if (pool_high > -15531)
      {
        if (pool_high > -15259)
        {
          if (pool_high != -15258)
          {
            int v177 = -15257;
            goto LABEL_216;
          }
        }

        else if (pool_high != -15530)
        {
          int v177 = -15529;
LABEL_216:
          if (pool_high != v177) {
            goto LABEL_219;
          }
        }

LABEL_274:
  uint64_t v202 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v202))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v202,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-2-restore",  (const char *)&unk_3189BB,  buf,  2u);
  }

  apr_pool_clear(p);
  uint64_t v203 = atomic_load((unint64_t *)(*(void *)&v695.st_uid + 72LL));
  *((void *)v682 + 10) = v64;
  *((void *)v682 + 11) = v203 - v64;
  while (v692 && v692->nelts)
    GroupBuilder_popGroup((uint64_t)v690, v203);
  *((void *)v682 + 14) = v691;
  apr_pool_destroy(p);
  uint64_t v204 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v204))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v204,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "BuildMemoryMap",  buf,  2u);
  }

  uint64_t v205 = *(void *)&v695.st_uid;
  pthread_mutex_lock(*(pthread_mutex_t **)&v695.st_uid);
  id v206 = apr_hash_copy(v66, *(const apr_hash_t **)(v205 + 88));
  pthread_mutex_unlock((pthread_mutex_t *)v205);
  *((void *)v682 + 1) = v206;
  uint64_t v207 = apr_hash_make(v66);
  *((void *)v206 + 3) = 0LL;
  *((void *)v206 + 4) = 0LL;
  *((void *)v206 + 2) = v206;
  *((_DWORD *)v206 + 10) = 0;
  uint64_t v208 = apr_hash_next((apr_hash_t *)((char *)v206 + 16));
  if (v208)
  {
    v209 = v208;
    do
    {
      for (uint64_t i = *(void *)(*(void *)(*(void *)(*((void *)v209 + 1) + 32LL) + 24LL) + 8LL); i; uint64_t i = *(void *)(i + 40))
      {
        unsigned int v211 = atomic_load((unsigned int *)(i + 4));
        int v212 = v211 - 64;
        if ((int)(v211 - 64) >= 1)
        {
          id v213 = (_DWORD *)(i + 64);
          do
          {
            apr_hash_set(v207, v213, 9LL, v213);
            signed int v214 = (v213[3] + 23) & 0xFFFFFFF8;
            id v213 = (_DWORD *)((char *)v213 + v214);
            BOOL v215 = __OFSUB__(v212, v214);
            v212 -= v214;
          }

          while (!((v212 < 0) ^ v215 | (v212 == 0)));
        }
      }

      v209 = apr_hash_next(v209);
    }

    while (v209);
  }

  *((void *)v682 + 2) = v207;
  uint64_t v216 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v216))
  {
    int v217 = *(_DWORD *)(*((void *)v682 + 2) + 48LL);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v217;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v216,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "%d",  buf,  8u);
  }

  unint64_t v218 = *((void *)v682 + 10);
  v219 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v219))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v219,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "OrderDispatchCommandBuffers",  buf,  2u);
  }

  uint64_t v220 = *((void *)v682 + 1);
  unint64_t v222 = *((void *)v682 + 10);
  uint64_t v221 = *((void *)v682 + 11);
  id v223 = apr_array_make(v66, v221, 64);
  v223->int nelts = v221;
  *(_DWORD *)(v220 + 40) = 0;
  *(void *)(v220 + 16) = v220;
  *(void *)(v220 + 24) = 0LL;
  *(void *)(v220 + 32) = 0LL;
  v224 = apr_hash_next((apr_hash_index_t *)(v220 + 16));
  if (v224)
  {
    unint64_t v225 = v221 + v222;
    do
    {
      for (uint64_t j = *(void *)(*(void *)(*((void *)v224 + 1) + 32LL) + 32LL); j; uint64_t j = *(void *)(j + 40))
      {
        unsigned int v227 = atomic_load((unsigned int *)(j + 4));
        int v228 = (v227 >> 6) - 1;
        if (v227 >> 6 == 1)
        {
          uint64_t v229 = 0LL;
        }

        else
        {
          uint64_t v229 = v228;
          id v230 = (char *)(j + (v227 & 0xFFFFFFC0) - 49);
          do
          {
            char v231 = *v230;
            v230 -= 64;
            if ((v231 & 8) != 0) {
              break;
            }
            --v229;
          }

          while (v229);
        }

        if (v227 < 0x80)
        {
          unint64_t v232 = j + 64;
        }

        else
        {
          unint64_t v232 = j + 64;
          do
          {
            unsigned int v233 = v228 >> 1;
            v234 = (unint64_t *)(v232 + (v228 >> 1 << 6));
            unint64_t v236 = *v234;
            v235 = v234 + 8;
            v228 += ~(v228 >> 1);
            if (v236 < v222) {
              unint64_t v232 = (unint64_t)v235;
            }
            else {
              int v228 = v233;
            }
          }

          while (v228 > 0);
        }

        unint64_t v237 = j + 64 + (v229 << 6);
        while (v232 < v237)
        {
          if (*(void *)v232 < v222 || *(void *)v232 >= v225) {
            goto LABEL_320;
          }
          v239 = &v223->elts[64 * (*(void *)v232 - v222)];
          __int128 v240 = *(_OWORD *)v232;
          __int128 v241 = *(_OWORD *)(v232 + 16);
          __int128 v242 = *(_OWORD *)(v232 + 48);
          *((_OWORD *)v239 + 2) = *(_OWORD *)(v232 + 32);
          *((_OWORD *)v239 + 3) = v242;
          *(_OWORD *)v239 = v240;
          *((_OWORD *)v239 + 1) = v241;
          v232 += 64LL;
        }
      }

LABEL_320:
      v224 = apr_hash_next(v224);
    }

    while (v224);
  }

  *((void *)v682 + 15) = v223;
  uint64_t v243 = *((void *)v682 + 1);
  uint64_t v244 = *((void *)v682 + 2);
  v680 = apr_array_make(v66, 8, 8);
  if (!v223->nelts) {
    goto LABEL_375;
  }
  unint64_t v246 = *(void *)v223->elts;
  apr_pool_create_ex((apr_pool_t **)buf, v66, 0LL, v245);
  v247 = *(apr_pool_t **)buf;
  v674 = apr_hash_make(*(apr_pool_t **)buf);
  if (v223->nelts < 1) {
    goto LABEL_374;
  }
  uint64_t v248 = 0LL;
  do
  {
    uint64_t v249 = (uint64_t)&v223->elts[64 * v248];
    int v250 = *(_DWORD *)(v249 + 8);
    if (v250 <= -15909)
    {
      if (v250 == -16362)
      {
        *(void *)&v696.st_dev = GTTraceFunc_targetContext(v249, v244);
        v265 = find_entry(v243, &v696, 8uLL, 0LL);
        if (*v265
          && (uint64_t v266 = *(void *)(*v265 + 32LL)) != 0
          && (uint64_t v267 = *(void *)(v266 + 32)) != 0
          && (*(_BYTE *)(v267 + 79) & 8) != 0)
        {
          v268 = (unint64_t *)(v267 + 64);
        }

        else
        {
          v268 = 0LL;
        }

        if (v246 <= *v268)
        {
          uint64_t v269 = GTTraceFunc_targetContext((uint64_t)v268, v244);
          QueueForRef = GetQueueForRef((apr_pool_t **)v674, (uint64_t)v269);
          uint64_t v271 = *(void *)&v696.st_dev;
          *(void *)apr_array_push(QueueForRef) = v271;
        }

        goto LABEL_369;
      }

      if (v250 != -16361 && v250 != -16202) {
        goto LABEL_369;
      }
    }

    else if (((v250 + 15343) > 0x1B || ((1 << (v250 - 17)) & 0xA000001) == 0) && v250 != -15908)
    {
      goto LABEL_369;
    }

    *(void *)&v696.st_dev = GTTraceFunc_targetContext(v249, v244);
    v254 = find_entry(v243, &v696, 8uLL, 0LL);
    if (*v254
      && (uint64_t v255 = *(void *)(*v254 + 32LL)) != 0
      && (uint64_t v256 = *(void *)(v255 + 32)) != 0
      && (*(_BYTE *)(v256 + 79) & 8) != 0)
    {
      v257 = (unint64_t *)(v256 + 64);
    }

    else
    {
      v257 = 0LL;
    }

    if (v246 <= *v257)
    {
      id v258 = GTTraceFunc_targetContext((uint64_t)v257, v244);
      id v259 = GetQueueForRef((apr_pool_t **)v674, (uint64_t)v258);
      v260 = v259;
      uint64_t v261 = *(void *)&v696.st_dev;
      uint64_t v262 = v259->nelts;
      uint64_t v263 = 0LL;
      uint64_t v264 = v259->elts;
      while (*(void *)&v264[8 * v263] != *(void *)&v696.st_dev)
      {
        if (v262 == ++v263) {
          goto LABEL_358;
        }
      }

      if ((_DWORD)v262 == (_DWORD)v263)
      {
LABEL_358:
        *(void *)apr_array_push(v260) = v261;
        uint64_t v264 = v260->elts;
        LODWORD(v272) = v260->nelts;
      }

      else
      {
        LODWORD(v272) = v262;
        LODWORD(v262) = v263;
      }

      *(void *)&v264[8 * (int)v262] |= 0x8000000000000000LL;
      int v66 = pool;
      if ((int)v272 < 1)
      {
        LODWORD(v274) = 0;
      }

      else
      {
        uint64_t v273 = *(void *)v264;
        if ((*(void *)v264 & 0x8000000000000000LL) != 0)
        {
          uint64_t v275 = 1LL;
          do
          {
            uint64_t v274 = v275;
            *(void *)apr_array_push(v680) = v273 & 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v272 = v260->nelts;
            uint64_t v264 = v260->elts;
            if (v274 >= v272) {
              break;
            }
            uint64_t v273 = *(void *)&v264[8 * v274];
            uint64_t v275 = v274 + 1;
          }

          while (v273 < 0);
        }

        else
        {
          LODWORD(v274) = 0;
        }

        int v66 = pool;
      }

      int v276 = v272 - v274;
      v260->int nelts = v276;
      memmove(v264, &v264[8 * v274], v260->elt_size * (uint64_t)v276);
    }

LABEL_369:
    ++v248;
  }

  while (v248 < v223->nelts);
  v247 = *(apr_pool_t **)buf;
LABEL_374:
  apr_pool_destroy(v247);
LABEL_375:
  uint64_t v278 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v278))
  {
    int v279 = *(_DWORD *)(*((void *)v682 + 15) + 12LL);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v279;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v278,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "%d",  buf,  8u);
  }

  v280 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v280))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v280,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "BuildDeviceMirror",  buf,  2u);
  }

  *((void *)v682 + 5) = GTMTLSMContext_buildDeviceMirrorWithIgnoreFlags( *((void *)v682 + 1),  *((void *)v682 + 2),  *((void *)v682 + 15),  *((void *)v682 + 10),  *((void *)v682 + 11),  v66);
  v281 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v281))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v281,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
  }

  *((void *)v682 + 12) = 0LL;
  uint64_t v282 = *((void *)v682 + 14);
  v675 = (apr_hash_t *)*((void *)v682 + 15);
  *((void *)v682 + 13) = *((int *)v675 + 3);
  int v283 = *(_DWORD *)(v282 + 12);
  if (v283 >= 1)
  {
    arrd = 0LL;
    id v284 = 0LL;
    char v285 = 0;
    int v286 = 0;
    int v287 = 0;
    uint64_t v288 = *(void *)(v282 + 24);
    while (1)
    {
      uint64_t v289 = v288 + 32LL * v287;
      int v290 = *(_DWORD *)(v289 + 28);
      int v291 = GetFuncEnumConstructorType(v290);
      if (v291 == 51) {
        break;
      }
      if (v291 == 25)
      {
        v292 = *(apr_array_header_t **)v289;
        if ((*(_BYTE *)(*((void *)v675 + 3) + (*(void *)v289 << 6) + 15LL) & 0x40) == 0 || v290 == -12544)
        {
          char v293 = v285 | (v286 == 0);
          id v284 = arrd;
          goto LABEL_391;
        }

        goto LABEL_394;
      }

LABEL_395:
      if (++v287 >= v283) {
        goto LABEL_396;
      }
    }

    v292 = *(apr_array_header_t **)v289;
    if ((*(_BYTE *)(*((void *)v675 + 3) + (*(void *)v289 << 6) + 15LL) & 0x40) == 0 || v290 == -12543)
    {
      char v293 = v285 | (v286 == 0);
LABEL_391:
      if ((v293 & 1) == 0)
      {
        *((void *)v682 + 12) = v292;
        arrd = v292;
        id v284 = v292;
      }

      *((void *)v682 + 13) = *(void *)(v288 + 32LL * v287 + 8) - (void)v284 + 1LL;
      char v285 = 1;
    }

LABEL_394:
    v287 += *(_DWORD *)(v288 + 32LL * v287 + 20);
    ++v286;
    goto LABEL_395;
  }

LABEL_396:
  uint64_t v294 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v294))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v294,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "Delta",  buf,  2u);
  }

  v295 = apr_array_make(pool, 128, 8);
  *((void *)v682 + 25) = v295;
  GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v682 + 5) + 200LL), v218, v295);
  uint64_t v296 = v295->nelts;
  if ((int)v296 >= 1)
  {
    unint64_t v297 = v296 + 1;
    do
    {
      uint64_t v298 = (v297 - 2);
      v299 = v295->elts;
      if (*(_BYTE *)(*(void *)&v299[8 * v298] + 60LL) != 1)
      {
        LODWORD(v296) = v296 - 1;
        v295->int nelts = v296;
        *(void *)&v299[8 * v298] = *(void *)&v299[8 * (int)v296];
      }

      --v297;
    }

    while (v297 > 1);
  }

  uint64_t v300 = 0LL;
  v301 = (apr_array_header_t *)*((void *)v682 + 25);
  uint64_t v302 = *((void *)v682 + 5);
  unint64_t v303 = *((void *)v682 + 10);
  unint64_t v304 = v303 + *((void *)v682 + 11);
  do
  {
    uint64_t v305 = *(void *)(v302 + 8 * v300 + 8);
    int v306 = *(_DWORD *)(v305 + 12);
    if (v306 >= 1)
    {
      for (uint64_t k = 0LL; k < v306; ++k)
      {
        uint64_t v308 = *(void *)(*(void *)(v305 + 24) + 8 * k);
        unint64_t v309 = *(void *)(v308 + 16);
        BOOL v310 = v303 <= v309 && v304 > v309;
        if (!v310)
        {
          unint64_t v311 = *(void *)(v308 + 24);
          if (v303 <= v311 && v304 > v311)
          {
            *(void *)apr_array_push(v301) = v308;
            int v306 = *(_DWORD *)(v305 + 12);
          }
        }
      }
    }

    ++v300;
  }

  while (v300 != 35);
  unint64_t v313 = *((void *)v682 + 8);
  uint64_t v314 = *((void *)v682 + 9);
  uint64_t v315 = v301->nelts;
  v301->int nelts = 0;
  if ((int)v315 < 1)
  {
    int v317 = 0;
    unint64_t v320 = pool;
  }

  else
  {
    uint64_t v316 = 0LL;
    int v317 = 0;
    unint64_t v318 = v314 + v313;
    uint64_t v319 = 8 * v315;
    unint64_t v320 = pool;
    do
    {
      char v321 = v301->elts;
      uint64_t v322 = *(void *)&v321[v316];
      unint64_t v323 = *(void *)(v322 + 16);
      if (v313 > v323 || v318 <= v323)
      {
        v301->int nelts = v317 + 1;
        *(void *)&v321[v316] = *(void *)&v321[8 * v317];
        *(void *)&v301->elts[8 * v317++] = v322;
      }

      v316 += 8LL;
    }

    while (v319 != v316);
  }

  qsort(v301->elts, v317, 8uLL, (int (__cdecl *)(const void *, const void *))GTMTLSMObject_compare);
  GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v682 + 5) + 120LL), v218, v301);
  GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v682 + 5) + 136LL), v218, v301);
  GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v682 + 5) + 128LL), v218, v301);
  v325 = apr_array_make(v320, 128, 8);
  uint64_t v326 = 0LL;
  *((void *)v682 + 24) = v325;
  uint64_t v327 = *((void *)v682 + 5);
  unint64_t v328 = *((void *)v682 + 10);
  unint64_t v329 = v328 + *((void *)v682 + 11);
  do
  {
    uint64_t v330 = *(void *)(v327 + 8 * v326 + 8);
    int v331 = *(_DWORD *)(v330 + 12);
    if (v331 >= 1)
    {
      for (uint64_t m = 0LL; m < v331; ++m)
      {
        uint64_t v333 = *(void *)(*(void *)(v330 + 24) + 8 * m);
        unint64_t v334 = *(void *)(v333 + 16);
        if (v328 <= v334 && v329 > v334)
        {
          *(void *)apr_array_push(v325) = v333;
          int v331 = *(_DWORD *)(v330 + 12);
        }
      }
    }

    ++v326;
  }

  while (v326 != 35);
  char v336 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v336))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v336,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
  }

  v337 = newpool;
  int v338 = apr_array_make(newpool, 128, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v682 + 5) + 56LL), v218, v338);
  if (v338->nelts >= 1)
  {
    uint64_t v339 = 0LL;
    unsigned int v340 = (apr_hash_t *)*((void *)v682 + 21);
    do
    {
      *(void *)buf = *(void *)(*(void *)&v338->elts[8 * v339] + 8LL);
      uint64_t v341 = *find_entry((uint64_t)v340, buf, 8uLL, 0LL);
      if (!v341 || (v342 = *(apr_array_header_t **)(v341 + 32)) == 0LL)
      {
        v342 = apr_array_make(pool, 8, 16);
        uint64_t v343 = apr_palloc(pool, 8uLL);
        *uint64_t v343 = *(void *)buf;
        apr_hash_set(v340, v343, 8LL, v342);
      }

      v344 = apr_array_push(v342);
      uint64_t v345 = *((void *)v682 + 10);
      void *v344 = 0LL;
      v344[1] = v345;
      ++v339;
    }

    while (v339 < v338->nelts);
  }

  v346 = apr_array_make(v337, 128, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v682 + 5) + 64LL), v218, v346);
  if (v346->nelts >= 1)
  {
    uint64_t v347 = 0LL;
    v348 = (apr_hash_t *)*((void *)v682 + 22);
    do
    {
      *(void *)buf = *(void *)(*(void *)&v346->elts[8 * v347] + 8LL);
      uint64_t v349 = *find_entry((uint64_t)v348, buf, 8uLL, 0LL);
      if (!v349 || (v350 = *(apr_array_header_t **)(v349 + 32)) == 0LL)
      {
        v350 = apr_array_make(pool, 8, 16);
        v351 = apr_palloc(pool, 8uLL);
        void *v351 = *(void *)buf;
        apr_hash_set(v348, v351, 8LL, v350);
      }

      v352 = apr_array_push(v350);
      uint64_t v353 = *((void *)v682 + 10);
      void *v352 = 0LL;
      v352[1] = v353;
      ++v347;
    }

    while (v347 < v346->nelts);
  }

  arre = (apr_array_header_t *)v337;
  v354 = apr_hash_make(pool);
  v355 = v682;
  uint64_t v356 = *((void *)v682 + 5);
  v357 = *(apr_hash_t **)(v356 + 200);
  int v358 = *((_DWORD *)v357 + 3);
  if (v358 >= 1)
  {
    uint64_t v359 = 0LL;
    uint64_t v360 = *(void *)(*((void *)v682 + 14) + 24LL) + 32LL * *(int *)(*((void *)v682 + 14) + 12LL);
    v676 = *(apr_hash_t **)(v356 + 200);
    do
    {
      uint64_t v361 = *(void *)(*((void *)v357 + 3) + 8 * v359);
      if (*(_BYTE *)(v361 + 60) == 1)
      {
        id v363 = (uint64_t *)(v361 + 32);
        uint64_t v362 = *(void *)(v361 + 32);
        if (v362)
        {
          int v364 = 0LL;
          do
          {
            uint64_t v365 = *((void *)v355 + 14);
            uint64_t v366 = *(void **)(v365 + 24);
            int v367 = *(_DWORD *)(v365 + 12);
            if (v367 >= 1)
            {
              do
              {
                uint64_t v368 = v367 >> 1;
                v369 = &v366[4 * v368];
                unint64_t v371 = *v369;
                v370 = v369 + 4;
                v367 += ~(v367 >> 1);
                if (v371 <= *(_DWORD *)(v362 + 24) - *((_DWORD *)v355 + 20)) {
                  uint64_t v366 = v370;
                }
                else {
                  int v367 = v368;
                }
              }

              while (v367 > 0);
            }

            if (v366 != (void *)v360 && v366 != v364)
            {
              uint64_t v373 = *(void *)(*((void *)v355 + 15) + 24LL) + (*v366 << 6);
              *(void *)buf = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v373,  *(unsigned __int8 *)(v373 + 13),  *((void *)v355 + 2))
                               + 1);
              uint64_t v374 = *find_entry((uint64_t)v354, buf, 8uLL, 0LL);
              if (!v374 || (id v375 = *(apr_array_header_t **)(v374 + 32)) == 0LL)
              {
                id v375 = apr_array_make(pool, 1, 8);
                id v376 = apr_palloc(pool, 8uLL);
                *id v376 = *(void *)buf;
                apr_hash_set(v354, v376, 8LL, v375);
              }

              *(void *)apr_array_push(v375) = v361;
              uint64_t v362 = *v363;
              int v364 = v366;
              v355 = v682;
            }

            uint64_t v361 = v362;
            id v363 = (uint64_t *)(v362 + 32);
            uint64_t v362 = *(void *)(v362 + 32);
          }

          while (v362);
          v357 = v676;
          int v358 = *((_DWORD *)v676 + 3);
        }
      }

      ++v359;
    }

    while (v359 < v358);
  }

  *((void *)v355 + 23) = v354;
  v377 = apr_hash_make(pool);
  *((void *)v355 + 17) = v377;
  *(void *)&v696.st_dev = 0LL;
  v378 = v664;
  id v379 = v680;
  if (v664->nelts >= 1)
  {
    uint64_t v380 = 0LL;
    LODWORD(v381) = 0;
    v382 = 0LL;
    while (1)
    {
      v383 = &v378->elts[64 * v380];
      unint64_t v385 = *((void *)v383 + 2);
      unint64_t v384 = (unint64_t *)(v383 + 16);
      if (v218 < v385) {
        break;
      }
      v378 = v664;
      if (!v382) {
        goto LABEL_481;
      }
LABEL_482:
      int v391 = v382[3] + 1;
      v382[3] = v391;
      v382[4] = v391;
      if (++v380 >= v378->nelts) {
        goto LABEL_483;
      }
    }

    uint64_t v381 = (int)v381;
    do
    {
      uint64_t v386 = *(void *)&v680->elts[8 * v381++];
      *(void *)&v696.st_dev = v386;
      uint64_t v387 = *((void *)v682 + 1);
      *(void *)buf = v386;
      v388 = find_entry(v387, buf, 8uLL, 0LL);
      unint64_t v389 = CommandBufferCommitIndex(*(void *)(*(void *)(*v388 + 32LL) + 32LL));
    }

    while (v389 < *v384);
    unint64_t v218 = v389;
    v378 = v664;
LABEL_481:
    v382 = apr_palloc(pool, 0x20uLL);
    *(void *)v382 = pool;
    v382[2] = v378->elt_size;
    v382[3] = 0;
    v382[4] = 0;
    *((void *)v382 + 3) = &v378->elts[v380 * v378->elt_size];
    v390 = apr_palloc(pool, 8uLL);
    void *v390 = *(void *)&v696.st_dev;
    apr_hash_set(v377, v390, 8LL, v382);
    goto LABEL_482;
  }

LABEL_483:
  *(void *)&v696.st_dev = 0LL;
  uint64_t v392 = *find_entry((uint64_t)v377, &v696, 8uLL, 0LL);
  if (!v392)
  {
    v394 = v682;
    *((void *)v682 + 26) = 0LL;
    v395 = (apr_array_header_t **)(v682 + 208);
    v396 = (apr_pool_t *)arre;
    goto LABEL_487;
  }

  uint64_t v393 = *(void *)(v392 + 32);
  v394 = v682;
  *((void *)v682 + 26) = v393;
  v395 = (apr_array_header_t **)(v682 + 208);
  v396 = (apr_pool_t *)arre;
  if (!v393) {
LABEL_487:
  }
    void *v395 = apr_array_make(pool, 0, 64);
  arrf = (apr_array_header_t *)v395;
  v398 = GTResourceTrackerMake(*((void *)v394 + 1), *((void *)v394 + 2), v396);
  if (v680->nelts >= 1)
  {
    uint64_t v399 = 0LL;
    do
      GTResourceTrackerProcessCommandBuffer((uint64_t)v398, *(apr_pool_t **)&v680->elts[8 * v399++], 1);
    while (v399 < v680->nelts);
  }

  if (*(_DWORD *)(v398[3] + 48))
  {
    uint64_t v400 = *v398;
    v401 = (apr_hash_index_t *)(*v398 + 16);
    *(void *)(v400 + 24) = 0LL;
    *(void *)(v400 + 32) = 0LL;
    *(void *)(v400 + 16) = v400;
    *(_DWORD *)(v400 + 40) = 0;
    v402 = apr_hash_next(v401);
    if (v402)
    {
      v403 = v402;
      do
      {
        uint64_t v404 = *(void *)(*((void *)v403 + 1) + 32LL);
        if (!v404) {
          goto LABEL_516;
        }
        uint64_t v405 = *(void *)(v404 + 32);
        if (!v405 || (*(_BYTE *)(v405 + 79) & 8) == 0) {
          goto LABEL_516;
        }
        id v406 = (uint64_t *)(v405 + 64);
        int v407 = GetFuncEnumConstructorType(*(_DWORD *)(v405 + 72));
        switch(v407)
        {
          case 16:
            memset(buf, 0, 24);
            __int128 v707 = 0u;
            __int128 v708 = 0u;
            __int128 v705 = 0u;
            __int128 v706 = 0u;
            __int128 v703 = 0u;
            __int128 v704 = 0u;
            __int128 v701 = 0u;
            __int128 v702 = 0u;
            __int128 v699 = 0u;
            __int128 v700 = 0u;
            __int128 v698 = 0u;
            *(_DWORD *)buf = 16;
            WORD1(v702) = 2;
            *(void *)&buf[24] = -1LL;
            *(void *)&__int128 v700 = -1LL;
            GTMTLSMAccelerationStructure_processTraceFuncWithMap(buf, v398[1], v406);
            if (!(void)v699) {
              goto LABEL_516;
            }
            uint64_t v416 = *find_entry(v398[3], &v699, 8uLL, 0LL);
            if (!v416) {
              goto LABEL_516;
            }
            uint64_t v417 = *(void *)(v416 + 32);
            if (!v417) {
              goto LABEL_516;
            }
            unint64_t v410 = *(void *)(v417 + 8);
            uint64_t v411 = *(void *)&buf[8];
            v412 = v398;
            int v413 = 16;
            break;
          case 80:
            memset(buf, 0, 24);
            __int128 v707 = 0u;
            __int128 v708 = 0u;
            __int128 v705 = 0u;
            __int128 v706 = 0u;
            __int128 v703 = 0u;
            __int128 v704 = 0u;
            __int128 v701 = 0u;
            __int128 v702 = 0u;
            __int128 v699 = 0u;
            __int128 v700 = 0u;
            __int128 v698 = 0u;
            *(_DWORD *)buf = 80;
            WORD1(v702) = 2;
            *(void *)&buf[24] = -1LL;
            *(void *)&__int128 v700 = -1LL;
            uint64_t v709 = 0xFFFFFFFFLL;
            GTMTLSMTexture_processTraceFuncWithMap(buf, v398[1], v406);
            if (!(void)v699) {
              goto LABEL_516;
            }
            uint64_t v414 = *find_entry(v398[3], &v699, 8uLL, 0LL);
            if (!v414) {
              goto LABEL_516;
            }
            uint64_t v415 = *(void *)(v414 + 32);
            if (!v415) {
              goto LABEL_516;
            }
            unint64_t v410 = *(void *)(v415 + 8);
            uint64_t v411 = *(void *)&buf[8];
            v412 = v398;
            int v413 = 80;
            break;
          case 22:
            memset(buf, 0, 24);
            __int128 v702 = 0u;
            __int128 v703 = 0u;
            __int128 v704 = 0u;
            __int128 v705 = 0u;
            __int128 v700 = 0u;
            __int128 v701 = 0u;
            __int128 v698 = 0u;
            __int128 v699 = 0u;
            *(_DWORD *)buf = 22;
            WORD1(v702) = 2;
            *(void *)&buf[24] = -1LL;
            *(void *)&__int128 v700 = -1LL;
            *(void *)&__int128 v703 = -1LL;
            GTMTLSMBuffer_processTraceFuncWithMap(buf, v398[1], v406);
            if (!(void)v699) {
              goto LABEL_516;
            }
            uint64_t v408 = *find_entry(v398[3], &v699, 8uLL, 0LL);
            if (!v408) {
              goto LABEL_516;
            }
            uint64_t v409 = *(void *)(v408 + 32);
            if (!v409) {
              goto LABEL_516;
            }
            unint64_t v410 = *(void *)(v409 + 8);
            uint64_t v411 = *(void *)&buf[8];
            v412 = v398;
            int v413 = 22;
            break;
          default:
            goto LABEL_516;
        }

        GTResourceTrackerResourceRead(v412, v413, v411, v410);
LABEL_516:
        v403 = apr_hash_next(v403);
      }

      while (v403);
    }

    apr_hash_clear((apr_hash_t *)v398[3]);
    id v379 = v680;
  }

  apr_pool_create_ex((apr_pool_t **)&v696, *(apr_pool_t **)v398[4], 0LL, v397);
  v418 = *(apr_pool_t **)&v696.st_dev;
  v419 = apr_array_make(*(apr_pool_t **)&v696.st_dev, 16, 8);
  uint64_t v420 = v398[4];
  *(_DWORD *)(v420 + 40) = 0;
  *(void *)(v420 + 16) = v420;
  *(void *)(v420 + 24) = 0LL;
  *(void *)(v420 + 32) = 0LL;
  v421 = apr_hash_next((apr_hash_index_t *)(v420 + 16));
  if (v421)
  {
    v422 = v421;
    do
    {
      uint64_t v423 = *(void *)(*((void *)v422 + 1) + 32LL);
      if (*(_DWORD *)(v423 + 40) == 16) {
        *(void *)apr_array_push(v419) = v423;
      }
      v422 = apr_hash_next(v422);
    }

    while (v422);
  }

  if (v419->nelts >= 1)
  {
    uint64_t v424 = 0LL;
    do
    {
      uint64_t v425 = *(void *)&v419->elts[8 * v424];
      memset(buf, 0, 24);
      __int128 v707 = 0u;
      __int128 v708 = 0u;
      __int128 v705 = 0u;
      __int128 v706 = 0u;
      __int128 v703 = 0u;
      __int128 v704 = 0u;
      __int128 v701 = 0u;
      __int128 v702 = 0u;
      __int128 v699 = 0u;
      __int128 v700 = 0u;
      __int128 v698 = 0u;
      *(_DWORD *)buf = 16;
      WORD1(v702) = 2;
      *(void *)&buf[24] = -1LL;
      *(void *)&__int128 v700 = -1LL;
      uint64_t v426 = *(void *)(*(void *)(*find_entry(*v398, (_BYTE *)(v425 + 8), 8uLL, 0LL) + 32LL) + 32LL);
      if (v426)
      {
        unsigned int v427 = 0;
        while (1)
        {
          unsigned int v428 = atomic_load((unsigned int *)(v426 + 4));
          uint64_t v429 = v427 + (v428 >> 6) - 1;
          uint64_t v426 = *(void *)(v426 + 40);
          unsigned int v427 = v429;
          if (!v426)
          {
            unsigned int v427 = v429;
            goto LABEL_532;
          }
        }
      }

      else
      {
        unsigned int v427 = 0;
      }

      uint64_t v429 = 0LL;
LABEL_532:
      unint64_t v430 = v427 | (unint64_t)(v429 << 32);
LABEL_533:
      uint64_t v431 = v426 + 64;
      while (v426 && (*(_BYTE *)(v431 + ((uint64_t)(HIDWORD(v430) - (int)v430) << 6) + 15) & 8) != 0)
      {
        uint64_t v432 = v431 + ((uint64_t)(HIDWORD(v430) - (int)v430) << 6);
        GTMTLSMAccelerationStructure_processTraceFuncWithMap(buf, v398[1], (uint64_t *)v432);
        if (*(_DWORD *)(v432 + 8) == -15552 && (void)v703 != 0LL) {
          GTResourceTrackerUsingAccelerationStructureDescriptor(v398, (uint64_t *)v703, *(void *)v432);
        }
        unsigned int v434 = atomic_load((unsigned int *)(v426 + 4));
        int v435 = v430 + (v434 >> 6);
        uint64_t v436 = (HIDWORD(v430) + 1);
        unint64_t v430 = (v436 << 32) | v430;
        if ((_DWORD)v436 == v435 - 1)
        {
          unint64_t v430 = (v436 << 32) | v436;
          uint64_t v426 = *(void *)(v426 + 40);
          goto LABEL_533;
        }
      }

      ++v424;
    }

    while (v424 < v419->nelts);
    v418 = *(apr_pool_t **)&v696.st_dev;
    id v379 = v680;
  }

  apr_pool_destroy(v418);
  apr_pool_create_ex((apr_pool_t **)&v696, *(apr_pool_t **)v398[4], 0LL, v437);
  __int128 v438 = *(apr_pool_t **)&v696.st_dev;
  __int128 v439 = apr_array_make(*(apr_pool_t **)&v696.st_dev, 16, 16);
  __int128 v440 = apr_hash_make(v438);
  uint64_t v441 = v398[2];
  *(_DWORD *)(v441 + 40) = 0;
  *(void *)(v441 + 16) = v441;
  *(void *)(v441 + 24) = 0LL;
  *(void *)(v441 + 32) = 0LL;
  v442 = apr_hash_next((apr_hash_index_t *)(v441 + 16));
  if (v442)
  {
    v443 = v442;
    v677 = v440;
    do
    {
      v444 = *(_DWORD **)(*((void *)v443 + 1) + 32LL);
      int v445 = v444[2];
      if (v445 == 2)
      {
        uint64_t v449 = *(void *)(*find_entry(*v398, *(_BYTE **)(*((void *)v443 + 1) + 32LL), 8uLL, 0LL) + 32LL);
        memset(buf, 0, 24);
        __int128 v698 = 0u;
        *(_DWORD *)buf = 2;
        *(void *)&__int128 v699 = 0LL;
        *(void *)&buf[24] = -1LL;
        uint64_t v450 = *(void *)(v449 + 32);
        if (v450)
        {
          unsigned int v451 = 0;
          while (1)
          {
            unsigned int v452 = atomic_load((unsigned int *)(v450 + 4));
            uint64_t v453 = v451 + (v452 >> 6) - 1;
            uint64_t v450 = *(void *)(v450 + 40);
            unsigned int v451 = v453;
            if (!v450)
            {
              unsigned int v451 = v453;
              goto LABEL_562;
            }
          }
        }

        else
        {
          unsigned int v451 = 0;
        }

        uint64_t v453 = 0LL;
LABEL_562:
        unint64_t v454 = v451 | (unint64_t)(v453 << 32);
LABEL_563:
        uint64_t v455 = v450 + 64;
        while (v450)
        {
          uint64_t v456 = v455 + ((uint64_t)(HIDWORD(v454) - (int)v454) << 6);
          GTMTLSMDrawable_processTraceFuncWithMap(buf, v398[1], (uint64_t *)v456);
          if (*(_DWORD *)(v456 + 8) == -7167) {
            break;
          }
          unsigned int v457 = atomic_load((unsigned int *)(v450 + 4));
          int v458 = v454 + (v457 >> 6);
          uint64_t v459 = (HIDWORD(v454) + 1);
          unint64_t v454 = (v459 << 32) | v454;
          if ((_DWORD)v459 == v458 - 1)
          {
            unint64_t v454 = (v459 << 32) | v459;
            uint64_t v450 = *(void *)(v450 + 40);
            goto LABEL_563;
          }
        }

        __int128 v438 = *(apr_pool_t **)&v696.st_dev;
        __int128 v460 = apr_palloc(*(apr_pool_t **)&v696.st_dev, 8uLL);
        *__int128 v460 = v699;
        __int128 v440 = v677;
        apr_hash_set(v677, v460, 8LL, v444);
        id v379 = v680;
      }

      else if (v445 == 80)
      {
        uint64_t v446 = *find_entry(*v398, *(_BYTE **)(*((void *)v443 + 1) + 32LL), 8uLL, 0LL);
        if (v446)
        {
          uint64_t v447 = *(void *)(v446 + 32);
          if (v447)
          {
            uint64_t v448 = *(void *)(v447 + 32);
            if (v448)
            {
              if ((*(_BYTE *)(v448 + 79) & 8) != 0)
              {
                memset(buf, 0, 24);
                __int128 v707 = 0u;
                __int128 v708 = 0u;
                __int128 v705 = 0u;
                __int128 v706 = 0u;
                __int128 v703 = 0u;
                __int128 v704 = 0u;
                __int128 v701 = 0u;
                __int128 v702 = 0u;
                __int128 v699 = 0u;
                __int128 v700 = 0u;
                __int128 v698 = 0u;
                *(_DWORD *)buf = 80;
                WORD1(v702) = 2;
                *(void *)&buf[24] = -1LL;
                *(void *)&__int128 v700 = -1LL;
                uint64_t v709 = 0xFFFFFFFFLL;
                GTMTLSMTexture_processTraceFuncWithMap(buf, v398[1], (uint64_t *)(v448 + 64));
                if ((void)v708 || *((void *)&v702 + 1) && *(_BYTE *)(*((void *)&v702 + 1) + 44LL)) {
                  *(_OWORD *)apr_array_push(v439) = *(_OWORD *)v444;
                }
              }
            }
          }
        }
      }

      v443 = apr_hash_next(v443);
    }

    while (v443);
  }

  int v461 = v439->nelts;
  if (v461 < 1)
  {
    v463 = pool;
    if (!v461) {
      goto LABEL_614;
    }
  }

  else
  {
    int v462 = 0;
    v463 = pool;
    do
    {
      v464 = find_entry((uint64_t)v440, &v439->elts[16 * v462], 8uLL, 0LL);
      if (*v464 && *(void *)(*v464 + 32LL))
      {
        uint64_t v465 = v439->nelts - 1LL;
        v439->int nelts = v465;
        v466 = v439->elts;
        __int128 v467 = *(_OWORD *)&v466[16 * v462];
        *(_OWORD *)&v466[16 * v462] = *(_OWORD *)&v466[16 * v465];
        *(_OWORD *)&v439->elts[16 * v465] = v467;
      }

      else
      {
        ++v462;
      }

      int v468 = v439->nelts;
    }

    while (v462 < v468);
    if (!v468) {
      goto LABEL_614;
    }
  }

  uint64_t v469 = *v398;
  v470 = (apr_hash_index_t *)(*v398 + 16);
  *(void *)(v469 + 24) = 0LL;
  *(void *)(v469 + 32) = 0LL;
  *(void *)(v469 + 16) = v469;
  *(_DWORD *)(v469 + 40) = 0;
  v471 = apr_hash_next(v470);
  if (v471)
  {
    v472 = v471;
    do
    {
      uint64_t v473 = *(void *)(*((void *)v472 + 1) + 32LL);
      if (v473)
      {
        uint64_t v474 = *(void *)(v473 + 32);
        if (v474)
        {
          if ((*(_BYTE *)(v474 + 79) & 8) != 0 && GetFuncEnumConstructorType(*(_DWORD *)(v474 + 72)) == 2)
          {
            memset(buf, 0, 24);
            __int128 v698 = 0u;
            *(_DWORD *)buf = 2;
            *(void *)&__int128 v699 = 0LL;
            *(void *)&buf[24] = -1LL;
            GTMTLSMDrawable_processTraceFuncWithMap(buf, v398[1], (uint64_t *)(v474 + 64));
            uint64_t v475 = *(void *)(v473 + 32);
            if (v475)
            {
              unsigned int v476 = 0;
              while (1)
              {
                unsigned int v477 = atomic_load((unsigned int *)(v475 + 4));
                uint64_t v478 = v476 + (v477 >> 6) - 1;
                uint64_t v475 = *(void *)(v475 + 40);
                unsigned int v476 = v478;
                if (!v475)
                {
                  unsigned int v476 = v478;
                  goto LABEL_598;
                }
              }

              uint64_t v478 = 1LL;
            }

            else
            {
              unsigned int v476 = 0;
              uint64_t v478 = 0LL;
            }

                    uint64_t v359 = atomic_load((unsigned int *)(v78 + 4));
                    uint64_t v360 = v308 + (v359 >> 6);
                    uint64_t v361 = (v310 + 1);
                    uint64_t v308 = (v361 << 32) | v308;
                    if ((_DWORD)v361 == v360 - 1)
                    {
                      uint64_t v308 = (v361 << 32) | v361;
                      BOOL v78 = *(void *)(v78 + 40);
                      continue;
                    }

                    goto LABEL_409;
                  }

                  if (v315 <= -15848)
                  {
                    if (v315 != -16029 && v315 != -16018) {
                      goto LABEL_483;
                    }
                    uint64_t v322 = v310;
                    unint64_t v335 = v309 + (v312 << 6);
                    char v336 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v335 + 13), v1239);
                    v1222 = *(void *)v313;
                    v1205 = *v316;
                    v1172 = *(void *)v336;
                    v1186 = *((void *)v336 + 1);
                    v337 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v335 + 14), v317);
                    if (v337)
                    {
                      v1127 = (char *)*((void *)v337 + 1);
                      v1119 = v337[16];
                    }

                    v1159 = v337;
                    int v338 = GTTraceFunc_argumentBytesWithMap((void *)v313, v336[24], v317);
                    if (v338)
                    {
                      v1081 = *(_DWORD *)v338;
                      v1078 = v338 + 8;
                    }

                    v1084 = GTTraceFunc_argumentBytesWithMap((void *)v313, v336[25], v317);
                    uint64_t v326 = 4;
                  }

                  else
                  {
                    if (v315 != -15847)
                    {
                      if (v315 == -15693)
                      {
                        v350 = v309 + (v312 << 6);
                        v351 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v350 + 13), v1239);
                        v1222 = *(void *)v313;
                        v1205 = *v316;
                        v1172 = *(void *)v351;
                        v1186 = *((void *)v351 + 1);
                        v352 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v350 + 14), v317);
                        if (v352)
                        {
                          v1127 = (char *)*((void *)v352 + 1);
                          v1119 = v352[16];
                        }

                        v1159 = v352;
                        v1066 = GTTraceFunc_argumentBytesWithMap((void *)v313, v351[24], v317);
                        uint64_t v353 = GTTraceFunc_argumentBytesWithMap((void *)v313, v351[25], v317);
                        unint64_t v334 = *(_DWORD *)v353;
                        v1091 = v353 + 8;
                        goto LABEL_452;
                      }

                      char v321 = -15435;
                      goto LABEL_436;
                    }

                    uint64_t v322 = v310;
                    uint64_t v347 = v309 + (v312 << 6);
                    v348 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v347 + 13), v1239);
                    v1222 = *(void *)v313;
                    v1205 = *v316;
                    v1172 = *(void *)v348;
                    v1186 = *((void *)v348 + 1);
                    uint64_t v349 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v347 + 14), v317);
                    if (v349)
                    {
                      v1127 = (char *)*((void *)v349 + 1);
                      v1119 = v349[16];
                    }

                    v1159 = v349;
                    v1078 = GTTraceFunc_argumentBytesWithMap((void *)v313, v348[32], v317);
                    v1081 = *((_DWORD *)v348 + 4);
                    v1084 = GTTraceFunc_argumentBytesWithMap((void *)v313, v348[33], v317);
                    uint64_t v326 = 5;
                  }

                  goto LABEL_481;
                }

                if (v315 <= -16293)
                {
                  uint64_t v322 = v310;
                  switch(v315)
                  {
                    case -16308:
                      uint64_t v339 = v309 + (v312 << 6);
                      unsigned int v340 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v339 + 13), v1239);
                      v1222 = *(void *)v313;
                      v1205 = *v316;
                      v1172 = *(void *)v340;
                      v1186 = *((void *)v340 + 1);
                      uint64_t v341 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v339 + 14), v317);
                      v1159 = v341;
                      if (v341)
                      {
                        v342 = v341;
                        v1127 = (char *)*((void *)v341 + 1);
                        v1119 = v341[16];
                        uint64_t v343 = v340[16];
                        goto LABEL_476;
                      }

                      uint64_t v362 = v340[16];
                      break;
                    case -16307:
                      goto LABEL_443;
                    case -16306:
                      v344 = v309 + (v312 << 6);
                      uint64_t v345 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v344 + 13), v1239);
                      v1222 = *(void *)v313;
                      v1205 = *v316;
                      v1172 = *(void *)v345;
                      v1186 = *((void *)v345 + 1);
                      v346 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v344 + 14), v317);
                      if (v346)
                      {
                        v1127 = (char *)*((void *)v346 + 1);
                        v1119 = v346[16];
                      }

                      v1159 = v346;
                      v1105 = GTTraceFunc_argumentBytesWithMap((void *)v313, v345[24], v317);
                      uint64_t v326 = 3;
                      goto LABEL_481;
                    case -16305:
                    case -16304:
                      unint64_t v323 = v309 + (v312 << 6);
                      v324 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v323 + 13), v1239);
                      v1222 = *(void *)v313;
                      v1205 = *v316;
                      v1172 = *(void *)v324;
                      v1186 = *((void *)v324 + 1);
                      v325 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v323 + 14), v317);
                      if (v325)
                      {
                        v1127 = (char *)*((void *)v325 + 1);
                        v1119 = v325[16];
                      }

                      v1159 = v325;
                      v1105 = GTTraceFunc_argumentBytesWithMap((void *)v313, v324[24], v317);
                      v1075 = GTTraceFunc_argumentBytesWithMap((void *)v313, v324[25], v317);
                      uint64_t v326 = 2;
                      goto LABEL_481;
                    default:
                      goto LABEL_483;
                  }

                  goto LABEL_487;
                }

                if (v315 > -16096)
                {
                  if (v315 != -16095)
                  {
                    if (v315 == -16083)
                    {
                      v357 = GTTraceFunc_argumentBytesWithMap( (void *)v313,  *(unsigned __int8 *)(v309 + (v312 << 6) + 13),  v1239);
                      v1068 = GTTraceFunc_argumentBytesWithMap((void *)v313, v357[8], v317);
                      goto LABEL_483;
                    }

                    if (v315 != -16039) {
                      goto LABEL_483;
                    }
                    uint64_t v322 = v310;
LABEL_443:
                    uint64_t v327 = v309 + (v312 << 6);
                    unint64_t v328 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v327 + 13), v1239);
                    v1222 = *(void *)v313;
                    v1205 = *v316;
                    v1172 = *(void *)v328;
                    v1186 = *((void *)v328 + 1);
                    unint64_t v329 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v327 + 14), v317);
                    v1159 = v329;
                    if (v329)
                    {
                      uint64_t v330 = v329;
                      v1127 = (char *)*((void *)v329 + 1);
                      v1119 = v329[16];
                      v1105 = GTTraceFunc_argumentBytesWithMap((void *)v313, v328[24], v317);
                      v1072 = *(void *)v330;
                    }

                    else
                    {
                      v1105 = GTTraceFunc_argumentBytesWithMap((void *)v313, v328[24], v317);
                      v1072 = 0LL;
                    }

                    uint64_t v326 = 1;
LABEL_481:
                    v1141 = v326;
LABEL_482:
                    unint64_t v309 = v78 + 64;
                    LODWORD(v310) = v322;
                    goto LABEL_483;
                  }

                  uint64_t v322 = v310;
                  v354 = v309 + (v312 << 6);
                  v355 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v354 + 13), v1239);
                  v1222 = *(void *)v313;
                  v1205 = *v316;
                  v1172 = *(void *)v355;
                  v1186 = *((void *)v355 + 1);
                  uint64_t v356 = GTTraceFunc_argumentBytesWithMap((void *)v313, *(unsigned __int8 *)(v354 + 14), v317);
                  v1159 = v356;
                  if (v356)
                  {
                    v342 = v356;
                    v1127 = (char *)*((void *)v356 + 1);
                    v1119 = v356[16];
                    uint64_t v343 = v355[24];
LABEL_476:
                    v1105 = GTTraceFunc_argumentBytesWithMap((void *)v313, v343, v317);
                    v1141 = 0;
                    v1070 = *(void *)v342;
                    goto LABEL_482;
                  }

                  uint64_t v362 = v355[24];
LABEL_487:
                  v1105 = GTTraceFunc_argumentBytesWithMap((void *)v313, v362, v317);
                  v1070 = 0LL;
                  v1141 = 0;
                  goto LABEL_482;
                }

                if (v315 != -16292)
                {
                  if (v315 == -16291) {
                    v1067 = *(void *)v313;
                  }
                  goto LABEL_483;
                }

LABEL_598:
            unint64_t v479 = v476 | (unint64_t)(v478 << 32);
LABEL_599:
            uint64_t v480 = v475 + 64;
            while (v475)
            {
              uint64_t v481 = v480 + ((uint64_t)(HIDWORD(v479) - (int)v479) << 6);
              GTMTLSMDrawable_processTraceFuncWithMap(buf, v398[1], (uint64_t *)v481);
              if (*(_DWORD *)(v481 + 8) == -7167) {
                break;
              }
              unsigned int v482 = atomic_load((unsigned int *)(v475 + 4));
              int v483 = v479 + (v482 >> 6);
              uint64_t v484 = (HIDWORD(v479) + 1);
              unint64_t v479 = (v484 << 32) | v479;
              if ((_DWORD)v484 == v483 - 1)
              {
                unint64_t v479 = (v484 << 32) | v484;
                uint64_t v475 = *(void *)(v475 + 40);
                goto LABEL_599;
              }
            }

            int v485 = v439->nelts;
            id v379 = v680;
            if (v485 >= 1)
            {
              int v486 = 0;
              uint64_t v487 = v699;
              uint64_t v488 = *(void *)&buf[8];
              do
              {
                if (*(void *)&v439->elts[16 * v486] == v487)
                {
                  GTResourceTrackerUsingResource(v398[2], 2, v488, *v398, v398[1]);
                  uint64_t v489 = v439->nelts - 1LL;
                  v439->int nelts = v489;
                  __int128 v490 = v439->elts;
                  __int128 v491 = *(_OWORD *)&v490[16 * v486];
                  *(_OWORD *)&v490[16 * v486] = *(_OWORD *)&v490[16 * v489];
                  *(_OWORD *)&v439->elts[16 * v489] = v491;
                  int v485 = v439->nelts;
                }

                else
                {
                  ++v486;
                }
              }

              while (v486 < v485);
            }

            v463 = pool;
          }
        }
      }

      v472 = apr_hash_next(v472);
    }

    while (v472);
    __int128 v438 = *(apr_pool_t **)&v696.st_dev;
  }

LABEL_614:
  apr_pool_destroy(v438);
  __int128 v492 = arrf->pool;
  uint64_t v493 = *((unsigned int *)arrf->pool + 3);
  *((_DWORD *)arrf->pool + 3) = 0;
  if ((int)v493 < 1)
  {
    int v504 = 0;
  }

  else
  {
    uint64_t v494 = 0LL;
    do
    {
      uint64_t v495 = *((void *)v492 + 3);
      __int128 v496 = (_OWORD *)(v495 + v494);
      uint64_t v497 = *(void *)(v495 + v494);
      if (v497 != 16 && v497 != 57)
      {
        uint64_t v498 = *((int *)v492 + 3);
        *((_DWORD *)v492 + 3) = v498 + 1;
        *(_OWORD *)buf = *v496;
        *(_OWORD *)&buf[16] = v496[1];
        __int128 v698 = v496[2];
        __int128 v699 = v496[3];
        __int128 v499 = (__int128 *)(v495 + (v498 << 6));
        __int128 v500 = v499[3];
        __int128 v502 = *v499;
        __int128 v501 = v499[1];
        v496[2] = v499[2];
        v496[3] = v500;
        *__int128 v496 = v502;
        v496[1] = v501;
        v503 = (_OWORD *)(*((void *)v492 + 3) + (v498 << 6));
        _OWORD *v503 = *(_OWORD *)buf;
        v503[1] = *(_OWORD *)&buf[16];
        v503[2] = v698;
        v503[3] = v699;
      }

      v494 += 64LL;
    }

    while (v493 << 6 != v494);
    int v504 = *((_DWORD *)v492 + 3);
  }

  *((_DWORD *)v492 + 4) = v504;
  int v505 = v493 - v504;
  __int128 v506 = apr_palloc(v463, 0x20uLL);
  *(void *)__int128 v506 = v463;
  int v507 = *((_DWORD *)v492 + 2);
  v506[3] = v505;
  v506[4] = v505;
  v506[2] = v507;
  *((void *)v506 + 3) = *((void *)v492 + 3) + *((int *)v492 + 2) * (uint64_t)v504;
  *((void *)v682 + 30) = v506;
  uint64_t v508 = *((void *)v682 + 25);
  if (*(int *)(v508 + 12) >= 1)
  {
    uint64_t v509 = 0LL;
    do
    {
      __int128 v510 = find_entry(v398[4], (_BYTE *)(*(void *)(*(void *)(v508 + 24) + 8 * v509) + 8LL), 8uLL, 0LL);
      if (*v510)
      {
        uint64_t v511 = *(void *)(*v510 + 32LL);
        if (v511) {
          *(void *)(v511 + 32) = 0x7FFFFFFFFFFFFFFFLL;
        }
      }

      ++v509;
      uint64_t v508 = *((void *)v682 + 25);
    }

    while (v509 < *(int *)(v508 + 12));
  }

  uint64_t v512 = *((unsigned int *)v492 + 3);
  *((_DWORD *)v492 + 3) = 0;
  if ((int)v512 >= 1)
  {
    uint64_t v513 = 0LL;
    while (1)
    {
      uint64_t v514 = *((void *)v492 + 3);
      uint64_t v515 = *find_entry(v398[4], (_BYTE *)(v514 + v513 + 8), 8uLL, 0LL);
      if (v515)
      {
        uint64_t v516 = *(void *)(v515 + 32);
        if (v516)
        {
          uint64_t v517 = *(void *)(v514 + v513);
          if (v517 == 80) {
            goto LABEL_637;
          }
          if (v517 == 22) {
            break;
          }
        }
      }

LABEL_648:
      v513 += 64LL;
      if (v512 << 6 == v513)
      {
        int v532 = *((_DWORD *)v492 + 3);
        v463 = pool;
        goto LABEL_651;
      }
    }

    Object = GTMTLSMContext_getObject(**((void **)v682 + 5), *(void *)(v514 + v513 + 8), *((void *)v682 + 10));
    __int16 v519 = *((_WORD *)Object + 48);
LABEL_637:
    BOOL v520 = (dword_5B9DE4 & 0x10) == 0 || *(_BYTE *)(v516 + 48) == 0;
    uint64_t v521 = *(void *)(v516 + 32);
    if (v521 != -1)
    {
      uint64_t v522 = *(void *)(v516 + 24);
      if (v522 == -1 || v522 > v521) {
        BOOL v520 = 0;
      }
      if (v520)
      {
        uint64_t v524 = *((int *)v492 + 3);
        *((_DWORD *)v492 + 3) = v524 + 1;
        uint64_t v525 = *((void *)v492 + 3);
        v526 = (_OWORD *)(v525 + v513);
        *(_OWORD *)buf = *(_OWORD *)(v525 + v513);
        *(_OWORD *)&buf[16] = *(_OWORD *)(v525 + v513 + 16);
        __int128 v698 = *(_OWORD *)(v525 + v513 + 32);
        __int128 v699 = *(_OWORD *)(v525 + v513 + 48);
        v527 = (__int128 *)(v525 + (v524 << 6));
        __int128 v528 = v527[3];
        __int128 v530 = *v527;
        __int128 v529 = v527[1];
        v526[2] = v527[2];
        v526[3] = v528;
        _OWORD *v526 = v530;
        v526[1] = v529;
        v531 = (_OWORD *)(*((void *)v492 + 3) + (v524 << 6));
        _OWORD *v531 = *(_OWORD *)buf;
        v531[1] = *(_OWORD *)&buf[16];
        v531[2] = v698;
        v531[3] = v699;
      }
    }

    goto LABEL_648;
  }

  int v532 = 0;
LABEL_651:
  *((_DWORD *)v492 + 4) = v532;
  v533 = apr_palloc(v463, 0x20uLL);
  *(void *)v533 = v463;
  int v534 = *((_DWORD *)v492 + 2);
  v533[3] = v512 - v532;
  v533[4] = v512 - v532;
  v533[2] = v534;
  *((void *)v533 + 3) = *((void *)v492 + 3) + *((int *)v492 + 2) * (uint64_t)v532;
  *((void *)v682 + 27) = v533;
  uint64_t v535 = *(void *)(*((void *)v682 + 5) + 280LL);
  uint64_t v536 = *(void *)(v535 + 24);
  *((void *)v682 + 32) = apr_array_make(v463, *(_DWORD *)(v535 + 12), 8);
  LODWORD(v537) = *(_DWORD *)(v535 + 12);
  if ((int)v537 >= 1)
  {
    uint64_t v538 = 0LL;
    do
    {
      uint64_t v539 = *(void *)(v536 + 8 * v538);
      if (v539) {
        uint64_t v540 = *(void *)(v539 + 8);
      }
      else {
        uint64_t v540 = 0LL;
      }
      uint64_t v541 = *((void *)v682 + 1);
      *(void *)buf = v540;
      uint64_t v542 = *find_entry(v541, buf, 8uLL, 0LL);
      if (v542) {
        uint64_t v543 = *(void *)(v542 + 32);
      }
      else {
        uint64_t v543 = 0LL;
      }
      if (*(void *)GTTraceStream_lastFunc(v543) >= *((void *)v682 + 10)) {
        *(void *)apr_array_push(*((apr_array_header_t **)v682 + 32)) = v539;
      }
      ++v538;
      uint64_t v537 = *(int *)(v535 + 12);
    }

    while (v538 < v537);
  }

  v544 = v682;
  *((void *)v682 + 33) = apr_array_make(v463, v537, 8);
  uint64_t v545 = *(void *)(*((void *)v682 + 5) + 184LL);
  v546 = (apr_pool_t **)apr_hash_make(v463);
  if (*(int *)(v545 + 12) >= 1)
  {
    uint64_t v547 = 0LL;
    do
    {
      uint64_t v548 = *((void *)v544 + 1);
      *(void *)buf = *(void *)(*(void *)(*(void *)(v545 + 24) + 8 * v547) + 8LL);
      v549 = find_entry(v548, buf, 8uLL, 0LL);
      if (*v549) {
        uint64_t v550 = *(void *)(*v549 + 32LL);
      }
      else {
        uint64_t v550 = 0LL;
      }
      v544 = v682;
      GatherCommandQueueResidencySetsUpToIndexInternal( v546,  v550,  *((void *)v682 + 2),  *((void *)v682 + 11) + *((void *)v682 + 10),  0);
      ++v547;
    }

    while (v547 < *(int *)(v545 + 12));
  }

  v551 = apr_hash_first(*v546, (apr_hash_t *)v546);
  if (v551)
  {
    v552 = v551;
    do
    {
      uint64_t v553 = **(void **)(*((void *)v552 + 1) + 16LL);
      *(void *)apr_array_push(*((apr_array_header_t **)v544 + 33)) = v553;
      v552 = apr_hash_next(v552);
    }

    while (v552);
  }

  *((void *)v544 + 20) = apr_hash_make(v463);
  v554 = (uint64_t *)v544;
  if (v379->nelts >= 1)
  {
    uint64_t v555 = 0LL;
    do
    {
      v556 = GTResourceTrackerMake(v554[1], v554[2], v463);
      v557 = *(apr_pool_t **)&v379->elts[8 * v555];
      GTResourceTrackerProcessCommandBuffer((uint64_t)v556, v557, 0);
      v558 = (apr_hash_t *)*((void *)v682 + 20);
      v559 = apr_palloc(v463, 8uLL);
      void *v559 = v557;
      v554 = (uint64_t *)v682;
      apr_hash_set(v558, v559, 8LL, v556);
      ++v555;
    }

    while (v555 < v379->nelts);
  }

  uint64_t v560 = v554[5];
  unint64_t v561 = v554[10];
  v562 = newpool;
  v563 = (int *)apr_hash_make(newpool);
  v564 = apr_array_make(v562, 8, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(v560 + 80), v561, v564);
  if (v564->nelts >= 1)
  {
    uint64_t v565 = 0LL;
    v566 = 0LL;
    do
    {
      uint64_t v567 = *(void *)&v564->elts[8 * v565];
      if (*(_BYTE *)(*(void *)(v567 + 48) + 19LL) == 2)
      {
        if (!v566)
        {
          v566 = apr_hash_make(v562);
          GTMTLSMContext_buildResourceChildrenMap((uint64_t *)v560, v561, (uint64_t)v566, v568);
        }

        v569 = find_entry((uint64_t)v566, (_BYTE *)(v567 + 8), 8uLL, 0LL);
        if (*v569)
        {
          uint64_t v570 = *(void *)(*v569 + 32LL);
          if (v570)
          {
            if (*(int *)(v570 + 12) >= 1)
            {
              uint64_t v571 = 0LL;
              do
              {
                uint64_t v572 = *(void *)(*(void *)(v570 + 24) + 8 * v571);
                apr_hash_set((apr_hash_t *)v563, (const void *)(v572 + 8), 8LL, (const void *)v572);
                ++v571;
              }

              while (v571 < *(int *)(v570 + 12));
              v463 = pool;
            }
          }
        }
      }

      ++v565;
    }

    while (v565 < v564->nelts);
  }

  v573 = apr_array_make(v463, v563[12], 64);
  v574 = v682;
  *((void *)v682 + 29) = v573;
  PushSparseDownloadRequests(*((_OWORD **)v682 + 27), v573, (uint64_t)v563);
  qsort( *(void **)(*((void *)v574 + 29) + 24LL),  *(int *)(*((void *)v574 + 29) + 12LL),  *(int *)(*((void *)v574 + 29) + 8LL),  (int (__cdecl *)(const void *, const void *))CompareRequestByTextureLevel);
  v575 = apr_array_make(v463, v563[12], 64);
  *((void *)v682 + 28) = v575;
  PushSparseDownloadRequests(*((_OWORD **)v682 + 26), v575, (uint64_t)v563);
  qsort( *(void **)(*((void *)v574 + 28) + 24LL),  *(int *)(*((void *)v574 + 28) + 12LL),  *(int *)(*((void *)v574 + 28) + 8LL),  (int (__cdecl *)(const void *, const void *))CompareRequestByTextureLevel);
  unint64_t v576 = *((void *)v682 + 34) & 0xFFFFFFFFFFFFFFFELL | (GTCaptureArchive_getFileWithFilename( *(void *)v682,  "gttrace-dump") == 0);
  *((void *)v682 + 34) = v576;
  v577 = (uint64_t *)*((void *)v682 + 5);
  if (*(int *)(v577[9] + 12) <= 0)
  {
    uint64_t v590 = *((void *)v682 + 15);
    uint64_t v591 = v577[4];
    uint64_t v592 = *(unsigned int *)(v591 + 12);
    if ((int)v592 >= 1)
    {
      uint64_t v593 = *(void *)(v591 + 24);
      do
      {
        v594 = *(void **)v593;
        if (*(void *)(*(void *)v593 + 168LL) || v594[28] || v594[35] || v594[42] || v594[49]) {
          goto LABEL_687;
        }
        v593 += 8LL;
      }

      while (--v592);
    }

    uint64_t v595 = v577[5];
    uint64_t v596 = *(unsigned int *)(v595 + 12);
    if ((int)v596 >= 1)
    {
      uint64_t v597 = *(void *)(v595 + 24);
      while (!*(void *)(*(void *)v597 + 168LL))
      {
        v597 += 8LL;
        if (!--v596) {
          goto LABEL_708;
        }
      }

      goto LABEL_687;
    }

LABEL_708:
    uint64_t v598 = *(int *)(v590 + 12);
    if ((int)v598 >= 1)
    {
      v599 = (int *)(*(void *)(v590 + 24) + 8LL);
      do
      {
        int v600 = *v599;
        v599 += 16;
        if ((IsFuncEnumUseResourceCall(v600) & 1) != 0) {
          goto LABEL_687;
        }
      }

      while (--v598);
    }

    uint64_t v601 = v577[2];
    uint64_t v602 = *(unsigned int *)(v601 + 12);
    if ((int)v602 >= 1)
    {
      v603 = *(uint64_t **)(v601 + 24);
      uint64_t v604 = v602 - 1;
      do
      {
        uint64_t v605 = *v603++;
        unsigned int v606 = *(_DWORD *)(v605 + 4) + 15690;
      }

      while (v606 >= 3 && v604-- != 0);
      if (v606 < 3) {
        goto LABEL_687;
      }
    }

    uint64_t v580 = 0LL;
    v581 = v682;
    *((void *)v682 + 34) = v576 & 0xFFFFFFFFFFFFFFFDLL;
  }

  else
  {
LABEL_687:
    *((void *)v682 + 34) = v576 | 2;
    uint64_t v578 = GTMTLSMContext_getObject(*v577, 1LL, *((void *)v682 + 10))[5];
    v579 = *(const char **)(v578 + 72);
    if (!v579 || !strcmp(v579, "Apple")) {
      uint64_t v580 = 4LL * (*(void *)(v578 + 32) != 0LL);
    }
    else {
      uint64_t v580 = 0LL;
    }
    v581 = v682;
  }

  *((void *)v581 + 34) = *((void *)v581 + 34) & 0xFFFFFFFFFFFFFFFBLL | v580;
  v582 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s/overrides/database",  v640));
  v583 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned __int8 v584 = [v583 fileExistsAtPath:v582];

  if ((v584 & 1) != 0)
  {
    id v684 = 0LL;
    v585 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithContentsOfFile:options:error:]( &OBJC_CLASS___NSData,  "dataWithContentsOfFile:options:error:",  v582,  0LL,  &v684));
    id v586 = v684;
    if (v585)
    {
      v587 = (void *)objc_claimAutoreleasedReturnValue( +[GTCaptureArchiveOverrides allowedClasses]( &OBJC_CLASS___GTCaptureArchiveOverrides,  "allowedClasses"));
      id v683 = v586;
      v588 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v587,  v585,  &v683));
      id v589 = v683;

      id v586 = v589;
    }

    else
    {
      v588 = 0LL;
    }
  }

  else
  {
    v588 = 0LL;
  }

  v277 = v682;
  objc_storeStrong((id *)v682 + 6, v588);
  apr_pool_destroy(newpool);

  return v277;
}

uint64_t GetDeviceObjectStreamRef(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  entry = find_entry(*(void *)(a1 + 24), &v7, 8uLL, 0LL);
  if (*entry
    && (uint64_t v4 = *(void *)(*entry + 32LL)) != 0
    && (unint64_t v5 = atomic_load((unint64_t *)(*(void *)(a1 + 16) + 72LL)), v5 < *(void *)(v4 + 24)))
  {
    return **(void **)(v4 + 8);
  }

  else
  {
    return 0LL;
  }

_OWORD *PushSparseDownloadRequests(_OWORD *result, apr_array_header_t *a2, uint64_t a3)
{
  if (*((int *)result + 3) >= 1)
  {
    unint64_t v5 = result;
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    do
    {
      int v8 = (__int128 *)(*((void *)v5 + 3) + v6);
      if (*(void *)v8 == 80LL)
      {
        uint64_t result = find_entry(a3, (_BYTE *)v8 + 8, 8uLL, 0LL);
        if (*(void *)result)
        {
          if (*(void *)(*(void *)result + 32LL))
          {
            uint64_t result = apr_array_push(a2);
            __int128 v9 = v8[3];
            __int128 v11 = *v8;
            __int128 v10 = v8[1];
            result[2] = v8[2];
            result[3] = v9;
            *uint64_t result = v11;
            result[1] = v10;
          }
        }
      }

      ++v7;
      v6 += 64LL;
    }

    while (v7 < *((int *)v5 + 3));
  }

  return result;
}

uint64_t CompareRequestByTextureLevel(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3)
  {
    unsigned int v4 = *(unsigned __int16 *)(a1 + 34);
    unsigned int v5 = *(unsigned __int16 *)(a2 + 34);
    BOOL v6 = v4 >= v5;
    BOOL v7 = v4 != v5;
    if (v6) {
      return v7;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else if (v2 < v3)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return 1LL;
  }

id GTMTLReplayController_dumpLibrary(uint64_t a1, char *a2, char *a3)
{
  if (!a3) {
    a3 = a2;
  }
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
  if ([v5 hasPrefix:@"/"])
  {
    uint64_t v6 = objc_claimAutoreleasedReturnValue([v5 substringFromIndex:1]);

    unsigned int v5 = (void *)v6;
  }

  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 22568) URLByAppendingPathComponent:v5]);
  int v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([v7 path]);
  unsigned int v10 = [v8 fileExistsAtPath:v9];

  if (!v10)
  {
    uint64_t v12 = **(void ***)a1;
    size_t FileWithFilename = GTCaptureArchive_getFileWithFilename((uint64_t)v12, a2);
    if (!FileWithFilename)
    {
      id NSError = MakeNSError(101, &__NSDictionary0__struct);
      id v27 = (id)objc_claimAutoreleasedReturnValue(NSError);
      GTMTLReplay_handleNSError(v27);

      goto LABEL_21;
    }

    ssize_t v14 = (unsigned int *)FileWithFilename;
    if ((*(_BYTE *)(FileWithFilename + 16) & 2) != 0)
    {
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *v12));
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
      uint64_t v20 = (NSMutableData *)objc_claimAutoreleasedReturnValue([v28 stringByAppendingPathComponent:v29]);

      vm_address_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v7 URLByDeletingLastPathComponent]);
      id v45 = 0LL;
      unsigned __int8 v32 = [v30 createDirectoryAtURL:v31 withIntermediateDirectories:1 attributes:0 error:&v45];
      id v18 = v45;

      if ((v32 & 1) != 0)
      {
        uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
        uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v7 path]);
        id v44 = v18;
        unsigned __int8 v35 = [v33 copyItemAtPath:v20 toPath:v34 error:&v44];
        id v22 = v44;

        if ((v35 & 1) != 0) {
          goto LABEL_15;
        }
        NSErrorUserInfoKey v50 = NSUnderlyingErrorKey;
        id v51 = v22;
        int32x2_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v51,  &v50,  1LL));
        id v18 = v22;
      }

      else
      {
        NSErrorUserInfoKey v52 = NSUnderlyingErrorKey;
        id v53 = v18;
        int32x2_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v53,  &v52,  1LL));
      }

      id v39 = MakeNSError(101, v38);
      id v40 = (id)objc_claimAutoreleasedReturnValue(v39);
      GTMTLReplay_handleNSError(v40);
    }

    else
    {
      ssize_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v7 URLByDeletingLastPathComponent]);
      id v43 = 0LL;
      unsigned __int8 v17 = [v15 createDirectoryAtURL:v16 withIntermediateDirectories:1 attributes:0 error:&v43];
      id v18 = v43;

      if ((v17 & 1) != 0)
      {
        uint64_t v19 = *(void *)(a1 + 152);
        uint64_t v20 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", *v14);
        GTCaptureArchive_fillBufferCompressedDeflate( (uint64_t)v12,  v19,  (uint64_t)v14,  -[NSMutableData mutableBytes](v20, "mutableBytes"),  *v14,  0LL);
        id v42 = v18;
        unsigned __int8 v21 = -[NSMutableData writeToURL:options:error:]( v20,  "writeToURL:options:error:",  v7,  1LL,  &v42);
        id v22 = v42;

        if ((v21 & 1) == 0)
        {
          NSErrorUserInfoKey v46 = NSUnderlyingErrorKey;
          id v47 = v22;
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL));
          id v24 = MakeNSError(101, v23);
          id v25 = (id)objc_claimAutoreleasedReturnValue(v24);
          GTMTLReplay_handleNSError(v25);

LABEL_21:
          id v11 = 0LL;
          goto LABEL_22;
        }

id GTMTLReplayController_dumpPipelineLibrary(uint64_t a1, char *a2, char *a3)
{
  if (!a3) {
    a3 = a2;
  }
  unsigned int v5 = &CATransform3DIdentity_ptr;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
  if ([v6 hasPrefix:@"/"])
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([v6 substringFromIndex:1]);

    uint64_t v6 = (void *)v7;
  }

  int v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 22568) URLByAppendingPathComponent:v6]);
  __int128 v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  char v70 = 0;
  unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v8 path]);
  unsigned int v11 = [v9 fileExistsAtPath:v10 isDirectory:&v70];

  if (v11)
  {
    if (v70)
    {
      id v13 = v8;
    }

    else
    {
      id NSError = MakeNSError(101, &__NSDictionary0__struct);
      id v28 = (id)objc_claimAutoreleasedReturnValue(NSError);
      GTMTLReplay_handleNSError(v28);

      id v13 = 0LL;
    }

    goto LABEL_16;
  }

  uint64_t v14 = **(void **)a1;
  uint64_t v15 = *(void *)(a1 + 152);
  id v69 = 0LL;
  apr_pool_create_ex(&newpool, 0LL, 0LL, v12);
  uint64_t v16 = newpool;
  unsigned __int8 v17 = GTCaptureArchive_mapData(v14, v15, a2, newpool);
  if (v17)
  {
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  v17,  v18,  0LL));
    uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSDictionary, v20);
    uint64_t v56 = objc_opt_class(&OBJC_CLASS___NSData, v22);
    id v24 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v21,  v56,  objc_opt_class(&OBJC_CLASS___NSString, v23),  0LL);
    id v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
    id v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v25,  v19,  &v69));

    apr_pool_destroy(v16);
  }

  else
  {
    apr_pool_destroy(v16);
    NSErrorUserInfoKey v80 = NSLocalizedDescriptionKey;
    int v81 = @"File not found in archive";
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v81,  &v80,  1LL));
    id v29 = MakeNSError(101, v19);
    id v69 = (id)objc_claimAutoreleasedReturnValue(v29);
    GTMTLReplay_handleNSError(v69);
    id v26 = 0LL;
  }

  id v30 = v69;
  if (v30 || ![v26 count])
  {
    v78[0] = NSLocalizedDescriptionKey;
    v78[1] = NSUnderlyingErrorKey;
    v79[0] = @"Failed to decode pipeline library data";
    v79[1] = v30;
    uint64_t v31 = (id *)v79;
    unsigned __int8 v32 = (NSErrorUserInfoKey *)v78;
    uint64_t v33 = 2LL;
LABEL_14:
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v31,  v32,  v33));
    id v35 = MakeNSError(101, v34);
    id v36 = (id)objc_claimAutoreleasedReturnValue(v35);
    GTMTLReplay_handleNSError(v36);

    id v13 = 0LL;
    goto LABEL_15;
  }

  id v68 = 0LL;
  [v9 createDirectoryAtURL:v8 withIntermediateDirectories:1 attributes:0 error:&v68];
  id v38 = v68;
  if (v38)
  {
    id v30 = v38;
    NSErrorUserInfoKey v76 = NSUnderlyingErrorKey;
    id v77 = v38;
    uint64_t v31 = &v77;
    unsigned __int8 v32 = &v76;
    uint64_t v33 = 1LL;
    goto LABEL_14;
  }

  __int128 v66 = 0u;
  __int128 v67 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  obuint64_t j = v26;
  id v58 = [obj countByEnumeratingWithState:&v64 objects:v75 count:16];
  if (!v58) {
    goto LABEL_30;
  }
  uint64_t v59 = *(void *)v65;
  BOOL v57 = v26;
  while (2)
  {
    for (uint64_t i = 0LL; i != v58; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v65 != v59) {
        objc_enumerationMutation(obj);
      }
      uint64_t v41 = *(void *)(*((void *)&v64 + 1) + 8LL * (void)i);
      uint64_t v42 = objc_opt_class(v5[288], v39);
      if ((objc_opt_isKindOfClass(v41, v42) & 1) == 0)
      {
        id v63 = 0LL;
        GTMTLReplay_fillError(&v63, 101, &__NSDictionary0__struct);
        id v43 = v63;
        GTMTLReplay_handleNSError(v43);
LABEL_34:

        id v13 = 0LL;
        id v26 = v57;
        goto LABEL_15;
      }

      id v43 = (id)objc_claimAutoreleasedReturnValue([obj objectForKeyedSubscript:v41]);
      uint64_t v45 = objc_opt_class(&OBJC_CLASS___NSData, v44);
      if ((objc_opt_isKindOfClass(v43, v45) & 1) == 0)
      {
        id v62 = 0LL;
        GTMTLReplay_fillError(&v62, 101, &__NSDictionary0__struct);
        id v53 = v62;
        GTMTLReplay_handleNSError(v53);

        goto LABEL_34;
      }

      NSErrorUserInfoKey v46 = v5;
      id v47 = v9;
      NSErrorUserInfoKey v48 = v5[288];
      id v49 = (void *)objc_claimAutoreleasedReturnValue([v8 path]);
      v74[0] = v49;
      v74[1] = v41;
      NSErrorUserInfoKey v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v74, 2LL));
      id v51 = (CATransform3D *)v48;
      __int128 v9 = v47;
      NSErrorUserInfoKey v52 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D pathWithComponents:](v51, "pathWithComponents:", v50));

      if (([v47 createFileAtPath:v52 contents:v43 attributes:0] & 1) == 0)
      {
        NSErrorUserInfoKey v72 = NSLocalizedDescriptionKey;
        int v73 = @"Failed to create temporary pipeline library file";
        unsigned int v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v73,  &v72,  1LL));
        id v61 = 0LL;
        GTMTLReplay_fillError(&v61, 101, v54);
        id v55 = v61;
        GTMTLReplay_handleNSError(v55);

        goto LABEL_34;
      }

      unsigned int v5 = v46;
    }

    id v26 = v57;
    id v58 = [obj countByEnumeratingWithState:&v64 objects:v75 count:16];
    if (v58) {
      continue;
    }
    break;
  }

uint64_t GTMTLReplayController_makeController( uint64_t a1, apr_pool_t *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a3;
  obuint64_t j = a4;
  id v217 = a4;
  id v212 = a5;
  id v208 = a5;
  id context = a6;
  id v209 = a6;
  pool = a2;
  apr_pool_create_ex(&newpool, a2, 0LL, v12);
  uint64_t v13 = 80LL;
  if ((dword_5B9DE4 & 0x400) == 0) {
    uint64_t v13 = 64LL;
  }
  unint64_t v14 = *(void *)(a1 + v13);
  uint64_t v15 = (apr_pool_t **)apr_hash_make(newpool);
  GTMTLSMContext_buildResourceChildrenMap(*(uint64_t **)(a1 + 40), v14, (uint64_t)v15, v16);
  uint64_t v218 = a1;
  uint64_t v17 = *(void *)(a1 + 40);
  ht = (apr_hash_t *)v15;
  uint64_t v18 = *v15;
  apr_pool_create_ex(p, *v15, 0LL, v19);
  uint64_t v20 = apr_array_make(p[0], *(_DWORD *)(*(void *)(v17 + 224) + 12LL), 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(v17 + 224), v14, v20);
  if (v20->nelts >= 1)
  {
    uint64_t v21 = 0LL;
    do
    {
      uint64_t v22 = *(void *)&v20->elts[8 * v21];
      uint64_t v23 = *find_entry((uint64_t)ht, (_BYTE *)(v22 + 40), 8uLL, 0LL);
      if (!v23 || (id v24 = *(apr_array_header_t **)(v23 + 32)) == 0LL)
      {
        id v24 = apr_array_make(v18, 1, 8);
        apr_hash_set(ht, (const void *)(v22 + 40), 8LL, v24);
      }

      *(void *)apr_array_push(v24) = v22;
      ++v21;
    }

    while (v21 < v20->nelts);
  }

  unint64_t v219 = v14;
  uint64_t v25 = GT_ENV;
  id v26 = v11;
  id v27 = (void *)insertBinaryArchives;
  insertBinaryArchives = 0LL;

  if (v25)
  {
    id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v25));
    id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 componentsSeparatedByString:@":"]);
    id v30 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v29 count]);
    uint64_t v31 = objc_alloc_init(&OBJC_CLASS___MTLBinaryArchiveDescriptor);
    *(_OWORD *)unsigned int v227 = 0u;
    __int128 v228 = 0u;
    __int128 v229 = 0u;
    __int128 v230 = 0u;
    id v32 = v29;
    uint64_t v33 = (char *)[v32 countByEnumeratingWithState:v227 objects:p count:16];
    if (v33)
    {
      uint64_t v34 = *(void *)v228;
      do
      {
        for (uint64_t i = 0LL; i != v33; ++i)
        {
          if (*(void *)v228 != v34) {
            objc_enumerationMutation(v32);
          }
          id v36 = -[NSURL initFileURLWithPath:isDirectory:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithPath:isDirectory:",  *((void *)v227[1] + (void)i),  0LL);
          -[MTLBinaryArchiveDescriptor setUrl:](v31, "setUrl:", v36);

          uint64_t v226 = 0LL;
          id v37 = [v26 newBinaryArchiveWithDescriptor:v31 error:&v226];
          -[NSMutableArray addObject:](v30, "addObject:", v37);
        }

        uint64_t v33 = (char *)[v32 countByEnumeratingWithState:v227 objects:p count:16];
      }

      while (v33);
    }

    id v38 = -[NSMutableArray copy](v30, "copy");
    uint64_t v39 = (void *)insertBinaryArchives;
    insertBinaryArchives = (uint64_t)v38;
  }

  uint64_t v41 = *(void *)(*(void *)(v218 + 40) + 184LL);
  uint64_t v42 = *(unsigned int *)(v41 + 12);
  if ((int)v42 < 1)
  {
    uint64_t v44 = 64LL;
  }

  else
  {
    id v43 = *(uint64_t **)(v41 + 24);
    uint64_t v44 = 64LL;
    do
    {
      uint64_t v45 = *v43++;
      v44 += *(unsigned int *)(v45 + 64);
      --v42;
    }

    while (v42);
  }

  if ((dword_5B9DE4 & 0x10000000) != 0)
  {
    id v46 = (id)objc_opt_new(&OBJC_CLASS___MTLCommandQueueDescriptor, v40);
    [v46 setMaxCommandBufferCount:v44];
    [v46 setLockParameterBufferSizeToMax:1];
    id v47 = v26;
    id v48 = [v47 newCommandQueueWithDescriptor:v46];
    [v217 setDefaultCommandQueue:v48];
  }

  else
  {
    id v46 = [v26 newCommandQueueWithMaxCommandBufferCount:v44];
    [v217 setDefaultCommandQueue:v46];
  }

  else {
    uint64_t v49 = byte_5B9DE3;
  }
  NSErrorUserInfoKey v50 = apr_palloc(pool, (24 * v49) + 22584LL);
  uint64_t v52 = (uint64_t)v50;
  if (v50) {
    bzero(v50, (24 * v49) + 22584LL);
  }
  apr_pool_cleanup_register( pool,  (const void *)v52,  (apr_status_t (__cdecl *)(void *))GTMTLReplayController_cleanup,  v51);
  *(void *)uint64_t v52 = v218;
  uint64_t v206 = v52 + 8;
  objc_storeStrong((id *)(v52 + 8), obj);
  id v53 = -[GTMTLReplaySharedResourcePool initWithDevice:bufferCapacity:]( objc_alloc(&OBJC_CLASS___GTMTLReplaySharedResourcePool),  "initWithDevice:bufferCapacity:",  v26,  0x2000000LL);
  unsigned int v54 = *(void **)(v52 + 16);
  *(void *)(v52 + 16) = v53;

  [*(id *)(v52 + 16) setMaxPooledBuffers:(v49 + 2)];
  id v55 = objc_alloc(&OBJC_CLASS___GTMTLReplaySharedBlitBuffer);
  uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v217 defaultCommandQueue]);
  BOOL v57 = -[GTMTLReplaySharedBlitBuffer initWithCommandQueue:resourcePool:]( v55,  "initWithCommandQueue:resourcePool:",  v56,  *(void *)(v52 + 16));
  id v58 = *(void **)(v52 + 24);
  *(void *)(v52 + 24) = v57;

  *(void *)(v52 + 152) = GTCaptureArchiveDecompressor_create(pool);
  objc_storeStrong((id *)(v52 + 136), v212);
  objc_storeStrong((id *)(v52 + 128), context);
  uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v217 defaultDevice]);
  LODWORD(v55) = [v59 supportsRaytracing];

  if ((_DWORD)v55)
  {
    id v61 = +[NSBundle bundleForClass:]( &OBJC_CLASS___NSBundle,  "bundleForClass:",  objc_opt_class(&OBJC_CLASS___GTMTLReplayObjectMap, v60),  v206,  v208,  v209);
    id v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
    id v63 = (void *)objc_claimAutoreleasedReturnValue([v217 defaultDevice]);
    id v224 = 0LL;
    id v64 = [v63 newDefaultLibraryWithBundle:v62 error:&v224];
    id v65 = v224;

    id v66 = [v64 newFunctionWithName:@"RestoreMTLIntersectionFunctionTable"];
    if (v66)
    {
      __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v217 defaultDevice]);
      id v223 = v65;
      id v68 = [v67 newComputePipelineStateWithFunction:v66 error:&v223];
      id v69 = v223;

      if (v68) {
        objc_storeStrong((id *)(v52 + 120), v68);
      }
      else {
        GTMTLReplay_handleUnderlyingNSError(@"Failed to create IFT restore pipeline", v69);
      }
    }

    else
    {
      id v69 = v65;
    }
  }

  id contexta = objc_autoreleasePoolPush();
  char v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
  id obja = (id)objc_claimAutoreleasedReturnValue([v70 globallyUniqueString]);

  unint64_t v71 = NSTemporaryDirectory();
  NSErrorUserInfoKey v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
  id v213 = (id)objc_claimAutoreleasedReturnValue([v72 stringByAppendingPathComponent:obja]);

  uint64_t v73 = objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](&OBJC_CLASS___NSURL, "fileURLWithPath:isDirectory:", v213, 1LL));
  __int128 v74 = *(void **)(v52 + 22560);
  *(void *)(v52 + 22560) = v73;

  BOOL v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  uint64_t v76 = *(void *)(v52 + 22560);
  id v222 = 0LL;
  LODWORD(v72) = [v75 createDirectoryAtURL:v76 withIntermediateDirectories:1 attributes:0 error:&v222];
  id v77 = v222;

  if ((_DWORD)v72)
  {
    uint64_t v78 = objc_claimAutoreleasedReturnValue([*(id *)(v52 + 22560) URLByAppendingPathComponent:@"lib_root" isDirectory:1]);
    BOOL v79 = *(void **)(v52 + 22568);
    *(void *)(v52 + 22568) = v78;

    NSErrorUserInfoKey v80 = *(void **)v52;
    uint64_t v81 = *(void *)(*(void *)v52 + 40LL);
    uint64_t v82 = *(void *)(v81 + 40);
    int v83 = *(_DWORD *)(v82 + 12);
    if (v83 >= 1)
    {
      for (uint64_t j = 0LL; j < v83; ++j)
      {
        uint64_t v85 = *(void *)(*(void *)(v82 + 24) + 8 * j);
        if ((dword_5B9DE4 & 0x400) == 0)
        {
          unint64_t v86 = *(void *)(v85 + 16);
          unint64_t v87 = v80[8];
          if (v87 <= v86 && v80[9] + v87 > v86) {
            continue;
          }
        }

        uint64_t v89 = *(void *)(v85 + 64);
        if (*(_WORD *)(v89 + 96))
        {
          unint64_t v90 = 0LL;
          do
          {
            id v91 =  GTMTLReplayController_dumpLibrary( v52,  *(char **)(*(void *)(v89 + 40) + 8 * v90),  *(char **)(*(void *)(v89 + 48) + 8 * v90));
            ++v90;
          }

          while (v90 < *(unsigned __int16 *)(v89 + 96));
          int v83 = *(_DWORD *)(v82 + 12);
        }
      }

      uint64_t v81 = v80[5];
    }

    uint64_t v92 = *(void *)(v81 + 32);
    int v93 = *(_DWORD *)(v92 + 12);
    if (v93 >= 1)
    {
      for (uint64_t k = 0LL; k < v93; ++k)
      {
        uint64_t v95 = *(void *)(*(void *)(v92 + 24) + 8 * k);
        if ((dword_5B9DE4 & 0x400) == 0)
        {
          unint64_t v96 = *(void *)(v95 + 16);
          unint64_t v97 = v80[8];
          if (v97 <= v96 && v80[9] + v97 > v96) {
            continue;
          }
        }

        uint64_t v99 = *(void *)(v95 + 56);
        if (*(_WORD *)(v99 + 214))
        {
          unint64_t v100 = 0LL;
          do
          {
            id v101 =  GTMTLReplayController_dumpLibrary( v52,  *(char **)(*(void *)(v99 + 96) + 8 * v100),  *(char **)(*(void *)(v99 + 104) + 8 * v100));
            ++v100;
          }

          while (v100 < *(unsigned __int16 *)(v99 + 214));
          int v93 = *(_DWORD *)(v92 + 12);
        }
      }
    }
  }

  else
  {
    GTMTLReplay_handleUnderlyingNSError(@"Failed to create replay controller temporary directory", v77);
  }

  objc_autoreleasePoolPop(contexta);
  *(void *)(v52 + 22504) = apr_array_make(pool, 128, 16);
  dispatch_semaphore_t v102 = dispatch_semaphore_create(0LL);
  __int128 v103 = *(void **)(v52 + 22520);
  *(void *)(v52 + 22520) = v102;

  dispatch_group_t v104 = dispatch_group_create();
  uint64_t v105 = *(void **)(v52 + 22528);
  *(void *)(v52 + 22528) = v104;

  *(_DWORD *)(v52 + 22576) = v49;
  if ((_DWORD)v49)
  {
    uint64_t v106 = v52 + 22584;
    do
    {
      *(void *)(v106 + 8) = v52;
      pthread_create((pthread_t *)v106, 0LL, (void *(__cdecl *)(void *))StartLoadingThread, (void *)v106);
      v106 += 24LL;
      --v49;
    }

    while (v49);
  }

  uint64_t v107 = (void *)g_activityLog;
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  **(void **)v218,  v206));
  [v107 enterLoadArchiveWithPath:v108];

  uint64_t v109 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v109))
  {
    LOWORD(p[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v109,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "CreateDeviceResources",  (uint8_t *)p,  2u);
  }

  uint64_t v110 = *(_DWORD ***)(v218 + 40);
  uint64_t v111 = *(void *)v52;
  apr_pool_create_ex(v227, 0LL, 0LL, v112);
  int v113 = v227[0];
  uint64_t v114 = apr_array_make(v227[0], 128, 8);
  uint64_t v115 = apr_array_make(v113, 128, 8);
  GTMTLSMContext_getObjects(v110[10], v219, v115);
  if (v115->nelts >= 1)
  {
    uint64_t v116 = 0LL;
    do
      ExpandChildren(v114, *(void *)&v115->elts[8 * v116++], (uint64_t)ht);
    while (v116 < v115->nelts);
  }

  v115->int nelts = 0;
  GTMTLSMContext_getObjects(v110[2], v219, v115);
  int nelts = v115->nelts;
  if (nelts >= 1)
  {
    for (uint64_t m = 0LL; m < nelts; ++m)
    {
      uint64_t v119 = *(void **)&v115->elts[8 * m];
      if (!v119[6] && !v119[17] && !v119[18])
      {
        ExpandChildren(v114, (uint64_t)v119, (uint64_t)ht);
        int nelts = v115->nelts;
      }
    }
  }

  v115->int nelts = 0;
  GTMTLSMContext_getObjects(v110[1], v219, v115);
  int v120 = v115->nelts;
  if (v120 >= 1)
  {
    for (uint64_t n = 0LL; n < v120; ++n)
    {
      uint64_t v122 = *(void *)&v115->elts[8 * n];
      if (!*(void *)(v122 + 48))
      {
        ExpandChildren(v114, v122, (uint64_t)ht);
        int v120 = v115->nelts;
      }
    }
  }

  GTMTLSMContext_getObjects(v110[9], v219, v114);
  hta = *(apr_hash_t **)(v111 + 8);
  uint64_t v123 = *(void *)(*(void *)v52 + 8LL);
  p[0] = 0LL;
  uint64_t v124 = *(void *)(*(void *)(*find_entry(v123, p, 8uLL, 0LL) + 32LL) + 32LL);
  if (v124)
  {
    unsigned int v125 = 0;
    while (1)
    {
      unsigned int v126 = atomic_load((unsigned int *)(v124 + 4));
      uint64_t v127 = v125 + (v126 >> 6) - 1;
      uint64_t v124 = *(void *)(v124 + 40);
      unsigned int v125 = v127;
      if (!v124)
      {
        unsigned int v125 = v127;
        goto LABEL_94;
      }
    }
  }

  else
  {
    unsigned int v125 = 0;
  }

  uint64_t v127 = 0LL;
LABEL_94:
  unint64_t v128 = v125 | (unint64_t)(v127 << 32);
LABEL_95:
  uint64_t v129 = v124 + 64;
  while (v124)
  {
    int v130 = HIDWORD(v128) - v128;
    uint64_t v131 = v130;
    uint64_t v132 = (unint64_t *)(v129 + ((uint64_t)v130 << 6));
    if (*v132 >= v219) {
      break;
    }
    __int128 v133 = objc_autoreleasePoolPush();
    if (*(_DWORD *)(v129 + (v131 << 6) + 8) == -7155) {
      GTMTLReplayController_defaultDispatchFunction(v52, (uint64_t)v132);
    }
    objc_autoreleasePoolPop(v133);
    unsigned int v134 = atomic_load((unsigned int *)(v124 + 4));
    int v135 = v128 + (v134 >> 6);
    uint64_t v136 = (HIDWORD(v128) + 1);
    unint64_t v128 = (v136 << 32) | v128;
    if ((_DWORD)v136 == v135 - 1)
    {
      unint64_t v128 = (v136 << 32) | v136;
      uint64_t v124 = *(void *)(v124 + 40);
      goto LABEL_95;
    }
  }

  for (iuint64_t i = (apr_pool_t *)(&dword_0 + 1); ; iuint64_t i = (apr_pool_t *)((char *)ii + 1))
  {
    p[0] = ii;
    uint64_t v138 = *find_entry((uint64_t)hta, p, 8uLL, 0LL);
    if (!v138) {
      break;
    }
    uint64_t v139 = *(void *)(v138 + 32);
    if (!v139) {
      break;
    }
    uint64_t v140 = *(void *)(v139 + 32);
    if (!v140 || (*(_BYTE *)(v140 + 79) & 8) == 0) {
      break;
    }
    int v141 = *(_DWORD *)(v140 + 72);
    if (v141 != -7163 && v141 != -10239) {
      break;
    }
    CreateResourceFromStream((id *)v52, v139, v219);
  }

  LODWORD(v143) = v114->nelts;
  if ((int)v143 >= 1)
  {
    uint64_t v144 = 0LL;
    do
    {
      int v145 = *(apr_pool_t **)&v114->elts[8 * v144];
      if (v145) {
        int v145 = (apr_pool_t *)*((void *)v145 + 1);
      }
      p[0] = v145;
      uint64_t v146 = *find_entry((uint64_t)hta, p, 8uLL, 0LL);
      if (v146) {
        uint64_t v147 = *(void *)(v146 + 32);
      }
      else {
        uint64_t v147 = 0LL;
      }
      CreateResourceFromStream((id *)v52, v147, v219);
      ++v144;
      uint64_t v143 = v114->nelts;
    }

    while (v144 < v143);
  }

  apr_pool_destroy(v227[0]);
  int v148 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v148))
  {
    LODWORD(p[0]) = 67109120;
    HIDWORD(p[0]) = v143;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v148,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Replayer-1-serial",  "%d",  (uint8_t *)p,  8u);
  }

  if ((GT_SUPPORT_0 & 0x800) != 0
    && (*(_DWORD *)(*(void *)(v218 + 232) + 12LL) || *(_DWORD *)(*(void *)(v218 + 224) + 12LL)))
  {
    uint64_t v149 = objc_autoreleasePoolPush();
    uint64_t v150 = (void *)objc_claimAutoreleasedReturnValue([v217 defaultCommandQueue]);
    id v151 = InternalCommandBuffer(v150, @"MapSparseTextureRegions");
    uint64_t v152 = (void *)objc_claimAutoreleasedReturnValue(v151);

    std::__split_buffer<std::string> v153 = (void *)objc_claimAutoreleasedReturnValue([v152 resourceStateCommandEncoder]);
    uint64_t v154 = **(apr_pool_t ***)(v52 + 152);
    MapSparseTextureRegions(v153, *(void **)(v52 + 8), *(void *)(v218 + 232), v154);
    MapSparseTextureRegions(v153, *v207, *(void *)(v218 + 224), v154);
    apr_pool_clear(v154);
    [v153 endEncoding];
    GTMTLReplay_commitCommandBuffer(v152);

    objc_autoreleasePoolPop(v149);
  }

  FillRequestsAlignment(*(void *)(v218 + 216), *(uint64_t **)(v218 + 40), v26);
  GroupRequestsByCapacity(*(apr_array_header_t **)(v218 + 216), v155, v156, v157);
  uint64_t v158 = *(void *)(v218 + 136);
  uint64_t v159 = (apr_hash_index_t *)(v158 + 16);
  *(void *)(v158 + 24) = 0LL;
  *(void *)(v158 + 32) = 0LL;
  *(void *)(v158 + 16) = v158;
  *(_DWORD *)(v158 + 40) = 0;
  while (1)
  {
    __int128 v160 = apr_hash_next(v159);
    if (!v160) {
      break;
    }
    uint64_t v159 = v160;
    unint64_t v161 = *(apr_array_header_t **)(*((void *)v160 + 1) + 32LL);
    FillRequestsAlignment((uint64_t)v161, *(uint64_t **)(v218 + 40), v26);
    GroupRequestsByCapacity(v161, v162, v163, v164);
  }

  AppendRestoreJobsToLoadQueue(v52, *(void *)(v218 + 216));
  AppendRestoreJobsToLoadQueue(v52, *(void *)(v218 + 208));
  SignalLoadQueueThreads(v52, *(_DWORD *)(*(void *)(v52 + 22504) + 12LL));
  os_signpost_id_t v165 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, (const void *)v52);
  int v166 = apr_array_make(newpool, 128, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 96LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 88LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 224LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 104LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 32LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 40LL), v219, v166);
  qsort(v166->elts, v166->nelts, 8uLL, (int (__cdecl *)(const void *, const void *))GTMTLSMObject_compare);
  __int128 v167 = g_signpostLog;
  __int128 v168 = (os_log_s *)v167;
  unint64_t v169 = v165 - 1;
  if (v165 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v167))
  {
    int v170 = v166->nelts;
    LODWORD(p[0]) = 67109120;
    HIDWORD(p[0]) = v170;
    _os_signpost_emit_with_name_impl( &dword_0,  v168,  OS_SIGNPOST_INTERVAL_BEGIN,  v165,  "Replayer-1-serial",  "CreatePipelineStates %d",  (uint8_t *)p,  8u);
  }

  if (v166->nelts >= 1)
  {
    uint64_t v171 = 0LL;
    do
    {
      __int128 v172 = *(apr_pool_t **)&v166->elts[8 * v171];
      if (v172) {
        __int128 v172 = (apr_pool_t *)*((void *)v172 + 1);
      }
      uint64_t v173 = *(void *)(v218 + 8);
      p[0] = v172;
      uint64_t v174 = *find_entry(v173, p, 8uLL, 0LL);
      if (v174) {
        uint64_t v175 = *(void *)(v174 + 32);
      }
      else {
        uint64_t v175 = 0LL;
      }
      CreateResourceFromStream((id *)v52, v175, v219);
      ++v171;
    }

    while (v171 < v166->nelts);
  }

  uint64_t v176 = g_signpostLog;
  int v177 = (os_log_s *)v176;
  if (v169 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v176))
  {
    LOWORD(p[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v177,  OS_SIGNPOST_INTERVAL_END,  v165,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)p,  2u);
  }

  v166->int nelts = 0;
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 152LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 120LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 112LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 216LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 48LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 200LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 24LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 136LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 128LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 256LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 56LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 64LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 264LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 272LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 280LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 184LL), v219, v166);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v218 + 40) + 192LL), v219, v166);
  uint64_t v178 = g_signpostLog;
  uint64_t v179 = (os_log_s *)v178;
  if (v169 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v178))
  {
    int v180 = v166->nelts;
    LODWORD(p[0]) = 67109120;
    HIDWORD(p[0]) = v180;
    _os_signpost_emit_with_name_impl( &dword_0,  v179,  OS_SIGNPOST_INTERVAL_BEGIN,  v165,  "Replayer-1-serial",  "CreateOtherStates %d",  (uint8_t *)p,  8u);
  }

  if (v166->nelts >= 1)
  {
    uint64_t v181 = 0LL;
    do
    {
      int v182 = *(apr_pool_t **)&v166->elts[8 * v181];
      if (v182) {
        int v182 = (apr_pool_t *)*((void *)v182 + 1);
      }
      uint64_t v183 = *(void *)(v218 + 8);
      p[0] = v182;
      uint64_t v184 = *find_entry(v183, p, 8uLL, 0LL);
      if (v184) {
        uint64_t v185 = *(void *)(v184 + 32);
      }
      else {
        uint64_t v185 = 0LL;
      }
      CreateResourceFromStream((id *)v52, v185, v219);
      ++v181;
    }

    while (v181 < v166->nelts);
  }

  unsigned int v186 = g_signpostLog;
  uint64_t v187 = (os_log_s *)v186;
  if (v169 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v186))
  {
    LOWORD(p[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v187,  OS_SIGNPOST_INTERVAL_END,  v165,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)p,  2u);
  }

  unsigned int v188 = objc_alloc(&OBJC_CLASS___GTMTLReplayActivityLog);
  NSErrorUserInfoKey v189 = -[GTMTLReplayActivityLog initWithLog:](v188, "initWithLog:", g_activityLog);
  RestoreOrderedResourcesFromArchive( (id *)v52,  *(void *)(*(void *)(v218 + 240) + 24LL),  *(unsigned int *)(*(void *)(v218 + 240) + 12LL),  v189);
  RestoreVisibleFunctionTablesForFunctionIndex((id *)v52, v219 - 1);
  RestoreIntersectionFunctionTablesForFunctionIndex((id *)v52, v219 - 1);
  id v190 = (unsigned int *)(v52 + 22512);
  do
    signed int v191 = __ldaxr(v190);
  while (__stlxr(v191 + 1, v190));
  uint64_t v192 = *(void *)(v52 + 22504);
  if (v191 >= *(_DWORD *)(v192 + 12)) {
    uint64_t v193 = 0LL;
  }
  else {
    uint64_t v193 = *(void *)(v192 + 24) + 16LL * v191;
  }
  while (v193)
  {
    __int128 v194 = objc_autoreleasePoolPush();
    DoLoadJob((uint64_t **)v52, v193, v189, 0LL);
    do
      signed int v195 = __ldaxr(v190);
    while (__stlxr(v195 + 1, v190));
    uint64_t v196 = *(void *)(v52 + 22504);
    if (v195 >= *(_DWORD *)(v196 + 12)) {
      uint64_t v193 = 0LL;
    }
    else {
      uint64_t v193 = *(void *)(v196 + 24) + 16LL * v195;
    }
    objc_autoreleasePoolPop(v194);
  }

  dispatch_group_wait(*(dispatch_group_t *)(v52 + 22528), 0xFFFFFFFFFFFFFFFFLL);
  *(_DWORD *)(*(void *)(v52 + 22504) + 12LL) = 0;
  apr_pool_destroy(newpool);
  char v197 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  8LL);
  __int128 v198 = *(void **)(v52 + 40);
  *(void *)(v52 + 40) = v197;

  dispatch_semaphore_t v199 = dispatch_semaphore_create(1LL);
  int v200 = *(void **)(v52 + 48);
  *(void *)(v52 + 48) = v199;

  uint64_t v201 = objc_claimAutoreleasedReturnValue(+[NSMapTable strongToStrongObjectsMapTable](&OBJC_CLASS___NSMapTable, "strongToStrongObjectsMapTable"));
  uint64_t v202 = *(void **)(v52 + 56);
  *(void *)(v52 + 56) = v201;

  uint64_t v203 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v204 = *(void **)(v52 + 144);
  *(void *)(v52 + 144) = v203;

  *(void *)(v52 + 22496) = apr_hash_make(pool);
  *(void *)(v52 + 22544) = apr_hash_make(pool);
  *(void *)(v52 + 22552) = *(void *)(v218 + 136);
  [(id)g_activityLog leaveActivity];

  return v52;
}

void sub_12DD90(_Unwind_Exception *a1)
{
}

uint64_t GTMTLReplayController_cleanup(uint64_t a1)
{
  uint64_t v2 = a1 + 22516;
  atomic_store(1u, (unsigned int *)(a1 + 22516));
  SignalLoadQueueThreads(a1, *(_DWORD *)(a1 + 22576));
  if (*(int *)(v2 + 60) >= 1)
  {
    uint64_t v3 = 0LL;
    unsigned int v4 = (_opaque_pthread_t **)(a1 + 22584);
    do
    {
      unsigned int v5 = *v4;
      v4 += 3;
      pthread_join(v5, 0LL);
      ++v3;
    }

    while (v3 < *(int *)(v2 + 60));
  }

  uint64_t v6 = *(void **)(a1 + 22520);
  *(void *)(a1 + 22520) = 0LL;

  uint64_t v7 = *(void **)(a1 + 22528);
  *(void *)(a1 + 22528) = 0LL;

  int v8 = *(void **)(a1 + 22536);
  *(void *)(a1 + 22536) = 0LL;

  __int128 v9 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0LL;

  unsigned int v10 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;

  id v11 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;

  uint64_t v12 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0LL;

  uint64_t v13 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0LL;

  unint64_t v14 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;

  uint64_t v15 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = 0LL;

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  [v16 removeItemAtURL:*(void *)(a1 + 22560) error:0];

  uint64_t v17 = *(void **)(a1 + 22560);
  *(void *)(a1 + 22560) = 0LL;

  uint64_t v18 = *(void **)(a1 + 22568);
  *(void *)(a1 + 22568) = 0LL;

  uint64_t v19 = *(void **)(a1 + 128);
  *(void *)(a1 + 128) = 0LL;

  uint64_t v20 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;

  GTMTLReplayController_tileMemoryFree(a1);
  return 0LL;
}

uint64_t StartLoadingThread(uint64_t a1)
{
  id context = objc_autoreleasePoolPush();
  apr_pool_create_ex(&newpool, 0LL, 0LL, v2);
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(id *)(v3 + 8);
  unsigned int v5 = newpool;
  apr_pool_create_ex(&v48, newpool, 0LL, v6);
  *(void *)(a1 + 16) = apr_hash_make(v48);
  uint64_t v34 = *(uint64_t **)v3;
  id v35 = v4;
  uint64_t v36 = 0LL;
  uint64_t v7 = objc_alloc(&OBJC_CLASS___GTMTLReplaySharedBlitBuffer);
  id v32 = v35;
  int v8 = (void *)objc_claimAutoreleasedReturnValue([v35 defaultCommandQueue]);
  id v37 = -[GTMTLReplaySharedBlitBuffer initWithCommandQueue:resourcePool:]( v7,  "initWithCommandQueue:resourcePool:",  v8,  *(void *)(v3 + 16));
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  uint64_t v45 = 0LL;
  id v46 = GTCaptureArchiveDecompressor_create(v5);
  bzero(&v47, 0x5798uLL);

  __int128 v9 = (unsigned int *)(v3 + 22512);
  while (1)
  {
    dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v3 + 22520), 0xFFFFFFFFFFFFFFFFLL);
    id v11 = pthread_self();
    uint64_t v12 = objc_alloc(&OBJC_CLASS___GTMTLReplayActivityLog);
    uint64_t v13 = -[GTMTLReplayActivityLog initWithLog:](v12, "initWithLog:", g_activityLog);
    pthread_rwlock_wrlock(&rwlock);
    uint64_t v14 = 0LL;
    uint64_t v15 = (pthread_t *)threadLocalLogs;
    do
    {
      if (pthread_equal(v11, *v15))
      {
        uint64_t v18 = (void **)&threadLocalLogs[2 * v14 + 1];
        uint64_t v19 = v13;
        goto LABEL_12;
      }

      ++v14;
      v15 += 2;
    }

    while (v14 != 7);
    uint64_t v16 = 0LL;
    uint64_t v17 = &qword_5B99D8;
    while (*v17)
    {
      ++v16;
      v17 += 2;
      if (v16 == 7) {
        goto LABEL_13;
      }
    }

    uint64_t v20 = &threadLocalLogs[2 * v16];
    uint64_t v21 = v13;
    *uint64_t v20 = (uint64_t)v11;
    uint64_t v18 = (void **)(v20 + 1);
LABEL_12:
    uint64_t v22 = *v18;
    *uint64_t v18 = v13;

LABEL_13:
    pthread_rwlock_unlock(&rwlock);

    do
      signed int v23 = __ldaxr(v9);
    while (__stlxr(v23 + 1, v9));
    uint64_t v24 = *(void *)(v3 + 22504);
    if (v23 < *(_DWORD *)(v24 + 12))
    {
      uint64_t v25 = *(void *)(v24 + 24);
      if (v25)
      {
        uint64_t v26 = v25 + 16LL * v23;
        do
        {
          id v27 = objc_autoreleasePoolPush();
          DoLoadJob(&v34, v26, v13, *(apr_hash_t **)(a1 + 16));
          objc_autoreleasePoolPop(v27);
          do
            signed int v28 = __ldaxr(v9);
          while (__stlxr(v28 + 1, v9));
          uint64_t v29 = *(void *)(v3 + 22504);
          if (v28 >= *(_DWORD *)(v29 + 12)) {
            break;
          }
          uint64_t v30 = *(void *)(v29 + 24);
          uint64_t v26 = v30 + 16LL * v28;
        }

        while (v30);
      }
    }

    -[GTMTLReplaySharedBlitBuffer releaseBuffer](v37, "releaseBuffer");
    dispatch_group_leave(*(dispatch_group_t *)(v3 + 22528));
  }

  apr_pool_destroy(newpool);
  __destructor_8_s8_s16_s24_s40_s48_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_S_s144_S_s22520_s22528_S_s22536_s22560_s22568((id *)&v34);

  objc_autoreleasePoolPop(context);
  return 0LL;
}

void sub_12E1FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *ExpandChildren(apr_array_header_t *a1, uint64_t a2, uint64_t a3)
{
  *(void *)apr_array_push(a1) = a2;
  uint64_t result = find_entry(a3, (_BYTE *)(a2 + 8), 8uLL, 0LL);
  if (*result)
  {
    uint64_t v7 = *(void *)(*result + 32LL);
    if (v7)
    {
      if (*(int *)(v7 + 12) >= 1)
      {
        uint64_t v8 = 0LL;
        do
          uint64_t result = (void *)ExpandChildren(a1, *(void *)(*(void *)(v7 + 24) + 8 * v8++), a3);
        while (v8 < *(int *)(v7 + 12));
      }
    }
  }

  return result;
}

void CreateResourceFromStream(id *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v25 = *((void *)*a1 + 2);
  id v27 = a1[1];
  uint64_t v5 = *(void *)(a2 + 32);
  if (v5)
  {
    unsigned int v6 = 0;
    while (1)
    {
      unsigned int v7 = atomic_load((unsigned int *)(v5 + 4));
      uint64_t v8 = v6 + (v7 >> 6) - 1;
      uint64_t v5 = *(void *)(v5 + 40);
      unsigned int v6 = v8;
      if (!v5)
      {
        unsigned int v6 = v8;
        goto LABEL_8;
      }
    }
  }

  else
  {
    unsigned int v6 = 0;
  }

  uint64_t v8 = 0LL;
LABEL_8:
  unint64_t v9 = v6 | (unint64_t)(v8 << 32);
LABEL_9:
  uint64_t v10 = v5 + 64;
  while (v5)
  {
    int v11 = HIDWORD(v9) - v9;
    uint64_t v12 = v11;
    uint64_t v13 = v10 + ((uint64_t)v11 << 6);
    if (*(void *)v13 >= a3) {
      break;
    }
    uint64_t v14 = objc_autoreleasePoolPush();
    int v15 = *(_DWORD *)(v13 + 8);
    uint64_t v16 = (v15 + 10238);
    if (v16 <= 0x30)
    {
      if (v16 == 1) {
        goto LABEL_18;
      }
    }

    if (v15 != -16236)
    {
      if (v15 == -16313)
      {
LABEL_18:
        if ((GT_SUPPORT_0 & 0x80000) == 0)
        {
          uint64_t v17 = GTTraceFunc_argumentBytesWithMap((void *)v13, *(unsigned __int8 *)(v10 + (v12 << 6) + 13), v25);
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v27 deviceForKey:*(void *)v17]);
          uint64_t v19 = v18;
          if ((dword_5B9DE4 & 4) != 0) {
            unint64_t v20 = 32LL;
          }
          else {
            unint64_t v20 = *((void *)v17 + 3) & 0xFFFFFFFFFFEFFFFFLL;
          }
          id v21 = [v18 newBufferWithLength:*((void *)v17 + 2) options:v20];
          if (v21) {
            [v27 setBuffer:v21 forKey:*((void *)v17 + 1)];
          }
        }

        goto LABEL_26;
      }

      GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, v13);
    }

void MapSparseTextureRegions(void *a1, void *a2, uint64_t a3, apr_pool_t *a4)
{
  id v7 = a1;
  id v41 = a2;
  uint64_t v8 = apr_array_make(a4, 8, 48);
  arr = apr_array_make(a4, 8, 48);
  __int128 v43 = apr_array_make(a4, 8, 8);
  __int128 v42 = apr_array_make(a4, 8, 8);
  __int128 v40 = v7;
  __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([v7 device]);
  if (*(int *)(a3 + 12) < 1)
  {
    int v11 = 0LL;
  }

  else
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    int v11 = 0LL;
    id v12 = 0LL;
    uint64_t v13 = 32LL;
    do
    {
      uint64_t v14 = *(void *)(a3 + 24);
      uint64_t v15 = v14 + v13;
      uint64_t v16 = *(void *)(v14 + v13 - 24);
      if (v16 != v10)
      {
        if (v8->nelts >= 1)
        {
          id v17 = [v11 textureType];
          id v18 = [v11 pixelFormat];
          id v19 = [v11 sampleCount];
          if (v39)
          {
            [v39 sparseTileSizeWithTextureType:v17 pixelFormat:v18 sampleCount:v19];
          }

          else
          {
            __int128 v47 = 0uLL;
            uint64_t v48 = 0LL;
          }

          elts = v8->elts;
          id v21 = arr->elts;
          uint64_t nelts = v8->nelts;
          __int128 v45 = v47;
          uint64_t v46 = v48;
          objc_msgSend( v39,  "convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:",  elts,  v21,  &v45,  0,  nelts,  v39);
          [v40 updateTextureMappings:v11 mode:0 regions:arr->elts mipLevels:v43->elts slices:v42->elts numRegions:v8->nelts];
          arr->uint64_t nelts = 0;
          v8->uint64_t nelts = 0;
          v43->uint64_t nelts = 0;
          v42->uint64_t nelts = 0;
          uint64_t v16 = *(void *)(v15 - 24);
        }

        int v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "textureForKey:", v16, v39));

        id v12 = [v23 firstMipmapInTail];
        uint64_t v10 = *(void *)(v15 - 24);
        int v11 = v23;
      }

      if ((unint64_t)v12 >= *(unsigned __int16 *)(v15 + 2))
      {
        apr_array_push(arr);
        uint64_t v24 = apr_array_push(v8);
        uint64_t v25 = *(unsigned __int16 *)(v14 + v13 + 6);
        uint64_t v26 = *(unsigned __int16 *)(v14 + v13 + 8);
        uint64_t v27 = *(unsigned __int16 *)(v14 + v13 + 10);
        uint64_t v28 = *(unsigned __int16 *)(v14 + v13 + 12);
        uint64_t v29 = *(unsigned __int16 *)(v14 + v13 + 14);
        void *v24 = *(unsigned __int16 *)(v14 + v13 + 4);
        v24[1] = v25;
        v24[2] = v26;
        v24[3] = v27;
        void v24[4] = v28;
        void v24[5] = v29;
        uint64_t v30 = *(unsigned __int16 *)(v15 + 2);
        *(void *)apr_array_push(v43) = v30;
        uint64_t v31 = *(unsigned __int16 *)(v14 + v13);
        *(void *)apr_array_push(v42) = v31;
      }

      ++v9;
      v13 += 64LL;
    }

    while (v9 < *(int *)(a3 + 12));
  }

  id v32 = v39;
  if (v8->nelts > 0)
  {
    id v33 = [v11 textureType];
    id v34 = [v11 pixelFormat];
    id v35 = [v11 sampleCount];
    if (v39)
    {
      [v39 sparseTileSizeWithTextureType:v33 pixelFormat:v34 sampleCount:v35];
    }

    else
    {
      __int128 v47 = 0uLL;
      uint64_t v48 = 0LL;
    }

    uint64_t v36 = v8->elts;
    id v37 = arr->elts;
    uint64_t v38 = v8->nelts;
    __int128 v45 = v47;
    uint64_t v46 = v48;
    objc_msgSend( v39,  "convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:",  v36,  v37,  &v45,  0,  v38,  v39);
    [v40 updateTextureMappings:v11 mode:0 regions:arr->elts mipLevels:v43->elts slices:v42->elts numRegions:v8->nelts];
  }
}

void FillRequestsAlignment(uint64_t a1, uint64_t *a2, void *a3)
{
  id v5 = a3;
  int v6 = *(_DWORD *)(a1 + 12);
  if (v6 >= 1)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = 2LL;
    do
    {
      uint64_t v10 = *(void *)(a1 + 24);
      if (*(void *)(v10 + v7) == 80LL)
      {
        uint64_t v15 = v9;
        uint64_t v11 = v10 + v7;
        GTMTLSMContext_getTextureDescriptor(a2, *(void *)(v10 + v7 + 8), *(void *)(v10 + v7 + 16), (uint64_t)v21);
        uint64_t v12 = v25;
        GTMTLPixelFormatGetInfoForDevice((uint64_t)v19, (uint64_t)v5, v25);
        __int128 v13 = xmmword_318400;
        if ((~v20 & 0x60) != 0)
        {
          *((void *)&v13 + 1) = v15;
          *(void *)&__int128 v13 = 0LL;
          if ((v20 & 0x2000) != 0) {
            *(void *)&__int128 v13 = 4LL;
          }
        }

        uint64_t v16 = *((void *)&v13 + 1);
        char v14 = v13;
        GTMTLGetTextureLevelInfoForDeviceWithOptions( (uint64_t)v17,  (uint64_t)v5,  v12,  v22,  v24,  v23,  v26,  *(unsigned __int16 *)(v11 + 34),  v13);
        *(_WORD *)(v11 + 60) = v18;
        *(_BYTE *)(v11 + 62) = v14;
        int v6 = *(_DWORD *)(a1 + 12);
        uint64_t v9 = v16;
      }

      ++v8;
      v7 += 64LL;
    }

    while (v8 < v6);
  }
}

void GroupRequestsByCapacity(apr_array_header_t *a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  p = newpool;
  id v5 = apr_array_copy(newpool, a1);
  qsort(v5->elts, v5->nelts, v5->elt_size, (int (__cdecl *)(const void *, const void *))CompareRequestsBySize);
  a1->uint64_t nelts = 0;
  while (v5->nelts)
  {
    elts = v5->elts;
    uint64_t v7 = apr_array_push(a1);
    __int128 v8 = *((_OWORD *)elts + 3);
    __int128 v10 = *(_OWORD *)elts;
    __int128 v9 = *((_OWORD *)elts + 1);
    v7[2] = *((_OWORD *)elts + 2);
    v7[3] = v8;
    *uint64_t v7 = v10;
    v7[1] = v9;
    uint64_t v11 = RequestSize((uint64_t)elts);
    uint64_t nelts = v5->nelts;
    v5->uint64_t nelts = 0;
    uint64_t v13 = v11;
    uint64_t v14 = 0LL;
    uint64_t v15 = (nelts << 6) - 64;
    do
    {
      uint64_t v16 = 0LL;
      id v17 = v5->elts;
      uint64_t v18 = *(void *)&v17[v14 + 64];
      if (v18 <= 56)
      {
        if (v18 == 16)
        {
          uint64_t v20 = v13 + 31;
          uint64_t v19 = 32LL;
          goto LABEL_20;
        }

        if (v18 != 22) {
          goto LABEL_11;
        }
      }

      else if (v18 != 57)
      {
        if (v18 == 86)
        {
          uint64_t v20 = v13 + 255;
          uint64_t v19 = 256LL;
          goto LABEL_20;
        }

        if (v18 == 80)
        {
          uint64_t v19 = *(unsigned __int16 *)&v17[v14 + 124];
          uint64_t v20 = v13 + v19 - 1;
          goto LABEL_20;
        }

uint64_t AppendRestoreJobsToLoadQueue(uint64_t result, uint64_t a2)
{
  if (a2 && *(int *)(a2 + 12) >= 1)
  {
    uint64_t v3 = result;
    int v4 = 0;
    do
    {
      id v5 = apr_array_push(*(apr_array_header_t **)(v3 + 22504));
      *(_DWORD *)id v5 = 0;
      uint64_t v6 = *(void *)(a2 + 24) + ((uint64_t)v4 << 6);
      v5[1] = v6;
      int v7 = *(_DWORD *)(a2 + 12);
      uint64_t result = CountRequestsWithinCapacity(v6, (v7 - v4));
      *((_DWORD *)v5 + 1) = result;
      v4 += result;
    }

    while (v4 < v7);
  }

  return result;
}

uint64_t SignalLoadQueueThreads(uint64_t result, int a2)
{
  int v2 = *(_DWORD *)(result + 22576);
  if (v2 >= a2) {
    int v2 = a2;
  }
  if (v2 >= 1)
  {
    uint64_t v3 = result;
    int v4 = v2 & ~(v2 >> 31);
    do
    {
      dispatch_group_enter(*(dispatch_group_t *)(v3 + 22528));
      uint64_t result = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v3 + 22520));
      --v4;
    }

    while (v4);
  }

  return result;
}

void RestoreOrderedResourcesFromArchive(id *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  os_signpost_id_t v8 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
  __int128 v47 = v7;
  [v7 enterRestoreResources:a2 count:a3];
  id v50 = a1[3];
  uint64_t v48 = a1;
  uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([a1[1] defaultDevice]);
  id v9 = [v46 sharedMemorySize];
  __int128 v10 = g_signpostLog;
  uint64_t v11 = (os_log_s *)v10;
  os_signpost_id_t spid = v8;
  unint64_t v57 = v8 - 1;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v10))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v59) = a3;
    _os_signpost_emit_with_name_impl( &dword_0,  v11,  OS_SIGNPOST_INTERVAL_BEGIN,  v8,  "Replayer-2-restore",  "RestoreOrderedResourcesFromArchive x%d",  buf,  8u);
  }

  if ((int)a3 < 1)
  {
    uint64_t v12 = 0LL;
  }

  else
  {
    uint64_t v12 = 0LL;
    unint64_t v13 = 0LL;
    unint64_t v56 = 4 * (uint64_t)v9 / 0xAuLL;
    uint64_t v14 = a3;
    uint64_t v15 = &_os_log_disabled;
    do
    {
      uint64_t v16 = objc_autoreleasePoolPush();
      uint64_t v17 = RequestSize(a2);
      id v18 = v15;
      if (v57 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v15))
      {
        uint64_t v19 = *(void *)(a2 + 8);
        uint64_t v20 = *(void *)(a2 + 24);
        *(_DWORD *)buf = 134218498;
        uint64_t v59 = v19;
        __int16 v60 = 2048;
        uint64_t v61 = v17;
        __int16 v62 = 2082;
        uint64_t v63 = v20;
        _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v15,  OS_SIGNPOST_INTERVAL_BEGIN,  spid,  "Replayer-6-high",  "%llu. %{xcode:size-in-bytes}zu %{public}s",  buf,  0x20u);
      }

      if (*(void *)a2 == 57LL)
      {
        uint64_t v53 = v17;
        id v21 = *v48;
        Object = GTMTLSMContext_getObject(**((void **)*v48 + 5), *(void *)(a2 + 8), *(void *)(a2 + 16));
        uint64_t v23 = *((unsigned int *)Object + 34);
        uint64_t v51 = Object[13];
        uint64_t v52 = v23;
        MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(v51);
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
        unint64_t v55 = v13;
        unsigned __int8 v26 = (void *)objc_claimAutoreleasedReturnValue([v48[1] defaultDevice]);
        id v27 = [v26 newIndirectCommandBufferWithDescriptor:v25 maxCommandCount:v23 options:256];

        __int128 v28 = (apr_pool_t **)v48[19];
        __int128 v29 = *v28;
        Data = GTCaptureArchive_readData(*(const char ***)v21, v28, *(char **)(a2 + 24), *v28, 0LL);
        GTMTLSMContext_indirectCommandBufferResources((uint64_t)buf, *((_DWORD ***)v21 + 5), *((void *)v21 + 10), v29);
        id v31 = [v27 size];
        unsigned int v54 = v16;
        uint64_t v32 = v12;
        id v33 = v15;
        id v34 = (void *)objc_claimAutoreleasedReturnValue([v48[1] restoreIndirectCommandBufferDataMap]);
        uint64_t v35 = (uint64_t)v31;
        uint64_t v17 = v53;
        GTMTLEncodeIndirectCommandBufferWithRange(v27, 0LL, v35, v51, (uint64_t)Data, (uint64_t *)buf, v34);

        uint64_t v15 = v33;
        uint64_t v12 = v32;
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v48[1] indirectCommandBufferForKey:*(void *)(a2 + 8)]);
        id v37 = (void *)objc_claimAutoreleasedReturnValue([v48[3] blitCommandEncoder]);
        objc_msgSend( v37,  "copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:",  v27,  0,  v52,  v36,  0);

        uint64_t v16 = v54;
        apr_pool_clear(v29);

        unint64_t v13 = v55;
      }

      uint64_t v38 = g_signpostLog;
      __int128 v39 = (os_log_s *)v38;
      if (v57 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v38))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v39,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-6-high",  (const char *)&unk_3189BB,  buf,  2u);
      }

      v13 += v17;

      if (v13 >= v56)
      {
        __int128 v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"RestoreOrderedResourcesFromArchive"));
        id v41 = (void *)objc_claimAutoreleasedReturnValue([v50 commandBuffer]);
        [v41 setLabel:v40];

        [v50 commitCommandBuffer];
        unint64_t v13 = 0LL;
      }

      v12 += v17;
      objc_autoreleasePoolPop(v16);
      a2 += 64LL;
      --v14;
    }

    while (v14);
  }

  __int128 v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"RestoreOrderedResourcesFromArchive"));
  __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([v50 commandBuffer]);
  [v43 setLabel:v42];

  [v50 commitCommandBuffer];
  __int128 v44 = g_signpostLog;
  __int128 v45 = (os_log_s *)v44;
  if (v57 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v44))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v59 = v12;
    _os_signpost_emit_with_name_impl( &dword_0,  v45,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-2-restore",  "%{xcode:size-in-bytes}zu",  buf,  0xCu);
  }

  [v47 leaveActivity];
}

apr_hash_index_t *RestoreVisibleFunctionTablesForFunctionIndex(id *a1, unint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *((void *)*a1 + 21);
  *(void *)(v4 + 24) = 0LL;
  *(void *)(v4 + 32) = 0LL;
  *(void *)(v4 + 16) = v4;
  *(_DWORD *)(v4 + 40) = 0;
  uint64_t result = apr_hash_next((apr_hash_index_t *)(v4 + 16));
  if (result)
  {
    uint64_t v6 = result;
    char v7 = 1;
    unint64_t v53 = a2;
    unsigned int v54 = v3;
    do
    {
      uint64_t v8 = *((void *)v6 + 1);
      uint64_t v9 = *(void *)(v8 + 32);
      uint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v12 = **(void **)(v8 + 16);
      do
      {
        Object = GTMTLSMContext_getObject(**((void **)*v3 + 5), v12, a2);
        if (Object)
        {
          unint64_t v14 = Object[2];
          uint64_t v15 = *v3;
          unint64_t v16 = *((void *)*v3 + 8);
          if (v16 > v14 || *((void *)*v3 + 9) + v16 <= v14)
          {
            id v18 = (unint64_t *)(*(void *)(v9 + 24) + v10);
            unint64_t v19 = *v18;
            unint64_t v20 = v18[1] + *v18;
            if (*v18 <= a2 && v20 > a2)
            {
              if ((v7 & 1) != 0)
              {
                os_signpost_id_t v22 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v3);
                uint64_t v23 = g_signpostLog;
                uint64_t v24 = (os_log_s *)v23;
                if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v23))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl( &dword_0,  v24,  OS_SIGNPOST_INTERVAL_BEGIN,  v22,  "Replayer-2-restore",  "RestoreVisibleFunctionTablesFlush",  buf,  2u);
                }

                uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v3[1] defaultCommandQueue]);
                [v25 finish];
                unsigned __int8 v26 = g_signpostLog;
                id v27 = (os_log_s *)v26;
                if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v26))
                {
                  *(_WORD *)uint64_t v59 = 0;
                  _os_signpost_emit_with_name_impl( &dword_0,  v27,  OS_SIGNPOST_INTERVAL_END,  v22,  "Replayer-2-restore",  (const char *)&unk_3189BB,  v59,  2u);
                }

                uint64_t v15 = *v3;
              }

              uint64_t v58 = v15[2];
              id v28 = v3[1];
              uint64_t v29 = *((void *)*v3 + 1);
              uint64_t v61 = v12;
              uint64_t v30 = *(void *)(*(void *)(*find_entry(v29, &v61, 8uLL, 0LL) + 32LL) + 32LL);
              unsigned int v31 = 0;
              if (v30)
              {
                do
                {
                  unsigned int v32 = atomic_load((unsigned int *)(v30 + 4));
                  uint64_t v33 = v31 + (v32 >> 6) - 1;
                  uint64_t v30 = *(void *)(v30 + 40);
                  unsigned int v31 = v33;
                }

                while (v30);
                unsigned int v31 = v33;
              }

              else
              {
LABEL_28:
                uint64_t v33 = 0LL;
              }

              unint64_t v34 = v31 | (unint64_t)(v33 << 32);
              unint64_t v57 = v28;
LABEL_30:
              uint64_t v35 = v30 + 64;
LABEL_31:
              if (!v30
                || (int v36 = HIDWORD(v34) - v34, (*(_BYTE *)(v35 + ((uint64_t)(HIDWORD(v34) - (int)v34) << 6) + 15) & 8) == 0))
              {
LABEL_51:

                char v7 = 0;
                a2 = v53;
                break;
              }

              uint64_t v37 = v35 + ((uint64_t)v36 << 6);
              unint64_t v38 = *(void *)v37;
              if (v19 <= *(void *)v37 && v20 > v38)
              {
                int v40 = *(_DWORD *)(v37 + 8);
                if (v40 == -15597)
                {
                  __int128 v44 = GTTraceFunc_argumentBytesWithMap( (void *)v37,  *(unsigned __int8 *)(v35 + ((uint64_t)v36 << 6) + 13),  v58);
                  uint64_t v3 = v54;
                  unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v28 visibleFunctionTableForKey:*(void *)v44]);
                  p = *(apr_pool_t **)v54[19];
                  __int128 v45 = apr_palloc(p, 8LL * *((void *)v44 + 2));
                  uint64_t v46 = GTTraceFunc_argumentBytesWithMap((void *)v37, v44[24], v58);
                  if (*((void *)v44 + 2))
                  {
                    __int128 v47 = v46;
                    unint64_t v48 = 0LL;
                    do
                    {
                      v45[v48] = objc_msgSend(v57, "functionHandleForKey:", *(void *)&v47[8 * v48], v53);
                      ++v48;
                      unint64_t v49 = *((void *)v44 + 2);
                    }

                    while (v49 > v48);
                    uint64_t v3 = v54;
                  }

                  else
                  {
                    unint64_t v49 = 0LL;
                  }

                  __int128 v42 = v56;
                  objc_msgSend(v56, "setFunctions:withRange:", v45, *((void *)v44 + 1), v49, v53);
                  apr_pool_clear(p);
                  id v28 = v57;
                }

                else
                {
                  if (v40 != -15598) {
                    goto LABEL_49;
                  }
                  id v41 = GTTraceFunc_argumentBytesWithMap( (void *)v37,  *(unsigned __int8 *)(v35 + ((uint64_t)v36 << 6) + 13),  v58);
                  __int128 v42 = (void *)objc_claimAutoreleasedReturnValue([v28 visibleFunctionTableForKey:*(void *)v41]);
                  __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([v28 functionHandleForKey:*((void *)v41 + 1)]);
                  [v42 setFunction:v43 atIndex:*((void *)v41 + 2)];
                }

                uint64_t v35 = v30 + 64;
              }

              else if (v38 > v20)
              {
                goto LABEL_51;
              }

apr_hash_index_t *RestoreIntersectionFunctionTablesForFunctionIndex(id *a1, unint64_t a2)
{
  uint64_t v4 = *((void *)*a1 + 22);
  *(void *)(v4 + 24) = 0LL;
  *(void *)(v4 + 32) = 0LL;
  *(void *)(v4 + 16) = v4;
  *(_DWORD *)(v4 + 40) = 0;
  uint64_t result = apr_hash_next((apr_hash_index_t *)(v4 + 16));
  if (result)
  {
    uint64_t v6 = result;
    char v7 = 1;
    do
    {
      uint64_t v8 = *((void *)v6 + 1);
      uint64_t v9 = *(void *)(v8 + 32);
      if (*(int *)(v9 + 12) >= 1)
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        uint64_t v12 = **(void **)(v8 + 16);
        while (1)
        {
          Object = GTMTLSMContext_getObject(**((void **)*a1 + 5), v12, a2);
          if (Object)
          {
            unint64_t v14 = Object[2];
            unint64_t v15 = *((void *)*a1 + 8);
            if (v15 > v14 || *((void *)*a1 + 9) + v15 <= v14)
            {
              uint64_t v17 = (unint64_t *)(*(void *)(v9 + 24) + v10);
              unint64_t v18 = *v17;
              unint64_t v19 = v17[1] + *v17;
              if (v18 <= a2 && v19 > a2) {
                break;
              }
            }
          }

          ++v11;
          v10 += 16LL;
        }

        if ((v7 & 1) != 0)
        {
          os_signpost_id_t v21 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
          os_signpost_id_t v22 = g_signpostLog;
          uint64_t v23 = (os_log_s *)v22;
          if (v21 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v22))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl( &dword_0,  v23,  OS_SIGNPOST_INTERVAL_BEGIN,  v21,  "Replayer-2-restore",  "RestoreIntersectionFunctionTablesFlush",  buf,  2u);
          }

          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([a1[1] defaultCommandQueue]);
          [v24 finish];
          uint64_t v25 = g_signpostLog;
          unsigned __int8 v26 = (os_log_s *)v25;
          if (v21 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v25))
          {
            v27[0] = 0;
            _os_signpost_emit_with_name_impl( &dword_0,  v26,  OS_SIGNPOST_INTERVAL_END,  v21,  "Replayer-2-restore",  (const char *)&unk_3189BB,  (uint8_t *)v27,  2u);
          }
        }

        char v7 = 0;
      }

void DoLoadJob(uint64_t **a1, uint64_t a2, void *a3, apr_hash_t *a4)
{
  id v6 = a3;
  char v7 = v6;
  if (*(_DWORD *)a2 == 1)
  {
    ht = a4;
    uint64_t v25 = *(void *)(a2 + 8);
    uint64_t v26 = *(unsigned int *)(a2 + 4);
    id v27 = v6;
    os_signpost_id_t v28 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
    id v91 = v27;
    uint64_t v98 = v25;
    [v27 enterRestoreResources:v25 count:v26];
    uint64_t v29 = a1[3];
    uint64_t v108 = a1[1];
    uint64_t v107 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  (int)v26);
    uint64_t v30 = g_signpostLog;
    unsigned int v31 = (os_log_s *)v30;
    os_signpost_id_t spid = v28;
    unint64_t v95 = v28 - 1;
    if (v28 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v30))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v31,  OS_SIGNPOST_INTERVAL_BEGIN,  v28,  "Replayer-2-restore",  "DownloadBufferContent",  buf,  2u);
    }

    uint64_t v97 = v26;
    if ((int)v26 >= 1)
    {
      uint64_t v32 = v26;
      uint64_t v33 = (void *)(v25 + 40);
      do
      {
        if (*(v33 - 5) == 22LL)
        {
          unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v108 bufferForKey:*(v33 - 4)]);
          uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v29 bufferWithLength:*v33 alignment:1]);
          int v36 = (void *)objc_claimAutoreleasedReturnValue([v29 blitCommandEncoder]);
          uint64_t v37 = *(v33 - 1);
          unint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v35 heapBuffer]);
          objc_msgSend( v36,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v34,  v37,  v38,  objc_msgSend(v35, "heapLocation"),  *v33);

          __int128 v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(v33 - 4)));
          -[NSMutableDictionary setObject:forKey:](v107, "setObject:forKey:", v35, v39);
        }

        v33 += 8;
        --v32;
      }

      while (v32);
    }

    int v40 = (void *)objc_claimAutoreleasedReturnValue([v29 commandBuffer]);
    id v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"DownloadBufferContent"));
    [v40 setLabel:v41];

    [v29 commitCommandBuffer];
    [v40 waitUntilCompleted];

    p_class_meths = &OBJC_PROTOCOL___MTLResource.class_meths;
    __int128 v43 = g_signpostLog;
    __int128 v44 = (os_log_s *)v43;
    unint64_t v45 = v95;
    if (v95 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v43))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v44,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-2-restore",  (const char *)&unk_3189BB,  buf,  2u);
    }

    uint64_t v94 = **a1;
    uint64_t v46 = (apr_pool_t **)a1[19];
    p = *(apr_pool_t **)ht;
    __int128 v47 = g_signpostLog;
    unint64_t v48 = (os_log_s *)v47;
    uint64_t v50 = v97;
    uint64_t v49 = v98;
    if (v95 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v47))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v114) = v97;
      _os_signpost_emit_with_name_impl( &dword_0,  v48,  OS_SIGNPOST_INTERVAL_BEGIN,  spid,  "Replayer-2-restore",  "CompareAndRestoreResourcesFromArchive x%d",  buf,  8u);
    }

    uint64_t v92 = v7;

    if ((int)v97 < 1)
    {
      uint64_t v52 = 0LL;
    }

    else
    {
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      unint64_t v100 = v29;
      int v93 = v46;
      do
      {
        uint64_t v111 = objc_autoreleasePoolPush();
        unint64_t v53 = (uint64_t *)(v49 + (v51 << 6));
        uint64_t v112 = RequestSize((uint64_t)v53);
        id v54 = &_os_log_disabled;
        if (v45 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)&_os_log_disabled))
        {
          uint64_t v55 = v49 + (v51 << 6);
          uint64_t v56 = *(void *)(v55 + 8);
          uint64_t v57 = *(void *)(v55 + 24);
          *(_DWORD *)buf = 134218498;
          uint64_t v114 = v56;
          __int16 v115 = 2048;
          uint64_t v116 = v112;
          __int16 v117 = 2082;
          uint64_t v118 = v57;
          _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)&_os_log_disabled,  OS_SIGNPOST_INTERVAL_BEGIN,  spid,  "Replayer-6-high",  "%llu. %{xcode:size-in-bytes}zu %{public}s",  buf,  0x20u);
        }

        uint64_t v58 = *v53;
        if (*v53 == 86)
        {
          GTMTLReplayController_restoreIOSurfaceData_length_forPlane((uint64_t)a1, v49 + (v51 << 6));
        }

        else if (v58 == 80)
        {
          GTMTLReplayController_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)a1,  v49 + (v51 << 6));
        }

        else if (v58 == 22)
        {
          uint64_t v59 = v49 + (v51 << 6);
          __int16 v60 = (void *)objc_claimAutoreleasedReturnValue([v29 bufferWithLength:*(void *)(v59 + 40) alignment:1]);
          GTCaptureArchive_fillBuffer( v94,  v46,  *(char **)(v59 + 24),  (char *)[v60 contents],  *(void *)(v59 + 40),  0);
          uint64_t v61 = apr_array_make(p, 0, 16);
          dispatch_group_t v104 = (void *)(v59 + 8);
          dispatch_semaphore_t v102 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v59 + 8)));
          __int16 v62 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v107, "objectForKeyedSubscript:"));
          id v63 = v60;
          id v64 = (char *)[v62 length];
          id v101 = v62;
          id v65 = (char *)[v62 contents];
          __int128 v103 = v63;
          id v66 = (char *)[v63 contents];
          if (v64)
          {
            __int128 v67 = v66;
            BOOL v68 = 0;
            unint64_t v69 = 0LL;
            for (unint64_t i = 0LL; i < (unint64_t)v64; i += 0x10000LL)
            {
              unint64_t v71 = (unint64_t)&v64[-i];
              while (1)
              {
                unint64_t v72 = v71 - 0x10000;
                size_t v73 = v71 >= 0x10000 ? 0x10000LL : v71;
                int v74 = memcmp(&v65[i], &v67[i], v73);
                if (v74 || !v68) {
                  break;
                }
                BOOL v75 = apr_array_push(v61);
                BOOL v68 = 0;
                *BOOL v75 = v69;
                v75[1] = i - v69;
                i += 0x10000LL;
                unint64_t v71 = v72;
              }

              if (((v68 ^ (v74 != 0)) & 1) != 0)
              {
                unint64_t v69 = i;
                BOOL v68 = v74 != 0;
              }
            }

            if (v68)
            {
              uint64_t v76 = apr_array_push(v61);
              *uint64_t v76 = v69;
              v76[1] = &v64[-v69];
            }
          }

uint64_t RequestSize(uint64_t a1)
{
  uint64_t result = 0LL;
  uint64_t v3 = *(void *)a1;
  if (*(uint64_t *)a1 > 49)
  {
    if (v3 == 86) {
      return *(unsigned int *)(a1 + 32);
    }
    if (v3 == 80) {
      return *(unsigned int *)(a1 + 56);
    }
    if (v3 != 50) {
      return result;
    }
    return *(void *)(a1 + 40);
  }

  if (v3 == 16) {
    return *(void *)(a1 + 32);
  }
  if (v3 == 22) {
    return *(void *)(a1 + 40);
  }
  return result;
}

void GTMTLReplayController_restoreIOSurfaceData_length_forPlane(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(apr_pool_t ***)(a1 + 152);
  id v5 = *v4;
  Data = GTCaptureArchive_readData(**(const char ****)a1, v4, *(char **)(a2 + 24), *v4, 0LL);
  unint64_t v8 = v7;
  id v37 = *(id *)(a1 + 8);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v37 textureForKey:*(void *)(a2 + 8)]);
  id v10 = (__IOSurface *)[v9 iosurface];
  os_signpost_id_t v11 = v10;
  if (Data) {
    BOOL v12 = v8 >= 0x10;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12 && *(void *)Data == 0x63617074757265LL)
  {
    IOSurfaceLock(v10, 0, 0LL);
    if (!IOSurfaceGetPlaneCount(v11)) {
      IOSurfaceGetAllocSize(v11);
    }
    uint64_t v13 = *((void *)Data + 2);
    if (v13 <= 1)
    {
      if (v13 != 1) {
        goto LABEL_31;
      }
      uint64_t v14 = *(int *)(a2 + 36);
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    uint64_t v29 = Data;
    if (*(void *)Data == 0x63617074757265LL)
    {
      uint64_t v30 = *((int *)Data + 3);
      if (*((_WORD *)Data + 4) == 1) {
        v30 += 16LL;
      }
      uint64_t v29 = &Data[v30];
    }

    uint64_t v31 = 0LL;
    uint64_t v32 = (size_t *)(Data + 64);
    do
    {
      IOSurfaceGetHeightOfPlane(v11, v14 + v31);
      IOSurfaceGetWidthOfPlane(v11, v14 + v31);
      IOSurfaceGetBytesPerRowOfPlane(v11, v14 + v31);
      BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(v11, v14 + v31);
      memcpy(BaseAddressOfPlane, v29, *v32);
      size_t v34 = *v32;
      v32 += 6;
      v29 += v34;
      ++v31;
    }

    while (*((void *)Data + 2) > v31);
  }

  else if (((unint64_t)[v9 pixelFormat] & 0xFFFFFFFFFFFFFFFELL) == 0x226)
  {
    os_signpost_id_t v11 = (__IOSurface *)[v9 iosurface];
    IOSurfaceLock(v11, 0, 0LL);
    size_t PlaneCount = IOSurfaceGetPlaneCount(v11);
    if (PlaneCount)
    {
      size_t v16 = PlaneCount;
      uint64_t v35 = v9;
      int v36 = v5;
      uint64_t v17 = 0LL;
      for (size_t i = 0LL; i != v16; ++i)
      {
        size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(v11, i);
        size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(v11, i);
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v11, i);
        size_t BytesPerElementOfPlane = IOSurfaceGetBytesPerElementOfPlane(v11, i);
        uint64_t v23 = (char *)IOSurfaceGetBaseAddressOfPlane(v11, i);
        if (HeightOfPlane)
        {
          uint64_t v24 = v23;
          size_t v25 = BytesPerElementOfPlane * WidthOfPlane;
          do
          {
            memcpy(v24, &Data[v17], v25);
            v17 += v25;
            v24 += BytesPerRowOfPlane;
            --HeightOfPlane;
          }

          while (HeightOfPlane);
        }
      }

      uint64_t v9 = v35;
      id v5 = v36;
    }
  }

  else
  {
    IOSurfaceLock(v11, 0, 0LL);
    uint64_t v26 = IOSurfaceGetBaseAddressOfPlane(v11, *(unsigned int *)(a2 + 36));
    size_t v27 = *(unsigned int *)(a2 + 32);
    if (IOSurfaceGetAllocSize(v11) <= v27) {
      size_t AllocSize = IOSurfaceGetAllocSize(v11);
    }
    else {
      size_t AllocSize = *(unsigned int *)(a2 + 32);
    }
    memcpy(v26, Data, AllocSize);
  }

uint64_t CountRequestsWithinCapacity(uint64_t a1, uint64_t a2)
{
  if ((int)a2 >= 2)
  {
    uint64_t v2 = a2;
    unint64_t v4 = RequestSize(a1);
    uint64_t v5 = a1 + 64;
    uint64_t v6 = 1LL;
    while (1)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = *(void *)v5;
      if (*(uint64_t *)v5 <= 56)
      {
        if (v8 == 16)
        {
          uint64_t v10 = v4 + 31;
          uint64_t v9 = 32LL;
          goto LABEL_22;
        }

        if (v8 != 22) {
          goto LABEL_10;
        }
      }

      else if (v8 != 57)
      {
        if (v8 == 86)
        {
          uint64_t v10 = v4 + 255;
LABEL_19:
          uint64_t v9 = 256LL;
          goto LABEL_22;
        }

        if (v8 == 80)
        {
          uint64_t v9 = *(unsigned __int16 *)(v5 + 60);
          uint64_t v10 = v4 + v9 - 1;
          goto LABEL_22;
        }

uint64_t CompareRequestsBySize(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = RequestSize(a2);
  unint64_t v5 = RequestSize(a1);
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 != v5) {
    return 1LL;
  }
  unint64_t v7 = *(void *)(a1 + 8);
  unint64_t v8 = *(void *)(a2 + 8);
  BOOL v9 = v7 >= v8;
  BOOL v10 = v7 != v8;
  if (v9) {
    return v10;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void __destructor_8_s8_s16_s24_s40_s48_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_S_s144_S_s22520_s22528_S_s22536_s22560_s22568( id *a1)
{
}

void GTMTLReplayController_optimizeRestores(void **a1)
{
  uint64_t v2 = a1[2817];
  a1[2817] = 0LL;

  apr_hash_clear((apr_hash_t *)a1[2818]);
  a1[2819] = (void *)(*a1)[17];
  if ((dword_5B9DE4 & 0x10) == 0)
  {
    [a1[3] releaseBuffer];
    [a1[2] waitUntilCapacity];
    [(id)g_activityLog enterOptimizeRestores];
    int v148 = a1;
    os_signpost_id_t v3 = os_signpost_id_generate((os_log_t)g_signpostLog);
    unint64_t v4 = g_signpostLog;
    unint64_t v5 = (os_log_s *)v4;
    os_signpost_id_t spid = v3;
    unint64_t v135 = v3 - 1;
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v4))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v5,  OS_SIGNPOST_INTERVAL_BEGIN,  v3,  "Replayer-1-serial",  "PlayCaptureAndRewind",  buf,  2u);
    }

    apr_pool_create_ex(&newpool, 0LL, 0LL, v6);
    p = newpool;
    uint64_t v139 = (apr_pool_t **)apr_hash_make(newpool);
    unint64_t v7 = (apr_array_header_t **)v148;
    GTMTLReplayController_rewind((uint64_t)v148);
    uint64_t v8 = (*v148)[15];
    BOOL v9 = (unsigned int *)(v148 + 2810);
    if (*((_DWORD *)v148 + 5620) < *(_DWORD *)(v8 + 12))
    {
      unint64_t v7 = (apr_array_header_t **)v148;
      do
      {
        BOOL v10 = objc_autoreleasePoolPush();
        uint64_t v11 = *(void *)(v8 + 24) + ((unint64_t)*v9 << 6);
        int v12 = *(_DWORD *)(v11 + 8);
        if (GetFuncEnumConstructorType(v12) == 25)
        {
          CompareCommandBufferRestore((apr_array_header_t **)v148, v11, v139);
          int v12 = *(_DWORD *)(v11 + 8);
        }

        GTMTLReplayController_updateCommandEncoder((uint64_t)v148, v11);
        GTMTLReplayController_defaultDispatchFunction((uint64_t)v148, v11);
        objc_autoreleasePoolPop(v10);
        unsigned int v13 = *v9 + 1;
        *BOOL v9 = v13;
      }

      while (v13 < *(_DWORD *)(v8 + 12));
    }

    RewindWithoutRestore((uint64_t)v7);
    RestoreCommandBuffer(v7, 0LL, p, (apr_hash_t *)v139);
    uint64_t v14 = g_signpostLog;
    unint64_t v15 = (os_log_s *)v14;
    if (v135 > 0xFFFFFFFFFFFFFFFDLL)
    {

      size_t v16 = g_signpostLog;
    }

    else
    {
      if (os_signpost_enabled((os_log_t)v14))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v15,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
      }

      size_t v16 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v16))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v16,  OS_SIGNPOST_INTERVAL_BEGIN,  spid,  "Replayer-1-serial",  "SortCommandBufferKeys",  buf,  2u);
      }
    }

    uint64_t v17 = (*v148)[17];
    arr = apr_array_make(p, *(_DWORD *)(v17 + 48), 8);
    *(void *)(v17 + 24) = 0LL;
    *(void *)(v17 + 32) = 0LL;
    uint64_t v18 = (apr_hash_index_t *)(v17 + 16);
    *(void *)(v17 + 16) = v17;
    uint64_t v168 = v17;
    *(_DWORD *)(v17 + 40) = 0;
    while (1)
    {
      id v19 = apr_hash_next(v18);
      if (!v19) {
        break;
      }
      uint64_t v18 = v19;
      uint64_t v20 = **(void **)(*((void *)v19 + 1) + 16LL);
      *(void *)apr_array_push(arr) = v20;
    }

    qsort(arr->elts, arr->nelts, arr->elt_size, (int (__cdecl *)(const void *, const void *))CompareU64Pointer);
    int nelts = arr->nelts;
    if (nelts)
    {
      elts = arr->elts;
      if (!*(void *)elts)
      {
        memmove(elts, elts + 8, 8LL * (nelts - 1));
        *(void *)&arr->elts[8 * arr->nelts - 8] = 0LL;
      }
    }

    uint64_t v23 = g_signpostLog;
    uint64_t v24 = (os_log_s *)v23;
    if (v135 > 0xFFFFFFFFFFFFFFFDLL)
    {

      size_t v25 = g_signpostLog;
    }

    else
    {
      if (os_signpost_enabled((os_log_t)v23))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v24,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
      }

      size_t v25 = g_signpostLog;
      if (os_signpost_enabled((os_log_t)v25))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v25,  OS_SIGNPOST_INTERVAL_BEGIN,  spid,  "Replayer-1-serial",  "FitResourcesInOptimizedBuffer",  buf,  2u);
      }
    }

    uint64_t v140 = (apr_pool_t *)*v148[2819];
    ht = apr_hash_make(p);
    if (arr->nelts >= 1)
    {
      uint64_t v26 = 0LL;
      uint64_t v27 = 0LL;
      os_signpost_id_t v28 = arr;
      while (1)
      {
        v174[0] = *(void *)&v28->elts[8 * v26];
        uint64_t v29 = *find_entry((uint64_t)v139, v174, 8uLL, 0LL);
        uint64_t v30 = v29 ? *(void *)(v29 + 32) : 0LL;
        uint64_t v31 = *find_entry(v168, v174, 8uLL, 0LL);
        uint64_t v32 = v31 ? *(const apr_array_header_t **)(v31 + 32) : 0LL;
        uint64_t v33 = apr_array_copy(v140, v32);
        qsort(v33->elts, v33->nelts, v33->elt_size, (int (__cdecl *)(const void *, const void *))CompareRequestsBySize);
        uint64_t v34 = v33->nelts;
        v33->int nelts = 0;
LABEL_96:
        os_signpost_id_t v28 = arr;
        apr_hash_set(ht, &arr->elts[8 * v26], 8LL, v33);
        int v62 = v33->nelts;
        id v63 = (apr_array_header_t *)apr_palloc(v140, 0x20uLL);
        v63->pool = v140;
        int elt_size = v33->elt_size;
        v63->int nelts = v34 - v62;
        v63->nalloc = v34 - v62;
        v63->int elt_size = elt_size;
        v63->elts = &v33->elts[v33->elt_size * (uint64_t)v62];
        GroupRequestsByCapacity(v63, v65, v66, v67);
        BOOL v68 = (apr_hash_t *)v148[2819];
        unint64_t v69 = apr_palloc(v140, 8uLL);
        void *v69 = v174[0];
        apr_hash_set(v68, v69, 8LL, v63);
        if (++v26 >= arr->nelts) {
          goto LABEL_99;
        }
      }

      uint64_t v35 = 0LL;
      while (1)
      {
        int v36 = v33->elts;
        id v37 = &v36[64 * v35];
        if (*(void *)v37 != 22LL)
        {
          if (*(void *)v37 != 80LL) {
            goto LABEL_95;
          }
          GTMTLSMContext_getTextureDescriptor( (uint64_t *)(*v148)[5],  *(void *)&v36[64 * v35 + 8],  *(void *)&v36[64 * v35 + 16],  (uint64_t)buf);
          if (GetPlanePixelFormat(WORD1(v180), 0LL)) {
            goto LABEL_95;
          }
        }

        uint64_t v38 = *find_entry(v30, v37 + 8, 8uLL, 0LL);
        if (!v38 || (uint64_t v39 = *(void *)(v38 + 32)) == 0)
        {
          uint64_t v42 = RequestSize((uint64_t)&v36[64 * v35]);
          uint64_t v40 = *(void *)v37;
          goto LABEL_61;
        }

        uint64_t v40 = *(void *)v37;
        if (*(uint64_t *)v37 <= 56)
        {
          if (v40 != 16)
          {
            uint64_t v41 = 1LL;
            if (v40 == 22) {
              goto LABEL_56;
            }
            goto LABEL_53;
          }

          uint64_t v41 = 32LL;
        }

        else
        {
          uint64_t v41 = 1LL;
          if (v40 == 57) {
            goto LABEL_56;
          }
          if (v40 != 86)
          {
            if (v40 == 80)
            {
              uint64_t v41 = *(unsigned __int16 *)&v36[64 * v35 + 60];
              goto LABEL_56;
            }

LABEL_53:
            uint64_t v41 = 0LL;
            goto LABEL_56;
          }

          uint64_t v41 = 256LL;
        }

          uint64_t v50 = 0LL;
          uint64_t v51 = v47 | (unint64_t)(v49 << 32);
LABEL_54:
          uint64_t v52 = v46 + 64;
          while (v46)
          {
            uint64_t v53 = HIDWORD(v51) - v51;
            uint64_t v54 = v53;
            uint64_t v55 = *(void *)(v52 + ((uint64_t)v53 << 6));
            if (v55 >= v33) {
              break;
            }
            uint64_t v56 = *(_DWORD *)(v52 + (v54 << 6) + 8);
            __int128 v58 = atomic_load((unsigned int *)(v46 + 4));
            __int128 v59 = (HIDWORD(v51) + 1);
            __int128 v60 = v51 + (v58 >> 6) - 1;
            uint64_t v51 = (v59 << 32) | v51;
            if ((_DWORD)v59 == v60)
            {
              uint64_t v51 = (v59 << 32) | v59;
              uint64_t v46 = *(void *)(v46 + 40);
              goto LABEL_54;
            }
          }

          uint64_t v61 = *(void *)(v44 + 32);
          hsize_t i = v42;
          uint64_t v101 = v39;
          int v62 = 0;
          if (v61)
          {
            while (1)
            {
              id v63 = atomic_load((unsigned int *)(v61 + 4));
              id v64 = v62 + (v63 >> 6) - 1;
              uint64_t v61 = *(void *)(v61 + 40);
              int v62 = v64;
              if (!v61)
              {
                int v62 = v64;
                goto LABEL_70;
              }
            }
          }

          id v64 = 0LL;
LABEL_70:
          uint64_t v65 = v62 | (unint64_t)(v64 << 32);
LABEL_71:
          uint64_t v66 = v61 + 64;
          while (v61)
          {
            __int128 v67 = HIDWORD(v65) - v65;
            BOOL v68 = (unint64_t *)(v66 + ((uint64_t)v67 << 6));
            if (*v68 >= v50)
            {
              if (*v68 >= v33)
              {
              }

              else
              {
                switch(*(_DWORD *)(v66 + ((uint64_t)v67 << 6) + 8))
                {
                  case 0xFFFFC48C:
                    uint64_t v101 = apr_hash_copy(*h, (const apr_hash_t *)h);
                    break;
                  case 0xFFFFC494:
                    uint64_t v98 = v66;
                    unint64_t v72 = GTTraceFunc_argumentBytesWithMap( v68,  *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13),  v45)
                        + 8;
                    size_t v73 = *find_entry((uint64_t)h, v72, 8uLL, 0LL);
                    if (!v73 || !*(void *)(v73 + 32))
                    {
                      int v74 = apr_palloc(*h, 8uLL);
                      *int v74 = *(void *)v72;
                      apr_hash_set((apr_hash_t *)h, v74, 8LL, v74);
                    }

                    uint64_t v66 = v98;
                    break;
                  case 0xFFFFC495:
                    BOOL v75 = v45;
                    uint64_t v76 = GTTraceFunc_argumentBytesWithMap( v68,  *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13),  v45);
                    uint64_t v77 = GTTraceFunc_argumentBytesWithMap(v68, v76[16], v75);
                    uint64_t v102 = v76;
                    if (!*((void *)v76 + 1)) {
                      goto LABEL_101;
                    }
                    uint64_t v78 = v77;
                    uint64_t v97 = v75;
                    size_t v99 = v66;
                    uint64_t v79 = 0LL;
                    uint64_t v80 = 0LL;
                    do
                    {
                      uint64_t v81 = *find_entry((uint64_t)h, &v78[v79], 8uLL, 0LL);
                      if (!v81 || !*(void *)(v81 + 32))
                      {
                        if (v78)
                        {
                          uint64_t v82 = (apr_hash_t *)h;
                          int v83 = apr_palloc(*h, 8uLL);
                          *int v83 = *(void *)&v78[8 * v80];
                        }

                        else
                        {
                          int v83 = 0LL;
                          uint64_t v82 = (apr_hash_t *)h;
                        }

                        apr_hash_set(v82, v83, 8LL, v83);
                      }

                      ++v80;
                      v79 += 8LL;
                    }

                    while (*((void *)v102 + 1) > v80);
                    goto LABEL_100;
                  case 0xFFFFC498:
                    apr_hash_clear((apr_hash_t *)h);
                    break;
                  case 0xFFFFC499:
                    uint64_t v84 = GTTraceFunc_argumentBytesWithMap( v68,  *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13),  v45);
                    apr_hash_set((apr_hash_t *)h, v84 + 8, 8LL, 0LL);
                    break;
                  case 0xFFFFC49A:
                    BOOL v75 = v45;
                    uint64_t v85 = GTTraceFunc_argumentBytesWithMap( v68,  *(unsigned __int8 *)(v66 + ((uint64_t)v67 << 6) + 13),  v45);
                    unint64_t v86 = GTTraceFunc_argumentBytesWithMap(v68, v85[16], v75);
                    if (*((void *)v85 + 1))
                    {
                      uint64_t v87 = v86;
                      uint64_t v97 = v75;
                      size_t v99 = v66;
                      uint64_t v88 = 0LL;
                      do
                      {
                        apr_hash_set((apr_hash_t *)h, v87, 8LL, 0LL);
                        ++v88;
                        v87 += 8;
                      }

                      while (*((void *)v85 + 1) > v88);
LABEL_100:
                      uint64_t v45 = v97;
                      uint64_t v66 = v99;
                    }

                    else
                    {
LABEL_101:
                      uint64_t v45 = v75;
                    }

                    break;
                  default:
                    break;
                }
              }
            }

            unint64_t v69 = atomic_load((unsigned int *)(v61 + 4));
            char v70 = v65 + (v69 >> 6);
            unint64_t v71 = (HIDWORD(v65) + 1);
            uint64_t v65 = (v71 << 32) | v65;
            if ((_DWORD)v71 == v70 - 1)
            {
              uint64_t v65 = (v71 << 32) | v71;
              uint64_t v61 = *(void *)(v61 + 40);
              goto LABEL_71;
            }
          }

          uint64_t v89 = 1;
          uint64_t v39 = v101;
          do
          {
            uint64_t v90 = v89;
            if ((v89 & 1) != 0) {
              id v91 = v101;
            }
            else {
              id v91 = (apr_hash_t *)h;
            }
            for (size_t i = apr_hash_first(pool, v91); ; size_t i = apr_hash_next(v93))
            {
              int v93 = i;
              if (!i) {
                break;
              }
              id v94 = *(uint64_t **)(*((void *)i + 1) + 16LL);
              if (GTResourceTrackerGetResourceType(*v94, *(void *)a1) == 50)
              {
                GTResourceTrackerUsingResourceHeap((uint64_t *)a1, *v94, v33);
              }

              else
              {
                BOOL v95 = *(void *)(a1 + 16);
                ResourceType = GTResourceTrackerGetResourceType(*v94, *(void *)a1);
                GTResourceTrackerUsingResource(v95, ResourceType, *v94, *(void *)a1, *(void *)(a1 + 8));
              }
            }

            uint64_t v89 = 0;
          }

          while ((v90 & 1) != 0);
          apr_hash_clear(v101);
          apr_hash_clear((apr_hash_t *)h);
          uint64_t v42 = apr_hash_next(hi);
        }

        while (v42);
        uint64_t v38 = pool;
      }

      apr_pool_destroy(v38);
      apr_hash_clear(*(apr_hash_t **)(a1 + 40));
    }
  }

                  uint64_t v40 = 0;
LABEL_54:
                  uint64_t v33 = 0;
LABEL_68:
                  switch(v27)
                  {
                    case 0x3Cu:
                      if (v40)
                      {
                        int v36 = a3[15];
                        a3[15] = v36 + 24;
                        unint64_t v7 = DecodeDYMTLPointerType(v36, (unsigned int *)((char *)v7 + *v7), (uint64_t)a3, a4, a5);
                      }

                      else
                      {
                        int v36 = 0LL;
                      }

                      LOBYTE(v27) = 60;
                      goto LABEL_36;
                    case 2u:
                      if (a5)
                      {
                        if (v39)
                        {
                          uint64_t v50 = a3;
                          int v36 = a3[18];
                          a3[18] = v36 + 32;
                          uint64_t v51 = (unsigned int *)((char *)v7 + *v7);
                          uint64_t v52 = v36;
                          uint64_t v53 = a4;
                          uint64_t v54 = a5;
                          goto LABEL_87;
                        }

                        uint64_t v56 = *a5;
                        unint64_t v71 = 0LL;
                        unint64_t v72 = 0LL;
                        size_t v73 = 0LL;
                        BOOL v68 = v56;
                        unint64_t v69 = 500;
                        char v70 = "isArrayType";
                        int v74 = 0LL;
                        GTError_addError(a5, (uint64_t)&v68);
LABEL_92:
                        int v36 = 0LL;
                      }

                      else
                      {
                        if (!v39) {
                          goto LABEL_92;
                        }
                        uint64_t v50 = a3;
                        int v36 = a3[18];
                        a3[18] = v36 + 32;
                        uint64_t v51 = (unsigned int *)((char *)v7 + *v7);
                        uint64_t v52 = v36;
                        uint64_t v53 = a4;
                        uint64_t v54 = 0LL;
LABEL_87:
                        unint64_t v7 = DecodeDYMTLArrayType(v52, v51, v50, v53, v54);
                      }

                      LOBYTE(v27) = 2;
                      goto LABEL_36;
                    case 1u:
                      if (a5)
                      {
                        if (v38)
                        {
                          uint64_t v45 = a3;
                          int v36 = a3[16];
                          a3[16] = v36 + 24;
                          uint64_t v46 = (char *)v7 + *v7;
                          uint64_t v47 = v36;
                          uint64_t v48 = a4;
                          uint64_t v49 = a5;
                          goto LABEL_84;
                        }

                        uint64_t v55 = *a5;
                        unint64_t v71 = 0LL;
                        unint64_t v72 = 0LL;
                        size_t v73 = 0LL;
                        BOOL v68 = v55;
                        unint64_t v69 = 500;
                        char v70 = "isStructType";
                        int v74 = 0LL;
                        GTError_addError(a5, (uint64_t)&v68);
LABEL_89:
                        int v36 = 0LL;
                      }

                      else
                      {
                        if (!v38) {
                          goto LABEL_89;
                        }
                        uint64_t v45 = a3;
                        int v36 = a3[16];
                        a3[16] = v36 + 24;
                        uint64_t v46 = (char *)v7 + *v7;
                        uint64_t v47 = v36;
                        uint64_t v48 = a4;
                        uint64_t v49 = 0LL;
LABEL_84:
                        unint64_t v7 = (unsigned int *)DecodeDYMTLStructType(v47, v46, v45, v48, v49);
                      }

                      LOBYTE(v27) = 1;
                      goto LABEL_36;
                  }

LABEL_56:
        uint64_t v43 = *(unsigned int *)(v39 + 12);
        if ((int)v43 < 1)
        {
          uint64_t v42 = 0LL;
        }

        else
        {
          uint64_t v42 = 0LL;
          uint64_t v44 = v41 - 1;
          uint64_t v45 = -v41;
          uint64_t v46 = (uint64_t *)(*(void *)(v39 + 24) + 8LL);
          do
          {
            uint64_t v47 = *v46;
            v46 += 2;
            uint64_t v42 = ((v44 + v42) & v45) + v47;
            --v43;
          }

          while (v43);
        }

      uint64_t v29 = a1;
      uint64_t v30 = 80;
LABEL_233:
      id v222 = tracker_resource_get(v29, v30, v28, a3);
      if (v222) {
        v222[4] = a3;
      }
      return;
    }

    if (v6 > -16088)
    {
      switch(v6)
      {
        case -16047:
        case -16043:
          goto LABEL_86;
        case -16046:
        case -16042:
          goto LABEL_42;
        case -16045:
        case -16041:
          goto LABEL_85;
        case -16044:
          unint64_t v161 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v162 = GTTraceFunc_argumentBytesWithMap((void *)a2, v161[16], a1[1]);
          uint64_t v163 = *((void *)v161 + 1);
          if (v163)
          {
            uint64_t v164 = (uint64_t *)v162;
            do
            {
              os_signpost_id_t v165 = *v164++;
              GTResourceTrackerUsingResourceHeap(a1, v165, a3);
              --v163;
            }

            while (v163);
          }

          break;
        case -16040:
          __int128 v166 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          __int128 v167 = GTTraceFunc_argumentBytesWithMap((void *)a2, v166[16], a1[1]);
          uint64_t v168 = *((void *)v166 + 1);
          if (v168)
          {
            uint64_t v169 = (uint64_t *)v167;
            do
            {
              uint64_t v170 = *v169++;
              GTResourceTrackerUsingResourceHeap(a1, v170, a3);
              --v168;
            }

            while (v168);
          }

          break;
        default:
          switch(v6)
          {
            case -16087:
              uint64_t v45 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v46 = a1[2];
              uint64_t v47 = GTTraceFunc_argumentBytesWithMap((void *)a2, v45[24], a1[1]);
              uint64_t v48 = *((void *)v45 + 2);
              if (v48)
              {
                uint64_t v49 = (uint64_t *)v47;
                uint64_t v51 = *a1;
                uint64_t v50 = a1[1];
                do
                {
                  uint64_t v53 = *v49++;
                  uint64_t v52 = v53;
                  if (v53) {
                    GTResourceTrackerUsingResource(v46, 22, v52, v51, v50);
                  }
                  --v48;
                }

                while (v48);
              }

              break;
            case -16086:
              __int128 v194 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              signed int v195 = a1[2];
              uint64_t v196 = GTTraceFunc_argumentBytesWithMap((void *)a2, v194[24], a1[1]);
              char v197 = *((void *)v194 + 2);
              if (v197)
              {
                __int128 v198 = (uint64_t *)v196;
                int v200 = *a1;
                dispatch_semaphore_t v199 = a1[1];
                do
                {
                  uint64_t v202 = *v198++;
                  uint64_t v201 = v202;
                  if (v202) {
                    GTResourceTrackerUsingResource(v195, 80, v201, v200, v199);
                  }
                  --v197;
                }

                while (v197);
              }

              break;
            case -16085:
              uint64_t v203 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              uint64_t v204 = a1[2];
              uint64_t v205 = GTTraceFunc_argumentBytesWithMap((void *)a2, v203[24], a1[1]);
              uint64_t v206 = *((void *)v203 + 2);
              if (v206)
              {
                uint64_t v207 = (uint64_t *)v205;
                id v209 = *a1;
                id v208 = a1[1];
                do
                {
                  unsigned int v211 = *v207++;
                  v210 = v211;
                  if (v211) {
                    GTResourceTrackerUsingResource(v204, 75, v210, v209, v208);
                  }
                  --v206;
                }

                while (v206);
              }

              break;
            case -16084:
              id v212 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
              id v213 = a1[2];
              signed int v214 = GTTraceFunc_argumentBytesWithMap((void *)a2, v212[24], a1[1]);
              BOOL v215 = *((void *)v212 + 2);
              if (v215)
              {
                uint64_t v216 = (uint64_t *)v214;
                uint64_t v218 = *a1;
                id v217 = a1[1];
                do
                {
                  uint64_t v220 = *v216++;
                  unint64_t v219 = v220;
                  if (v220) {
                    GTResourceTrackerUsingResource(v213, 75, v219, v218, v217);
                  }
                  --v215;
                }

                while (v215);
              }

              break;
            case -16083:
            case -16082:
            case -16081:
            case -16080:
              return;
            case -16079:
              goto LABEL_211;
            default:
              if (v6 == -16017) {
                goto LABEL_211;
              }
              break;
          }

          break;
      }
    }

    else
    {
      switch(v6)
      {
        case -16156:
        case -16155:
          goto LABEL_71;
        case -16148:
          goto LABEL_211;
        case -16147:
          goto LABEL_29;
        case -16146:
          uint64_t v156 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          size_t v157 = v156[2];
          goto LABEL_297;
        case -16145:
          uint64_t v158 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          uint64_t v159 = v158[4];
          goto LABEL_303;
        case -16144:
          uint64_t v158 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a1[1]);
          GTResourceTrackerResourceRead(a1, 22, v158[2], a3);
          uint64_t v159 = v158[4];
          goto LABEL_303;
        case -16142:
          goto LABEL_99;
        case -16140:
          goto LABEL_69;
        case -16139:
        case -16138:
          goto LABEL_60;
        case -16133:
          goto LABEL_398;
        case -16131:
        case -16130:
        case -16129:
        case -16126:
        case -16125:
        case -16124:
          goto LABEL_58;
        default:
          return;
      }
    }
  }

            Offset = v270;
            goto LABEL_57;
          }

LABEL_61:
        uint64_t v48 = 0LL;
        if (v40 <= 56)
        {
          if (v40 == 16)
          {
            uint64_t v50 = v27 + 31;
            uint64_t v49 = 32LL;
            goto LABEL_77;
          }

          if (v40 != 22) {
            goto LABEL_68;
          }
        }

        else if (v40 != 57)
        {
          if (v40 == 86)
          {
            uint64_t v50 = v27 + 255;
            uint64_t v49 = 256LL;
            goto LABEL_77;
          }

          if (v40 == 80)
          {
            uint64_t v49 = *(unsigned __int16 *)&v36[64 * v35 + 60];
            uint64_t v50 = v27 + v49 - 1;
            goto LABEL_77;
          }

            uint64_t v50 = v52;
          }

          if (-[NSMutableArray count](v242, "count"))
          {
            id v64 = v226[4 * v42 + 1];
            uint64_t v65 = -[NSMutableArray copy](v242, "copy");
            uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v64));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v206, "setObject:forKeyedSubscript:", v65, v66);

            -[NSMutableArray removeAllObjects](v242, "removeAllObjects");
          }

          apr_pool_clear(pb);

          uint64_t v41 = v239[14];
        }

        ++v42;
      }

      while (v42 < *(int *)(v41 + 12));
    }

    apr_pool_destroy(v213);

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v201,  "setObject:forKeyedSubscript:",  v206,  @"DependencyGraphRequestedTexturesForThumbnail");
    DependencyGraphThumbnails = GTMTLReplayClient_generateDependencyGraphThumbnails((uint64_t)*a1, v201, v202);
    uint64_t v204 = (void *)objc_claimAutoreleasedReturnValue(DependencyGraphThumbnails);
    unsigned int v227 = (id)objc_claimAutoreleasedReturnValue([v204 objectForKeyedSubscript:@"object"]);
    BOOL v68 = (void *)objc_claimAutoreleasedReturnValue([v227 allKeys]);
    unint64_t v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v68, "sortedArrayUsingSelector:"));

    __int128 v241 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v227 count]));
    uint64_t v302 = 0u;
    unint64_t v303 = 0u;
    uint64_t v300 = 0u;
    v301 = 0u;
    signed int v214 = v69;
    unint64_t v232 = [v214 countByEnumeratingWithState:&v300 objects:v294 count:16];
    if (v232)
    {
      pc = *(apr_pool_t **)v301;
      do
      {
        char v70 = 0LL;
        do
        {
          if (*(apr_pool_t **)v301 != pc)
          {
            unint64_t v71 = v70;
            objc_enumerationMutation(v214);
            char v70 = v71;
          }

          __int128 v240 = v70;
          unint64_t v72 = (void *)objc_claimAutoreleasedReturnValue([v227 objectForKeyedSubscript:*(void *)(*((void *)&v300 + 1) + 8 * v70)]);
          uint64_t v271 = 0u;
          uint64_t v272 = 0u;
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          size_t v73 = (char *)[v72 countByEnumeratingWithState:parent objects:&v296 count:16];
          if (v73)
          {
            int v74 = *(void *)v270;
            do
            {
              for (uint64_t j = 0LL; j != v73; ++j)
              {
                if (*(void *)v270 != v74) {
                  objc_enumerationMutation(v72);
                }
                uint64_t v76 = (void *)*((void *)parent[1] + (void)j);
                id v284 = @"context";
                uint64_t v77 = (apr_pool_t *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  0LL));
                uint64_t v288 = v77;
                uint64_t v289 = &off_5A09E8;
                char v285 = @"type";
                int v286 = @"object";
                uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue( [v76 objectForKeyedSubscript:@"DependencyGraphRequestedThumbnailTextureID"]);
                int v287 = @"functionIndex";
                int v290 = v78;
                int v291 = &off_5A0A60;
                uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v288,  &v284,  4LL));
                [v241 addObject:v79];
              }

              size_t v73 = (char *)[v72 countByEnumeratingWithState:parent objects:&v296 count:16];
            }

            while (v73);
          }

          char v70 = v240 + 1;
        }

        while ((id)(v240 + 1) != v232);
        unint64_t v232 = [v214 countByEnumeratingWithState:&v300 objects:v294 count:16];
      }

      while (v232);
    }

    uint64_t v80 = (id)objc_claimAutoreleasedReturnValue([v204 objectForKeyedSubscript:@"object"]);
    uint64_t v238 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v80 count]);
    uint64_t v302 = 0u;
    unint64_t v303 = 0u;
    uint64_t v300 = 0u;
    v301 = 0u;
    unint64_t v225 = (apr_pool_t *)v80;
    pd = (apr_pool_t *)-[apr_pool_t countByEnumeratingWithState:objects:count:]( v225,  "countByEnumeratingWithState:objects:count:",  &v300,  v294,  16LL);
    if (pd)
    {
      BOOL v215 = *(id *)v301;
      do
      {
        uint64_t v81 = 0LL;
        do
        {
          if (*(id *)v301 != v215)
          {
            uint64_t v82 = v81;
            objc_enumerationMutation(v225);
            uint64_t v81 = v82;
          }

          unsigned int v233 = v81;
          int v83 = *(apr_pool_t **)(*((void *)&v300 + 1) + 8 * v81);
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          uint64_t v271 = 0u;
          uint64_t v272 = 0u;
          uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t objectForKeyedSubscript:](v225, "objectForKeyedSubscript:", v83));
          uint64_t v85 = (char *)[v84 countByEnumeratingWithState:parent objects:&v296 count:16];
          if (v85)
          {
            unint64_t v86 = *(void *)v270;
            do
            {
              for (uint64_t k = 0LL; k != v85; ++k)
              {
                if (*(void *)v270 != v86) {
                  objc_enumerationMutation(v84);
                }
                uint64_t v88 = (void *)*((void *)parent[1] + (void)k);
                uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue( [v88 objectForKeyedSubscript:@"DependencyGraphRequestedThumbnailTextureID"]);
                uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue( [v88 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"]);
                id v91 = v90;
                uint64_t v288 = v83;
                if (v90) {
                  uint64_t v92 = objc_claimAutoreleasedReturnValue( objc_msgSend( &off_59FA40,  "objectAtIndexedSubscript:",  objc_msgSend(v90, "unsignedIntegerValue")));
                }
                else {
                  uint64_t v92 = objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"DependencyGraphRequestedTextureID"]);
                }
                int v93 = (void *)v92;
                uint64_t v289 = (_UNKNOWN **)v92;
                id v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v288,  2LL));
                -[NSMutableDictionary setObject:forKeyedSubscript:](v238, "setObject:forKeyedSubscript:", v94, v89);
              }

              uint64_t v85 = (char *)[v84 countByEnumeratingWithState:parent objects:&v296 count:16];
            }

            while (v85);
          }

          uint64_t v81 = v233 + 1;
        }

        while ((apr_pool_t *)(v233 + 1) != pd);
        pd = (apr_pool_t *)-[apr_pool_t countByEnumeratingWithState:objects:count:]( v225,  "countByEnumeratingWithState:objects:count:",  &v300,  v294,  16LL);
      }

      while (pd);
    }
  }

  else
  {
    if ((v15 & 2) != 0) {
      size_t v16 = @"All";
    }
    else {
      size_t v16 = @"First";
    }
    uint64_t v206 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue([&off_59FA40 arrayByAddingObject:v16]);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v201,  "setObject:forKeyedSubscript:",  v206,  @"attachments");
    Thumbnails = GTMTLReplayClient_generateThumbnails(*a1, v201, v202);
    uint64_t v204 = (void *)objc_claimAutoreleasedReturnValue(Thumbnails);
    p = (apr_pool_t *)objc_claimAutoreleasedReturnValue([v204 objectForKeyedSubscript:@"object"]);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t allKeys](p, "allKeys"));
    id v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "sortedArrayUsingSelector:"));

    __int128 v241 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  -[apr_pool_t count](p, "count")));
    uint64_t v302 = 0u;
    unint64_t v303 = 0u;
    uint64_t v300 = 0u;
    v301 = 0u;
    obuint64_t j = v19;
    id v224 = [obj countByEnumeratingWithState:&v300 objects:v294 count:16];
    if (v224)
    {
      unsigned int v211 = *(id *)v301;
      do
      {
        for (uint64_t m = 0LL; m != v224; uint64_t m = (char *)m + 1)
        {
          if (*(id *)v301 != v211) {
            objc_enumerationMutation(obj);
          }
          __int128 v229 = (void *)objc_claimAutoreleasedReturnValue( -[apr_pool_t objectForKeyedSubscript:]( p,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v300 + 1) + 8LL * (void)m)));
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v229 objectForKeyedSubscript:@"target"]);
          uint64_t v271 = 0u;
          uint64_t v272 = 0u;
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          uint64_t v21 = (char *)[v20 countByEnumeratingWithState:parent objects:&v296 count:16];
          if (v21)
          {
            uint64_t v22 = *(void *)v270;
            do
            {
              for (uint64_t n = 0LL; n != v21; ++n)
              {
                if (*(void *)v270 != v22) {
                  objc_enumerationMutation(v20);
                }
                uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:*((void *)parent[1] + (void)n)]);
                id v284 = @"context";
                size_t v25 = (apr_pool_t *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  0LL));
                uint64_t v288 = v25;
                uint64_t v289 = &off_5A09E8;
                char v285 = @"type";
                int v286 = @"object";
                uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:@"object"]);
                int v287 = @"functionIndex";
                int v290 = v26;
                int v291 = &off_5A0A60;
                uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v288,  &v284,  4LL));
                [v241 addObject:v27];
              }

              uint64_t v21 = (char *)[v20 countByEnumeratingWithState:parent objects:&v296 count:16];
            }

            while (v21);
          }
        }

        id v224 = [obj countByEnumeratingWithState:&v300 objects:v294 count:16];
      }

      while (v224);
    }

    os_signpost_id_t v28 = p;
    uint64_t v238 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  -[apr_pool_t count](v28, "count"));
    uint64_t v302 = 0u;
    unint64_t v303 = 0u;
    uint64_t v300 = 0u;
    v301 = 0u;
    unint64_t v225 = v28;
    id v212 = (char *)-[apr_pool_t countByEnumeratingWithState:objects:count:]( v225,  "countByEnumeratingWithState:objects:count:",  &v300,  v294,  16LL);
    if (v212)
    {
      id obja = *(id *)v301;
      do
      {
        uint64_t v29 = 0LL;
        do
        {
          if (*(id *)v301 != obja)
          {
            uint64_t v30 = v29;
            objc_enumerationMutation(v225);
            uint64_t v29 = v30;
          }

          pa = v29;
          uint64_t v31 = *(apr_pool_t **)(*((void *)&v300 + 1) + 8LL * (void)v29);
          __int128 v230 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t objectForKeyedSubscript:](v225, "objectForKeyedSubscript:", v31));
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v230 objectForKeyedSubscript:@"target"]);
          uint64_t v271 = 0u;
          uint64_t v272 = 0u;
          *(_OWORD *)parent = 0u;
          v270 = 0u;
          uint64_t v33 = (char *)[v32 countByEnumeratingWithState:parent objects:&v296 count:16];
          if (v33)
          {
            uint64_t v34 = *(void *)v270;
            do
            {
              for (isize_t i = 0LL; ii != v33; ++ii)
              {
                if (*(void *)v270 != v34) {
                  objc_enumerationMutation(v32);
                }
                int v36 = (_UNKNOWN **)*((void *)parent[1] + (void)ii);
                id v37 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:v36]);
                uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKeyedSubscript:@"object"]);
                uint64_t v288 = v31;
                uint64_t v289 = v36;
                uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v288,  2LL));
                -[NSMutableDictionary setObject:forKeyedSubscript:](v238, "setObject:forKeyedSubscript:", v39, v38);
              }

              uint64_t v33 = (char *)[v32 countByEnumeratingWithState:parent objects:&v296 count:16];
            }

            while (v33);
          }

          uint64_t v29 = (apr_pool_t *)((char *)pa + 1);
        }

        while ((char *)pa + 1 != v212);
        id v212 = (char *)-[apr_pool_t countByEnumeratingWithState:objects:count:]( v225,  "countByEnumeratingWithState:objects:count:",  &v300,  v294,  16LL);
      }

      while (v212);
    }
  }

  BOOL v95 = v241;
  uint64_t v96 = v202;
  v234 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v299 = 0u;
  uint64_t v298 = 0u;
  unint64_t v297 = 0u;
  uint64_t v296 = 0u;
  __int128 v228 = v95;
  uint64_t v97 = [v228 countByEnumeratingWithState:&v296 objects:v294 count:16];
  if (v97)
  {
    uint64_t v98 = *(void *)v297;
    do
    {
      for (juint64_t j = 0LL; jj != v97; juint64_t j = (char *)jj + 1)
      {
        if (*(void *)v297 != v98) {
          objc_enumerationMutation(v228);
        }
        uint64_t v100 = *(void **)(*((void *)&v296 + 1) + 8LL * (void)jj);
        uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v100 objectForKeyedSubscript:@"functionIndex"]);
        if ([v101 unsignedIntValue] == -1)
        {
          uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([v100 objectForKeyedSubscript:@"object"]);
          uint64_t v103 = [v102 unsignedLongLongValue];

          uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v96, "objectAtIndexedSubscript:", v103));
          uint64_t v105 = objc_claimAutoreleasedReturnValue([v104 objectForKeyedSubscript:@"functionIndex"]);

          uint64_t v101 = (void *)v105;
        }

        uint64_t v106 = (NSMutableArray *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v234,  "objectForKeyedSubscript:",  v101));
        if (!v106)
        {
          uint64_t v106 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v234, "setObject:forKeyedSubscript:", v106, v101);
        }

        -[NSMutableArray addObject:](v106, "addObject:", v100);
      }

      uint64_t v97 = [v228 countByEnumeratingWithState:&v296 objects:v294 count:16];
    }

    while (v97);
  }

  uint64_t v288 = (apr_pool_t *)v294;
  uint64_t v289 = (_UNKNOWN **)(&stru_3D8 + 40);
  int v290 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 4096LL));
  __int128 v184 = a1[3];
  uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allKeys](v234, "allKeys"));
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v107 sortedArrayUsingSelector:"compare:"]);

  if ((v194[46] & 0x10) != 0 && [v108 count])
  {
    unint64_t v109 = objc_claimAutoreleasedReturnValue(objc_msgSend(v108, "subarrayWithRange:", (char *)objc_msgSend( v108,  "count") - 1, 1));

    uint64_t v108 = (void *)v109;
  }

  uint64_t v266 = 0u;
  uint64_t v267 = 0u;
  uint64_t v264 = 0u;
  v265 = 0u;
  uint64_t v187 = v108;
  NSErrorUserInfoKey v189 = [v187 countByEnumeratingWithState:&v264 objects:v279 count:16];
  if (v189)
  {
    unsigned int v188 = *(void *)v265;
    while (2)
    {
      for (kuint64_t k = 0LL; kk != v189; kuint64_t k = (char *)kk + 1)
      {
        if (*(void *)v265 != v188) {
          objc_enumerationMutation(v187);
        }
        uint64_t v110 = *(void **)(*((void *)&v264 + 1) + 8LL * (void)kk);
        GTMTLReplayController_debugSubCommandStop( (uint64_t)a1,  [v110 unsignedIntegerValue],  0);
        unsigned int v111 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v234, "objectForKeyedSubscript:", v110));
        uint64_t v112 = [v111 count];
        signed int v195 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v112));
        uint64_t v196 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  v112));
        -[NSMutableArray removeAllObjects](v235, "removeAllObjects");
        __int128 v113 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v262 = 0u;
        uint64_t v263 = 0u;
        v260 = 0u;
        uint64_t v261 = 0u;
        uint64_t v243 = v111;
        __int128 v114 = [v243 countByEnumeratingWithState:&v260 objects:v278 count:16];
        if (v114)
        {
          unint64_t v115 = *(void *)v261;
          do
          {
            for (muint64_t m = 0LL; mm != v114; muint64_t m = (char *)mm + 1)
            {
              if (*(void *)v261 != v115) {
                objc_enumerationMutation(v243);
              }
              int v117 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v260 + 1) + 8 * (void)mm) objectForKeyedSubscript:@"object"]);
              int v118 = [v117 unsignedIntegerValue];

              uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v96, "objectAtIndexedSubscript:", v118));
              -[NSMutableArray addObject:](v235, "addObject:", v119);
              int v120 = (void *)objc_claimAutoreleasedReturnValue([v119 objectForKeyedSubscript:@"object"]);
              uint64_t v121 = [v120 unsignedLongLongValue];

              uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue([v119 objectForKeyedSubscript:@"functionIndex"]);
              uint64_t v123 = [v122 unsignedIntValue];

              AliasStreauint64_t m = (uint64_t *)GetAliasStream((*a1)[3], (uint64_t)v121, (*a1)[10] + v123 - 1);
              if (AliasStream) {
                int v125 = *AliasStream;
              }
              else {
                int v125 = 0LL;
              }
              uint64_t v126 = a1[5];
              int v127 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v125));
              int v128 = (void *)objc_claimAutoreleasedReturnValue([v126 objectForKeyedSubscript:v127]);

              if (!v128) {
                int v128 = (void *)objc_claimAutoreleasedReturnValue([a1[1] textureForKey:v125]);
              }
              -[NSMutableArray addObject:](v113, "addObject:", v128);
            }

            __int128 v114 = [v243 countByEnumeratingWithState:&v260 objects:v278 count:16];
          }

          while (v114);
        }

        GTMTLReplayClient_waitForUntrackedWritesToComplete((uint64_t)a1, v113);
        id v259 = 0LL;
        __int16 v129 = GTMTLReplayClient_retrieveTexturesForResize((id *)a1, v235, v113, 1, &v259);
        signed int v191 = (void *)objc_claimAutoreleasedReturnValue(v129);
        char v130 = v259;
        if (v130)
        {
          uint64_t v131 = v130;
          int v276 = NSUnderlyingErrorKey;
          v277 = v130;
          uint64_t v216 = (NSMutableArray *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v277,  &v276,  1LL));
          GTMTLReplay_fillError(a6, 101, v216);
          if (a6) {
            uint64_t v132 = *a6;
          }
          else {
            uint64_t v132 = 0LL;
          }
          GTMTLReplay_handleNSError(v132);
          uint64_t v178 = 1;
        }

        else
        {
          uint64_t v216 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v191 count]);
          __int128 v133 = (void *)objc_claimAutoreleasedReturnValue([a1[1] defaultCommandQueue]);
          objb = (id)objc_claimAutoreleasedReturnValue([v133 commandBuffer]);

          unsigned int v134 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"TextureResize"));
          [objb setLabel:v134];

          v257 = 0u;
          id v258 = 0u;
          uint64_t v255 = 0u;
          uint64_t v256 = 0u;
          unint64_t v135 = v191;
          uint64_t v136 = [v135 countByEnumeratingWithState:&v255 objects:v275 count:16];
          if (v136)
          {
            int v200 = *(void *)v256;
            uint64_t v193 = v135;
            while (2)
            {
              dispatch_semaphore_t v199 = v136;
              for (nuint64_t n = 0LL; nn != v199; nuint64_t n = (char *)nn + 1)
              {
                if (*(void *)v256 != v200) {
                  objc_enumerationMutation(v193);
                }
                uint64_t v138 = *(void **)(*((void *)&v255 + 1) + 8LL * (void)nn);
                uint64_t v139 = [v138 width];
                uint64_t v140 = [v138 height];
                int v141 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v201,  "objectForKeyedSubscript:",  @"resolution"));
                *(void *)&uint64_t v296 = v139;
                *((void *)&v296 + 1) = v140;
                *(void *)&unint64_t v297 = 1LL;
                GTMTLReplayClient_resizeResolution((unint64_t *)&v284, v141, (unint64_t *)&v296);

                uint64_t v142 = (void *)objc_claimAutoreleasedReturnValue([v138 device]);
                MTLPixelFormatGetInfoForDevice(v142, [v138 pixelFormat]);

                uint64_t v143 = (int)parent[1];
                uint64_t v144 = a1[2];
                v254 = 0LL;
                int v145 = GTMTLReplayController_resizeTexture( v144,  a2,  objb,  v138,  (unint64_t)v284,  (unint64_t)v285,  &v254);
                uint64_t v146 = (id)objc_claimAutoreleasedReturnValue(v145);
                uint64_t v131 = v254;
                if ((v143 & 0x20000) != 0)
                {
                  __int128 v198 = v198 & 0xFFFFFFFF00000000LL | 0x1040302;
                  uint64_t v147 = objc_msgSend( v146,  "newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:",  objc_msgSend(v146, "pixelFormat"),  2,  0,  objc_msgSend(v138, "mipmapLevelCount"),  0,  1,  v198);

                  uint64_t v203 = v131;
                  if ((v194[46] & 0x20) != 0) {
                    int v148 = 70LL;
                  }
                  else {
                    int v148 = 125LL;
                  }
                  uint64_t v149 = a1[2];
                  uint64_t v205 = objb;
                  uint64_t v150 = v147;
                  id v151 = v149;
                  uint64_t v152 = v150;
                  uint64_t v207 = (void *)objc_claimAutoreleasedReturnValue([v150 device]);
                  [v150 pixelFormat];
                  GTMTLPixelFormatGetInfoForDevice((uint64_t)&v296, (uint64_t)v207, v148);
                  pe = (apr_pool_t *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  v148,  [v150 width],  objc_msgSend(v150, "height"),  0));
                  -[apr_pool_t setUsage:](pe, "setUsage:", 5LL);
                  -[apr_pool_t setResourceOptions:](pe, "setResourceOptions:", 32LL);
                  char v293 = 0LL;
                  uint64_t v146 = [v151 newTextureWithDescriptor:pe error:&v293];

                  std::__split_buffer<std::string> v153 = v293;
                  char v197 = v153;
                  if (v146)
                  {
                    unsigned int v154 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
                    uint64_t v155 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v154, "colorAttachments"));
                    uint64_t v156 = (void *)objc_claimAutoreleasedReturnValue([v155 objectAtIndexedSubscript:0]);
                    [v156 setTexture:v146];

                    size_t v157 = (void *)objc_claimAutoreleasedReturnValue([v205 renderCommandEncoderWithDescriptor:v154]);
                    uint64_t v300 = v296;
                    v301 = v297;
                    uint64_t v302 = v298;
                    *(void *)&unint64_t v303 = v299;
                    id ResizeRenderPipelineState = GTMTLReplayController_getResizeRenderPipelineState( a2,  (uint64_t)&v300,  v148);
                    uint64_t v159 = (void *)objc_claimAutoreleasedReturnValue(ResizeRenderPipelineState);
                    [v157 setRenderPipelineState:v159];

                    [v157 setVertexBuffer:*(void *)(a2 + 144) offset:0 atIndex:0];
                    [v157 setVertexBuffer:*(void *)(a2 + 144) offset:96 atIndex:1];
                    [v157 setFragmentSamplerState:*(void *)(a2 + 128) atIndex:0];
                    [v157 setFragmentTexture:v152 atIndex:0];
                    [v157 drawPrimitives:3 vertexStart:0 vertexCount:6];
                    [v157 endEncoding];
                    uint64_t v160 = v146;

                    unint64_t v161 = v203;
                  }

                  else
                  {
                    if (v153)
                    {
                      v292 = NSUnderlyingErrorKey;
                      *(void *)&uint64_t v300 = v153;
                      uint64_t v162 = (MTLRenderPassDescriptor *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v300,  &v292,  1LL));
                    }

                    else
                    {
                      uint64_t v162 = 0LL;
                    }

                    unsigned int v154 = v162;
                    id NSError = MakeNSError(101, v162);
                    unint64_t v161 = (id)objc_claimAutoreleasedReturnValue(NSError);
                    GTMTLReplay_handleNSError(v161);
                  }

                  uint64_t v131 = v161;
                }

                if (v131)
                {
                  uint64_t v273 = NSUnderlyingErrorKey;
                  uint64_t v274 = v131;
                  __int128 v180 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v274,  &v273,  1LL));
                  GTMTLReplay_fillError(a6, 101, v180);
                  if (a6) {
                    __int128 v181 = *a6;
                  }
                  else {
                    __int128 v181 = 0LL;
                  }
                  GTMTLReplay_handleNSError(v181);

                  uint64_t v178 = 1;
                  __int128 v179 = v193;
                  goto LABEL_163;
                }

                -[NSMutableArray addObject:](v216, "addObject:", v146);
              }

              unint64_t v135 = v193;
              uint64_t v136 = [v193 countByEnumeratingWithState:&v255 objects:v275 count:16];
              if (v136) {
                continue;
              }
              break;
            }
          }

          GTMTLReplay_commitCommandBuffer(objb);
          uint64_t v164 = (char *)-[NSMutableArray count](v235, "count");
          if (v164)
          {
            for (i1 = 0LL; i1 != v164; ++i1)
            {
              __int128 v166 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v216, "objectAtIndexedSubscript:", i1));
              __int128 v167 = (void *)objc_claimAutoreleasedReturnValue([v243 objectAtIndexedSubscript:i1]);
              uint64_t v168 = (void *)objc_claimAutoreleasedReturnValue([v167 objectForKeyedSubscript:@"object"]);
              uint64_t v169 = [v168 unsignedIntegerValue];

              [v290 setLength:0];
              [v290 appendBytes:"MTSP" length:8];
              unint64_t v251 = 0u;
              id v252 = 0u;
              v253 = 0u;
              DWORD2(v251) = 7;
              LODWORD(v252) = 2;
              DYTraceEncode_InternalData((uint64_t)&v251, (unsigned int *)v288);
              uint64_t v170 = *(unsigned int *)v288;
              if ((*((_BYTE *)v288 + 33) & 0x10) != 0)
              {
                uint64_t v171 = v288;
                __int128 v172 = *(unsigned int *)v288;
                do
                {
                  uint64_t v171 = (apr_pool_t *)((char *)v171 + v170);
                  uint64_t v170 = *(unsigned int *)v171;
                  v172 += v170;
                }

                while ((*((_BYTE *)v171 + 33) & 0x20) == 0);
              }

              objc_msgSend(v290, "appendBytes:length:");
              *(void *)&uint64_t v296 = &v288;
              int v173 = v196;
              *((void *)&v296 + 1) = v173;
              *(void *)&unint64_t v297 = 0LL;
              uint64_t v174 = a1[3];
              int v250 = 0LL;
              GTMTLReplayClient_harvestTexture( a2,  v174,  v166,  (uint64_t)v169,  (unsigned int ***)&v296,  0xFFFFFFFFFFFFFFFFLL,  0LL,  0LL,  &v250);
              unsigned __int16 v175 = v250;
              unsigned __int8 v176 = [v290 copy];
              [v195 addObject:v176];
            }
          }

          unsigned __int8 v177 = (void *)objc_claimAutoreleasedReturnValue([v184 commandBuffer]);
          v244[0] = _NSConcreteStackBlock;
          v244[1] = 3221225472LL;
          v244[2] = __GenerateThumbnails_block_invoke;
          v244[3] = &unk_58F228;
          v245 = v195;
          unint64_t v246 = v238;
          v247 = v196;
          uint64_t v249 = a3;
          uint64_t v248 = v186;
          [v177 addCompletedHandler:v244];

          [v184 commitCommandBuffer];
          uint64_t v131 = 0LL;
          uint64_t v178 = 0;
          __int128 v179 = v245;
LABEL_163:
        }

        if (v178)
        {

          uint64_t v182 = 0LL;
          goto LABEL_169;
        }
      }

      NSErrorUserInfoKey v189 = [v187 countByEnumeratingWithState:&v264 objects:v279 count:16];
      if (v189) {
        continue;
      }
      break;
    }
  }

  apr_pool_destroy(newpool);
  uint64_t v182 = 1LL;
LABEL_169:

  return v182;
}

LABEL_157:
              uint64_t v102 = 0LL;
              goto LABEL_158;
            }

            if (v101 != 86)
            {
              if (v101 == 80)
              {
                uint64_t v102 = *(unsigned __int16 *)(v150 + (v152 << 6) + 60);
                goto LABEL_158;
              }

              goto LABEL_157;
            }

LABEL_155:
            uint64_t v102 = 256LL;
            goto LABEL_158;
          case 'V':
            uint64_t v103 = v169 + 255;
            goto LABEL_155;
          case 'P':
            uint64_t v102 = *(unsigned __int16 *)(v150 + (v152 << 6) + 60);
            uint64_t v103 = v169 + v102 - 1;
LABEL_158:
            uint64_t v107 = v150 + (v152 << 6);
            size_t v157 = (uint64_t *)(v107 + 8);
            GTMTLSMContext_getTextureDescriptor( (uint64_t *)(*v97)[5],  *(void *)(v107 + 8),  *(void *)(v107 + 16),  (uint64_t)v174);
            uint64_t v160 = v175;
            GTMTLPixelFormatGetInfoForDevice((uint64_t)v172, (uint64_t)v161, v175);
            *(void *)&__int128 v184 = 0LL;
            if ((~v173 & 0x60) != 0)
            {
              if ((v173 & 0x2000) != 0) {
                *(void *)&__int128 v184 = 4LL;
              }
              uint64_t v108 = 1LL;
            }

            else
            {
              __int128 v184 = xmmword_318400;
              uint64_t v108 = 2LL;
            }

            uint64_t v156 = v108;
            unint64_t v109 = 0LL;
            uint64_t v169 = v103 & -v102;
            uint64_t v110 = v150 + (v152 << 6);
            std::__split_buffer<std::string> v153 = (void *)(v110 + 48);
            uint64_t v155 = (__int16 *)(v110 + 32);
            unsigned int v111 = v177;
            uint64_t v158 = v93;
            uint64_t v159 = v176;
            uint64_t v112 = (__int128 *)(v93 + 14);
            unsigned int v154 = v177;
            while (1)
            {
              if (v93 && *((_WORD *)v93 + 5) == 1 && *((void *)v93 + 2) >= v109)
              {
                __int128 v114 = *v112;
              }

              else
              {
                *(void *)&__int128 v113 = *v153;
                *((void *)&v113 + 1) = HIDWORD(*v153);
                __int128 v114 = v113;
              }

              if (v111 < 2) {
                break;
              }
              unint64_t v115 = v114;
              if (v111 != 7) {
                goto LABEL_171;
              }
LABEL_172:
              __int128 v166 = v114;
              uint64_t v116 = *((void *)&v184 + v109);
              GTMTLGetTextureLevelInfoForDeviceWithOptions( (uint64_t)buf,  (uint64_t)v161,  v160,  *(unsigned __int16 *)(v85 + 42),  *(unsigned __int16 *)(v85 + 44),  *(unsigned __int16 *)(v85 + 46),  v159,  0LL,  v116);
              if ((void)v166) {
                int v117 = v166;
              }
              else {
                int v117 = v182;
              }
              if (*((void *)&v166 + 1)) {
                int v118 = DWORD2(v166);
              }
              else {
                int v118 = v117 * v180;
              }
              uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue([v162 blitCommandEncoder]);
              int v120 = (void *)objc_claimAutoreleasedReturnValue([v167 heapBuffer]);
              uint64_t v121 = (char *)[v167 heapLocation];
              uint64_t v122 = v183;
              [v119 copyFromBuffer:v120 sourceOffset:&v121[v96] toBuffer:v164 destinationOffset:v169 size:v183];

              uint64_t v123 = apr_array_push(v163);
              int v124 = *(unsigned __int16 *)(v85 + 42);
              int v125 = *(_DWORD *)(v85 + 44);
              uint64_t v126 = *v157;
              int v127 = *(unsigned __int16 *)(v85 + 36);
              int v128 = *(_DWORD *)(v85 + 38);
              __int16 v129 = *v155;
              char v130 = *(_BYTE *)(v85 + 34);
              *uint64_t v123 = v169;
              v123[1] = 80;
              v123[2] = v117;
              v123[3] = v118;
              v123[4] = v124;
              v123[5] = v125;
              *((void *)v123 + 3) = v126;
              v123[8] = v127;
              v123[9] = v128;
              *((_WORD *)v123 + 20) = v129;
              *((_BYTE *)v123 + 42) = v130;
              v169 += v122;
              v96 += v122;
              *((_BYTE *)v123 + 43) = v116;
              ++v109;
              v112 += 3;
              v123[11] = 0;
              int v93 = v158;
              unsigned int v111 = v154;
              if (v156 == v109)
              {

                goto LABEL_181;
              }
            }

            unint64_t v115 = 0LL;
LABEL_171:
            __int128 v114 = v115;
            goto LABEL_172;
        }
      }

      uint64_t v100 = -1LL;
      goto LABEL_141;
    }

LABEL_184:
    apr_pool_destroy(p);
    uint64_t v131 = g_signpostLog;
    uint64_t v132 = (os_log_s *)v131;
    if (v135 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v131))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v132,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
    }

    [(id)g_activityLog leaveActivity];
  }

        id v213 = v175;
        unsigned __int16 v175 = &stru_591D98;
        goto LABEL_185;
      }

      if (v183 > -15608)
      {
        if (v183 <= -15314)
        {
          uint64_t v185 = v183 == -15607 || v183 == -15570;
          unsigned int v186 = -15491;
LABEL_110:
          if (v185 || v183 == v186) {
            goto LABEL_157;
          }
          goto LABEL_120;
        }

        id v217 = (v183 + 15313) > 0x17;
        uint64_t v218 = 1 << (v183 - 47);
        unint64_t v219 = 8388673;
      }

      else
      {
        if (v183 <= -15677)
        {
          uint64_t v185 = (v183 + 15925) <= 0x2D && ((1LL << (v183 + 53)) & 0x200800000001LL) != 0
              || v183 == -15794;
          unsigned int v186 = -15743;
          goto LABEL_110;
        }

        id v217 = (v183 + 15676) > 0x1C;
        uint64_t v218 = 1 << (v183 + 60);
        unint64_t v219 = 268468481;
      }

      uint64_t v220 = v218 & v219;
      if (!v217 && v220 != 0) {
        goto LABEL_157;
      }
LABEL_120:
      if (IsFuncEnumSampledCall(*((_DWORD *)v182 + 2), v717))
      {
        InclusiveRange = GroupBuilder_findInclusiveRange(v676->nelts, (void *)v676->elts, v179);
        if (obja == InclusiveRange)
        {
          InclusiveRange = obja;
        }

        else
        {
          objb = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          if (InclusiveRange)
          {
            signed int v191 = InclusiveRange;
            do
            {
              uint64_t v192 = var3->elts;
              uint64_t v193 = *v191;
              __int128 v194 = *(_DWORD *)&v192[64 * *v191 + 8];
              if (IsFuncEnumPushDebugGroup(v194))
              {
                if (v194 <= -16245)
                {
                  signed int v195 = v194 == -16374 || v194 == -16323;
                  uint64_t v196 = -16283;
                }

                else if (v194 > -15883)
                {
                  signed int v195 = v194 == -15786;
                  uint64_t v196 = -15882;
                }

                else
                {
                  signed int v195 = v194 == -16244;
                  uint64_t v196 = -16065;
                }

                if (v195 || v194 == v196)
                {
                  __int128 v198 = GTTraceFunc_argumentBytesWithMap(&v192[64 * v193], v192[64 * v193 + 13], v172);
                  dispatch_semaphore_t v199 = GTTraceFunc_argumentBytesWithMap(&v192[64 * v193], v198[8], v172);
                  if (v199)
                  {
                    int v200 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v199));
                    -[NSMutableArray addObject:](objb, "addObject:", v200);
                  }
                }
              }

              uint64_t v201 = *((unsigned int *)v191 + 4);
              if ((_DWORD)v201) {
                v191 -= 4 * v201;
              }
              else {
                signed int v191 = 0LL;
              }
            }

            while ((_DWORD)v201);
          }

          uint64_t v202 = objb;
          uint64_t v203 = (unint64_t)-[NSMutableArray count](v202, "count");
          if (v203 >= 2)
          {
            uint64_t v204 = 0LL;
            uint64_t v205 = v203 >> 1;
            uint64_t v206 = v203 - 1;
            do
              -[NSMutableArray exchangeObjectAtIndex:withObjectAtIndex:]( v202,  "exchangeObjectAtIndex:withObjectAtIndex:",  v204++,  v206--);
            while (v205 != v204);
          }

          uint64_t v207 = objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v202, "componentsJoinedByString:", @"->"));
          v675 = (__CFString *)v207;
        }

        id v213 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v180));
        p_isa = &v213->isa;
        v810 = (uint64_t)v174;
        v811 = (uint64_t)v175;
        v812 = v675;
        id v224 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &p_isa,  4LL));
        -[NSMutableArray addObject:](v682, "addObject:", v224);

        id obja = InclusiveRange;
        goto LABEL_185;
      }

      if ((IsFuncEnumEndEncoding(v183) & 1) != 0) {
        goto LABEL_184;
      }
      if (v183 > -15344)
      {
        unint64_t v225 = (v183 + 15343) > 0x1B || ((1 << (v183 - 17)) & 0xA000001) == 0;
        id v213 = v174;
        uint64_t v216 = &stru_591D98;
        if (!v225) {
          goto LABEL_186;
        }
      }

      else
      {
        id v223 = v183 == -16361 || v183 == -16202 || v183 == -15908;
        id v213 = v174;
        uint64_t v216 = &stru_591D98;
        if (v223) {
          goto LABEL_186;
        }
      }

void sub_131A34(_Unwind_Exception *a1)
{
}

id GTMTLReplayController_rewind(uint64_t a1)
{
  if (s_logUsingOsLog)
  {
    id v2 = gt_default_log();
    os_signpost_id_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_INFO, "Rewinding", buf, 2u);
    }
  }

  else
  {
    unint64_t v4 = __stdoutp;
    id v5 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Rewinding"));
    fprintf(v4, "%s\n", (const char *)[v5 UTF8String]);
  }

  Rewind((_DWORD *)a1);
  return objc_msgSend(*(id *)(a1 + 8), "setLayerClass:", objc_opt_class(DYMetalLayer, v6));
}

id CompareCommandBufferRestore(apr_array_header_t **a1, uint64_t a2, apr_pool_t **a3)
{
  uint64_t v9 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)a2,  *(unsigned __int8 *)(a2 + 13),  *(void *)&(*a1)->nalloc)
       + 1);
  -[apr_array_header_t commitCommandBuffer](a1[3], "commitCommandBuffer");
  RestoreCommandBuffer(a1, v9, *a3, (apr_hash_t *)a3);
  uint64_t v6 = *find_entry(*(void *)&(*a1)[4].nalloc, &v9, 8uLL, 0LL);
  if (v6) {
    uint64_t v7 = *(void *)(v6 + 32);
  }
  else {
    uint64_t v7 = 0LL;
  }
  DYMTLIndirectArgumentBufferManager_processCommandBuffer((uint64_t)a1, v7);
  return [(id)g_activityLog leaveActivity];
}

void sub_131C34(_Unwind_Exception *a1)
{
}

void RewindWithoutRestore(uint64_t a1)
{
  uint64_t v1 = (id *)a1;
  GTMTLReplayController_tileMemoryFree(a1);
  id v2 = v1[1];
  id v3 = *v1;
  uint64_t v4 = *((void *)*v1 + 24);
  id v5 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(int *)(v4 + 12));
  if (*(int *)(v4 + 12) >= 1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(*(void *)(v4 + 24) + 8 * v6) + 8LL)));
      -[NSMutableArray addObject:](v5, "addObject:", v7);

      ++v6;
    }

    while (v6 < *(int *)(v4 + 12));
  }

  [v2 removeResourcesForKeys:v5];

  if ((dword_5B9DE4 & 0x8000) != 0 || (*((_BYTE *)v3 + 272) & 4) != 0)
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v1[1] defaultCommandQueue]);
    [v8 finish];
  }

  uint64_t v9 = *((void *)v3 + 25);
  if (*(int *)(v9 + 12) >= 1)
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = *((void *)v3 + 10);
    do
    {
      uint64_t v12 = *(void *)(*(void *)(v9 + 24) + 8 * v10);
      if (v12) {
        uint64_t v12 = *(void *)(v12 + 8);
      }
      uint64_t v13 = *((void *)v3 + 1);
      *(void *)&__int128 v67 = v12;
      uint64_t v14 = *find_entry(v13, &v67, 8uLL, 0LL);
      if (v14) {
        uint64_t v15 = *(void *)(v14 + 32);
      }
      else {
        uint64_t v15 = 0LL;
      }
      CreateResourceFromStream(v1, v15, v11);
      ++v10;
    }

    while (v10 < *(int *)(v9 + 12));
  }

  if ((GT_SUPPORT_0 & 0x800) != 0 && *(_DWORD *)(*((void *)v3 + 28) + 12LL))
  {
    id context = objc_autoreleasePoolPush();
    size_t v16 = (void *)objc_claimAutoreleasedReturnValue([v2 defaultCommandQueue]);
    id v17 = InternalCommandBuffer(v16, @"MapSparseTextureRegions");
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);

    uint64_t v51 = v18;
    id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 resourceStateCommandEncoder]);
    uint64_t v55 = v1;
    uint64_t v20 = *(apr_pool_t **)v1[19];
    uint64_t v53 = v3;
    uint64_t v21 = *((void *)v3 + 28);
    id v22 = v19;
    id v54 = v2;
    id v58 = v2;
    uint64_t v23 = apr_array_make(v20, 8, 48);
    uint64_t v24 = apr_array_make(v20, 8, 48);
    size_t v25 = apr_array_make(v20, 8, 8);
    uint64_t v50 = v20;
    uint64_t v26 = apr_array_make(v20, 8, 8);
    __int128 v59 = v22;
    uint64_t v27 = objc_claimAutoreleasedReturnValue([v22 device]);
    os_signpost_id_t v28 = (void *)v27;
    int v29 = *(_DWORD *)(v21 + 12);
    if (v29 >= 1)
    {
      uint64_t v30 = 0LL;
      uint64_t v31 = 0LL;
      uint64_t v56 = v21;
      uint64_t v57 = (void *)v27;
      do
      {
        uint64_t v32 = *(void *)(v21 + 24) + (v30 << 6);
        uint64_t v34 = *(void *)(v32 + 8);
        uint64_t v33 = (uint64_t *)(v32 + 8);
        if (v34 != v31)
        {
          uint64_t v61 = v33;
          uint64_t v62 = v30;
          uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "textureForKey:"));
          int v36 = (char *)[v35 textureType];
          unint64_t v37 = (unint64_t)[v35 width];
          unint64_t v38 = (unint64_t)[v35 height];
          unint64_t v39 = (unint64_t)[v35 depth];
          id v63 = v35;
          id v64 = [v35 firstMipmapInTail];
          __int128 v60 = v36;
          uint64_t v40 = (uint64_t)[v35 arrayLength];
          unint64_t v41 = 0LL;
          else {
            uint64_t v42 = 6 * v40;
          }
          do
          {
            if (v42)
            {
              for (uint64_t i = 0LL; i != v42; ++i)
              {
                apr_array_push(v24);
                uint64_t v44 = apr_array_push(v23);
                void *v44 = 0LL;
                v44[1] = 0LL;
                void v44[2] = 0LL;
                _OWORD v44[3] = v37;
                v44[4] = v38;
                v44[5] = v39;
                *(void *)apr_array_push(v25) = v41;
                *(void *)apr_array_push(v26) = i;
              }
            }

            if (v37 <= 1) {
              unint64_t v37 = 1LL;
            }
            else {
              v37 >>= 1;
            }
            if (v38 <= 1) {
              unint64_t v38 = 1LL;
            }
            else {
              v38 >>= 1;
            }
            if (v39 <= 1) {
              unint64_t v39 = 1LL;
            }
            else {
              v39 >>= 1;
            }
            ++v41;
          }

          while (v41 <= (unint64_t)v64);
          id v45 = [v63 pixelFormat];
          id v46 = [v63 sampleCount];
          os_signpost_id_t v28 = v57;
          if (v57)
          {
            [v57 sparseTileSizeWithTextureType:v60 pixelFormat:v45 sampleCount:v46];
          }

          else
          {
            __int128 v67 = 0uLL;
            uint64_t v68 = 0LL;
          }

          uint64_t v21 = v56;
          uint64_t v30 = v62;
          elts = v23->elts;
          uint64_t v48 = v24->elts;
          uint64_t nelts = v23->nelts;
          __int128 v65 = v67;
          uint64_t v66 = v68;
          [v57 convertSparsePixelRegions:elts toTileRegions:v48 withTileSize:&v65 alignmentMode:0 numRegions:nelts];
          [v59 updateTextureMappings:v63 mode:1 regions:v24->elts mipLevels:v25->elts slices:v26->elts numRegions:v23->nelts];
          v23->uint64_t nelts = 0;
          v24->uint64_t nelts = 0;
          v25->uint64_t nelts = 0;
          v26->uint64_t nelts = 0;
          uint64_t v31 = *v61;

          int v29 = *(_DWORD *)(v56 + 12);
        }

        ++v30;
      }

      while (v30 < v29);
    }

    MapSparseTextureRegions(v59, v58, v53[28], v50);
    apr_pool_clear(v50);
    [v59 endEncoding];
    GTMTLReplay_commitCommandBuffer(v51);

    objc_autoreleasePoolPop(context);
    id v2 = v54;
    uint64_t v1 = v55;
  }

  v1[2810] = 0LL;
  bzero(v1 + 20, 0x5720uLL);
}

apr_array_header_t *RestoreCommandBuffer( apr_array_header_t **a1, uint64_t a2, apr_pool_t *pool, apr_hash_t *a4)
{
  uint64_t v48 = a2;
  uint64_t v8 = apr_hash_make(pool);
  uint64_t v9 = apr_palloc(pool, 8uLL);
  *uint64_t v9 = a2;
  apr_hash_set(a4, v9, 8LL, v8);
  uint64_t result = (apr_array_header_t *)find_entry(*(void *)&(*a1)[4].elt_size, &v48, 8uLL, 0LL);
  if (result->pool)
  {
    uint64_t v11 = *((void *)result->pool + 4);
    if (v11)
    {
      int v12 = *(_DWORD *)(v11 + 12);
      if (v12)
      {
        if (v12 >= 1)
        {
          int v13 = 0;
          do
          {
            uint64_t v14 = apr_array_push(a1[2813]);
            *(_DWORD *)uint64_t v14 = 1;
            uint64_t v15 = *(void *)(v11 + 24) + ((uint64_t)v13 << 6);
            v14[1] = v15;
            int v16 = *(_DWORD *)(v11 + 12);
            int v17 = CountRequestsWithinCapacity(v15, (v16 - v13));
            *((_DWORD *)v14 + 1) = v17;
            v13 += v17;
          }

          while (v13 < v16);
        }

        SignalLoadQueueThreads((uint64_t)a1, a1[2813]->nelts - 1);
        uint64_t v18 = *(void *)&(*a1)->elt_size;
        uint64_t v49 = v48;
        entry = find_entry(v18, &v49, 8uLL, 0LL);
        unint64_t v20 = CommandBufferCommitIndex(*(void *)(*(void *)(*entry + 32LL) + 32LL));
        RestoreVisibleFunctionTablesForFunctionIndex((id *)a1, v20);
        uint64_t v21 = *(void *)&(*a1)->elt_size;
        uint64_t v49 = v48;
        id v22 = find_entry(v21, &v49, 8uLL, 0LL);
        unint64_t v23 = CommandBufferCommitIndex(*(void *)(*(void *)(*v22 + 32LL) + 32LL));
        RestoreIntersectionFunctionTablesForFunctionIndex((id *)a1, v23);
        uint64_t v24 = objc_alloc(&OBJC_CLASS___GTMTLReplayActivityLog);
        size_t v25 = -[GTMTLReplayActivityLog initWithLog:](v24, "initWithLog:", g_activityLog);
        uint64_t v26 = (unsigned int *)(a1 + 2814);
        do
          signed int v27 = __ldaxr(v26);
        while (__stlxr(v27 + 1, v26));
        os_signpost_id_t v28 = a1[2813];
        if (v27 < v28->nelts)
        {
          elts = v28->elts;
          if (elts)
          {
            uint64_t v30 = (uint64_t)&elts[16 * v27];
            while (1)
            {
              uint64_t v31 = objc_autoreleasePoolPush();
              DoLoadJob((uint64_t **)a1, v30, v25, v8);
              do
                signed int v32 = __ldaxr(v26);
              while (__stlxr(v32 + 1, v26));
              uint64_t v33 = a1[2813];
              if (v32 >= v33->nelts) {
                break;
              }
              uint64_t v34 = v33->elts;
              uint64_t v30 = (uint64_t)&v34[16 * v32];
              objc_autoreleasePoolPop(v31);
              if (!v34) {
                goto LABEL_18;
              }
            }

            objc_autoreleasePoolPop(v31);
          }
        }

uint64_t CompareU64Pointer(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

uint64_t FillBufferWithBufferBlitOperation( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, apr_array_header_t *a8)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = *(void *)a2;
  if (*(uint64_t *)a2 > 56)
  {
    switch(v14)
    {
      case '9':
        goto LABEL_9;
      case 'V':
        uint64_t v16 = a7 + 255;
        goto LABEL_17;
      case 'P':
        uint64_t v15 = *(unsigned __int16 *)(a2 + 60);
        uint64_t v16 = a7 + v15 - 1;
        goto LABEL_20;
    }

    goto LABEL_8;
  }

  if (v14 == 16)
  {
    uint64_t v16 = a7 + 31;
    uint64_t v15 = 32LL;
    goto LABEL_20;
  }

  if (v14 != 22) {
LABEL_8:
  }
    uint64_t v13 = -1LL;
LABEL_9:
  uint64_t v16 = v13 + a7;
  if (v14 > 79)
  {
    if (v14 != 86)
    {
      if (v14 == 80)
      {
        uint64_t v15 = *(unsigned __int16 *)(a2 + 60);
        goto LABEL_20;
      }

_DWORD *Rewind(_DWORD *result)
{
  if (result[5620])
  {
    uint64_t v1 = (uint64_t)result;
    [(id)g_activityLog enterRewind];
    RewindWithoutRestore(v1);
    uint64_t v43 = 0LL;
    uint64_t v2 = *find_entry(*(void *)(v1 + 22552), &v43, 8uLL, 0LL);
    if (v2) {
      uint64_t v3 = *(void *)(v2 + 32);
    }
    else {
      uint64_t v3 = 0LL;
    }
    AppendRestoreJobsToLoadQueue(v1, v3);
    SignalLoadQueueThreads(v1, *(_DWORD *)(*(void *)(v1 + 22504) + 12LL));
    uint64_t v4 = objc_alloc(&OBJC_CLASS___GTMTLReplayActivityLog);
    id v5 = -[GTMTLReplayActivityLog initWithLog:](v4, "initWithLog:", g_activityLog);
    entry = find_entry(*(void *)(v1 + 22544), &v43, 8uLL, 0LL);
    if (*entry)
    {
      uint64_t v7 = *(void *)(*entry + 32LL);
      if (v7) {
        RestoreResourcesFromBuffer((id *)v1, *(void **)(v1 + 22536), *(void *)(v7 + 24), *(_DWORD *)(v7 + 12), v5);
      }
    }

    RestoreOrderedResourcesFromArchive( (id *)v1,  *(void *)(*(void *)(*(void *)v1 + 240LL) + 24LL),  *(unsigned int *)(*(void *)(*(void *)v1 + 240LL) + 12LL),  v5);
    RestoreVisibleFunctionTablesForFunctionIndex((id *)v1, *(void *)(*(void *)v1 + 80LL) - 1LL);
    RestoreIntersectionFunctionTablesForFunctionIndex((id *)v1, *(void *)(*(void *)v1 + 80LL) - 1LL);
    uint64_t v8 = (unsigned int *)(v1 + 22512);
    do
      signed int v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    uint64_t v10 = *(void *)(v1 + 22504);
    if (v9 >= *(_DWORD *)(v10 + 12)) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = *(void *)(v10 + 24) + 16LL * v9;
    }
    while (v11)
    {
      int v12 = objc_autoreleasePoolPush();
      DoLoadJob((uint64_t **)v1, v11, v5, 0LL);
      do
        signed int v13 = __ldaxr(v8);
      while (__stlxr(v13 + 1, v8));
      uint64_t v14 = *(void *)(v1 + 22504);
      if (v13 >= *(_DWORD *)(v14 + 12)) {
        uint64_t v11 = 0LL;
      }
      else {
        uint64_t v11 = *(void *)(v14 + 24) + 16LL * v13;
      }
      objc_autoreleasePoolPop(v12);
    }

    dispatch_group_wait(*(dispatch_group_t *)(v1 + 22528), 0xFFFFFFFFFFFFFFFFLL);
    *(_DWORD *)(*(void *)(v1 + 22504) + 12LL) = 0;
    uint64_t v15 = *(void **)v1;
    unint64_t v16 = *(void *)(*(void *)v1 + 80LL);
    uint64_t v17 = *(void *)(*(void *)v1 + 256LL);
    if (*(int *)(v17 + 12) >= 1)
    {
      uint64_t v18 = 0LL;
      do
      {
        uint64_t v19 = *(void *)(*(void *)(v17 + 24) + 8 * v18);
        id v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 8) residencySetForKey:*(void *)(v19 + 8)]);
        [v20 removeAllAllocations];
        uint64_t v21 = v15[1];
        uint64_t v44 = *(void *)(v19 + 8);
        uint64_t v22 = *find_entry(v21, &v44, 8uLL, 0LL);
        if (v22) {
          uint64_t v23 = *(void *)(v22 + 32);
        }
        else {
          uint64_t v23 = 0LL;
        }
        RestoreResourceFromStream(v1, v23, v16);

        ++v18;
        uint64_t v17 = v15[32];
      }

      while (v18 < *(int *)(v17 + 12));
    }

    uint64_t v24 = *(int *)(v15[33] + 12LL);
    if ((_DWORD)v24)
    {
      uint64_t v25 = **(apr_pool_t ***)(v1 + 152);
      int v26 = apr_palloc(v25, 8 * v24);
      signed int v27 = v26;
      if (v26) {
        bzero(v26, 8 * v24);
      }
      if ((int)v24 >= 1)
      {
        uint64_t v28 = 0LL;
        int v29 = 0;
        uint64_t v30 = 8LL * v24;
        do
        {
          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(v1 + 8) residencySetForKey:*(void *)(*(void *)(v15[33] + 24) + v28)]);
          if (v31) {
            v27[v29++] = v31;
          }

          v28 += 8LL;
        }

        while (v30 != v28);
        if (v29)
        {
          signed int v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 8) defaultCommandQueue]);
          [v32 removeResidencySets:v27 count:v29];
        }
      }

      apr_pool_clear(v25);
    }

    uint64_t v33 = *(void *)(v15[5] + 184LL);
    int v34 = *(_DWORD *)(v33 + 12);
    if (v34 >= 1)
    {
      for (uint64_t i = 0LL; i < v34; ++i)
      {
        uint64_t v36 = *(void *)(*(void *)(v33 + 24) + 8 * i);
        unint64_t v37 = *(void *)(v36 + 16);
        unint64_t v38 = v15[8];
        if (v38 > v37 || v15[9] + v38 <= v37)
        {
          uint64_t v40 = v15[1];
          uint64_t v44 = *(void *)(v36 + 8);
          uint64_t v41 = *find_entry(v40, &v44, 8uLL, 0LL);
          if (v41) {
            uint64_t v42 = *(void *)(v41 + 32);
          }
          else {
            uint64_t v42 = 0LL;
          }
          RestoreResourceFromStream(v1, v42, v16);
          int v34 = *(_DWORD *)(v33 + 12);
        }
      }
    }

    return [(id)g_activityLog leaveActivity];
  }

  return result;
}

void sub_132988(_Unwind_Exception *a1)
{
}

id RestoreResourcesFromBuffer(id *a1, void *a2, uint64_t a3, int a4, void *a5)
{
  id v9 = a2;
  id v10 = a5;
  os_signpost_id_t v11 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, a1);
  id v43 = a1[3];
  id v12 = a1[1];
  signed int v13 = g_signpostLog;
  uint64_t v14 = (os_log_s *)v13;
  unint64_t v37 = v11 - 1;
  if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v13))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a4;
    _os_signpost_emit_with_name_impl( &dword_0,  v14,  OS_SIGNPOST_INTERVAL_BEGIN,  v11,  "Replayer-2-restore",  "RestoreResourcesFromBuffer x%d",  (uint8_t *)&buf,  8u);
  }

  os_signpost_id_t spid = v11;
  unint64_t v38 = v10;

  if (a4 >= 1)
  {
    uint64_t v15 = 0LL;
    unint64_t v16 = (unsigned __int16 *)(a3 + 22);
    uint64_t v17 = a4;
    id v39 = v12;
    id v40 = v9;
    while (1)
    {
      uint64_t v18 = objc_autoreleasePoolPush();
      int v19 = *(_DWORD *)(v16 - 9);
      if (v19 == 80) {
        break;
      }
      if (v19 == 22)
      {
        id v20 = (void *)objc_claimAutoreleasedReturnValue([v12 bufferForKey:*(void *)(v16 - 7)]);
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v43 blitCommandEncoder]);
        [v21 copyFromBuffer:v9 sourceOffset:*(unsigned int *)(v16 - 11) toBuffer:v20 destinationOffset:*(unsigned int *)(v16 - 3) size:*(unsigned int *)(v16 - 1)];

        unsigned int v22 = *(_DWORD *)(v16 - 1);
LABEL_10:
        v15 += v22;
      }

      objc_autoreleasePoolPop(v18);
      v16 += 24;
      if (!--v17) {
        goto LABEL_14;
      }
    }

    id v20 = (void *)objc_claimAutoreleasedReturnValue([v12 textureForKey:*(void *)(v16 + 1)]);
    uint64_t v42 = *(unsigned int *)(v16 - 3);
    uint64_t v41 = *(v16 - 1);
    uint64_t v23 = *v16;
    uint64_t v24 = v15;
    uint64_t v25 = *(unsigned int *)(v16 + 5);
    uint64_t v26 = v16[7];
    uint64_t v27 = v16[8];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v43 blitCommandEncoder]);
    uint64_t v29 = v16[9];
    uint64_t v30 = *((unsigned __int8 *)v16 + 20);
    uint64_t v31 = *((unsigned __int8 *)v16 + 21);
    void v44[2] = v27;
    *(void *)&__int128 buf = v42;
    *((void *)&buf + 1) = v41;
    uint64_t v46 = v23;
    id v12 = v39;
    v44[0] = v25;
    v44[1] = v26;
    uint64_t v15 = v24;
    id v9 = v40;
    objc_msgSend( v28,  "copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinatio nLevel:destinationOrigin:options:",  v29,  v30,  v44,  v31);

    unsigned int v22 = *(_DWORD *)(v16 - 5) * *v16;
    goto LABEL_10;
  }

  uint64_t v15 = 0LL;
LABEL_14:
  id v32 = [v43 commitCommandBufferWithLog:v38];
  uint64_t v33 = g_signpostLog;
  int v34 = (os_log_s *)v33;
  if (v37 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v33))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v15;
    _os_signpost_emit_with_name_impl( &dword_0,  v34,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-2-restore",  "%{xcode:size-in-bytes}zu",  (uint8_t *)&buf,  0xCu);
  }

  return v32;
}

void RestoreResourceFromStream(uint64_t a1, uint64_t a2, unint64_t a3)
{
  id v6 = *(id *)(a1 + 8);
  uint64_t v7 = *(void *)(a2 + 32);
  id v18 = v6;
  unsigned int v8 = 0;
  if (v7)
  {
    while (1)
    {
      unsigned int v9 = atomic_load((unsigned int *)(v7 + 4));
      uint64_t v10 = v8 + (v9 >> 6) - 1;
      uint64_t v7 = *(void *)(v7 + 40);
      unsigned int v8 = v10;
      if (!v7)
      {
        unsigned int v8 = v10;
        goto LABEL_6;
      }
    }
  }

  uint64_t v10 = 0LL;
LABEL_6:
  unint64_t v11 = v8 | (unint64_t)(v10 << 32);
LABEL_7:
  uint64_t v12 = v7 + 64;
  while (v7)
  {
    uint64_t v13 = v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6);
    if (*(void *)v13 >= a3) {
      break;
    }
    if (!GetFuncEnumConstructorType(*(_DWORD *)(v13 + 8)))
    {
      uint64_t v14 = objc_autoreleasePoolPush();
      GTMTLReplayController_defaultDispatchFunction(a1, v13);
      objc_autoreleasePoolPop(v14);
    }

    unsigned int v15 = atomic_load((unsigned int *)(v7 + 4));
    int v16 = v11 + (v15 >> 6);
    uint64_t v17 = (HIDWORD(v11) + 1);
    unint64_t v11 = (v17 << 32) | v11;
    if ((_DWORD)v17 == v16 - 1)
    {
      unint64_t v11 = (v17 << 32) | v17;
      uint64_t v7 = *(void *)(v7 + 40);
      goto LABEL_7;
    }
  }
}

uint64_t GTMTLReplayController_restoreCommandBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)a2,  *(unsigned __int8 *)(a2 + 13),  *(void *)(*(void *)a1 + 16LL))
        + 1);
  unsigned int v4 = [*(id *)(a1 + 24) commitCommandBuffer];
  uint64_t v5 = *find_entry(*(void *)(*(void *)a1 + 184LL), &v42, 8uLL, 0LL);
  if (v5) {
    uint64_t v6 = *(void *)(v5 + 32);
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t v7 = *find_entry(*(void *)(a1 + 22552), &v42, 8uLL, 0LL);
  if (!v7)
  {
    if (v6)
    {
      char v9 = 0;
      uint64_t v8 = 0LL;
      goto LABEL_9;
    }

void sub_1331C0(_Unwind_Exception *a1)
{
}

uint64_t GTMTLReplayController_init(uint64_t a1)
{
  if (a1 && !initialized)
  {
    shared_initialized = 1;
    apr_pools_initialized = 1;
    apr_pools_shared_initialized = 1;
    global_pool = a1;
    global_allocator = *(void *)(a1 + 48);
  }

  qword_5B9DC0 = GetEnvDefault("MTLREPLAYER_ABORT_ON_ERROR_CODE", -1LL);
  qword_5B9DC8 = GetEnvDefault("MTLREPLAYER_ABORT_ON_FAILURE_TYPE", 1LL);
  qword_5B9DD0 = GetEnvDefault("MTLREPLAYER_FORCE_PATCHING_TYPE_REPLACE_MASK", 0LL);
  word_5B9DE0 = GetEnvDefault("MTLREPLAYER_SHARED_RESOURCE_POOL_MAX_SIZE", 128LL);
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
  byte_5B9DE3 = GetEnvDefault("MTLREPLAYER_RESTORE_THREAD_COUNT", (uint64_t)[v1 activeProcessorCount] - 1);

  byte_5B9DE2 = GetEnvDefault("MTLREPLAYER_SLEEP_AFTER_RESTORE", 0LL);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFFE | GetEnvDefault("MTLREPLAYER_VALIDATE_LOAD_ACTIONS", 0LL) & 1;
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFFD | (2 * (GetEnvDefault("MTLREPLAYER_FORCE_WAIT_UNTIL_COMPLETED", 0LL) & 1));
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFFB | (4
                                            * (GetEnvDefault("MTLREPLAYER_FORCE_BUFFER_STORAGE_MODE_PRIVATE", 0LL) & 1));
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFF7 | (8 * (GetEnvDefault("MTLREPLAYER_ENHANCED_COMMAND_BUFFER_ERRORS", 0LL) & 1));
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFEF | (16 * (GetEnvDefault("MTLREPLAYER_DISABLE_OPTIMIZE_RESTORES", 0LL) & 1));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFDF | (32
                                            * (GetEnvDefault( "METAL_FRAME_DEBUGGER_DISABLE_DISPLAY_ON_DEVICE",  [v2 isiOSAppOnMac]) & 1));

  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFFBF | ((GetEnvDefault("MTLREPLAYER_DISABLE_PATCHING_ARRAYS", 0LL) & 1) << 6);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFF7F | ((GetEnvDefault("MTLREPLAYER_PATCH_USING_ALL_RESOURCES", 0LL) & 1) << 7);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFEFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_BUFFER_PINNING", 1LL) & 1) << 8);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFEFFFF | ((GetEnvDefault("MTLREPLAYER_BUFFER_PINNING_REQUIRES_AB", 1LL) & 1) << 16);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFDFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_PROGRAM_ADDRESS_TABLES", 1LL) & 1) << 9);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFF7FF | ((GetEnvDefault("MTLREPLAYER_IGNORE_UNUSED_RESOURCE", 0LL) & 1) << 11);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFFBFF | ((GetEnvDefault("MTLREPLAYER_FORCE_LOAD_UNUSED_RESOURCE", 0LL) & 1) << 10);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFEFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_COMMAND_ENCODER_RESUME", 0LL) & 1) << 12);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFDFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_HEAP_TEXTURE_COMPRESSION", 0LL) & 1) << 13);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFFBFFF | ((GetEnvDefault( "MTLREPLAYER_DISABLE_SHADER_DEBUGGER_DRIVER_COMPILER_OPTIONS",  0LL) & 1) << 14);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFF7FFF | ((GetEnvDefault("MTLREPLAYER_FORCE_FINISH_ON_REWIND", 0LL) & 1) << 15);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFDFFFF | ((GetEnvDefault("MTLREPLAYER_DISABLE_MEMORY_BARRIER_RENDER_TARGETS", 0LL) & 1) << 17);
  GT_ENV = (uint64_t)getenv("MTLREPLAYER_INSERT_BINARY_ARCHIVES");
  dword_5B9DE4 = dword_5B9DE4 & 0xFFFBFFFF | ((GetEnvDefault("MTLREPLAYER_FORCE_DEFAULT_HAZARD_TRACKING", 0LL) & 1) << 18);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFF7FFFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_OTHER_PLATFORMS", 0LL) & 1) << 19);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFEFFFFF | ((GetEnvDefault("MTLREPLAYER_DRAWABLE_RESOURCE_INDEX_WORKAROUND", 0LL) & 1) << 20);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFBFFFFF | ((GetEnvDefault("MTLREPLAYER_GPURESOURCEID_SCAN_AND_PATCH", 1LL) & 1) << 22);
  qword_5B9DD8 = GetEnvDefault("MTLREPLAYER_ERROR_FILTERING", -1LL);
  dword_5B9DE4 = dword_5B9DE4 & 0xFFDFFFFF | ((GetEnvDefault("MTLREPLAYER_ALLOW_ALIAS_IOSURFACE_BACKED_BUFFERS", 1LL) & 1) << 21);
  dword_5B9DE4 = dword_5B9DE4 & 0xFF7FFFFF | ((GetEnvDefault("MTLREPLAYER_LOAD_VALIDATION", 0LL) & 1) << 23);
  dword_5B9DE4 = dword_5B9DE4 & 0xFEFFFFFF | ((GetEnvDefault("MTLREPLAYER_LOAD_CAPTURE", 0LL) & 1) << 24);
  dword_5B9DE4 = dword_5B9DE4 & 0xFDFFFFFF | ((GetEnvDefault("MTLREPLAYER_LOAD_HUD", 0LL) & 1) << 25);
  dword_5B9DE4 = dword_5B9DE4 & 0xFBFFFFFF | ((GetEnvDefault("MTLREPLAYER_STOP_ON_COMMIT_ERROR", 0LL) & 1) << 26);
  dword_5B9DE4 = dword_5B9DE4 & 0xF7FFFFFF | ((GetEnvDefault("MTLREPLAYER_REDIRECT_LOGGING_TO_STREAMS", 0LL) & 1) << 27);
  dword_5B9DE4 = dword_5B9DE4 & 0xEFFFFFFF | ((GetEnvDefault("MTLREPLAYER_LOCK_PARAM_BUFFER_SIZE_TO_MAX", 1LL) & 1) << 28);
  if (s_defaultLog == &_os_log_default)
  {
    os_log_t v5 = os_log_create("com.apple.gputools.MTLReplayController", "");
    uint64_t v6 = s_defaultLog;
    s_defaultLog = v5;

    uint64_t v7 = 0LL;
    s_logs = (uint64_t)calloc(3uLL, 0x20uLL);
    s_logCount = 1;
    uint64_t v8 = &off_58ED00;
    for (uint64_t i = 24LL; i != 120; i += 32LL)
    {
      uint64_t v10 = *v8;
      if (v7 == *(v8 - 1))
      {
        uint64_t v11 = s_logs;
        uint64_t v12 = s_logs + i;
        uint64_t v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.gputools.MTLReplayController"));
        uint64_t v14 = *(void **)(v12 - 24);
        *(void *)(v12 - 24) = v13;

        uint64_t v15 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10));
        uint64_t v16 = *(void **)(v12 - 16);
        *(void *)(v12 - 16) = v15;

        if (*((_BYTE *)v8 + 8))
        {
          uint64_t v17 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@.enableLog",  *(void *)(v12 - 24),  *(void *)(v12 - 16)));
          id v18 = *(void **)(v12 - 8);
          *(void *)(v12 - 8) = v17;
        }

        else
        {
          id v18 = *(void **)(v12 - 8);
          *(void *)(v12 - 8) = 0LL;
        }

        os_log_t v21 = os_log_create("com.apple.gputools.MTLReplayController", v10);
        unint64_t v22 = *(void **)(v11 + i);
        *(void *)(v11 + i) = v21;

        GTCoreLog_enabled(v12 - 24);
      }

      else
      {
        if (s_logUsingOsLog)
        {
          id v19 = gt_default_log();
          uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136315394;
            *(void *)&uint8_t buf[4] = v10;
            __int16 v48 = 1024;
            int v49 = (int)v7;
            _os_log_error_impl( &dword_0,  v20,  OS_LOG_TYPE_ERROR,  "warning: Invalid tag ID for %s, %d expected. Falling back to OS_LOG_DEFAULT",  buf,  0x12u);
          }
        }

        else
        {
          uint64_t v23 = __stderrp;
          uint64_t v20 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: Invalid tag ID for %s, %d expected. Falling back to OS_LOG_DEFAULT", *v8, v7));
          fprintf(v23, "%s\n", (const char *)-[os_log_s UTF8String](v20, "UTF8String"));
        }

        objc_storeStrong((id *)(s_logs + i), &_os_log_default);
      }

      ++v7;
      v8 += 3;
    }

    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
    unsigned __int8 v25 = [v24 BOOLForKey:@"GPUToolsPerfLogging"];

    if ((v25 & 1) != 0)
    {
      os_log_t v26 = os_log_create("com.apple.gputools.MTLReplayController", "");
      uint64_t v27 = g_signpostLog;
      g_signpostLog = v26;
    }
  }

  else if (s_logUsingOsLog)
  {
    id v3 = gt_default_log();
    unsigned int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = "Log already initialized, did you call GTCoreLogInit twice?";
      _os_log_error_impl(&dword_0, v4, OS_LOG_TYPE_ERROR, "warning: %s", buf, 0xCu);
    }
  }

  else
  {
    uint64_t v28 = __stderrp;
    id v29 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: %s", "Log already initialized, did you call GTCoreLogInit twice?"));
    fprintf(v28, "%s\n", (const char *)[v29 UTF8String]);
  }

  int v30 = dword_5B9DE4;
  s_logUsingOsLog = (dword_5B9DE4 & 0x8000000) == 0;
  if ((dword_5B9DE4 & 0x800000) == 0)
  {
    if ((dword_5B9DE4 & 0x1000000) == 0) {
      goto LABEL_26;
    }
LABEL_39:
    setenv("METAL_CAPTURE_ENABLED", "1", 1);
    if ((dword_5B9DE4 & 0x2000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  setenv("MTL_DEBUG_LAYER", "1", 1);
  int v30 = dword_5B9DE4;
  if ((dword_5B9DE4 & 0x1000000) != 0) {
    goto LABEL_39;
  }
LABEL_26:
  if ((v30 & 0x2000000) != 0) {
LABEL_27:
  }
    setenv("MTL_HUD_ENABLED", "1", 1);
LABEL_28:
  setenv("AGX_SUPPORT_D24_S8", "1", 1);
  id v31 = -[GTMTLReplayActivityLog init:](objc_alloc(&OBJC_CLASS___GTMTLReplayActivityLog), "init:", 0LL);
  id v32 = (void *)g_activityLog;
  g_activityLog = (uint64_t)v31;

  mach_timebase_info((mach_timebase_info_t)buf);
  LODWORD(v33) = *(_DWORD *)buf;
  LODWORD(v34) = *(_DWORD *)&buf[4];
  *(double *)&time_scale = (double)v33 / (double)v34 * 0.000000001;
  unint64_t v35 = dword_5B9DE4;
  uint64_t v36 = NSClassFromString(@"_MTLCommandBufferDescriptor");
  if (v36 || (uint64_t v36 = NSClassFromString(@"MTLCommandBufferDescriptor")) != 0LL)
  {
    id v37 = objc_alloc_init(v36);
    unint64_t v38 = (void *)g_commandBufferDescriptor;
    g_commandBufferDescriptor = (uint64_t)v37;

    [(id)g_commandBufferDescriptor setRetainedReferences:1];
    [(id)g_commandBufferDescriptor setErrorOptions:(v35 >> 3) & 1];
    id v39 = (id)g_commandBufferDescriptor;
    if ((objc_opt_respondsToSelector(v39, "captureProgramAddressTable") & 1) != 0) {
      [v39 setCaptureProgramAddressTable:(v35 >> 9) & 1];
    }
  }

  uint64_t v40 = 0LL;
  newHandler.__sigaction_u.__sa_handler = (void (__cdecl *)(int))HandleCrashSignal;
  *(void *)&newHandler.sa_masuint64_t k = 0LL;
  do
  {
    oldHandlers[v40] = 0LL;
    v40 += 2LL;
  }

  while (v40 != 64);
  for (uint64_t j = 0LL; j != 5; ++j)
    sigaction( GTMTLReplay_registerSignalHandlers_signals[j],  &newHandler,  (sigaction *)&oldHandlers[2 * GTMTLReplay_registerSignalHandlers_signals[j]]);
  uint64_t v42 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v43 = (void *)funcMap;
  funcMap = (uint64_t)v42;

  uint64_t v44 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v45 = (void *)failureMap;
  failureMap = (uint64_t)v44;

  getrlimit(8, (rlimit *)buf);
  *(void *)__int128 buf = 10000LL;
  setrlimit(8, (const rlimit *)buf);
  return MTLSetReportFailureBlock(&__block_literal_global_3699);
}

void sub_133DF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_133E80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_133F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_133FD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_134090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_134120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object {objcproto17MTLFunctionHandle}*>>>::unordered_map( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  *(void *)(a2 + 8));
  os_log_t v5 = *(uint64_t **)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = (void *)(a1 + 16);
    do
    {
      uint64_t v7 = v5 + 2;
      unint64_t v8 = v5[3] ^ (v5[2] << 32);
      unint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          unint64_t v2 = v5[3] ^ (v5[2] << 32);
          if (v8 >= v9) {
            unint64_t v2 = v8 % v9;
          }
        }

        else
        {
          unint64_t v2 = (v9 - 1) & v8;
        }

        uint64_t v11 = *(void **)(*(void *)a1 + 8 * v2);
        if (v11)
        {
          for (uint64_t i = (void *)*v11; i; uint64_t i = (void *)*i)
          {
            unint64_t v13 = i[1];
            if (v13 == v8)
            {
              if (i[2] == *v7 && i[3] == v5[3]) {
                goto LABEL_45;
              }
            }

            else
            {
              if (v10.u32[0] > 1uLL)
              {
                if (v13 >= v9) {
                  v13 %= v9;
                }
              }

              else
              {
                v13 &= v9 - 1;
              }

              if (v13 != v2) {
                break;
              }
            }
          }
        }
      }

      uint64_t v15 = operator new(0x28uLL);
      *uint64_t v15 = 0LL;
      v15[1] = v8;
      *((_OWORD *)v15 + 1) = *(_OWORD *)v7;
      v15[4] = (id)v5[4];
      float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
      float v17 = *(float *)(a1 + 32);
      if (!v9 || (float)(v17 * (float)v9) < v16)
      {
        BOOL v18 = (v9 & (v9 - 1)) != 0;
        if (v9 < 3) {
          BOOL v18 = 1LL;
        }
        unint64_t v19 = v18 | (2 * v9);
        unint64_t v20 = vcvtps_u32_f32(v16 / v17);
        if (v19 <= v20) {
          size_t v21 = v20;
        }
        else {
          size_t v21 = v19;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v21);
        unint64_t v9 = *(void *)(a1 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v2 = v8 % v9;
          }
          else {
            unint64_t v2 = v8;
          }
        }

        else
        {
          unint64_t v2 = (v9 - 1) & v8;
        }
      }

      uint64_t v22 = *(void *)a1;
      uint64_t v23 = *(void **)(*(void *)a1 + 8 * v2);
      if (v23)
      {
        *uint64_t v15 = *v23;
      }

      else
      {
        *uint64_t v15 = *v6;
        *uint64_t v6 = v15;
        *(void *)(v22 + 8 * v2) = v6;
        if (!*v15) {
          goto LABEL_44;
        }
        unint64_t v24 = *(void *)(*v15 + 8LL);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v24 >= v9) {
            v24 %= v9;
          }
        }

        else
        {
          v24 &= v9 - 1;
        }

        uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
      }

      void *v23 = v15;
LABEL_44:
      ++*(void *)(a1 + 24);
LABEL_45:
      os_log_t v5 = (uint64_t *)*v5;
    }

    while (v5);
  }

  return a1;
}

void sub_1343A0(_Unwind_Exception *a1)
{
}

uint64_t std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    os_log_t v5 = a2;
    uint64_t v6 = &a2[6 * a3];
    uint64_t v7 = (void *)(a1 + 16);
    do
    {
      unint64_t v8 = *v5;
      unint64_t v9 = *(void *)(a1 + 8);
      if (v9)
      {
        uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          unint64_t v3 = *v5;
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
        }

        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }

        uint64_t v11 = *(void **)(*(void *)a1 + 8 * v3);
        if (v11)
        {
          for (uint64_t i = (void *)*v11; i; uint64_t i = (void *)*i)
          {
            unint64_t v13 = i[1];
            if (v13 == v8)
            {
              if (i[2] == v8) {
                goto LABEL_41;
              }
            }

            else
            {
              if (v10.u32[0] > 1uLL)
              {
                if (v13 >= v9) {
                  v13 %= v9;
                }
              }

              else
              {
                v13 &= v9 - 1;
              }

              if (v13 != v3) {
                break;
              }
            }
          }
        }
      }

      uint64_t v14 = operator new(0x40uLL);
      v25[0] = v14;
      v25[1] = a1 + 16;
      char v26 = 0;
      *uint64_t v14 = 0LL;
      v14[1] = v8;
      v14[2] = v8;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)(v14 + 3),  (uint64_t)(v5 + 1));
      char v26 = 1;
      float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
      float v16 = *(float *)(a1 + 32);
      if (!v9 || (float)(v16 * (float)v9) < v15)
      {
        BOOL v17 = (v9 & (v9 - 1)) != 0;
        if (v9 < 3) {
          BOOL v17 = 1LL;
        }
        unint64_t v18 = v17 | (2 * v9);
        unint64_t v19 = vcvtps_u32_f32(v15 / v16);
        if (v18 <= v19) {
          size_t v20 = v19;
        }
        else {
          size_t v20 = v18;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v20);
        unint64_t v9 = *(void *)(a1 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
          else {
            unint64_t v3 = v8;
          }
        }

        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }
      }

      uint64_t v21 = *(void *)a1;
      uint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
      if (v22)
      {
        *uint64_t v14 = *v22;
      }

      else
      {
        *uint64_t v14 = *v7;
        *uint64_t v7 = v14;
        *(void *)(v21 + 8 * v3) = v7;
        if (!*v14) {
          goto LABEL_40;
        }
        unint64_t v23 = *(void *)(*v14 + 8LL);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v23 >= v9) {
            v23 %= v9;
          }
        }

        else
        {
          v23 &= v9 - 1;
        }

        uint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
      }

      void *v22 = v14;
LABEL_40:
      v25[0] = 0LL;
      ++*(void *)(a1 + 24);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100]((uint64_t)v25);
LABEL_41:
      v5 += 6;
    }

    while (v5 != v6);
  }

  return a1;
}

void sub_13461C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking(id *this)
{
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

BOOL InstrumentRenderSubCommand( uint64_t a1, unint64_t *a2, unint64_t a3, void *a4, uint64_t *a5, void *a6, uint64_t a7, apr_pool_t *a8)
{
  unint64_t v8 = a6[1];
  if (v8 <= a3 && a6[2] + v8 >= a3)
  {
    uint64_t v18 = *(void *)a1;
    id v19 = *(id *)(a1 + 8);
    GTMTLReplayController_debugSubCommandResume((unsigned int *)a1, *(_DWORD *)a2 - *(_DWORD *)(v18 + 80) + 1, a3 + 1);
    uint64_t v20 = a6[3];
    if (v20)
    {
      uint64_t v21 = v20 + a4[13] * a3;
      unint64_t v22 = *(void *)(v21 + a4[1]);
      if (v22 <= 8)
      {
        if (((1LL << v22) & 0x116) != 0) {
          goto LABEL_11;
        }
        if (!v22)
        {
          BOOL v11 = 1LL;
LABEL_30:

          return v11;
        }
      }

      if (v22 == 256 || v22 == 128)
      {
LABEL_11:
        unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v19 renderCommandEncoderForKey:*(void *)(a1 + 11320)]);
        unint64_t v24 = v23;
        if (v23)
        {
          [v23 useResource:*(void *)(a7 + 240) usage:3];
          if (*(_BYTE *)(*a4 + 11LL))
          {
            uint64_t v25 = *(void *)(a1 + 19912);
            if (v25) {
              goto LABEL_14;
            }
          }

          else
          {
            uint64_t v25 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a5[3], *(void *)(v21 + a4[2]));
            if (v25)
            {
LABEL_14:
              unint64_t v34 = v19;
              Object = GTMTLSMContext_getObject(**(void **)(v18 + 40), v25, *a2);
              if (!Object)
              {
                int v31 = 1;
LABEL_28:
                id v19 = v34;
                goto LABEL_29;
              }

              uint64_t v27 = Object;
              id v28 = ObtainTracingRenderPipelineState(*(uint64_t **)(v18 + 40), v34, Object, a7, *a2, a8);
              id v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
              if (!v29)
              {
                int v31 = 1;
LABEL_27:

                goto LABEL_28;
              }

              id v33 = v29;
              ReplaceFunctionTablesWithInstrumented((uint64_t)v36, a1, a7, *a2, v27, a5, a8);
              std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v37);
              std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v36);
              if (*(_BYTE *)(*a4 + 10LL))
              {
                [v24 setRenderPipelineState:v33];
                int v30 = (void *)objc_claimAutoreleasedReturnValue([v34 executeIndirectCommandBufferMap]);
                DYMTLDrawRenderCommandEncoder(v24, (uint64_t)a4, v21, (uint64_t)a5, v30);
              }

              else
              {
                memcpy(__dst, (const void *)(a1 + 11368), sizeof(__dst));
                if (!GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)__dst, a4, v21, a5))
                {
                  int v31 = 1;
                  goto LABEL_26;
                }

                GTMTLReplayController_restoreRenderCommandEncoder(v24, a1 + 11368, (uint64_t)__dst, v34);
                [v24 setRenderPipelineState:v33];
                int v30 = (void *)objc_claimAutoreleasedReturnValue([v34 executeIndirectCommandBufferMap]);
                DYMTLDrawRenderCommandEncoder(v24, (uint64_t)a4, v21, (uint64_t)a5, v30);
              }

              int v31 = 2;
LABEL_26:
              id v29 = v33;
              goto LABEL_27;
            }
          }
        }

        int v31 = 1;
LABEL_29:

        BOOL v11 = v31 == 2;
        goto LABEL_30;
      }
    }

    BOOL v11 = 0LL;
    goto LABEL_30;
  }

  return 0LL;
}

void sub_134A94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

id ObtainTracingRenderPipelineState( uint64_t *a1, void *a2, void *a3, uint64_t a4, unint64_t a5, apr_pool_t *a6)
{
  id v11 = a2;
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 defaultDevice]);
  if (a3[11]) {
    goto LABEL_2;
  }
  v118[0] = a3[1];
  id v13 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( (uint64_t *)(a4 + 40),  v118[0],  v118)[3];
  if (v13) {
    goto LABEL_33;
  }
  uint64_t v14 = *(void *)(a4 + 248);
  unint64_t v15 = (unint64_t)(v14 == 2) << 31;
  BOOL v16 = v14 == 1;
  uint64_t v17 = 0x40000000LL;
  if (!v16) {
    uint64_t v17 = v15;
  }
  uint64_t v94 = v17;
  int v18 = GTMTLSMRenderPipelineState_renderPipelineDescriptorType(a1, a3);
  int v112 = v18;
  switch(v18)
  {
    case 3:
      id v19 = (const void *)a3[9];
      if (!v19) {
        goto LABEL_16;
      }
      memcpy(v113, v19, 0x200uLL);
      break;
    case 2:
      GTMTLSMRenderPipelineState_tilePipelineDescriptor(a1, a3, v113, a6);
      break;
    case 1:
      GTMTLSMRenderPipelineState_renderPipelineDescriptor(a1, a3, (uint64_t)v113, a6);
      break;
    default:
      goto LABEL_30;
  }

  if (v112 == 1)
  {
    uint64_t Object = GTMTLSMContext_lastObject(*a1, v117, a5);
    if (!Object) {
      goto LABEL_2;
    }
    uint64_t v45 = Object;
    if (*(_BYTE *)(Object + 132)) {
      goto LABEL_2;
    }
    uint64_t v46 = MakeMTLRenderPipelineDescriptor;
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v11 renderPipelineDescriptorMap]);
    uint64_t v48 = ((uint64_t (*)(uint64_t **, void *))v46)(v113, v47);
    int v93 = (void *)objc_claimAutoreleasedReturnValue(v48);

    int v49 = *(_DWORD *)(a4 + 256);
    if (v49 == 2)
    {
      if (!v116) {
        goto LABEL_78;
      }
      uint64_t v78 = GTMTLSMContext_lastObject(*a1, v116, a5);
      id v30 = (id)v78;
      if (!v78)
      {
LABEL_80:

        goto LABEL_2;
      }

      uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v11 libraryForKey:*(void *)(v78 + 40)]);
      uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v11 functionMap]);
      id v110 = 0LL;
      id v80 = ObtainTracingFunction(v12, v92, a4, (uint64_t)v30, v79, (uint64_t)&v110);
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v80);
      id v30 = v110;

      if (!v52) {
        goto LABEL_79;
      }
      [v93 setFragmentFunction:v52];
      uint64_t v81 = ObtainTracingLinkedFunctions( (const GTMTLSMContext *)a1,  v11,  (GTMTLReplayAccessTracking *)a4,  (uint64_t)v114,  a5);
      id v54 = (void *)objc_claimAutoreleasedReturnValue(v81);
      [v93 setFragmentLinkedFunctions:v54];
    }

    else
    {
      if (v49 != 1)
      {
        id v30 = 0LL;
LABEL_82:
        id v109 = v30;
        id v82 = [v12 newRenderPipelineStateWithDescriptor:v93 options:v94 reflection:0 error:&v109];
        id v83 = v109;

        uint64_t v84 = v82;
        if (SupportsGlobalRelocation(v12, a4))
        {
          id v108 = v83;
          id v85 = [v12 newRenderPipelineStateWithDescriptor:v93 options:v94 reflection:0 error:&v108];
          id v42 = v108;
          id v13 = v85;
LABEL_94:

          __int128 v65 = v84;
          goto LABEL_65;
        }

        id v106 = v83;
        id v107 = 0LL;
        id v13 = [v12 newRenderPipelineStateWithDescriptor:v93 options:v94 | 1 reflection:&v107 error:&v106];
        id v86 = v107;
        id v42 = v106;

        unsigned int v87 = *(_DWORD *)(a4 + 256);
        if (v87 == 2)
        {
          uint64_t v88 = objc_claimAutoreleasedReturnValue([v86 fragmentBindings]);
        }

        else
        {
          if (v87 != 1)
          {
            id v83 = 0LL;
            goto LABEL_93;
          }

          uint64_t v88 = objc_claimAutoreleasedReturnValue([v86 vertexBindings]);
        }

        id v83 = (id)v88;
        unsigned int v87 = *(_DWORD *)(a4 + 256);
LABEL_93:
        unsigned int v89 = TraceBufferBindingIndex(v83, v87);
        unint64_t v105 = a3[1];
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( a4,  v105,  &v105)
        + 6) = v89;
        uint64_t v84 = v86;
        goto LABEL_94;
      }

      uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v11 libraryForKey:*(void *)(v45 + 40)]);
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v11 functionMap]);
      id v111 = 0LL;
      id v51 = ObtainTracingFunction(v12, v92, a4, v45, v50, (uint64_t)&v111);
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
      id v30 = v111;

      if (!v52) {
        goto LABEL_79;
      }
      [v93 setVertexFunction:v52];
      uint64_t v53 = ObtainTracingLinkedFunctions( (const GTMTLSMContext *)a1,  v11,  (GTMTLReplayAccessTracking *)a4,  (uint64_t)v115,  a5);
      id v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
      [v93 setVertexLinkedFunctions:v54];
    }

    goto LABEL_82;
  }

  if (v112 != 2)
  {
    if (v112 == 3)
    {
LABEL_16:
      uint64_t v20 = MakeMTLMeshRenderPipelineDescriptor;
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v11 renderPipelineDescriptorMap]);
      uint64_t v22 = ((uint64_t (*)(uint64_t **, void *))v20)(v113, v21);
      int v93 = (void *)objc_claimAutoreleasedReturnValue(v22);

      int v23 = *(_DWORD *)(a4 + 256);
      switch(v23)
      {
        case 2:
          uint64_t v55 = *(void *)(a3[9] + 344LL);
          if (v55)
          {
            uint64_t v56 = GTMTLSMContext_lastObject(*a1, v55, a5);
            if (v56)
            {
              uint64_t v57 = v56;
              uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v11 libraryForKey:*(void *)(v56 + 40)]);
              id v58 = (void *)objc_claimAutoreleasedReturnValue([v11 functionMap]);
              id v98 = 0LL;
              id v59 = ObtainTracingFunction(v12, v92, a4, v57, v58, (uint64_t)&v98);
              id v29 = (void *)objc_claimAutoreleasedReturnValue(v59);
              id v30 = v98;

              if (v29)
              {
                [v93 setFragmentFunction:v29];
                goto LABEL_48;
              }

              goto LABEL_79;
            }
          }

          break;
        case 32:
          uint64_t v60 = *(void *)(a3[9] + 360LL);
          if (v60)
          {
            uint64_t v61 = GTMTLSMContext_lastObject(*a1, v60, a5);
            if (v61)
            {
              uint64_t v62 = v61;
              uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v11 libraryForKey:*(void *)(v61 + 40)]);
              id v63 = (void *)objc_claimAutoreleasedReturnValue([v11 functionMap]);
              id v99 = 0LL;
              id v64 = ObtainTracingFunction(v12, v92, a4, v62, v63, (uint64_t)&v99);
              id v29 = (void *)objc_claimAutoreleasedReturnValue(v64);
              id v30 = v99;

              if (v29)
              {
                [v93 setMeshFunction:v29];
                goto LABEL_48;
              }

              goto LABEL_79;
            }
          }

          break;
        case 16:
          uint64_t v24 = *(void *)(a3[9] + 368LL);
          if (v24)
          {
            uint64_t v25 = GTMTLSMContext_lastObject(*a1, v24, a5);
            if (v25)
            {
              uint64_t v26 = v25;
              uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v11 libraryForKey:*(void *)(v25 + 40)]);
              uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v11 functionMap]);
              id v100 = 0LL;
              id v28 = ObtainTracingFunction(v12, v92, a4, v26, v27, (uint64_t)&v100);
              id v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
              id v30 = v100;

              if (v29)
              {
                [v93 setObjectFunction:v29];
LABEL_48:

                __int128 v65 = v30;
                goto LABEL_50;
              }

              goto LABEL_79;
            }
          }

          break;
        default:
          __int128 v65 = 0LL;
LABEL_50:
          if (SupportsGlobalRelocation(v12, a4))
          {
            id v97 = v65;
            id v13 = [v12 newRenderPipelineStateWithMeshDescriptor:v93 options:v94 reflection:0 error:&v97];
            id v42 = v97;
            goto LABEL_65;
          }

          if ((objc_opt_respondsToSelector(v93, "setGpuCompilerSPIOptions:") & 1) != 0) {
            [v93 setGpuCompilerSPIOptions:&off_5A00B0];
          }
          id v95 = v65;
          id v96 = 0LL;
          id v13 = [v12 newRenderPipelineStateWithMeshDescriptor:v93 options:v94 | 1 reflection:&v96 error:&v95];
          id v66 = v96;
          id v42 = v95;

          unsigned int v67 = *(_DWORD *)(a4 + 256);
          switch(v67)
          {
            case 2u:
              uint64_t v68 = objc_claimAutoreleasedReturnValue([v66 fragmentBindings]);
              break;
            case 0x20u:
              uint64_t v68 = objc_claimAutoreleasedReturnValue([v66 meshBindings]);
              break;
            case 0x10u:
              uint64_t v68 = objc_claimAutoreleasedReturnValue([v66 objectBindings]);
              break;
            default:
              unint64_t v72 = 0LL;
              goto LABEL_64;
          }

          unint64_t v72 = (void *)v68;
          unsigned int v67 = *(_DWORD *)(a4 + 256);
LABEL_64:
          unsigned int v73 = TraceBufferBindingIndex(v72, v67);
          unint64_t v105 = a3[1];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( a4,  v105,  &v105)
          + 6) = v73;

          __int128 v65 = v66;
          goto LABEL_65;
      }

void sub_135574( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ReplaceFunctionTablesWithInstrumented( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5, uint64_t *a6, apr_pool_t *p)
{
  uint64_t v11 = *(void *)a2;
  uint64_t v12 = apr_array_make(p, 5, 8);
  pa = p;
  id v13 = apr_array_make(p, 5, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v11 + 40) + 56LL), a4, v12);
  unint64_t v76 = a4;
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v11 + 40) + 64LL), a4, v13);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  id v69 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + 56) = 0u;
  uint64_t v73 = a1;
  *(_DWORD *)(a1 + 72) = 1065353216;
  if (v12->nelts >= 1)
  {
    uint64_t v14 = 0LL;
    while (1)
    {
      uint64_t v15 = *(void *)&v12->elts[8 * v14];
      if (v15)
      {
        unint64_t v16 = *(void *)(v15 + 16);
        unint64_t v17 = *(void *)(v11 + 64);
        if (v17 > v16 || *(void *)(v11 + 72) + v17 <= v16)
        {
          int v19 = *(_DWORD *)(a3 + 256);
          if (!*(void *)(v15 + 120) || v19 == 8)
          {
            uint64_t v21 = *(void *)(v15 + 128);
            if (!v21) {
              break;
            }
            HIDWORD(v23) = *(unsigned __int8 *)(v15 + 168);
            LODWORD(v23) = (HIDWORD(v23) << 24) - 0x2000000;
            unsigned __int8 v22 = v23 >> 25;
            int v24 = v22 > 7u ? 1 : dword_316FF8[v22];
            if (v24 == v19) {
              break;
            }
          }
        }
      }

LABEL_90:
              id v50 = v72;
              goto LABEL_91;
            }
          }
        }

        id v56 = 0LL;
      }

LABEL_91:
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v78);
      if (v56)
      {
        v80[0] = *(void *)(v39 + 8);
        __int128 v65 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( v69,  v80[0],  v80);
        objc_storeStrong(v65 + 3, v56);
        [*(id *)(a2 + 8) setIntersectionFunctionTable:v56 forKey:*(void *)(v39 + 8)];
      }

LABEL_94:
      ;
    }
  }

  char v70 = *(void *)v3;
  if (*((void *)v3 + 1) != *(void *)v3)
  {
    id v71 = 0LL;
    unint64_t v72 = 0LL;
    do
    {
      v253 = v72;
      uint64_t v73 = v72;
      int v74 = (uint64_t *)(v70 + 88LL * v72);
      unint64_t v76 = v74 + 8;
      int v75 = v74[8];
      unint64_t v77 = *((unsigned int *)v74 + 5);
      uint64_t v78 = v74 + 10;
      v257 = v74 + 10;
      if (v77 > (v74[10] - v75) >> 4)
      {
        uint64_t v79 = v70 + 88LL * v72;
        uint64_t v81 = *(void *)(v79 + 72);
        id v80 = (void **)(v79 + 72);
        id v82 = v81 - v75;
        id v83 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v77);
        id v85 = &v83[v82 & 0xFFFFFFFFFFFFFFF0LL];
        id v86 = (char *)*v80;
        unsigned int v87 = (char *)*v76;
        uint64_t v88 = v85;
        if (*v80 != (void *)*v76)
        {
          do
          {
            *((_OWORD *)v88 - 1) = *((_OWORD *)v86 - 1);
            v88 -= 16;
            v86 -= 16;
          }

          while (v86 != v87);
          id v86 = (char *)*v76;
        }

        uint64_t v78 = v74 + 10;
        *unint64_t v76 = v88;
        *id v80 = v85;
        unint64_t *v257 = (uint64_t)&v83[16 * v84];
        if (v86) {
          operator delete(v86);
        }
      }

      unsigned int v89 = *v74;
      uint64_t v90 = *(void *)(v70 + 88LL * v73 + 8);
      id v91 = *(void *)(*((void *)v3 + 6) + 120LL);
      v270 = v91;
      uint64_t v271 = v89;
      if (v90)
      {
        uint64_t v261 = v90 + v89;
        uint64_t v92 = (char **)(v70 + 88LL * v73 + 72);
        int v93 = v91;
        while (1)
        {
          (*(void (**)(unint64_t *__return_ptr))(*(void *)v93 + 24LL))(&v274);
          uint64_t v94 = v274;
          if ((v275 & 1) != 0) {
            break;
          }
          if (v274)
          {
            id v95 = (*(uint64_t (**)(void, unint64_t))(**(void **)(*((void *)v3 + 6) + 136LL) + 16LL))( *(void *)(*((void *)v3 + 6) + 136LL),  v274 + 24);
            if ((_DWORD)v95 == -1 || (v95 & 0xFF00000000LL) == 0) {
              id v97 = 1;
            }
            else {
              id v97 = v95;
            }
            id v98 = (*(uint64_t (**)(void, unint64_t))(**(void **)(*((void *)v3 + 6) + 88LL) + 56LL))( *(void *)(*((void *)v3 + 6) + 88LL),  v94);
            id v99 = (*(uint64_t (**)(void, unint64_t))(**(void **)(*((void *)v3 + 6) + 88LL) + 64LL))( *(void *)(*((void *)v3 + 6) + 88LL),  v94);
            id v100 = v99;
            id v101 = *(void *)v94;
            id v102 = *v92;
            id v103 = *v78;
            if ((unint64_t)*v92 >= *v78)
            {
              unint64_t v105 = (uint64_t)&v102[-*v76] >> 4;
              id v106 = v105 + 1;
              id v107 = v103 - *v76;
              if (v107 >> 3 > v106) {
                id v106 = v107 >> 3;
              }
              else {
                id v108 = v106;
              }
              id v109 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v108);
              id v111 = &v109[16 * v105];
              *(_DWORD *)id v111 = v101;
              *((_DWORD *)v111 + 1) = v97;
              *((_DWORD *)v111 + 2) = v98;
              *((_DWORD *)v111 + 3) = v100;
              int v112 = *v92;
              __int128 v113 = (char *)*v76;
              __int128 v114 = v111;
              if (*v92 == (char *)*v76)
              {
                uint64_t v78 = v257;
              }

              else
              {
                uint64_t v78 = v257;
                do
                {
                  *((_OWORD *)v114 - 1) = *((_OWORD *)v112 - 1);
                  v114 -= 16;
                  v112 -= 16;
                }

                while (v112 != v113);
                int v112 = (char *)*v76;
              }

              *unint64_t v76 = v114;
              id v104 = v111 + 16;
              void *v92 = v111 + 16;
              *uint64_t v78 = (uint64_t)&v109[16 * v110];
              if (v112) {
                operator delete(v112);
              }
            }

            else
            {
              *(_DWORD *)id v102 = v101;
              *((_DWORD *)v102 + 1) = v97;
              id v104 = v102 + 16;
              *((_DWORD *)v102 + 2) = v98;
              *((_DWORD *)v102 + 3) = v99;
            }

            void *v92 = v104;
          }

          llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput>::operator++(&v270);
          int v93 = v270;
          if (v270 == v91 && v271 == v261) {
            goto LABEL_133;
          }
        }

        fwrite("Unexpected instruction found", 0x1CuLL, 1uLL, __stderrp);
        if (v94) {
          (*(void (**)(unint64_t))(*(void *)v94 + 8LL))(v94);
        }
      }

void sub_135E9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va1);

  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a5);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a8);
  _Unwind_Resume(a1);
}

void *GetVisibleFunctionTableState(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, apr_pool_t *p)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)a1 = 83;
  *(void *)(a1 + 24) = -1LL;
  *(_WORD *)(a1 + 98) = 2;
  *(void *)(a1 + 64) = -1LL;
  uint64_t v9 = **(void **)(a3 + 104);
  *(void *)(a1 + 184) = v9;
  size_t v10 = 8 * v9;
  uint64_t v11 = apr_palloc(p, 8 * v9);
  *(void *)(a1 + 176) = v11;
  bzero(v11, v10);
  uint64_t v12 = *(void *)(a2 + 8);
  uint64_t v25 = *(void *)(a3 + 8);
  uint64_t result = find_entry(v12, &v25, 8uLL, 0LL);
  if (*(void *)result)
  {
    uint64_t v14 = *(void *)(*(void *)result + 32LL);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 32);
      if (v15)
      {
        unsigned int v16 = 0;
        while (1)
        {
          unsigned int v17 = atomic_load((unsigned int *)(v15 + 4));
          uint64_t v18 = v16 + (v17 >> 6) - 1;
          uint64_t v15 = *(void *)(v15 + 40);
          unsigned int v16 = v18;
          if (!v15)
          {
            unsigned int v16 = v18;
            goto LABEL_10;
          }
        }
      }

      else
      {
        unsigned int v16 = 0;
      }

      uint64_t v18 = 0LL;
LABEL_10:
      unint64_t v19 = v16 | (unint64_t)(v18 << 32);
LABEL_11:
      uint64_t v20 = v15 + 64;
      while (v15)
      {
        uint64_t v21 = (unint64_t *)(v20 + ((uint64_t)(HIDWORD(v19) - (int)v19) << 6));
        if (*v21 >= a4) {
          break;
        }
        uint64_t result = GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithMap(a1, *(void *)(a2 + 16), (uint64_t)v21);
        unsigned int v22 = atomic_load((unsigned int *)(v15 + 4));
        int v23 = v19 + (v22 >> 6);
        uint64_t v24 = (HIDWORD(v19) + 1);
        unint64_t v19 = (v24 << 32) | v19;
        if ((_DWORD)v24 == v23 - 1)
        {
          unint64_t v19 = (v24 << 32) | v24;
          uint64_t v15 = *(void *)(v15 + 40);
          goto LABEL_11;
        }
      }
    }
  }

  return result;
}

void SetupInstrumentedFunctionTable( void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  id v17 = a1;
  if (*(void *)(a4 + 184))
  {
    unint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a4 + 176) + 8 * v11);
      if (v12)
      {
        uint64_t Object = GTMTLSMContext_getObject(*a2, v12, a6);
        if (Object)
        {
          uint64_t v14 = Object[5];
          v18[0] = a5;
          v18[1] = v14;
          uint64_t v15 = std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::find<FunctionHandleKey>( *(void *)a3,  *(void *)(a3 + 8),  v18);
          if (v15)
          {
            id v16 = (id)v15[4];
            [v17 setFunction:v16 atIndex:v11];
          }
        }
      }

      else
      {
        [v17 setFunction:0 atIndex:v11];
      }

      ++v11;
    }

    while (*(void *)(a4 + 184) > v11);
  }
}

void sub_136204( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object {objcproto23MTLVisibleFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object {objcproto23MTLVisibleFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object {objcproto23MTLVisibleFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto23MTLVisibleFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    *unint64_t v19 = i;
    goto LABEL_39;
  }

  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_13641C(_Unwind_Exception *a1)
{
}

uint64_t std::unordered_map<unsigned long long,objc_object {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map( uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  *(void *)(a2 + 8));
  os_log_t v5 = *(void **)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = (void *)(a1 + 16);
    do
    {
      unint64_t v7 = v5[2];
      unint64_t v8 = *(void *)(a1 + 8);
      if (v8)
      {
        uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          unint64_t v2 = v5[2];
          if (v7 >= v8) {
            unint64_t v2 = v7 % v8;
          }
        }

        else
        {
          unint64_t v2 = (v8 - 1) & v7;
        }

        size_t v10 = *(void **)(*(void *)a1 + 8 * v2);
        if (v10)
        {
          for (uint64_t i = (void *)*v10; i; uint64_t i = (void *)*i)
          {
            unint64_t v12 = i[1];
            if (v12 == v7)
            {
              if (i[2] == v7) {
                goto LABEL_41;
              }
            }

            else
            {
              if (v9.u32[0] > 1uLL)
              {
                if (v12 >= v8) {
                  v12 %= v8;
                }
              }

              else
              {
                v12 &= v8 - 1;
              }

              if (v12 != v2) {
                break;
              }
            }
          }
        }
      }

      float v13 = operator new(0x20uLL);
      *float v13 = 0LL;
      v13[1] = v7;
      BOOL v14 = (void *)v5[3];
      v13[2] = v5[2];
      v13[3] = v14;
      float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
      float v16 = *(float *)(a1 + 32);
      if (!v8 || (float)(v16 * (float)v8) < v15)
      {
        BOOL v17 = (v8 & (v8 - 1)) != 0;
        if (v8 < 3) {
          BOOL v17 = 1LL;
        }
        unint64_t v18 = v17 | (2 * v8);
        unint64_t v19 = vcvtps_u32_f32(v15 / v16);
        if (v18 <= v19) {
          size_t v20 = v19;
        }
        else {
          size_t v20 = v18;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v20);
        unint64_t v8 = *(void *)(a1 + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8) {
            unint64_t v2 = v7 % v8;
          }
          else {
            unint64_t v2 = v7;
          }
        }

        else
        {
          unint64_t v2 = (v8 - 1) & v7;
        }
      }

      uint64_t v21 = *(void *)a1;
      unsigned int v22 = *(void **)(*(void *)a1 + 8 * v2);
      if (v22)
      {
        *float v13 = *v22;
      }

      else
      {
        *float v13 = *v6;
        *uint64_t v6 = v13;
        *(void *)(v21 + 8 * v2) = v6;
        if (!*v13) {
          goto LABEL_40;
        }
        unint64_t v23 = *(void *)(*v13 + 8LL);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v23 >= v8) {
            v23 %= v8;
          }
        }

        else
        {
          v23 &= v8 - 1;
        }

        unsigned int v22 = (void *)(*(void *)a1 + 8 * v23);
      }

      void *v22 = v13;
LABEL_40:
      ++*(void *)(a1 + 24);
LABEL_41:
      os_log_t v5 = (void *)*v5;
    }

    while (v5);
  }

  return a1;
}

void sub_136660(_Unwind_Exception *a1)
{
}

void *GetIntersectionFunctionTableState( _DWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5, apr_pool_t *a6)
{
  *a1 = 60;
  *((void *)a1 + 3) = -1LL;
  *((_WORD *)a1 + 49) = 2;
  *((void *)a1 + 8) = -1LL;
  uint64_t v12 = *(unsigned int *)(*(void *)(a3 + 104) + 8LL);
  *((void *)a1 + 22) = v12;
  size_t v13 = 16 * v12;
  BOOL v14 = apr_palloc(a6, 16 * v12);
  *((void *)a1 + 21) = v14;
  bzero(v14, v13);
  uint64_t v15 = *(void *)(a2 + 8);
  uint64_t v28 = *(void *)(a3 + 8);
  uint64_t result = find_entry(v15, &v28, 8uLL, 0LL);
  if (*(void *)result)
  {
    uint64_t v17 = *(void *)(*(void *)result + 32LL);
    if (v17)
    {
      uint64_t v18 = *(void *)(v17 + 32);
      if (v18)
      {
        unsigned int v19 = 0;
        while (1)
        {
          unsigned int v20 = atomic_load((unsigned int *)(v18 + 4));
          uint64_t v21 = v19 + (v20 >> 6) - 1;
          uint64_t v18 = *(void *)(v18 + 40);
          unsigned int v19 = v21;
          if (!v18)
          {
            unsigned int v19 = v21;
            goto LABEL_10;
          }
        }
      }

      else
      {
        unsigned int v19 = 0;
      }

      uint64_t v21 = 0LL;
LABEL_10:
      unint64_t v22 = v19 | (unint64_t)(v21 << 32);
LABEL_11:
      uint64_t v23 = v18 + 64;
      while (v18)
      {
        uint64_t v24 = (unint64_t *)(v23 + ((uint64_t)(HIDWORD(v22) - (int)v22) << 6));
        if (*v24 >= a4) {
          break;
        }
        uint64_t result = GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap( (uint64_t)a1,  *(void *)(a2 + 16),  (uint64_t)v24,  a5);
        unsigned int v25 = atomic_load((unsigned int *)(v18 + 4));
        int v26 = v22 + (v25 >> 6);
        uint64_t v27 = (HIDWORD(v22) + 1);
        unint64_t v22 = (v27 << 32) | v22;
        if ((_DWORD)v27 == v26 - 1)
        {
          unint64_t v22 = (v27 << 32) | v27;
          uint64_t v18 = *(void *)(v18 + 40);
          goto LABEL_11;
        }
      }
    }
  }

  return result;
}

void SetupInstrumentedIntersectionFunctionTable( void *a1, void *a2, uint64_t *a3, uint64_t a4, void *a5, void *a6, uint64_t a7, unint64_t a8)
{
  id v30 = a1;
  id v15 = a2;
  if (a6[22])
  {
    uint64_t v16 = 0LL;
    unint64_t v17 = 0LL;
    do
    {
      uint64_t v18 = a6[21];
      int v19 = *(_DWORD *)(v18 + v16);
      switch(v19)
      {
        case 3:
          [v30 setOpaqueCurveIntersectionFunctionWithSignature:*(void *)(v18 + v16 + 8) atIndex:v17];
          break;
        case 2:
          [v30 setOpaqueTriangleIntersectionFunctionWithSignature:*(void *)(v18 + v16 + 8) atIndex:v17];
          break;
        case 1:
          uint64_t v20 = *(void *)(v18 + v16 + 8);
          if (v20)
          {
            uint64_t Object = GTMTLSMContext_getObject(*a3, v20, a8);
            if (Object && (Object[7] == a7 || Object[6] == a7))
            {
              uint64_t v22 = Object[5];
              v31[0] = a7;
              v31[1] = v22;
              uint64_t v23 = std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::find<FunctionHandleKey>( *(void *)a4,  *(void *)(a4 + 8),  v31);
              if (v23)
              {
                id v24 = (id)v23[4];
                [v30 setFunction:v24 atIndex:v17];
              }
            }
          }

          else
          {
            [v30 setFunction:0 atIndex:v17];
          }

          break;
      }

      ++v17;
      v16 += 16LL;
    }

    while (a6[22] > v17);
  }

  uint64_t v25 = 0LL;
  int v26 = a6 + 25;
  do
  {
    int v27 = *((_DWORD *)v26 - 4);
    if (v27 == 2)
    {
      id v29 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( a5,  *(v26 - 1));
      if (!v29) {
        goto LABEL_23;
      }
      id v28 = (id)v29[3];
      [v30 setVisibleFunctionTable:v28 atBufferIndex:v25];
    }

    else
    {
      if (v27 != 1) {
        goto LABEL_23;
      }
      id v28 = (id)objc_claimAutoreleasedReturnValue([v15 bufferForKey:*(v26 - 1)]);
      [v30 setBuffer:v28 offset:*v26 atIndex:v25];
    }

LABEL_23:
    ++v25;
    v26 += 3;
  }

  while (v25 != 31);
}

void sub_136A08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object {objcproto28MTLIntersectionFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object {objcproto28MTLIntersectionFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object {objcproto28MTLIntersectionFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto28MTLIntersectionFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint8x8_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = a1 + 2;
  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0LL;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }

  BOOL v15 = 1LL;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1LL)
  {
    int8x8_t prime = (int8x8_t)2LL;
  }

  else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }

  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }

    else
    {
      uint64_t v27 = 1LL << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }

    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }

    if (!*(void *)&prime)
    {
      id v34 = (void *)*a1;
      *a1 = 0LL;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0LL;
      a1[1] = 0LL;
      goto LABEL_60;
    }
  }

  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  int v19 = operator new(8LL * *(void *)&prime);
  uint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0LL;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0LL;
  while (*(void *)&prime != v21);
  uint64_t v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }

    else
    {
      v23 &= *(void *)&prime - 1LL;
    }

    *(void *)(*a1 + 8 * v23) = v12;
    id v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }

        else
        {
          v29 &= *(void *)&prime - 1LL;
        }

        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }

          void *v22 = *v28;
          void *v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          id v28 = v22;
        }

        unint64_t v29 = v23;
LABEL_56:
        uint64_t v22 = v28;
        id v28 = (void *)*v28;
        unint64_t v23 = v29;
      }

      while (v28);
    }
  }

  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }

  else
  {
    v5 &= v7 - 1;
  }

void sub_136E18(_Unwind_Exception *a1)
{
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,objc_object {objcproto28MTLIntersectionFunctionTable}* {__strong}>,void *>>>::operator()[abi:nn180100]( char a1, id *a2)
{
  if (a1)
  {
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void *std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object {objcproto17MTLFunctionHandle}* {__strong}>>::find<FunctionHandleKey>( uint64_t a1, unint64_t a2, void *a3)
{
  if (!a2) {
    return 0LL;
  }
  unint64_t v3 = a3[1] ^ (*a3 << 32);
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a3[1] ^ (*a3 << 32);
    if (v3 >= a2) {
      unint64_t v5 = v3 % a2;
    }
  }

  else
  {
    unint64_t v5 = (a2 - 1) & v3;
  }

  uint64_t v6 = *(void **)(a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == *a3 && result[3] == a3[1]) {
          return result;
        }
      }

      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= a2) {
            v8 %= a2;
          }
        }

        else
        {
          v8 &= a2 - 1;
        }

        if (v8 != v5) {
          return 0LL;
        }
      }

      uint64_t result = (void *)*result;
    }

    while (result);
  }

  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint8x8_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = a1 + 2;
  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0LL;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }

  BOOL v15 = 1LL;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1LL)
  {
    int8x8_t prime = (int8x8_t)2LL;
  }

  else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }

  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }

    else
    {
      uint64_t v27 = 1LL << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }

    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }

    if (!*(void *)&prime)
    {
      id v34 = (void *)*a1;
      *a1 = 0LL;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0LL;
      a1[1] = 0LL;
      goto LABEL_60;
    }
  }

  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  int v19 = operator new(8LL * *(void *)&prime);
  uint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0LL;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0LL;
  while (*(void *)&prime != v21);
  uint64_t v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }

    else
    {
      v23 &= *(void *)&prime - 1LL;
    }

    *(void *)(*a1 + 8 * v23) = v12;
    id v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }

        else
        {
          v29 &= *(void *)&prime - 1LL;
        }

        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }

          void *v22 = *v28;
          void *v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          id v28 = v22;
        }

        unint64_t v29 = v23;
LABEL_56:
        uint64_t v22 = v28;
        id v28 = (void *)*v28;
        unint64_t v23 = v29;
      }

      while (v28);
    }
  }

  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }

  else
  {
    v5 &= v7 - 1;
  }

void sub_137304(_Unwind_Exception *a1)
{
}

id ObtainTracingFunction(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  id v11 = a1;
  id v12 = a2;
  id v13 = a5;
  if (*(_BYTE *)(a4 + 132)) {
    goto LABEL_2;
  }
  uint64_t v15 = a3 + 160;
  unint64_t v35 = *(void *)(a4 + 8);
  id v14 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( a3 + 160,  v35,  &v35)[3];
  if (v14) {
    goto LABEL_15;
  }
  uint64_t v16 = *(void *)(a4 + 112);
  if (v16)
  {
    MTLFunctionDescriptor = MakeMTLFunctionDescriptor(v16, v13);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);
    id v19 = [v12 newFunctionWithDescriptor:v18 error:a6];
LABEL_8:
    id v14 = v19;
    goto LABEL_9;
  }

  uint64_t v20 = *(void *)(a4 + 120);
  if (v20)
  {
    MTLIntersectionFunctionDescriptor = MakeMTLIntersectionFunctionDescriptor(v20, v13);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionDescriptor);
    id v19 = [v12 newIntersectionFunctionWithDescriptor:v18 error:a6];
    goto LABEL_8;
  }

  if (!*(void *)(a4 + 56))
  {
LABEL_2:
    id v14 = 0LL;
    goto LABEL_15;
  }

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
  unint64_t v32 = *(void **)(a4 + 72);
  if (!v32)
  {
    id v19 = [v12 newFunctionWithName:v18];
    goto LABEL_8;
  }

  MTLFunctionConstantValues = MakeMTLFunctionConstantValues(v32);
  id v34 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
  id v14 = [v12 newFunctionWithName:v18 constantValues:v34 error:a6];

LABEL_9:
  if (v14)
  {
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v14 device]);
    unsigned int v23 = SupportsGlobalRelocation(v22, a3);

    if (v23)
    {
      uint8x8_t v24 = *(void **)(a3 + 240);
      id v25 = v14;
      id v26 = v24;
      id v27 = [[MTLBufferRelocation alloc] initWithSymbolName:@"__resource_tracking_impl_trace_buffer" buffer:v26 offset:0];
      id v28 = v27;
      if (v27)
      {
        unint64_t v35 = (unint64_t)v27;
        unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v35, 1LL));
        [v25 setRelocations:v29];
      }
    }

    unint64_t v35 = *(void *)(a4 + 8);
    uint64_t v30 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( v15,  v35,  &v35);
    objc_storeStrong(v30 + 3, v14);
  }

void sub_137578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

MTLLinkedFunctions *ObtainTracingLinkedFunctions( const GTMTLSMContext *a1, void *a2, GTMTLReplayAccessTracking *a3, uint64_t a4, unint64_t a5)
{
  uint8x8_t v9 = a2;
  if (a4)
  {
    size_t v10 = ObtainTracingFunctions(a1, v9, a3, *(const unint64_t **)(a4 + 16), *(void *)(a4 + 24), a5);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    id v12 = ObtainTracingFunctions(a1, v9, a3, *(const unint64_t **)a4, *(void *)(a4 + 8), a5);
    id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    id v14 = ObtainTracingFunctions(a1, v9, a3, *(const unint64_t **)(a4 + 48), *(void *)(a4 + 56), a5);
    uint64_t v15 = objc_claimAutoreleasedReturnValue(v14);
    uint64_t v16 = (void *)v15;
    if (v11 || v13 || v15)
    {
      unint64_t v17 = objc_alloc_init(&OBJC_CLASS___MTLLinkedFunctions);
      -[MTLLinkedFunctions setFunctions:](v17, "setFunctions:", v11);
      -[MTLLinkedFunctions setBinaryFunctions:](v17, "setBinaryFunctions:", v13);
      -[MTLLinkedFunctions setPrivateFunctions:](v17, "setPrivateFunctions:", v16);
    }

    else
    {
      unint64_t v17 = 0LL;
    }
  }

  else
  {
    unint64_t v17 = 0LL;
  }

  return v17;
}

void sub_137738(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id SupportsGlobalRelocation(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint8x8_t v4 = v3;
  id v5 = 0LL;
  int v6 = *(_DWORD *)(a2 + 256);
  switch(v6)
  {
    case 1:
    case 4:
      goto LABEL_11;
    case 2:
      if (*(_BYTE *)(a2 + 261))
      {
        if (![v3 supportsFamily:1009])
        {
LABEL_15:
          id v5 = 0LL;
          goto LABEL_16;
        }

void sub_13789C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *TraceBufferBindingIndex(void *a1, unsigned int a2)
{
  id v3 = a1;
  uint8x8_t v4 = 0LL;
  if (a2 <= 0x20 && ((1LL << a2) & 0x100010116LL) != 0)
  {
    uint8x8_t v4 = 0LL;
    while (2)
    {
      __int128 v13 = 0u;
      __int128 v14 = 0u;
      __int128 v11 = 0u;
      __int128 v12 = 0u;
      id v5 = v3;
      id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (v6)
      {
        uint64_t v7 = *(void *)v12;
LABEL_6:
        uint64_t v8 = 0LL;
        while (1)
        {
          if (*(void *)v12 != v7) {
            objc_enumerationMutation(v5);
          }
          uint8x8_t v9 = *(void **)(*((void *)&v11 + 1) + 8 * v8);
          if (![v9 type] && objc_msgSend(v9, "index") == v4) {
            break;
          }
          if (v6 == (id)++v8)
          {
            id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
            if (v6) {
              goto LABEL_6;
            }
            goto LABEL_16;
          }
        }

        if (++v4 != (_BYTE *)&dword_1C + 3) {
          continue;
        }
        uint8x8_t v4 = 0LL;
      }

      else
      {
LABEL_16:
      }

      break;
    }
  }

  return v4;
}

void sub_137A14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      size_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          size_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  size_t v10 = operator new(0x20uLL);
  void *v10 = 0LL;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  id v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    *id v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    id v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_137C34(_Unwind_Exception *a1)
{
}

void CreateRenderFunctionHandles( GTMTLReplayAccessTracking *a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
}

void CreateRenderFunctionHandles( GTMTLReplayAccessTracking *a1, unint64_t a2, const unint64_t *a3, uint64_t a4, unint64_t a5)
{
  if (a3 && a4)
  {
    uint64_t v8 = 0LL;
    uint8x8_t v9 = (uint64_t *)((char *)a1 + 80);
    uint64_t v31 = (char *)a1 + 160;
    unint64_t v32 = (uint64_t *)((char *)a1 + 40);
    size_t v10 = (void *)((char *)a1 + 96);
    do
    {
      unint64_t v11 = a3[v8];
      unint64_t v36 = v11;
      unint64_t v37 = a2;
      unint64_t v12 = *((void *)a1 + 11);
      if (v12)
      {
        uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v13.i16[0] = vaddlv_u8(v13);
        if (v13.u32[0] > 1uLL)
        {
          uint64_t v5 = a5;
          if (v12 <= a5) {
            uint64_t v5 = a5 % v12;
          }
        }

        else
        {
          uint64_t v5 = (v12 - 1) & a5;
        }

        BOOL v14 = *(void ***)(*v9 + 8 * v5);
        if (v14)
        {
          unint64_t v15 = (char *)*v14;
          if (*v14)
          {
            do
            {
              unint64_t v16 = *((void *)v15 + 1);
              if (v16 == a5)
              {
                if (*((void *)v15 + 2) == a5) {
                  goto LABEL_42;
                }
              }

              else
              {
                if (v13.u32[0] > 1uLL)
                {
                  if (v16 >= v12) {
                    v16 %= v12;
                  }
                }

                else
                {
                  v16 &= v12 - 1;
                }

                if (v16 != v5) {
                  break;
                }
              }

              unint64_t v15 = *(char **)v15;
            }

            while (v15);
          }
        }
      }

      unint64_t v15 = (char *)operator new(0x40uLL);
      *(void *)&__int128 v38 = v15;
      *((void *)&v38 + 1) = v10;
      *(void *)unint64_t v15 = 0LL;
      *((void *)v15 + 1) = a5;
      *((void *)v15 + 2) = a5;
      *(_OWORD *)(v15 + 24) = 0u;
      *(_OWORD *)(v15 + 40) = 0u;
      *((_DWORD *)v15 + 14) = 1065353216;
      char v39 = 1;
      float v17 = (float)(unint64_t)(*((void *)a1 + 13) + 1LL);
      float v18 = *((float *)a1 + 28);
      if (!v12 || (float)(v18 * (float)v12) < v17)
      {
        BOOL v19 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3) {
          BOOL v19 = 1LL;
        }
        unint64_t v20 = v19 | (2 * v12);
        unint64_t v21 = vcvtps_u32_f32(v17 / v18);
        if (v20 <= v21) {
          size_t v22 = v21;
        }
        else {
          size_t v22 = v20;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)v9,  v22);
        unint64_t v12 = *((void *)a1 + 11);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v12 <= a5) {
            uint64_t v5 = a5 % v12;
          }
          else {
            uint64_t v5 = a5;
          }
        }

        else
        {
          uint64_t v5 = (v12 - 1) & a5;
        }
      }

      uint64_t v23 = *v9;
      uint8x8_t v24 = *(void **)(*v9 + 8 * v5);
      if (v24)
      {
        *(void *)unint64_t v15 = *v24;
      }

      else
      {
        *(void *)unint64_t v15 = *v10;
        void *v10 = v15;
        *(void *)(v23 + 8 * v5) = v10;
        if (!*(void *)v15) {
          goto LABEL_41;
        }
        unint64_t v25 = *(void *)(*(void *)v15 + 8LL);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v25 >= v12) {
            v25 %= v12;
          }
        }

        else
        {
          v25 &= v12 - 1;
        }

        uint8x8_t v24 = (void *)(*v9 + 8 * v25);
      }

      void *v24 = v15;
LABEL_41:
      *(void *)&__int128 v38 = 0LL;
      ++*((void *)a1 + 13);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100]((uint64_t)&v38);
LABEL_42:
      uint64_t v5 = (uint64_t)(v15 + 24);
      *(void *)&__int128 v38 = a2;
      *((void *)&v38 + 1) = v11;
      id v26 = (id)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>( (uint64_t)(v15 + 24),  &v38,  &v38)[4];
      if (!v26)
      {
        id v27 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( v32,  v37,  &v37)[3];
        if (v27)
        {
          id v28 = v27;
          id v29 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( (uint64_t)v31,  v36,  &v36)[3];
          if (v29)
          {
            id v26 = (id)objc_claimAutoreleasedReturnValue([v28 functionHandleWithFunction:v29 stage:a5]);
            if (v26)
            {
              uint64_t v30 = (id *)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>( v5,  &v38,  &v38);
              objc_storeStrong(v30 + 4, v26);
            }
          }

          else
          {
            id v26 = 0LL;
          }
        }

        else
        {
          id v26 = 0LL;
        }
      }

      ++v8;
    }

    while (v8 != a4);
  }

void sub_137FD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>( uint64_t a1, void *a2, _OWORD *a3)
{
  unint64_t v6 = a2[1] ^ (*a2 << 32);
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2[1] ^ (*a2 << 32);
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == *a2 && i[3] == a2[1]) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = operator new(0x28uLL);
  void *i = 0LL;
  i[1] = v6;
  *((_OWORD *)i + 1) = *a3;
  i[4] = 0LL;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v19 = *(void *)a1;
  unint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *i = *v20;
LABEL_42:
    *unint64_t v20 = i;
    goto LABEL_43;
  }

  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v21 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    unint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_42;
  }

void sub_138210(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    *uint64_t v19 = i;
    goto LABEL_39;
  }

  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_138420(_Unwind_Exception *a1)
{
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FunctionHandleKey,objc_object {objcproto17MTLFunctionHandle}* {__strong}>,void *>>>::operator()[abi:nn180100]( char a1, id *a2)
{
  if (a1)
  {
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,void *>,std::__hash_node_destructor<std::equal_to<FunctionHandleKey><void *>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)v1 + 24);
    }
    operator delete(v1);
  }

NSMutableArray *ObtainTracingFunctions( const GTMTLSMContext *a1, GTMTLReplayObjectMap *a2, GTMTLReplayAccessTracking *a3, const unint64_t *a4, uint64_t a5, unint64_t a6)
{
  size_t v10 = a2;
  uint8x8_t v24 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap defaultDevice](v10, "defaultDevice"));
  if (a4)
  {
    size_t v22 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a5);
    if (a5)
    {
      unint64_t v11 = 0LL;
      do
      {
        uint64_t v12 = *a4++;
        uint64_t Object = GTMTLSMContext_lastObject(*(void *)a1, v12, a6);
        if (Object)
        {
          uint64_t v14 = Object;
          unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap libraryForKey:](v10, "libraryForKey:", *(void *)(Object + 40)));
          unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap functionMap](v10, "functionMap"));
          id v25 = v11;
          id v17 = ObtainTracingFunction(v24, v15, (uint64_t)a3, v14, v16, (uint64_t)&v25);
          uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          id v19 = v25;

          if (v18) {
            -[NSMutableArray addObject:](v22, "addObject:", v18);
          }

          unint64_t v11 = v19;
        }

        else
        {
          id v19 = v11;
        }

        --a5;
      }

      while (a5);
    }

    else
    {
      id v19 = 0LL;
    }

    unint64_t v20 = v22;
  }

  else
  {
    unint64_t v20 = 0LL;
  }

  return v20;
}

void sub_138614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  id v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    *id v19 = i;
    goto LABEL_39;
  }

  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    id v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_138868(_Unwind_Exception *a1)
{
}

void FlushCommandQueue(GTMTLReplayController *a1)
{
  unint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultCommandQueue]);
  id v3 = (id)objc_claimAutoreleasedReturnValue([v2 commandBuffer]);

  [v3 commit];
  [v3 waitUntilCompleted];
  [v3 status];
}

void sub_1388E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t UpdateDrawFunctionTables( uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, void *a5, unint64_t a6)
{
  id v11 = a5;
  uint64_t updated = 0LL;
  signed int v13 = *(_DWORD *)(a1 + 256);
  if (v13 > 15)
  {
    if (v13 == 16)
    {
      uint64_t v14 = a4 + 3584;
      uint64_t v15 = a4 + 3576;
      goto LABEL_10;
    }

    if (v13 == 32)
    {
      uint64_t v14 = a4 + 5240;
      uint64_t v15 = a4 + 5232;
      goto LABEL_10;
    }
  }

  else
  {
    if (v13 == 1)
    {
      uint64_t v14 = a4 + 24;
      uint64_t v15 = a4 + 8;
      goto LABEL_10;
    }

    if (v13 == 2)
    {
      uint64_t v14 = a4 + 1928;
      uint64_t v15 = a4 + 1920;
LABEL_10:
      uint64_t updated = UpdateFunctionTables<31ul,1ul>(v13, v11, v14, v15, a2, a6, a3);
    }
  }

  return updated;
}

void sub_1389D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t UpdateFunctionTables<31ul,1ul>( unsigned int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t *a5, unint64_t a6, void *a7)
{
  id v13 = a2;
  uint64_t v14 = v13;
  LOBYTE(v15) = 0;
  if (a1 > 0x20) {
    goto LABEL_46;
  }
  if (((1LL << a1) & 0x100010016LL) == 0)
  {
    if (a1 != 8LL) {
      goto LABEL_46;
    }
LABEL_45:
    LOBYTE(v15) = 0;
    goto LABEL_46;
  }

LABEL_37:
LABEL_7:
    uint64_t v15 = v17;
LABEL_8:
    ++v16;
    uint64_t v17 = v15;
  }

  while (v16 != 31);
LABEL_46:

  return v15 & 1;
}

void sub_138CD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ObtainTracingComputePipelineState( uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, apr_pool_t *a6)
{
  id v11 = a2;
  unsigned __int8 v46 = (void *)objc_claimAutoreleasedReturnValue([v11 defaultDevice]);
  unint64_t v12 = *(void *)(a3 + 8);
  v54[0] = v12;
  id v13 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( (uint64_t *)(a4 + 120),  v12,  v54)[3];
  unsigned int v45 = SupportsGlobalRelocation(v46, a4);
  if (v13)
  {
LABEL_2:
    id v13 = v13;
    uint64_t v14 = v13;
    goto LABEL_20;
  }

  uint64_t v15 = *(void *)(a4 + 248);
  unint64_t v16 = (unint64_t)(v15 == 2) << 31;
  BOOL v17 = v15 == 1;
  uint64_t v18 = 0x40000000LL;
  if (!v17) {
    uint64_t v18 = v16;
  }
  uint64_t v41 = v18;
  uint64_t v19 = *(void *)(a3 + 48);
  if (!v19)
  {
    uint64_t Object = (void *)a3;
    while (1)
    {
      uint64_t v21 = Object[7];
      if (v21) {
        break;
      }
      uint64_t Object = GTMTLSMContext_getObject(*a1, Object[5], Object[2]);
      uint64_t v19 = Object[6];
      if (v19) {
        goto LABEL_11;
      }
    }

    uint64_t v19 = *(void *)(v21 + 848);
  }

void sub_139100( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    uint8x8_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  unint64_t v12 = a1 + 2;
  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = v5;
  i[2] = *a3;
  i[3] = 0LL;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }

  BOOL v15 = 1LL;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1LL)
  {
    int8x8_t prime = (int8x8_t)2LL;
  }

  else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }

  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }

    else
    {
      uint64_t v27 = 1LL << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }

    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }

    if (!*(void *)&prime)
    {
      id v34 = (void *)*a1;
      *a1 = 0LL;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0LL;
      a1[1] = 0LL;
      goto LABEL_60;
    }
  }

  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v19 = operator new(8LL * *(void *)&prime);
  unint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0LL;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0LL;
  while (*(void *)&prime != v21);
  int8x8_t v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }

    else
    {
      v23 &= *(void *)&prime - 1LL;
    }

    *(void *)(*a1 + 8 * v23) = v12;
    unint64_t v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }

        else
        {
          v29 &= *(void *)&prime - 1LL;
        }

        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }

          void *v22 = *v28;
          void *v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          unint64_t v28 = v22;
        }

        unint64_t v29 = v23;
LABEL_56:
        int8x8_t v22 = v28;
        unint64_t v28 = (void *)*v28;
        unint64_t v23 = v29;
      }

      while (v28);
    }
  }

  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }

  else
  {
    v5 &= v7 - 1;
  }

void sub_1395C0(_Unwind_Exception *a1)
{
}

void CreateComputeFunctionHandles(uint64_t a1, unint64_t a2, unint64_t *a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    if (a4)
    {
      unint64_t v5 = a3;
      uint64_t v7 = a1 + 200;
      uint8x8_t v8 = (uint64_t *)(a1 + 120);
      uint64_t v9 = a1 + 160;
      do
      {
        unint64_t v11 = *v5++;
        unint64_t v10 = v11;
        unint64_t v18 = v11;
        unint64_t v19 = a2;
        *(void *)&__int128 v17 = a2;
        *((void *)&v17 + 1) = v11;
        id v12 = (id)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>( v7,  &v17,  &v17)[4];
        if (!v12)
        {
          id v13 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( v8,  a2,  &v19)[3];
          if (v13)
          {
            float v14 = v13;
            id v15 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto11MTLFunction}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto11MTLFunction}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( v9,  v10,  &v18)[3];
            if (v15)
            {
              id v12 = (id)objc_claimAutoreleasedReturnValue([v14 functionHandleWithFunction:v15]);
              if (v12)
              {
                unint64_t v16 = (id *)std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::__emplace_unique_key_args<FunctionHandleKey,std::piecewise_construct_t const&,std::tuple<FunctionHandleKey const&>,std::piecewise_construct_t const&<>>( v7,  &v17,  &v17);
                objc_storeStrong(v16 + 4, v12);
              }
            }

            else
            {
              id v12 = 0LL;
            }
          }

          else
          {
            id v12 = 0LL;
          }
        }

        --v4;
      }

      while (v4);
    }
  }

void sub_139704(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ReplaceFunctionTablesWithRegular( uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t *a5, apr_pool_t *p)
{
  uint64_t v9 = *(void *)a2;
  unint64_t v10 = apr_array_make(p, 5, 8);
  pa = p;
  unint64_t v11 = apr_array_make(p, 5, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v9 + 40) + 56LL), a4, v10);
  unint64_t v64 = a4;
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(v9 + 40) + 64LL), a4, v11);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  id v58 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + 56) = 0u;
  uint64_t v60 = a1;
  *(_DWORD *)(a1 + 72) = 1065353216;
  int nelts = v10->nelts;
  if (nelts >= 1)
  {
    uint64_t v13 = 0LL;
    while (1)
    {
      uint64_t v14 = *(void *)&v10->elts[8 * v13];
      if (v14)
      {
        unint64_t v15 = *(void *)(v14 + 16);
        unint64_t v16 = *(void *)(v9 + 64);
        BOOL v17 = v16 <= v15 && *(void *)(v9 + 72) + v16 > v15;
        if (!v17 && ((a3 & 8) != 0 || !*(void *)(v14 + 120)))
        {
          if (!*(void *)(v14 + 128)) {
            break;
          }
          HIDWORD(v19) = *(unsigned __int8 *)(v14 + 168);
          LODWORD(v19) = (HIDWORD(v19) << 24) - 0x2000000;
          unsigned __int8 v18 = v19 >> 25;
          int v20 = v18 > 7u ? 1 : dword_316FF8[v18];
          if ((v20 & a3) != 0) {
            break;
          }
        }
      }

void sub_139CC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va1);

  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a3);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table(a5);
  _Unwind_Resume(a1);
}

DYMTLResourceUsageItem *MakeResourceUsageItem(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___DYMTLResourceUsageItem);
  -[DYMTLResourceUsageItem setStage:](v4, "setStage:", a2);
  -[DYMTLResourceUsageItem setKind:](v4, "setKind:", *(void *)(a1 + 8));
  -[DYMTLResourceUsageItem setResourceID:](v4, "setResourceID:", *(void *)a1);
  -[DYMTLResourceUsageItem setUsage:](v4, "setUsage:", *(unsigned __int8 *)(a1 + 16));
  return v4;
}

void sub_139DF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

DYMTLResourceUsageItem *MakeResourceUsageItem(uint64_t a1)
{
  unint64_t v2 = objc_alloc_init(&OBJC_CLASS___DYMTLResourceUsageItem);
  -[DYMTLResourceUsageItem setStage:](v2, "setStage:", 0LL);
  -[DYMTLResourceUsageItem setKind:](v2, "setKind:", *(void *)(a1 + 8));
  -[DYMTLResourceUsageItem setResourceID:](v2, "setResourceID:", *(void *)a1);
  -[DYMTLResourceUsageItem setUsage:](v2, "setUsage:", *(unsigned __int8 *)(a1 + 16));
  return v2;
}

void sub_139E60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ObtainResourceTrackingTracingBufferV2(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = objc_msgSend( v3,  "newBufferWithLength:options:",  24 * *(int *)(*a2 + 12)
       + 16LL
       * (*(_DWORD *)(a2[2] + 48LL)
                      + *(_DWORD *)(a2[1] + 48LL)
                      + *(_DWORD *)(a2[3] + 48LL)
                      + *(_DWORD *)(a2[4] + 48LL)
                      + *(_DWORD *)(a2[5] + 48LL)
                      + *(_DWORD *)(a2[6] + 48LL)
                      + *(_DWORD *)(a2[7] + 48LL)
                      + 2 * *(_DWORD *)(a2[8] + 48LL))
       + 64,
         0LL);

  return v4;
}

void sub_139F0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void InstrumentSubCommandWithAccessTrackingV2( uint64_t a1, GTMTLReplayController *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t *a6, apr_pool_t *a7)
{
  unsigned int v8 = *(_DWORD *)(a3 + 8);
  if (v8 >> 2 != 1073737833) {
    goto LABEL_9;
  }
  unsigned int v15 = v8 & 0xFFFFFFFE;
  if (v15 == -15964)
  {
    var0 = a2->var0;
    id v63 = a2->var1;
    GetExecuteCommandsInBufferArgs((uint64_t)&v71, a3, (uint64_t)var0->var2);
    uint64_t Object = GTMTLSMContext_getObject(*(void *)var0->var5, v71, *(void *)a3);
    GTMTLCreateIndirectCommandEncoder((uint64_t)&v66, Object[13]);
    if (*((void *)&v71 + 1) > a4 || v72 + *((void *)&v71 + 1) < a4) {
      goto LABEL_36;
    }
    GTMTLReplayController_debugSubCommandResume( (unsigned int *)a2,  *(_DWORD *)a3 - LODWORD(var0->var9.var0.var0) + 1,  a4 + 1);
    unint64_t v32 = a2->var0;
    id v33 = a2->var1;
    uint64_t v34 = v73 + v70 * a4;
    uint64_t v35 = *(void *)(v34 + *((void *)&v66 + 1));
    if (v35 != 64 && v35 != 32)
    {
      if (!v35)
      {

LABEL_16:
        RemapIndirectResources((uint64_t)__dst, (uint64_t)a6, v63, a7);
        PopulateResourceTrackingBufferV2( *(void **)(a5 + 240),  __dst,  v36,  v37,  v38,  v39,  v40,  v41,  (uint64_t)v54,  v57,  (uint64_t)v60,  (uint64_t)v63,  v66,  v67,  v68,  v69);
        FlushCommandQueue(a2);
        DecodeResourceTrackingBufferV2( (unint64_t *)&v75,  *(void **)(a5 + 240),  __dst,  v42,  v43,  v44,  v45,  v46,  (uint64_t)v56,  v59,  v62,  (uint64_t)v65,  v66,  v67,  v68,  v69);
        *(_BYTE *)a1 = 1;
        *(_OWORD *)(a1 + 8) = v75;
        *(void *)(a1 + 24) = v76;
        goto LABEL_37;
      }

      goto LABEL_35;
    }

    uint64_t v60 = v33;
    unint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v33 computeCommandEncoderForKey:a2->var21.var0.var2]);
    id v48 = v47;
    if (v47)
    {
      [v47 useResource:*(void *)(a5 + 240) usage:3];
      uint64_t v57 = v66;
      uint64_t v49 = *(_BYTE *)(v66 + 11)
          ? a2->var21.var3.var0.var1[0]
          : GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6[4], *(void *)(v34 + v67));
      if (v49)
      {
        id v50 = GTMTLSMContext_getObject(*(void *)v32->var5, v49, *(void *)a3);
        if (v50)
        {
          id v51 = v50;
          id v52 = ObtainTracingComputePipelineState((uint64_t *)v32->var5, v60, (uint64_t)v50, a5, *(void *)a3, a7);
          id v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
          if (v53)
          {
            id v54 = v53;
            ReplaceFunctionTablesWithInstrumented((uint64_t)&v75, (uint64_t)a2, a5, *(void *)a3, v51, a6, a7);
            std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v78);
            std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v75);
            if (*(_BYTE *)(v57 + 10))
            {
              [v48 setComputePipelineState:v54];
              DYMTLDispatchComputeCommandEncoder(v48, (uint64_t)&v66, v34);
LABEL_31:

              goto LABEL_16;
            }

            memcpy(__dst, &a2->var21.var3, sizeof(__dst));
            if (GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)&a2->var21.var3, &v66, v34, a6))
            {
              GTMTLReplayController_restoreComputeCommandEncoder(v48, (uint64_t)&a2->var21.var3, (uint64_t)__dst, v60);
              [v48 setComputePipelineState:v54];
              DYMTLDispatchComputeCommandEncoder(v48, (uint64_t)&v66, v34);
              goto LABEL_31;
            }

            id v53 = v54;
          }
        }
      }
    }

LABEL_35:
    FlushCommandQueue(a2);
LABEL_36:
    *(void *)(a1 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 24) = 0LL;
    *(_BYTE *)a1 = 0;
    goto LABEL_37;
  }

  if (v15 != -15962)
  {
LABEL_9:
    *(void *)(a1 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 24) = 0LL;
    *(_BYTE *)a1 = 0;
    return;
  }

  uint64_t v16 = a2->var0;
  id v63 = a2->var1;
  GetExecuteCommandsInBufferArgs((uint64_t)&v75, a3, (uint64_t)v16->var2);
  uint64_t v17 = GTMTLSMContext_getObject(*(void *)v16->var5, v75, *(void *)a3);
  GTMTLCreateIndirectCommandEncoder((uint64_t)__dst, v17[13]);
  if (*((void *)&v75 + 1) > a4 || v76 + *((void *)&v75 + 1) < a4 || !v77) {
    goto LABEL_21;
  }
  GTMTLReplayController_debugSubCommandResume( (unsigned int *)a2,  *(_DWORD *)a3 - LODWORD(v16->var9.var0.var0) + 1,  a4 + 1);
  if (!InstrumentRenderSubCommand((uint64_t)a2, (unint64_t *)a3, a4, __dst, a6, &v75, a5, a7))
  {
    FlushCommandQueue(a2);
LABEL_21:
    *(void *)(a1 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 24) = 0LL;
    *(_BYTE *)a1 = 0;
    goto LABEL_37;
  }

  RemapIndirectResources((uint64_t)&v66, (uint64_t)a6, v63, a7);
  PopulateResourceTrackingBufferV2( *(void **)(a5 + 240),  &v66,  v18,  v19,  v20,  v21,  v22,  v23,  (uint64_t)v54,  v57,  (uint64_t)v60,  (uint64_t)v63,  v66,  v67,  v68,  v69);
  FlushCommandQueue(a2);
  DecodeResourceTrackingBufferV2( (unint64_t *)&v71,  *(void **)(a5 + 240),  &v66,  v24,  v25,  v26,  v27,  v28,  (uint64_t)v55,  v58,  v61,  (uint64_t)v64,  v66,  v67,  v68,  v69);
  uint64_t v29 = v72;
  *(_BYTE *)a1 = 1;
  *(_OWORD *)(a1 + 8) = v71;
  *(void *)(a1 + 24) = v29;
LABEL_37:
}

void sub_13A38C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, id a12)
{
  _Unwind_Resume(a1);
}

void RemapIndirectResources(uint64_t a1, uint64_t a2, void *a3, apr_pool_t *a4)
{
  id v99 = a3;
  __int128 v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)id v100 = *(_OWORD *)a2;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v7;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = apr_hash_make(a4);
  *(void *)(a1 + 56) = apr_hash_make(a4);
  unsigned int v8 = apr_hash_make(a4);
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 64) = v8;
  if ((GT_SUPPORT_0 & 0x80000) == 0)
  {
    int v9 = *((_DWORD *)v100[0] + 3);
    if (v9 <= 0)
    {
      unint64_t v14 = v9;
    }

    else
    {
      uint64_t v10 = 0LL;
      for (uint64_t i = 0LL; i < v9; ++i)
      {
        uint64_t v12 = *((void *)v100[0] + 3);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v99 bufferForKey:*(void *)(v12 + v10 + 16)]);
        *(void *)(v12 + v10) = [v13 gpuAddress];

        int v9 = *((_DWORD *)v100[0] + 3);
        v10 += 24LL;
      }

      unint64_t v14 = v9;
    }

    uint64_t v15 = *((void *)v100[0] + 3);
    unint64_t v16 = v15 + 24LL * (int)v14;
    id v102 = (uint64_t (*)(__int128 *, __int128 *))CompareGTMTLGPUAddressResource;
    unint64_t v17 = 126 - 2 * __clz(v14);
    if (v9) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = 0LL;
    }
    std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*,false>( v15,  v16,  &v102,  v18,  1);
  }

  char v19 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 1) == 0)
  {
    uint64_t v20 = *(void *)(a2 + 8);
    id v21 = v99;
    uint64_t v22 = apr_hash_make(a4);
    *(void *)(v20 + 24) = 0LL;
    *(void *)(v20 + 32) = 0LL;
    *(void *)(v20 + 16) = v20;
    *(_DWORD *)(v20 + 40) = 0;
    for (uint64_t j = apr_hash_next((apr_hash_index_t *)(v20 + 16)); j; uint64_t j = apr_hash_next(j))
    {
      uint64_t v24 = *(void *)(*((void *)j + 1) + 32LL);
      uint64_t v25 = objc_claimAutoreleasedReturnValue([v21 resourceForKey:*(void *)(v24 + 8)]);
      uint64_t v26 = (void *)v25;
      if (v25 && (objc_opt_respondsToSelector(v25, "uniqueIdentifier") & 1) != 0)
      {
        id v27 = [v26 uniqueIdentifier];
        uint64_t v28 = apr_palloc(a4, 0x20uLL);
        uint64_t v29 = *(void *)(v24 + 8);
        void *v28 = v27;
        v28[1] = v29;
        apr_hash_set(v22, v28, 8LL, v28);
      }
    }

    *(void *)(a1 + 8) = v22;
    char v19 = g_enableIndexedResourceType;
  }

  if ((v19 & 2) == 0)
  {
    uint64_t v30 = *(void *)(a2 + 16);
    id v31 = v99;
    unint64_t v32 = apr_hash_make(a4);
    *(void *)(v30 + 24) = 0LL;
    *(void *)(v30 + 32) = 0LL;
    *(void *)(v30 + 16) = v30;
    *(_DWORD *)(v30 + 40) = 0;
    for (uint64_t k = apr_hash_next((apr_hash_index_t *)(v30 + 16)); k; uint64_t k = apr_hash_next(k))
    {
      uint64_t v34 = *(void *)(*((void *)k + 1) + 32LL);
      uint64_t v35 = objc_claimAutoreleasedReturnValue([v31 resourceForKey:*(void *)(v34 + 8)]);
      uint64_t v36 = (void *)v35;
      if (v35 && (objc_opt_respondsToSelector(v35, "uniqueIdentifier") & 1) != 0)
      {
        id v37 = [v36 uniqueIdentifier];
        uint64_t v38 = apr_palloc(a4, 0x20uLL);
        uint64_t v39 = *(void *)(v34 + 8);
        *uint64_t v38 = v37;
        v38[1] = v39;
        apr_hash_set(v32, v38, 8LL, v38);
      }
    }

    *(void *)(a1 + 16) = v32;
    char v19 = g_enableIndexedResourceType;
  }

  if ((v19 & 0x10) == 0)
  {
    uint64_t v40 = *(void *)(a2 + 24);
    id v41 = v99;
    uint64_t v42 = apr_hash_make(a4);
    *(void *)(v40 + 24) = 0LL;
    *(void *)(v40 + 32) = 0LL;
    *(void *)(v40 + 16) = v40;
    *(_DWORD *)(v40 + 40) = 0;
    for (uint64_t m = apr_hash_next((apr_hash_index_t *)(v40 + 16)); m; uint64_t m = apr_hash_next(m))
    {
      uint64_t v44 = *(void *)(*((void *)m + 1) + 32LL);
      uint64_t v45 = objc_claimAutoreleasedReturnValue([v41 resourceForKey:*(void *)(v44 + 8)]);
      uint64_t v46 = (void *)v45;
      if (v45 && (objc_opt_respondsToSelector(v45, "uniqueIdentifier") & 1) != 0)
      {
        id v47 = [v46 uniqueIdentifier];
        id v48 = apr_palloc(a4, 0x20uLL);
        uint64_t v49 = *(void *)(v44 + 8);
        void *v48 = v47;
        v48[1] = v49;
        apr_hash_set(v42, v48, 8LL, v48);
      }
    }

    *(void *)(a1 + 24) = v42;
    uint64_t v50 = *(void *)(a2 + 32);
    id v51 = v41;
    id v52 = apr_hash_make(a4);
    *(void *)(v50 + 24) = 0LL;
    *(void *)(v50 + 32) = 0LL;
    *(void *)(v50 + 16) = v50;
    *(_DWORD *)(v50 + 40) = 0;
    for (uint64_t n = apr_hash_next((apr_hash_index_t *)(v50 + 16)); n; uint64_t n = apr_hash_next(n))
    {
      uint64_t v54 = *(void *)(*((void *)n + 1) + 32LL);
      uint64_t v55 = objc_claimAutoreleasedReturnValue([v51 resourceForKey:*(void *)(v54 + 8)]);
      id v56 = (void *)v55;
      if (v55 && (objc_opt_respondsToSelector(v55, "uniqueIdentifier") & 1) != 0)
      {
        id v57 = [v56 uniqueIdentifier];
        uint64_t v58 = apr_palloc(a4, 0x20uLL);
        uint64_t v59 = *(void *)(v54 + 8);
        void *v58 = v57;
        v58[1] = v59;
        apr_hash_set(v52, v58, 8LL, v58);
      }
    }

    *(void *)(a1 + 32) = v52;
  }

  uint64_t v60 = *(void *)(a2 + 40);
  id v61 = v99;
  uint64_t v62 = apr_hash_make(a4);
  *(void *)(v60 + 24) = 0LL;
  *(void *)(v60 + 32) = 0LL;
  *(void *)(v60 + 16) = v60;
  *(_DWORD *)(v60 + 40) = 0;
  for (iuint64_t i = apr_hash_next((apr_hash_index_t *)(v60 + 16)); ii; iuint64_t i = apr_hash_next(ii))
  {
    uint64_t v64 = *(void *)(*((void *)ii + 1) + 32LL);
    uint64_t v65 = objc_claimAutoreleasedReturnValue([v61 resourceForKey:*(void *)(v64 + 8)]);
    __int128 v66 = (void *)v65;
    if (v65 && (objc_opt_respondsToSelector(v65, "uniqueIdentifier") & 1) != 0)
    {
      id v67 = [v66 uniqueIdentifier];
      __int128 v68 = apr_palloc(a4, 0x20uLL);
      uint64_t v69 = *(void *)(v64 + 8);
      *__int128 v68 = v67;
      v68[1] = v69;
      apr_hash_set(v62, v68, 8LL, v68);
    }
  }

  *(void *)(a1 + 40) = v62;
  uint64_t v70 = *(void *)(a2 + 48);
  id v71 = v61;
  uint64_t v72 = apr_hash_make(a4);
  *(void *)(v70 + 24) = 0LL;
  *(void *)(v70 + 32) = 0LL;
  *(void *)(v70 + 16) = v70;
  *(_DWORD *)(v70 + 40) = 0;
  for (juint64_t j = apr_hash_next((apr_hash_index_t *)(v70 + 16)); jj; juint64_t j = apr_hash_next(jj))
  {
    uint64_t v74 = *(void *)(*((void *)jj + 1) + 32LL);
    uint64_t v75 = objc_claimAutoreleasedReturnValue([v71 resourceForKey:*(void *)(v74 + 8)]);
    uint64_t v76 = (void *)v75;
    if (v75 && (objc_opt_respondsToSelector(v75, "uniqueIdentifier") & 1) != 0)
    {
      id v77 = [v76 uniqueIdentifier];
      uint64_t v78 = apr_palloc(a4, 0x20uLL);
      uint64_t v79 = *(void *)(v74 + 8);
      *uint64_t v78 = v77;
      v78[1] = v79;
      apr_hash_set(v72, v78, 8LL, v78);
    }
  }

  *(void *)(a1 + 48) = v72;
  uint64_t v80 = *(void *)(a2 + 56);
  id v81 = v71;
  id v82 = apr_hash_make(a4);
  *(void *)(v80 + 24) = 0LL;
  *(void *)(v80 + 32) = 0LL;
  *(void *)(v80 + 16) = v80;
  *(_DWORD *)(v80 + 40) = 0;
  for (kuint64_t k = apr_hash_next((apr_hash_index_t *)(v80 + 16)); kk; kuint64_t k = apr_hash_next(kk))
  {
    uint64_t v84 = *(void *)(*((void *)kk + 1) + 32LL);
    uint64_t v85 = objc_claimAutoreleasedReturnValue([v81 resourceForKey:*(void *)(v84 + 8)]);
    id v86 = (void *)v85;
    if (v85 && (objc_opt_respondsToSelector(v85, "uniqueIdentifier") & 1) != 0)
    {
      id v87 = [v86 uniqueIdentifier];
      uint64_t v88 = apr_palloc(a4, 0x20uLL);
      uint64_t v89 = *(void *)(v84 + 8);
      void *v88 = v87;
      v88[1] = v89;
      apr_hash_set(v82, v88, 8LL, v88);
    }
  }

  *(void *)(a1 + 56) = v82;
  uint64_t v90 = *(void *)(a2 + 64);
  id v101 = v81;
  id v91 = apr_hash_make(a4);
  *(void *)(v90 + 24) = 0LL;
  *(void *)(v90 + 32) = 0LL;
  *(void *)(v90 + 16) = v90;
  *(_DWORD *)(v90 + 40) = 0;
  for (muint64_t m = apr_hash_next((apr_hash_index_t *)(v90 + 16)); mm; muint64_t m = apr_hash_next(mm))
  {
    uint64_t v93 = *(void *)(*((void *)mm + 1) + 32LL);
    uint64_t v94 = objc_claimAutoreleasedReturnValue([v101 resourceForKey:*(void *)(v93 + 8)]);
    id v95 = (void *)v94;
    if (v94 && (objc_opt_respondsToSelector(v94, "uniqueIdentifier") & 1) != 0)
    {
      id v96 = [v95 uniqueIdentifier];
      id v97 = apr_palloc(a4, 0x20uLL);
      uint64_t v98 = *(void *)(v93 + 8);
      *id v97 = v96;
      v97[1] = v98;
      apr_hash_set(v91, v97, 8LL, v97);
    }
  }

  *(void *)(a1 + 64) = v91;
}

void sub_13AB38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, id a11)
{
}

void PopulateResourceTrackingBufferV2( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, __int128 a14, __int128 a15, __int128 a16)
{
  id v62 = a1;
  uint64_t v17 = 0LL;
  a15 = 0u;
  a16 = 0u;
  a13 = 0u;
  a14 = 0u;
  LOBYTE(a13) = 2;
  unint64_t v18 = *(int *)(*a2 + 12LL);
  int v19 = *(_DWORD *)(a2[1] + 48LL);
  HIDWORD(vars8) = v19;
  DWORD1(a13) = v18;
  HIDWORD(a13) = v19;
  do
  {
    v19 += *(_DWORD *)((char *)&vars8 + v17 + 8);
    *(_DWORD *)((char *)&a13 + v17 + 16) = v19;
    v17 += 4LL;
  }

  while (v17 != 32);
  if ((_DWORD)v18)
  {
    if ((v18 & 0x80000000) != 0) {
      abort();
    }
    uint64_t v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v18);
    uint64_t v22 = v20;
    uint64_t v23 = *a2;
    if (*(int *)(*a2 + 12LL) < 1)
    {
      uint64_t v26 = v20;
    }

    else
    {
      uint64_t v24 = 0LL;
      uint64_t v25 = &v20[24 * v21];
      uint64_t v26 = v20;
      do
      {
        id v27 = (uint64_t *)(*(void *)(v23 + 24) + 24 * v24);
        uint64_t v28 = *v27;
        uint64_t v29 = v27[1] + *v27;
        if (v26 >= v25)
        {
          unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v22) >> 3) + 1;
          if (v30 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556LL * ((v25 - v22) >> 3) > v30) {
            unint64_t v30 = 0x5555555555555556LL * ((v25 - v22) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v25 - v22) >> 3) >= 0x555555555555555LL) {
            unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v31 = v30;
          }
          if (v31) {
            unint64_t v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v31);
          }
          else {
            uint64_t v32 = 0LL;
          }
          id v33 = (void *)(v31 + 8 * ((v26 - v22) >> 3));
          void *v33 = v28;
          v33[1] = v29;
          void v33[2] = 0LL;
          if (v26 == v22)
          {
            uint64_t v36 = (char *)(v31 + 8 * ((v26 - v22) >> 3));
          }

          else
          {
            unint64_t v34 = v31 + 8 * ((v26 - v22) >> 3);
            do
            {
              __int128 v35 = *(_OWORD *)(v26 - 24);
              uint64_t v36 = (char *)(v34 - 24);
              *(void *)(v34 - 8) = *((void *)v26 - 1);
              *(_OWORD *)(v34 - 24) = v35;
              v26 -= 24;
              v34 -= 24LL;
            }

            while (v26 != v22);
          }

          uint64_t v25 = (char *)(v31 + 24 * v32);
          uint64_t v26 = (char *)(v33 + 3);
          if (v22) {
            operator delete(v22);
          }
          uint64_t v22 = v36;
        }

        else
        {
          *(void *)uint64_t v26 = v28;
          *((void *)v26 + 1) = v29;
          *((void *)v26 + 2) = 0LL;
          v26 += 24;
        }

        ++v24;
        uint64_t v23 = *a2;
      }

      while (v24 < *(int *)(*a2 + 12LL));
    }
  }

  else
  {
    uint64_t v22 = 0LL;
    uint64_t v26 = 0LL;
  }

  unint64_t v37 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v26 - v22) >> 3));
  if (v26 == v22) {
    uint64_t v38 = 0LL;
  }
  else {
    uint64_t v38 = v37;
  }
  std::__introsort<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *,false>( (uint64_t)v22,  (unint64_t)v26,  v38,  1);
  size_t v61 = v26 - v22;
  if (HIDWORD(a15))
  {
    uint64_t v39 = (__int128 *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(HIDWORD(a15));
    id v41 = &v39[v40];
  }

  else
  {
    uint64_t v39 = 0LL;
    id v41 = 0LL;
  }

  int v42 = 0;
  uint64_t v43 = v39;
  do
  {
    uint64_t v44 = IndirectResourcesByTypeIndex(a2, v42);
    if (v44)
    {
      uint64_t v45 = (apr_hash_index_t *)(v44 + 16);
      *(void *)(v44 + 24) = 0LL;
      *(void *)(v44 + 32) = 0LL;
      *(void *)(v44 + 16) = v44;
      uint64_t v46 = v43;
      *(_DWORD *)(v44 + 40) = 0;
LABEL_39:
      id v47 = v39;
      while (1)
      {
        id v48 = apr_hash_next(v45);
        if (!v48) {
          break;
        }
        uint64_t v45 = v48;
        uint64_t v49 = **(void **)(*((void *)v48 + 1) + 32LL);
        if (v46 >= v41)
        {
          uint64_t v50 = v46 - v47;
          unint64_t v51 = v50 + 1;
          else {
            unint64_t v52 = v51;
          }
          if (v52) {
            unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v52);
          }
          else {
            uint64_t v53 = 0LL;
          }
          uint64_t v54 = (void *)(v52 + 16 * v50);
          *uint64_t v54 = v49;
          v54[1] = 0LL;
          if (v46 == v47)
          {
            uint64_t v39 = (__int128 *)(v52 + 16 * v50);
          }

          else
          {
            unint64_t v55 = 0LL;
            do
            {
              *(_OWORD *)&v54[v55 / 8 - 2] = v46[v55 / 0x10 - 1];
              v55 -= 16LL;
            }

            while (&v46[v55 / 0x10] != v47);
            uint64_t v39 = (__int128 *)&v54[v55 / 8];
          }

          id v41 = (__int128 *)(v52 + 16 * v53);
          uint64_t v46 = (__int128 *)(v54 + 2);
          if (v47) {
            operator delete(v47);
          }
          goto LABEL_39;
        }

        *(void *)uint64_t v46 = v49;
        *((void *)v46++ + 1) = 0LL;
      }

      unint64_t v56 = 126 - 2 * __clz(v46 - v43);
      vars0 = (uint64_t (*)(__int128 *, __int128 *))CompareResourceTrackingTracingResourceEntryV2;
      if (v46 == v43) {
        uint64_t v57 = 0LL;
      }
      else {
        uint64_t v57 = v56;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*,false>( v43,  v46,  &vars0,  v57,  1);
      uint64_t v39 = v47;
      uint64_t v43 = v46;
    }

    ++v42;
  }

  while (v42 != 9);
  if ((unint64_t)[v62 length] >= (char *)v43 - (char *)v39 + v61 + 64)
  {
    uint64_t v58 = [v62 contents];
    __int128 v59 = a14;
    _OWORD *v58 = a13;
    v58[1] = v59;
    __int128 v60 = a16;
    v58[2] = a15;
    v58[3] = v60;
    memcpy(v58 + 4, v22, v61);
    memcpy((char *)v58 + v61 + 64, v39, (char *)v43 - (char *)v39);
  }

  if (v39) {
    operator delete(v39);
  }
  if (v22) {
    operator delete(v22);
  }
}

void sub_13B074( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  if (v19) {
    operator delete(v19);
  }
  if (v18) {
    operator delete(v18);
  }

  _Unwind_Resume(a1);
}

void DecodeResourceTrackingBufferV2( unint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, __int128 a14, __int128 a15, __int128 a16)
{
  id v17 = a2;
  if (IsTraceBufferValidV2(v17))
  {
    id v73 = v17;
    unint64_t v18 = [v17 contents];
    __int128 v19 = v18[1];
    a13 = *v18;
    a14 = v19;
    __int128 v20 = v18[3];
    a15 = v18[2];
    a16 = v20;
    unint64_t v21 = HIDWORD(a15);
    size_t v22 = 24LL * DWORD1(a13);
    if (DWORD1(a13))
    {
      uint64_t v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(DWORD1(a13));
      bzero(v23, 24 * ((v22 - 24) / 0x18) + 24);
      uint64_t v24 = &v23[24 * ((v22 - 24) / 0x18) + 24];
      __dst = v23;
    }

    else
    {
      __dst = 0LL;
      uint64_t v24 = 0LL;
    }

    size_t v25 = 16 * v21;
    if ((_DWORD)v21)
    {
      uint64_t v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v21);
      bzero(v26, v25);
      uint64_t v79 = &v26[v25];
    }

    else
    {
      uint64_t v26 = 0LL;
      uint64_t v79 = 0LL;
    }

    id v27 = (char *)(v18 + 4);
    memcpy(__dst, v27, v22);
    size_t v28 = v25;
    uint64_t v29 = __dst;
    memcpy(v26, &v27[v22], v28);
    a1[1] = 0LL;
    a1[2] = 0LL;
    *a1 = 0LL;
    uint64_t vars8 = a1;
    unint64_t v30 = 0LL;
    if (v24 != __dst)
    {
      uint64_t v31 = 0LL;
      else {
        uint64_t v32 = (v24 - __dst) / 24;
      }
      do
      {
        int v33 = v29[6 * v31 + 4];
        if (v33)
        {
          unint64_t v34 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*a3 + 24LL),  *(int *)(*a3 + 12LL),  *(void *)&v29[6 * v31]);
          if (v34)
          {
            uint64_t v35 = v34[2];
            unint64_t v36 = vars8[2];
            if ((unint64_t)v30 >= v36)
            {
              uint64_t v38 = (void *)*vars8;
              unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v30 - *vars8) >> 3);
              unint64_t v40 = v39 + 1;
              if (v39 + 1 > 0xAAAAAAAAAAAAAAALL) {
                abort();
              }
              unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - (void)v38) >> 3);
              if (2 * v41 > v40) {
                unint64_t v40 = 2 * v41;
              }
              if (v41 >= 0x555555555555555LL) {
                unint64_t v42 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v42 = v40;
              }
              if (v42) {
                unint64_t v42 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v42);
              }
              else {
                uint64_t v43 = 0LL;
              }
              unint64_t v44 = v42 + 24 * v39;
              *(void *)unint64_t v44 = v35;
              *(void *)(v44 + 8) = 60LL;
              *(_BYTE *)(v44 + 16) = v33;
              *(_DWORD *)(v44 + 17) = 0;
              *(_DWORD *)(v44 + 20) = 0;
              unint64_t v45 = v44;
              if (v30 == v38)
              {
                uint64_t v29 = __dst;
                id v47 = vars8;
              }

              else
              {
                uint64_t v29 = __dst;
                do
                {
                  __int128 v46 = *(_OWORD *)(v30 - 3);
                  *(void *)(v45 - 8) = *(v30 - 1);
                  *(_OWORD *)(v45 - 24) = v46;
                  v45 -= 24LL;
                  v30 -= 3;
                }

                while (v30 != v38);
                id v47 = vars8;
                unint64_t v30 = (void *)*vars8;
              }

              unint64_t v37 = (void *)(v44 + 24);
              unint64_t *v47 = v45;
              v47[1] = v44 + 24;
              v47[2] = v42 + 24 * v43;
              if (v30) {
                operator delete(v30);
              }
            }

            else
            {
              *unint64_t v30 = v35;
              v30[1] = 60LL;
              *((_BYTE *)v30 + 16) = v33;
              *(_DWORD *)((char *)v30 + 17) = 0;
              unint64_t v37 = v30 + 3;
              *((_DWORD *)v30 + 5) = 0;
              uint64_t v29 = __dst;
            }

            vars8[1] = (unint64_t)v37;
            unint64_t v30 = v37;
          }
        }

        ++v31;
      }

      while (v31 != v32);
    }

    uint64_t v48 = 0LL;
    uint64_t v49 = vars8;
    unint64_t v74 = (v79 - v26) >> 4;
    do
    {
      uint64_t v80 = ResourceKindByResourceTypeIndex[v48];
      uint64_t v50 = IndirectResourcesByTypeIndex(a3, v48);
      if (v50)
      {
        unint64_t v51 = *((unsigned int *)&a13 + v48++ + 2);
        uint64_t v78 = (unsigned int *)&a13 + v48 + 2;
        unint64_t v52 = *v78;
        if (v51 < v52)
        {
          uint64_t v53 = v50;
          if (v74 <= v51) {
            unint64_t v54 = v51;
          }
          else {
            unint64_t v54 = v74;
          }
          do
          {
            if (v51 == v54) {
              break;
            }
            unint64_t v55 = &v26[16 * v51];
            int v57 = *((_DWORD *)v55 + 2);
            unint64_t v56 = (int *)(v55 + 8);
            if (v57)
            {
              a12 = *(void *)&v26[16 * v51];
              uint64_t v58 = *find_entry(v53, &a12, 8uLL, 0LL);
              if (v58)
              {
                uint64_t v59 = *(void *)(v58 + 32);
                if (v59)
                {
                  uint64_t v60 = *(void *)(v59 + 8);
                  int v61 = *v56;
                  unint64_t v62 = v49[2];
                  if ((unint64_t)v30 >= v62)
                  {
                    uint64_t v64 = (void *)*v49;
                    unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v30 - *v49) >> 3);
                    unint64_t v66 = v65 + 1;
                    if (v65 + 1 > 0xAAAAAAAAAAAAAAALL) {
                      abort();
                    }
                    unint64_t v67 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - (void)v64) >> 3);
                    if (2 * v67 > v66) {
                      unint64_t v66 = 2 * v67;
                    }
                    if (v67 >= 0x555555555555555LL) {
                      unint64_t v68 = 0xAAAAAAAAAAAAAAALL;
                    }
                    else {
                      unint64_t v68 = v66;
                    }
                    if (v68) {
                      unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v68);
                    }
                    else {
                      uint64_t v69 = 0LL;
                    }
                    unint64_t v70 = v68 + 24 * v65;
                    *(void *)unint64_t v70 = v60;
                    *(void *)(v70 + 8) = v80;
                    *(_BYTE *)(v70 + 16) = v61;
                    *(_DWORD *)(v70 + 17) = 0;
                    *(_DWORD *)(v70 + 20) = 0;
                    unint64_t v71 = v70;
                    if (v30 == v64)
                    {
                      uint64_t v49 = vars8;
                    }

                    else
                    {
                      uint64_t v49 = vars8;
                      do
                      {
                        __int128 v72 = *(_OWORD *)(v30 - 3);
                        *(void *)(v71 - 8) = *(v30 - 1);
                        *(_OWORD *)(v71 - 24) = v72;
                        v71 -= 24LL;
                        v30 -= 3;
                      }

                      while (v30 != v64);
                      unint64_t v30 = (void *)*vars8;
                    }

                    id v63 = (void *)(v70 + 24);
                    *uint64_t v49 = v71;
                    v49[1] = v70 + 24;
                    uint64_t v49[2] = v68 + 24 * v69;
                    if (v30) {
                      operator delete(v30);
                    }
                  }

                  else
                  {
                    *unint64_t v30 = v60;
                    v30[1] = v80;
                    *((_BYTE *)v30 + 16) = v61;
                    *(_DWORD *)((char *)v30 + 17) = 0;
                    id v63 = v30 + 3;
                    *((_DWORD *)v30 + 5) = 0;
                  }

                  v49[1] = (unint64_t)v63;
                  unint64_t v52 = *v78;
                  unint64_t v30 = v63;
                }
              }
            }

            ++v51;
          }

          while (v51 < v52);
        }
      }

      else
      {
        ++v48;
      }
    }

    while (v48 != 9);
    if (v26) {
      operator delete(v26);
    }
    if (__dst) {
      operator delete(__dst);
    }
    id v17 = v73;
  }

  else
  {
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
}

void sub_13B5FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
}

BOOL IsTraceBufferValidV2(void *a1)
{
  id v1 = a1;
  unint64_t v2 = v1;
  if (v1 && ![v1 storageMode] && (unint64_t)objc_msgSend(v2, "length") >= 0x40)
  {
    id v5 = v2;
    unint64_t v6 = [v5 contents];
    unsigned int v7 = v6[1];
    uint64_t v8 = v6[11];
    BOOL v3 = (unint64_t)[v5 length] >= 16 * v8 + 24 * (unint64_t)v7 + 64;
  }

  else
  {
    BOOL v3 = 0LL;
  }

  return v3;
}

void sub_13B6FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IndirectResourcesByTypeIndex(void *a1, int a2)
{
  switch(a2)
  {
    case 0:
      uint64_t result = a1[1];
      break;
    case 1:
      uint64_t result = a1[2];
      break;
    case 2:
      uint64_t result = a1[6];
      break;
    case 3:
      uint64_t result = a1[7];
      break;
    case 4:
    case 5:
      uint64_t result = a1[8];
      break;
    case 6:
      uint64_t result = a1[3];
      break;
    case 7:
      uint64_t result = a1[4];
      break;
    case 8:
      uint64_t result = a1[5];
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *,false>( uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v8 = a2 - 24;
  unint64_t v9 = a1;
  while (2)
  {
    a1 = v9;
    uint64_t v10 = a2 - v9;
    uint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v9) >> 3);
    switch(v11)
    {
      case 0LL:
      case 1LL:
        return;
      case 2LL:
        if (*(void *)v8 < *(void *)v9)
        {
          uint64_t v107 = *(void *)(v9 + 16);
          __int128 v99 = *(_OWORD *)v9;
          __int128 v41 = *(_OWORD *)v8;
          *(void *)(v9 + 16) = *(void *)(a2 - 8);
          *(_OWORD *)unint64_t v9 = v41;
          *(void *)(a2 - 8) = v107;
          *(_OWORD *)unint64_t v8 = v99;
        }

        return;
      case 3LL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)v9,  (unint64_t *)(v9 + 24),  (unint64_t *)(a2 - 24));
        return;
      case 4LL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( v9,  (unint64_t *)(v9 + 24),  (unint64_t *)(v9 + 48),  a2 - 24);
        return;
      case 5LL:
        unint64_t v42 = (__int128 *)(v9 + 24);
        uint64_t v43 = (__int128 *)(v9 + 48);
        unint64_t v44 = (__int128 *)(v9 + 72);
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( v9,  (unint64_t *)(v9 + 24),  (unint64_t *)(v9 + 48),  v9 + 72);
        if (*(void *)v8 < *(void *)(v9 + 72))
        {
          __int128 v45 = *v44;
          uint64_t v46 = *(void *)(v9 + 88);
          uint64_t v47 = *(void *)(v8 + 16);
          __int128 *v44 = *(_OWORD *)v8;
          *(void *)(v9 + 88) = v47;
          *(void *)(v8 + 16) = v46;
          *(_OWORD *)unint64_t v8 = v45;
          if (*(void *)v44 < *(void *)v43)
          {
            uint64_t v48 = *(void *)(v9 + 64);
            __int128 v49 = *v43;
            __int128 *v43 = *v44;
            *(void *)(v9 + 64) = *(void *)(v9 + 88);
            __int128 *v44 = v49;
            *(void *)(v9 + 88) = v48;
            if (*(void *)v43 < *(void *)v42)
            {
              uint64_t v50 = *(void *)(v9 + 40);
              __int128 v51 = *v42;
              __int128 *v42 = *v43;
              *(void *)(v9 + 40) = *(void *)(v9 + 64);
              __int128 *v43 = v51;
              *(void *)(v9 + 64) = v50;
              if (*(void *)(v9 + 24) < *(void *)v9)
              {
                uint64_t v108 = *(void *)(v9 + 16);
                __int128 v100 = *(_OWORD *)v9;
                *(_OWORD *)unint64_t v9 = *v42;
                *(void *)(v9 + 16) = *(void *)(v9 + 40);
                __int128 *v42 = v100;
                *(void *)(v9 + 40) = v108;
              }
            }
          }
        }

        return;
      default:
        if (v10 <= 575)
        {
          unint64_t v52 = v9 + 24;
          BOOL v54 = v9 == a2 || v52 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v54)
            {
              uint64_t v55 = 0LL;
              unint64_t v56 = v9;
              do
              {
                unint64_t v57 = v52;
                unint64_t v58 = *(void *)(v56 + 24);
                if (v58 < *(void *)v56)
                {
                  __int128 v101 = *(_OWORD *)(v56 + 32);
                  uint64_t v59 = v55;
                  while (1)
                  {
                    uint64_t v60 = v9 + v59;
                    *(_OWORD *)(v60 + 24) = *(_OWORD *)(v9 + v59);
                    *(void *)(v60 + 40) = *(void *)(v9 + v59 + 16);
                    if (!v59) {
                      break;
                    }
                    v59 -= 24LL;
                    if (v58 >= *(void *)(v60 - 24))
                    {
                      uint64_t v61 = v9 + v59 + 24;
                      goto LABEL_75;
                    }
                  }

                  uint64_t v61 = v9;
LABEL_75:
                  *(void *)uint64_t v61 = v58;
                  *(_OWORD *)(v61 + 8) = v101;
                }

                unint64_t v52 = v57 + 24;
                v55 += 24LL;
                unint64_t v56 = v57;
              }

              while (v57 + 24 != a2);
            }
          }

          else if (!v54)
          {
            do
            {
              uint64_t v91 = v52;
              unint64_t v92 = *(void *)(a1 + 24);
              if (v92 < *(void *)a1)
              {
                __int128 v104 = *(_OWORD *)(a1 + 32);
                do
                {
                  *(_OWORD *)unint64_t v52 = *(_OWORD *)(v52 - 24);
                  *(void *)(v52 + 16) = *(void *)(v52 - 8);
                  unint64_t v93 = *(void *)(v52 - 48);
                  v52 -= 24LL;
                }

                while (v92 < v93);
                *(void *)unint64_t v52 = v92;
                *(_OWORD *)(v52 + 8) = v104;
              }

              unint64_t v52 = v91 + 24;
              a1 = v91;
            }

            while (v91 + 24 != a2);
          }

          return;
        }

        if (!a3)
        {
          if (v9 != a2)
          {
            int64_t v62 = (unint64_t)(v11 - 2) >> 1;
            int64_t v63 = v62;
            do
            {
              int64_t v64 = v63;
              if (v62 >= v63)
              {
                uint64_t v65 = (2 * v63) | 1;
                unint64_t v66 = (unint64_t *)(v9 + 24 * v65);
                if (2 * v64 + 2 >= v11)
                {
                  unint64_t v67 = *v66;
                }

                else
                {
                  unint64_t v67 = v66[3];
                  BOOL v68 = *v66 >= v67;
                  if (*v66 > v67) {
                    unint64_t v67 = *v66;
                  }
                  if (!v68)
                  {
                    v66 += 3;
                    uint64_t v65 = 2 * v64 + 2;
                  }
                }

                uint64_t v69 = (unint64_t *)(v9 + 24 * v64);
                unint64_t v70 = *v69;
                if (v67 >= *v69)
                {
                  __int128 v102 = *(_OWORD *)(v69 + 1);
                  do
                  {
                    unint64_t v71 = v69;
                    uint64_t v69 = v66;
                    __int128 v72 = *(_OWORD *)v66;
                    v71[2] = v66[2];
                    *(_OWORD *)unint64_t v71 = v72;
                    if (v62 < v65) {
                      break;
                    }
                    uint64_t v73 = (2 * v65) | 1;
                    unint64_t v66 = (unint64_t *)(v9 + 24 * v73);
                    uint64_t v65 = 2 * v65 + 2;
                    if (v65 >= v11)
                    {
                      unint64_t v74 = *v66;
                      uint64_t v65 = v73;
                    }

                    else
                    {
                      unint64_t v74 = *v66;
                      unint64_t v75 = v66[3];
                      if (*v66 <= v75) {
                        unint64_t v74 = v66[3];
                      }
                      if (*v66 >= v75) {
                        uint64_t v65 = v73;
                      }
                      else {
                        v66 += 3;
                      }
                    }
                  }

                  while (v74 >= v70);
                  unint64_t *v69 = v70;
                  *(_OWORD *)(v69 + 1) = v102;
                }
              }

              int64_t v63 = v64 - 1;
            }

            while (v64);
            int64_t v76 = v10 / 0x18uLL;
            do
            {
              uint64_t v77 = 0LL;
              uint64_t v109 = *(void *)(v9 + 16);
              __int128 v103 = *(_OWORD *)v9;
              unint64_t v78 = v9;
              do
              {
                uint64_t v79 = v78 + 24 * v77 + 24;
                uint64_t v80 = (2 * v77) | 1;
                uint64_t v81 = 2 * v77 + 2;
                if (v81 < v76 && *(void *)v79 < *(void *)(v79 + 24))
                {
                  v79 += 24LL;
                  uint64_t v80 = v81;
                }

                __int128 v82 = *(_OWORD *)v79;
                *(void *)(v78 + 16) = *(void *)(v79 + 16);
                *(_OWORD *)unint64_t v78 = v82;
                unint64_t v78 = v79;
                uint64_t v77 = v80;
              }

              while (v80 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
              a2 -= 24LL;
              if (v79 == a2)
              {
                *(void *)(v79 + 16) = v109;
                *(_OWORD *)uint64_t v79 = v103;
              }

              else
              {
                __int128 v83 = *(_OWORD *)a2;
                *(void *)(v79 + 16) = *(void *)(a2 + 16);
                *(_OWORD *)uint64_t v79 = v83;
                *(void *)(a2 + 16) = v109;
                *(_OWORD *)a2 = v103;
                uint64_t v84 = v79 - v9 + 24;
                if (v84 >= 25)
                {
                  unint64_t v85 = (v84 / 0x18uLL - 2) >> 1;
                  uint64_t v86 = v9 + 24 * v85;
                  unint64_t v87 = *(void *)v79;
                  if (*(void *)v86 < *(void *)v79)
                  {
                    __int128 v96 = *(_OWORD *)(v79 + 8);
                    do
                    {
                      uint64_t v88 = v79;
                      uint64_t v79 = v86;
                      __int128 v89 = *(_OWORD *)v86;
                      *(void *)(v88 + 16) = *(void *)(v86 + 16);
                      *(_OWORD *)uint64_t v88 = v89;
                      if (!v85) {
                        break;
                      }
                      unint64_t v85 = (v85 - 1) >> 1;
                      uint64_t v86 = v9 + 24 * v85;
                    }

                    while (*(void *)v86 < v87);
                    *(void *)uint64_t v79 = v87;
                    *(_OWORD *)(v79 + 8) = v96;
                  }
                }
              }
            }

            while (v76-- > 2);
          }

          return;
        }

        unint64_t v12 = (unint64_t)v11 >> 1;
        uint64_t v13 = (unint64_t *)(v9 + 24 * ((unint64_t)v11 >> 1));
        if ((unint64_t)v10 < 0xC01)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)(a1 + 24 * v12),  (unint64_t *)a1,  (unint64_t *)(a2 - 24));
        }

        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)a1,  (unint64_t *)(a1 + 24 * v12),  (unint64_t *)(a2 - 24));
          uint64_t v14 = 3 * v12;
          uint64_t v15 = (unint64_t *)(a1 + 24 * v12 - 24);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)(a1 + 24),  v15,  (unint64_t *)(a2 - 48));
          unint64_t v16 = (unint64_t *)(a1 + 24 + 8 * v14);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)(a1 + 48),  v16,  (unint64_t *)(a2 - 72));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)v15,  v13,  v16);
          unint64_t v105 = *(void *)(a1 + 16);
          __int128 v97 = *(_OWORD *)a1;
          unint64_t v17 = v13[2];
          *(_OWORD *)a1 = *(_OWORD *)v13;
          *(void *)(a1 + 16) = v17;
          v13[2] = v105;
          *(_OWORD *)uint64_t v13 = v97;
        }

        --a3;
        unint64_t v18 = *(void *)a1;
        if ((a4 & 1) == 0 && *(void *)(a1 - 24) >= v18)
        {
          __int128 v95 = *(_OWORD *)(a1 + 8);
          if (v18 >= *(void *)v8)
          {
            unint64_t v34 = a1 + 24;
            do
            {
              unint64_t v9 = v34;
              if (v34 >= a2) {
                break;
              }
              v34 += 24LL;
            }

            while (v18 >= *(void *)v9);
          }

          else
          {
            unint64_t v9 = a1;
            do
            {
              unint64_t v33 = *(void *)(v9 + 24);
              v9 += 24LL;
            }

            while (v18 >= v33);
          }

          unint64_t v35 = a2;
          if (v9 < a2)
          {
            unint64_t v35 = a2;
            do
            {
              unint64_t v36 = *(void *)(v35 - 24);
              v35 -= 24LL;
            }

            while (v18 < v36);
          }

          while (v9 < v35)
          {
            uint64_t v106 = *(void *)(v9 + 16);
            __int128 v98 = *(_OWORD *)v9;
            __int128 v37 = *(_OWORD *)v35;
            *(void *)(v9 + 16) = *(void *)(v35 + 16);
            *(_OWORD *)unint64_t v9 = v37;
            *(void *)(v35 + 16) = v106;
            *(_OWORD *)unint64_t v35 = v98;
            do
            {
              unint64_t v38 = *(void *)(v9 + 24);
              v9 += 24LL;
            }

            while (v18 >= v38);
            do
            {
              unint64_t v39 = *(void *)(v35 - 24);
              v35 -= 24LL;
            }

            while (v18 < v39);
          }

          if (v9 - 24 != a1)
          {
            __int128 v40 = *(_OWORD *)(v9 - 24);
            *(void *)(a1 + 16) = *(void *)(v9 - 8);
            *(_OWORD *)a1 = v40;
          }

          a4 = 0;
          *(void *)(v9 - 24) = v18;
          *(_OWORD *)(v9 - 16) = v95;
          continue;
        }

        __int128 v94 = *(_OWORD *)(a1 + 8);
        unint64_t v19 = a1;
        do
        {
          unint64_t v20 = v19;
          unint64_t v21 = *(void *)(v19 + 24);
          v19 += 24LL;
        }

        while (v21 < v18);
        unint64_t v22 = a2;
        if (v20 == a1)
        {
          unint64_t v22 = a2;
          do
          {
            if (v19 >= v22) {
              break;
            }
            unint64_t v24 = *(void *)(v22 - 24);
            v22 -= 24LL;
          }

          while (v24 >= v18);
        }

        else
        {
          do
          {
            unint64_t v23 = *(void *)(v22 - 24);
            v22 -= 24LL;
          }

          while (v23 >= v18);
        }

        unint64_t v9 = v19;
        if (v19 < v22)
        {
          unint64_t v25 = v22;
          do
          {
            __int128 v26 = *(_OWORD *)v9;
            uint64_t v27 = *(void *)(v9 + 16);
            uint64_t v28 = *(void *)(v25 + 16);
            *(_OWORD *)unint64_t v9 = *(_OWORD *)v25;
            *(void *)(v9 + 16) = v28;
            *(void *)(v25 + 16) = v27;
            *(_OWORD *)unint64_t v25 = v26;
            do
            {
              unint64_t v29 = *(void *)(v9 + 24);
              v9 += 24LL;
            }

            while (v29 < v18);
            do
            {
              unint64_t v30 = *(void *)(v25 - 24);
              v25 -= 24LL;
            }

            while (v30 >= v18);
          }

          while (v9 < v25);
        }

        if (v9 - 24 != a1)
        {
          __int128 v31 = *(_OWORD *)(v9 - 24);
          *(void *)(a1 + 16) = *(void *)(v9 - 8);
          *(_OWORD *)a1 = v31;
        }

        *(void *)(v9 - 24) = v18;
        *(_OWORD *)(v9 - 16) = v94;
        if (v19 < v22)
        {
LABEL_29:
          std::__introsort<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *,false>( a1,  v9 - 24,  a3,  a4 & 1);
          a4 = 0;
          continue;
        }

        BOOL v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( a1,  v9 - 24);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( v9,  a2))
        {
          if (v32) {
            continue;
          }
          goto LABEL_29;
        }

        a2 = v9 - 24;
        if (!v32) {
          goto LABEL_1;
        }
        return;
    }
  }

BOOL CompareResourceTrackingTracingResourceEntryV2(void *a1, void *a2)
{
  return *a1 < *a2;
}

double std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*,false>( __int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
LABEL_1:
  int64_t v62 = a2;
  int64_t v63 = a2 - 1;
  uint64_t v60 = a2 - 3;
  uint64_t v61 = a2 - 2;
  uint64_t v10 = a1;
  while (2)
  {
    a1 = v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    unint64_t v12 = a2 - v10;
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        if ((*a3)(v63, v10))
        {
          __int128 v66 = *v10;
          __int128 *v10 = *v63;
          double result = *(double *)&v66;
          __int128 *v63 = v66;
        }

        return result;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v10,  v10 + 1,  v63,  a3);
        return result;
      case 4uLL:
        *(void *)&double result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v10,  v10 + 1,  v10 + 2,  v63,  a3).n128_u64[0];
        return result;
      case 5uLL:
        *(void *)&double result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v10,  v10 + 1,  v10 + 2,  v10 + 3,  v63,  a3).n128_u64[0];
        return result;
      default:
        if (v11 <= 383)
        {
          __int128 v26 = v10 + 1;
          BOOL v28 = v10 == a2 || v26 == a2;
          if ((a5 & 1) != 0)
          {
            if (!v28)
            {
              uint64_t v29 = 0LL;
              unint64_t v30 = v10;
              do
              {
                __int128 v31 = v30;
                unint64_t v30 = v26;
                if ((*a3)(v26, v31))
                {
                  __int128 v66 = *v30;
                  uint64_t v32 = v29;
                  while (1)
                  {
                    *(__int128 *)((char *)v10 + v32 + 16) = *(__int128 *)((char *)v10 + v32);
                    if (!v32) {
                      break;
                    }
                    v32 -= 16LL;
                    if (((*a3)(&v66, (__int128 *)((char *)v10 + v32)) & 1) == 0)
                    {
                      unint64_t v33 = (__int128 *)((char *)v10 + v32 + 16);
                      goto LABEL_71;
                    }
                  }

                  unint64_t v33 = v10;
LABEL_71:
                  double result = *(double *)&v66;
                  __int128 *v33 = v66;
                  a2 = v62;
                }

                __int128 v26 = v30 + 1;
                v29 += 16LL;
              }

              while (v30 + 1 != a2);
            }
          }

          else if (!v28)
          {
            do
            {
              unint64_t v56 = a1;
              a1 = v26;
              if ((*a3)(v26, v56))
              {
                __int128 v66 = *a1;
                unint64_t v57 = a1;
                do
                {
                  unint64_t v58 = v57 - 1;
                  *unint64_t v57 = *(v57 - 1);
                  char v59 = (*a3)(&v66, v57 - 2);
                  unint64_t v57 = v58;
                }

                while ((v59 & 1) != 0);
                double result = *(double *)&v66;
                __int128 *v58 = v66;
              }

              __int128 v26 = a1 + 1;
            }

            while (a1 + 1 != a2);
          }

          return result;
        }

        if (!a4)
        {
          if (v10 != a2)
          {
            int64_t v34 = (v12 - 2) >> 1;
            int64_t v64 = v34;
            do
            {
              int64_t v35 = v34;
              if (v64 >= v34)
              {
                uint64_t v36 = (2 * v34) | 1;
                __int128 v37 = &a1[v36];
                if (2 * v34 + 2 < (uint64_t)v12 && (*a3)(&a1[v36], v37 + 1))
                {
                  ++v37;
                  uint64_t v36 = 2 * v35 + 2;
                }

                unint64_t v38 = &a1[v35];
                if (((*a3)(v37, v38) & 1) == 0)
                {
                  __int128 v66 = *v38;
                  do
                  {
                    unint64_t v39 = v37;
                    *unint64_t v38 = *v37;
                    if (v64 < v36) {
                      break;
                    }
                    uint64_t v40 = (2 * v36) | 1;
                    __int128 v37 = &a1[v40];
                    uint64_t v41 = 2 * v36 + 2;
                    if (v41 < (uint64_t)v12 && (*a3)(&a1[v40], v37 + 1))
                    {
                      ++v37;
                      uint64_t v40 = v41;
                    }

                    unint64_t v38 = v39;
                    uint64_t v36 = v40;
                  }

                  while (!(*a3)(v37, &v66));
                  *unint64_t v39 = v66;
                }
              }

              int64_t v34 = v35 - 1;
            }

            while (v35);
            uint64_t v42 = (unint64_t)v11 >> 4;
            uint64_t v43 = v62;
            do
            {
              unint64_t v44 = v43;
              uint64_t v45 = 0LL;
              __int128 v65 = *a1;
              uint64_t v46 = a1;
              do
              {
                uint64_t v47 = &v46[v45 + 1];
                uint64_t v48 = (2 * v45) | 1;
                uint64_t v49 = 2 * v45 + 2;
                if (v49 < v42 && (*a3)(&v46[v45 + 1], &v46[v45 + 2]))
                {
                  ++v47;
                  uint64_t v48 = v49;
                }

                __int128 *v46 = *v47;
                uint64_t v46 = v47;
                uint64_t v45 = v48;
              }

              while (v48 <= (uint64_t)((unint64_t)(v42 - 2) >> 1));
              uint64_t v50 = v44 - 1;
              if (v47 == v50)
              {
                uint64_t v43 = v50;
                double result = *(double *)&v65;
                __int128 *v47 = v65;
              }

              else
              {
                __int128 *v47 = *v50;
                double result = *(double *)&v65;
                uint64_t v43 = v50;
                __int128 *v50 = v65;
                uint64_t v51 = (char *)v47 - (char *)a1 + 16;
                if (v51 >= 17)
                {
                  unint64_t v52 = (unint64_t)((v51 >> 4) - 2) >> 1;
                  uint64_t v53 = &a1[v52];
                  if ((*a3)(v53, v47))
                  {
                    __int128 v66 = *v47;
                    do
                    {
                      BOOL v54 = v53;
                      __int128 *v47 = *v53;
                      if (!v52) {
                        break;
                      }
                      unint64_t v52 = (v52 - 1) >> 1;
                      uint64_t v53 = &a1[v52];
                      uint64_t v47 = v54;
                    }

                    while (((*a3)(v53, &v66) & 1) != 0);
                    double result = *(double *)&v66;
                    *BOOL v54 = v66;
                  }
                }
              }
            }

            while (v42-- > 2);
          }

          return result;
        }

        uint64_t v13 = &v10[v12 >> 1];
        if ((unint64_t)v11 < 0x801)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( &v10[v12 >> 1],  v10,  v63,  a3);
        }

        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v10,  &v10[v12 >> 1],  v63,  a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v10 + 1,  v13 - 1,  v61,  a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v10 + 2,  &v10[(v12 >> 1) + 1],  v60,  a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v13 - 1,  &v10[v12 >> 1],  &v10[(v12 >> 1) + 1],  a3);
          __int128 v66 = *v10;
          __int128 *v10 = *v13;
          *uint64_t v13 = v66;
        }

        --a4;
        a2 = v62;
        if ((a5 & 1) == 0 && ((*a3)(v10 - 1, v10) & 1) == 0)
        {
          __int128 v65 = *v10;
          if (((*a3)(&v65, v63) & 1) != 0)
          {
            do
              ++v10;
            while (((*a3)(&v65, v10) & 1) == 0);
          }

          else
          {
            unint64_t v22 = v10 + 1;
            do
            {
              uint64_t v10 = v22;
              if (v22 >= v62) {
                break;
              }
              int v23 = (*a3)(&v65, v22);
              unint64_t v22 = v10 + 1;
            }

            while (!v23);
          }

          unint64_t v24 = v62;
          if (v10 < v62)
          {
            unint64_t v24 = v62;
            do
              --v24;
            while (((*a3)(&v65, v24) & 1) != 0);
          }

          while (v10 < v24)
          {
            __int128 v66 = *v10;
            __int128 *v10 = *v24;
            __int128 *v24 = v66;
            do
              ++v10;
            while (!(*a3)(&v65, v10));
            do
              --v24;
            while (((*a3)(&v65, v24) & 1) != 0);
          }

          unint64_t v25 = v10 - 1;
          if (v10 - 1 != a1) {
            *a1 = *v25;
          }
          a5 = 0;
          double result = *(double *)&v65;
          __int128 *v25 = v65;
          continue;
        }

        __int128 v65 = *v10;
        uint64_t v14 = v10;
        do
          uint64_t v15 = v14++;
        while (((*a3)(v14, &v65) & 1) != 0);
        unint64_t v16 = v62;
        if (v15 == v10)
        {
          unint64_t v16 = v62;
          do
          {
            if (v14 >= v16) {
              break;
            }
            --v16;
          }

          while (((*a3)(v16, &v65) & 1) == 0);
        }

        else
        {
          do
            --v16;
          while (!(*a3)(v16, &v65));
        }

        if (v14 < v16)
        {
          unint64_t v17 = v14;
          unint64_t v18 = v16;
          do
          {
            __int128 v66 = *v17;
            __int128 v19 = v66;
            *unint64_t v17 = *v18;
            *unint64_t v18 = v19;
            do
              uint64_t v15 = v17++;
            while (((*a3)(v17, &v65) & 1) != 0);
            do
              --v18;
            while (!(*a3)(v18, &v65));
          }

          while (v17 < v18);
        }

        if (v15 != a1) {
          *a1 = *v15;
        }
        *uint64_t v15 = v65;
        if (v14 < v16)
        {
LABEL_29:
          std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*,false>( a1,  v15,  a3,  a4,  a5 & 1);
          a5 = 0;
          uint64_t v10 = v15 + 1;
          continue;
        }

        BOOL v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( a1,  v15,  a3);
        uint64_t v10 = v15 + 1;
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( v15 + 1,  v62,  a3))
        {
          if (v20) {
            continue;
          }
          goto LABEL_29;
        }

        a2 = v15;
        if (!v20) {
          goto LABEL_1;
        }
        return result;
    }
  }

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( __int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      __int128 v10 = *a1;
      *a1 = *a3;
    }

    else
    {
      __int128 v13 = *a1;
      *a1 = *a2;
      *a2 = v13;
      uint64_t result = (*a4)(a3, a2);
      if (!(_DWORD)result) {
        return result;
      }
      __int128 v10 = *a2;
      *a2 = *a3;
    }

    *a3 = v10;
  }

  else if ((_DWORD)result)
  {
    __int128 v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    uint64_t result = (*a4)(a2, a1);
    if ((_DWORD)result)
    {
      __int128 v12 = *a1;
      *a1 = *a2;
      *a2 = v12;
    }
  }

  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( __int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  if ((*a5)(a4, a3))
  {
    __int128 v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    if ((*a5)(a3, a2))
    {
      __int128 v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      if ((*a5)(a2, a1))
      {
        __n128 result = (__n128)*a1;
        *a1 = *a2;
        *a2 = (__int128)result;
      }
    }
  }

  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( __int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  __n128 v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( a1,  a2,  a3,  a4,  a6);
  if (((unsigned int (*)(__int128 *, __int128 *, __n128))*a6)(a5, a4, v12))
  {
    __int128 v14 = *a4;
    *a4 = *a5;
    *a5 = v14;
    if ((*a6)(a4, a3))
    {
      __int128 v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      if ((*a6)(a3, a2))
      {
        __int128 v16 = *a2;
        *a2 = *a3;
        *a3 = v16;
        if ((*a6)(a2, a1))
        {
          __n128 result = (__n128)*a1;
          *a1 = *a2;
          *a2 = (__int128)result;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( __int128 *a1, __int128 *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1LL;
  switch(v6)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      char v8 = a2 - 1;
      if ((*a3)(a2 - 1, a1))
      {
        __int128 v9 = *a1;
        *a1 = *v8;
        *char v8 = v9;
      }

      return 1LL;
    case 3LL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( a1,  a1 + 1,  a2 - 1,  a3);
      return 1LL;
    case 4LL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( a1,  a1 + 1,  a1 + 2,  a2 - 1,  a3);
      return 1LL;
    case 5LL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( a1,  a1 + 1,  a1 + 2,  a1 + 3,  a2 - 1,  a3);
      return 1LL;
    default:
      __int128 v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLReplayResourceTrackingTracingResourceEntryV2 const&,GTMTLReplayResourceTrackingTracingResourceEntryV2 const&),GTMTLReplayResourceTrackingTracingResourceEntryV2*>( a1,  a1 + 1,  a1 + 2,  a3);
      __int128 v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1LL;
      }
      uint64_t v12 = 0LL;
      int v13 = 0;
      break;
  }

  while (1)
  {
    if ((*a3)(v11, v10))
    {
      __int128 v17 = *v11;
      uint64_t v14 = v12;
      while (1)
      {
        __int128 v15 = (__int128 *)((char *)a1 + v14);
        *(__int128 *)((char *)a1 + v14 + 48) = *(__int128 *)((char *)a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        v14 -= 16LL;
        if (((*a3)(&v17, v15 + 1) & 1) == 0)
        {
          __int128 v16 = (__int128 *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }

      __int128 v16 = a1;
LABEL_12:
      *__int128 v16 = v17;
      if (++v13 == 8) {
        return v11 + 1 == a2;
      }
    }

    __int128 v10 = v11;
    v12 += 16LL;
    if (++v11 == a2) {
      return 1LL;
    }
  }

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( __int128 *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *a3;
  if (*a2 >= *(void *)result)
  {
    if (v4 < v3)
    {
      unint64_t v8 = a2[2];
      __int128 v9 = *(_OWORD *)a2;
      unint64_t v10 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v10;
      *(_OWORD *)a3 = v9;
      a3[2] = v8;
      if (*a2 < *(void *)result)
      {
        unint64_t v11 = *((void *)result + 2);
        __int128 v12 = *result;
        unint64_t v13 = a2[2];
        *BOOL result = *(_OWORD *)a2;
        *((void *)result + 2) = v13;
        *(_OWORD *)a2 = v12;
        a2[2] = v11;
      }
    }
  }

  else
  {
    if (v4 >= v3)
    {
      unint64_t v14 = *((void *)result + 2);
      __int128 v15 = *result;
      unint64_t v16 = a2[2];
      *BOOL result = *(_OWORD *)a2;
      *((void *)result + 2) = v16;
      *(_OWORD *)a2 = v15;
      a2[2] = v14;
      if (*a3 >= *a2) {
        return result;
      }
      unint64_t v5 = a2[2];
      __int128 v6 = *(_OWORD *)a2;
      unint64_t v17 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v17;
    }

    else
    {
      unint64_t v5 = *((void *)result + 2);
      __int128 v6 = *result;
      unint64_t v7 = a3[2];
      *BOOL result = *(_OWORD *)a3;
      *((void *)result + 2) = v7;
    }

    *(_OWORD *)a3 = v6;
    a3[2] = v5;
  }

  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  if (*(void *)a4 < *a3)
  {
    unint64_t v9 = a3[2];
    __n128 result = *(__n128 *)a3;
    unint64_t v10 = *(void *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v10;
    *(__n128 *)a4 = result;
    *(void *)(a4 + 16) = v9;
    if (*a3 < *a2)
    {
      unint64_t v11 = a2[2];
      __n128 result = *(__n128 *)a2;
      unint64_t v12 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v12;
      *(__n128 *)a3 = result;
      a3[2] = v11;
      if (*a2 < *(void *)a1)
      {
        unint64_t v13 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        unint64_t v14 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        a2[2] = v13;
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      __int128 v6 = (__int128 *)(a2 - 24);
      if (*(void *)(a2 - 24) < *(void *)a1)
      {
        uint64_t v7 = *(void *)(a1 + 16);
        __int128 v8 = *(_OWORD *)a1;
        uint64_t v9 = *(void *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(void *)(a1 + 16) = v9;
        *__int128 v6 = v8;
        *(void *)(a2 - 8) = v7;
      }

      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)a1,  (unint64_t *)(a1 + 24),  (unint64_t *)(a2 - 24));
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( a1,  (unint64_t *)(a1 + 24),  (unint64_t *)(a1 + 48),  a2 - 24);
      return 1LL;
    case 5uLL:
      unint64_t v18 = (__int128 *)(a1 + 24);
      __int128 v19 = (__int128 *)(a1 + 48);
      BOOL v20 = (__int128 *)(a1 + 72);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( a1,  (unint64_t *)(a1 + 24),  (unint64_t *)(a1 + 48),  a1 + 72);
      unint64_t v22 = *(void *)(a2 - 24);
      uint64_t v21 = a2 - 24;
      if (v22 < *(void *)(a1 + 72))
      {
        uint64_t v23 = *(void *)(a1 + 88);
        __int128 v24 = *v20;
        uint64_t v25 = *(void *)(v21 + 16);
        *BOOL v20 = *(_OWORD *)v21;
        *(void *)(a1 + 88) = v25;
        *(_OWORD *)uint64_t v21 = v24;
        *(void *)(v21 + 16) = v23;
        if (*(void *)v20 < *(void *)v19)
        {
          uint64_t v26 = *(void *)(a1 + 64);
          __int128 v27 = *v19;
          *__int128 v19 = *v20;
          *(void *)(a1 + 64) = *(void *)(a1 + 88);
          *BOOL v20 = v27;
          *(void *)(a1 + 88) = v26;
          if (*(void *)v19 < *(void *)v18)
          {
            uint64_t v28 = *(void *)(a1 + 40);
            __int128 v29 = *v18;
            *unint64_t v18 = *v19;
            *(void *)(a1 + 40) = *(void *)(a1 + 64);
            *__int128 v19 = v29;
            *(void *)(a1 + 64) = v28;
            if (*(void *)(a1 + 24) < *(void *)a1)
            {
              uint64_t v30 = *(void *)(a1 + 16);
              __int128 v31 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v18;
              *(void *)(a1 + 16) = *(void *)(a1 + 40);
              *unint64_t v18 = v31;
              *(void *)(a1 + 40) = v30;
            }
          }
        }
      }

      return 1LL;
    default:
      unint64_t v10 = (void *)(a1 + 48);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,PopulateResourceTrackingBufferV2(objc_object  {objcproto9MTLBuffer}*,GTMTLIndirectResources const&,apr_pool_t *)::$_0 &,GTMTLReplayResourceTrackingTracingBufferEntryV2 *>( (__int128 *)a1,  (unint64_t *)(a1 + 24),  (unint64_t *)(a1 + 48));
      uint64_t v11 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1LL;
      }
      uint64_t v12 = 0LL;
      int v13 = 0;
      break;
  }

  while (1)
  {
    unint64_t v14 = *(void *)v11;
    if (*(void *)v11 < *v10)
    {
      __int128 v32 = *(_OWORD *)(v11 + 8);
      uint64_t v15 = v12;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(void *)(v16 + 88) = *(void *)(a1 + v15 + 64);
        if (v15 == -48) {
          break;
        }
        v15 -= 24LL;
        if (v14 >= *(void *)(v16 + 24))
        {
          uint64_t v17 = a1 + v15 + 72;
          goto LABEL_13;
        }
      }

      uint64_t v17 = a1;
LABEL_13:
      *(void *)uint64_t v17 = v14;
      *(_OWORD *)(v17 + 8) = v32;
      if (++v13 == 8) {
        return v11 + 24 == a2;
      }
    }

    unint64_t v10 = (void *)v11;
    v12 += 24LL;
    v11 += 24LL;
    if (v11 == a2) {
      return 1LL;
    }
  }

BOOL CompareGTMTLGPUAddressResource(void *a1, void *a2)
{
  return *a1 < *a2;
}

double std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*,false>( uint64_t a1, unint64_t a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
LABEL_1:
  unint64_t v88 = a2;
  uint64_t v90 = a2 - 24;
  uint64_t v86 = (__int128 *)(a2 - 72);
  unint64_t v87 = (__int128 *)(a2 - 48);
  unint64_t v10 = a1;
  while (2)
  {
    a1 = v10;
    uint64_t v11 = a2 - v10;
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v10) >> 3);
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return *(double *)&v29;
      case 2uLL:
        if ((*a3)((__int128 *)v90, (__int128 *)v10))
        {
          __int128 v39 = *(_OWORD *)v10;
          uint64_t v95 = *(void *)(v10 + 16);
          __int128 v94 = v39;
          __int128 v40 = *(_OWORD *)v90;
          *(void *)(v10 + 16) = *(void *)(v90 + 16);
          *(_OWORD *)unint64_t v10 = v40;
          __int128 v29 = v94;
          *(void *)(v90 + 16) = v95;
          *(_OWORD *)uint64_t v90 = v29;
        }

        return *(double *)&v29;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)v10,  (__int128 *)(v10 + 24),  (__int128 *)v90,  a3);
        return *(double *)&v29;
      case 4uLL:
        *(void *)&__int128 v29 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( v10,  v10 + 24,  v10 + 48,  v90,  a3).n128_u64[0];
        return *(double *)&v29;
      case 5uLL:
        *(void *)&__int128 v29 = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__n128 *)v10,  v10 + 24,  v10 + 48,  v10 + 72,  v90,  a3).n128_u64[0];
        return *(double *)&v29;
      default:
        if (v11 <= 575)
        {
          uint64_t v41 = (__int128 *)(v10 + 24);
          BOOL v43 = v10 == a2 || v41 == (__int128 *)a2;
          if ((a5 & 1) != 0)
          {
            if (!v43)
            {
              uint64_t v44 = 0LL;
              unint64_t v45 = v10;
              do
              {
                uint64_t v46 = (__int128 *)v45;
                unint64_t v45 = (unint64_t)v41;
                if ((*a3)(v41, v46))
                {
                  __int128 v47 = *(_OWORD *)v45;
                  uint64_t v95 = *(void *)(v45 + 16);
                  __int128 v94 = v47;
                  uint64_t v48 = v44;
                  while (1)
                  {
                    uint64_t v49 = v10 + v48;
                    *(_OWORD *)(v49 + 24) = *(_OWORD *)(v10 + v48);
                    *(void *)(v49 + 40) = *(void *)(v10 + v48 + 16);
                    if (!v48) {
                      break;
                    }
                    v48 -= 24LL;
                    if (((*a3)(&v94, (__int128 *)(v48 + v10)) & 1) == 0)
                    {
                      uint64_t v50 = v10 + v48 + 24;
                      goto LABEL_71;
                    }
                  }

                  uint64_t v50 = v10;
LABEL_71:
                  __int128 v29 = v94;
                  *(void *)(v50 + 16) = v95;
                  *(_OWORD *)uint64_t v50 = v29;
                  a2 = v88;
                }

                uint64_t v41 = (__int128 *)(v45 + 24);
                v44 += 24LL;
              }

              while (v45 + 24 != a2);
            }
          }

          else if (!v43)
          {
            do
            {
              uint64_t v80 = (__int128 *)a1;
              a1 = (uint64_t)v41;
              if ((*a3)(v41, v80))
              {
                __int128 v81 = *(_OWORD *)a1;
                uint64_t v95 = *(void *)(a1 + 16);
                __int128 v94 = v81;
                uint64_t v82 = a1;
                do
                {
                  uint64_t v83 = v82 - 24;
                  *(_OWORD *)uint64_t v82 = *(_OWORD *)(v82 - 24);
                  *(void *)(v82 + 16) = *(void *)(v82 - 8);
                  char v84 = (*a3)(&v94, (__int128 *)(v82 - 48));
                  uint64_t v82 = v83;
                }

                while ((v84 & 1) != 0);
                __int128 v29 = v94;
                *(void *)(v83 + 16) = v95;
                *(_OWORD *)uint64_t v83 = v29;
              }

              uint64_t v41 = (__int128 *)(a1 + 24);
            }

            while (a1 + 24 != a2);
          }

          return *(double *)&v29;
        }

        if (!a4)
        {
          if (v10 != a2)
          {
            int64_t v51 = (v12 - 2) >> 1;
            int64_t v91 = v51;
            do
            {
              int64_t v52 = v51;
              if (v91 >= v51)
              {
                uint64_t v53 = (2 * v51) | 1;
                uint64_t v54 = a1 + 24 * v53;
                if (2 * v51 + 2 < (uint64_t)v12
                  && (*a3)((__int128 *)(a1 + 24 * v53), (__int128 *)(v54 + 24)))
                {
                  v54 += 24LL;
                  uint64_t v53 = 2 * v52 + 2;
                }

                uint64_t v55 = a1 + 24 * v52;
                if (((*a3)((__int128 *)v54, (__int128 *)v55) & 1) == 0)
                {
                  __int128 v56 = *(_OWORD *)v55;
                  uint64_t v95 = *(void *)(v55 + 16);
                  __int128 v94 = v56;
                  do
                  {
                    uint64_t v57 = v54;
                    __int128 v58 = *(_OWORD *)v54;
                    *(void *)(v55 + 16) = *(void *)(v54 + 16);
                    *(_OWORD *)uint64_t v55 = v58;
                    if (v91 < v53) {
                      break;
                    }
                    uint64_t v59 = (2 * v53) | 1;
                    uint64_t v54 = a1 + 24 * v59;
                    uint64_t v60 = 2 * v53 + 2;
                    if (v60 < (uint64_t)v12 && (*a3)((__int128 *)(a1 + 24 * v59), (__int128 *)(v54 + 24)))
                    {
                      v54 += 24LL;
                      uint64_t v59 = v60;
                    }

                    uint64_t v55 = v57;
                    uint64_t v53 = v59;
                  }

                  while (!(*a3)((__int128 *)v54, &v94));
                  __int128 v61 = v94;
                  *(void *)(v57 + 16) = v95;
                  *(_OWORD *)uint64_t v57 = v61;
                }
              }

              int64_t v51 = v52 - 1;
            }

            while (v52);
            int64_t v62 = v11 / 0x18uLL;
            unint64_t v63 = v88;
            do
            {
              unint64_t v89 = v63;
              uint64_t v64 = 0LL;
              __int128 v65 = *(_OWORD *)a1;
              uint64_t v93 = *(void *)(a1 + 16);
              __int128 v92 = v65;
              uint64_t v66 = a1;
              do
              {
                uint64_t v67 = v66 + 24 * v64 + 24;
                uint64_t v68 = (2 * v64) | 1;
                uint64_t v69 = 2 * v64 + 2;
                if (v69 < v62
                  && (*a3)((__int128 *)(v66 + 24 * v64 + 24), (__int128 *)(v66 + 24 * v64 + 48)))
                {
                  v67 += 24LL;
                  uint64_t v68 = v69;
                }

                __int128 v70 = *(_OWORD *)v67;
                *(void *)(v66 + 16) = *(void *)(v67 + 16);
                *(_OWORD *)uint64_t v66 = v70;
                uint64_t v66 = v67;
                uint64_t v64 = v68;
              }

              while (v68 <= (uint64_t)((unint64_t)(v62 - 2) >> 1));
              unint64_t v71 = (__int128 *)(v89 - 24);
              if (v67 == v89 - 24)
              {
                unint64_t v63 = v89 - 24;
                __int128 v29 = v92;
                *(void *)(v67 + 16) = v93;
                *(_OWORD *)uint64_t v67 = v29;
              }

              else
              {
                __int128 v72 = *v71;
                *(void *)(v67 + 16) = *(void *)(v89 - 8);
                *(_OWORD *)uint64_t v67 = v72;
                __int128 v29 = v92;
                *(void *)(v89 - 8) = v93;
                unint64_t v63 = v89 - 24;
                *unint64_t v71 = v29;
                uint64_t v73 = v67 - a1 + 24;
                if (v73 >= 25)
                {
                  unint64_t v74 = (unint64_t)(-2 - 0x5555555555555555LL * (v73 >> 3)) >> 1;
                  unint64_t v75 = a1 + 24 * v74;
                  if ((*a3)((__int128 *)v75, (__int128 *)v67))
                  {
                    __int128 v76 = *(_OWORD *)v67;
                    uint64_t v95 = *(void *)(v67 + 16);
                    __int128 v94 = v76;
                    do
                    {
                      uint64_t v77 = v75;
                      __int128 v78 = *(_OWORD *)v75;
                      *(void *)(v67 + 16) = *(void *)(v75 + 16);
                      *(_OWORD *)uint64_t v67 = v78;
                      if (!v74) {
                        break;
                      }
                      unint64_t v74 = (v74 - 1) >> 1;
                      unint64_t v75 = a1 + 24 * v74;
                      uint64_t v67 = v77;
                    }

                    while (((*a3)((__int128 *)v75, &v94) & 1) != 0);
                    __int128 v29 = v94;
                    *(void *)(v77 + 16) = v95;
                    *(_OWORD *)uint64_t v77 = v29;
                  }
                }
              }
            }

            while (v62-- > 2);
          }

          return *(double *)&v29;
        }

        unint64_t v13 = v10 + 24 * (v12 >> 1);
        if ((unint64_t)v11 < 0xC01)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)(v10 + 24 * (v12 >> 1)),  (__int128 *)v10,  (__int128 *)v90,  a3);
        }

        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)v10,  (__int128 *)(v10 + 24 * (v12 >> 1)),  (__int128 *)v90,  a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)(v10 + 24),  (__int128 *)(v10 + 24 * (v12 >> 1) - 24),  v87,  a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)(v10 + 48),  (__int128 *)(v10 + 24 + 24 * (v12 >> 1)),  v86,  a3);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)(v10 + 24 * (v12 >> 1) - 24),  (__int128 *)(v10 + 24 * (v12 >> 1)),  (__int128 *)(v10 + 24 + 24 * (v12 >> 1)),  a3);
          __int128 v14 = *(_OWORD *)v10;
          uint64_t v95 = *(void *)(v10 + 16);
          __int128 v94 = v14;
          uint64_t v15 = *(void *)(v13 + 16);
          *(_OWORD *)unint64_t v10 = *(_OWORD *)v13;
          *(void *)(v10 + 16) = v15;
          __int128 v16 = v94;
          *(void *)(v13 + 16) = v95;
          *(_OWORD *)unint64_t v13 = v16;
        }

        --a4;
        a2 = v88;
        if ((a5 & 1) == 0 && ((*a3)((__int128 *)(v10 - 24), (__int128 *)v10) & 1) == 0)
        {
          __int128 v30 = *(_OWORD *)v10;
          uint64_t v93 = *(void *)(v10 + 16);
          __int128 v92 = v30;
          if (((*a3)(&v92, (__int128 *)v90) & 1) != 0)
          {
            do
              v10 += 24LL;
            while (((*a3)(&v92, (__int128 *)v10) & 1) == 0);
          }

          else
          {
            __int128 v31 = (__int128 *)(v10 + 24);
            do
            {
              unint64_t v10 = (unint64_t)v31;
              int v32 = (*a3)(&v92, v31);
              __int128 v31 = (__int128 *)(v10 + 24);
            }

            while (!v32);
          }

          unint64_t v33 = v88;
          if (v10 < v88)
          {
            unint64_t v33 = v88;
            do
              v33 -= 24LL;
            while (((*a3)(&v92, (__int128 *)v33) & 1) != 0);
          }

          while (v10 < v33)
          {
            __int128 v34 = *(_OWORD *)v10;
            uint64_t v95 = *(void *)(v10 + 16);
            __int128 v94 = v34;
            __int128 v35 = *(_OWORD *)v33;
            *(void *)(v10 + 16) = *(void *)(v33 + 16);
            *(_OWORD *)unint64_t v10 = v35;
            __int128 v36 = v94;
            *(void *)(v33 + 16) = v95;
            *(_OWORD *)unint64_t v33 = v36;
            do
              v10 += 24LL;
            while (!(*a3)(&v92, (__int128 *)v10));
            do
              v33 -= 24LL;
            while (((*a3)(&v92, (__int128 *)v33) & 1) != 0);
          }

          __int128 v37 = (__int128 *)(v10 - 24);
          if (v10 - 24 != a1)
          {
            __int128 v38 = *v37;
            *(void *)(a1 + 16) = *(void *)(v10 - 8);
            *(_OWORD *)a1 = v38;
          }

          a5 = 0;
          __int128 v29 = v92;
          *(void *)(v10 - 8) = v93;
          __int128 *v37 = v29;
          continue;
        }

        __int128 v17 = *(_OWORD *)v10;
        uint64_t v93 = *(void *)(v10 + 16);
        __int128 v92 = v17;
        unint64_t v18 = (__int128 *)v10;
        do
        {
          uint64_t v19 = (uint64_t)v18;
          unint64_t v18 = (__int128 *)((char *)v18 + 24);
        }

        while (((*a3)(v18, &v92) & 1) != 0);
        BOOL v20 = (__int128 *)v88;
        if (v19 == v10)
        {
          BOOL v20 = (__int128 *)v88;
          do
          {
            if (v18 >= v20) {
              break;
            }
            BOOL v20 = (__int128 *)((char *)v20 - 24);
          }

          while (((*a3)(v20, &v92) & 1) == 0);
        }

        else
        {
          do
            BOOL v20 = (__int128 *)((char *)v20 - 24);
          while (!(*a3)(v20, &v92));
        }

        if (v18 < v20)
        {
          unint64_t v21 = (unint64_t)v18;
          unint64_t v22 = v20;
          do
          {
            __int128 v94 = *(_OWORD *)v21;
            __int128 v23 = v94;
            uint64_t v95 = *(void *)(v21 + 16);
            uint64_t v24 = v95;
            uint64_t v25 = *((void *)v22 + 2);
            *(_OWORD *)unint64_t v21 = *v22;
            *(void *)(v21 + 16) = v25;
            *((void *)v22 + 2) = v24;
            __int128 *v22 = v23;
            do
            {
              uint64_t v19 = v21;
              v21 += 24LL;
            }

            while (((*a3)((__int128 *)v21, &v92) & 1) != 0);
            do
              unint64_t v22 = (__int128 *)((char *)v22 - 24);
            while (!(*a3)(v22, &v92));
          }

          while (v21 < (unint64_t)v22);
        }

        if (v19 != a1)
        {
          __int128 v26 = *(_OWORD *)v19;
          *(void *)(a1 + 16) = *(void *)(v19 + 16);
          *(_OWORD *)a1 = v26;
        }

        __int128 v27 = v92;
        *(void *)(v19 + 16) = v93;
        *(_OWORD *)uint64_t v19 = v27;
        if (v18 < v20)
        {
LABEL_29:
          std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*,false>( a1,  v19,  a3,  a4,  a5 & 1);
          a5 = 0;
          unint64_t v10 = v19 + 24;
          continue;
        }

        BOOL v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( a1,  v19,  a3);
        unint64_t v10 = v19 + 24;
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( v19 + 24,  v88,  a3))
        {
          if (v28) {
            continue;
          }
          goto LABEL_29;
        }

        a2 = v19;
        if (!v28) {
          goto LABEL_1;
        }
        return *(double *)&v29;
    }
  }

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( __int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if ((v8 & 1) != 0)
  {
    if ((_DWORD)result)
    {
      uint64_t v10 = *((void *)a1 + 2);
      __int128 v11 = *a1;
      uint64_t v12 = *((void *)a3 + 2);
      *a1 = *a3;
      *((void *)a1 + 2) = v12;
    }

    else
    {
      uint64_t v19 = *((void *)a1 + 2);
      __int128 v20 = *a1;
      uint64_t v21 = *((void *)a2 + 2);
      *a1 = *a2;
      *((void *)a1 + 2) = v21;
      *a2 = v20;
      *((void *)a2 + 2) = v19;
      uint64_t result = (*a4)(a3, a2);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v10 = *((void *)a2 + 2);
      __int128 v11 = *a2;
      uint64_t v22 = *((void *)a3 + 2);
      *a2 = *a3;
      *((void *)a2 + 2) = v22;
    }

    *a3 = v11;
    *((void *)a3 + 2) = v10;
  }

  else if ((_DWORD)result)
  {
    uint64_t v13 = *((void *)a2 + 2);
    __int128 v14 = *a2;
    uint64_t v15 = *((void *)a3 + 2);
    *a2 = *a3;
    *((void *)a2 + 2) = v15;
    *a3 = v14;
    *((void *)a3 + 2) = v13;
    uint64_t result = (*a4)(a2, a1);
    if ((_DWORD)result)
    {
      uint64_t v16 = *((void *)a1 + 2);
      __int128 v17 = *a1;
      uint64_t v18 = *((void *)a2 + 2);
      *a1 = *a2;
      *((void *)a1 + 2) = v18;
      *a2 = v17;
      *((void *)a2 + 2) = v16;
    }
  }

  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  if ((*a5)((__int128 *)a4, (__int128 *)a3))
  {
    uint64_t v11 = *(void *)(a3 + 16);
    __int128 v12 = *(_OWORD *)a3;
    uint64_t v13 = *(void *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(void *)(a3 + 16) = v13;
    *(_OWORD *)a4 = v12;
    *(void *)(a4 + 16) = v11;
    if ((*a5)((__int128 *)a3, (__int128 *)a2))
    {
      uint64_t v14 = *(void *)(a2 + 16);
      __int128 v15 = *(_OWORD *)a2;
      uint64_t v16 = *(void *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = v16;
      *(_OWORD *)a3 = v15;
      *(void *)(a3 + 16) = v14;
      if ((*a5)((__int128 *)a2, (__int128 *)a1))
      {
        uint64_t v17 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v18 = *(void *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v18;
        *(__n128 *)a2 = result;
        *(void *)(a2 + 16) = v17;
      }
    }
  }

  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( __n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  __n128 v12 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (uint64_t)a1,  a2,  a3,  a4,  a6);
  if (((unsigned int (*)(uint64_t, uint64_t, __n128))*a6)(a5, a4, v12))
  {
    uint64_t v14 = *(void *)(a4 + 16);
    __int128 v15 = *(_OWORD *)a4;
    uint64_t v16 = *(void *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(void *)(a4 + 16) = v16;
    *(_OWORD *)a5 = v15;
    *(void *)(a5 + 16) = v14;
    if ((*a6)((__int128 *)a4, (__int128 *)a3))
    {
      uint64_t v17 = *(void *)(a3 + 16);
      __int128 v18 = *(_OWORD *)a3;
      uint64_t v19 = *(void *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(void *)(a3 + 16) = v19;
      *(_OWORD *)a4 = v18;
      *(void *)(a4 + 16) = v17;
      if ((*a6)((__int128 *)a3, (__int128 *)a2))
      {
        uint64_t v20 = *(void *)(a2 + 16);
        __n128 v21 = *(__n128 *)a2;
        uint64_t v22 = *(void *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(void *)(a2 + 16) = v22;
        *(__n128 *)a3 = v21;
        *(void *)(a3 + 16) = v20;
        if ((*a6)((__int128 *)a2, (__int128 *)a1))
        {
          unint64_t v23 = a1[1].n128_u64[0];
          __n128 result = *a1;
          unint64_t v24 = *(void *)(a2 + 16);
          *a1 = *(__n128 *)a2;
          a1[1].n128_u64[0] = v24;
          *(__n128 *)a2 = result;
          *(void *)(a2 + 16) = v23;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( uint64_t a1, uint64_t a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      char v8 = (__int128 *)(a2 - 24);
      if ((*a3)((__int128 *)(a2 - 24), (__int128 *)a1))
      {
        uint64_t v9 = *(void *)(a1 + 16);
        __int128 v10 = *(_OWORD *)a1;
        uint64_t v11 = *(void *)(a2 - 8);
        *(_OWORD *)a1 = *v8;
        *(void *)(a1 + 16) = v11;
        *char v8 = v10;
        *(void *)(a2 - 8) = v9;
      }

      return 1LL;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)a1,  (__int128 *)(a1 + 24),  (__int128 *)(a2 - 24),  a3);
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( a1,  a1 + 24,  a1 + 48,  a2 - 24,  a3);
      return 1LL;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__n128 *)a1,  a1 + 24,  a1 + 48,  a1 + 72,  a2 - 24,  a3);
      return 1LL;
    default:
      __n128 v12 = (__int128 *)(a1 + 48);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(GTMTLGPUAddressResource const&,GTMTLGPUAddressResource const&),GTMTLGPUAddressResource*>( (__int128 *)a1,  (__int128 *)(a1 + 24),  (__int128 *)(a1 + 48),  a3);
      uint64_t v13 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1LL;
      }
      uint64_t v14 = 0LL;
      int v15 = 0;
      break;
  }

  while (1)
  {
    if ((*a3)((__int128 *)v13, v12))
    {
      __int128 v19 = *(_OWORD *)v13;
      uint64_t v20 = *(void *)(v13 + 16);
      uint64_t v16 = v14;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(_OWORD *)(v17 + 72) = *(_OWORD *)(a1 + v16 + 48);
        *(void *)(v17 + 88) = *(void *)(a1 + v16 + 64);
        if (v16 == -48) {
          break;
        }
        v16 -= 24LL;
        if (((*a3)(&v19, (__int128 *)(v17 + 24)) & 1) == 0)
        {
          uint64_t v18 = a1 + v16 + 72;
          goto LABEL_12;
        }
      }

      uint64_t v18 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v18 = v19;
      *(void *)(v18 + 16) = v20;
      if (++v15 == 8) {
        return v13 + 24 == a2;
      }
    }

    __n128 v12 = (__int128 *)v13;
    v14 += 24LL;
    v13 += 24LL;
    if (v13 == a2) {
      return 1LL;
    }
  }

void SetupRegularVisibleFunctionTable(void *a1, uint64_t *a2, void *a3, uint64_t a4, unint64_t a5)
{
  id v14 = a1;
  id v9 = a3;
  if (*(void *)(a4 + 184))
  {
    unint64_t v10 = 0LL;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(a4 + 176) + 8 * v10);
      if (v11)
      {
        uint64_t Object = GTMTLSMContext_getObject(*a2, v11, a5);
        if (Object)
        {
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v9 functionHandleForKey:Object[1]]);
          [v14 setFunction:v13 atIndex:v10];
        }
      }

      else
      {
        [v14 setFunction:0 atIndex:v10];
      }

      ++v10;
    }

    while (*(void *)(a4 + 184) > v10);
  }
}

void sub_13DF80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void SetupRegularIntersectionFunctionTable( void *a1, void *a2, uint64_t *a3, void *a4, void *a5, uint64_t a6, unint64_t a7)
{
  id v26 = a1;
  id v13 = a2;
  if (a5[22])
  {
    uint64_t v14 = 0LL;
    unint64_t v15 = 0LL;
    do
    {
      uint64_t v16 = a5[21];
      int v17 = *(_DWORD *)(v16 + v14);
      switch(v17)
      {
        case 3:
          [v26 setOpaqueCurveIntersectionFunctionWithSignature:*(void *)(v16 + v14 + 8) atIndex:v15];
          break;
        case 2:
          [v26 setOpaqueTriangleIntersectionFunctionWithSignature:*(void *)(v16 + v14 + 8) atIndex:v15];
          break;
        case 1:
          uint64_t v18 = *(void *)(v16 + v14 + 8);
          if (v18)
          {
            uint64_t Object = GTMTLSMContext_getObject(*a3, v18, a7);
            if (Object && (Object[7] == a6 || Object[6] == a6))
            {
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v13 functionHandleForKey:Object[1]]);
              [v26 setFunction:v20 atIndex:v15];
            }
          }

          else
          {
            [v26 setFunction:0 atIndex:v15];
          }

          break;
      }

      ++v15;
      v14 += 16LL;
    }

    while (a5[22] > v15);
  }

  uint64_t v21 = 0LL;
  uint64_t v22 = a5 + 25;
  do
  {
    int v23 = *((_DWORD *)v22 - 4);
    if (v23 == 2)
    {
      uint64_t v25 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( a4,  *(v22 - 1));
      if (!v25) {
        goto LABEL_22;
      }
      id v24 = (id)v25[3];
      [v26 setVisibleFunctionTable:v24 atBufferIndex:v21];
    }

    else
    {
      if (v23 != 1) {
        goto LABEL_22;
      }
      id v24 = (id)objc_claimAutoreleasedReturnValue([v13 bufferForKey:*(v22 - 1)]);
      [v26 setBuffer:v24 offset:*v22 atIndex:v21];
    }

LABEL_22:
    ++v21;
    v22 += 3;
  }

  while (v21 != 31);
}

void sub_13E184( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t GTMTLReplayClient_generateFunctionResourceUsageInfoV2( unsigned int *a1, unint64_t a2, unint64_t a3, void *a4)
{
  *a4 = &__NSArray0__struct;
  uint64_t v4 = *(void *)(*(void *)a1 + 120LL);
  char v8 = (_DWORD *)(*(void *)(v4 + 24) + (a2 << 6));
  GTMTLReplayController_debugSubCommandResume(a1, *v8 - *(_DWORD *)(*(void *)a1 + 80LL) + 1, a3 + 1);
  return GTMTLReplayClient_generateFunctionResourceUsageInfoV2_impl((GTMTLReplayController *)a1, (uint64_t)v8, a3, a4);
}

uint64_t GTMTLReplayClient_generateFunctionResourceUsageInfoV2_impl( GTMTLReplayController *a1, uint64_t a2, unint64_t a3, void *a4)
{
  var0 = a1->var0;
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
  id v6 = [v5 argumentBuffersSupport];

  if (!v6) {
    return 0LL;
  }
  newpool = 0LL;
  apr_pool_create_ex(&newpool, 0LL, 0LL, v7);
  unint64_t v8 = *(void *)a2;
  id v9 = newpool;
  var5 = var0->var5;
  uint64_t v11 = apr_array_make(newpool, 32, 8);
  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 1), v8, v11);
  __n128 v12 = apr_array_make(v9, v11->nelts, 24);
  *(void *)&__int128 v247 = v12;
  int nelts = v11->nelts;
  uint64_t v14 = a1;
  if (nelts >= 1)
  {
    unint64_t v15 = v12;
    for (uint64_t i = 0LL; i < nelts; ++i)
    {
      uint64_t v17 = *(void *)&v11->elts[8 * i];
      unint64_t v18 = *(void *)(v17 + 16);
      unint64_t v19 = var0->var8.var0;
      if (v19 > v18 || var0->var8.var1 + v19 <= v18)
      {
        uint64_t v21 = (int8x16_t *)apr_array_push(v15);
        int8x16_t *v21 = vextq_s8(*(int8x16_t *)(v17 + 104), *(int8x16_t *)(v17 + 104), 8uLL);
        v21[1].i64[0] = *(void *)(v17 + 8);
        int nelts = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 2), v8, v11);
  uint64_t v22 = apr_array_make(v9, v11->nelts, 32);
  *((void *)&v247 + 1) = v22;
  int v23 = v11->nelts;
  if (v23 >= 1)
  {
    id v24 = v22;
    for (uint64_t j = 0LL; j < v23; ++j)
    {
      id v26 = *(void **)&v11->elts[8 * j];
      unint64_t v27 = v26[2];
      unint64_t v28 = var0->var8.var0;
      if (v28 > v27 || var0->var8.var1 + v28 <= v27)
      {
        __int128 v30 = apr_array_push(v24);
        v30[1] = v26[1];
        *__int128 v30 = v26[21];
        int v23 = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 3), v8, v11);
  __int128 v31 = apr_array_make(v9, v11->nelts, 32);
  *(void *)&__int128 v248 = v31;
  int v32 = v11->nelts;
  if (v32 >= 1)
  {
    unint64_t v33 = v31;
    for (uint64_t k = 0LL; k < v32; ++k)
    {
      __int128 v35 = *(void **)&v11->elts[8 * k];
      unint64_t v36 = v35[2];
      unint64_t v37 = var0->var8.var0;
      if (v37 > v36 || var0->var8.var1 + v37 <= v36)
      {
        uint64_t v39 = v35[6];
        if (!v39 || *(_BYTE *)(v39 + 62))
        {
          __int128 v40 = apr_array_push(v33);
          v40[1] = v35[1];
          *__int128 v40 = v35[8];
          int v32 = v11->nelts;
        }
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 4), v8, v11);
  uint64_t v41 = apr_array_make(v9, v11->nelts, 32);
  *((void *)&v248 + 1) = v41;
  int v42 = v11->nelts;
  if (v42 >= 1)
  {
    BOOL v43 = v41;
    for (uint64_t m = 0LL; m < v42; ++m)
    {
      unint64_t v45 = *(void **)&v11->elts[8 * m];
      unint64_t v46 = v45[2];
      unint64_t v47 = var0->var8.var0;
      BOOL v48 = v47 <= v46 && var0->var8.var1 + v47 > v46;
      if (!v48 && GTMTLSMPipelineState_supportsIndirectCommandBuffers(*(void *)&v11->elts[8 * m]))
      {
        uint64_t v49 = apr_array_push(v43);
        v49[1] = v45[1];
        *uint64_t v49 = v45[12];
        int v42 = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 5), v8, v11);
  uint64_t v50 = apr_array_make(v9, v11->nelts, 32);
  uint64_t v249 = v50;
  int v51 = v11->nelts;
  if (v51 >= 1)
  {
    int64_t v52 = v50;
    for (uint64_t n = 0LL; n < v51; ++n)
    {
      uint64_t v54 = *(void **)&v11->elts[8 * n];
      unint64_t v55 = v54[2];
      unint64_t v56 = var0->var8.var0;
      BOOL v57 = v56 <= v55 && var0->var8.var1 + v56 > v55;
      if (!v57 && GTMTLSMPipelineState_supportsIndirectCommandBuffers(*(void *)&v11->elts[8 * n]))
      {
        __int128 v58 = apr_array_push(v52);
        v58[1] = v54[1];
        void *v58 = v54[12];
        int v51 = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 6), v8, v11);
  uint64_t v59 = apr_array_make(v9, v11->nelts, 32);
  *(void *)&__int128 v250 = v59;
  int v60 = v11->nelts;
  uint64_t v61 = a2;
  if (v60 >= 1)
  {
    int64_t v62 = v59;
    for (iuint64_t i = 0LL; ii < v60; ++ii)
    {
      uint64_t v64 = *(void **)&v11->elts[8 * ii];
      unint64_t v65 = v64[2];
      unint64_t v66 = var0->var8.var0;
      if (v66 > v65 || var0->var8.var1 + v66 <= v65)
      {
        uint64_t v68 = apr_array_push(v62);
        v68[1] = v64[1];
        *uint64_t v68 = v64[15];
        int v60 = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 7), v8, v11);
  uint64_t v69 = apr_array_make(v9, v11->nelts, 32);
  *((void *)&v250 + 1) = v69;
  int v70 = v11->nelts;
  if (v70 >= 1)
  {
    unint64_t v71 = v69;
    for (juint64_t j = 0LL; jj < v70; ++jj)
    {
      uint64_t v73 = *(void **)&v11->elts[8 * jj];
      unint64_t v74 = v73[2];
      unint64_t v75 = var0->var8.var0;
      if (v75 > v74 || var0->var8.var1 + v75 <= v74)
      {
        uint64_t v77 = apr_array_push(v71);
        v77[1] = v73[1];
        *uint64_t v77 = v73[17];
        int v70 = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 8), v8, v11);
  __int128 v78 = apr_array_make(v9, v11->nelts, 32);
  *(void *)&__int128 v251 = v78;
  int v79 = v11->nelts;
  if (v79 >= 1)
  {
    uint64_t v80 = v78;
    for (kuint64_t k = 0LL; kk < v79; ++kk)
    {
      uint64_t v82 = *(void **)&v11->elts[8 * kk];
      unint64_t v83 = v82[2];
      unint64_t v84 = var0->var8.var0;
      if (v84 > v83 || var0->var8.var1 + v84 <= v83)
      {
        uint64_t v86 = apr_array_push(v80);
        v86[1] = v82[1];
        *uint64_t v86 = v82[18];
        int v79 = v11->nelts;
      }
    }
  }

  v11->int nelts = 0;
  GTMTLSMContext_getObjects(*((_DWORD **)var5 + 9), v8, v11);
  unint64_t v87 = apr_array_make(v9, v11->nelts, 32);
  *((void *)&v251 + 1) = v87;
  int v88 = v11->nelts;
  if (v88 >= 1)
  {
    unint64_t v89 = v87;
    for (muint64_t m = 0LL; mm < v88; ++mm)
    {
      int64_t v91 = *(void **)&v11->elts[8 * mm];
      unint64_t v92 = v91[2];
      unint64_t v93 = var0->var8.var0;
      if (v93 > v92 || var0->var8.var1 + v93 <= v92)
      {
        uint64_t v95 = apr_array_push(v89);
        v95[1] = v91[1];
        *uint64_t v95 = v91[16];
        int v88 = v11->nelts;
      }
    }
  }

  GTMTLIndirectResources_optimizeByKey(v233, (uint64_t *)&v247, 0, v9);
  __int128 v96 = objc_autoreleasePoolPush();
  int v97 = *(_DWORD *)(a2 + 8);
  id context = v96;
  if (IsFuncEnumDrawCall(v97))
  {
    __int128 v98 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
    id v99 = ObtainResourceTrackingTracingBufferV2(v98, v233);
    int v200 = (void *)objc_claimAutoreleasedReturnValue(v99);

    int v100 = *(_DWORD *)(a2 + 8);
    if ((v100 + 15416) > 2)
    {
      __int128 v248 = 0u;
      __int128 v247 = 0u;
      __int128 v250 = 0u;
      __int128 v251 = 0u;
      LODWORD(v249) = 1065353216;
      int v252 = 1065353216;
      __int128 v230 = 0u;
      __int128 v231 = 0u;
      uint64_t v235 = 1LL;
      int v232 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
      __int128 v227 = 0u;
      __int128 v228 = 0u;
      int v229 = 1065353216;
      uint64_t v239 = 2LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
      __int128 v224 = 0u;
      __int128 v225 = 0u;
      int v226 = 1065353216;
      uint64_t v241 = 4LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
      __int128 v221 = 0u;
      __int128 v222 = 0u;
      int v223 = 1065353216;
      uint64_t v243 = 16LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
      __int128 v218 = 0u;
      __int128 v219 = 0u;
      int v220 = 1065353216;
      uint64_t v245 = 8LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
      for (nuint64_t n = 200LL; nn != -40; nn -= 48LL)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + nn);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
      __int128 v254 = 0u;
      __int128 v255 = 0u;
      int v256 = 1065353216;
      __int128 v257 = 0u;
      __int128 v258 = 0u;
      __int128 v260 = 0u;
      __int128 v261 = 0u;
      int v259 = 1065353216;
      int v262 = 1065353216;
      id v263 = v200;
      uint64_t v264 = 2LL;
      uint64_t v265 = 1LL;
      id v111 = newpool;
      InstrumentFunctionWithResourceTrackingV2((uint64_t)&v235, a1, a2, (uint64_t)&v247, (uint64_t)v233, newpool);
      int v199 = v235;
      int v112 = v236;
      __int128 v113 = v237;

      char v197 = v112;
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
      std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v247);
      __int128 v114 = 0LL;
      std::string __p = 0LL;
      uint64_t v107 = 0LL;
      __int128 v198 = 0LL;
    }

    else
    {
      __int128 v101 = a1->var0;
      if (IsFuncEnumDrawCall(v100)
        && a1->var21.var0.var0 == 70
        && (uint64_t Object = GTMTLSMContext_getObject(*(void *)v101->var5, a1->var21.var3.var0.var23, *(void *)a2)) != 0LL
        && (uint64_t v103 = Object[9]) != 0
        && *(void *)(v103 + 368))
      {
        __int128 v248 = 0u;
        __int128 v247 = 0u;
        __int128 v250 = 0u;
        __int128 v251 = 0u;
        LODWORD(v249) = 1065353216;
        int v252 = 1065353216;
        __int128 v230 = 0u;
        __int128 v231 = 0u;
        uint64_t v235 = 1LL;
        int v232 = 1065353216;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
        __int128 v227 = 0u;
        __int128 v228 = 0u;
        int v229 = 1065353216;
        uint64_t v239 = 2LL;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
        __int128 v224 = 0u;
        __int128 v225 = 0u;
        int v226 = 1065353216;
        uint64_t v241 = 4LL;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
        __int128 v221 = 0u;
        __int128 v222 = 0u;
        int v223 = 1065353216;
        uint64_t v243 = 16LL;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
        __int128 v218 = 0u;
        __int128 v219 = 0u;
        int v220 = 1065353216;
        uint64_t v245 = 8LL;
        std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
        std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
        for (uint64_t i1 = 200LL; i1 != -40; i1 -= 48LL)
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i1);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
        __int128 v254 = 0u;
        __int128 v255 = 0u;
        int v256 = 1065353216;
        __int128 v257 = 0u;
        __int128 v258 = 0u;
        __int128 v260 = 0u;
        __int128 v261 = 0u;
        int v259 = 1065353216;
        int v262 = 1065353216;
        id v263 = v200;
        uint64_t v264 = 2LL;
        uint64_t v265 = 0x10000000010LL;
        InstrumentFunctionWithResourceTrackingV2((uint64_t)&v235, a1, a2, (uint64_t)&v247, (uint64_t)v233, newpool);
        BOOL v105 = (_BYTE)v235 != 0;
        uint64_t v106 = v236;
        uint64_t v107 = v237;

        __int128 v198 = v106;
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
        std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
        std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
        std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
        std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v247);
        uint64_t v14 = a1;
        uint64_t v61 = a2;
      }

      else
      {
        uint64_t v107 = 0LL;
        __int128 v198 = 0LL;
        BOOL v105 = 1;
      }

      __int128 v248 = 0u;
      __int128 v247 = 0u;
      __int128 v250 = 0u;
      __int128 v251 = 0u;
      LODWORD(v249) = 1065353216;
      int v252 = 1065353216;
      __int128 v230 = 0u;
      __int128 v231 = 0u;
      uint64_t v235 = 1LL;
      int v232 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
      __int128 v227 = 0u;
      __int128 v228 = 0u;
      int v229 = 1065353216;
      uint64_t v239 = 2LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
      __int128 v224 = 0u;
      __int128 v225 = 0u;
      int v226 = 1065353216;
      uint64_t v241 = 4LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
      __int128 v221 = 0u;
      __int128 v222 = 0u;
      int v223 = 1065353216;
      uint64_t v243 = 16LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
      __int128 v218 = 0u;
      __int128 v219 = 0u;
      int v220 = 1065353216;
      uint64_t v245 = 8LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
      for (uint64_t i2 = 200LL; i2 != -40; i2 -= 48LL)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i2);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
      __int128 v254 = 0u;
      __int128 v255 = 0u;
      int v256 = 1065353216;
      __int128 v257 = 0u;
      __int128 v258 = 0u;
      __int128 v260 = 0u;
      __int128 v261 = 0u;
      int v259 = 1065353216;
      int v262 = 1065353216;
      id v263 = v200;
      uint64_t v264 = 2LL;
      uint64_t v265 = 0x10000000020LL;
      id v111 = newpool;
      InstrumentFunctionWithResourceTrackingV2((uint64_t)&v235, v14, v61, (uint64_t)&v247, (uint64_t)v233, newpool);
      if ((_BYTE)v235) {
        BOOL v116 = v105;
      }
      else {
        BOOL v116 = 0;
      }
      int v199 = v116;
      std::string __p = v236;
      __int128 v114 = v237;

      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
      std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v247);
      __int128 v113 = 0LL;
      char v197 = 0LL;
    }

    uint64_t v117 = (uint64_t)a1;
    if (ShouldInstrumentFragmentStage((uint64_t *)a1, (uint64_t)v233, a2, a3))
    {
      __int128 v248 = 0u;
      __int128 v247 = 0u;
      __int128 v250 = 0u;
      __int128 v251 = 0u;
      LODWORD(v249) = 1065353216;
      int v252 = 1065353216;
      __int128 v230 = 0u;
      __int128 v231 = 0u;
      uint64_t v235 = 1LL;
      int v232 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
      __int128 v227 = 0u;
      __int128 v228 = 0u;
      int v229 = 1065353216;
      uint64_t v239 = 2LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
      __int128 v224 = 0u;
      __int128 v225 = 0u;
      int v226 = 1065353216;
      uint64_t v241 = 4LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
      __int128 v221 = 0u;
      __int128 v222 = 0u;
      int v223 = 1065353216;
      uint64_t v243 = 16LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
      __int128 v218 = 0u;
      __int128 v219 = 0u;
      int v220 = 1065353216;
      uint64_t v245 = 8LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
      for (uint64_t i3 = 200LL; i3 != -40; i3 -= 48LL)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i3);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
      __int128 v254 = 0u;
      __int128 v255 = 0u;
      int v256 = 1065353216;
      __int128 v257 = 0u;
      __int128 v258 = 0u;
      __int128 v260 = 0u;
      __int128 v261 = 0u;
      int v259 = 1065353216;
      int v262 = 1065353216;
      id v263 = v200;
      uint64_t v264 = 2LL;
      LODWORD(v265) = 2;
      BYTE4(v265) = 0;
      BYTE5(v265) = (*(_DWORD *)(a2 + 8) + 15416) < 3;
      HIWORD(v265) = 0;
      id v111 = newpool;
      InstrumentFunctionWithResourceTrackingV2((uint64_t)&v235, a1, a2, (uint64_t)&v247, (uint64_t)v233, newpool);
      if (v199) {
        BOOL v119 = v235 == 0;
      }
      else {
        BOOL v119 = 1;
      }
      char v120 = !v119;
      LOBYTE(v199) = v120;
      uint64_t v121 = v236;
      uint64_t v122 = v237;

      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
      std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v247);
      uint64_t v117 = (uint64_t)a1;
    }

    else
    {
      uint64_t v122 = 0LL;
      uint64_t v121 = 0LL;
    }

    ReplaceFunctionTablesWithRegular((uint64_t)v216, v117, 3, *(void *)a2, v233, v111);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v217);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v216);
    uint64_t v123 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  0xAAAAAAAAAAAAAAABLL * ((v114 - __p) >> 3)
           - 0x5555555555555555LL * ((v107 - v198) >> 3)
           - 0x5555555555555555LL * ((v113 - v197) >> 3)
           - 0x5555555555555555LL * ((v122 - v121) >> 3));
    if (v198 != v107)
    {
      int v124 = v198;
      do
      {
        __int128 v125 = *(_OWORD *)v124;
        *(void *)&__int128 v248 = v124[2];
        __int128 v247 = v125;
        ResourceUsageIteuint64_t m = MakeResourceUsageItem((uint64_t)&v247, 8LL);
        int v127 = (void *)objc_claimAutoreleasedReturnValue(ResourceUsageItem);
        -[NSMutableArray addObject:](v123, "addObject:", v127);

        v124 += 3;
      }

      while (v124 != (void *)v107);
    }

    if (__p != v114)
    {
      int v128 = __p;
      do
      {
        __int128 v247 = *(_OWORD *)v128;
        *(void *)&__int128 v248 = v128[2];
        __int16 v129 = MakeResourceUsageItem((uint64_t)&v247, 16LL);
        char v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
        -[NSMutableArray addObject:](v123, "addObject:", v130);

        v128 += 3;
      }

      while (v128 != (void *)v114);
    }

    if (v197 != v113)
    {
      uint64_t v131 = v197;
      do
      {
        __int128 v247 = *(_OWORD *)v131;
        *(void *)&__int128 v248 = v131[2];
        uint64_t v132 = MakeResourceUsageItem((uint64_t)&v247, 1LL);
        __int128 v133 = (void *)objc_claimAutoreleasedReturnValue(v132);
        -[NSMutableArray addObject:](v123, "addObject:", v133);

        v131 += 3;
      }

      while (v131 != (void *)v113);
    }

    if (v121 != v122)
    {
      unsigned int v134 = v121;
      do
      {
        __int128 v247 = *(_OWORD *)v134;
        *(void *)&__int128 v248 = v134[2];
        unint64_t v135 = MakeResourceUsageItem((uint64_t)&v247, 2LL);
        uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
        -[NSMutableArray addObject:](v123, "addObject:", v136);

        v134 += 3;
      }

      while (v134 != (void *)v122);
    }

    if (__p) {
      operator delete(__p);
    }
    if (v198) {
      operator delete(v198);
    }
    if (v121) {
      operator delete(v121);
    }
    if (v197) {
      operator delete(v197);
    }

    uint64_t v108 = v199 & 1;
    goto LABEL_156;
  }

  if (v97 <= -16080)
  {
    if (v97 != -16327 && v97 != -16220)
    {
      int v109 = -16137;
      goto LABEL_138;
    }

void sub_140580( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void InstrumentFunctionWithResourceTrackingV2( uint64_t a1, GTMTLReplayController *a2, uint64_t a3, uint64_t a4, uint64_t a5, apr_pool_t *a6)
{
  __n128 v12 = (void *)objc_claimAutoreleasedReturnValue([a2->var1 defaultDevice]);
  var0 = a2->var0;
  __int128 v14 = *(_OWORD *)(a5 + 32);
  __int128 v15 = *(_OWORD *)(a5 + 64);
  __int128 v69 = *(_OWORD *)(a5 + 48);
  __int128 v70 = v15;
  uint64_t v71 = *(void *)(a5 + 80);
  __int128 v16 = *(_OWORD *)(a5 + 16);
  unsigned int v17 = *(_DWORD *)(a3 + 8);
  __int128 v66 = *(_OWORD *)a5;
  __int128 v67 = v16;
  __int128 v68 = v14;
  if (v17 >> 2 == 1073737833) {
    goto LABEL_60;
  }
  GTMTLReplayController_debugSubCommandResume((unsigned int *)a2, *(_DWORD *)a3 - LODWORD(var0->var9.var0.var0) + 1, -1);
  if (!*(void *)(a4 + 240)) {
    goto LABEL_59;
  }
  unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([a2->var1 defaultDevice]);
  unint64_t v19 = a2->var0;
  var5 = (uint64_t *)a2->var0->var5;
  unsigned int v20 = a2->var21.var0.var0;
  if (v20 != 28)
  {
    if (v20 != 70)
    {
LABEL_58:

LABEL_59:
      GTMTLReplay_handleError( 101,  (uint64_t)"Resource access tracking failed",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_accessTracking.mm",  (uint64_t)"InstrumentFunctionWithResourceTrackingV2",  4806LL,  64LL);
      FlushCommandQueue(a2);
      goto LABEL_60;
    }

    *(void *)unint64_t v63 = v18;
    uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([a2->var1 renderCommandEncoderForKey:a2->var21.var0.var2]);
    if (!v59) {
      goto LABEL_56;
    }
    uint64_t Object = GTMTLSMContext_getObject(*(void *)v19->var5, a2->var21.var3.var0.var23, *(void *)a3);
    if (!Object) {
      goto LABEL_56;
    }
    uint64_t v22 = Object;
    id v23 = ObtainTracingRenderPipelineState((uint64_t *)v19->var5, a2->var1, Object, a4, *(void *)a3, a6);
    uint64_t v24 = objc_claimAutoreleasedReturnValue(v23);
    if (!v24) {
      goto LABEL_56;
    }
    BOOL v57 = (void *)v24;
    ReplaceFunctionTablesWithInstrumented((uint64_t)&v63[8], (uint64_t)a2, a4, *(void *)a3, v22, (uint64_t *)&v66, a6);
    [v59 setRenderPipelineState:v24];
    uint64_t v25 = *(_DWORD *)(a4 + 256) & 0x37;
    if ((*(_DWORD *)(a4 + 256) & 0x37u) <= 3)
    {
      if ((*(_DWORD *)(a4 + 256) & 0x37) != 1)
      {
        if ((*(_DWORD *)(a4 + 256) & 0x37) != 2) {
          goto LABEL_55;
        }
        uint64_t v25 = 2LL;
      }
    }

    else
    {
      switch(*(_DWORD *)(a4 + 256) & 0x37)
      {
        case 4:
          uint64_t v25 = 4LL;
          break;
        case 16:
          uint64_t v25 = 8LL;
          break;
        case 32:
          uint64_t v25 = 16LL;
          break;
        default:
          goto LABEL_55;
      }
    }

    [v59 useResource:*(void *)(a4 + 240) usage:3 stages:v25];
    int v33 = *(_DWORD *)(a3 + 8);
    if (!IsFuncEnumDrawCall(v33))
    {
      if (v33 == -16137 || v33 == -15297 || v33 == -15486)
      {
        if ((SupportsGlobalRelocation(*(void **)v63, a4) & 1) == 0)
        {
          __int128 v34 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( *(void *)a4,  *(void *)(a4 + 8),  v22[1]);
          if (!v34) {
            goto LABEL_55;
          }
          [v59 setTileBuffer:*(void *)(a4 + 240) offset:0 atIndex:*((unsigned int *)v34 + 6)];
        }

        if (!UpdateFunctionTables<31ul,1ul>( 4u,  v59,  (uint64_t)&a2->var21.var3.var0.var20.var0,  (uint64_t)a2->var21.var3.var0.var19,  var5,  *(void *)a3,  &v63[8])) {
          goto LABEL_55;
        }
      }

void sub_1416F0(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va1);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

void *ShouldInstrumentFragmentStage(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *a1;
  unsigned int v9 = *(_DWORD *)(a3 + 8);
  if (IsFuncEnumDrawCall(v9))
  {
    if (*((_DWORD *)a1 + 2828) == 70)
    {
      BOOL result = GTMTLSMContext_getObject(**(void **)(v8 + 40), a1[2489], *(void *)a3);
      if (!result) {
        return result;
      }
      BOOL v11 = GTMTLSMRenderPipelineState_fragmentFunction(*(uint64_t **)(v8 + 40), result) == 0;
      return (void *)!v11;
    }

    return 0LL;
  }

  if (v9 >> 1 != 2147475667) {
    return 0LL;
  }
  GetExecuteCommandsInBufferArgs((uint64_t)&v21, a3, *(void *)(v8 + 16));
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(v8 + 40), v21, *(void *)a3);
  GTMTLCreateIndirectCommandEncoder((uint64_t)v20, Object[13]);
  if (v22 > a4 || v23 + v22 < a4) {
    return 0LL;
  }
  uint64_t v13 = v24 + v20[13] * a4;
  unint64_t v14 = *(void *)(v13 + v20[1]);
  BOOL v15 = v14 > 8;
  uint64_t v16 = (1LL << v14) & 0x116;
  if (v15 || v16 == 0) {
    return 0LL;
  }
  if (*(_BYTE *)(v20[0] + 11LL))
  {
    uint64_t v18 = a1[2489];
    if (!v18) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v18 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(*(void *)(a2 + 24), *(void *)(v13 + v20[2]));
    if (!v18) {
      return 0LL;
    }
  }

  BOOL result = GTMTLSMContext_getObject(**(void **)(v8 + 40), v18, *(void *)a3);
  if (!result) {
    return result;
  }
  uint64_t v19 = result[6];
  if (!v19) {
    return 0LL;
  }
  BOOL v11 = *(void *)(v19 + 1176) == 0LL;
  return (void *)!v11;
}

BOOL ShouldInstrumentICBObjectStage(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  if (*(_DWORD *)(a2 + 8) >> 2 != 1073737833) {
    return 0LL;
  }
  uint64_t v6 = *a1;
  id v7 = (id)a1[1];
  GTMTLSMContext_indirectCommandBufferResources( (uint64_t)v20,  *(_DWORD ***)(v6 + 40),  *(void *)a2,  *(apr_pool_t **)a1[19]);
  GetExecuteCommandsInBufferArgs((uint64_t)&v16, a2, *(void *)(v6 + 16));
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(v6 + 40), v16, *(void *)a2);
  GTMTLCreateIndirectCommandEncoder((uint64_t)v15, Object[13]);
  BOOL v11 = v17 <= a3
     && v18 + v17 >= a3
     && v19
     && (uint64_t v9 = Object[13]) != 0
     && (!*(_BYTE *)(v9 + 11)
       ? (uint64_t v10 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier( v21,  *(void *)(v19 + v15[13] * a3 + v15[2])))
       : (uint64_t v10 = a1[2489]),
         (v12 = GTMTLSMContext_getObject(**(void **)(v6 + 40), v10, *(void *)a2)) != 0LL && (uint64_t v13 = v12[9]) != 0)
     && *(void *)(v13 + 368) != 0LL;

  return v11;
}

void MakeRootResourceAliasable(void *a1)
{
  id v6 = a1;
  id v1 = (void *)objc_claimAutoreleasedReturnValue([v6 heap]);
  unint64_t v2 = v1;
  if (v1 && ![v1 type])
  {
    if ([v6 conformsToProtocol:&OBJC_PROTOCOL___MTLTexture])
    {
      id v3 = v6;
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 parentTexture]);
      if (v4)
      {

        goto LABEL_8;
      }

      unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 buffer]);

      if (v5) {
        goto LABEL_8;
      }
    }

    [v6 makeAliasable];
  }

uint64_t IsResourceIndirectCommandBuffer(void *a1)
{
  id v1 = a1;
  if (IsResourceIndirectCommandBuffer_onceToken != -1) {
    dispatch_once(&IsResourceIndirectCommandBuffer_onceToken, &__block_literal_global_4302);
  }
  if ([v1 conformsToProtocol:&OBJC_PROTOCOL___MTLIndirectCommandBuffer])
  {
    char isKindOfClass = 1;
  }

  else if (IsResourceIndirectCommandBuffer__MTLIOAccelIndirectCommandBufferClass)
  {
    char isKindOfClass = objc_opt_isKindOfClass(v1, IsResourceIndirectCommandBuffer__MTLIOAccelIndirectCommandBufferClass);
  }

  else
  {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

id GTMTLReplayController_generatePostMeshData( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  id v240 = a2;
  id v14 = a11;
  id v15 = *(id *)(a10 + 72);
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 device]);
  uint64_t v223 = a8;
  memcpy(v263, *(const void **)(a8 + 72), sizeof(v263));
  uint64_t v17 = 0LL;
  int v18 = BYTE5(v263[63]);
  do
  {
    uint64_t v19 = &v263[v17];
    *(_WORD *)uint64_t v19 = 0;
    *((_BYTE *)v19 + 3) = 0;
    v17 += 2LL;
  }

  while (v17 != 16);
  LOWORD(v263[50]) = 0;
  LOWORD(v263[51]) = 0;
  BYTE6(v263[63]) = 0;
  LOWORD(v263[0]) = 70;
  memset(&v263[16], 0, 64);
  v263[43] = 0LL;
  v263[47] = 0LL;
  uint64_t v229 = a1;
  unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) renderPipelineDescriptorMap]);
  MTLMeshRenderPipelineDescriptorWithoutResourceIndex = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex( (uint64_t)v263,  v20);
  unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptorWithoutResourceIndex);

  int v271 = 0;
  uint64_t v270 = 0LL;
  [v22 setRasterizationEnabled:0];
  [v22 setLabel:@"GPUToolsInternalPostTransformPipelineStateLabel"];
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  id v262 = 0LL;
  id v261 = 0LL;
  id v25 = [v16 newRenderPipelineStateWithMeshDescriptor:v22 options:1 reflection:&v262 error:&v261];
  id v26 = v262;
  id v27 = v261;
  obuint64_t j = v25;
  if (v25)
  {
    unint64_t v236 = v16;
    unint64_t v237 = v22;
    __int128 v257 = 0u;
    __int128 v258 = 0u;
    __int128 v259 = 0u;
    __int128 v260 = 0u;
    id v28 = (id)objc_claimAutoreleasedReturnValue([v26 meshBuiltInArguments]);
    id v29 = [v28 countByEnumeratingWithState:&v257 objects:v269 count:16];
    uint64_t v235 = v15;
    if (v29)
    {
      id v30 = v29;
      id v213 = v26;
      int v217 = v18;
      id v221 = v14;
      uint64_t v31 = *(void *)v258;
      int v32 = v240;
      while (2)
      {
        for (uint64_t i = 0LL; i != v30; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v258 != v31) {
            objc_enumerationMutation(v28);
          }
          __int128 v34 = *(void **)(*((void *)&v257 + 1) + 8LL * (void)i);
          if ([v34 builtInType] == &dword_18)
          {
            unsigned int v215 = [v34 meshVertexCount];
            unsigned int v216 = [v34 meshPrimitiveCount];
            unint64_t v36 = (unint64_t)[v34 meshTopologyType] - 1;
            id v211 = v27;
            if (v36 > 2) {
              int v208 = 0;
            }
            else {
              int v208 = dword_317018[v36];
            }
            uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v34 meshVertexStruct]);
            unsigned int v233 = (void *)objc_claimAutoreleasedReturnValue([v34 meshPrimitiveStruct]);
            __int128 v253 = 0u;
            __int128 v254 = 0u;
            __int128 v255 = 0u;
            __int128 v256 = 0u;
            uint64_t v209 = v39;
            uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v39 members]);
            id v41 = [v40 countByEnumeratingWithState:&v253 objects:v268 count:16];
            if (v41)
            {
              id v42 = v41;
              uint64_t v43 = *(void *)v254;
              do
              {
                for (uint64_t j = 0LL; j != v42; uint64_t j = (char *)j + 1)
                {
                  if (*(void *)v254 != v43) {
                    objc_enumerationMutation(v40);
                  }
                  uint64_t v45 = *(void **)(*((void *)&v253 + 1) + 8LL * (void)j);
                  unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v45 dataType]));
                  int64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v45 name]);
                  [v23 setObject:v46 forKeyedSubscript:v47];
                }

                id v42 = [v40 countByEnumeratingWithState:&v253 objects:v268 count:16];
              }

              while (v42);
            }

            __int128 v252 = 0u;
            __int128 v251 = 0u;
            __int128 v250 = 0u;
            __int128 v249 = 0u;
            BOOL v48 = (void *)objc_claimAutoreleasedReturnValue([v233 members]);
            id v49 = [v48 countByEnumeratingWithState:&v249 objects:v267 count:16];
            if (v49)
            {
              id v50 = v49;
              uint64_t v51 = *(void *)v250;
              do
              {
                for (uint64_t k = 0LL; k != v50; uint64_t k = (char *)k + 1)
                {
                  if (*(void *)v250 != v51) {
                    objc_enumerationMutation(v48);
                  }
                  uint64_t v53 = *(void **)(*((void *)&v249 + 1) + 8LL * (void)k);
                  int v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v53 dataType]));
                  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v53 name]);
                  [v24 setObject:v54 forKeyedSubscript:v55];
                }

                id v50 = [v48 countByEnumeratingWithState:&v249 objects:v267 count:16];
              }

              while (v50);
            }

            char v35 = 1;
            int v32 = v240;
            id v14 = v221;
            int v18 = v217;
            id v27 = v211;
            goto LABEL_33;
          }
        }

        id v30 = [v28 countByEnumeratingWithState:&v257 objects:v269 count:16];
        if (v30) {
          continue;
        }
        break;
      }

      int v208 = 0;
      unsigned int v215 = 0;
      unsigned int v216 = 0;
      char v35 = 0;
      id v14 = v221;
      int v18 = v217;
LABEL_33:
      id v26 = v213;
    }

    else
    {
      int v208 = 0;
      unsigned int v215 = 0;
      unsigned int v216 = 0;
      char v35 = 0;
      int v32 = v240;
    }

    unint64_t v22 = v237;
    if ((v35 & 1) == 0 && v18)
    {
      id v56 = GTPostVertexDataError(1u, @"Internal error: Missing mesh reflection", 0LL, 0LL);
      id v38 = 0LL;
      *a12 = (id)objc_claimAutoreleasedReturnValue(v56);
      id v15 = v235;
      uint64_t v16 = v236;
      goto LABEL_121;
    }

    uint64_t v16 = v236;
    if ((objc_opt_respondsToSelector(v237, "setGpuCompilerSPIOptions:") & 1) == 0)
    {
      id v71 = GTPostVertexDataError( 3u,  @"Post-vertex data fetch for mesh pipelines is not supported",  @"Update target OS to the latest version",  0LL);
      id v38 = 0LL;
      *a12 = (id)objc_claimAutoreleasedReturnValue(v71);
      id v15 = v235;
      goto LABEL_121;
    }

    int v218 = v18;
    uint64_t v265 = @"enable-post-mesh-dump-instrumentation";
    BOOL v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    uint64_t v266 = v57;
    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v266,  &v265,  1LL));
    [v237 setGpuCompilerSPIOptions:v58];

    id v248 = 0LL;
    id v247 = 0LL;
    id v59 = [v236 newRenderPipelineStateWithMeshDescriptor:v237 options:0x200000001 reflection:&v248 error:&v247];
    id v60 = v248;
    id v61 = v247;
    id v212 = v60;
    signed int v214 = v59;
    v234 = v61;
    if (v59)
    {
      id v222 = v14;
      __int128 v243 = 0u;
      __int128 v244 = 0u;
      __int128 v245 = 0u;
      __int128 v246 = 0u;
      id obja = (id)objc_claimAutoreleasedReturnValue([v60 meshBindings]);
      id v62 = [obja countByEnumeratingWithState:&v243 objects:v264 count:16];
      if (v62)
      {
        id v63 = v62;
        uint64_t v64 = *(void *)v244;
        while (2)
        {
          for (uint64_t m = 0LL; m != v63; uint64_t m = (char *)m + 1)
          {
            if (*(void *)v244 != v64) {
              objc_enumerationMutation(obja);
            }
            __int128 v66 = *(void **)(*((void *)&v243 + 1) + 8LL * (void)m);
            __int128 v67 = (void *)objc_claimAutoreleasedReturnValue([v66 name]);
            if ([v67 isEqualToString:@"__post_mesh_dump_impl_trace_buffer"])
            {
              id v68 = [v66 type];

              if (!v68)
              {
                id v167 = [v66 index];
                uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v66 bufferStructType]);
                __int128 v81 = (void *)objc_claimAutoreleasedReturnValue([v80 memberByName:@"size"]);
                __int128 v166 = (char *)[v81 offset];
                uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v80 memberByName:@"os_tg_bounds"]);
                unint64_t v165 = (char *)[v82 offset];
                unint64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v82 arrayType]);
                unint64_t v164 = (unint64_t)[v83 stride];
                unint64_t v84 = (void *)objc_claimAutoreleasedReturnValue([v80 memberByName:@"num_dumped_mesh_threadgroups"]);
                unsigned int v188 = (char *)[v84 offset];
                unint64_t v85 = (void *)objc_claimAutoreleasedReturnValue([v80 memberByName:@"max_ms_tg_ids"]);
                int v184 = (char *)[v85 offset];

                uint64_t v205 = v80;
                uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue([v80 memberByName:@"mesh_data"]);
                uint64_t v207 = [v86 offset];
                uint64_t v203 = v86;
                unint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v86 arrayType]);
                unsigned int v210 = [v87 stride];
                uint64_t v201 = v87;
                int v88 = (void *)objc_claimAutoreleasedReturnValue([v87 elementStructType]);
                int v199 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"primitive_count"]);
                unsigned int v186 = [v199 offset];
                char v197 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"amplification_id"]);
                unsigned int v185 = [v197 offset];
                signed int v195 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"object_threadgroup_position_in_grid"]);
                unsigned int v183 = [v195 offset];
                __int128 v194 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"threadgroup_position_in_grid"]);
                unsigned int v182 = [v194 offset];
                uint64_t v193 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"indices"]);
                unsigned int v181 = [v193 offset];
                uint64_t v192 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"indices_present"]);
                unsigned int v180 = [v192 offset];
                unint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"indices_thread_id"]);
                unsigned int v179 = [v89 offset];
                signed int v191 = v89;
                if (v216)
                {
                  uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue([v89 arrayType]);
                  unsigned int v178 = [v90 stride];
                }

                else
                {
                  unsigned int v178 = 0;
                }

                int v32 = v240;
                id v190 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"vertices_present"]);
                unsigned int v177 = [v190 offset];
                unint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"vertices_thread_id"]);
                unsigned int v176 = [v92 offset];
                if (v215)
                {
                  unint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v92 arrayType]);
                  unsigned int v175 = [v93 stride];
                }

                else
                {
                  unsigned int v175 = 0;
                }

                BOOL v189 = v92;
                __int128 v94 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"vertices"]);
                unsigned int v173 = [v94 offset];
                if (v215)
                {
                  uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v94 arrayType]);
                  unsigned int v96 = [v95 stride];
                  uint64_t v219 = objc_claimAutoreleasedReturnValue([v95 elementStructType]);

                  unsigned int v174 = v96;
                  unsigned int v168 = v96;
                }

                else
                {
                  unsigned int v174 = 0;
                  unsigned int v168 = 0;
                  uint64_t v219 = 0LL;
                }

                int v97 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"primitives_present"]);
                unsigned int v172 = [v97 offset];
                __int128 v98 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"primitives_thread_id"]);
                unsigned int v171 = [v98 offset];
                if (v216)
                {
                  id v99 = (void *)objc_claimAutoreleasedReturnValue([v98 arrayType]);
                  unsigned int v170 = [v99 stride];
                }

                else
                {
                  unsigned int v170 = 0;
                }

                int v100 = (void *)objc_claimAutoreleasedReturnValue([v88 memberByName:@"primitives"]);
                unsigned int v169 = [v100 offset];
                if (v216)
                {
                  __int128 v101 = (void *)objc_claimAutoreleasedReturnValue([v100 arrayType]);
                  unsigned int v187 = [v101 stride];
                  __int128 v102 = v97;
                  uint64_t v103 = v94;
                  uint64_t v104 = objc_claimAutoreleasedReturnValue([v101 elementStructType]);

                  BOOL v105 = (void *)v104;
                  __int128 v94 = v103;
                  int v97 = v102;
                }

                else
                {
                  unsigned int v187 = 0;
                  BOOL v105 = 0LL;
                }

                BOOL v106 = 0;
                int v107 = 1;
                uint64_t v108 = (void *)v219;
                id v14 = v222;
                goto LABEL_79;
              }
            }

            else
            {
            }
          }

          id v63 = [obja countByEnumeratingWithState:&v243 objects:v264 count:16];
          if (v63) {
            continue;
          }
          break;
        }
      }

      if (v218) {
        char v69 = 1;
      }
      else {
        char v69 = v35;
      }
      if ((v69 & 1) != 0)
      {
        id v70 = GTPostVertexDataError(1u, @"Internal error: Post-vertex data buffer binding is missing", 0LL, 0LL);
        id v38 = 0LL;
        *a12 = (id)objc_claimAutoreleasedReturnValue(v70);
        int v32 = v240;
        id v14 = v222;
        id v15 = v235;
        uint64_t v16 = v236;
      }

      else
      {
        unsigned int v173 = 0;
        unsigned int v174 = 0;
        unsigned int v169 = 0;
        unsigned int v170 = 0;
        unsigned int v186 = 0;
        unsigned int v187 = 0;
        unsigned int v210 = 0;
        unsigned int v185 = 0;
        unsigned int v182 = 0;
        unsigned int v183 = 0;
        unsigned int v180 = 0;
        unsigned int v181 = 0;
        unsigned int v176 = 0;
        unsigned int v177 = 0;
        unsigned int v171 = 0;
        unsigned int v172 = 0;
        unsigned int v175 = 0;
        unsigned int v178 = 0;
        unsigned int v179 = 0;
        id v167 = 0LL;
        unsigned int v168 = 0;
        uint64_t v108 = 0LL;
        BOOL v105 = 0LL;
        int v107 = 0;
        __int128 v166 = 0LL;
        BOOL v106 = v263[46] != 0LL;
        unint64_t v164 = 0LL;
        unint64_t v165 = (char *)&dword_4;
        unsigned int v188 = (_BYTE *)(&stru_20 + 4);
        int v184 = (_BYTE *)(&stru_20 + 8);
        uint64_t v207 = (_BYTE *)(&stru_20 + 12);
        int v32 = v240;
        id v14 = v222;
LABEL_79:
        id v15 = v235;
        unint64_t v22 = v237;
        if (!v108 && v215 || !v105 && v216)
        {
          id v109 = GTPostVertexDataError(1u, @"Internal error: Post-vertex data buffer binding error", 0LL, 0LL);
          *a12 = (id)objc_claimAutoreleasedReturnValue(v109);

          id v38 = 0LL;
          uint64_t v16 = v236;
LABEL_119:

          goto LABEL_120;
        }

        BOOL v198 = v106;
        uint64_t v202 = v105;
        int v220 = v108;
        if (v107)
        {
          uint64_t v110 = *(void *)(a4 + 24)
               + (*GroupBuilder_getCommandBuffer( *(_DWORD *)(*(void *)(a3 + 112) + 12LL),  *(void **)(*(void *)(a3 + 112) + 24LL),  a5) << 6);
          GTMTLReplayController_defaultDispatchFunction(v229, v110);
          id v111 = objc_msgSend( v32,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v110,  *(unsigned __int8 *)(v110 + 13),  *(void *)(a3 + 16))
                   + 1));
          uint64_t v206 = (void *)objc_claimAutoreleasedReturnValue(v111);
          int v112 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
          -[MTLRenderPassDescriptor setRenderTargetWidth:](v112, "setRenderTargetWidth:", *(void *)(v229 + 22464));
          -[MTLRenderPassDescriptor setRenderTargetHeight:](v112, "setRenderTargetHeight:", *(void *)(v229 + 22472));
          __int128 v113 = (void *)objc_claimAutoreleasedReturnValue([v237 colorAttachments]);
          __int128 v114 = (void *)objc_claimAutoreleasedReturnValue([v113 objectAtIndexedSubscript:0]);
          unint64_t v115 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  [v114 pixelFormat],  *(void *)(v229 + 22464),  *(void *)(v229 + 22472),  0));

          [v115 setStorageMode:2];
          id v116 = [v236 newTextureWithDescriptor:v115];
          uint64_t v117 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v112, "colorAttachments"));
          int v118 = (void *)objc_claimAutoreleasedReturnValue([v117 objectAtIndexedSubscript:0]);
          [v118 setTexture:v116];

          BOOL v119 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v112, "colorAttachments"));
          char v120 = (void *)objc_claimAutoreleasedReturnValue([v119 objectAtIndexedSubscript:0]);
          [v120 setLoadAction:0];

          uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v112, "colorAttachments"));
          uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue([v121 objectAtIndexedSubscript:0]);
          [v122 setStoreAction:0];

          if ((GT_SUPPORT_0 & 0x40) != 0) {
            -[MTLRenderPassDescriptor setDefaultRasterSampleCount:](v112, "setDefaultRasterSampleCount:", 1LL);
          }
          CommandEncoder = GroupBuilder_getCommandEncoder( *(_DWORD *)(*(void *)(a3 + 112) + 12LL),  *(void **)(*(void *)(a3 + 112) + 24LL),  a5);
          int v124 = (void *)objc_claimAutoreleasedReturnValue([v206 renderCommandEncoderWithDescriptor:v112]);
          uint64_t v125 = *(void *)(a4 + 24) + (*CommandEncoder << 6);
          objc_msgSend( v32,  "setRenderCommandEncoder:forKey:",  v124,  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v125,  *(unsigned __int8 *)(v125 + 13),  *(void *)(a3 + 16))
            + 1));
          *(void *)(a7 + 8544) = 0LL;
          *(void *)(a7 + 9848) = 0LL;
          *(_BYTE *)(a7 + 11085) = 0;
          *(_DWORD *)(a7 + 11076) = 0;
          GTMTLReplayController_restoreDefaultRenderCommandEncoder( v124,  *(void *)(v229 + 22464),  *(void *)(v229 + 22472),  (uint64_t *)a7,  v32);
          int v200 = v124;
          [v124 setRenderPipelineState:v214];

          uint64_t v126 = v220;
          id v14 = v222;
        }

        else
        {
          uint64_t v126 = v108;
          int v200 = 0LL;
          uint64_t v206 = 0LL;
        }

        id v127 = v235;
        id v128 = [v127 contents];
        __int16 v129 = [v127 length];
        bzero(v128, (size_t)v129);
        id v204 = v128;
        if (v107)
        {
          id v130 = [v14 length];
          uint64_t v131 = (char *)[v14 bytes];
          *(_DWORD *)&v166[(void)v128] = (_DWORD)v129;
          uint64_t v132 = &v165[(void)v128];
          __int128 v133 = &v165[(void)v128 + v164];
          bzero(v132, 2 * v164);
          if (v130)
          {
            uint64_t v134 = *(void *)v131;
            *((_DWORD *)v132 + 2) = *((_DWORD *)v131 + 2);
            *(void *)uint64_t v132 = v134;
            uint64_t v135 = *(void *)(v131 + 12);
            *((_DWORD *)v133 + 2) = *((_DWORD *)v131 + 5);
            *(void *)__int128 v133 = v135;
          }

          else
          {
            *((_DWORD *)v132 + 2) = 0;
            *(void *)uint64_t v132 = 0LL;
            *(void *)__int128 v133 = -1LL;
            *((_DWORD *)v133 + 2) = -1;
          }

          *(_DWORD *)&v188[(void)v204] = 0;
          [v200 setMeshBuffer:v127 offset:0 atIndex:v167];
          if (*(_DWORD *)(a6 + 8) >> 2 == 1073737833)
          {
            uint64_t v196 = *(void *)(a9 + 240);
            uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue([v32 executeIndirectCommandBufferMap]);
            DYMTLDrawRenderCommandEncoder(v200, a9 + 40, v196, a9 + 152, v136);

            apr_pool_clear(*(apr_pool_t **)(a9 + 248));
            uint64_t v137 = v229;
          }

          else
          {
            uint64_t v137 = v229;
            GTMTLReplayController_defaultDispatchFunction(v229, a6);
          }

          uint64_t v126 = v220;
          GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer(v137, a5);
          [v32 commitCommandBuffers];
          [v206 waitUntilCompleted];
          id v128 = v204;
        }

        unint64_t v138 = *(unsigned int *)&v188[(void)v128];
        unint64_t v139 = v207 + v210 * (_DWORD)v138;
        uint64_t v16 = v236;
        id v140 = [v236 maxBufferLength];
        else {
          unint64_t v141 = (unint64_t)v140;
        }
        if (v141 >= 0x20000000) {
          unint64_t v142 = 0x20000000LL;
        }
        else {
          unint64_t v142 = v141;
        }
        if (v142 > (unint64_t)v129 && (id v143 = objc_msgSend(v236, "newBufferWithLength:options:")) != 0)
        {
          uint64_t v144 = *(void **)(a10 + 72);
          *(void *)(a10 + 72) = v143;

          memcpy(__dst, (const void *)a7, sizeof(__dst));
          __int128 v145 = *(_OWORD *)(a9 + 208);
          v241[12] = *(_OWORD *)(a9 + 192);
          v241[13] = v145;
          __int128 v146 = *(_OWORD *)(a9 + 240);
          v241[14] = *(_OWORD *)(a9 + 224);
          v241[15] = v146;
          __int128 v147 = *(_OWORD *)(a9 + 144);
          v241[8] = *(_OWORD *)(a9 + 128);
          v241[9] = v147;
          __int128 v148 = *(_OWORD *)(a9 + 176);
          v241[10] = *(_OWORD *)(a9 + 160);
          v241[11] = v148;
          __int128 v149 = *(_OWORD *)(a9 + 80);
          v241[4] = *(_OWORD *)(a9 + 64);
          v241[5] = v149;
          __int128 v150 = *(_OWORD *)(a9 + 112);
          v241[6] = *(_OWORD *)(a9 + 96);
          v241[7] = v150;
          __int128 v151 = *(_OWORD *)(a9 + 16);
          v241[0] = *(_OWORD *)a9;
          v241[1] = v151;
          __int128 v152 = *(_OWORD *)(a9 + 48);
          v241[2] = *(_OWORD *)(a9 + 32);
          v241[3] = v152;
          id v14 = v222;
          uint64_t PostMeshData = GTMTLReplayController_generatePostMeshData( v229,  v32,  a3,  a4,  a5,  a6,  __dst,  v223,  v241,  a10,  v222,  a12);
          id v38 = (id)objc_claimAutoreleasedReturnValue(PostMeshData);
          unsigned int v154 = v202;
          uint64_t v155 = v126;
        }

        else
        {
          unint64_t v156 = SaveObjectStruct(v168, v126, v23, 0LL, 0LL);
          unint64_t v232 = SaveObjectStruct(v187, v202, v24, 0LL, 0LL);
          BOOL v230 = (unint64_t)v129 < v139;
          id v157 = &v184[(void)v128];
          if (v198)
          {
            id v158 = [v214 maxTotalThreadgroupsPerMeshGrid];
            unint64_t v159 = 0xFFFFFFFFLL;
            if (v159 <= 1) {
              LODWORD(v159) = 1;
            }
            int v160 = v159 - 1;
            *(_DWORD *)id v157 = v160;
            *((_DWORD *)v157 + 1) = v160;
            *((_DWORD *)v157 + 2) = v160;
          }

          uint64_t v270 = *(void *)v157;
          int v271 = *((_DWORD *)v157 + 2);
          size_t v228 = v138 * v210;
          uint64_t v16 = v236;
          id v38 = objc_retainAutorelease( [v236 newBufferWithLength:((v228 + 255) & 0xFFFFFFFFFFFFFF00) + ((v156 + v232 + 380) & 0xFFFFFFFFFFFFFF00) options:0]);
          unint64_t v161 = (char *)[v38 contents];
          *(_DWORD *)unint64_t v161 = 2;
          *((_DWORD *)v161 + 1) = (v156 + v232 + 380) & 0xFFFFFF00;
          *((_DWORD *)v161 + 2) = 125;
          *((_DWORD *)v161 + 3) = v156;
          *((_DWORD *)v161 + 4) = v232;
          *((_DWORD *)v161 + 5) = v208;
          *((_DWORD *)v161 + 6) = v215;
          *((_DWORD *)v161 + 7) = v173;
          *((_DWORD *)v161 + 8) = v174;
          *((_DWORD *)v161 + 9) = v216;
          *((_DWORD *)v161 + 10) = v169;
          *((_DWORD *)v161 + 11) = v187;
          *((_DWORD *)v161 + 12) = v138;
          *((_DWORD *)v161 + 13) = v210;
          *((_DWORD *)v161 + 14) = v186;
          *((_DWORD *)v161 + 15) = v185;
          *((_DWORD *)v161 + 16) = v183;
          *((_DWORD *)v161 + 17) = v182;
          *((_DWORD *)v161 + 18) = v181;
          int v162 = v271;
          *(void *)(v161 + 76) = v270;
          *((_DWORD *)v161 + 21) = v162;
          *((_DWORD *)v161 + 22) = v177;
          *((_DWORD *)v161 + 23) = v172;
          *((_DWORD *)v161 + 24) = v180;
          *((_DWORD *)v161 + 25) = v176;
          *((_DWORD *)v161 + 26) = v175;
          *((_DWORD *)v161 + 27) = v171;
          *((_DWORD *)v161 + 28) = v170;
          *((_DWORD *)v161 + 29) = v179;
          *((_DWORD *)v161 + 30) = v178;
          v161[124] = v230;
          uint64_t v155 = v220;
          SaveObjectStruct(v174, v220, v23, v161 + 125, v156);
          unsigned int v154 = v202;
          SaveObjectStruct(v187, v202, v24, &v161[v156 + 125], v232);
          memcpy(&v161[(v156 + v232 + 380) & 0xFFFFFFFFFFFFFF00LL], &v207[(void)v204], v228);
          id v14 = v222;
          id v15 = v235;
        }
      }

      unint64_t v22 = v237;
      goto LABEL_119;
    }

    __int128 v72 = v61;
    uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v61 domain]);
    if ([v73 hasPrefix:@"AGXMetal"])
    {
      unint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([v72 localizedDescription]);
      unsigned int v75 = [v74 containsString:@"Payload size >"];

      id v15 = v235;
      if (v75)
      {
        __int128 v76 = @"Maximum tools-supported payload size exceeded";
        uint64_t v77 = @"Reduce your object data payload to 16368 bytes or less";
        unsigned int v78 = 3;
        int v79 = 0LL;
LABEL_63:
        id v91 = GTPostVertexDataError(v78, v76, v77, v79);
        id v38 = 0LL;
        unint64_t v22 = v237;
        *a12 = (id)objc_claimAutoreleasedReturnValue(v91);
LABEL_120:

        goto LABEL_121;
      }
    }

    else
    {

      id v15 = v235;
    }

    __int128 v76 = @"Post-vertex data fetch pipeline error";
    unsigned int v78 = 2;
    uint64_t v77 = 0LL;
    int v79 = v234;
    goto LABEL_63;
  }

  id v37 = GTPostVertexDataError(2u, @"Post-vertex data fetch pipeline reflection error", 0LL, v27);
  *a12 = (id)objc_claimAutoreleasedReturnValue(v37);

  id v38 = 0LL;
  int v32 = v240;
LABEL_121:

  return v38;
}

id GTMTLReplayController_generatePostVertexData( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  id v92 = a2;
  unint64_t v17 = 63 - __clz(~(*(_DWORD *)(a8 + 128) | *(_DWORD *)(a8 + 120)) & 0x7FFFFFFF);
  id v91 = *(id *)(a10 + 72);
  unint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v91 device]);
  if ((unint64_t)[v93 maxVertexBuffers] <= v17)
  {
    id v52 = GTPostVertexDataError(1u, @"Internal error: Post-vertex data buffer binding error", 0LL, 0LL);
    id v53 = 0LL;
    *a11 = (id)objc_claimAutoreleasedReturnValue(v52);
    unint64_t v46 = v92;
    uint64_t v23 = v93;
    int v54 = v91;
  }

  else
  {
    unint64_t v87 = a5;
    unint64_t v88 = v17;
    uint64_t v82 = a8;
    uint64_t v90 = a1;
    uint64_t v85 = a6;
    memcpy(v98, *(const void **)(a8 + 48), 0x5E8uLL);
    for (uint64_t i = 0LL; i != 16; i += 2LL)
    {
      uint64_t v19 = &v98[i];
      *((_WORD *)v19 + 372) = 0;
      *((_BYTE *)v19 + 747) = 0;
    }

    WORD2(v98[167]) = 0;
    LOWORD(v98[169]) = 0;
    BYTE3(v98[187]) = 0;
    LOWORD(v98[93]) = 70;
    v98[147] = 0LL;
    memset(&v98[109], 0, 64);
    unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) renderPipelineDescriptorMap]);
    MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex( (uint64_t)v98,  v20);
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);

    [v22 setLabel:@"GPUToolsInternalPostTransformPipelineStateLabel"];
    [v22 setRasterizationEnabled:0];
    uint64_t v23 = v93;
    if ((GT_SUPPORT_0 & 0x20) != 0)
    {
      [v22 setTessellationPartitionMode:1];
      [v22 setMaxTessellationFactor:1];
      [v22 setTessellationFactorScaleEnabled:1];
    }

    [v22 setPostVertexDumpBufferIndex:v17];
    id v97 = 0LL;
    id v96 = 0LL;
    id v24 = [v93 newRenderPipelineStateWithDescriptor:v22 options:0x80000 reflection:&v97 error:&v96];
    id v25 = v97;
    id v26 = v96;
    if (v24)
    {
      uint64_t v27 = a3;
      id v78 = v26;
      int v79 = v22;
      id v84 = v24;
      __int128 v81 = v25;
      unint64_t v28 = (unint64_t)[v25 postVertexDumpStride];
      id v29 = v91;
      id v30 = (unsigned int *)[v29 contents];
      *id v30 = 0;
      id v83 = v29;
      uint64_t v80 = v28;
      uint64_t v77 = v30;
      v30[1] = ((unint64_t)[v29 length] - 8) / v28;
      uint64_t v31 = *(void *)(a4 + 24)
          + (*GroupBuilder_getCommandBuffer( *(_DWORD *)(*(void *)(a3 + 112) + 12LL),  *(void **)(*(void *)(a3 + 112) + 24LL),  v87) << 6);
      GTMTLReplayController_defaultDispatchFunction(v90, v31);
      id v32 = objc_msgSend( v92,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v31,  *(unsigned __int8 *)(v31 + 13),  *(void *)(a3 + 16))
              + 1));
      uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue(v32);
      int v33 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
      -[MTLRenderPassDescriptor setRenderTargetWidth:](v33, "setRenderTargetWidth:", *(void *)(v90 + 22464));
      -[MTLRenderPassDescriptor setRenderTargetHeight:](v33, "setRenderTargetHeight:", *(void *)(v90 + 22472));
      __int128 v34 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( &OBJC_CLASS___MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  LOWORD(v98[93]),  *(void *)(v90 + 22464),  *(void *)(v90 + 22472),  0LL));
      [v34 setStorageMode:2];
      id v35 = [v93 newTextureWithDescriptor:v34];
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v33, "colorAttachments"));
      id v37 = (void *)objc_claimAutoreleasedReturnValue([v36 objectAtIndexedSubscript:0]);
      [v37 setTexture:v35];

      id v38 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v33, "colorAttachments"));
      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v38 objectAtIndexedSubscript:0]);
      [v39 setLoadAction:0];

      uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v33, "colorAttachments"));
      id v41 = (void *)objc_claimAutoreleasedReturnValue([v40 objectAtIndexedSubscript:0]);
      [v41 setStoreAction:0];

      if ((GT_SUPPORT_0 & 0x40) != 0) {
        -[MTLRenderPassDescriptor setDefaultRasterSampleCount:](v33, "setDefaultRasterSampleCount:", 1LL);
      }
      unint64_t v42 = v87;
      CommandEncoder = GroupBuilder_getCommandEncoder( *(_DWORD *)(*(void *)(a3 + 112) + 12LL),  *(void **)(*(void *)(a3 + 112) + 24LL),  v87);
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v86 renderCommandEncoderWithDescriptor:v33]);
      uint64_t v45 = *(void *)(a4 + 24) + (*CommandEncoder << 6);
      objc_msgSend( v92,  "setRenderCommandEncoder:forKey:",  v44,  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v45,  *(unsigned __int8 *)(v45 + 13),  *(void *)(a3 + 16))
        + 1));
      *(void *)(a7 + 8544) = 0LL;
      *(void *)(a7 + 9848) = 0LL;
      *(_BYTE *)(a7 + 11085) = 0;
      *(_DWORD *)(a7 + 11076) = 0;
      unint64_t v46 = v92;
      GTMTLReplayController_restoreDefaultRenderCommandEncoder( v44,  *(void *)(v90 + 22464),  *(void *)(v90 + 22472),  (uint64_t *)a7,  v92);

      if ((GT_SUPPORT_0 & 0x20) != 0)
      {
        LODWORD(v47) = 925353388;
        [v44 setTessellationFactorScale:v47];
      }

      [v44 setRenderPipelineState:v84];
      [v44 setVertexBuffer:v83 offset:0 atIndex:v88];
      uint64_t v48 = v85;
      if (*(_DWORD *)(v85 + 8) >> 2 == 1073737833)
      {
        uint64_t v49 = *(void *)(a9 + 240);
        id v50 = (void *)objc_claimAutoreleasedReturnValue([v92 executeIndirectCommandBufferMap]);
        uint64_t v48 = v85;
        uint64_t v27 = a3;
        DYMTLDrawRenderCommandEncoder(v44, a9 + 40, v49, a9 + 152, v50);

        unint64_t v42 = v87;
        apr_pool_clear(*(apr_pool_t **)(a9 + 248));
        uint64_t v51 = v90;
      }

      else
      {
        uint64_t v51 = v90;
        GTMTLReplayController_defaultDispatchFunction(v90, v85);
      }

      GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer(v51, v42);
      [v92 commitCommandBuffers];
      [v86 waitUntilCompleted];
      uint64_t v57 = *v30;
      if (v57 <= v30[1])
      {
        id v25 = v81;
        id v70 = (void *)objc_claimAutoreleasedReturnValue([v81 postVertexDumpOutputs]);
        unint64_t v71 = (SaveObject(v80, v70, 0LL, 0LL) + 259) & 0xFFFFFFFFFFFFFF00LL;
        LODWORD(v72) = *v77;
        unsigned int v73 = v77[1];
        if (*v77 >= v73) {
          uint64_t v72 = v73;
        }
        else {
          uint64_t v72 = v72;
        }
        size_t v74 = (v80 * v72 + 263) & 0xFFFFFFFFFFFFFF00LL;
        uint64_t v23 = v93;
        id v53 = [v93 newBufferWithLength:v74 + v71 options:0];
        unsigned int v75 = (char *)[v53 contents];
        *(_DWORD *)unsigned int v75 = v71;
        SaveObject(v80, v70, v75 + 4, v71 - 4);
        memcpy(&v75[v71], [v83 contents], v74);
      }

      else
      {
        id v58 = [v93 newBufferWithLength:v80 * v57 + 8 options:0];
        id v59 = *(void **)(a10 + 72);
        *(void *)(a10 + 72) = v58;

        memcpy(__dst, (const void *)a7, sizeof(__dst));
        __int128 v60 = *(_OWORD *)(a9 + 208);
        v94[12] = *(_OWORD *)(a9 + 192);
        v94[13] = v60;
        __int128 v61 = *(_OWORD *)(a9 + 240);
        v94[14] = *(_OWORD *)(a9 + 224);
        v94[15] = v61;
        __int128 v62 = *(_OWORD *)(a9 + 144);
        v94[8] = *(_OWORD *)(a9 + 128);
        v94[9] = v62;
        __int128 v63 = *(_OWORD *)(a9 + 176);
        v94[10] = *(_OWORD *)(a9 + 160);
        v94[11] = v63;
        __int128 v64 = *(_OWORD *)(a9 + 80);
        v94[4] = *(_OWORD *)(a9 + 64);
        v94[5] = v64;
        __int128 v65 = *(_OWORD *)(a9 + 112);
        v94[6] = *(_OWORD *)(a9 + 96);
        v94[7] = v65;
        __int128 v66 = *(_OWORD *)(a9 + 16);
        v94[0] = *(_OWORD *)a9;
        v94[1] = v66;
        __int128 v67 = *(_OWORD *)(a9 + 48);
        v94[2] = *(_OWORD *)(a9 + 32);
        void v94[3] = v67;
        unint64_t v68 = v42;
        uint64_t v23 = v93;
        uint64_t PostVertexData = GTMTLReplayController_generatePostVertexData( v51,  v92,  v27,  a4,  v68,  v48,  __dst,  v82,  v94,  a10,  a11);
        id v53 = (id)objc_claimAutoreleasedReturnValue(PostVertexData);
        id v25 = v81;
      }

      int v54 = v91;
      uint64_t v55 = v78;
      unint64_t v22 = v79;
      id v24 = v84;
    }

    else
    {
      uint64_t v55 = v26;
      id v56 = GTPostVertexDataError(2u, @"Post-vertex data fetch pipeline error", 0LL, v26);
      id v53 = 0LL;
      *a11 = (id)objc_claimAutoreleasedReturnValue(v56);
      int v54 = v91;
      unint64_t v46 = v92;
    }
  }

  return v53;
}

id GTPostVertexDataError(unsigned int a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  id v9 = a2;
  uint64_t v10 = -[NSMutableDictionary initWithObjectsAndKeys:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithObjectsAndKeys:",  v9,  NSLocalizedDescriptionKey,  0LL);

  if (v7) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v7,  NSLocalizedRecoverySuggestionErrorKey);
  }
  if (v8) {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v8, NSUnderlyingErrorKey);
  }
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"GTPostVertexDumpErrorDomain",  a1,  v10));

  return v11;
}

uint64_t SaveObject(uint64_t a1, void *a2, void *a3, unint64_t a4)
{
  id v7 = a2;
  id v8 = v7;
  uint64_t v27 = a3;
  unint64_t v29 = a4;
  if (a4 >= 8 && (*a3 = 81LL, a4 > 0xF))
  {
    a3[1] = a1;
    id v22 = [v7 count];
    if (a4 >= 0x18) {
      a3[2] = v22;
    }
  }

  else
  {
    [v7 count];
  }

  uint64_t v9 = 24LL;
  uint64_t v28 = 24LL;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  id v10 = v8;
  id v11 = [v10 countByEnumeratingWithState:&v23 objects:v30 count:16];
  if (v11)
  {
    id v12 = v11;
    uint64_t v13 = *(void *)v24;
    do
    {
      for (uint64_t i = 0LL; i != v12; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v13) {
          objc_enumerationMutation(v10);
        }
        id v15 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)i);
        id v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "airMDType", (void)v23));
        WriteDynamicBufferString(&v27, (const char *)[v16 UTF8String]);

        id v17 = [v15 dataType];
        uint64_t v18 = v28 + 8;
        if (v28 + 8 <= v29) {
          *(void *)((char *)v27 + v28) = v17;
        }
        uint64_t v28 = v18;
        id v19 = objc_claimAutoreleasedReturnValue([v15 name]);
        WriteDynamicBufferString(&v27, (const char *)[v19 UTF8String]);

        id v20 = [v15 offset];
        uint64_t v9 = v28 + 8;
        if (v28 + 8 <= v29) {
          *(void *)((char *)v27 + v28) = v20;
        }
        uint64_t v28 = v9;
      }

      id v12 = [v10 countByEnumeratingWithState:&v23 objects:v30 count:16];
    }

    while (v12);
  }

  return v9;
}

void WriteDynamicBufferString(void *a1, const char *a2)
{
  if (a2) {
    id v3 = a2;
  }
  else {
    id v3 = "";
  }
  size_t v4 = strlen(v3);
  size_t v5 = v4 + 1;
  uint64_t v7 = a1[1];
  size_t v6 = a1[2];
  size_t v8 = v7 + v4 + 1;
  if (v8 <= v6)
  {
    memcpy((void *)(*a1 + v7), v3, v5);
    size_t v6 = a1[2];
    size_t v8 = a1[1] + v5;
  }

  a1[1] = v8;
  unint64_t v9 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + ~v4 + 8;
  BOOL v10 = v6 > v8;
  size_t v11 = v6 - v8;
  if (v10)
  {
    if (v11 >= v9) {
      size_t v12 = v9;
    }
    else {
      size_t v12 = v11;
    }
    bzero((void *)(*a1 + v8), v12);
    size_t v8 = a1[1];
  }

  a1[1] = v8 + v9;
}

uint64_t SaveObjectStruct(uint64_t a1, void *a2, void *a3, void *a4, unint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  uint64_t v45 = a4;
  unint64_t v47 = a5;
  if (a5 >= 8)
  {
    *a4 = 81LL;
    if (a5 >= 0x10) {
      a4[1] = a1;
    }
  }

  size_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 members]);
  id v12 = [v11 count];
  if (a5 >= 0x18) {
    a4[2] = v12;
  }
  uint64_t v13 = 24LL;
  uint64_t v46 = 24LL;

  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  obuint64_t j = (id)objc_claimAutoreleasedReturnValue([v9 members]);
  id v39 = [obj countByEnumeratingWithState:&v41 objects:v48 count:16];
  if (v39)
  {
    id v35 = v9;
    id v36 = v10;
    uint64_t v38 = *(void *)v42;
    id v14 = obj;
    while (1)
    {
      for (uint64_t i = 0LL; i != v39; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v42 != v38) {
          objc_enumerationMutation(v14);
        }
        id v16 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)i);
        id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 name]);
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 componentsSeparatedByString:@"/"]);
        id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 objectAtIndexedSubscript:0]);
        id v20 = &stru_591D98;
        uint64_t v40 = v17;
        if (-[__CFString length](v20, "length")
          || [v19 isEqualToString:@"air.position"])
        {
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v20]);
          if ([v16 dataType] != (char *)&dword_0 + 2)
          {
            if (v21)
            {
              id v24 = [v21 unsignedIntegerValue];
            }

            else
            {
LABEL_33:
              id v24 = [v16 dataType];
              uint64_t v21 = 0LL;
            }

void sub_14B5D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_14B6AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_14B928( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
}

void sub_14BC8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  if (v24 > v23) {
  _Unwind_Resume(a1);
  }
}

void sub_14BEC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_14BF58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_14C16C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_14C320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getRenderPipelineBinaries(void *a1)
{
  id v1 = DEVICEOBJECT(a1);
  uint64_t v2 = objc_claimAutoreleasedReturnValue(v1);
  id v3 = (void *)v2;
  if ((dword_5B9DE4 & 0x200) != 0 && (objc_opt_respondsToSelector(v2, "pipelineBinaries") & 1) != 0) {
    size_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 pipelineBinaries]);
  }
  else {
    size_t v4 = &__NSDictionary0__struct;
  }

  return v4;
}

void sub_14C488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getComputePipelineBinaries(void *a1)
{
  id v1 = DEVICEOBJECT(a1);
  uint64_t v2 = objc_claimAutoreleasedReturnValue(v1);
  id v3 = (void *)v2;
  if ((dword_5B9DE4 & 0x200) != 0 && (objc_opt_respondsToSelector(v2, "pipelineBinaries") & 1) != 0) {
    size_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 pipelineBinaries]);
  }
  else {
    size_t v4 = &__NSDictionary0__struct;
  }

  return v4;
}

void sub_14C504(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayController_dispatchForUSCSampling( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  id v24 = a3;
  id v11 = a5;
  if ((dword_5B9DE4 & 0x200) == 0) {
    goto LABEL_2;
  }
  int v12 = *(_DWORD *)(a2 + 8);
  if (v12 <= -16286)
  {
    if (v12 == -16337)
    {
      uint64_t v21 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a4);
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v24 computeCommandEncoderForKey:*(void *)v21]);
      id v15 = (void *)objc_claimAutoreleasedReturnValue([v24 computePipelineStateForKey:*((void *)v21 + 1)]);
      GTMTLReplayController_defaultDispatchFunction(a1, a2);
      id ComputePipelineBinaries = getComputePipelineBinaries(v15);
      unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(ComputePipelineBinaries);
      [v11 addBinaries:v23];

      goto LABEL_14;
    }

    if (v12 == -16325)
    {
      id v16 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a4);
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v24 computeCommandEncoderForKey:*(void *)v16]);
      id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 endEncodingAndRetrieveProgramAddressTable]);
      objc_msgSend( v11,  "addProgramAddressTable:forEncoder:atEncoderIndex:",  v15,  objc_msgSend(v24, "globalTraceIdForEncoder:ofType:", *(void *)v16, 0),  a6);
      [v24 removeComputeCommandEncoderForKey:*(void *)v16];
      goto LABEL_14;
    }
  }

  else
  {
    switch(v12)
    {
      case -16285:
        id v17 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a4);
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v24 parallelRenderCommandEncoderForKey:*(void *)v17]);
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 endEncodingAndRetrieveProgramAddressTable]);
        objc_msgSend( v11,  "addProgramAddressTable:forEncoder:atEncoderIndex:",  v15,  objc_msgSend(v24, "globalTraceIdForEncoder:ofType:", *(void *)v17, 1),  a6);
        [v24 removeRenderCommandEncoderForKey:*(void *)v17];
        goto LABEL_14;
      case -16279:
        id v18 = objc_msgSend( v24,  "renderPipelineStateForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a4) + 1));
        id v14 = (void *)objc_claimAutoreleasedReturnValue(v18);
        id RenderPipelineBinaries = getRenderPipelineBinaries(v14);
        id v20 = (void *)objc_claimAutoreleasedReturnValue(RenderPipelineBinaries);
        [v11 addBinaries:v20];

        GTMTLReplayController_defaultDispatchFunction(a1, a2);
LABEL_15:

        goto LABEL_16;
      case -16246:
        uint64_t v13 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a4);
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v24 renderCommandEncoderForKey:*(void *)v13]);
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 endEncodingAndRetrieveProgramAddressTable]);
        objc_msgSend( v11,  "addProgramAddressTable:forEncoder:atEncoderIndex:",  v15,  objc_msgSend(v24, "globalTraceIdForEncoder:ofType:", *(void *)v13, 0),  a6);
        [v24 removeRenderCommandEncoderForKey:*(void *)v13];
LABEL_14:

        goto LABEL_15;
    }
  }

void sub_14C7E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ProcessMessage(uint64_t a1, void *a2, void *a3)
{
  id v235 = a2;
  id v5 = a3;
  unsigned int v6 = [v5 serial];
  os_signpost_id_t v7 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v5);
  v234 = objc_autoreleasePoolPush();
  int v8 = [v5 kind];
  if (v8 <= 1793)
  {
    if (v8 > 1536)
    {
      switch(v8)
      {
        case 1537:
          id v28 = v235;
          id v22 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:attributes:",  4096LL,  &off_5A01A0));
          [v28 send:v22 error:0];
LABEL_47:

LABEL_48:
          break;
        case 1540:
          uint64_t v48 = g_signpostLog;
          uint64_t v49 = (os_log_s *)v48;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v48))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v6;
            _os_signpost_emit_with_name_impl( &dword_0,  v49,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageGuestAppInvalidateSavePointerAliases",  buf,  8u);
          }

          id v50 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:]( GTTransportMessage_replayer,  "messageWithKind:",  [v5 kind]));
          [v235 send:v50 inReplyTo:v5 error:0];

          break;
        case 1793:
          uint64_t v30 = g_signpostLog;
          uint64_t v31 = (os_log_s *)v30;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v30))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v6;
            _os_signpost_emit_with_name_impl( &dword_0,  v31,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageTraceConfiguration",  buf,  8u);
          }

          id v32 = [v5 uint32ForKey:@"trace mode"];
          *(_DWORD *)(a1 + 56) = (_DWORD)v32;
          SetTraceMode(v235, (uint64_t)v32);
          *(void *)(a1 + 24) = [v5 uint64ForKey:@"trace host type"];
          *(void *)(a1 + 32) = [v5 uint64ForKey:@"profiling send period"];
          *(void *)(a1 + 40) = [v5 uint64ForKey:@"profiling flags"];
          break;
      }
    }

    else
    {
      switch(v8)
      {
        case 1026:
          uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
          id v39 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"object"]);
          id v40 = [v39 unsignedLongLongValue];

          __int128 v41 = g_signpostLog;
          __int128 v42 = (os_log_s *)v41;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v41))
          {
            *(_DWORD *)__int128 buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v6;
            LOWORD(v343) = 2048;
            *(void *)((char *)&v343 + 2) = v40;
            _os_signpost_emit_with_name_impl( &dword_0,  v42,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageFetchResourceObject %{xcode:address}llu",  buf,  0x12u);
          }

          __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
          v303[0] = _NSConcreteStackBlock;
          v303[1] = 3221225472LL;
          v303[2] = __ProcessMessage_block_invoke_54;
          v303[3] = &unk_58EE90;
          uint64_t v306 = a1;
          id v304 = v235;
          id v305 = v5;
          os_signpost_id_t v307 = v7;
          unsigned int v308 = v6;
          FetchResourceObject((id *)a1, v43, v303);

          break;
        case 1028:
          __int128 v44 = g_signpostLog;
          uint64_t v45 = (os_log_s *)v44;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v44))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v6;
            _os_signpost_emit_with_name_impl( &dword_0,  v45,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageUpdateResourceObject",  buf,  8u);
          }

          v236[0] = _NSConcreteStackBlock;
          v236[1] = 3221225472LL;
          v236[2] = __ProcessMessage_block_invoke_188;
          v236[3] = &unk_58EDD0;
          uint64_t v46 = *(void *)(a1 + 64);
          id v237 = v5;
          os_signpost_id_t v239 = v7;
          uint64_t v240 = a1;
          unsigned int v241 = v6;
          id v238 = v235;
          uint64_t v242 = v46;
          unint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v236));
          [*(id *)(a1 + 256) addOperation:v47];

          break;
        case 1030:
          id v18 = g_signpostLog;
          id v19 = (os_log_s *)v18;
          if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v18))
          {
            *(_DWORD *)__int128 buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v6;
            _os_signpost_emit_with_name_impl( &dword_0,  v19,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYGenerateShaderDebuggerTrace",  buf,  8u);
          }

          id v20 = *(void **)(a1 + 256);
          v248[0] = _NSConcreteStackBlock;
          v248[1] = 3221225472LL;
          v248[2] = __ProcessMessage_block_invoke_177;
          v248[3] = &unk_58EEE0;
          id v249 = v5;
          os_signpost_id_t v251 = v7;
          uint64_t v252 = a1;
          unsigned int v253 = v6;
          id v250 = v235;
          [v20 addOperationWithBlock:v248];

          break;
      }
    }
  }

  else
  {
    switch(v8)
    {
      case 4098:
        id v9 = g_signpostLog;
        id v10 = (os_log_s *)v9;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v9))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v7,  "Replayer-1-serial",  "%u. kDYMessageReplayerReplayArchive",  buf,  8u);
        }

        id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 stringPayload]);
        int v12 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"archivedExperiments"]);
        id v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"queryAvailableCounters"]);
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"profileCounters"]);
        id v16 = g_signpostLog;
        id v17 = (os_log_s *)v16;
        if (v7 - 1 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v16))
        {
          *(_WORD *)__int128 buf = 0;
          _os_signpost_emit_with_name_impl( &dword_0,  v17,  OS_SIGNPOST_INTERVAL_END,  v7,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
        }

        break;
      case 4099:
      case 4100:
      case 4101:
      case 4105:
      case 4110:
      case 4111:
      case 4112:
      case 4113:
      case 4115:
      case 4116:
      case 4123:
      case 4124:
      case 4126:
      case 4127:
      case 4128:
        break;
      case 4102:
        uint64_t v51 = g_signpostLog;
        id v52 = (os_log_s *)v51;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v51))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v52,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDeleteAllArchives",  buf,  8u);
        }

        id v53 = *(void **)(a1 + 256);
        v316[0] = _NSConcreteStackBlock;
        v316[1] = 3221225472LL;
        v316[2] = __ProcessMessage_block_invoke_44;
        v316[3] = &unk_58EDF8;
        id v317 = v5;
        os_signpost_id_t v319 = v7;
        unsigned int v320 = v6;
        id v318 = v235;
        [v53 addBarrierBlock:v316];

        break;
      case 4103:
        int v54 = (void *)objc_claimAutoreleasedReturnValue([v5 stringPayload]);
        uint64_t v55 = g_signpostLog;
        id v56 = (os_log_s *)v55;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v55))
        {
          *(_DWORD *)__int128 buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 2082;
          *(void *)((char *)&v343 + 2) = [v54 UTF8String];
          _os_signpost_emit_with_name_impl( &dword_0,  v56,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerBeginDebugArchive %{public}s",  buf,  0x12u);
        }

        dispatch_semaphore_t v57 = dispatch_semaphore_create(0LL);
        id v58 = *(void **)(a1 + 256);
        v310[0] = _NSConcreteStackBlock;
        v310[1] = 3221225472LL;
        v310[2] = __ProcessMessage_block_invoke_45;
        v310[3] = &unk_58EE48;
        uint64_t v315 = a1;
        id v311 = v5;
        id v312 = v54;
        id v313 = v235;
        dispatch_semaphore_t v314 = v57;
        id v59 = v57;
        id v60 = v54;
        [v58 addBarrierBlock:v310];
        dispatch_semaphore_wait(v59, 0xFFFFFFFFFFFFFFFFLL);

        break;
      case 4104:
        __int128 v61 = g_signpostLog;
        __int128 v62 = (os_log_s *)v61;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v61))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v62,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerEndDebugArchive",  buf,  8u);
        }

        break;
      case 4106:
        __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
        id v64 = [v63 unsignedLongLongValue];

        __int128 v65 = g_signpostLog;
        __int128 v66 = (os_log_s *)v65;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v65))
        {
          *(_DWORD *)__int128 buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 1024;
          *(_DWORD *)((char *)&v343 + 2) = (_DWORD)v64;
          _os_signpost_emit_with_name_impl( &dword_0,  v66,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDebugFuncStop %u",  buf,  0xEu);
        }

        __int128 v67 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  4105LL,  &__kCFBooleanTrue));
        [v235 send:v67 inReplyTo:v5 error:0];

        if (*(id *)(a1 + 64) != v64)
        {
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = __ProcessMessage_block_invoke_51;
          block[3] = &__block_descriptor_40_e5_v8__0l;
          block[4] = a1;
          dispatch_async(&_dispatch_main_q, block);
          *(void *)(a1 + 64) = v64;
          DisplayAttachmentIfNeeded(a1, (int)v64, SHIDWORD(v64));
        }

        break;
      case 4107:
        unint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
        else {
          int v69 = 0;
        }
        *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFFFFD | v69;

        id v70 = g_signpostLog;
        unint64_t v71 = (os_log_s *)v70;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v70))
        {
          int v72 = (*(_DWORD *)(a1 + 84) >> 1) & 1;
          *(_DWORD *)__int128 buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 1024;
          *(_DWORD *)((char *)&v343 + 2) = v72;
          _os_signpost_emit_with_name_impl( &dword_0,  v71,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDebugEnableWireframePresent %d",  buf,  0xEu);
        }

        goto LABEL_116;
      case 4108:
        unsigned int v73 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
        *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFFFFE | [v73 BOOLValue];

        size_t v74 = g_signpostLog;
        unint64_t v71 = (os_log_s *)v74;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v74))
        {
          int v75 = *(_DWORD *)(a1 + 84) & 1;
          *(_DWORD *)__int128 buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 1024;
          *(_DWORD *)((char *)&v343 + 2) = v75;
          _os_signpost_emit_with_name_impl( &dword_0,  v71,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDebugEnableDrawCallPresent %d",  buf,  0xEu);
        }

        goto LABEL_116;
      case 4109:
        __int128 v76 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
        [v76 floatValue];
        *(_DWORD *)(a1 + 80) = v77;

        id v78 = g_signpostLog;
        int v79 = (os_log_s *)v78;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v78))
        {
          double v80 = *(float *)(a1 + 80);
          *(_DWORD *)__int128 buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 2048;
          *(double *)((char *)&v343 + 2) = v80;
          _os_signpost_emit_with_name_impl( &dword_0,  v79,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDebugWireframeLineWidth %f",  buf,  0x12u);
        }

        __int128 v81 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  4105LL,  &__kCFBooleanTrue));
        [v235 send:v81 inReplyTo:v5 error:0];

        break;
      case 4114:
        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v5 plistPayload]);
        id v83 = (void *)objc_claimAutoreleasedReturnValue([v82 objectAtIndexedSubscript:0]);
        id v84 = g_signpostLog;
        uint64_t v85 = (os_log_s *)v84;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v84))
        {
          *(_DWORD *)__int128 buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 2082;
          *(void *)((char *)&v343 + 2) = [v83 UTF8String];
          _os_signpost_emit_with_name_impl( &dword_0,  v85,  OS_SIGNPOST_INTERVAL_BEGIN,  v7,  "Replayer-1-serial",  "%u. kDYMessageReplayerLoadArchives %{public}s",  buf,  0x12u);
        }

        dispatch_semaphore_t v86 = dispatch_semaphore_create(0LL);
        unint64_t v87 = *(void **)(a1 + 256);
        v243[0] = _NSConcreteStackBlock;
        v243[1] = 3221225472LL;
        v243[2] = __ProcessMessage_block_invoke_178;
        v243[3] = &unk_58F860;
        id v88 = v5;
        id v244 = v88;
        id v89 = v83;
        id v245 = v89;
        uint64_t v247 = a1;
        uint64_t v90 = v86;
        __int128 v246 = v90;
        [v87 addBarrierBlock:v243];
        dispatch_semaphore_wait(v90, 0xFFFFFFFFFFFFFFFFLL);
        BOOL v91 = *(void *)(a1 + 8) != 0LL;
        id v92 = [v88 kind];
        unint64_t v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v91));
        __int128 v94 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  v92,  v93));
        [v235 send:v94 inReplyTo:v88 error:0];

        uint64_t v95 = g_signpostLog;
        id v96 = (os_log_s *)v95;
        if (v7 - 1 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled((os_log_t)v95))
        {
          *(_WORD *)__int128 buf = 0;
          _os_signpost_emit_with_name_impl( &dword_0,  v96,  OS_SIGNPOST_INTERVAL_END,  v7,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
        }

        break;
      case 4117:
        id v97 = g_signpostLog;
        __int128 v98 = (os_log_s *)v97;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v97))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v98,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerQueryShaderInfo",  buf,  8u);
        }

        v263[0] = _NSConcreteStackBlock;
        v263[1] = 3221225472LL;
        v263[2] = __ProcessMessage_block_invoke_131;
        v263[3] = &unk_58EEE0;
        uint64_t v266 = a1;
        os_signpost_id_t v267 = v7;
        unsigned int v268 = v6;
        id v264 = v235;
        id v265 = v5;
        id v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v263));
        [*(id *)(a1 + 264) addOperation:v99];

        break;
      case 4118:
        int v100 = g_signpostLog;
        __int128 v101 = (os_log_s *)v100;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v100))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v101,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDerivedCounterData",  buf,  8u);
        }

        __int128 v102 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
        uint64_t v103 = (void *)objc_claimAutoreleasedReturnValue([v102 objectForKeyedSubscript:@"profileCounters"]);
        if (v103)
        {
          uint64_t v104 = *(void **)(a1 + 264);
          v254[0] = _NSConcreteStackBlock;
          v254[1] = 3221225472LL;
          v254[2] = __ProcessMessage_block_invoke_171;
          v254[3] = &unk_58EFA8;
          uint64_t v256 = a1;
          BOOL v105 = v254;
          v254[4] = v5;
          v254[5] = v102;
          id v255 = v235;
          os_signpost_id_t v257 = v7;
          unsigned int v258 = v6;
          [v104 addOperationWithBlock:v254];

          goto LABEL_194;
        }

        signed int v214 = (void *)objc_claimAutoreleasedReturnValue([v102 objectForKeyedSubscript:@"pause"]);
        if (v214)
        {

LABEL_193:
          id v222 = *(void **)(a1 + 264);
          v261[0] = _NSConcreteStackBlock;
          v261[1] = 3221225472LL;
          v261[2] = __ProcessMessage_block_invoke_167;
          v261[3] = &unk_58EF80;
          BOOL v105 = v261;
          v261[4] = v102;
          v261[5] = v235;
          id v262 = v5;
          [v222 addOperationWithBlock:v261];

          goto LABEL_194;
        }

        int v220 = (void *)objc_claimAutoreleasedReturnValue([v102 objectForKeyedSubscript:@"resume"]);
        BOOL v221 = v220 == 0LL;

        if (!v221) {
          goto LABEL_193;
        }
        uint64_t v223 = *(void **)(a1 + 264);
        v259[0] = _NSConcreteStackBlock;
        v259[1] = 3221225472LL;
        v259[2] = __ProcessMessage_block_invoke_2_170;
        v259[3] = &unk_58EEE0;
        unsigned int v260 = v6;
        v259[6] = v7;
        v259[7] = a1;
        BOOL v105 = v259;
        v259[4] = v235;
        v259[5] = v5;
        [v223 addOperationWithBlock:v259];
LABEL_194:

        break;
      case 4119:
        BOOL v106 = g_signpostLog;
        int v107 = (os_log_s *)v106;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v106))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v107,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerGenerateThumbnails",  buf,  8u);
        }

        v288[0] = _NSConcreteStackBlock;
        v288[1] = 3221225472LL;
        v288[2] = __ProcessMessage_block_invoke_77;
        v288[3] = &unk_58EEE0;
        id v289 = v5;
        os_signpost_id_t v291 = v7;
        unsigned int v293 = v6;
        uint64_t v292 = a1;
        id v290 = v235;
        uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v288));
        [v108 setQueuePriority:4];
        [*(id *)(a1 + 256) addOperation:v108];

        break;
      case 4120:
        id v109 = g_signpostLog;
        uint64_t v110 = (os_log_s *)v109;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v109))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v110,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerGenerateDependencyGraphThumbnails",  buf,  8u);
        }

        v282[0] = _NSConcreteStackBlock;
        v282[1] = 3221225472LL;
        v282[2] = __ProcessMessage_block_invoke_78;
        v282[3] = &unk_58EEE0;
        id v283 = v5;
        os_signpost_id_t v285 = v7;
        unsigned int v287 = v6;
        uint64_t v286 = a1;
        id v284 = v235;
        id v111 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v282));
        [v111 setQueuePriority:4];
        [*(id *)(a1 + 256) addOperation:v111];

        break;
      case 4121:
        int v112 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
        __int128 v113 = (void *)objc_claimAutoreleasedReturnValue([v112 objectForKeyedSubscript:@"stream"]);

        __int128 v114 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
        unint64_t v115 = (void *)objc_claimAutoreleasedReturnValue([v114 objectForKeyedSubscript:@"compressed"]);

        v300[0] = _NSConcreteStackBlock;
        v300[1] = 3221225472LL;
        v300[2] = __ProcessMessage_block_invoke_74;
        v300[3] = &unk_58EEB8;
        id v301 = v235;
        id v302 = v5;
        FetchResourceObjectBatch(a1, v113, v115, v300);

        break;
      case 4122:
        id v116 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
        else {
          int v117 = 0;
        }
        *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 84) & 0xFFFFFFFB | v117;

        int v118 = g_signpostLog;
        unint64_t v71 = (os_log_s *)v118;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v118))
        {
          int v119 = (*(_DWORD *)(a1 + 84) >> 2) & 1;
          *(_DWORD *)__int128 buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v6;
          LOWORD(v343) = 1024;
          *(_DWORD *)((char *)&v343 + 2) = v119;
          _os_signpost_emit_with_name_impl( &dword_0,  v71,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerDebugEnableOutlinePresent %d",  buf,  0xEu);
        }

LABEL_116:
        DisplayAttachmentIfNeeded(a1, *(_DWORD *)(a1 + 64), *(_DWORD *)(a1 + 68));
        char v120 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  4105LL,  &__kCFBooleanTrue));
        [v235 send:v120 inReplyTo:v5 error:0];

        break;
      case 4125:
        uint64_t v121 = g_signpostLog;
        uint64_t v122 = (os_log_s *)v121;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v121))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v122,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kGTMessageQueryInducedGPUPerfState",  buf,  8u);
        }

        uint64_t v123 = *(void **)(a1 + 256);
        v276[0] = _NSConcreteStackBlock;
        v276[1] = 3221225472LL;
        v276[2] = __ProcessMessage_block_invoke_79;
        v276[3] = &unk_58EEE0;
        id v277 = v5;
        os_signpost_id_t v279 = v7;
        unsigned int v281 = v6;
        uint64_t v280 = a1;
        id v278 = v235;
        [v123 addOperationWithBlock:v276];

        break;
      case 4129:
        int v124 = g_signpostLog;
        uint64_t v125 = (os_log_s *)v124;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v124))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v125,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kGTMessageReplayerResourcesUsedForFunctionIndex",  buf,  8u);
        }

        uint64_t v126 = *(void **)(a1 + 256);
        v294[0] = _NSConcreteStackBlock;
        v294[1] = 3221225472LL;
        v294[2] = __ProcessMessage_block_invoke_76;
        v294[3] = &unk_58EEE0;
        id v295 = v5;
        os_signpost_id_t v297 = v7;
        unsigned int v299 = v6;
        uint64_t v298 = a1;
        id v296 = v235;
        [v126 addOperationWithBlock:v294];

        break;
      case 4130:
        id v127 = g_signpostLog;
        id v128 = (os_log_s *)v127;
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v127))
        {
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v6;
          _os_signpost_emit_with_name_impl( &dword_0,  v128,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kGTMessageReplayerQueryAPSData",  buf,  8u);
        }

        __int16 v129 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 8) + 8) defaultDevice]);
        id v130 = DEVICEOBJECT(v129);
        uint64_t v131 = (void *)objc_claimAutoreleasedReturnValue(v130);
        io_registry_entry_t v132 = [v131 acceleratorPort];

        LODWORD(v345) = 0x7FFFFFFF;
        id MetalPluginName = GetMetalPluginName(v132, &v345);
        BOOL v230 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
        unsigned int v135 = IsAGXMetalPlugin(v230, v134);
        else {
          unsigned int v136 = 0;
        }
        if (v136 == 1)
        {
          id DerivedDataPayload = GTMTLReplayHost_generateDerivedDataPayload(**(void **)(a1 + 8), 1);
          __int128 v227 = (void *)objc_claimAutoreleasedReturnValue(DerivedDataPayload);
          size_t v228 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v227));
          unint64_t v232 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
          __int128 v225 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
          if (v232)
          {
            unint64_t v138 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"UseMTLCounters"]);
            BOOL v139 = v138 == 0LL;

            if (!v139) {
              [v228 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseMTLCounters"];
            }
            id v140 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"UseKicktimestamps"]);
            BOOL v141 = v140 == 0LL;

            if (!v141) {
              [v228 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseKicktimestamps"];
            }
            unint64_t v142 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"CoalesceComputeEncoders"]);
            BOOL v143 = v142 == 0LL;

            if (!v143) {
              [v228 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CoalesceComputeEncoders"];
            }
            uint64_t v144 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"CoalesceBlitEncoders"]);
            BOOL v145 = v144 == 0LL;

            if (!v145) {
              [v228 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CoalesceBlitEncoders"];
            }
            __int128 v146 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"GPUState"]);
            if (v146) {
              [v228 setObject:v146 forKeyedSubscript:@"GPUState"];
            }
            __int128 v147 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"ProfilingConfig"]);
            BOOL v148 = v147 == 0LL;

            if (!v148)
            {
              __int128 v149 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"ProfilingConfig"]);
              [v228 setObject:v149 forKeyedSubscript:@"ProfilingConfig"];
            }

            __int128 v150 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"CounterConfig"]);
            BOOL v151 = v150 == 0LL;

            if (!v151)
            {
              __int128 v152 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"CounterConfig"]);
              [v228 setObject:v152 forKeyedSubscript:@"CounterConfig"];
            }

            std::__split_buffer<std::string> v153 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"TimelineConfig"]);
            BOOL v154 = v153 == 0LL;

            if (!v154)
            {
              uint64_t v155 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"TimelineConfig"]);
              [v228 setObject:v155 forKeyedSubscript:@"TimelineConfig"];
            }

            unint64_t v156 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"useOverlap"]);
            BOOL v157 = v156 == 0LL;

            if (!v157)
            {
              id v158 = (void *)objc_claimAutoreleasedReturnValue([v232 objectForKeyedSubscript:@"useOverlap"]);
              [v228 setObject:v158 forKeyedSubscript:@"useOverlap"];
            }
          }

          [v228 setObject:v230 forKeyedSubscript:@"MetalPluginName"];
          uint64_t v161 = v345;
          if ((_DWORD)v345 != 0x7FFFFFFF)
          {
            int v162 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:"));
            [v228 setObject:v162 forKeyedSubscript:@"gpuTarget"];
          }

          id v163 = GTShaderProfilerStreamDataFromReplayDataSource(**(uint64_t ****)(a1 + 8), v159, v161, v160);
          unint64_t v164 = (void *)objc_claimAutoreleasedReturnValue(v163);
          id context = objc_autoreleasePoolPush();
          v340[0] = @"Streaming APS Data";
          v340[1] = @"MetalPluginName";
          v341[0] = &__kCFBooleanTrue;
          v341[1] = v230;
          v340[2] = @"gpuTarget";
          unint64_t v165 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v345));
          v341[2] = v165;
          int v226 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v341,  v340,  3LL));

          __int128 v166 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  [v5 kind],  v226));
          [v235 send:v166 inReplyTo:v5 error:0];

          dispatch_semaphore_t v167 = dispatch_semaphore_create(0LL);
          *(void *)__int128 buf = 0LL;
          *(void *)&__int128 v343 = buf;
          *((void *)&v343 + 1) = 0x2020000000LL;
          char v344 = 0;
          *(void *)&__int128 v332 = 0LL;
          *((void *)&v332 + 1) = &v332;
          *(void *)&__int128 v333 = 0x2020000000LL;
          BYTE8(v333) = 0;
          uint64_t v168 = *(void *)(a1 + 8);
          unsigned int v169 = (id *)(a1 + 256);
          v271[0] = _NSConcreteStackBlock;
          v271[1] = 3221225472LL;
          v271[2] = __ProcessMessage_block_invoke_117;
          v271[3] = &unk_58EF08;
          unsigned int v170 = v167;
          uint64_t v272 = v170;
          uint64_t v274 = buf;
          id v171 = v164;
          id v273 = v171;
          uint64_t v275 = &v332;
          GTMTLReplayClient_collectAPSData(v168, v169, v228, v271);
          unsigned int v172 = v170;
          dispatch_semaphore_wait(v170, 0xFFFFFFFFFFFFFFFFLL);
          uint64_t v173 = objc_claimAutoreleasedReturnValue([v171 traceName]);
          unsigned int v174 = (void *)v173;
          unsigned int v175 = @"local";
          if (v173) {
            unsigned int v175 = (const __CFString *)v173;
          }
          unsigned int v176 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"/tmp/com.apple.gputools.profiling/%@.gpuprofiler_raw",  v175));

          [v171 setMetalPluginName:v230];
          unsigned int v177 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          unsigned int v178 = (void *)objc_claimAutoreleasedReturnValue([v176 stringByDeletingLastPathComponent]);
          [v177 createDirectoryAtPath:v178 withIntermediateDirectories:1 attributes:0 error:0];

          if ([v177 fileExistsAtPath:v176])
          {
            uint64_t v270 = 0LL;
            [v177 removeItemAtPath:v176 error:&v270];
          }

          id v269 = 0LL;
          unsigned int v179 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v171,  1LL,  &v269));
          id v180 = v269;
          [v179 writeToFile:v176 atomically:0];
          int v338 = @"Profiler Raw";
          uint64_t v339 = v179;
          unsigned int v181 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v339,  &v338,  1LL));
          unsigned int v182 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  v181));
          [v235 send:v182 inReplyTo:0 error:0];

          _Block_object_dispose(&v332, 8);
          _Block_object_dispose(buf, 8);

          objc_autoreleasePoolPop(context);
        }

        break;
      default:
        switch(v8)
        {
          case 4609:
            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v5 attributes]);
            id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 objectForKeyedSubscript:@"sessionId"]);

            if (!v22 || (objc_opt_respondsToSelector(v22, "unsignedIntegerValue") & 1) == 0) {
              goto LABEL_48;
            }
            id v23 = [v22 unsignedIntegerValue];
            uint64_t v24 = *(void *)(a1 + 8);
            unint64_t v25 = *(dispatch_semaphore_s **)(v24 + 48);
            v24 += 48LL;
            dispatch_semaphore_wait(v25, 0xFFFFFFFFFFFFFFFFLL);
            uint64_t v26 = *(void **)(v24 + 8);
            id v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v23));
            id v28 = (id)objc_claimAutoreleasedReturnValue([v26 objectForKey:v27]);

            dispatch_semaphore_signal(*(dispatch_semaphore_t *)v24);
            if (v28)
            {
              id v29 = (void *)objc_claimAutoreleasedReturnValue([v5 payload]);
              [v28 receiveData:v29];
            }

            goto LABEL_47;
          case 4610:
            unsigned int v183 = (void *)objc_claimAutoreleasedReturnValue([v5 objectPayload]);
            int v184 = (void *)objc_claimAutoreleasedReturnValue([v183 objectForKeyedSubscript:@"sessionId"]);
            id v185 = [v184 unsignedIntegerValue];

            uint64_t v186 = *(void *)(a1 + 8);
            dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v186 + 48), 0xFFFFFFFFFFFFFFFFLL);
            unsigned int v187 = *(void **)(v186 + 56);
            unsigned int v188 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v185));
            BOOL v189 = (void *)objc_claimAutoreleasedReturnValue([v187 objectForKey:v188]);

            if (v189)
            {
              id v190 = *(void **)(v186 + 56);
              signed int v191 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v185));
              [v190 removeObjectForKey:v191];
            }

            else
            {
              NSLog(@"ASV session %llu does not exist", v185);
            }

            dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v186 + 48));
            id v215 = [v5 kind];
            char v336 = @"sessionId";
            unsigned int v216 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v185));
            v337 = v216;
            int v217 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v337,  &v336,  1LL));
            int v218 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  v215,  v217));

            [v235 send:v218 inReplyTo:v5 error:0];
            goto LABEL_195;
          case 4611:
            uint64_t v192 = g_signpostLog;
            uint64_t v193 = (os_log_s *)v192;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v192))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v6;
              _os_signpost_emit_with_name_impl( &dword_0,  v193,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerGenerateListOfDebugFilesInCache",  buf,  8u);
            }

            __int128 v194 = ArchiveDirectory();
            unsigned int v233 = (void *)objc_claimAutoreleasedReturnValue(v194);
            uint64_t v229 = -[NSURL initFileURLWithPath:](objc_alloc(&OBJC_CLASS___NSURL), "initFileURLWithPath:", v233);
            __int128 v231 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
            NSURLResourceKey v345 = NSURLNameKey;
            signed int v195 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v345,  1LL));
            uint64_t v196 = (void *)objc_claimAutoreleasedReturnValue( [v231 enumeratorAtURL:v229 includingPropertiesForKeys:v195 options:17 errorHandler:0]);

            char v197 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            __int128 v335 = 0u;
            __int128 v334 = 0u;
            __int128 v333 = 0u;
            __int128 v332 = 0u;
            id v198 = v196;
            id v199 = [v198 countByEnumeratingWithState:&v332 objects:buf count:16];
            if (v199)
            {
              uint64_t v200 = *(void *)v333;
              do
              {
                for (uint64_t i = 0LL; i != v199; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v333 != v200) {
                    objc_enumerationMutation(v198);
                  }
                  uint64_t v202 = *(void **)(*((void *)&v332 + 1) + 8LL * (void)i);
                  uint64_t v203 = (void *)objc_claimAutoreleasedReturnValue([v202 lastPathComponent]);
                  id v204 = (void *)objc_claimAutoreleasedReturnValue([v203 stringByDeletingPathExtension]);

                  uint64_t v205 = (void *)objc_claimAutoreleasedReturnValue([v202 pathExtension]);
                  LODWORD(v203) = [v205 isEqualToString:@"metallib"];

                  if ((_DWORD)v203) {
                    -[NSMutableArray addObject:](v197, "addObject:", v204);
                  }
                }

                id v199 = [v198 countByEnumeratingWithState:&v332 objects:buf count:16];
              }

              while (v199);
            }

            uint64_t v206 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  4611LL,  v197));
            [v235 send:v206 inReplyTo:v5 error:0];

            goto LABEL_195;
          case 4612:
            uint64_t v207 = g_signpostLog;
            int v208 = (os_log_s *)v207;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v207))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v6;
              _os_signpost_emit_with_name_impl( &dword_0,  v208,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerSendDebuggingFiles",  buf,  8u);
            }

            v328[0] = _NSConcreteStackBlock;
            v328[1] = 3221225472LL;
            v328[2] = __ProcessMessage_block_invoke;
            v328[3] = &unk_58EDA8;
            id v329 = v5;
            uint64_t v331 = a1;
            id v330 = v235;
            uint64_t v209 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v328));
            [*(id *)(a1 + 256) addOperation:v209];

            goto LABEL_195;
          case 4613:
            unsigned int v210 = g_signpostLog;
            id v211 = (os_log_s *)v210;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v210))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v6;
              _os_signpost_emit_with_name_impl( &dword_0,  v211,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageReplayerUpdateLibraries",  buf,  8u);
            }

            v321[0] = _NSConcreteStackBlock;
            v321[1] = 3221225472LL;
            v321[2] = __ProcessMessage_block_invoke_41;
            v321[3] = &unk_58EDD0;
            uint64_t v212 = *(void *)(a1 + 64);
            id v322 = v5;
            os_signpost_id_t v324 = v7;
            unsigned int v326 = v6;
            uint64_t v325 = a1;
            id v323 = v235;
            uint64_t v327 = v212;
            id v213 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v321));
            [*(id *)(a1 + 256) addOperation:v213];

            goto LABEL_195;
          default:
            if (v8 != 1794) {
              goto LABEL_195;
            }
            uint64_t v33 = g_signpostLog;
            __int128 v34 = (os_log_s *)v33;
            if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v33))
            {
              *(_DWORD *)__int128 buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v6;
              _os_signpost_emit_with_name_impl( &dword_0,  v34,  OS_SIGNPOST_EVENT,  v7,  "Replayer-5-network",  "%u. kDYMessageTraceOverridesConfiguration",  buf,  8u);
            }

            unsigned int v35 = [v5 uint32ForKey:@"override_flags"];
            unsigned int v36 = v35;
            if (v35 == *(_DWORD *)(a1 + 60)) {
              goto LABEL_190;
            }
            if (v35)
            {
              if (*(_DWORD *)(a1 + 56) == 7) {
                goto LABEL_189;
              }
              uint64_t v37 = 7LL;
            }

            else
            {
              uint64_t v37 = 1LL;
            }

            SetTraceMode(v235, v37);
LABEL_189:
            *(_DWORD *)(a1 + 60) = v36;
LABEL_190:
            if ((v36 & 0x40) != 0)
            {
              [v5 doubleForKey:@"override_scale_tesselation_factor"];
              *(void *)(a1 + 48) = v219;
            }

            break;
        }

        break;
    }
  }

      dispatch_semaphore_t v57 = *(void *)(v55 + 8);
      if (v51.u32[0] > 1uLL)
      {
        if (v57 >= *(void *)&v49) {
          v57 %= *(void *)&v49;
        }
      }

      else
      {
        v57 &= *(void *)&v49 - 1LL;
      }

      if (v57 != v50)
      {
        *(void *)(*v8 + 8 * v57) = v53;
        uint64_t v55 = *(void *)v9;
      }
    }

    *id v53 = v55;
    --v8[3];
    operator delete(v9);
LABEL_123:
    id v9 = v26;
  }

  while (v26);
LABEL_124:
  id v58 = a4;
  id v59 = a4 >> 1;
  if ((a4 & 1) != 0)
  {
    int v117 = a3;
    __int128 v67 = *(void *)this + 88LL * a2;
    id v70 = *(void *)(v67 + 48);
    unint64_t v68 = v67 + 48;
    int v69 = v70;
    if (v70)
    {
      unint64_t v71 = v68;
      do
      {
        int v72 = *(_DWORD *)(v69 + 28);
        unsigned int v73 = v72 >= a3;
        if (v72 >= a3) {
          size_t v74 = (uint64_t *)v69;
        }
        else {
          size_t v74 = (uint64_t *)(v69 + 8);
        }
        if (v73) {
          unint64_t v71 = v69;
        }
        int v69 = *v74;
      }

      while (*v74);
      if (v71 != v68 && *(_DWORD *)(v71 + 28) <= a3)
      {
        int v75 = *(_DWORD *)(v71 + 32);
        *(_DWORD *)(v71 + 32) = (v75 & 0xFFFF0000 | (unsigned __int16)(v75 - 1)) & ((~(1 << (a4 & 0xFE) << v59) << 16) | 0xFFFF);
        if ((_WORD)v75 == 1)
        {
          std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (float *)this + 36,  a3,  &v117)[4] = a5;
          std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( *(void *)this + 88LL * a2,  *(_DWORD *)(v71 + 28),  *(_DWORD *)(v71 + 28));
        }

        __int128 v76 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)this + 5 * v59 + 23,  a3);
        if (v76) {
          v76[4] = a5;
        }
      }
    }
  }

  else
  {
    int v118 = a3;
    id v60 = *(void *)this + 88LL * a2;
    __int128 v63 = *(uint64_t **)(v60 + 48);
    __int128 v61 = (uint64_t **)(v60 + 48);
    __int128 v62 = v63;
    if (v63)
    {
      while (1)
      {
        while (1)
        {
          id v64 = v62;
          __int128 v65 = *((_DWORD *)v62 + 7);
          if (v65 <= a3) {
            break;
          }
          __int128 v62 = (uint64_t *)*v64;
          __int128 v66 = (uint64_t **)v64;
          if (!*v64) {
            goto LABEL_148;
          }
        }

        if (v65 >= a3) {
          break;
        }
        __int128 v62 = (uint64_t *)v64[1];
        if (!v62)
        {
          __int128 v66 = (uint64_t **)(v64 + 1);
          goto LABEL_148;
        }
      }
    }

    else
    {
      __int128 v66 = v61;
      id v64 = v61;
LABEL_148:
      int v77 = v64;
      id v78 = v61 - 1;
      id v64 = operator new(0x28uLL);
      *(void *)((char *)v64 + 28) = a3;
      *id v64 = 0LL;
      v64[1] = 0LL;
      v64[2] = v77;
      os_log_s *v66 = v64;
      int v79 = (uint64_t *)**v78;
      double v80 = v64;
      if (v79)
      {
        *id v78 = v79;
        double v80 = *v66;
      }

      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v78[1], v80);
      void v78[2] = (uint64_t *)((char *)v78[2] + 1);
    }

    __int128 v81 = 1 << a4;
    uint64_t v82 = (unsigned __int16)++*((_WORD *)v64 + 16);
    if (v82 == 1)
    {
      id v83 = std::__hash_table<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::tuple<unsigned long long,unsigned long long,unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (float *)this + 36,  a3,  &v118);
      v83[3] = a5;
      v83[4] = -1LL;
      *((_DWORD *)v83 + 10) = v81;
    }

    id v84 = (char *)this + 40 * v59 + 184;
    uint64_t v85 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v84,  a3);
    if (v85)
    {
      dispatch_semaphore_t v86 = v85 + 4;
      if (v85[4] != -1)
      {
        v85[3] = a5;
        goto LABEL_230;
      }

      goto LABEL_231;
    }

    unint64_t v87 = a3;
    id v88 = *((void *)v84 + 1);
    if (v88)
    {
      id v89 = (uint8x8_t)vcnt_s8((int8x8_t)v88);
      v89.i16[0] = vaddlv_u8(v89);
      if (v89.u32[0] > 1uLL)
      {
        id v58 = a3;
        if (v88 <= a3) {
          id v58 = a3 % v88;
        }
      }

      else
      {
        id v58 = ((_DWORD)v88 - 1) & a3;
      }

      uint64_t v90 = *(void ***)(*(void *)v84 + 8 * v58);
      if (v90)
      {
        BOOL v91 = *v90;
        if (*v90)
        {
          do
          {
            id v92 = v91[1];
            if (v92 == a3)
            {
              if (*((_DWORD *)v91 + 4) == a3) {
                goto LABEL_229;
              }
            }

            else
            {
              if (v89.u32[0] > 1uLL)
              {
                if (v92 >= v88) {
                  v92 %= v88;
                }
              }

              else
              {
                v92 &= v88 - 1;
              }

              if (v92 != v58) {
                break;
              }
            }

            BOOL v91 = (void *)*v91;
          }

          while (v91);
        }
      }
    }

    BOOL v91 = operator new(0x28uLL);
    *BOOL v91 = 0LL;
    v91[1] = a3;
    *((_DWORD *)v91 + 4) = a3;
    v91[3] = 0LL;
    v91[4] = 0LL;
    unint64_t v93 = (float)(unint64_t)(*((void *)v84 + 3) + 1LL);
    __int128 v94 = *((float *)v84 + 8);
    if (v88 && (float)(v94 * (float)v88) >= v93)
    {
      unint64_t v87 = v58;
      goto LABEL_219;
    }

    uint64_t v95 = 1LL;
    if (v88 >= 3) {
      uint64_t v95 = (v88 & (v88 - 1)) != 0;
    }
    id v96 = v95 | (2 * v88);
    id v97 = vcvtps_u32_f32(v93 / v94);
    if (v96 <= v97) {
      int8x8_t prime = (int8x8_t)v97;
    }
    else {
      int8x8_t prime = (int8x8_t)v96;
    }
    if (*(void *)&prime == 1LL)
    {
      int8x8_t prime = (int8x8_t)2LL;
    }

    else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      id v88 = *((void *)v84 + 1);
    }

    if (*(void *)&prime <= v88)
    {
      if (*(void *)&prime < v88)
      {
        BOOL v105 = vcvtps_u32_f32((float)*((unint64_t *)v84 + 3) / *((float *)v84 + 8));
        if (v88 < 3 || (BOOL v106 = (uint8x8_t)vcnt_s8((int8x8_t)v88), v106.i16[0] = vaddlv_u8(v106), v106.u32[0] > 1uLL))
        {
          BOOL v105 = std::__next_prime(v105);
        }

        else
        {
          int v107 = 1LL << -(char)__clz(v105 - 1);
          if (v105 >= 2) {
            BOOL v105 = v107;
          }
        }

        if (*(void *)&prime <= v105) {
          int8x8_t prime = (int8x8_t)v105;
        }
        if (*(void *)&prime >= v88)
        {
          id v88 = *((void *)v84 + 1);
        }

        else
        {
          if (prime) {
            goto LABEL_186;
          }
          __int128 v113 = *(void **)v84;
          *(void *)id v84 = 0LL;
          if (v113) {
            operator delete(v113);
          }
          id v88 = 0LL;
          *((void *)v84 + 1) = 0LL;
        }
      }
    }

    else
    {
LABEL_186:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      id v99 = operator new(8LL * *(void *)&prime);
      int v100 = *(void **)v84;
      *(void *)id v84 = v99;
      if (v100) {
        operator delete(v100);
      }
      __int128 v101 = 0LL;
      *((int8x8_t *)v84 + 1) = prime;
      do
        *(void *)(*(void *)v84 + 8 * v101++) = 0LL;
      while (*(void *)&prime != v101);
      __int128 v102 = (void *)*((void *)v84 + 2);
      if (v102)
      {
        uint64_t v103 = v102[1];
        uint64_t v104 = (uint8x8_t)vcnt_s8(prime);
        v104.i16[0] = vaddlv_u8(v104);
        if (v104.u32[0] > 1uLL)
        {
          if (v103 >= *(void *)&prime) {
            v103 %= *(void *)&prime;
          }
        }

        else
        {
          v103 &= *(void *)&prime - 1LL;
        }

        *(void *)(*(void *)v84 + 8 * v103) = v84 + 16;
        uint64_t v108 = (void *)*v102;
        if (*v102)
        {
          do
          {
            id v109 = v108[1];
            if (v104.u32[0] > 1uLL)
            {
              if (v109 >= *(void *)&prime) {
                v109 %= *(void *)&prime;
              }
            }

            else
            {
              v109 &= *(void *)&prime - 1LL;
            }

            if (v109 != v103)
            {
              if (!*(void *)(*(void *)v84 + 8 * v109))
              {
                *(void *)(*(void *)v84 + 8 * v109) = v102;
                goto LABEL_211;
              }

              void *v102 = *v108;
              *uint64_t v108 = **(void **)(*(void *)v84 + 8 * v109);
              **(void **)(*(void *)v84 + 8 * v109) = v108;
              uint64_t v108 = v102;
            }

            id v109 = v103;
LABEL_211:
            __int128 v102 = v108;
            uint64_t v108 = (void *)*v108;
            uint64_t v103 = v109;
          }

          while (v108);
        }
      }

      id v88 = (unint64_t)prime;
    }

    if ((v88 & (v88 - 1)) != 0)
    {
      if (v88 <= v87) {
        v87 %= v88;
      }
    }

    else
    {
      unint64_t v87 = ((_DWORD)v88 - 1) & v87;
    }

LABEL_195:
  objc_autoreleasePoolPop(v234);
}

void sub_14F18C(_Unwind_Exception *a1)
{
}

void SetTraceMode(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v5 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
  size_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  1796LL,  v5));
  [v3 send:v4 error:0];
}

void DisplayAttachmentIfNeeded(uint64_t a1, int a2, int a3)
{
  if (*(void *)(a1 + 280))
  {
    if ((dword_5B9DE4 & 0x20) == 0)
    {
      uint64_t v6 = *(void *)(**(void **)(a1 + 8) + 112LL);
      ExclusiveRange = GroupBuilder_findExclusiveRange( *(_DWORD *)(v6 + 12),  *(void **)(v6 + 24),  (a2 - 1));
      if (ExclusiveRange)
      {
        while (1)
        {
          int v8 = *((_DWORD *)ExclusiveRange + 7);
          if (v8 == -16353 || v8 == -16351) {
            break;
          }
          uint64_t v10 = *((unsigned int *)ExclusiveRange + 4);
          if ((_DWORD)v10) {
            BOOL v11 = ExclusiveRange == 0LL;
          }
          else {
            BOOL v11 = 1;
          }
          ExclusiveRange -= 4 * v10;
          if (v11) {
            return;
          }
        }

        v17[0] = 0LL;
        v17[1] = v17;
        v17[2] = 0x3010000000LL;
        v17[3] = "";
        v17[4] = *(void *)(a1 + 72);
        char v12 = *(_BYTE *)(a1 + 84);
        char v18 = v12 & 1;
        BOOL v19 = (v12 & 2) != 0;
        BOOL v20 = (v12 & 4) != 0;
        char v21 = 0;
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472LL;
        v14[2] = __DisplayAttachmentIfNeeded_block_invoke;
        v14[3] = &unk_58F048;
        int v15 = a2;
        int v16 = a3;
        v14[4] = v17;
        v14[5] = a1;
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v14));
        [*(id *)(a1 + 256) addOperation:v13];

        _Block_object_dispose(v17, 8);
      }
    }
  }

void sub_14F39C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

__CFString *ArchiveDirectory()
{
  v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
  unsigned __int8 v1 = [v0 isiOSAppOnMac];

  if ((v1 & 1) != 0)
  {
    uint64_t v2 = @"/tmp/com.apple.GPUToolsAgent";
  }

  else
  {
    id v3 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", getpwnam("mobile")->pw_dir);
    size_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    uint64_t v2 = (__CFString *)objc_claimAutoreleasedReturnValue([v4 stringByAppendingPathComponent:@"Library/GPUTools"]);
  }

  return v2;
}

void __ProcessMessage_block_invoke(uint64_t a1)
{
  id v11 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectPayload]);
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v3 = *(void **)(v2 + 128);
  size_t v4 = *(void **)(v2 + 136);
  id v5 = ArchiveDirectory();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  BOOL updated = UpdateDebugFileCache(v11, v3, v4, v6);

  int v8 = *(void **)(a1 + 40);
  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", updated));
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  4612LL,  v9));
  [v8 send:v10 inReplyTo:*(void *)(a1 + 32) error:0];
}

id __ProcessMessage_block_invoke_41(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kDYMessageReplayerUpdateLibraries",  buf,  8u);
  }

  uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8LL);
  id v7 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectPayload]);
  uint64_t v19 = 0LL;
  BOOL v20 = &v19;
  uint64_t v21 = 0x2020000000LL;
  char v22 = 0;
  id v9 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v8);
  *(void *)__int128 buf = _NSConcreteStackBlock;
  uint64_t v24 = 3221225472LL;
  unint64_t v25 = __UpdateLibraries_block_invoke;
  uint64_t v26 = &unk_58F070;
  id v28 = &v19;
  uint64_t v29 = v6;
  id v10 = v9;
  id v27 = v10;
  [v7 enumerateKeysAndObjectsUsingBlock:buf];
  id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((unsigned __int8 *)v20 + 24)));
  [v10 setObject:v11 forKeyedSubscript:@"succeeded"];

  _Block_object_dispose(&v19, 8);
  char v12 = *(void **)(a1 + 40);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:attributes:objectPayload:",  [*(id *)(a1 + 32) kind],  0,  v10));
  [v12 send:v13 inReplyTo:*(void *)(a1 + 32) error:0];

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"succeeded"]);
  LODWORD(v13) = [v14 BOOLValue];

  if ((_DWORD)v13) {
    DisplayAttachmentIfNeeded(*(void *)(a1 + 56), *(_DWORD *)(a1 + 68), *(_DWORD *)(a1 + 72));
  }
  int v15 = g_signpostLog;
  int v16 = (os_log_s *)v15;
  os_signpost_id_t v17 = *(void *)(a1 + 48);
  if (v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v15))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v16,  OS_SIGNPOST_INTERVAL_END,  v17,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

void sub_14F7AC(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_44(uint64_t a1)
{
  uint64_t v2 = ArchiveDirectory();
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = g_signpostLog;
  int v5 = (os_log_s *)v4;
  os_signpost_id_t v6 = *(void *)(a1 + 48);
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v4))
  {
    int v7 = *(_DWORD *)(a1 + 56);
    v14[0] = 67109378;
    v14[1] = v7;
    __int16 v15 = 2082;
    id v16 = [v3 UTF8String];
    _os_signpost_emit_with_name_impl( &dword_0,  v5,  OS_SIGNPOST_EVENT,  v6,  "Replayer-1-serial",  "%u. kDYMessageReplayerDeleteAllArchives %{public}s",  (uint8_t *)v14,  0x12u);
  }

  DeleteAllArchives(v3);
  uint64_t v8 = g_signpostLog;
  id v9 = (os_log_s *)v8;
  os_signpost_id_t v10 = *(void *)(a1 + 48);
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v8))
  {
    LOWORD(v14[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v9,  OS_SIGNPOST_EVENT,  v10,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)v14,  2u);
  }

  id v11 = *(void **)(a1 + 40);
  char v12 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:]( GTTransportMessage_replayer,  "messageWithKind:",  [*(id *)(a1 + 32) kind]));
  [v11 send:v12 inReplyTo:*(void *)(a1 + 32) error:0];

  return [(id)g_activityLog leaveActivity];
}

void sub_14F9AC(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_45(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) attributes]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"sandbox_extensions"]);

  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) attributes]);
  int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"debug_files"]);

  os_signpost_id_t v6 = *(apr_pool_t ***)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = ArchiveDirectory();
  id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v19 = _NSConcreteStackBlock;
  uint64_t v20 = 3221225472LL;
  uint64_t v21 = __ProcessMessage_block_invoke_2;
  char v22 = &unk_58EE20;
  id v23 = *(id *)(a1 + 48);
  id v24 = *(id *)(a1 + 32);
  id v10 = v9;
  id v11 = v3;
  id v12 = v5;
  uint64_t v13 = &v19;
  id v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "stringByAppendingPathComponent:", v7, v19, v20, v21, v22));
  if (v11)
  {
    uint64_t v15 = sandbox_extension_consume([v11 UTF8String]);
    id v16 = apr_palloc(*v6, 8uLL);
    *id v16 = v15;
    apr_pool_cleanup_register(*v6, v16, (apr_status_t (__cdecl *)(void *))CleanupSandboxExtension, v17);
  }

  BeginDebugArchivePath(v6, v14, v10, v12, v13);

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
  return [(id)g_activityLog leaveActivity];
}

void sub_14FBA4(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_51(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 272) makeObjectsPerformSelector:"cancel"];
}

void __ProcessMessage_block_invoke_54(void *a1, void *a2, void *a3)
{
  id v42 = a2;
  id v5 = a3;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  id v45 = [v5 countByEnumeratingWithState:&v50 objects:v66 count:16];
  if (v45)
  {
    uint64_t v44 = *(void *)v51;
    id v43 = v5;
    uint64_t v49 = a1;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v51 != v44) {
          objc_enumerationMutation(v5);
        }
        uint64_t v7 = *(void **)(*((void *)&v50 + 1) + 8 * v6);
        v64[0] = @"buffer name";
        v64[1] = @"capture serial";
        v65[0] = v7;
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1[6] + 16LL)));
        v65[1] = v8;
        unint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v65,  v64,  2LL));

        id v46 = v7;
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v7]);
        uint64_t v48 = v6;
        if ((unint64_t)[v9 length] < 0x40000001)
        {
          id v27 = v47;
        }

        else
        {
          id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
          id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 UUIDString]);

          if ([v9 length])
          {
            uint64_t v12 = 0LL;
            unint64_t v13 = 0LL;
            id v14 = v9;
            do
            {
              id v15 = v9;
              id v16 = (char *)[v15 bytes];
              else {
                uint64_t v17 = (uint64_t)[v15 length] + v12;
              }
              char v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  &v16[v13],  v17,  0LL));
              v63[0] = v11;
              v62[0] = @"chunkUUID";
              v62[1] = @"fullSize";
              uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v15 length]));
              v63[1] = v19;
              v62[2] = @"index";
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v13 >> 30));
              v63[2] = v20;
              v62[3] = @"currentOffset";
              uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  v13));
              v63[3] = v21;
              char v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v63,  v62,  4LL));

              id v23 = (void *)v49[4];
              id v24 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:payload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:attributes:payload:",  271LL,  v22,  v18));
              [v23 send:v24 inReplyTo:v49[5] error:0];

              v13 += 0x40000000LL;
              v12 -= 0x40000000LL;
              id v9 = v14;
            }

            while (v13 < (unint64_t)[v15 length]);
          }

          v61[0] = v46;
          v60[0] = @"buffer name";
          v60[1] = @"capture serial";
          a1 = v49;
          unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v49[6] + 16LL)));
          v60[2] = @"chunkUUID";
          v61[1] = v25;
          v61[2] = v11;
          uint64_t v26 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v61,  v60,  3LL));

          id v9 = 0LL;
          id v27 = (void *)v26;
          id v5 = v43;
        }

        id v28 = g_signpostLog;
        uint64_t v29 = (os_log_s *)v28;
        os_signpost_id_t v30 = a1[7];
        if (v30 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v28))
        {
          uint64_t v31 = v27;
          int v32 = *((_DWORD *)a1 + 16);
          id v33 = [v46 UTF8String];
          id v34 = [v9 length];
          *(_DWORD *)__int128 buf = 67109634;
          int v55 = v32;
          id v27 = v31;
          __int16 v56 = 2082;
          id v57 = v33;
          __int16 v58 = 2048;
          id v59 = v34;
          _os_signpost_emit_with_name_impl( &dword_0,  v29,  OS_SIGNPOST_INTERVAL_BEGIN,  v30,  "Replayer-5-network",  "%u. send %{public}s %{xcode:size-in-bytes}lu",  buf,  0x1Cu);
        }

        unsigned int v35 = (void *)a1[4];
        unsigned int v36 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:payload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:attributes:payload:",  258LL,  v27,  v9));
        [v35 send:v36 inReplyTo:a1[5] error:0];

        uint64_t v37 = g_signpostLog;
        uint64_t v38 = (os_log_s *)v37;
        os_signpost_id_t v39 = a1[7];
        if (v39 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v37))
        {
          *(_WORD *)__int128 buf = 0;
          _os_signpost_emit_with_name_impl( &dword_0,  v38,  OS_SIGNPOST_INTERVAL_END,  v39,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
        }

        uint64_t v6 = v48 + 1;
      }

      while ((id)(v48 + 1) != v45);
      id v45 = [v5 countByEnumeratingWithState:&v50 objects:v66 count:16];
    }

    while (v45);
  }

  id v40 = (void *)a1[4];
  __int128 v41 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:payload:]( GTTransportMessage_replayer,  "messageWithKind:attributes:payload:",  [(id)a1[5] kind],  0,  v42));
  [v40 send:v41 inReplyTo:a1[5] error:0];
}

void __ProcessMessage_block_invoke_74(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  os_signpost_id_t v4 = *(void **)(a1 + 40);
  id v5 = a2;
  id v6 = (id)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:payload:]( GTTransportMessage_replayer,  "messageWithKind:attributes:payload:",  [v4 kind],  0,  v5));

  [v3 send:v6 inReplyTo:*(void *)(a1 + 40) error:0];
}

id __ProcessMessage_block_invoke_76(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kGTMessageReplayerResourcesUsedForFunctionIndex",  buf,  8u);
  }

  id v6 = *(unsigned int **)(*(void *)(a1 + 56) + 8LL);
  id v7 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) plistPayload]);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"functionIndex"]);
  id v9 = [v8 unsignedLongLongValue];

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"subCommandIndex"]);
  id v11 = [v10 unsignedLongLongValue];

  id v31 = 0LL;
  int v12 = GTMTLReplayClient_generateFunctionResourceUsageInfoV2(v6, (unint64_t)v9, (unint64_t)v11, &v31);
  id v13 = v31;
  id v14 = v13;
  id v15 = &__NSArray0__struct;
  if (v13) {
    id v15 = v13;
  }
  v32[1] = @"error";
  *(void *)__int128 buf = v15;
  v32[0] = @"resources";
  id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v12 ^ 1u));
  id v34 = v16;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  buf,  v32,  2LL));

  char v18 = g_signpostLog;
  uint64_t v19 = (os_log_s *)v18;
  os_signpost_id_t v20 = *(void *)(a1 + 48);
  if (v20 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v18))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v19,  OS_SIGNPOST_INTERVAL_END,  v20,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
  }

  uint64_t v21 = g_signpostLog;
  char v22 = (os_log_s *)v21;
  os_signpost_id_t v23 = *(void *)(a1 + 48);
  if (v23 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v21))
  {
    int v24 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v24;
    _os_signpost_emit_with_name_impl( &dword_0,  v22,  OS_SIGNPOST_INTERVAL_BEGIN,  v23,  "Replayer-5-network",  "%u. kGTMessageReplayerResourcesUsedForFunctionIndex",  buf,  8u);
  }

  unint64_t v25 = *(void **)(a1 + 40);
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  [*(id *)(a1 + 32) kind],  v17));
  [v25 send:v26 inReplyTo:*(void *)(a1 + 32) error:0];

  id v27 = g_signpostLog;
  id v28 = (os_log_s *)v27;
  os_signpost_id_t v29 = *(void *)(a1 + 48);
  if (v29 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v27))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v28,  OS_SIGNPOST_INTERVAL_END,  v29,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

void sub_150560(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_77(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    v15[0] = 67109120;
    v15[1] = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kDYMessageReplayerGenerateThumbnails",  (uint8_t *)v15,  8u);
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectPayload]);
  id Thumbnails = GTMTLReplayClient_generateThumbnails( **(void ***)(*(void *)(a1 + 56) + 8LL),  v6,  *(void **)(*(void *)(a1 + 56) + 88LL));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(Thumbnails);
  id v9 = *(void **)(a1 + 40);
  id v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  [*(id *)(a1 + 32) kind],  v8));
  [v9 send:v10 inReplyTo:*(void *)(a1 + 32) error:0];

  id v11 = g_signpostLog;
  int v12 = (os_log_s *)v11;
  os_signpost_id_t v13 = *(void *)(a1 + 48);
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v11))
  {
    LOWORD(v15[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v12,  OS_SIGNPOST_INTERVAL_END,  v13,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)v15,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

void sub_150754(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_78(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    v15[0] = 67109120;
    v15[1] = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kDYMessageReplayerGenerateDependencyGraphThumbnails",  (uint8_t *)v15,  8u);
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectPayload]);
  DependencyGraphid Thumbnails = GTMTLReplayClient_generateDependencyGraphThumbnails( **(void **)(*(void *)(a1 + 56) + 8LL),  v6,  *(void **)(*(void *)(a1 + 56) + 88LL));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(DependencyGraphThumbnails);
  id v9 = *(void **)(a1 + 40);
  id v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  [*(id *)(a1 + 32) kind],  v8));
  [v9 send:v10 inReplyTo:*(void *)(a1 + 32) error:0];

  id v11 = g_signpostLog;
  int v12 = (os_log_s *)v11;
  os_signpost_id_t v13 = *(void *)(a1 + 48);
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v11))
  {
    LOWORD(v15[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v12,  OS_SIGNPOST_INTERVAL_END,  v13,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)v15,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

void sub_15094C(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_79(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    int v30 = 67109120;
    int v31 = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kGTMessageQueryInducedGPUPerfState",  (uint8_t *)&v30,  8u);
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 8) defaultDevice]);
  id v7 = DEVICEOBJECT(v6);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  id MetalPluginName = GetMetalPluginName((io_registry_entry_t)[v8 acceleratorPort], 0);
  id v10 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
  if (IsAGXMetalPlugin(v10, v11))
  {
    id v12 = ConsistentPerformanceStateInfo(*(void *)(*(void *)(a1 + 56) + 8LL));
    os_signpost_id_t v13 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(v12);
    if ([v8 supportsFamily:1009])
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v13));
      [v14 setObject:&off_5A0988 forKeyedSubscript:@"gen"];
      id v15 = (_UNKNOWN **)[v14 copy];
    }

    else
    {
      if (![v8 supportsFamily:1004])
      {
        id v16 = v13;
        goto LABEL_12;
      }

      id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v13));
      [v14 setObject:&off_5A09A0 forKeyedSubscript:@"gen"];
      id v15 = (_UNKNOWN **)[v14 copy];
    }

    id v16 = v15;
  }

  else
  {
    id v16 = &off_5A00D8;
  }

void sub_150CF0(_Unwind_Exception *a1)
{
}

void __ProcessMessage_block_invoke_117(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v7 = v3;
  if (v3)
  {
    os_signpost_id_t v4 = v3;
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)
      || (int v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"Streaming APS Counters"]),
          *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v5 != 0LL,
          v5,
          os_signpost_id_t v4 = v7,
          *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)))
    {
      if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL)) {
        goto LABEL_8;
      }
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"Streaming APS Profiling"]);
      if (v6) {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
      }

      os_signpost_id_t v4 = v7;
      if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL)) {
LABEL_8:
      }
        [*(id *)(a1 + 40) addAPSTimelineData:v4];
      else {
        [*(id *)(a1 + 40) addAPSCounterData:v7];
      }
    }

    else
    {
      [*(id *)(a1 + 40) addAPSData:v7];
    }
  }

  else
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
}

void __ProcessMessage_block_invoke_131(uint64_t a1)
{
  uint64_t v2 = a1 + 48;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 8) defaultDevice]);
  id v4 = DEVICEOBJECT(v3);
  int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  io_registry_entry_t v6 = [v5 acceleratorPort];

  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)v2 + 8) + 8) defaultDevice]);
  LODWORD(v5) = [v7 supportsFamily:1009];

  if (!(_DWORD)v5)
  {
    unsigned int v84 = 0x7FFFFFFF;
    id MetalPluginName = GetMetalPluginName(v6, &v84);
    char v18 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
    int v20 = IsAGXMetalPlugin(v18, v19);
    id DerivedDataPayload = GTMTLReplayHost_generateDerivedDataPayload(**(void **)(*(void *)(a1 + 48) + 8LL), v20);
    int v77 = (void *)objc_claimAutoreleasedReturnValue(DerivedDataPayload);
    os_signpost_id_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v77));
    int v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectPayload]);
    __int128 v76 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) attributes]);
    if (v23)
    {
      int v24 = (void *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:@"UseMTLCounters"]);
      BOOL v25 = v24 == 0LL;

      if (!v25) {
        [v22 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseMTLCounters"];
      }
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKeyedSubscript:", @"UseKicktimestamps", v76));
      BOOL v27 = v26 == 0LL;

      if (!v27) {
        [v22 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseKicktimestamps"];
      }
      os_signpost_id_t v28 = (void *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:@"CoalesceComputeEncoders"]);
      BOOL v29 = v28 == 0LL;

      if (!v29) {
        [v22 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CoalesceComputeEncoders"];
      }
      int v30 = (void *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:@"CoalesceBlitEncoders"]);
      BOOL v31 = v30 == 0LL;

      if (!v31) {
        [v22 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CoalesceBlitEncoders"];
      }
      int v32 = (void *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:@"GPUState"]);
      if (v32) {
        [v22 setObject:v32 forKeyedSubscript:@"GPUState"];
      }
    }

    if (!v20)
    {
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectPayload]);
      id v38 = [v37 mutableCopy];

      if (v38)
      {
        [v38 setObject:v18 forKeyedSubscript:@"MetalPluginName"];
        ShaderInfo = GTMTLReplayClient_queryShaderInfo( *(void *)(*(void *)(a1 + 48) + 8LL),  (id *)(*(void *)(a1 + 48) + 256LL),  v38);
      }

      else
      {
        ShaderInfo = GTMTLReplayClient_queryShaderInfo( *(void *)(*(void *)(a1 + 48) + 8LL),  (id *)(*(void *)(a1 + 48) + 256LL),  0LL);
      }

      id v34 = (void *)objc_claimAutoreleasedReturnValue(ShaderInfo);
      id v40 = g_signpostLog;
      __int128 v41 = (os_log_s *)v40;
      os_signpost_id_t v42 = *(void *)(a1 + 56);
      if (v42 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v40))
      {
        int v43 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v43;
        _os_signpost_emit_with_name_impl( &dword_0,  v41,  OS_SIGNPOST_INTERVAL_BEGIN,  v42,  "Replayer-5-network",  "%u. kDYMessageReplayerQueryShaderInfo",  buf,  8u);
      }

      uint64_t v44 = *(void **)(a1 + 32);
      id v45 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 40) kind],  v34));
      [v44 send:v45 inReplyTo:*(void *)(a1 + 40) error:0];

      id v46 = g_signpostLog;
      unint64_t v47 = (os_log_s *)v46;
      os_signpost_id_t v48 = *(void *)(a1 + 56);
      if (v48 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v46))
      {
        *(_WORD *)__int128 buf = 0;
        _os_signpost_emit_with_name_impl( &dword_0,  v47,  OS_SIGNPOST_INTERVAL_END,  v48,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
      }

      os_signpost_id_t v22 = v38;
      goto LABEL_50;
    }

    [v22 setObject:v18 forKeyedSubscript:@"MetalPluginName"];
    if (v84 != 0x7FFFFFFF)
    {
      id v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:"));
      [v22 setObject:v33 forKeyedSubscript:@"gpuTarget"];
    }

    id v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKeyedSubscript:", @"useOverlap", v76));
    if (v34) {
      [v22 setObject:v34 forKeyedSubscript:@"useOverlap"];
    }
    *(void *)__int128 buf = 0LL;
    dispatch_semaphore_t v86 = buf;
    uint64_t v87 = 0x3032000000LL;
    id v88 = __Block_byref_object_copy__4942;
    id v89 = __Block_byref_object_dispose__4943;
    uint64_t v90 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
    [*((id *)v86 + 5) setName:@"gputools.GPUToolsDebugger.GPUToolsPlatform.ShaderProfiler.StreamingData.SerialQueue"];
    [*((id *)v86 + 5) setMaxConcurrentOperationCount:1];
    if (v76)
    {
      unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue([v76 objectForKeyedSubscript:@"GPUTimelineInfo"]);
      unsigned int v36 = v35;
      if (v35)
      {
        if (v84 <= 0x7FFFFFFE)
        {

LABEL_41:
          __int128 v50 = objc_autoreleasePoolPush();
          __int128 v51 = *(void **)(a1 + 32);
          __int128 v52 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 40) kind],  &off_5A0100));
          [v51 send:v52 inReplyTo:*(void *)(a1 + 40) error:0];

          dispatch_semaphore_t v53 = dispatch_semaphore_create(0LL);
          uint64_t v54 = *(void *)(a1 + 48);
          uint64_t v55 = *(void *)(v54 + 8);
          __int16 v56 = (id *)(v54 + 256);
          v80[0] = _NSConcreteStackBlock;
          v80[1] = 3221225472LL;
          id v80[2] = __ProcessMessage_block_invoke_142;
          v80[3] = &unk_58EF58;
          id v83 = buf;
          id v81 = *(id *)(a1 + 32);
          id v57 = v53;
          uint64_t v82 = v57;
          GTMTLReplayClient_collectGPUShaderTimelineData(v55, v56, v22, v80);
          dispatch_semaphore_wait(v57, 0xFFFFFFFFFFFFFFFFLL);

          objc_autoreleasePoolPop(v50);
LABEL_49:
          _Block_object_dispose(buf, 8);

LABEL_50:
          return;
        }

        int v49 = MetalPluginTarget(v18);

        if (v49 >= 0) {
          goto LABEL_41;
        }
      }
    }

    __int16 v58 = GTMTLReplayClient_embeddedQueryShaderInfo( *(GTMTLReplayController **)(*(void *)(a1 + 48) + 8LL),  (id *)(*(void *)(a1 + 48) + 256LL),  v22);
    id v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
    id v60 = *(void **)(a1 + 32);
    __int128 v61 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 40) kind],  v59));
    [v60 send:v61 inReplyTo:*(void *)(a1 + 40) error:0];

    if (v59)
    {
      __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"Streaming Shader Profiling Data"]);
      BOOL v63 = v62 == 0LL;

      if (!v63)
      {
        dispatch_semaphore_t v64 = dispatch_semaphore_create(0LL);
        uint64_t v65 = *(void *)(a1 + 48);
        uint64_t v66 = *(void *)(v65 + 8);
        __int128 v67 = (id *)(v65 + 256);
        v79[0] = _NSConcreteStackBlock;
        v79[1] = 3221225472LL;
        void v79[2] = __ProcessMessage_block_invoke_3;
        v79[3] = &unk_58EF58;
        v79[6] = buf;
        unint64_t v68 = v79;
        v79[4] = *(id *)(a1 + 32);
        int v69 = v64;
        void v79[5] = v69;
        GTMTLReplayClient_streamShaderProfilingData(v66, v67, v22, v79);
LABEL_47:
        dispatch_semaphore_wait(v69, 0xFFFFFFFFFFFFFFFFLL);

        goto LABEL_48;
      }

      id v70 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"Streaming Timeline Data"]);
      BOOL v71 = v70 == 0LL;

      if (!v71)
      {
        dispatch_semaphore_t v72 = dispatch_semaphore_create(0LL);
        uint64_t v73 = *(void *)(a1 + 48);
        uint64_t v74 = *(void *)(v73 + 8);
        int v75 = (id *)(v73 + 256);
        v78[0] = _NSConcreteStackBlock;
        v78[1] = 3221225472LL;
        void v78[2] = __ProcessMessage_block_invoke_5;
        v78[3] = &unk_58EF58;
        v78[6] = buf;
        unint64_t v68 = v78;
        v78[4] = *(id *)(a1 + 32);
        int v69 = v72;
        v78[5] = v69;
        GTMTLReplayClient_collectGPUShaderTimelineData(v74, v75, v22, v78);
        goto LABEL_47;
      }
    }

void sub_1517A0(_Unwind_Exception *a1)
{
}

void __ProcessMessage_block_invoke_167(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  id v3 = [*(id *)(a1 + 48) kind];
  id v7 = @"Batch Filtering Request Received";
  id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
  uint64_t v8 = v4;
  int v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v8,  &v7,  1LL));
  io_registry_entry_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  v3,  v5));
  [v2 send:v6 inReplyTo:*(void *)(a1 + 48) error:0];
}

void __ProcessMessage_block_invoke_2_170(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    int v21 = 67109120;
    int v22 = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-4-parallel",  "%u. loadAnalysis",  (uint8_t *)&v21,  8u);
  }

  io_registry_entry_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 8) defaultDevice]);
  id Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v6);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(Analysis);

  id v9 = g_signpostLog;
  os_signpost_id_t v10 = (os_log_s *)v9;
  os_signpost_id_t v11 = *(void *)(a1 + 48);
  if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v9))
  {
    LOWORD(v21) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v10,  OS_SIGNPOST_INTERVAL_END,  v11,  "Replayer-4-parallel",  (const char *)&unk_3189BB,  (uint8_t *)&v21,  2u);
  }

  id v12 = g_signpostLog;
  os_signpost_id_t v13 = (os_log_s *)v12;
  os_signpost_id_t v14 = *(void *)(a1 + 48);
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v12))
  {
    int v15 = *(_DWORD *)(a1 + 64);
    int v21 = 67109120;
    int v22 = v15;
    _os_signpost_emit_with_name_impl( &dword_0,  v13,  OS_SIGNPOST_INTERVAL_BEGIN,  v14,  "Replayer-5-network",  "%u. kDYMessageReplayerDerivedCounterData",  (uint8_t *)&v21,  8u);
  }

  os_signpost_id_t v16 = *(void **)(a1 + 32);
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 40) kind],  v8));
  [v16 send:v17 inReplyTo:*(void *)(a1 + 40) error:0];

  char v18 = g_signpostLog;
  os_signpost_id_t v19 = (os_log_s *)v18;
  os_signpost_id_t v20 = *(void *)(a1 + 48);
  if (v20 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v18))
  {
    LOWORD(v21) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v19,  OS_SIGNPOST_INTERVAL_END,  v20,  "Replayer-5-network",  (const char *)&unk_3189BB,  (uint8_t *)&v21,  2u);
  }
}

void __ProcessMessage_block_invoke_171(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 8) defaultDevice]);
  id v3 = DEVICEOBJECT(v2);
  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  io_registry_entry_t v5 = [v4 acceleratorPort];

  id MetalPluginName = GetMetalPluginName(v5, 0LL);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
  if ([v7 containsString:@"AGXMetal"])
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) attributes]);
    id v9 = v8;
    if (v8)
    {
      os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"collectInBackground"]);

      if (v10)
      {
        dispatch_semaphore_t v11 = dispatch_semaphore_create(0LL);
        id v12 = *(void **)(a1 + 48);
        uint64_t v13 = *(void *)(a1 + 56);
        uint64_t v14 = *(void *)(v13 + 8);
        int v15 = (id *)(v13 + 256);
        os_signpost_id_t v16 = *(void **)(a1 + 40);
        unint64_t v47 = _NSConcreteStackBlock;
        uint64_t v48 = 3221225472LL;
        int v49 = __ProcessMessage_block_invoke_2_174;
        __int128 v50 = &unk_58EE20;
        dispatch_semaphore_t v51 = v11;
        id v52 = v12;
        uint64_t v17 = v11;
        BOOL v18 = GTMTLReplayClient_streamBatchFilteredData(v14, v15, v16, &v47);
        os_signpost_id_t v19 = *(void **)(a1 + 48);
        id v20 = objc_msgSend(*(id *)(a1 + 32), "kind", v47, v48, v49, v50);
        id v57 = @"Batch Filtering Started";
        int v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v18));
        __int16 v58 = v21;
        int v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v58,  &v57,  1LL));
        int v23 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  v20,  v22));
        [v19 send:v23 inReplyTo:*(void *)(a1 + 32) error:0];

        dispatch_semaphore_wait(v17, 0xFFFFFFFFFFFFFFFFLL);
      }

      else
      {
        GTMTLReplayClient_addBatchFilteringRequest(*(void **)(a1 + 40));
        __int128 v41 = *(void **)(a1 + 32);
        id v40 = (void *)(a1 + 32);
        os_signpost_id_t v42 = (void *)v40[2];
        id v43 = [v41 kind];
        uint64_t v55 = @"Batch Filtering Request Received";
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
        __int16 v56 = v44;
        id v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v56,  &v55,  1LL));
        id v46 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  v43,  v45));
        [v42 send:v46 inReplyTo:*v40 error:0];
      }
    }

    else
    {
      id v34 = GTMTLReplayClient_embeddedDerivedCounterData( *(GTMTLReplayController **)(*(void *)(a1 + 56) + 8LL),  (id *)(*(void *)(a1 + 56) + 256LL),  *(void **)(a1 + 40));
      unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
      uint64_t v37 = *(void **)(a1 + 32);
      unsigned int v36 = (void *)(a1 + 32);
      id v38 = (void *)v36[2];
      os_signpost_id_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  [v37 kind],  v35));
      [v38 send:v39 inReplyTo:*v36 error:0];

      id v9 = 0LL;
    }
  }

  else
  {
    id v24 = GTMTLReplayClient_derivedCounterData( *(id **)(*(void *)(a1 + 56) + 8LL),  (id *)(*(void *)(a1 + 56) + 256LL),  *(void **)(a1 + 40));
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v24);
    BOOL v25 = g_signpostLog;
    uint64_t v26 = (os_log_s *)v25;
    os_signpost_id_t v27 = *(void *)(a1 + 64);
    if (v27 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v25))
    {
      int v28 = *(_DWORD *)(a1 + 72);
      *(_DWORD *)__int128 buf = 67109120;
      int v54 = v28;
      _os_signpost_emit_with_name_impl( &dword_0,  v26,  OS_SIGNPOST_INTERVAL_BEGIN,  v27,  "Replayer-5-network",  "%u. kDYMessageReplayerDerivedCounterData",  buf,  8u);
    }

    BOOL v29 = *(void **)(a1 + 48);
    int v30 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 32) kind],  v9));
    [v29 send:v30 inReplyTo:*(void *)(a1 + 32) error:0];

    BOOL v31 = g_signpostLog;
    int v32 = (os_log_s *)v31;
    os_signpost_id_t v33 = *(void *)(a1 + 64);
    if (v33 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v31))
    {
      *(_WORD *)__int128 buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v32,  OS_SIGNPOST_INTERVAL_END,  v33,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
    }
  }
}

id __ProcessMessage_block_invoke_177(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kDYGenerateShaderDebuggerTrace",  buf,  8u);
  }

  io_registry_entry_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) attributes]);
  id v7 = v6;
  if (v6) {
    id v8 = v6;
  }
  else {
    id v8 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectPayload]);
  }
  id v9 = v8;

  os_signpost_id_t v10 = *(uint64_t **)(*(void *)(a1 + 56) + 8LL);
  id v34 = 0LL;
  id v11 = GTMTLShaderDebugger_generateTrace(v10, v9, &v34);
  id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  id v13 = v34;
  uint64_t v14 = v13;
  if (v12)
  {
    id v15 = v12;
  }

  else
  {
    id v16 = v13;
    uint64_t v17 = v16;
    if (v16)
    {
      id v18 = v16;
    }

    else
    {
      id Error = GTShaderDebuggerMakeError(1u, @"Internal error", 0LL, 0LL, 0LL);
      id v18 = (id)objc_claimAutoreleasedReturnValue(Error);
    }

    id v20 = v18;
    unsigned int v35 = @"Error";
    *(void *)__int128 buf = v18;
    id v15 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  buf,  &v35,  1LL));
  }

  int v21 = g_signpostLog;
  int v22 = (os_log_s *)v21;
  os_signpost_id_t v23 = *(void *)(a1 + 48);
  if (v23 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v21))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v22,  OS_SIGNPOST_INTERVAL_END,  v23,  "Replayer-1-serial",  (const char *)&unk_3189BB,  buf,  2u);
  }

  id v24 = g_signpostLog;
  BOOL v25 = (os_log_s *)v24;
  os_signpost_id_t v26 = *(void *)(a1 + 48);
  if (v26 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v24))
  {
    int v27 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v27;
    _os_signpost_emit_with_name_impl( &dword_0,  v25,  OS_SIGNPOST_INTERVAL_BEGIN,  v26,  "Replayer-5-network",  "%u. kDYGenerateShaderDebuggerTrace",  buf,  8u);
  }

  int v28 = *(void **)(a1 + 40);
  BOOL v29 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:objectPayload:",  [*(id *)(a1 + 32) kind],  v15));
  [v28 send:v29 inReplyTo:*(void *)(a1 + 32) error:0];

  int v30 = g_signpostLog;
  BOOL v31 = (os_log_s *)v30;
  os_signpost_id_t v32 = *(void *)(a1 + 48);
  if (v32 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v30))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v31,  OS_SIGNPOST_INTERVAL_END,  v32,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

void sub_152324(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_178(uint64_t a1)
{
  uint64_t v2 = ArchiveDirectory();
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 stringByAppendingPathComponent:*(void *)(a1 + 40)]);

  id v5 = v4;
  DataSource = GTMTLReplayController_makeDataSource( (const char *)[v5 UTF8String],  **(apr_pool_t ***)(a1 + 56));
  id v7 = v5;
  id v8 = -[NSURL initFileURLWithPath:isDirectory:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithPath:isDirectory:",  v7,  1LL);

  id v9 = -[NSURL initWithString:relativeToURL:]( objc_alloc(&OBJC_CLASS___NSURL),  "initWithString:relativeToURL:",  @"metadata",  v8);
  os_signpost_id_t v10 = -[NSDictionary initWithContentsOfURL:error:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithContentsOfURL:error:",  v9,  0LL);

  id v11 = *(void **)(*(void *)(a1 + 56) + 280LL);
  id v12 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v10,  "objectForKeyedSubscript:",  @"DYCaptureEngine.launch_dictionary"));
  id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"title"]);
  [v11 setWindowTitle:v13];

  id v14 = PreferDevice((uint64_t)DataSource);
  id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  id v16 = -[GTMTLReplayObjectMap initWithDevice:](objc_alloc(&OBJC_CLASS___GTMTLReplayObjectMap), "initWithDevice:", v15);
  GTMTLReplaySupport_init(v15);
  GTMTLReplayController_initializeArgumentBufferSupport((uint64_t)DataSource, v15, v16);
  GTMTLReplayController_populateUnusedResources(DataSource, v16);
  *(void *)(*(void *)(a1 + 56) + 8LL) = GTMTLReplayController_makeController( (uint64_t)DataSource,  **(apr_pool_t ***)(a1 + 56),  v15,  v16,  0LL,  0LL);
  GTMTLReplayWireframeRenderer_initWithDevice(*(void *)(a1 + 56) + 96LL, v15);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));

  return [(id)g_activityLog leaveActivity];
}

void sub_152528(_Unwind_Exception *a1)
{
}

id __ProcessMessage_block_invoke_188(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  id v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 64);
    v21[0] = 67109120;
    v21[1] = v5;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-1-serial",  "%u. kDYMessageUpdateResourceObject",  (uint8_t *)v21,  8u);
  }

  uint64_t v6 = *(void *)(a1 + 56);
  id v7 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) attributes]);
  id v9 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v8);
  os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"type"]);
  unsigned int v11 = [v10 unsignedIntValue];

  if (v11 == 13)
  {
    id v12 = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  UpdateLibraryResource(*(id **)(v6 + 8), v7, v9, 0LL));
    id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    [v9 setObject:v13 forKeyedSubscript:@"succeeded"];
  }

  id v14 = *(void **)(a1 + 40);
  id v15 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:objectPayload:]( GTTransportMessage_replayer,  "messageWithKind:attributes:objectPayload:",  [*(id *)(a1 + 32) kind],  0,  v9));
  [v14 send:v15 inReplyTo:*(void *)(a1 + 32) error:0];

  id v16 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"succeeded"]);
  LODWORD(v15) = [v16 BOOLValue];

  if ((_DWORD)v15) {
    DisplayAttachmentIfNeeded(*(void *)(a1 + 56), *(_DWORD *)(a1 + 68), *(_DWORD *)(a1 + 72));
  }
  uint64_t v17 = g_signpostLog;
  id v18 = (os_log_s *)v17;
  os_signpost_id_t v19 = *(void *)(a1 + 48);
  if (v19 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v17))
  {
    LOWORD(v21[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v18,  OS_SIGNPOST_INTERVAL_END,  v19,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)v21,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

void sub_1527C4(_Unwind_Exception *a1)
{
}

void __ProcessMessage_block_invoke_2_174(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v3 = (id)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  a2));
    [*(id *)(a1 + 40) send:v3 inReplyTo:0 error:0];
  }

  else
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }

uint64_t __Block_byref_object_copy__4942(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__4943(uint64_t a1)
{
}

void __ProcessMessage_block_invoke_142(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v17 = 0LL;
    id v18 = &v17;
    uint64_t v19 = 0x3032000000LL;
    id v20 = __Block_byref_object_copy__4942;
    int v21 = __Block_byref_object_dispose__4943;
    id v22 = 0LL;
    os_signpost_id_t v4 = objc_autoreleasePoolPush();
    id v5 = [v3 copy];
    uint64_t v6 = (void *)v18[5];
    v18[5] = (uint64_t)v5;

    objc_autoreleasePoolPop(v4);
    id v7 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
    unsigned int v11 = _NSConcreteStackBlock;
    uint64_t v12 = 3221225472LL;
    id v13 = __ProcessMessage_block_invoke_2_148;
    id v14 = &unk_58EF30;
    id v16 = &v17;
    id v15 = *(id *)(a1 + 32);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v11));
    objc_msgSend(v7, "addOperation:", v8, v11, v12, v13, v14);

    _Block_object_dispose(&v17, 8);
  }

  else
  {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) waitUntilAllOperationsAreFinished];
    id v9 = *(void **)(a1 + 32);
    os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  &off_5A0128));
    [v9 send:v10 inReplyTo:0 error:0];

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  }
}

void sub_1529F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __ProcessMessage_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v17 = 0LL;
    id v18 = &v17;
    uint64_t v19 = 0x3032000000LL;
    id v20 = __Block_byref_object_copy__4942;
    int v21 = __Block_byref_object_dispose__4943;
    id v22 = 0LL;
    os_signpost_id_t v4 = objc_autoreleasePoolPush();
    id v5 = [v3 copy];
    uint64_t v6 = (void *)v18[5];
    v18[5] = (uint64_t)v5;

    objc_autoreleasePoolPop(v4);
    id v7 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
    unsigned int v11 = _NSConcreteStackBlock;
    uint64_t v12 = 3221225472LL;
    id v13 = __ProcessMessage_block_invoke_4;
    id v14 = &unk_58EF30;
    id v16 = &v17;
    id v15 = *(id *)(a1 + 32);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v11));
    objc_msgSend(v7, "addOperation:", v8, v11, v12, v13, v14);

    _Block_object_dispose(&v17, 8);
  }

  else
  {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) waitUntilAllOperationsAreFinished];
    id v9 = *(void **)(a1 + 32);
    os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  &off_5A0150));
    [v9 send:v10 inReplyTo:0 error:0];

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
    NSLog(@"Streamed All Shader Profiler Data");
  }
}

void sub_152B94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __ProcessMessage_block_invoke_5(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v17 = 0LL;
    id v18 = &v17;
    uint64_t v19 = 0x3032000000LL;
    id v20 = __Block_byref_object_copy__4942;
    int v21 = __Block_byref_object_dispose__4943;
    id v22 = 0LL;
    os_signpost_id_t v4 = objc_autoreleasePoolPush();
    id v5 = [v3 copy];
    uint64_t v6 = (void *)v18[5];
    v18[5] = (uint64_t)v5;

    objc_autoreleasePoolPop(v4);
    id v7 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
    unsigned int v11 = _NSConcreteStackBlock;
    uint64_t v12 = 3221225472LL;
    id v13 = __ProcessMessage_block_invoke_6;
    id v14 = &unk_58EF30;
    id v16 = &v17;
    id v15 = *(id *)(a1 + 32);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v11));
    objc_msgSend(v7, "addOperation:", v8, v11, v12, v13, v14);

    _Block_object_dispose(&v17, 8);
  }

  else
  {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) waitUntilAllOperationsAreFinished];
    id v9 = *(void **)(a1 + 32);
    os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  &off_5A0178));
    [v9 send:v10 inReplyTo:0 error:0];

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  }
}

void sub_152D28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __ProcessMessage_block_invoke_6(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)));
  [*(id *)(a1 + 32) send:v2 inReplyTo:0 error:0];
}

void __ProcessMessage_block_invoke_4(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)));
  [*(id *)(a1 + 32) send:v2 inReplyTo:0 error:0];
}

void __ProcessMessage_block_invoke_2_148(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  4124LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)));
  [*(id *)(a1 + 32) send:v2 inReplyTo:0 error:0];
}

void __ProcessMessage_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = (id)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:objectPayload:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:attributes:objectPayload:",  4105LL,  a2,  &__kCFBooleanTrue));
  [v3 send:v4 inReplyTo:*(void *)(a1 + 40) error:0];
}

void __UpdateLibraries_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = *(void **)(*(void *)(a1 + 48) + 128LL);
  id v8 = v4;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"object"]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v6]);

  if (v7) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = UpdateLibraryResource( *(id **)(a1 + 48),  v8,  *(void **)(a1 + 32),  v7);
  }
}

id __DisplayAttachmentIfNeeded_block_invoke(uint64_t a1)
{
  return [(id)g_activityLog leaveActivity];
}

void sub_152F9C(_Unwind_Exception *a1)
{
}

void GTMTLReplayClient_createOldTransport(uint64_t a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  __int128 v68 = 0u;
  __int128 v69 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  *(void *)&__int128 v56 = 0xFF0000FF00FF00FFLL;
  DWORD2(v56) = 1082130432;
  *(void *)&__int128 v57 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  128LL);
  *((void *)&v67 + 1) = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
  *(void *)&__int128 v68 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
  *((void *)&v68 + 1) = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  16LL);
  __copy_assignment_8_8_t0w88_s88_S_s96_s104_t112w8_s120_s128_s136_t144w8_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288( a1,  (uint64_t)&newpool);
  [*(id *)(a1 + 264) setName:@"gputools.MTLReplayer.parallelQueue"];
  [*(id *)(a1 + 256) setName:@"gputools.MTLReplayer.serialQueue"];
  [*(id *)(a1 + 256) setMaxConcurrentOperationCount:1];
  if (!a2)
  {
    if (s_logUsingOsLog)
    {
      unsigned int v36 = (os_log_s *)gt_default_log();
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_FAULT)) {
        goto LABEL_27;
      }
      LOWORD(buf) = 0;
      uint64_t v37 = "fail: [create_transport] GT_HOST_URL environment not set";
      id v38 = v36;
      uint32_t v39 = 2;
      goto LABEL_26;
    }

    __int128 v41 = __stderrp;
    -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"fail: [create_transport] GT_HOST_URL environment not set"),  "UTF8String");
    fprintf(v41, "%s\n");
LABEL_27:
    abort();
  }

  uint64_t v6 = +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", a2, 4LL);
  if (!v6) {
    __assert_rtn("GTTransport *DYCreateTransportC(const char *)", "", 0, "url_str");
  }
  id v7 = +[NSURL URLWithString:](&OBJC_CLASS___NSURL, "URLWithString:", v6);
  id v8 = v7;
  if (!v7)
  {
    if (s_logUsingOsLog)
    {
      id v40 = (os_log_s *)gt_default_log();
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
        goto LABEL_27;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = a2;
      uint64_t v37 = "fail: [create_transport] failed to parse GT_HOST_URL: %s";
LABEL_25:
      id v38 = v40;
      uint32_t v39 = 12;
LABEL_26:
      _os_log_fault_impl(&dword_0, v38, OS_LOG_TYPE_FAULT, v37, (uint8_t *)&buf, v39);
      goto LABEL_27;
    }

    os_signpost_id_t v42 = __stderrp;
    -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"fail: [create_transport] failed to parse GT_HOST_URL: %s",  a2),  "UTF8String");
    goto LABEL_32;
  }

  id v9 = -[NSURL scheme](v7, "scheme");
  if (-[NSString isEqualToString:](v9, "isEqualToString:", @"null"))
  {
    id v10 = 0LL;
    goto LABEL_12;
  }

  if (-[NSString isEqualToString:](v9, "isEqualToString:", @"file"))
  {
    unsigned int v11 = off_3405D8;
  }

  else
  {
    if (!-[NSString isEqualToString:](v9, "isEqualToString:", @"dysmt")
      && !-[NSString isEqualToString:](v9, "isEqualToString:", @"dysmtdeferred"))
    {
      goto LABEL_22;
    }

    unsigned int v11 = off_3405D0;
  }

  id v10 = [objc_alloc(*v11) initWithMode:1];
  [v10 setUrl:v8];
  if (!v10)
  {
LABEL_22:
    if (s_logUsingOsLog)
    {
      id v40 = (os_log_s *)gt_default_log();
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_FAULT)) {
        goto LABEL_27;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = a2;
      uint64_t v37 = "fail: [create_transport] failed to create transport; GT_HOST_URL: %s";
      goto LABEL_25;
    }

    os_signpost_id_t v42 = __stderrp;
    -[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"fail: [create_transport] failed to create transport; GT_HOST_URL: %s",
        a2),
      "UTF8String");
LABEL_32:
    fprintf(v42, "%s\n");
    goto LABEL_27;
  }

void sub_153770( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

void __copy_assignment_8_8_t0w88_s88_S_s96_s104_t112w8_s120_s128_s136_t144w8_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288( uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  __int128 v5 = *(_OWORD *)(a2 + 32);
  __int128 v6 = *(_OWORD *)(a2 + 48);
  __int128 v7 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = v6;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 32) = v5;
  objc_storeStrong((id *)(a1 + 88), *(id *)(a2 + 88));
  objc_storeStrong((id *)(a1 + 96), *(id *)(a2 + 96));
  objc_storeStrong((id *)(a1 + 104), *(id *)(a2 + 104));
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  objc_storeStrong((id *)(a1 + 120), *(id *)(a2 + 120));
  objc_storeStrong((id *)(a1 + 128), *(id *)(a2 + 128));
  objc_storeStrong((id *)(a1 + 136), *(id *)(a2 + 136));
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  objc_storeStrong((id *)(a1 + 152), *(id *)(a2 + 152));
  objc_storeStrong((id *)(a1 + 160), *(id *)(a2 + 160));
  objc_storeStrong((id *)(a1 + 168), *(id *)(a2 + 168));
  objc_storeStrong((id *)(a1 + 176), *(id *)(a2 + 176));
  objc_storeStrong((id *)(a1 + 184), *(id *)(a2 + 184));
  objc_storeStrong((id *)(a1 + 192), *(id *)(a2 + 192));
  objc_storeStrong((id *)(a1 + 200), *(id *)(a2 + 200));
  objc_storeStrong((id *)(a1 + 208), *(id *)(a2 + 208));
  objc_storeStrong((id *)(a1 + 216), *(id *)(a2 + 216));
  objc_storeStrong((id *)(a1 + 224), *(id *)(a2 + 224));
  objc_storeStrong((id *)(a1 + 232), *(id *)(a2 + 232));
  objc_storeStrong((id *)(a1 + 240), *(id *)(a2 + 240));
  objc_storeStrong((id *)(a1 + 248), *(id *)(a2 + 248));
  objc_storeStrong((id *)(a1 + 256), *(id *)(a2 + 256));
  objc_storeStrong((id *)(a1 + 264), *(id *)(a2 + 264));
  objc_storeStrong((id *)(a1 + 272), *(id *)(a2 + 272));
  objc_storeStrong((id *)(a1 + 280), *(id *)(a2 + 280));
  objc_storeStrong((id *)(a1 + 288), *(id *)(a2 + 288));
}

void __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288( id *a1)
{
}

void __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152(id *a1)
{
}

uint64_t AddResourceRestoreRequest(apr_array_header_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result = 0LL;
  uint64_t v7 = *(void *)(a2 + 24);
  int v8 = *(_DWORD *)(a3 + 4);
  if (v8 <= -10241)
  {
    if (v8 == -16313)
    {
LABEL_18:
      DYTraceDecode_MTLDevice_newBufferWithBytes_length_options( (uint64_t)&v79,  a3,  (*(_DWORD *)a3 - 36),  0LL);
      AliasStreauint64_t m = (uint64_t *)GetAliasStream(v7, *(uint64_t *)v80, a4);
      if (AliasStream) {
        uint64_t v24 = *AliasStream;
      }
      else {
        uint64_t v24 = 0LL;
      }
      dispatch_queue_t v45 = apr_pstrdup(a1->pool, *(const char **)&v80[8]);
      id v46 = apr_array_push(a1);
      uint64_t v47 = *(void *)&v80[16];
      void *v46 = 22LL;
      v46[1] = v24;
      v46[2] = a4;
      v46[3] = v45;
      void v46[4] = 0LL;
      v46[5] = v47;
      v46[7] = 0LL;
LABEL_51:
      v46[6] = 0LL;
    }

    else
    {
      if (v8 == -16236)
      {
LABEL_16:
        DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)&v79,  a3,  (*(_DWORD *)a3 - 36),  0LL);
        int v21 = (uint64_t *)GetAliasStream(v7, v79, a4);
        if (v21) {
          uint64_t v22 = *v21;
        }
        else {
          uint64_t v22 = 0LL;
        }
        BOOL v25 = apr_pstrdup(a1->pool, s);
        os_signpost_id_t v26 = (char *)apr_array_push(a1);
        int v27 = v85;
        int32x2_t v28 = vmovn_s64(v84);
        int16x4_t v29 = vmovn_s32(vuzp1q_s32((int32x4_t)vextq_s8(*(int8x16_t *)v82, *(int8x16_t *)v82, 8uLL), *(int32x4_t *)v80));
        int16x4_t v30 = vmovn_s32(vuzp1q_s32(*(int32x4_t *)&v80[16], v81));
        *(void *)os_signpost_id_t v26 = 80LL;
        *((void *)v26 + 1) = v22;
        *((void *)v26 + 2) = a4;
        *((void *)v26 + 3) = v25;
        *((int16x4_t *)v26 + 4) = v29;
        *((int16x4_t *)v26 + 5) = v30;
        *((int32x2_t *)v26 + 6) = v28;
        *((_DWORD *)v26 + 14) = v27;
      }

      else
      {
        if (v8 != -16234) {
          return result;
        }
        DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_withBytes_bytesPerRow( (uint64_t)&v79,  a3,  (*(_DWORD *)a3 - 36),  0LL);
        unsigned int v11 = (uint64_t *)GetAliasStream(v7, v79, a4);
        if (v11) {
          uint64_t v12 = *v11;
        }
        else {
          uint64_t v12 = 0LL;
        }
        dispatch_semaphore_t v51 = apr_pstrdup(a1->pool, v82[1]);
        os_signpost_id_t v26 = (char *)apr_array_push(a1);
        int32x4_t v52 = v81;
        __int16 v53 = (__int16)v82[0];
        int v54 = (int)s;
        int16x4_t v55 = vmovn_s32(vuzp1q_s32(*(int32x4_t *)v80, *(int32x4_t *)&v80[16]));
        *(void *)os_signpost_id_t v26 = 80LL;
        *((void *)v26 + 1) = v12;
        *((void *)v26 + 2) = a4;
        *((void *)v26 + 3) = v51;
        *((_WORD *)v26 + 16) = 0;
        *((_WORD *)v26 + 17) = v53;
        *(int16x4_t *)(v26 + 36) = v55;
        *((_WORD *)v26 + 22) = v52.i16[0];
        *((_WORD *)v26 + 23) = v52.i16[4];
        *((_DWORD *)v26 + 12) = v54;
        *(void *)(v26 + 52) = 0LL;
      }

      *((_DWORD *)v26 + 15) = 0;
    }

    return 1LL;
  }

  if (v8 > -10220)
  {
    switch(v8)
    {
      case -10219:
        uint64_t v79 = *(void *)(a3 + 40);
        uint64_t v86 = 12LL;
        appended = AppendString_10195((const char **)v80, a3 + 36, &v86);
        id v38 = (uint64_t *)GetAliasStream(v7, v79, a4);
        if (v38) {
          uint64_t v39 = *v38;
        }
        else {
          uint64_t v39 = 0LL;
        }
        BOOL v71 = apr_pstrdup(a1->pool, appended);
        dispatch_semaphore_t v72 = apr_array_push(a1);
        void *v72 = 57LL;
        v72[1] = v39;
        v72[2] = a4;
        v72[3] = v71;
        *((_OWORD *)v72 + 2) = 0u;
        *((_OWORD *)v72 + 3) = 0u;
        break;
      case -10194:
        uint64_t v40 = a3 + 36;
        uint64_t v79 = *(void *)(a3 + 44);
        uint64_t v86 = 16LL;
        __int128 v41 = AppendString_10195((const char **)v80, a3 + 36, &v86);
        uint64_t v42 = *(void *)(v40 + ((v86 + 3) & 0xFFFFFFFFFFFFFFFCLL));
        id v43 = (uint64_t *)GetAliasStream(v7, v79, a4);
        if (v43) {
          uint64_t v44 = *v43;
        }
        else {
          uint64_t v44 = 0LL;
        }
        uint64_t v73 = apr_pstrdup(a1->pool, v41);
        uint64_t v74 = apr_array_push(a1);
        *uint64_t v74 = 16LL;
        v74[1] = v44;
        void v74[2] = a4;
        v74[3] = v73;
        v74[4] = v42;
        uint64_t v74[5] = 0LL;
        uint64_t result = 1LL;
        v74[6] = 0LL;
        v74[7] = 0LL;
        return result;
      case -10190:
        uint64_t v14 = a3 + 36;
        uint64_t v79 = *(void *)(a3 + 52);
        uint64_t v86 = 24LL;
        id v15 = AppendString_10195((const char **)v80, a3 + 36, &v86);
        unint64_t v16 = (v86 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v17 = *(void *)(v14 + v16);
        *(void *)double v80 = v15;
        *(void *)&v80[8] = v17;
        uint64_t v86 = v16 + 8;
        id v18 = (char *)AppendString_10195((const char **)&v80[16], v14, &v86);
        uint64_t v19 = *(void *)(v14 + ((v86 + 3) & 0xFFFFFFFFFFFFFFFCLL));
        uint64_t v20 = (uint64_t *)GetAliasStream(v7, v79, a4);
        if (v20) {
          uint64_t v78 = *v20;
        }
        else {
          uint64_t v78 = 0LL;
        }
        int v77 = apr_pstrdup(a1->pool, *(const char **)v80);
        __int128 v56 = *(apr_pool_t ***)(a2 + 8);
        __int128 v57 = *v56;
        Data = GTCaptureArchive_readData(*(const char ***)a2, v56, v18, *v56, 0LL);
        if (v19) {
          LODWORD(v60) = v19;
        }
        else {
          unint64_t v60 = v58 >> 3;
        }
        __int128 v61 = apr_palloc(a1->pool, 8LL * v60);
        __int128 v62 = v61;
        if ((_DWORD)v60)
        {
          char v63 = 0;
          uint64_t v64 = v60;
          __int128 v65 = v61;
          do
          {
            uint64_t v66 = *(void *)Data;
            Data += 8;
            __int128 v67 = (uint64_t *)GetAliasStream(v7, v66, a4);
            if (v67) {
              uint64_t v68 = *v67;
            }
            else {
              uint64_t v68 = 0LL;
            }
            *v65++ = v68;
            v63 |= v68 == 0;
            --v64;
          }

          while (v64);
          apr_pool_clear(v57);
          if ((v63 & 1) != 0) {
            return 1LL;
          }
        }

        else
        {
          apr_pool_clear(v57);
        }

        int v75 = apr_array_push(a1);
        uint64_t v76 = *(void *)&v80[8];
        *int v75 = 16LL;
        v75[1] = v78;
        v75[2] = a4;
        v75[3] = v77;
        v75[4] = v76;
        v75[5] = v62;
        *((_DWORD *)v75 + 12) = v60;
        *((_DWORD *)v75 + 13) = 0;
        break;
      default:
        return result;
    }

    return 1LL;
  }

  switch(v8)
  {
    case -10240:
      DYTraceDecode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)&v79, a3);
      id v9 = (uint64_t *)GetAliasStream(v7, *(uint64_t *)v80, a4);
      if (v9) {
        uint64_t v10 = *v9;
      }
      else {
        uint64_t v10 = 0LL;
      }
      uint64_t v48 = apr_pstrdup(a1->pool, *(const char **)&v80[8]);
      id v49 = apr_array_push(a1);
      __int128 v50 = *(_OWORD *)&v80[16];
      *id v49 = 22LL;
      v49[1] = v10;
      uint64_t v49[2] = a4;
      v49[3] = v48;
      *((_OWORD *)v49 + 2) = v50;
      return 1LL;
    case -10238:
    case -10236:
      goto LABEL_16;
    case -10237:
      goto LABEL_18;
    case -10232:
      uint64_t v31 = a3 + 36;
      int v32 = strcmp((const char *)(a3 + 36), "CUulul");
      uint64_t v33 = 12LL;
      if (!v32) {
        uint64_t v33 = 8LL;
      }
      uint64_t v79 = *(void *)(v31 + v33);
      uint64_t v86 = v33 + 8;
      id v34 = AppendString_10195((const char **)v80, v31, &v86);
      *(_OWORD *)&v80[8] = *(_OWORD *)(v31 + ((v86 + 3) & 0xFFFFFFFFFFFFFFFCLL));
      unsigned int v35 = (uint64_t *)GetAliasStream(v7, v79, a4);
      if (v35) {
        uint64_t v36 = *v35;
      }
      else {
        uint64_t v36 = 0LL;
      }
      __int128 v69 = apr_pstrdup(a1->pool, v34);
      id v46 = apr_array_push(a1);
      int32x2_t v70 = vmovn_s64(*(int64x2_t *)&v80[8]);
      void *v46 = 86LL;
      v46[1] = v36;
      v46[2] = a4;
      v46[3] = v69;
      void v46[4] = v70;
      v46[7] = 0LL;
      v46[5] = 0LL;
      goto LABEL_51;
    default:
      return result;
  }

  return result;
}

uint64_t GTMTLDataSource_compareRestores(uint64_t a1, uint64_t a2)
{
  int RestoreSortingOrder = GetRestoreSortingOrder(a1);
  return RestoreSortingOrder - GetRestoreSortingOrder(a2);
}

uint64_t GetRestoreSortingOrder(uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  if (*(uint64_t *)a1 > 59)
  {
    if (v1 > 82)
    {
      if (v1 == 86) {
        return 4LL;
      }
      if (v1 == 83) {
        return 2LL;
      }
    }

    else
    {
      if (v1 == 60) {
        return 1LL;
      }
      if (v1 == 80) {
        return 5LL;
      }
    }

    return 0LL;
  }

  switch(v1)
  {
    case 16LL:
      if (*(_DWORD *)(a1 + 48)) {
        return 7LL;
      }
      else {
        return 6LL;
      }
    case 22LL:
      return 3LL;
    case 57LL:
      return 8LL;
    default:
      return 0LL;
  }

id SharedBufferArray_retainArray(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 8) copy];
  [*(id *)(a1 + 8) removeAllObjects];
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 lastObject]);
  __int128 v4 = v3;
  if (v3)
  {
    unint64_t v5 = *(void *)(a1 + 16);
    __int128 v6 = (void *)objc_claimAutoreleasedReturnValue([v3 buffer]);
    id v7 = [v6 length];
  }

  return v2;
}

void SharedCommandBuffer_clearCommandBuffer(uint64_t a1)
{
  id v2 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;

  id v3 = *(void **)(a1 + 8);
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
}

id SharedCommandBuffer_commandBuffer(uint64_t a1)
{
  id v2 = *(void **)(a1 + 8);
  if (!v2)
  {
    id v3 = InternalCommandBuffer(*(void **)a1, @"SharedCommandBuffer");
    uint64_t v4 = objc_claimAutoreleasedReturnValue(v3);
    unint64_t v5 = *(void **)(a1 + 8);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v4;

    id v2 = *(void **)(a1 + 8);
  }

  return v2;
}

id InternalCommandBuffer(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if ([v3 isStatEnabled])
  {
    id v5 = [v3 getStatLocations];
    [v3 setStatLocations:0];
    id v6 = NewCommandBuffer(v3);
    id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    [v3 setStatLocations:v5];
  }

  else
  {
    id v8 = NewCommandBuffer(v3);
    id v7 = (void *)objc_claimAutoreleasedReturnValue(v8);
  }

  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  v4));

  [v7 setLabel:v9];
  return v7;
}

id InternalBlitCommandEncoder(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if ([v4 isStatEnabled])
  {
    id v5 = [v4 getStatLocations];
    [v4 setStatLocations:0];
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 blitCommandEncoder]);
    [v4 setStatLocations:v5];
  }

  else
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 blitCommandEncoder]);
  }

  return v6;
}

void verifyPerCounterCommandData(void *a1, void *a2, void *a3, id a4)
{
  id v7 = a2;
  id v8 = a3;
  if (g_runningValidationCI)
  {
    int16x4_t v30 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKeyedSubscript:v7]);
    if (v30)
    {
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      id v28 = v8;
      obuint64_t j = v8;
      id v9 = [obj countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (!v9) {
        goto LABEL_18;
      }
      id v10 = v9;
      uint64_t v11 = *(void *)v32;
      id v12 = v7;
      while (1)
      {
        for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v32 != v11) {
            objc_enumerationMutation(obj);
          }
          uint64_t v14 = *(void *)(*((void *)&v31 + 1) + 8LL * (void)i);
          id v15 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:v14]);
          unint64_t v16 = v15;
          if (v15)
          {
            if ([v15 count] == a4) {
              goto LABEL_16;
            }
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"Counter %@ had incorrect number of results when validating %@ dictionary, size was %lu should be %lu",  v14,  v7,  [v16 count],  a4));
            uint64_t v18 = 579LL;
          }

          else
          {
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Counter %@ not found when validating %@ dictionary",  v14,  v7));
            uint64_t v18 = 575LL;
          }

          uint64_t v19 = __stdoutp;
          if (g_runningInCI) {
            uint64_t v20 = "#CI_ERROR# ";
          }
          else {
            uint64_t v20 = "";
          }
          id v21 = v17;
          fprintf( v19,  "%s%s %u: %s\n",  v20,  "void verifyPerCounterCommandData(NSDictionary *__strong, NSString *__strong, NSArray *__strong, NSUInteger)",  v18,  (const char *)[v21 UTF8String]);
          id v22 = v21;
          GTMTLReplay_handleError( 101,  (uint64_t)[v22 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"verifyPerCounterCommandData",  v18,  1);

          id v7 = v12;
LABEL_16:
        }

        id v10 = [obj countByEnumeratingWithState:&v31 objects:v35 count:16];
        if (!v10)
        {
LABEL_18:

          id v8 = v28;
          goto LABEL_23;
        }
      }
    }

    os_signpost_id_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Dictionary %@ not found in JSON dictionary",  v7));
    uint64_t v24 = __stdoutp;
    if (g_runningInCI) {
      BOOL v25 = "#CI_ERROR# ";
    }
    else {
      BOOL v25 = "";
    }
    id v26 = v23;
    fprintf( v24,  "%s%s %u: %s\n",  v25,  "void verifyPerCounterCommandData(NSDictionary *__strong, NSString *__strong, NSArray *__strong, NSUInteger)",  567,  (const char *)[v26 UTF8String]);
    id v27 = v26;
    GTMTLReplay_handleError( 101,  (uint64_t)[v27 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"verifyPerCounterCommandData",  567,  1);

LABEL_23:
  }
}

void __BatchIdFilteredCounters_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"batchfiltered"]);
  unsigned int v6 = [v5 BOOLValue];

  if (v6)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"vendorCounters"]);
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v8 = [v7 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v13;
      do
      {
        uint64_t v11 = 0LL;
        do
        {
          if (*(void *)v13 != v10) {
            objc_enumerationMutation(v7);
          }
          [*(id *)(a1 + 32) addObject:*(void *)(*((void *)&v12 + 1) + 8 * (void)v11)];
          uint64_t v11 = (char *)v11 + 1;
        }

        while (v9 != v11);
        id v9 = [v7 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }

      while (v9);
    }
  }
}

NSMutableArray *GenerateSimplePriorityList(void *a1, unint64_t *a2)
{
  id v2 = a1;
  id v3 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v2 count]);
  unint64_t v4 = 0LL;
  if ([v2 count])
  {
    unint64_t v5 = 0LL;
    do
    {
      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v2 objectAtIndexedSubscript:v5]);
      unsigned int v7 = [v6 unsignedIntValue];

      if (v7)
      {
        id v8 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v7);
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  i));
          -[NSMutableArray addObject:](v8, "addObject:", v10);
        }

        -[NSMutableArray addObject:](v3, "addObject:", v8);
        if (v4 <= v7) {
          unint64_t v4 = v7;
        }
      }

      ++v5;
    }

    while (v5 < (unint64_t)[v2 count]);
  }

  if (g_runningInCI)
  {
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Batch ID filtering will require %lu batches",  v4));
    __int128 v12 = (void *)objc_claimAutoreleasedReturnValue( [v11 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    __int128 v13 = __stdoutp;
    id v14 = v12;
    fprintf(v13, "#CI-INFO# %s\n", (const char *)[v14 UTF8String]);
  }

  if (a2) {
    *a2 = v4;
  }

  return v3;
}

id RemoveUnfilterableCounters(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 mutableCopy];
  uint64_t v21 = 0LL;
  id v22 = &v21;
  uint64_t v23 = 0x3032000000LL;
  uint64_t v24 = __Block_byref_object_copy__5384;
  BOOL v25 = __Block_byref_object_dispose__5385;
  id v26 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v6);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  void v18[2] = __RemoveUnfilterableCounters_block_invoke;
  v18[3] = &unk_58F110;
  id v7 = v4;
  id v19 = v7;
  uint64_t v20 = &v21;
  [v5 enumerateKeysAndObjectsUsingBlock:v18];
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v8 = (id)v22[5];
  id v9 = [v8 countByEnumeratingWithState:&v14 objects:v27 count:16];
  if (v9)
  {
    uint64_t v10 = *(void *)v15;
    do
    {
      uint64_t v11 = 0LL;
      do
      {
        if (*(void *)v15 != v10) {
          objc_enumerationMutation(v8);
        }
        objc_msgSend(v5, "removeObjectForKey:", *(void *)(*((void *)&v14 + 1) + 8 * (void)v11), (void)v14);
        uint64_t v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v9 = [v8 countByEnumeratingWithState:&v14 objects:v27 count:16];
    }

    while (v9);
  }

  id v12 = [v5 copy];
  _Block_object_dispose(&v21, 8);

  return v12;
}

void sub_1561C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

uint64_t __Block_byref_object_copy__5384(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__5385(uint64_t a1)
{
}

void __RemoveUnfilterableCounters_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
}

uint64_t GTMTLReplay_CLI(const char *a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  v772 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
  v773 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
  -[NSOperationQueue setName:](v773, "setName:", @"gputools.MTLReplayer.parallelQueue");
  -[NSOperationQueue setName:](v772, "setName:", @"gputools.MTLReplayer.serialQueue");
  -[NSOperationQueue setMaxConcurrentOperationCount:](v772, "setMaxConcurrentOperationCount:", 1LL);
  if (g_runningInCI)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLReplayer attempting to open capture archive: %s",  a1));
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( [v5 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    id v7 = __stdoutp;
    id v8 = v6;
    fprintf(v7, "#CI-INFO# %s\n", (const char *)[v8 UTF8String]);
  }

  id v9 = newpool;
  DataSource = GTMTLReplayController_makeDataSource(a1, newpool);
  if (!DataSource)
  {
    id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to open capture archive: %s",  a1));
    uint64_t v20 = __stdoutp;
    int v21 = g_runningInCI;
    id v22 = v19;
    uint64_t v23 = (const char *)[v22 UTF8String];
    uint64_t v24 = "#CI_ERROR# ";
    if (!v21) {
      uint64_t v24 = "";
    }
    fprintf( v20,  "%s%s %u: %s\n",  v24,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  673,  v23);
    id v25 = v22;
    uint64_t v26 = 1LL;
    GTMTLReplay_handleError( 101,  (uint64_t)[v25 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  673,  1);
    goto LABEL_337;
  }

  if (g_runningInCI)
  {
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLReplayer opened capture archive: %s",  a1));
    id v12 = (void *)objc_claimAutoreleasedReturnValue( [v11 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    __int128 v13 = __stdoutp;
    id v14 = v12;
    fprintf(v13, "#CI-INFO# %s\n", (const char *)[v14 UTF8String]);
  }

  __int128 v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v771 = 0LL;
  [v15 createDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" withIntermediateDirectories:1 attributes:0 error:&v771];
  id v678 = v771;

  __int128 v16 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(GTMTLSMContext_getObject(**((void **)DataSource + 5), 1LL, *((void *)DataSource + 10))[5] + 64LL));
  v679 = (void *)objc_claimAutoreleasedReturnValue(v16);
  __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  v681 = (void *)objc_claimAutoreleasedReturnValue([v17 stringForKey:@"GPUMTLOverrideDeviceFamily"]);

  if (*(void *)(a2 + 40))
  {
    id v18 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
  }

  else
  {
    id v18 = v28;
  }

  v673 = v18;
  uint64_t v29 = *(void *)(GTMTLSMContext_getObject(**((void **)DataSource + 5), 1LL, *((void *)DataSource + 10))[5] + 16LL);
  int16x4_t v30 = (void (*)(void))dlsym((void *)0xFFFFFFFFFFFFFFFDLL, "MTLOverrideDeviceCreationFlags");
  if (v30) {
    v30(v29);
  }
  if (g_runningInCI)
  {
    __int128 v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Creating system default device"));
    __int128 v32 = (void *)objc_claimAutoreleasedReturnValue( [v31 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    __int128 v33 = __stdoutp;
    id v34 = v32;
    fprintf(v33, "#CI-INFO# %s\n", (const char *)[v34 UTF8String]);
  }

  id v693 = MTLCreateSystemDefaultDevice();
  if (g_runningInCI)
  {
    unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue([v693 name]);
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Selected default device %@",  v35));

    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( [v36 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);
    id v38 = __stdoutp;
    id v39 = v37;
    fprintf(v38, "#CI-INFO# %s\n", (const char *)[v39 UTF8String]);
  }

  id v40 = DEVICEOBJECT(v693);
  __int128 v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
  io_registry_entry_t v42 = [v41 acceleratorPort];

  unsigned int v770 = 0x7FFFFFFF;
  id MetalPluginName = GetMetalPluginName(v42, &v770);
  v686 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
  uint64_t v706 = v770;
  if (v770 == 0x80000000) {
    uint64_t v706 = MetalPluginTarget(v686);
  }
  int v717 = IsAGXMetalPlugin(v686, v44);
  if (v717)
  {
    id v45 = DEVICEOBJECT(v693);
    id v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
    char v47 = objc_opt_respondsToSelector(v46, "setShaderDebugInfoCaching:");

    if ((v47 & 1) != 0)
    {
      [v693 setShaderDebugInfoCaching:1];
      if (g_runningInCI)
      {
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Enabled shaderDebugInfoCaching on device"));
        id v49 = (void *)objc_claimAutoreleasedReturnValue( [v48 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

        __int128 v50 = __stdoutp;
        id v51 = v49;
        fprintf(v50, "#CI-INFO# %s\n", (const char *)[v51 UTF8String]);
      }
    }

    if ((*(_BYTE *)(a2 + 186) & 0x40) != 0)
    {
      CFTypeRef v52 = GTProfilerConfigurationVariables(v42);
      __int16 v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
      int v54 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"num_cores"]);
      unsigned int v55 = [v54 unsignedIntValue];
    }
  }

  if (g_runningInCI)
  {
    __int128 v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Calling GTMTLReplaySupport_init()"));
    __int128 v57 = (void *)objc_claimAutoreleasedReturnValue( [v56 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    unint64_t v58 = __stdoutp;
    id v59 = v57;
    fprintf(v58, "#CI-INFO# %s\n", (const char *)[v59 UTF8String]);
  }

  unint64_t v60 = -[GTMTLReplayObjectMap initWithDevice:](objc_alloc(&OBJC_CLASS___GTMTLReplayObjectMap), "initWithDevice:", v693);
  GTMTLReplaySupport_init(v693);
  GTMTLReplayController_initializeArgumentBufferSupport((uint64_t)DataSource, v693, v60);
  GTMTLReplayController_populateUnusedResources(DataSource, v60);
  if (g_runningInCI)
  {
    __int128 v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Calling GTMTLReplayController_makeController()"));
    __int128 v62 = (void *)objc_claimAutoreleasedReturnValue( [v61 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    char v63 = __stdoutp;
    id v64 = v62;
    fprintf(v63, "#CI-INFO# %s\n", (const char *)[v64 UTF8String]);
  }

  Controller = (GTMTLReplayController *)GTMTLReplayController_makeController( (uint64_t)DataSource,  v9,  v693,  v60,  0LL,  0LL);
  if ((*(_BYTE *)(a2 + 186) & 0xF0) != 0) {
    GTMTLReplayController_optimizeRestores(Controller);
  }
  v672 = v60;
  int v65 = g_runningInCI;
  if (g_runningInCI)
  {
    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Creating GTMTLReplayWireframeRenderer"));
    __int128 v67 = (void *)objc_claimAutoreleasedReturnValue( [v66 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    uint64_t v68 = __stdoutp;
    id v69 = v67;
    fprintf(v68, "#CI-INFO# %s\n", (const char *)[v69 UTF8String]);

    int v65 = g_runningInCI;
  }

  v762[1] = 0LL;
  v762[0] = 0LL;
  memset(&v762[3], 0, 24);
  __int128 v763 = 0u;
  __int128 v764 = 0u;
  __int128 v765 = 0u;
  __int128 v766 = 0u;
  __int128 v767 = 0u;
  __int128 v768 = 0u;
  uint64_t v769 = 0LL;
  if (v65)
  {
    int32x2_t v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Calling GTMTLReplayWireframeRenderer_initWithDevice()"));
    BOOL v71 = (void *)objc_claimAutoreleasedReturnValue( [v70 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    dispatch_semaphore_t v72 = __stdoutp;
    id v73 = v71;
    fprintf(v72, "#CI-INFO# %s\n", (const char *)[v73 UTF8String]);
  }

  uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultDevice]);
  GTMTLReplayWireframeRenderer_initWithDevice((uint64_t)v762, v74);

  int v75 = getenv("ATF_RESULTSDIRECTORY");
  if (!v75 || g_runningInCI)
  {
    uint64_t v76 = a2;
    if (g_runningInCI)
    {
      int v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"options.saveDestination=%s",  *(void *)(a2 + 48)));
      uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue( [v77 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

      uint64_t v79 = __stdoutp;
      id v80 = v78;
      fprintf(v79, "#CI-INFO# %s\n", (const char *)[v80 UTF8String]);

      uint64_t v76 = a2;
    }
  }

  else
  {
    uint64_t v76 = a2;
    *(void *)(a2 + 4_Block_object_dispose(va, 8) = v75;
    *(_DWORD *)(a2 + 184) |= 0x40u;
  }

  int32x4_t v81 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(v76 + 48)));
  v687 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:](&OBJC_CLASS___NSURL, "fileURLWithPath:isDirectory:", v81, 1LL));

  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  [v82 createDirectoryAtURL:v687 withIntermediateDirectories:1 attributes:0 error:0];

  id v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
  int64x2_t v84 = (void *)objc_claimAutoreleasedReturnValue([v83 lastPathComponent]);
  v680 = (void *)objc_claimAutoreleasedReturnValue([v84 stringByDeletingPathExtension]);

  unsigned int v86 = *(_DWORD *)(a2 + 184);
  if ((v86 & 1) != 0)
  {
    if (g_runningInCI)
    {
      io_registry_entry_t v132 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Calling GenerateThumbnails"));
      __int128 v133 = (void *)objc_claimAutoreleasedReturnValue( [v132 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

      uint64_t v134 = __stdoutp;
      id v135 = v133;
      fprintf(v134, "#CI-INFO# %s\n", (const char *)[v135 UTF8String]);
    }

    v758[0] = _NSConcreteStackBlock;
    v758[1] = 3221225472LL;
    v758[2] = __GTMTLReplay_CLI_block_invoke;
    v758[3] = &unk_58F138;
    id v759 = v680;
    uint64_t v761 = a3;
    id v760 = v687;
    v757 = 0LL;
    char v136 = GenerateThumbnails((uint64_t **)Controller, (uint64_t)v762, (uint64_t)&v772, (unsigned int *)a2, v758, &v757);
    v682 = v757;
    if ((v136 & 1) == 0)
    {
      GTMTLReplay_handleNSError(v682);
      uint64_t v137 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to generate thumbnails!"));
      unint64_t v138 = __stdoutp;
      int v139 = g_runningInCI;
      id v140 = v137;
      BOOL v141 = (const char *)[v140 UTF8String];
      unint64_t v142 = "#CI_ERROR# ";
      if (!v139) {
        unint64_t v142 = "";
      }
      fprintf( v138,  "%s%s %u: %s\n",  v142,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  808,  v141);
      id v143 = v140;
      GTMTLReplay_handleError( 101,  (uint64_t)[v143 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  808,  1);
    }

    id v99 = v759;
    goto LABEL_330;
  }

  if ((v86 & 0xC40000) == 0x40000)
  {
    if (g_runningInCI)
    {
      uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"profileBatchIdFilter"));
      id v88 = (void *)objc_claimAutoreleasedReturnValue( [v87 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

      id v89 = __stdoutp;
      id v90 = v88;
      fprintf(v89, "#CI-INFO# %s\n", (const char *)[v90 UTF8String]);
    }

    if ((v717 & 1) != 0)
    {
      if ((v706 & 0x80000000) == 0)
      {
        if (g_runningInCI)
        {
          BOOL v91 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"targetIndex=%d",  v706));
          id v92 = (void *)objc_claimAutoreleasedReturnValue( [v91 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

          unint64_t v93 = __stdoutp;
          id v94 = v92;
          fprintf(v93, "#CI-INFO# %s\n", (const char *)[v94 UTF8String]);
        }

        uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultDevice]);
        id Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v95);
        id v97 = (void *)objc_claimAutoreleasedReturnValue(Analysis);
        v682 = (NSMutableArray *)[v97 mutableCopy];

        __int128 v98 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableArray objectForKeyedSubscript:]( v682,  "objectForKeyedSubscript:",  @"DerivedCounterDictionary"));
        id v99 = [v98 mutableCopy];

        verifyCounterDictionary(v99);
        v710 = (void *)objc_claimAutoreleasedReturnValue([v99 objectForKeyedSubscript:@"DerivedCounters"]);
        int v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
        __int128 v101 = (void *)objc_claimAutoreleasedReturnValue([v100 pathForResource:@"GPUCounterGraph" ofType:@"plist"]);

        id v102 = v101;
        v718 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableSet, v103);
        if (v102)
        {
          uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithContentsOfFile:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithContentsOfFile:",  v102));
          BOOL v105 = v104;
          if (v104)
          {
            BOOL v106 = (void *)objc_claimAutoreleasedReturnValue([v104 objectForKey:@"counters"]);
            p_isa = _NSConcreteStackBlock;
            uint64_t v810 = 3221225472LL;
            uint64_t v811 = (uint64_t)__BatchIdFilteredCounters_block_invoke;
            v812 = (__CFString *)&unk_58F0E8;
            id v813 = v718;
            [v106 enumerateKeysAndObjectsUsingBlock:&p_isa];
          }
        }

        [v718 addObject:@"GPUTime"];
        id v107 = RemoveUnfilterableCounters(v710, v718);
        uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue(v107);
        [v99 setObject:v108 forKeyedSubscript:@"DerivedCounters"];
        -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  v99,  @"DerivedCounterDictionary");
        if (g_runningInCI)
        {
          id v109 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"Filtered counter list from %lu to %lu counters",  [v710 count],  objc_msgSend(v108, "count")));
          uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue( [v109 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

          id v111 = __stdoutp;
          id v112 = v110;
          fprintf(v111, "#CI-INFO# %s\n", (const char *)[v112 UTF8String]);
        }

        id v113 = GTMTLReplayHost_rawCounters(v108);
        v694 = (void *)objc_claimAutoreleasedReturnValue(v113);
        id DerivedDataPayload = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
        unint64_t v115 = (void *)objc_claimAutoreleasedReturnValue(DerivedDataPayload);
        id v116 = [v115 mutableCopy];

        int v117 = GTMTLReplayHost_rawCountersToNormalizeSet(v108);
        obuint64_t j = (id)objc_claimAutoreleasedReturnValue(v117);
        [v116 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoBlitSampling"];
        [v116 setObject:&__kCFBooleanTrue forKeyedSubscript:@"SampleEncoders"];
        [v116 setObject:&__kCFBooleanFalse forKeyedSubscript:@"SplitEncoderData"];
        [v116 setObject:obj forKeyedSubscript:@"NormalizedCounters"];
        int v118 = (void *)objc_claimAutoreleasedReturnValue([v116 objectForKeyedSubscript:@"activePerEncoderDrawCallCount"]);
        if (v118)
        {
          [v116 setObject:v682 forKeyedSubscript:@"derivedCounterInfo"];
          int v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  (*(_DWORD *)(a2 + 184) >> 18) & 1));
          [v116 setObject:v119 forKeyedSubscript:@"profileBatchIdFilter"];

          [v116 setObject:v694 forKeyedSubscript:@"profileCounters"];
          [v116 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
          char v120 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v706));
          [v116 setObject:v120 forKeyedSubscript:@"gpuTarget"];

          SimplePriorityList = GenerateSimplePriorityList(v118, 0LL);
          uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue(SimplePriorityList);
          [v116 setObject:v122 forKeyedSubscript:@"encoderBatchPriorityList"];

          [v116 setObject:0 forKeyedSubscript:@"pause"];
          [v116 setObject:&__kCFBooleanTrue forKeyedSubscript:@"resume"];
          [v116 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
          p_isa = (void **)objc_claimAutoreleasedReturnValue([v687 path]);
          uint64_t v810 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
          uint64_t v811 = 256LL;
          uint64_t v123 = -[GTShaderProfilerHelper initWithOptions:]( objc_alloc(&OBJC_CLASS___GTShaderProfilerHelper),  "initWithOptions:",  &p_isa);
          -[GTShaderProfilerHelper profileBatchIdFilteredData:withPayload:forReplayController:]( v123,  "profileBatchIdFilteredData:withPayload:forReplayController:",  Controller->var0,  v116);
          objc_initWeak(&location, v123);
          v755[0] = _NSConcreteStackBlock;
          v755[1] = 3221225472LL;
          v755[2] = __GTMTLReplay_CLI_block_invoke_2;
          v755[3] = &unk_58F160;
          objc_copyWeak(&v756, &location);
          GTMTLReplayClient_streamBatchFilteredData((uint64_t)Controller, (id *)&v772, v116, v755);
          if (g_runningInCI)
          {
            int v124 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Waiting for batch ID streaming..."));
            uint64_t v125 = (void *)objc_claimAutoreleasedReturnValue( [v124 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            uint64_t v126 = __stdoutp;
            id v127 = v125;
            fprintf(v126, "#CI-INFO# %s\n", (const char *)[v127 UTF8String]);
          }

          -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
          if (g_runningInCI)
          {
            id v128 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Finished"));
            __int16 v129 = (void *)objc_claimAutoreleasedReturnValue( [v128 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            id v130 = __stdoutp;
            id v131 = v129;
            fprintf(v130, "#CI-INFO# %s\n", (const char *)[v131 UTF8String]);
          }

          objc_destroyWeak(&v756);
          objc_destroyWeak(&location);
        }

        else
        {
          uint64_t v368 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"activePerEncoderDrawCallCount missing in payload"));
          v369 = __stdoutp;
          int v370 = g_runningInCI;
          id v371 = v368;
          v372 = (const char *)[v371 UTF8String];
          uint64_t v373 = "#CI_ERROR# ";
          if (!v370) {
            uint64_t v373 = "";
          }
          fprintf( v369,  "%s%s %u: %s\n",  v373,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  854,  v372);
          id v374 = v371;
          GTMTLReplay_handleError( 101,  (uint64_t)[v374 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  854,  1);
        }

        goto LABEL_330;
      }

      os_signpost_id_t v239 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"-profileBatchIdFilter only supported on recent AGX devices"));
      uint64_t v240 = __stdoutp;
      int v241 = g_runningInCI;
      id v242 = v239;
      __int128 v243 = (const char *)[v242 UTF8String];
      id v244 = "#CI_ERROR# ";
      if (!v241) {
        id v244 = "";
      }
      fprintf( v240,  "%s%s %u: %s\n",  v244,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  821,  v243);
      id v684 = v242;
      GTMTLReplay_handleError( 101,  (uint64_t)[v684 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  821,  1);
    }

    else
    {
      int v226 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"-profileBatchIdFilter only supported on AGX devices"));
      __int128 v227 = __stdoutp;
      int v228 = g_runningInCI;
      id v229 = v226;
      BOOL v230 = (const char *)[v229 UTF8String];
      __int128 v231 = "#CI_ERROR# ";
      if (!v228) {
        __int128 v231 = "";
      }
      fprintf( v227,  "%s%s %u: %s\n",  v231,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  817,  v230);
      id v683 = v229;
      GTMTLReplay_handleError( 101,  (uint64_t)[v683 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  817,  1);
    }

    goto LABEL_331;
  }

  id v25 = v678;
  if ((v86 & 0x100) == 0)
  {
    if ((v86 & 0x20000) != 0)
    {
      if (v717)
      {
        unint64_t v232 = (NSMutableArray *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v85);
        -[NSMutableArray setObject:forKeyedSubscript:]( v232,  "setObject:forKeyedSubscript:",  v686,  @"MetalPluginName");
        -[NSMutableArray setObject:forKeyedSubscript:]( v232,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"UseMTLCounters");
        -[NSMutableArray setObject:forKeyedSubscript:]( v232,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"UseKicktimestamps");
        -[NSMutableArray setObject:forKeyedSubscript:]( v232,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CoalesceComputeEncoders");
        -[NSMutableArray setObject:forKeyedSubscript:]( v232,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CoalesceBlitEncoders");
        -[NSMutableArray setObject:forKeyedSubscript:]( v232,  "setObject:forKeyedSubscript:",  &off_5A0A00,  @"GPUState");
        v682 = v232;
        id v233 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
        id v99 = (id)objc_claimAutoreleasedReturnValue(v233);
        -[NSMutableArray addEntriesFromDictionary:](v232, "addEntriesFromDictionary:", v99);
        p_isa = (void **)objc_claimAutoreleasedReturnValue([v687 path]);
        uint64_t v810 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
        uint64_t v811 = 4416LL;
        if (g_runningInCI)
        {
          v234 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Creating Streaming Shader Profiler Helper"));
          id v235 = (void *)objc_claimAutoreleasedReturnValue( [v234 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

          unint64_t v236 = __stdoutp;
          id v237 = v235;
          fprintf(v236, "#CI-INFO# %s\n", (const char *)[v237 UTF8String]);
        }

        id v238 = -[GTShaderProfilerHelper initWithOptions:]( objc_alloc(&OBJC_CLASS___GTShaderProfilerHelper),  "initWithOptions:",  &p_isa);
        -[GTShaderProfilerHelper profileShadersForDataSource:withPayload:forReplayController:]( v238,  "profileShadersForDataSource:withPayload:forReplayController:",  Controller->var0,  v682);
        objc_initWeak(&location, v238);
        v751[0] = _NSConcreteStackBlock;
        v751[1] = 3221225472LL;
        v751[2] = __GTMTLReplay_CLI_block_invoke_208;
        v751[3] = &unk_58F160;
        objc_copyWeak(&v752, &location);
        GTMTLReplayClient_streamShaderProfilingData((uint64_t)Controller, (id *)&v772, v682, v751);
        -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
        objc_destroyWeak(&v752);
        objc_destroyWeak(&location);

        goto LABEL_330;
      }
    }

    else
    {
      if ((v717 & (v86 >> 23)) == 1)
      {
        uint64_t v144 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultDevice]);
        id v145 = DYMTLReplayFrameProfiler_loadAnalysis(v144);
        __int128 v146 = (void *)objc_claimAutoreleasedReturnValue(v145);
        v682 = (NSMutableArray *)[v146 mutableCopy];

        id v150 = GTShaderProfilerStreamDataFromReplayDataSource((uint64_t **)Controller->var0, v147, v148, v149);
        id v99 = (id)objc_claimAutoreleasedReturnValue(v150);
        [v99 setMetalPluginName:v686];
        BOOL v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
        __int128 v152 = (void *)objc_claimAutoreleasedReturnValue([v151 lastPathComponent]);
        [v99 setTraceName:v152];

        [v99 setSupportsFileFormatV2:1];
        p_isa = 0LL;
        uint64_t v810 = (uint64_t)&p_isa;
        uint64_t v811 = 0x2020000000LL;
        v812 = 0LL;
        locatiouint64_t n = 0LL;
        p_locatiouint64_t n = &location;
        uint64_t v807 = 0x2020000000LL;
        uint64_t v808 = 0LL;
        v801 = 0LL;
        v802 = &v801;
        uint64_t v803 = 0x2020000000LL;
        uint64_t v804 = 0LL;
        std::__split_buffer<std::string> v153 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableArray objectForKeyedSubscript:]( v682,  "objectForKeyedSubscript:",  @"DerivedCounterDictionary"));
        BOOL v154 = v153;
        if (v153)
        {
          verifyCounterDictionary(v153);
          uint64_t v155 = (void *)objc_claimAutoreleasedReturnValue([v154 objectForKeyedSubscript:@"DerivedCounters"]);
          id v156 = GTMTLReplayHost_rawCounters(v155);
          BOOL v157 = (void *)objc_claimAutoreleasedReturnValue(v156);
          -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  v157,  @"profileCounters");

          if (g_runningInCI)
          {
            id v158 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray description](v682, "description"));
            uint64_t v159 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Derived Counters %@",  v158));

            int v160 = (void *)objc_claimAutoreleasedReturnValue( [v159 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);
            uint64_t v161 = __stdoutp;
            id v162 = v160;
            fprintf(v161, "#CI-INFO# %s\n", (const char *)[v162 UTF8String]);
          }

          id v163 = GTMTLReplayHost_rawCountersToNormalizeSet(v155);
          v719 = (void *)objc_claimAutoreleasedReturnValue(v163);
        }

        else
        {
          v719 = 0LL;
        }

        id v531 = -[GTGPUAPSConfig initForProfiling](objc_alloc(&OBJC_CLASS___GTGPUAPSConfig), "initForProfiling");
        id v715 = -[GTGPUAPSConfig initForCounters](objc_alloc(&OBJC_CLASS___GTGPUAPSConfig), "initForCounters");
        v533 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v532);
        [v533 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
        [v533 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CoalesceComputeEncoders"];
        [v533 setObject:&__kCFBooleanTrue forKeyedSubscript:@"CoalesceBlitEncoders"];
        int v534 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v706));
        [v533 setObject:v534 forKeyedSubscript:@"gpuTarget"];

        uint64_t v536 = v719;
        if (!v719) {
          uint64_t v536 = (void *)objc_opt_new(&OBJC_CLASS___NSSet, v535);
        }
        [v533 setObject:v536 forKeyedSubscript:@"NormalizedCounters"];
        if (!v719) {

        }
        [v533 setObject:v682 forKeyedSubscript:@"derivedCounterInfo"];
        [v533 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseKicktimestamps"];
        uint64_t v537 = (void *)objc_claimAutoreleasedReturnValue([v531 toDictionary]);
        [v533 setObject:v537 forKeyedSubscript:@"ProfilingConfig"];

        uint64_t v538 = (void *)objc_claimAutoreleasedReturnValue([v715 toDictionary]);
        [v533 setObject:v538 forKeyedSubscript:@"CounterConfig"];

        [v533 setObject:&__kCFBooleanTrue forKeyedSubscript:@"useOverlap"];
        id v539 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
        uint64_t v540 = (void *)objc_claimAutoreleasedReturnValue(v539);
        [v533 addEntriesFromDictionary:v540];
        if (v99)
        {
          if (g_runningInCI)
          {
            uint64_t v541 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Collecting APS Data..."));
            uint64_t v542 = (void *)objc_claimAutoreleasedReturnValue( [v541 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            uint64_t v543 = __stdoutp;
            id v544 = v542;
            fprintf(v543, "#CI-INFO# %s\n", (const char *)[v544 UTF8String]);
          }

          *(void *)&__int128 v783 = 0LL;
          *((void *)&v783 + 1) = &v783;
          *(void *)&__int128 v784 = 0x2020000000LL;
          BYTE8(v784) = 0;
          *(void *)&__int128 v779 = 0LL;
          *((void *)&v779 + 1) = &v779;
          *(void *)&__int128 v780 = 0x2020000000LL;
          BYTE8(v780) = 0;
          dispatch_semaphore_t v545 = dispatch_semaphore_create(0LL);
          v743[0] = _NSConcreteStackBlock;
          v743[1] = 3221225472LL;
          v743[2] = __GTMTLReplay_CLI_block_invoke_2_224;
          v743[3] = &unk_58F188;
          v546 = v545;
          v744 = v546;
          v746 = &v783;
          id v745 = v99;
          v747 = &p_isa;
          v748 = &v779;
          v749 = &location;
          v750 = &v801;
          GTMTLReplayClient_collectAPSData((uint64_t)Controller, (id *)&v772, v533, v743);
          if (g_runningInCI)
          {
            uint64_t v547 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Waiting for APS Data..."));
            uint64_t v548 = (void *)objc_claimAutoreleasedReturnValue( [v547 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            v549 = __stdoutp;
            id v550 = v548;
            fprintf(v549, "#CI-INFO# %s\n", (const char *)[v550 UTF8String]);
          }

          dispatch_semaphore_wait(v546, 0xFFFFFFFFFFFFFFFFLL);
          -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");

          _Block_object_dispose(&v779, 8);
          _Block_object_dispose(&v783, 8);
        }

        if ((*(_BYTE *)(a2 + 186) & 4) != 0)
        {
          id v551 = BatchIdFiterableCounters();
          v552 = (void *)objc_claimAutoreleasedReturnValue(v551);
          NSLog(@"Filered: Batch Id Filtered Derived Counters %@", v552);
          id v553 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
          v554 = (void *)objc_claimAutoreleasedReturnValue(v553);
          id v555 = [v554 mutableCopy];

          v557 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableSet, v556);
          [v555 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoBlitSampling"];
          [v555 setObject:&__kCFBooleanTrue forKeyedSubscript:@"SampleEncoders"];
          [v555 setObject:&__kCFBooleanFalse forKeyedSubscript:@"SplitEncoderData"];
          [v555 setObject:v557 forKeyedSubscript:@"NormalizedCounters"];
          v558 = (void *)objc_claimAutoreleasedReturnValue([v555 objectForKeyedSubscript:@"activePerEncoderDrawCallCount"]);
          *(void *)&__int128 v779 = 0LL;
          [v555 setObject:v682 forKeyedSubscript:@"derivedCounterInfo"];
          v559 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  (*(_DWORD *)(a2 + 184) >> 18) & 1));
          [v555 setObject:v559 forKeyedSubscript:@"profileBatchIdFilter"];

          [v555 setObject:v552 forKeyedSubscript:@"profileCounters"];
          [v555 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
          uint64_t v560 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v706));
          [v555 setObject:v560 forKeyedSubscript:@"gpuTarget"];

          unint64_t v561 = GenerateSimplePriorityList(v558, (unint64_t *)&v779);
          v562 = (void *)objc_claimAutoreleasedReturnValue(v561);
          [v555 setObject:v562 forKeyedSubscript:@"encoderBatchPriorityList"];

          [v555 setObject:0 forKeyedSubscript:@"pause"];
          [v555 setObject:&__kCFBooleanTrue forKeyedSubscript:@"resume"];
          [v555 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
          *(void *)&__int128 v783 = 0LL;
          *((void *)&v783 + 1) = &v783;
          __int128 v784 = 0x2020000000uLL;
          v742[0] = _NSConcreteStackBlock;
          v742[1] = 3221225472LL;
          v742[2] = __GTMTLReplay_CLI_block_invoke_3;
          v742[3] = &unk_58F1B0;
          v742[4] = &v783;
          v742[5] = v779;
          GTMTLReplayClient_streamBatchFilteredData((uint64_t)Controller, (id *)&v772, v555, v742);
          if (g_runningInCI)
          {
            v563 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Waiting for batch ID streaming..."));
            v564 = (void *)objc_claimAutoreleasedReturnValue( [v563 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            uint64_t v565 = __stdoutp;
            id v566 = v564;
            fprintf(v565, "#CI-INFO# %s\n", (const char *)[v566 UTF8String]);
          }

          -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
          uint64_t v567 = (void *)objc_claimAutoreleasedReturnValue([v99 archivedBatchIdFilteredCounterData]);
          id v568 = [v567 count];
          BOOL v569 = v568 == (id)v779;

          if (g_runningInCI) {
            char v570 = v569;
          }
          else {
            char v570 = 1;
          }
          if ((v570 & 1) == 0)
          {
            uint64_t v571 = v779;
            uint64_t v572 = (void *)objc_claimAutoreleasedReturnValue([v99 archivedBatchIdFilteredCounterData]);
            v573 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"Invalid batch ID fitering counter count, expected max batches: %lu, got: %lu",  v571,  [v572 count]));

            v574 = (void *)objc_claimAutoreleasedReturnValue( [v573 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);
            v575 = __stdoutp;
            id v576 = v574;
            fprintf(v575, "#CI-ERROR# %s\n", (const char *)[v576 UTF8String]);
          }

          _Block_object_dispose(&v783, 8);
        }

        if (g_runningInCI)
        {
          v577 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"Finished"));
          uint64_t v578 = (void *)objc_claimAutoreleasedReturnValue( [v577 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

          v579 = __stdoutp;
          id v580 = v578;
          fprintf(v579, "#CI-INFO# %s\n", (const char *)[v580 UTF8String]);
        }

        if (*(void *)(a2 + 48))
        {
          v581 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
          v582 = (void *)objc_claimAutoreleasedReturnValue([v581 stringByStandardizingPath]);

          LOBYTE(v783) = 0;
          v583 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          [v583 createDirectoryAtPath:v582 withIntermediateDirectories:1 attributes:0 error:0];

          unsigned __int8 v584 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          unsigned int v585 = [v584 fileExistsAtPath:v582 isDirectory:&v783];

          if ((_BYTE)v783) {
            unsigned int v586 = v585;
          }
          else {
            unsigned int v586 = 0;
          }
          if (v586 == 1)
          {
            v587 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
            v588 = (void *)objc_claimAutoreleasedReturnValue([v587 lastPathComponent]);
            id v589 = (void *)objc_claimAutoreleasedReturnValue([v588 stringByDeletingPathExtension]);
            uint64_t v590 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.gpuprofiler_raw",  v589));
            uint64_t v591 = objc_claimAutoreleasedReturnValue([v582 stringByAppendingPathComponent:v590]);

            v582 = (void *)v591;
          }

          uint64_t v592 = (void *)objc_claimAutoreleasedReturnValue([v582 pathExtension]);
          unsigned __int8 v593 = [v592 isEqualToString:@"gpuprofiler_raw"];

          if ((v593 & 1) == 0)
          {
            uint64_t v594 = objc_claimAutoreleasedReturnValue([v582 stringByAppendingPathExtension:@"gpuprofiler_raw"]);

            v582 = (void *)v594;
          }

          NSLog(@"Save Destination %@", v582);
          uint64_t v595 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          unsigned int v596 = [v595 fileExistsAtPath:v582];

          if (v596)
          {
            uint64_t v597 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
            [v597 removeItemAtPath:v582 error:0];
          }

          uint64_t v598 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v582));
          id v599 = [v99 encode:v598 error:0];

          int v600 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          NSLog( @"Written %u at Destination %@",  [v600 fileExistsAtPath:v582],  v582);

          [v99 cleanupLocalFiles];
        }

        _Block_object_dispose(&v801, 8);
        _Block_object_dispose(&location, 8);
        _Block_object_dispose(&p_isa, 8);
        goto LABEL_330;
      }

      if ((v717 & (v86 >> 22)) == 1)
      {
        uint64_t v274 = (NSMutableArray *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v85);
        -[NSMutableArray setObject:forKeyedSubscript:]( v274,  "setObject:forKeyedSubscript:",  v686,  @"MetalPluginName");
        uint64_t v275 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v706));
        -[NSMutableArray setObject:forKeyedSubscript:](v274, "setObject:forKeyedSubscript:", v275, @"gpuTarget");
        v682 = v274;

        -[NSMutableArray setObject:forKeyedSubscript:]( v274,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"UseMTLCounters");
        -[NSMutableArray setObject:forKeyedSubscript:]( v274,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"UseKicktimestamps");
        -[NSMutableArray setObject:forKeyedSubscript:]( v274,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CoalesceComputeEncoders");
        -[NSMutableArray setObject:forKeyedSubscript:]( v274,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CoalesceBlitEncoders");
        int v276 = *(_DWORD *)(a2 + 164);
        if ((v276 & 0x80000000) == 0)
        {
          if (v276 <= 2) {
            uint64_t v277 = 2LL;
          }
          else {
            uint64_t v277 = v276;
          }
          id v278 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v277));
          -[NSMutableArray setObject:forKeyedSubscript:](v274, "setObject:forKeyedSubscript:", v278, @"GPUState");
        }

        id v279 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
        uint64_t v280 = objc_claimAutoreleasedReturnValue(v279);
        -[NSMutableArray addEntriesFromDictionary:](v682, "addEntriesFromDictionary:", v280);
        id v668 = (id)v280;
        id v284 = GTShaderProfilerStreamDataFromReplayDataSource((uint64_t **)Controller->var0, v281, v282, v283);
        v720 = (void *)objc_claimAutoreleasedReturnValue(v284);
        [v720 setMetalPluginName:v686];
        os_signpost_id_t v285 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
        uint64_t v286 = (void *)objc_claimAutoreleasedReturnValue([v285 lastPathComponent]);
        [v720 setTraceName:v286];

        p_isa = 0LL;
        uint64_t v810 = (uint64_t)&p_isa;
        uint64_t v811 = 0x2020000000LL;
        v812 = 0LL;
        locatiouint64_t n = 0LL;
        p_locatiouint64_t n = &location;
        uint64_t v807 = 0x2020000000LL;
        uint64_t v808 = 0LL;
        v801 = 0LL;
        v802 = &v801;
        uint64_t v803 = 0x2020000000LL;
        uint64_t v804 = 0LL;
        if (v720)
        {
          if (g_runningInCI)
          {
            unsigned int v287 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Collecting Timeline Data..."));
            uint64_t v288 = (void *)objc_claimAutoreleasedReturnValue( [v287 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            id v289 = __stdoutp;
            id v290 = v288;
            fprintf(v289, "#CI-INFO# %s\n", (const char *)[v290 UTF8String]);
          }

          v739[0] = _NSConcreteStackBlock;
          v739[1] = 3221225472LL;
          v739[2] = __GTMTLReplay_CLI_block_invoke_4;
          v739[3] = &unk_58F1D8;
          id v291 = v720;
          id v740 = v291;
          v741 = &p_isa;
          GTMTLReplayClient_collectGPUShaderTimelineData((uint64_t)Controller, (id *)&v772, v682, v739);
          if (g_runningInCI)
          {
            uint64_t v292 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Waiting for GPU Timeline..."));
            unsigned int v293 = (void *)objc_claimAutoreleasedReturnValue( [v292 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            uint64_t v294 = __stdoutp;
            id v295 = v293;
            fprintf(v294, "#CI-INFO# %s\n", (const char *)[v295 UTF8String]);
          }

          -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
          if (g_runningInCI)
          {
            id v296 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Collecting Shader Profiler Data..."));
            os_signpost_id_t v297 = (void *)objc_claimAutoreleasedReturnValue( [v296 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            uint64_t v298 = __stdoutp;
            id v299 = v297;
            fprintf(v298, "#CI-INFO# %s\n", (const char *)[v299 UTF8String]);
          }

          v736[0] = _NSConcreteStackBlock;
          v736[1] = 3221225472LL;
          v736[2] = __GTMTLReplay_CLI_block_invoke_5;
          v736[3] = &unk_58F1D8;
          id v300 = v291;
          id v737 = v300;
          v738 = &location;
          GTMTLReplayClient_streamShaderProfilingData((uint64_t)Controller, (id *)&v772, v682, v736);
          if (g_runningInCI)
          {
            id v301 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Waiting for Shader Profiler..."));
            id v302 = (void *)objc_claimAutoreleasedReturnValue( [v301 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            unint64_t v303 = __stdoutp;
            id v304 = v302;
            fprintf(v303, "#CI-INFO# %s\n", (const char *)[v304 UTF8String]);
          }

          -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
          if (g_runningInCI)
          {
            id v305 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Colleting Batch ID Filtered Countersr..."));
            uint64_t v306 = (void *)objc_claimAutoreleasedReturnValue( [v305 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            os_signpost_id_t v307 = __stdoutp;
            id v308 = v306;
            fprintf(v307, "#CI-INFO# %s\n", (const char *)[v308 UTF8String]);
          }

          if ((*(_BYTE *)(a2 + 186) & 4) != 0)
          {
            unint64_t v309 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultDevice]);
            id v310 = DYMTLReplayFrameProfiler_loadAnalysis(v309);
            id v311 = (void *)objc_claimAutoreleasedReturnValue(v310);
            id v312 = [v311 mutableCopy];

            id v313 = (void *)objc_claimAutoreleasedReturnValue([v312 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
            id v314 = [v313 mutableCopy];

            verifyCounterDictionary(v314);
            v712 = (void *)objc_claimAutoreleasedReturnValue([v314 objectForKeyedSubscript:@"DerivedCounters"]);
            id v315 = BatchIdFiterableCounters();
            uint64_t v316 = (void *)objc_claimAutoreleasedReturnValue(v315);
            id v317 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", v316));

            [v317 addObject:@"GPUTime"];
            id v318 = RemoveUnfilterableCounters(v712, v317);
            os_signpost_id_t v319 = (void *)objc_claimAutoreleasedReturnValue(v318);
            [v314 setObject:v319 forKeyedSubscript:@"DerivedCounters"];
            [v312 setObject:v314 forKeyedSubscript:@"DerivedCounterDictionary"];
            id v320 = GTMTLReplayHost_rawCounters(v319);
            id objc = (id)objc_claimAutoreleasedReturnValue(v320);
            id v321 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
            id v322 = (void *)objc_claimAutoreleasedReturnValue(v321);
            id v323 = [v322 mutableCopy];

            os_signpost_id_t v324 = GTMTLReplayHost_rawCountersToNormalizeSet(v319);
            uint64_t v325 = objc_claimAutoreleasedReturnValue(v324);
            [v323 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoBlitSampling"];
            [v323 setObject:&__kCFBooleanTrue forKeyedSubscript:@"SampleEncoders"];
            [v323 setObject:&__kCFBooleanFalse forKeyedSubscript:@"SplitEncoderData"];
            [v323 setObject:v325 forKeyedSubscript:@"NormalizedCounters"];
            v689 = (void *)v325;
            stat v696 = (void *)objc_claimAutoreleasedReturnValue([v323 objectForKeyedSubscript:@"activePerEncoderDrawCallCount"]);
            *(void *)&__int128 v783 = 0LL;
            [v323 setObject:v312 forKeyedSubscript:@"derivedCounterInfo"];
            unsigned int v326 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  (*(_DWORD *)(a2 + 184) >> 18) & 1));
            [v323 setObject:v326 forKeyedSubscript:@"profileBatchIdFilter"];

            [v323 setObject:objc forKeyedSubscript:@"profileCounters"];
            [v323 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
            uint64_t v327 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v706));
            [v323 setObject:v327 forKeyedSubscript:@"gpuTarget"];

            unint64_t v328 = GenerateSimplePriorityList(v696, (unint64_t *)&v783);
            id v329 = (void *)objc_claimAutoreleasedReturnValue(v328);
            [v323 setObject:v329 forKeyedSubscript:@"encoderBatchPriorityList"];

            [v323 setObject:0 forKeyedSubscript:@"pause"];
            [v323 setObject:&__kCFBooleanTrue forKeyedSubscript:@"resume"];
            [v323 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
            if (g_runningInCI)
            {
              id v330 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\tBatch ID Filterable Counters: %@",  v317));
              uint64_t v331 = (void *)objc_claimAutoreleasedReturnValue( [v330 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

              __int128 v332 = __stdoutp;
              id v333 = v331;
              fprintf(v332, "#CI-INFO# %s\n", (const char *)[v333 UTF8String]);
            }

            __int128 v334 = (void *)objc_claimAutoreleasedReturnValue([v317 allObjects]);
            [v300 setBatchIdFilterableCounters:v334];

            v735[0] = _NSConcreteStackBlock;
            v735[1] = 3221225472LL;
            v735[2] = __GTMTLReplay_CLI_block_invoke_6;
            v735[3] = &unk_58F1B0;
            v735[4] = &v801;
            v735[5] = v783;
            GTMTLReplayClient_streamBatchFilteredData((uint64_t)Controller, (id *)&v772, v323, v735);
            if (g_runningInCI)
            {
              __int128 v335 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Waiting for batch ID streaming..."));
              char v336 = (void *)objc_claimAutoreleasedReturnValue( [v335 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

              v337 = __stdoutp;
              id v338 = v336;
              fprintf(v337, "#CI-INFO# %s\n", (const char *)[v338 UTF8String]);
            }

            -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
            uint64_t v339 = (void *)objc_claimAutoreleasedReturnValue([v300 archivedBatchIdFilteredCounterData]);
            id v340 = [v339 count];
            BOOL v341 = v340 == (id)v783;

            if (g_runningInCI) {
              char v342 = v341;
            }
            else {
              char v342 = 1;
            }
            if ((v342 & 1) == 0)
            {
              uint64_t v343 = v783;
              char v344 = (void *)objc_claimAutoreleasedReturnValue([v300 archivedBatchIdFilteredCounterData]);
              NSURLResourceKey v345 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"Invalid batch ID fitering counter count, expected max batches: %lu, got: %lu",  v343,  [v344 count]));

              v346 = (void *)objc_claimAutoreleasedReturnValue( [v345 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);
              uint64_t v347 = __stdoutp;
              id v348 = v346;
              fprintf(v347, "#CI-ERROR# %s\n", (const char *)[v348 UTF8String]);
            }
          }
        }

        if (g_runningInCI)
        {
          uint64_t v349 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"Finished"));
          v350 = (void *)objc_claimAutoreleasedReturnValue( [v349 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

          v351 = __stdoutp;
          id v352 = v350;
          fprintf(v351, "#CI-INFO# %s\n", (const char *)[v352 UTF8String]);
        }

        if (*(void *)(a2 + 48))
        {
          uint64_t v353 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
          LOBYTE(v783) = 0;
          v354 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          unsigned int v355 = [v354 fileExistsAtPath:v353 isDirectory:&v783];

          if ((_BYTE)v783) {
            unsigned int v356 = v355;
          }
          else {
            unsigned int v356 = 0;
          }
          if (v356 == 1)
          {
            v357 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(a2 + 48)));
            int v358 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
            uint64_t v359 = (void *)objc_claimAutoreleasedReturnValue([v358 lastPathComponent]);
            uint64_t v360 = (void *)objc_claimAutoreleasedReturnValue([v359 stringByDeletingPathExtension]);
            uint64_t v361 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.gpuprofiler_raw",  v360));
            uint64_t v362 = objc_claimAutoreleasedReturnValue([v357 stringByAppendingPathComponent:v361]);

            uint64_t v353 = (void *)v362;
          }

          id v363 = (void *)objc_claimAutoreleasedReturnValue([v353 pathExtension]);
          unsigned int v364 = [v363 isEqualToString:@"gpuprofiler_raw"];

          if (v364)
          {
            uint64_t v365 = objc_claimAutoreleasedReturnValue([v353 stringByAppendingPathExtension:@"gpuprofiler_raw"]);

            uint64_t v353 = (void *)v365;
          }

          id v734 = v678;
          uint64_t v366 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v720,  1LL,  &v734));
          id v367 = v734;

          [v366 writeToFile:v353 atomically:0];
          id v678 = v367;
        }

        _Block_object_dispose(&v801, 8);
        _Block_object_dispose(&location, 8);
        _Block_object_dispose(&p_isa, 8);

        goto LABEL_329;
      }

      if ((v86 & 0x100000) != 0)
      {
        if (v717)
        {
          uint64_t v601 = (NSMutableArray *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v85);
          -[NSMutableArray setObject:forKeyedSubscript:]( v601,  "setObject:forKeyedSubscript:",  v686,  @"MetalPluginName");
          -[NSMutableArray setObject:forKeyedSubscript:]( v601,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"UseMTLCounters");
          -[NSMutableArray setObject:forKeyedSubscript:]( v601,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"UseKicktimestamps");
          -[NSMutableArray setObject:forKeyedSubscript:]( v601,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CoalesceComputeEncoders");
          -[NSMutableArray setObject:forKeyedSubscript:]( v601,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CoalesceBlitEncoders");
          v682 = v601;
          id v602 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
          id v99 = (id)objc_claimAutoreleasedReturnValue(v602);
          -[NSMutableArray addEntriesFromDictionary:](v601, "addEntriesFromDictionary:", v99);
          p_isa = (void **)objc_claimAutoreleasedReturnValue([v687 path]);
          uint64_t v810 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
          uint64_t v811 = 576LL;
          if (g_runningInCI)
          {
            v603 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Creating Streaming Shader Profiler Helper"));
            uint64_t v604 = (void *)objc_claimAutoreleasedReturnValue( [v603 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

            uint64_t v605 = __stdoutp;
            id v606 = v604;
            fprintf(v605, "#CI-INFO# %s\n", (const char *)[v606 UTF8String]);
          }

          v607 = -[GTShaderProfilerHelper initWithOptions:]( objc_alloc(&OBJC_CLASS___GTShaderProfilerHelper),  "initWithOptions:",  &p_isa);
          -[GTShaderProfilerHelper processGPUTimelineDataSources:withPayload:forReplayController:]( v607,  "processGPUTimelineDataSources:withPayload:forReplayController:",  Controller->var0,  v682);
          objc_initWeak(&location, v607);
          v732[0] = _NSConcreteStackBlock;
          v732[1] = 3221225472LL;
          v732[2] = __GTMTLReplay_CLI_block_invoke_7;
          v732[3] = &unk_58F160;
          objc_copyWeak(&v733, &location);
          GTMTLReplayClient_collectGPUShaderTimelineData((uint64_t)Controller, (id *)&v772, v682, v732);
          -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
          objc_destroyWeak(&v733);
          objc_destroyWeak(&location);

          goto LABEL_330;
        }
      }

      else if ((v86 & 0x200) != 0)
      {
        if (v717)
        {
          v608 = (NSMutableArray *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v85);
          -[NSMutableArray setObject:forKeyedSubscript:]( v608,  "setObject:forKeyedSubscript:",  v686,  @"MetalPluginName");
          -[NSMutableArray setObject:forKeyedSubscript:]( v608,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CollectLimiters");
          id v609 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
          id v99 = (id)objc_claimAutoreleasedReturnValue(v609);
          -[NSMutableArray addEntriesFromDictionary:](v608, "addEntriesFromDictionary:", v99);
          v682 = v608;
          ShaderInfo = GTMTLReplayClient_embeddedQueryShaderInfo(Controller, (id *)&v772, v608);
          uint64_t v611 = (void *)objc_claimAutoreleasedReturnValue(ShaderInfo);
          id v612 = [v611 mutableCopy];

          [v612 setObject:v608 forKeyedSubscript:@"payload"];
          v613 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"LimiterCounters"]);
          if (v613)
          {
            unint64_t v614 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"limiter sample data"]);
            BOOL v615 = v614 == 0LL;

            if (v615)
            {
              v731 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"LimiterCounters"]);
              v723 = (void *)objc_claimAutoreleasedReturnValue([v731 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
              int v616 = (void *)objc_claimAutoreleasedReturnValue([v723 objectForKeyedSubscript:@"DerivedCounters"]);
              int v617 = GTMTLReplayHost_rawCountersToNormalizeSet(v616);
              v716 = (void *)objc_claimAutoreleasedReturnValue(v617);

              -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"NoBlitSampling");
              -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"SampleEncoders");
              -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  &__kCFBooleanFalse,  @"SplitEncoderData");
              v618 = (void *)objc_claimAutoreleasedReturnValue([v723 objectForKeyedSubscript:@"counters"]);
              -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  v618,  @"profileCounters");

              -[NSMutableArray setObject:forKeyedSubscript:]( v682,  "setObject:forKeyedSubscript:",  v716,  @"NormalizedCounters");
              off_t v619 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"gputime"]);
              v620 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"consistent time"]);
              id objf = v620;
              if (v620)
              {
                v621 = (void *)objc_claimAutoreleasedReturnValue([v620 objectForKeyedSubscript:@"gputime"]);
                v622 = v621;
                if (v621)
                {
                  id v623 = v621;

                  off_t v619 = v623;
                }
              }

              if (v619) {
                id v624 = [v619 unsignedLongLongValue];
              }
              else {
                id v624 = 0LL;
              }
              v641 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"encoder time data"]);
              unint64_t v642 = (void *)objc_claimAutoreleasedReturnValue([v612 objectForKeyedSubscript:@"kick time data"]);
              id v643 = ProcessEncoderTimeData(v641, v642, v682, (unint64_t)v624);
              uint64_t v709 = (void *)objc_claimAutoreleasedReturnValue(v643);
              __int128 v698 = v642;

              v644 = (void *)objc_claimAutoreleasedReturnValue([v709 objectAtIndexedSubscript:1]);
              id v645 = ProcessDerivedCounterDataFromDevice(v731, v682, v644);
              v646 = (void *)objc_claimAutoreleasedReturnValue(v645);

              id v647 = GTMTLReplayHost_collectSoftwareEncoderCounters((uint64_t)Controller->var0, 1);
              v648 = (void *)objc_claimAutoreleasedReturnValue(v647);
              id v649 = ComputeDerivedCounters(v731, v646, v648);
              unint64_t v650 = (void *)objc_claimAutoreleasedReturnValue(v649);
              if (v650)
              {
                [v612 setObject:v650 forKeyedSubscript:@"LimiterCounterData"];
                v651 = (void *)objc_claimAutoreleasedReturnValue( [v650 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
                v691 = (void *)objc_claimAutoreleasedReturnValue([v651 objectForKeyedSubscript:@"counters"]);

                v789[0] = @"PerCounterEncoderCallData";
                v652 = (void *)objc_claimAutoreleasedReturnValue( [v650 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
                v653 = (void *)objc_claimAutoreleasedReturnValue([v652 objectForKeyedSubscript:@"AverageSamples"]);
                id PerCounterCommandData = GTMTLReplayHost_createPerCounterCommandData(v691, v653);
                unint64_t v655 = (void *)objc_claimAutoreleasedReturnValue(PerCounterCommandData);
                v789[1] = @"MetalPluginName";
                v790[0] = v655;
                v790[1] = v686;
                uint64_t v656 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v790,  v789,  2LL));

                uint64_t v657 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization dataWithJSONObject:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "dataWithJSONObject:options:error:",  v656,  1LL,  0LL));
                BOOL v658 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingPathExtension:@"json"]);
                v659 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v658,  0LL,  v687));
                [v657 writeToURL:v659 atomically:0];
              }
            }
          }

          p_isa = (void **)objc_claimAutoreleasedReturnValue([v687 path]);
          uint64_t v810 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
          uint64_t v811 = 76LL;
          v660 = -[GTShaderProfilerHelper initWithOptions:]( objc_alloc(&OBJC_CLASS___GTShaderProfilerHelper),  "initWithOptions:",  &p_isa);
          -[GTShaderProfilerHelper analyzeShaderInfoResult:forDataSource:forReplayController:]( v660,  "analyzeShaderInfoResult:forDataSource:forReplayController:",  v612,  Controller->var0);

          goto LABEL_330;
        }
      }

      else if ((v86 & 0x80) == 0)
      {
        if ((v86 & 0x4000) != 0)
        {
          if (!strcmp(*(const char **)(a2 + 128), "all"))
          {
            v626 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultCommandQueue]);
            v682 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v626 availableCounters]);
            v629 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingString:@"_allCountersInfo.plist"]);
            uint64_t v630 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v629,  0LL,  v687));
            -[NSMutableArray writeToURL:error:](v682, "writeToURL:error:", v630, 0LL);
          }

          else
          {
            v625 = objc_alloc(&OBJC_CLASS___NSArray);
            v626 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(a2 + 128)));
            v682 = -[NSArray initWithContentsOfFile:](v625, "initWithContentsOfFile:", v626);
          }

          v787 = @"profileCounters";
          v788 = v682;
          id v99 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v788,  &v787,  1LL));
          id v631 = GTMTLReplayClient_derivedCounterData((id *)&Controller->var0, (id *)&v772, v99);
          size_t v632 = (void *)objc_claimAutoreleasedReturnValue(v631);
          ssize_t v633 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingPathExtension:@".csv"]);
          ssize_t v634 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v633,  0LL,  v687));
          WriteToCSVFromCounterData(v632, v634);

          v635 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingPathExtension:@".plist"]);
          v636 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v635,  0LL,  v687));
          WriteToPlistFromCounterData(v632, v636);

          goto LABEL_330;
        }

        if ((v86 & 0x8000) != 0)
        {
          id v627 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, v717);
          v685 = (void *)objc_claimAutoreleasedReturnValue(v627);
          id v628 = GTMTLReplayClient_queryShaderInfo((uint64_t)Controller, (id *)&v772, v685);

          goto LABEL_331;
        }

        if ((v86 & 0x80000) != 0)
        {
          id v637 = GTMTLReplayClient_collectPipelinePerformanceStatistics((uint64_t)Controller, v85);
          v682 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(v637);
          v638 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray description](v682, "description"));
          id v99 = (id)objc_claimAutoreleasedReturnValue([v638 stringByReplacingOccurrencesOfString:@"\\n" withString:@"\n"]);

          v639 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingPathExtension:@"txt"]);
          v640 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v639,  0LL,  v687));
          [v99 writeToURL:v640 atomically:0 encoding:4 error:0];

          goto LABEL_330;
        }

        if ((v86 & 0x10000) == 0)
        {
          uint64_t v522 = *(unsigned int *)(a2 + 24);
          uint64_t v523 = 0LL;
          do
          {
            if (g_runningInCI)
            {
              uint64_t v524 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"replayCapture, loop count=%d/%d",  v523,  v522));
              uint64_t v525 = (void *)objc_claimAutoreleasedReturnValue( [v524 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

              v526 = __stdoutp;
              id v527 = v525;
              fprintf(v526, "#CI-INFO# %s\n", (const char *)[v527 UTF8String]);
            }

            __int128 v528 = objc_alloc_init(&OBJC_CLASS___MTLCaptureDescriptor);
            __int128 v529 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultDevice]);
            -[MTLCaptureDescriptor setCaptureObject:](v528, "setCaptureObject:", v529);

            GTMTLReplayController_debugSubCommandStop((uint64_t)Controller, Controller->var0->var9.var3->nelts, 0LL);
            if (*(_BYTE *)(a2 + 37))
            {
              __int128 v530 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultCommandQueue]);
              [v530 finish];
            }

            GTMTLReplayController_rewind((uint64_t)Controller);

            id v678 = 0LL;
            id v25 = 0LL;
            uint64_t v523 = (v523 + 1);
            uint64_t v522 = *(unsigned int *)(a2 + 24);
          }

          while ((int)v523 < (int)v522);
        }
      }
    }

    goto LABEL_332;
  }

  if (g_runningInCI)
  {
    unint64_t v164 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"collectDerivedCounters"));
    unint64_t v165 = (void *)objc_claimAutoreleasedReturnValue( [v164 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    __int128 v166 = __stdoutp;
    id v167 = v165;
    fprintf(v166, "#CI-INFO# %s\n", (const char *)[v167 UTF8String]);
  }

  var0 = Controller->var0;
  v682 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  var2 = var0->var9.var2;
  int nelts = var2->nelts;
  if (nelts < 1)
  {
    unsigned int v174 = &stru_591D98;
    unsigned int v175 = &stru_591D98;
    v675 = &stru_591D98;
    goto LABEL_220;
  }

  id obja = 0LL;
  int v171 = 0;
  uint64_t v172 = (uint64_t)var0->var2;
  var3 = var0->var9.var3;
  unsigned int v174 = &stru_591D98;
  unsigned int v175 = &stru_591D98;
  v675 = &stru_591D98;
  v676 = var2;
  do
  {
    elts = var2->elts;
    uint64_t v177 = *(void *)&elts[32 * v171];
    v711 = &elts[32 * v171];
    unint64_t v178 = *((void *)v711 + 1);
    int v695 = v171;
    unint64_t v179 = (int)v177 + 1;
    uint64_t v180 = (v177 + 1);
    do
    {
      unsigned int v181 = var3->elts;
      unsigned int v182 = &v181[64 * v179];
      int v183 = *((_DWORD *)v182 + 2);
      if (v183 <= -15926)
      {
        if (v183 <= -16293)
        {
          goto LABEL_120;
        }

        if (v183 > -16124)
        {
          BOOL v187 = (v183 + 16123) > 0x3C
              || ((1LL << (v183 - 5)) & 0x1000000000000011LL) == 0;
          int v188 = -15974;
        }

        else
        {
          BOOL v187 = (v183 + 16292) > 0x34
              || ((1LL << (v183 - 92)) & 0x10000000000811LL) == 0;
          int v188 = -16136;
        }

        if (v187 && v183 != v188) {
          goto LABEL_120;
        }
LABEL_157:
        if (v183 > -16289)
        {
          if (v183 != -16288 && v183 != -16281 && v183 != -15890) {
            goto LABEL_184;
          }
        }

        else if (v183 != -16384)
        {
          if (v183 == -16365)
          {
            signed int v214 = GTTraceFunc_argumentBytesWithMap(v182, v181[64 * v179 + 13], v172);
            id v215 = GTTraceFunc_argumentBytesWithMap(v182, v214[8], v172);
            if (v215)
            {
              unsigned int v216 = (const __CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v215));
              id v213 = v174;
            }

            else
            {
              id v213 = v174;
              unsigned int v216 = &stru_591D98;
            }

            goto LABEL_186;
          }

          if (v183 != -16339) {
            goto LABEL_184;
          }
        }

        id v211 = GTTraceFunc_argumentBytesWithMap(v182, v181[64 * v179 + 13], v172);
        uint64_t v212 = GTTraceFunc_argumentBytesWithMap(v182, v211[8], v172);
        if (v212)
        {
          id v213 = v175;
          unsigned int v175 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v212));
LABEL_185:
          unsigned int v216 = v174;
LABEL_186:

          unint64_t v178 = *((void *)v711 + 1);
          unsigned int v174 = (__CFString *)v216;
          goto LABEL_187;
        }

LABEL_187:
      uint64_t v180 = (v180 + 1);
      unint64_t v179 = (int)v180;
    }

    while (v178 > (int)v180);
    var2 = v676;
    int nelts = v676->nelts;
    int v171 = v695;
LABEL_206:
    v171 += *((_DWORD *)v711 + 5);
LABEL_207:
    ++v171;
  }

  while (v171 < nelts);
LABEL_220:

  if ((v717 & 1) != 0)
  {
    id v245 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultDevice]);
    id v246 = DYMTLReplayFrameProfiler_loadAnalysis(v245);
    uint64_t v247 = (void *)objc_claimAutoreleasedReturnValue(v246);
    id v668 = [v247 mutableCopy];

    id v248 = (void *)objc_claimAutoreleasedReturnValue([v668 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    verifyCounterDictionary(v248);
    v666 = v248;
    id v667 = (id)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"DerivedCounters"]);
    id v249 = GTMTLReplayHost_rawCounters(v667);
    id v250 = (void *)objc_claimAutoreleasedReturnValue(v249);
    [v668 setObject:v250 forKeyedSubscript:@"profileCounters"];

    id v251 = GTMTLReplayHost_generateDerivedDataPayload((uint64_t)Controller->var0, 1);
    uint64_t v252 = (void *)objc_claimAutoreleasedReturnValue(v251);
    id v253 = [v252 mutableCopy];

    __int128 v254 = GTMTLReplayHost_rawCountersToNormalizeSet(v667);
    v665 = (void *)objc_claimAutoreleasedReturnValue(v254);
    [v253 setObject:&__kCFBooleanTrue forKeyedSubscript:@"NoBlitSampling"];
    [v253 setObject:&__kCFBooleanTrue forKeyedSubscript:@"SampleEncoders"];
    [v253 setObject:&__kCFBooleanFalse forKeyedSubscript:@"SplitEncoderData"];
    [v253 setObject:v665 forKeyedSubscript:@"NormalizedCounters"];
    [v253 setObject:v668 forKeyedSubscript:@"derivedCounterInfo"];
    [v253 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseMTLCounters"];
    [v253 setObject:&__kCFBooleanTrue forKeyedSubscript:@"UseKicktimestamps"];
    id v255 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v706));
    [v253 setObject:v255 forKeyedSubscript:@"gpuTarget"];

    if ((v706 & 0x80000000) != 0)
    {
      id v486 = GTMTLReplayClient_embeddedDerivedCounterData(Controller, (id *)&v772, v668);
      uint64_t v487 = (void *)objc_claimAutoreleasedReturnValue(v486);
      uint64_t v488 = (void *)objc_claimAutoreleasedReturnValue([v487 objectForKeyedSubscript:@"counters"]);
      [v253 setObject:v488 forKeyedSubscript:@"profileCounters"];

      id v489 = ProcessDerivedCounterDataFromDevice(v487, v253, 0LL);
      __int128 v490 = (void *)objc_claimAutoreleasedReturnValue(v489);
      id v491 = GTMTLReplayHost_collectSoftwareEncoderCounters((uint64_t)Controller->var0, 1);
      __int128 v492 = (void *)objc_claimAutoreleasedReturnValue(v491);
      id v493 = ComputeDerivedCounters(v668, v490, v492);
      uint64_t v494 = (void *)objc_claimAutoreleasedReturnValue(v493);
      id v495 = [v494 mutableCopy];

      [v495 setObject:v682 forKeyedSubscript:@"TraceInformation"];
      id v496 = [v495 copy];
      uint64_t v497 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingString:@"_derivedComputedData.plist"]);
      uint64_t v498 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v497,  0LL,  v687));
      [v496 writeToURL:v498 atomically:0];

      __int128 v499 = (void *)objc_claimAutoreleasedReturnValue( [v680 stringByAppendingString:@"_derivedCounterDataFromDeviceResult.plist"]);
      __int128 v500 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v499,  0LL,  v687));
      [v490 writeToURL:v500 atomically:0];

      __int128 v501 = (void *)objc_claimAutoreleasedReturnValue([v496 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
      __int128 v502 = (void *)objc_claimAutoreleasedReturnValue([v501 objectForKeyedSubscript:@"counters"]);

      v791[0] = @"PerCounterEncoderCallData";
      v503 = (void *)objc_claimAutoreleasedReturnValue([v496 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
      int v504 = (void *)objc_claimAutoreleasedReturnValue([v503 objectForKeyedSubscript:@"AverageSamples"]);
      id v505 = GTMTLReplayHost_createPerCounterCommandData(v502, v504);
      __int128 v506 = (void *)objc_claimAutoreleasedReturnValue(v505);
      v792[0] = v506;
      v791[1] = @"MetalPluginName";
      int v507 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v668, "objectForKeyedSubscript:"));
      v792[1] = v507;
      uint64_t v508 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v792,  v791,  2LL));

      uint64_t v509 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization dataWithJSONObject:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "dataWithJSONObject:options:error:",  v508,  1LL,  0LL));
      __int128 v510 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingPathExtension:@"json"]);
      uint64_t v511 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v510,  0LL,  v687));
      [v509 writeToURL:v511 atomically:0];

      id v256 = v487;
    }

    else
    {
      id v256 = v253;
      [v256 setObject:v686 forKeyedSubscript:@"MetalPluginName"];
      p_isa = (void **)objc_claimAutoreleasedReturnValue([v687 path]);
      uint64_t v810 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
      uint64_t v811 = 321LL;
      if (g_runningInCI)
      {
        os_signpost_id_t v257 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Creating Streaming Derived Counters Helper"));
        unsigned int v258 = (void *)objc_claimAutoreleasedReturnValue( [v257 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

        __int128 v259 = __stdoutp;
        id v260 = v258;
        fprintf(v259, "#CI-INFO# %s\n", (const char *)[v260 UTF8String]);
      }

      id v261 = -[GTShaderProfilerHelper initWithOptions:]( objc_alloc(&OBJC_CLASS___GTShaderProfilerHelper),  "initWithOptions:",  &p_isa);
      -[GTShaderProfilerHelper profileShadersForDataSource:withPayload:forReplayController:]( v261,  "profileShadersForDataSource:withPayload:forReplayController:",  Controller->var0,  v256);
      objc_initWeak(&location, v261);
      v753[0] = _NSConcreteStackBlock;
      v753[1] = 3221225472LL;
      v753[2] = __GTMTLReplay_CLI_block_invoke_194;
      v753[3] = &unk_58F160;
      objc_copyWeak(&v754, &location);
      GTMTLReplayClient_streamDerivedCounterData((uint64_t)Controller, (id *)&v772, v256, v753);
      -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
      objc_destroyWeak(&v754);
      objc_destroyWeak(&location);

      id v253 = v256;
    }
  }

  else
  {
    v799[0] = @"MetalPluginName";
    v799[1] = @"GPUState";
    v800[0] = v686;
    v800[1] = &off_5A09E8;
    id v262 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v800,  v799,  2LL));
    id v263 = GTMTLReplayClient_queryShaderInfo((uint64_t)Controller, (id *)&v772, v262);
    id v668 = (id)objc_claimAutoreleasedReturnValue(v263);

    id v264 = (void *)objc_claimAutoreleasedReturnValue([v668 objectForKeyedSubscript:@"derivedCounterData"]);
    id v265 = [v264 mutableCopy];

    if (*(void *)(a2 + 56))
    {
      uint64_t v266 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
      os_signpost_id_t v267 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(a2 + 56)));
      id DerivedCounterInfo = GTMTLReplayClient_loadDerivedCounterInfo(v266, v267);
      id v269 = (void *)objc_claimAutoreleasedReturnValue(DerivedCounterInfo);

      id v270 = GTMTLReplayClient_mergeDerivedCounterInfo(v265, v269);
      int v271 = (void *)objc_claimAutoreleasedReturnValue(v270);
      id v272 = [v271 mutableCopy];

      id v273 = v272;
    }

    else
    {
      id v273 = v265;
    }

    v666 = v273;
    id v375 = (void *)objc_claimAutoreleasedReturnValue([v273 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    id v376 = [v375 mutableCopy];

    verifyCounterDictionary(v376);
    id v667 = v376;
    v377 = (void *)objc_claimAutoreleasedReturnValue([v667 objectForKeyedSubscript:@"DerivedCounters"]);
    id v253 = [v377 mutableCopy];

    v378 = (void *)objc_claimAutoreleasedReturnValue([v667 objectForKeyedSubscript:@"Instruments"]);
    id v379 = v378;
    if (v378)
    {
      uint64_t v380 = (void *)objc_claimAutoreleasedReturnValue([v378 objectForKeyedSubscript:@"Profiles"]);
      uint64_t v381 = v380;
      v728 = v379;
      if (v380)
      {
        v382 = (void *)objc_claimAutoreleasedReturnValue([v380 allKeys]);
        v383 = v382;
        if (v382)
        {
          __int128 v785 = 0u;
          __int128 v786 = 0u;
          __int128 v783 = 0u;
          __int128 v784 = 0u;
          id v384 = [v382 countByEnumeratingWithState:&v783 objects:&p_isa count:16];
          if (v384)
          {
            uint64_t v721 = *(void *)v784;
            v725 = v381;
            id objd = v383;
            do
            {
              unint64_t v385 = 0LL;
              id v707 = v384;
              do
              {
                if (*(void *)v784 != v721) {
                  objc_enumerationMutation(objd);
                }
                uint64_t v386 = (void *)objc_claimAutoreleasedReturnValue( [v725 objectForKeyedSubscript:*(void *)(*((void *)&v783 + 1) + 8 * (void)v385)]);
                uint64_t v387 = v386;
                if (v386)
                {
                  v388 = (void *)objc_claimAutoreleasedReturnValue([v386 objectForKeyedSubscript:@"DerivedCounters"]);
                  __int128 v781 = 0u;
                  __int128 v782 = 0u;
                  __int128 v779 = 0u;
                  __int128 v780 = 0u;
                  id v389 = [v388 countByEnumeratingWithState:&v779 objects:&location count:16];
                  v713 = v387;
                  if (v389)
                  {
                    uint64_t v390 = *(void *)v780;
                    do
                    {
                      for (uint64_t i = 0LL; i != v389; uint64_t i = (char *)i + 1)
                      {
                        if (*(void *)v780 != v390) {
                          objc_enumerationMutation(v388);
                        }
                        __int128 v778 = 0u;
                        __int128 v777 = 0u;
                        __int128 v776 = 0u;
                        __int128 v775 = 0u;
                        id v393 = [v392 countByEnumeratingWithState:&v775 objects:&v801 count:16];
                        if (v393)
                        {
                          uint64_t v394 = *(void *)v776;
                          do
                          {
                            for (uint64_t j = 0LL; j != v393; uint64_t j = (char *)j + 1)
                            {
                              if (*(void *)v776 != v394) {
                                objc_enumerationMutation(v392);
                              }
                              [v253 removeObjectForKey:*(void *)(*((void *)&v775 + 1) + 8 * (void)j)];
                            }

                            id v393 = [v392 countByEnumeratingWithState:&v775 objects:&v801 count:16];
                          }

                          while (v393);
                        }
                      }

                      id v389 = [v388 countByEnumeratingWithState:&v779 objects:&location count:16];
                    }

                    while (v389);
                  }

                  uint64_t v387 = v713;
                }

                unint64_t v385 = (char *)v385 + 1;
              }

              while (v385 != v707);
              v383 = objd;
              id v384 = [objd countByEnumeratingWithState:&v783 objects:&p_isa count:16];
              uint64_t v381 = v725;
            }

            while (v384);
          }
        }
      }

      id v379 = v728;
    }

    [v667 setObject:v253 forKeyedSubscript:@"DerivedCounters"];
    verifyCounterDictionary(v667);
    [v666 setObject:v667 forKeyedSubscript:@"DerivedCounterDictionary"];
    v396 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingString:@"_derivedCounterInfoResult.plist"]);
    v397 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v396,  0LL,  v687));
    [v666 writeToURL:v397 atomically:0];

    id v398 = GTMTLReplayHost_rawCounters(v253);
    v665 = (void *)objc_claimAutoreleasedReturnValue(v398);
    if (![v665 count])
    {
      uint64_t v399 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No raw counters remain from derived counter list: %@",  v253));
      uint64_t v400 = __stdoutp;
      int v401 = g_runningInCI;
      id v402 = v399;
      v403 = (const char *)[v402 UTF8String];
      uint64_t v404 = "#CI_ERROR# ";
      if (!v401) {
        uint64_t v404 = "";
      }
      fprintf( v400,  "%s%s %u: %s\n",  v404,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  928,  v403);
      id v405 = v402;
      GTMTLReplay_handleError( 101,  (uint64_t)[v405 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  928,  1);
    }

    id v406 = GTMTLReplayHost_rawCountersToNormalizeSet(v253);
    uint64_t v407 = objc_claimAutoreleasedReturnValue(v406);
    v797[0] = @"NoBlitSampling";
    v797[1] = @"SampleEncoders";
    v798[0] = &__kCFBooleanTrue;
    v798[1] = &__kCFBooleanTrue;
    v797[2] = @"SplitEncoderData";
    v797[3] = @"profileCounters";
    v798[2] = &__kCFBooleanFalse;
    v798[3] = v665;
    v797[4] = @"NormalizedCounters";
    uint64_t v662 = (void *)v407;
    v798[4] = v407;
    v661 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v798,  v797,  5LL));
    id v408 = GTMTLReplayClient_derivedCounterData((id *)&Controller->var0, (id *)&v772, v661);
    uint64_t v409 = (void *)objc_claimAutoreleasedReturnValue(v408);
    id v664 = [v409 mutableCopy];

    v795 = @"frameProfile";
    unint64_t v410 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v668, "objectForKeyedSubscript:"));
    v796 = v410;
    uint64_t v411 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v796,  &v795,  1LL));
    [v664 setObject:v411 forKeyedSubscript:@"Timing Data"];

    v412 = (void *)objc_claimAutoreleasedReturnValue([v664 objectForKeyedSubscript:@"EncoderData"]);
    if (!v412)
    {
      int v413 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"encoderData is nil"));
      uint64_t v414 = __stdoutp;
      int v415 = g_runningInCI;
      id v416 = v413;
      uint64_t v417 = (const char *)[v416 UTF8String];
      v418 = "#CI_ERROR# ";
      if (!v415) {
        v418 = "";
      }
      fprintf( v414,  "%s%s %u: %s\n",  v418,  "int GTMTLReplay_CLI(const char *, GTMTLReplayCLIOptions, void (*)(NSData *__strong, NSURL *__strong))",  947,  v417);
      id v419 = v416;
      GTMTLReplay_handleError( 101,  (uint64_t)[v419 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_CLI.m",  (uint64_t)"GTMTLReplay_CLI",  947,  1);
    }

    id v420 = GTMTLReplayHost_collectSoftwareEncoderCounters((uint64_t)Controller->var0, 0);
    v421 = (void *)objc_claimAutoreleasedReturnValue(v420);
    id v422 = ComputeDerivedCounters(v666, v412, v421);
    uint64_t v423 = (void *)objc_claimAutoreleasedReturnValue(v422);
    id v424 = [v423 mutableCopy];

    [v424 setObject:v682 forKeyedSubscript:@"TraceInformation"];
    id v663 = [v424 copy];
    uint64_t v425 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingString:@"_encoder_derivedComputedData.plist"]);
    uint64_t v426 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v425,  0LL,  v687));
    [v663 writeToURL:v426 atomically:0];

    unsigned int v427 = Controller->var0;
    v722 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v677 = v427;
    v671 = v427->var9.var2;
    int v428 = v671->nelts;
    if (v428 >= 1)
    {
      int v429 = 0;
      uint64_t v690 = (uint64_t)v427->var2;
      obje = v427->var9.var3;
      do
      {
        int v674 = v429;
        uint64_t v669 = v429;
        v670 = v671->elts;
        unint64_t v430 = &v670[32 * v429];
        uint64_t v431 = &obje->elts[64 * *(void *)v430];
        if (GTMTLReplayHost_IsFuncEnumSampledEncoder(*((_DWORD *)v431 + 2), 0, 0LL))
        {
          uint64_t RenderPassDescriptor = GetRenderPassDescriptor((uint64_t *)v431, v690);
          uint64_t v726 = RenderPassDescriptorContainsClear(RenderPassDescriptor);
          v697 = v430 + 8;
          int v433 = *(_DWORD *)v430 + 1;
          if (*((void *)v430 + 1) > (unint64_t)v433)
          {
            uint64_t v434 = v433;
            int v708 = *(_DWORD *)v430 + 1;
            do
            {
              uint64_t v435 = (uint64_t)&obje->elts[64 * v434];
              unsigned int v436 = *(_DWORD *)(v435 + 8);
              if (IsFuncEnumSampledCall(v436, 0))
              {
                uint64_t v437 = SoftwareCounterForFunc(v435, v690);
                uint64_t v439 = v438;
                __int128 v440 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v726));
                locatiouint64_t n = v440;
                uint64_t v441 = (id *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v437));
                p_locatiouint64_t n = v441;
                v442 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v439));
                uint64_t v807 = (uint64_t)v442;
                v443 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &location,  3LL));
                -[NSMutableArray addObject:](v722, "addObject:", v443);
              }

              else if (v436 >> 2 == 1073737833)
              {
                GetExecuteCommandsInBufferArgs((uint64_t)&p_isa, v435, (uint64_t)v677->var2);
                uint64_t Object = GTMTLSMContext_getObject(*(void *)v677->var5, (uint64_t)p_isa, *(void *)v435);
                GTMTLCreateIndirectCommandEncoder((uint64_t)v814, Object[13]);
                unint64_t v445 = v811;
                if (v811)
                {
                  unint64_t v446 = 0LL;
                  v729 = v812;
                  uint64_t v447 = v814[13];
                  uint64_t v448 = v814[1];
                  uint64_t v714 = v814[12];
                  uint64_t v449 = v810 << 32;
                  do
                  {
                    uint64_t v450 = (uint64_t)v729 + v447 * (v449 >> 32);
                    if (*(void *)(v450 + v448))
                    {
                      uint64_t v451 = SoftwareCounterForIndirectCommand(v448, v714, v450);
                      uint64_t v453 = v452;
                      unint64_t v454 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v726));
                      v801 = v454;
                      uint64_t v455 = (void **)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v451));
                      v802 = v455;
                      uint64_t v456 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v453));
                      uint64_t v803 = (uint64_t)v456;
                      unsigned int v457 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v801,  3LL));
                      -[NSMutableArray addObject:](v722, "addObject:", v457);
                    }

                    ++v446;
                    v449 += 0x100000000LL;
                  }

                  while (v445 > v446);
                }
              }

              uint64_t v434 = ++v708;
            }

            while (*v697 > (unint64_t)v708);
          }

          int v458 = *(_DWORD *)&v670[32 * v669 + 20] + v674;
          int v428 = v671->nelts;
        }

        else
        {
          int v458 = v674;
        }

        int v429 = v458 + 1;
      }

      while (v429 < v428);
    }

    id v459 = -[NSMutableArray copy](v722, "copy");

    id v460 = ComputeDerivedCounters(v666, v664, v459);
    int v461 = (void *)objc_claimAutoreleasedReturnValue(v460);
    id v462 = [v461 mutableCopy];

    [v462 setObject:v682 forKeyedSubscript:@"TraceInformation"];
    id v730 = [v462 copy];
    v463 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingString:@"_derivedComputedData.plist"]);
    v464 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v463,  0LL,  v687));
    [v730 writeToURL:v464 atomically:0];

    uint64_t v465 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingString:@"_derivedCounterDataFromDeviceResult.plist"]);
    v466 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v465,  0LL,  v687));
    [v664 writeToURL:v466 atomically:0];

    __int128 v467 = (void *)objc_claimAutoreleasedReturnValue([v730 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
    int v468 = (void *)objc_claimAutoreleasedReturnValue([v467 objectForKeyedSubscript:@"counters"]);

    v793[0] = @"PerCounterDrawCallData";
    uint64_t v469 = (void *)objc_claimAutoreleasedReturnValue([v730 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
    v470 = (void *)objc_claimAutoreleasedReturnValue([v469 objectForKeyedSubscript:@"AverageSamples"]);
    id v471 = GTMTLReplayHost_createPerCounterCommandData(v468, v470);
    v472 = (void *)objc_claimAutoreleasedReturnValue(v471);
    v794[0] = v472;
    v793[1] = @"PerCounterEncoderCallData";
    uint64_t v473 = (void *)objc_claimAutoreleasedReturnValue([v663 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
    uint64_t v474 = (void *)objc_claimAutoreleasedReturnValue([v473 objectForKeyedSubscript:@"AverageSamples"]);
    id v475 = GTMTLReplayHost_createPerCounterCommandData(v468, v474);
    unsigned int v476 = (void *)objc_claimAutoreleasedReturnValue(v475);
    v794[1] = v476;
    v793[2] = @"MetalPluginName";
    unsigned int v477 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v666, "objectForKeyedSubscript:"));
    v794[2] = v477;
    uint64_t v478 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v794,  v793,  3LL));

    unint64_t v479 = (void *)objc_claimAutoreleasedReturnValue([v730 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
    uint64_t v480 = (void *)objc_claimAutoreleasedReturnValue([v479 objectForKeyedSubscript:@"AverageSamples"]);
    verifyPerCounterCommandData(v478, @"PerCounterDrawCallData", v468, [v480 count]);

    uint64_t v481 = (void *)objc_claimAutoreleasedReturnValue([v663 objectForKeyedSubscript:@"derivedCounterDataForBottleneckAnalysis"]);
    unsigned int v482 = (void *)objc_claimAutoreleasedReturnValue([v481 objectForKeyedSubscript:@"AverageSamples"]);
    verifyPerCounterCommandData(v478, @"PerCounterEncoderCallData", v468, [v482 count]);

    int v483 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization dataWithJSONObject:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "dataWithJSONObject:options:error:",  v478,  1LL,  0LL));
    uint64_t v484 = (void *)objc_claimAutoreleasedReturnValue([v680 stringByAppendingPathExtension:@"json"]);
    int v485 = (void *)objc_claimAutoreleasedReturnValue( +[NSURL fileURLWithPath:isDirectory:relativeToURL:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:relativeToURL:",  v484,  0LL,  v687));
    [v483 writeToURL:v485 atomically:0];

    id v256 = v662;
  }

LABEL_329:
  id v99 = v668;
LABEL_330:

LABEL_331:
  id v25 = v678;
LABEL_332:
  if (g_runningInCI)
  {
    uint64_t v512 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"commandQueue finish"));
    uint64_t v513 = (void *)objc_claimAutoreleasedReturnValue( [v512 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    uint64_t v514 = __stdoutp;
    id v515 = v513;
    fprintf(v514, "#CI-INFO# %s\n", (const char *)[v515 UTF8String]);
  }

  uint64_t v516 = (void *)objc_claimAutoreleasedReturnValue([Controller->var1 defaultCommandQueue]);
  [v516 finish];
  -[NSOperationQueue waitUntilAllOperationsAreFinished](v773, "waitUntilAllOperationsAreFinished");
  if (g_runningInCI)
  {
    uint64_t v517 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"normal exit"));
    __int128 v518 = (void *)objc_claimAutoreleasedReturnValue( [v517 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    __int16 v519 = __stdoutp;
    id v520 = v518;
    fprintf(v519, "#CI-INFO# %s\n", (const char *)[v520 UTF8String]);
  }

  __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152(v762);
  uint64_t v26 = 0LL;
LABEL_337:

  return v26;
}

void sub_15BA14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GenerateThumbnails(uint64_t **a1, uint64_t a2, uint64_t a3, unsigned int *a4, void *a5, void **a6)
{
  id v186 = a5;
  id v8 = objc_alloc(&OBJC_CLASS___NSMutableDictionary);
  v283[0] = &__kCFBooleanTrue;
  v282[0] = @"enable";
  v282[1] = @"resolution";
  unsigned int v9 = a4[46];
  int v194 = a4;
  if ((v9 & 8) != 0)
  {
    uint64_t v10 = &off_5A0268;
  }

  else
  {
    v280[0] = @"width";
    a4 = (unsigned int *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a4[39]));
    v281[0] = a4;
    v280[1] = @"height";
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v194[40]));
    v281[1] = v6;
    v280[2] = @"format";
    v281[2] = &off_5A0A48;
    uint64_t v10 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v281,  v280,  3LL));
  }

  BOOL v11 = (v9 & 8) == 0;
  v283[1] = v10;
  id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v283,  v282,  2LL));
  uint64_t v201 = -[NSMutableDictionary initWithDictionary:](v8, "initWithDictionary:", v12);

  if (v11)
  {
  }

  apr_pool_create_ex(&newpool, 0LL, 0LL, v13);
  uint64_t v202 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 64LL);
  id v235 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 4LL);
  unsigned int v15 = v194[46];
  if ((v15 & 4) != 0)
  {
    os_signpost_id_t v239 = *a1;
    apr_pool_create_ex(parent, 0LL, 0LL, v14);
    id v213 = parent[0];
    apr_pool_create_ex(&v288, parent[0], 0LL, v40);
    unint64_t v206 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v242 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v41 = v239[14];
    if (*(int *)(v41 + 12) >= 1)
    {
      uint64_t v42 = 0LL;
      pb = v288;
      do
      {
        int v226 = *(void **)(v41 + 24);
        uint64_t v43 = *(void *)(v239[15] + 24) + (v226[4 * v42] << 6);
        int v44 = *(_DWORD *)(v43 + 8);
        if (v44 != -16286 && IsFuncEnumCreateCommandEncoder(v44))
        {
          id v45 = GTResourceTrackerMake(v239[1], v239[2], pb);
          GTResourceTrackerProcessFunction(v45, v43);
          bzero(v294, 0x2B90uLL);
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v294, (uint64_t *)v43, v239[2]);
          if (v294[0] == 70)
          {
            uint64_t v46 = 0LL;
            char v47 = v295;
            uint64_t v48 = v295;
            do
            {
              AddAttachmentToArray(v242, v48, v46++, v45[4], v239[1]);
              v48 += 8;
            }

            while (v46 != 8);
            AddAttachmentToArray(v242, v47 + 84, 8LL, v45[4], v239[1]);
            AddAttachmentToArray(v242, v47 + 90, 9LL, v45[4], v239[1]);
          }

          id v231 = -[NSMutableArray copy](v242, "copy");
          uint64_t v49 = v45[4];
          __int128 v50 = (apr_hash_index_t *)(v49 + 16);
          *(void *)(v49 + 24) = 0LL;
          *(void *)(v49 + 32) = 0LL;
          *(void *)(v49 + 16) = v49;
          *(_DWORD *)(v49 + 40) = 0;
          while (1)
          {
            id v51 = apr_hash_next(v50);
            CFTypeRef v52 = v51;
            if (!v51) {
              break;
            }
            uint64_t v53 = *(void *)(*((void *)v51 + 1) + 32LL);
            if (*(_DWORD *)(v53 + 40) == 80 && (*(void *)(v53 + 32) & 0x8000000000000000LL) == 0)
            {
              id v54 = *(id *)v53;
              id v55 = v231;
              __int128 v300 = 0u;
              __int128 v301 = 0u;
              __int128 v302 = 0u;
              __int128 v303 = 0u;
              id v56 = v55;
              id v57 = [v56 countByEnumeratingWithState:&v300 objects:&v296 count:16];
              if (v57)
              {
                uint64_t v58 = *(void *)v301;
                while (2)
                {
                  for (uint64_t i = 0LL; i != v57; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v301 != v58) {
                      objc_enumerationMutation(v56);
                    }
                    unint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v300 + 1) + 8 * (void)i) objectForKeyedSubscript:@"DependencyGraphRequestedTextureID"]);
                    BOOL v61 = [v60 unsignedLongLongValue] == v54;

                    if (v61)
                    {

                      goto LABEL_61;
                    }
                  }

                  id v57 = [v56 countByEnumeratingWithState:&v300 objects:&v296 count:16];
                  if (v57) {
                    continue;
                  }
                  break;
                }
              }

              unsigned int v293 = @"DependencyGraphRequestedTextureID";
              __int128 v62 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v54));
              id v284 = v62;
              char v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v284,  &v293,  1LL));
              -[NSMutableArray addObject:](v242, "addObject:", v63);
            }

void sub_15DC90(_Unwind_Exception *a1)
{
}

id ComputeDerivedCounters(void *a1, void *a2, void *a3)
{
  id v26 = a1;
  id v5 = a2;
  id v25 = a3;
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"counters"]);
  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"AverageSamples"]);
  id v8 = [v7 countByEnumeratingWithState:&v31 objects:v36 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v32;
    do
    {
      BOOL v11 = 0LL;
      do
      {
        if (*(void *)v32 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)v11);
        __int128 v27 = 0u;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        __int128 v30 = 0u;
        id v13 = v12;
        id v14 = [v13 countByEnumeratingWithState:&v27 objects:v35 count:16];
        if (v14)
        {
          id v15 = v14;
          uint64_t v16 = *(void *)v28;
          do
          {
            __int128 v17 = 0LL;
            do
            {
              if (*(void *)v28 != v16) {
                objc_enumerationMutation(v13);
              }
              -[NSMutableArray addObjectsFromArray:]( v6,  "addObjectsFromArray:",  *(void *)(*((void *)&v27 + 1) + 8LL * (void)v17));
              __int128 v17 = (char *)v17 + 1;
            }

            while (v15 != v17);
            id v15 = [v13 countByEnumeratingWithState:&v27 objects:v35 count:16];
          }

          while (v15);
        }

        BOOL v11 = (char *)v11 + 1;
      }

      while (v11 != v9);
      id v9 = [v7 countByEnumeratingWithState:&v31 objects:v36 count:16];
    }

    while (v9);
  }

  id v18 = (void *)objc_claimAutoreleasedReturnValue([v26 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
  verifyCounterDictionary(v18);
  id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DerivedCounters"]);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 allKeys]);

  id v21 = GTMTLReplayHost_computeDerivedCountersFromData(v24, v6, v25, v20, v26);
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);

  return v22;
}

id BatchIdFiterableCounters()
{
  if (BatchIdFiterableCounters__once != -1) {
    dispatch_once(&BatchIdFiterableCounters__once, &__block_literal_global_5536);
  }
  return (id)BatchIdFiterableCounters_filterableCounters;
}

void WriteToCSVFromCounterData(void *a1, void *a2)
{
  id v3 = a1;
  id v24 = a2;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"counters"]);
  id v25 = v3;
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"AverageSamples"]);
  uint64_t v6 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  (char *)[v4 count] + 1);
  -[NSMutableArray addObject:](v6, "addObject:", @"Index");
  uint64_t v23 = v4;
  -[NSMutableArray addObjectsFromArray:](v6, "addObjectsFromArray:", v4);
  id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v6, "componentsJoinedByString:", @","));
  -[NSMutableArray addObject:](v7, "addObject:", v8);

  -[NSMutableArray addObject:](v7, "addObject:", @"Frame Start 1");
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  obuint64_t j = v5;
  id v28 = [obj countByEnumeratingWithState:&v42 objects:v48 count:16];
  if (v28)
  {
    uint64_t v9 = 0LL;
    uint64_t v27 = *(void *)v43;
    do
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(void *)v43 != v27) {
          objc_enumerationMutation(obj);
        }
        uint64_t v29 = v10;
        BOOL v11 = *(void **)(*((void *)&v42 + 1) + 8 * v10);
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        __int128 v41 = 0u;
        id v30 = v11;
        id v32 = [v30 countByEnumeratingWithState:&v38 objects:v47 count:16];
        if (v32)
        {
          uint64_t v31 = *(void *)v39;
          do
          {
            uint64_t v12 = 0LL;
            do
            {
              if (*(void *)v39 != v31) {
                objc_enumerationMutation(v30);
              }
              uint64_t v33 = v12;
              id v13 = *(void **)(*((void *)&v38 + 1) + 8 * v12);
              __int128 v34 = 0u;
              __int128 v35 = 0u;
              __int128 v36 = 0u;
              __int128 v37 = 0u;
              id v14 = v13;
              id v15 = [v14 countByEnumeratingWithState:&v34 objects:v46 count:16];
              if (v15)
              {
                id v16 = v15;
                uint64_t v17 = *(void *)v35;
                do
                {
                  id v18 = 0LL;
                  do
                  {
                    if (*(void *)v35 != v17) {
                      objc_enumerationMutation(v14);
                    }
                    uint64_t v19 = *(void *)(*((void *)&v34 + 1) + 8LL * (void)v18);
                    -[NSMutableArray removeAllObjects](v6, "removeAllObjects");
                    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  (char *)v18 + v9));
                    -[NSMutableArray addObject:](v6, "addObject:", v20);

                    -[NSMutableArray addObjectsFromArray:](v6, "addObjectsFromArray:", v19);
                    id v21 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableArray componentsJoinedByString:]( v6,  "componentsJoinedByString:",  @","));
                    -[NSMutableArray addObject:](v7, "addObject:", v21);

                    id v18 = (char *)v18 + 1;
                  }

                  while (v16 != v18);
                  v9 += (uint64_t)v18;
                  id v16 = [v14 countByEnumeratingWithState:&v34 objects:v46 count:16];
                }

                while (v16);
              }

              uint64_t v12 = v33 + 1;
            }

            while ((id)(v33 + 1) != v32);
            id v32 = [v30 countByEnumeratingWithState:&v38 objects:v47 count:16];
          }

          while (v32);
        }

        uint64_t v10 = v29 + 1;
      }

      while ((id)(v29 + 1) != v28);
      id v28 = [obj countByEnumeratingWithState:&v42 objects:v48 count:16];
    }

    while (v28);
  }

  -[NSMutableArray addObject:](v7, "addObject:", @"Frame End 1");
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v7, "componentsJoinedByString:", @"\n"));
  [v22 writeToURL:v24 atomically:0 encoding:4 error:0];
}

void WriteToPlistFromCounterData(void *a1, void *a2)
{
  id v3 = a1;
  id v28 = a2;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"counters"]);
  uint64_t v29 = v3;
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"AverageSamples"]);
  id v32 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v5 count]);
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  obuint64_t j = v5;
  id v33 = [obj countByEnumeratingWithState:&v51 objects:v59 count:16];
  if (v33)
  {
    uint64_t v6 = 0LL;
    uint64_t v31 = *(void *)v52;
    do
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = v6;
      do
      {
        uint64_t v34 = v8;
        if (*(void *)v52 != v31) {
          objc_enumerationMutation(obj);
        }
        uint64_t v35 = v7;
        uint64_t v9 = *(void **)(*((void *)&v51 + 1) + 8 * v7);
        __int128 v38 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v9 count]);
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        __int128 v49 = 0u;
        __int128 v50 = 0u;
        id v36 = v9;
        id v39 = [v36 countByEnumeratingWithState:&v47 objects:v58 count:16];
        if (v39)
        {
          uint64_t v10 = 0LL;
          uint64_t v37 = *(void *)v48;
          do
          {
            uint64_t v11 = 0LL;
            uint64_t v12 = v10;
            do
            {
              uint64_t v40 = v12;
              if (*(void *)v48 != v37) {
                objc_enumerationMutation(v36);
              }
              uint64_t v41 = v11;
              id v13 = *(void **)(*((void *)&v47 + 1) + 8 * v11);
              id v14 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v13 count]);
              __int128 v43 = 0u;
              __int128 v44 = 0u;
              __int128 v45 = 0u;
              __int128 v46 = 0u;
              id v15 = v13;
              id v16 = [v15 countByEnumeratingWithState:&v43 objects:v57 count:16];
              if (v16)
              {
                id v17 = v16;
                uint64_t v18 = 0LL;
                uint64_t v19 = *(void *)v44;
                do
                {
                  uint64_t v20 = 0LL;
                  do
                  {
                    if (*(void *)v44 != v19) {
                      objc_enumerationMutation(v15);
                    }
                    uint64_t v21 = *(void *)(*((void *)&v43 + 1) + 8LL * (void)v20);
                    uint64_t v22 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Draw Call %llu",  (char *)v20 + v18);
                    uint64_t v23 = -[NSDictionary initWithObjects:forKeys:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithObjects:forKeys:",  v21,  v4);
                    -[NSMutableDictionary setObject:forKeyedSubscript:](v14, "setObject:forKeyedSubscript:", v23, v22);

                    uint64_t v20 = (char *)v20 + 1;
                  }

                  while (v17 != v20);
                  v18 += (uint64_t)v20;
                  id v17 = [v15 countByEnumeratingWithState:&v43 objects:v57 count:16];
                }

                while (v17);
              }

              uint64_t v10 = v40 + 1;
              id v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Command Encoder %llu",  v40);
              -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v14, v24);

              uint64_t v11 = v41 + 1;
              uint64_t v12 = v40 + 1;
            }

            while ((id)(v41 + 1) != v39);
            id v39 = [v36 countByEnumeratingWithState:&v47 objects:v58 count:16];
          }

          while (v39);
        }

        uint64_t v6 = v34 + 1;
        id v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Command Buffer %llu",  v34);
        -[NSMutableDictionary setObject:forKeyedSubscript:](v32, "setObject:forKeyedSubscript:", v38, v25);

        uint64_t v7 = v35 + 1;
        uint64_t v8 = v34 + 1;
      }

      while ((id)(v35 + 1) != v33);
      id v33 = [obj countByEnumeratingWithState:&v51 objects:v59 count:16];
    }

    while (v33);
  }

  id v55 = @"Frame 0";
  id v56 = v32;
  id v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v56,  &v55,  1LL));
  uint64_t v42 = 0LL;
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v26,  100LL,  0LL,  &v42));

  [v27 writeToURL:v28 atomically:0];
}

void __GenerateThumbnails_block_invoke(uint64_t a1)
{
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  obuint64_t j = *(id *)(a1 + 32);
  id v23 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
  if (v23)
  {
    uint64_t v22 = *(void *)v31;
    do
    {
      for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v31 != v22) {
          objc_enumerationMutation(obj);
        }
        id v3 = *(void **)(*((void *)&v30 + 1) + 8LL * (void)i);
        if ((unint64_t)[v3 length] >= 9)
        {
          unint64_t v4 = 8LL;
          do
          {
            id v5 = v3;
            uint64_t v6 = (unsigned int *)((char *)[v5 bytes] + v4);
            unsigned int v7 = v6[1];
            if (v7 == -10236 || v7 == -16236)
            {
              DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)v29,  (uint64_t)v6,  *v6 - 36,  0LL);
              uint64_t v9 = *(void **)(a1 + 40);
              uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v29[0]));
              uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:v10]);

              uint64_t v12 = *(void **)(a1 + 48);
              id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v29[9]));
              id v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v13]);

              id v15 = *(void **)(*(void *)(a1 + 64) + 8LL);
              v24[0] = _NSConcreteStackBlock;
              v24[1] = 3221225472LL;
              v24[2] = __GenerateThumbnails_block_invoke_2;
              v24[3] = &unk_58F200;
              id v25 = *(id *)(a1 + 48);
              id v16 = *(id *)(a1 + 56);
              id v27 = v11;
              id v28 = v16;
              id v26 = v14;
              id v17 = v11;
              id v18 = v14;
              [v15 addOperationWithBlock:v24];
            }

            uint64_t v19 = *v6;
            if ((*((_BYTE *)v6 + 33) & 0x10) != 0)
            {
              uint64_t v20 = *v6;
              do
              {
                uint64_t v6 = (unsigned int *)((char *)v6 + v19);
                uint64_t v19 = *v6;
                v20 += v19;
              }

              while ((*((_BYTE *)v6 + 33) & 0x20) == 0);
            }

            else
            {
              uint64_t v20 = *v6;
            }

            v4 += v20;
          }

          while (v4 < (unint64_t)[v5 length]);
        }
      }

      id v23 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
    }

    while (v23);
  }
}

void __GenerateThumbnails_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 40);
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectAtIndexedSubscript:0]);
  unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectAtIndexedSubscript:1]);
  (*(void (**)(uint64_t, uint64_t, id, void *))(v2 + 16))(v2, v3, v5, v4);
}

void FetchResourceObject(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = (void *)os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v5);
  uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NSOperation);
  objc_initWeak(&location, v8);
  uint64_t v9 = &_dispatch_main_q;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __FetchResourceObject_block_invoke;
  block[3] = &unk_58F270;
  id v28 = a1;
  uint64_t v10 = v8;
  id v27 = v10;
  dispatch_async(&_dispatch_main_q, block);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = __FetchResourceObject_block_invoke_2;
  v23[3] = &unk_58F2C0;
  uint64_t v11 = &_dispatch_main_q;
  id v24 = &_dispatch_main_q;
  v25[1] = a1;
  objc_copyWeak(v25, &location);
  -[NSOperation setCompletionBlock:](v10, "setCompletionBlock:", v23);
  objc_destroyWeak(v25);

  id v15 = _NSConcreteStackBlock;
  uint64_t v16 = 3221225472LL;
  id v17 = __FetchResourceObject_block_invoke_4;
  id v18 = &unk_58F2E8;
  objc_copyWeak(v21, &location);
  v21[1] = a1;
  id v12 = v5;
  id v19 = v12;
  id v13 = v6;
  id v20 = v13;
  _DWORD v21[2] = v7;
  int v22 = 0;
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v15));
  objc_msgSend(a1[32], "addOperation:", v14, v15, v16, v17, v18);
  -[NSOperation addDependency:](v10, "addDependency:", v14);
  [a1[33] addOperation:v10];

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
}

void sub_15F438(_Unwind_Exception *a1)
{
}

id __FetchResourceObject_block_invoke(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 40) + 272) addObject:*(void *)(a1 + 32)];
}

void __FetchResourceObject_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(dispatch_queue_s **)(a1 + 32);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = __FetchResourceObject_block_invoke_3;
  v2[3] = &unk_58F298;
  v3[1] = *(id *)(a1 + 48);
  objc_copyWeak(v3, (id *)(a1 + 40));
  dispatch_async(v1, v2);
  objc_destroyWeak(v3);
}

void __FetchResourceObject_block_invoke_4(uint64_t a1)
{
  __int128 v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  1LL));
  v35[0] = &v47;
  v35[1] = 1024LL;
  id v29 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 4096LL));
  id v36 = v29;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  unsigned __int8 v3 = [WeakRetained isCancelled];

  if ((v3 & 1) == 0)
  {
    [*(id *)(*(void *)(a1 + 56) + 288) waitUntilDownloadCapacity];
    uint64_t v4 = *(void *)(*(void *)(a1 + 56) + 8LL);
    [*(id *)(v4 + 24) releaseBuffer];
    [*(id *)(v4 + 16) waitUntilCapacity];
    id Attributes = GetAttributes(*(void *)(a1 + 56), *(void **)(a1 + 32));
    id v6 = (id)objc_claimAutoreleasedReturnValue(Attributes);
    uint64_t v37 = (unsigned int **)v35;
    id v7 = v30;
    uint64_t v38 = (uint64_t)v7;
    id v39 = 0LL;
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(id **)(v8 + 8);
    uint64_t v34 = 0LL;
    unsigned __int8 v10 = HarvestResourceObject(v9, (apr_pool_t *)(v8 + 96), v6, &v37, &v34);
    uint64_t v11 = v34;
    id v12 = v11;
    if ((v10 & 1) == 0)
    {
      (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();

      goto LABEL_8;
    }
  }

  id v6 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
  id v13 = objc_loadWeakRetained((id *)(a1 + 48));
  unsigned __int8 v14 = [v13 isCancelled];

  if ((v14 & 1) != 0)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    [v6 clearCommandBuffer];
  }

  else
  {
    id val = objc_loadWeakRetained((id *)(a1 + 48));
    id v15 = *(void **)(a1 + 64);
    int v16 = *(_DWORD *)(a1 + 72);
    id v17 = *(void **)(a1 + 40);
    objc_initWeak(&location, val);
    id v18 = v30;
    id v19 = v29;
    id v20 = v17;
    uint64_t v37 = (unsigned int **)_NSConcreteStackBlock;
    uint64_t v38 = 3221225472LL;
    id v39 = __FetchResourceObjectReplyOperation_block_invoke;
    uint64_t v40 = &unk_58F380;
    objc_copyWeak(v44, &location);
    id v21 = v18;
    id v41 = v21;
    v44[1] = v15;
    int v45 = v16;
    id v22 = v19;
    id v42 = v22;
    id v23 = v20;
    id v43 = v23;
    id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v37));

    objc_destroyWeak(v44);
    objc_destroyWeak(&location);

    id v25 = objc_loadWeakRetained((id *)(a1 + 48));
    [v25 addDependency:v24];

    id v26 = (void *)objc_claimAutoreleasedReturnValue([v6 commandBuffer]);
    v31[0] = _NSConcreteStackBlock;
    v31[1] = 3221225472LL;
    void v31[2] = __FetchResourceObject_block_invoke_21;
    void v31[3] = &unk_58F760;
    uint64_t v33 = *(void *)(a1 + 56);
    id v27 = v24;
    id v32 = v27;
    [v26 addCompletedHandler:v31];

    [v6 commitCommandBuffer];
  }

void sub_15F86C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, id location)
{
  _Unwind_Resume(a1);
}

id GetAttributes(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"functionIndex"]);
  unsigned int v5 = [v4 unsignedIntValue];

  if (v5 == -1)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"object"]);
    id v8 = [v7 unsignedLongLongValue];

    id v6 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) objectAtIndexedSubscript:v8]);
  }

  else
  {
    id v6 = v3;
  }

  uint64_t v9 = v6;

  return v9;
}

void __FetchResourceObjectReplyOperation_block_invoke(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  unsigned __int8 v3 = [WeakRetained isCancelled];

  if ((v3 & 1) != 0)
  {
    (*(void (**)(void, void, void))(*(void *)(a1 + 48) + 16LL))(*(void *)(a1 + 48), 0LL, 0LL);
  }

  else
  {
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "allKeys", 0));
    id v5 = [v4 countByEnumeratingWithState:&v24 objects:v32 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v25;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v25 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void *)(*((void *)&v24 + 1) + 8LL * (void)i);
          unsigned __int8 v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v9]);
          id v11 = PreprocessICBData(v10);
          id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
          [*(id *)(a1 + 32) setObject:v12 forKeyedSubscript:v9];
        }

        id v6 = [v4 countByEnumeratingWithState:&v24 objects:v32 count:16];
      }

      while (v6);
    }

    id v13 = g_signpostLog;
    unsigned __int8 v14 = (os_log_s *)v13;
    os_signpost_id_t v15 = *(void *)(a1 + 64);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v13))
    {
      int v16 = *(_DWORD *)(a1 + 72);
      id v17 = [*(id *)(a1 + 40) length];
      *(_DWORD *)__int128 buf = 67109376;
      int v29 = v16;
      __int16 v30 = 2048;
      id v31 = v17;
      _os_signpost_emit_with_name_impl( &dword_0,  v14,  OS_SIGNPOST_INTERVAL_BEGIN,  v15,  "Replayer-5-network",  "%u. sendFbufStreamData %{xcode:size-in-bytes}lu",  buf,  0x12u);
    }

    uint64_t v18 = *(void *)(a1 + 48);
    id v19 = [*(id *)(a1 + 40) copy];
    id v20 = [*(id *)(a1 + 32) copy];
    (*(void (**)(uint64_t, id, id))(v18 + 16))(v18, v19, v20);

    id v21 = g_signpostLog;
    id v22 = (os_log_s *)v21;
    os_signpost_id_t v23 = *(void *)(a1 + 64);
    if (v23 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v21))
    {
      *(_WORD *)__int128 buf = 0;
      _os_signpost_emit_with_name_impl( &dword_0,  v22,  OS_SIGNPOST_INTERVAL_END,  v23,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
    }
  }

id __FetchResourceObject_block_invoke_21(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 40) + 264) addOperation:*(void *)(a1 + 32)];
}

id PreprocessICBData(void *a1)
{
  id v1 = a1;
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSArray, v2);
  if ((objc_opt_isKindOfClass(v1, v3) & 1) != 0 && [v1 count] == (char *)&dword_0 + 2)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v1 objectAtIndexedSubscript:0]);
    if ((IsResourceIndirectCommandBuffer(v4) & 1) == 0)
    {
      id v12 = v1;
LABEL_152:

      goto LABEL_153;
    }

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v1 objectAtIndexedSubscript:1]);
    id v6 = &CATransform3DIdentity_ptr;
    uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSData, v7);
    if ((objc_opt_isKindOfClass(v5, v8) & 1) == 0 || [v5 length] != &dword_18)
    {
      id v12 = v1;
LABEL_151:

      goto LABEL_152;
    }

    uint64_t v9 = (unsigned __int16 *)[v5 bytes];
    id v10 = v4;
    GTMTLCreateIndirectCommandEncoder((uint64_t)&v143, (uint64_t)v9);
    int v11 = v9[4];
    if ((v11 & 0xFE70) != 0)
    {
      if ((v11 & 0xFFFFFF9F) != 0)
      {

        goto LABEL_149;
      }

      id v111 = v1;
      id v112 = v10;
      id v113 = v5;
      id v114 = v4;
      id v137 = v10;
      id v80 = [v137 size];
      uint64_t v81 = v156;
      id v117 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData, "dataWithLength:", v156 * (void)v80));
      id v135 = (char *)[v117 mutableBytes];
      if (v80)
      {
        id v140 = 0LL;
        uint64_t v82 = 0LL;
        uint64_t v123 = v155 + 72;
        id v125 = 0LL;
        id v83 = v143;
        uint64_t v131 = v81;
        uint64_t v133 = v144;
        uint64_t v121 = v145;
        uint64_t v129 = v155;
        unint64_t v127 = (unint64_t)(v155 - v153) >> 3;
        int64x2_t v84 = &v135[v153];
        uint64_t v119 = v150;
        uint64_t v85 = &v135[v150];
        uint64_t v86 = &v135[v152];
        while (1)
        {
          id contexta = objc_autoreleasePoolPush();
          uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v137 indirectComputeCommandAtIndex:v82]);
          id v88 = (uint64_t *)[v87 getCommandType];
          unint64_t v142 = &v135[v81 * (void)v82];
          *(void *)&v142[v133] = v88;
          if (v88) {
            break;
          }
LABEL_145:

          objc_autoreleasePoolPop(contexta);
          uint64_t v82 = (char *)v82 + 1;
          v84 += v81;
          v85 += v81;
          v86 += v81;
          if (v82 == v80) {
            goto LABEL_146;
          }
        }

        id v89 = v88;
        if ((int)v127 >= 1)
        {
          uint64_t v90 = 0LL;
          do
          {
            *(void *)&v84[8 * v90] = [v87 getKernelAttributeStrideAtIndex:v90];
            ++v90;
          }

          while (v127 != v90);
        }

        BOOL v91 = &v142[v129];
        if (v89 == (uint64_t *)&stru_20)
        {
          id v94 = (void *)objc_claimAutoreleasedReturnValue([v87 dispatchThreadgroupsArguments]);
          unint64_t v93 = v94;
          if (v94)
          {
            [v94 threadgroupsPerGrid];
            goto LABEL_123;
          }
        }

        else
        {
          if (v89 != &stru_20.vmsize)
          {
LABEL_129:
            if (!v83[11])
            {
              id v103 = [v87 getPipelineStateUniqueIdentifier];
              id v104 = v125;
              if (v103 != (id)-1LL) {
                id v104 = v103;
              }
              id v125 = v104;
              *(void *)&v142[v121] = v104;
            }

            uint64_t v81 = v131;
            if (!v83[10])
            {
              if (v83[13])
              {
                unint64_t v105 = 0LL;
                do
                {
                  id v106 = [v87 getKernelBufferAtIndex:v105];
                  if (v106 == (id)-1LL)
                  {
                    if (v140) {
                      id v106 = *(id *)&v140[8 * v105];
                    }
                    else {
                      id v106 = 0LL;
                    }
                  }

                  *(void *)&v85[8 * v105++] = v106;
                }

                while (v105 < v83[13]);
              }

              id v140 = &v142[v119];
              uint64_t v81 = v131;
            }

            if (v83[14])
            {
              unint64_t v107 = 0LL;
              do
              {
                *(void *)&v86[8 * v107] = [v87 getThreadgroupMemoryLengthAtIndex:v107];
                ++v107;
              }

              while (v107 < v83[14]);
            }

            goto LABEL_145;
          }

          uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v87 dispatchThreadsArguments]);
          unint64_t v93 = v92;
          if (v92)
          {
            [v92 threadsPerGrid];
LABEL_123:
            [v93 threadsPerThreadgroup];
            __int128 v95 = v169;
            uint64_t v96 = v170;
            __int128 v97 = v167;
            uint64_t v98 = v168;
LABEL_125:
            id v99 = &v142[v123];
            *(_OWORD *)id v99 = v95;
            *((void *)v99 + 2) = v96;
            *(_OWORD *)(v99 + 24) = v97;
            *((void *)v99 + 5) = v98;
            if (v87)
            {
              [v87 getStageInRegion];
              __int128 v100 = v164;
              __int128 v101 = v165;
              __int128 v102 = v166;
            }

            else
            {
              __int128 v165 = 0u;
              __int128 v166 = 0u;
              __int128 v100 = 0uLL;
              __int128 v101 = 0uLL;
              __int128 v102 = 0uLL;
              __int128 v164 = 0u;
            }

            *(_OWORD *)BOOL v91 = v100;
            *((_OWORD *)v91 + 1) = v101;
            *((_OWORD *)v91 + 2) = v102;
            v91[64] = [v87 hasBarrier];

            goto LABEL_129;
          }
        }

        uint64_t v98 = 0LL;
        uint64_t v96 = 0LL;
        uint64_t v170 = 0LL;
        __int128 v95 = 0uLL;
        __int128 v169 = 0u;
        uint64_t v168 = 0LL;
        __int128 v167 = 0u;
        __int128 v97 = 0uLL;
        goto LABEL_125;
      }

LABEL_149:
    id v12 = (id)objc_claimAutoreleasedReturnValue(-[CATransform3D data]((id)v6[261], "data"));
    id v108 = 0LL;
    goto LABEL_150;
  }

  id v12 = v1;
LABEL_153:

  return v12;
}

void __FetchResourceObject_block_invoke_3(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 40) + 272LL);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [v1 removeObject:WeakRetained];
}

void FetchResourceObjectBatch(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  os_signpost_id_t v10 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, v7);
  id v11 = [v7 count];
  id v12 = g_signpostLog;
  id v13 = (os_log_s *)v12;
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v12))
  {
    *(_DWORD *)__int128 buf = 67109376;
    int v27 = 0;
    __int16 v28 = 2048;
    id v29 = v11;
    _os_signpost_emit_with_name_impl( &dword_0,  v13,  OS_SIGNPOST_EVENT,  v10,  "Replayer-1-serial",  "%u. kDYMessageFetchResourceObjectBatch x%lu",  buf,  0x12u);
  }

  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  void v18[2] = __FetchResourceObjectBatch_block_invoke;
  v18[3] = &unk_58F358;
  id v21 = v9;
  id v22 = v11;
  uint64_t v23 = a1;
  os_signpost_id_t v24 = v10;
  int v25 = 0;
  id v19 = v7;
  id v20 = v8;
  id v14 = v8;
  id v15 = v9;
  id v16 = v7;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v18));
  [v17 setQueuePriority:-4];
  [*(id *)(a1 + 256) addOperation:v17];
}

void __FetchResourceObjectBatch_block_invoke(uint64_t a1)
{
  uint64_t v2 = -[NSMutableData initWithLength:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithLength:",  8LL * *(void *)(a1 + 56));
  __int128 v62 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(a1 + 56));
  id v59 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  *(void *)(a1 + 56));
  id v58 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  *(void *)(a1 + 56));
  id v53 = v2;
  unint64_t v56 = -[NSMutableData mutableBytes](v53, "mutableBytes");
  [*(id *)(*(void *)(a1 + 64) + 288) waitUntilDownloadCapacity];
  uint64_t v3 = *(void *)(*(void *)(a1 + 64) + 8LL);
  [*(id *)(v3 + 24) releaseBuffer];
  [*(id *)(v3 + 16) waitUntilCapacity];
  uint64_t v63 = a1;
  id v64 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  __int128 v87 = 0u;
  __int128 v88 = 0u;
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  obuint64_t j = *(id *)(a1 + 32);
  id v4 = [obj countByEnumeratingWithState:&v87 objects:v94 count:16];
  if (v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = *(void *)v88;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v88 != v6) {
          objc_enumerationMutation(obj);
        }
        id Attributes = GetAttributes(*(void *)(v63 + 64), *(void **)(*((void *)&v87 + 1) + 8LL * (void)i));
        id v9 = (void *)objc_claimAutoreleasedReturnValue(Attributes);
        os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"functionIndex"]);
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v10 unsignedIntValue]));
        id v12 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v64, "objectForKeyedSubscript:", v11));
        if (!v12)
        {
          id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v64, "setObject:forKeyedSubscript:", v12, v11);
        }

        id v13 = [v9 mutableCopy];
        id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  (char *)i + v5));
        [v13 setObject:v14 forKeyedSubscript:@"requestStreamIndex"];

        -[NSMutableArray addObject:](v12, "addObject:", v13);
        id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        -[NSMutableArray addObject:](v62, "addObject:", v15);
      }

      id v4 = [obj countByEnumeratingWithState:&v87 objects:v94 count:16];
      v5 += (uint64_t)i;
    }

    while (v4);
  }

  id v16 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allKeys](v64, "allKeys"));
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 sortedArrayUsingSelector:"compare:"]);

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*(void *)(*(void *)(v63 + 64) + 8LL) + 22480LL)));
  id v19 = objc_msgSend( v17,  "indexOfObject:inSortedRange:options:usingComparator:",  v18,  0,  objc_msgSend(v17, "count"),  1024,  &__block_literal_global_5787);

  id v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "subarrayWithRange:", 0, v19));
  id v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "subarrayWithRange:", v19, (_BYTE *)objc_msgSend(v17, "count") - v19));
  id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 arrayByAddingObjectsFromArray:v20]);

  v85[0] = &v93;
  v85[1] = 1024LL;
  uint64_t v86 = -[NSMutableData initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithCapacity:", 4096LL);
  id v55 = *(id *)(*(void *)(*(void *)(v63 + 64) + 8LL) + 24LL);
  __int128 v81 = 0u;
  __int128 v82 = 0u;
  __int128 v83 = 0u;
  __int128 v84 = 0u;
  id v54 = v22;
  id v23 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v54,  "countByEnumeratingWithState:objects:count:",  &v81,  v92,  16LL);
  if (v23)
  {
    uint64_t v24 = *(void *)v82;
    uint64_t v50 = *(void *)v82;
    do
    {
      uint64_t v25 = 0LL;
      id v51 = v23;
      do
      {
        if (*(void *)v82 != v24) {
          objc_enumerationMutation(v54);
        }
        uint64_t v52 = v25;
        id v57 = *(void **)(*((void *)&v81 + 1) + 8 * v25);
        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v64, "objectForKeyedSubscript:"));
        __int128 v79 = 0u;
        __int128 v80 = 0u;
        __int128 v77 = 0u;
        __int128 v78 = 0u;
        id obja = v26;
        id v27 = [obja countByEnumeratingWithState:&v77 objects:v91 count:16];
        if (v27)
        {
          uint64_t v28 = *(void *)v78;
          while (2)
          {
            for (uint64_t j = 0LL; j != v27; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v78 != v28) {
                objc_enumerationMutation(obja);
              }
              __int16 v30 = *(void **)(*((void *)&v77 + 1) + 8LL * (void)j);
              id v31 = objc_autoreleasePoolPush();
              -[NSMutableData setLength:](v86, "setLength:", 0LL);
              v76[0] = (unsigned int **)v85;
              id v32 = v59;
              v76[1] = v32;
              uint64_t v33 = v58;
              v76[2] = v33;
              uint64_t v34 = *(void *)(v63 + 64);
              __int128 v35 = *(id **)(v34 + 8);
              unint64_t v75 = 0LL;
              unsigned __int8 v36 = HarvestResourceObject(v35, (apr_pool_t *)(v34 + 96), v30, v76, &v75);
              uint64_t v37 = v75;
              if ((v36 & 1) == 0
                && [obja count] == (char *)&dword_0 + 1
                && (uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:@"object"]),
                    BOOL v39 = [v38 unsignedLongLongValue] == (id)-1026,
                    v38,
                    v39))
              {
                (*(void (**)(void))(*(void *)(v63 + 48) + 16LL))();
                int v40 = 0;
              }

              else
              {
                id v41 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:@"requestStreamIndex"]);
                id v42 = [v41 unsignedIntegerValue];

                id v43 = -[NSMutableData copy](v86, "copy");
                -[NSMutableArray setObject:atIndexedSubscript:](v62, "setObject:atIndexedSubscript:", v43, v42);

                v56[(void)v42] = [v57 unsignedLongLongValue];
                int v40 = 1;
              }

              objc_autoreleasePoolPop(v31);
              if (!v40)
              {

                __int128 v49 = v54;
                goto LABEL_32;
              }
            }

            id v27 = [obja countByEnumeratingWithState:&v77 objects:v91 count:16];
            if (v27) {
              continue;
            }
            break;
          }
        }

        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"FetchResourceObjectBatch"));
        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v55 commandBuffer]);
        [v45 setLabel:v44];

        [v55 commitCommandBuffer];
        uint64_t v25 = v52 + 1;
        uint64_t v24 = v50;
      }

      while ((id)(v52 + 1) != v51);
      id v23 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v54,  "countByEnumeratingWithState:objects:count:",  &v81,  v92,  16LL);
    }

    while (v23);
  }

  id v46 = (void *)objc_claimAutoreleasedReturnValue([v55 commandBuffer]);
  v65[0] = _NSConcreteStackBlock;
  v65[1] = 3221225472LL;
  void v65[2] = __FetchResourceObjectBatch_block_invoke_3;
  v65[3] = &unk_58F330;
  __int128 v72 = *(_OWORD *)(v63 + 64);
  int v74 = *(_DWORD *)(v63 + 80);
  uint64_t v73 = *(void *)(v63 + 56);
  unint64_t v66 = v59;
  __int128 v67 = v62;
  id v68 = v53;
  id v69 = v58;
  id v70 = *(id *)(v63 + 40);
  id v71 = *(id *)(v63 + 48);
  [v46 addCompletedHandler:v65];

  char v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"FetchResourceObjectBatchFinish"));
  id v48 = (void *)objc_claimAutoreleasedReturnValue([v55 commandBuffer]);
  [v48 setLabel:v47];

  [v55 commitCommandBuffer];
  __int128 v49 = v66;
LABEL_32:
}

void sub_161428( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62)
{
}

void __FetchResourceObjectBatch_block_invoke_3(uint64_t a1)
{
  id v1 = *(void **)(a1 + 72);
  uint64_t v2 = *(void **)(*(void *)(a1 + 80) + 264LL);
  int v3 = *(_DWORD *)(a1 + 104);
  id v4 = *(void **)(a1 + 40);
  uint64_t v5 = *(void **)(a1 + 48);
  uint64_t v6 = *(void **)(a1 + 56);
  id v7 = *(void **)(a1 + 64);
  __int128 v16 = *(_OWORD *)(a1 + 88);
  id v8 = *(id *)(a1 + 32);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = __FetchResourceObjectBatchReplyOperation_block_invoke;
  v17[3] = &unk_58F3A8;
  int v25 = v3;
  __int128 v24 = v16;
  id v18 = v8;
  id v19 = v4;
  id v20 = v5;
  id v21 = v6;
  id v22 = v7;
  id v23 = v1;
  id v9 = v8;
  id v10 = v19;
  id v11 = v20;
  id v12 = v21;
  id v13 = v22;
  id v14 = v23;
  id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v17));

  [v2 addOperation:v15];
}

void __FetchResourceObjectBatchReplyOperation_block_invoke(uint64_t a1)
{
  uint64_t v2 = g_signpostLog;
  int v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    int v5 = *(_DWORD *)(a1 + 96);
    uint64_t v6 = *(void *)(a1 + 88);
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)__int128 v82 = v5;
    *(_WORD *)&v82[4] = 2048;
    *(void *)&void v82[6] = v6;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-4-parallel",  "%u. kDYMessageFetchResourceObjectBatch x%lu",  buf,  0x12u);
  }

  id context = objc_autoreleasePoolPush();
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) allKeys]);
  id v8 = [v7 countByEnumeratingWithState:&v75 objects:v87 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v76;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v76 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v75 + 1) + 8LL * (void)i);
        id v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v12]);
        id v14 = PreprocessICBData(v13);
        id v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
        [*(id *)(a1 + 32) setObject:v15 forKeyedSubscript:v12];
      }

      id v9 = [v7 countByEnumeratingWithState:&v75 objects:v87 count:16];
    }

    while (v9);
  }

  __int128 v16 = g_signpostLog;
  uint64_t v17 = (os_log_s *)v16;
  os_signpost_id_t v18 = *(void *)(a1 + 80);
  if (v18 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v16))
  {
    int v19 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)__int128 v82 = v19;
    _os_signpost_emit_with_name_impl( &dword_0,  v17,  OS_SIGNPOST_INTERVAL_BEGIN,  v18,  "Replayer-6-high",  "%u. archivedDataWithRootObject",  buf,  8u);
  }

  v85[0] = @"stream";
  v85[1] = @"object";
  uint64_t v20 = *(void *)(a1 + 32);
  v86[0] = *(void *)(a1 + 40);
  v86[1] = v20;
  void v85[2] = @"functionIndex";
  v85[3] = @"requestID";
  uint64_t v21 = *(void *)(a1 + 56);
  void v86[2] = *(void *)(a1 + 48);
  v86[3] = v21;
  id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v86,  v85,  4LL));
  id v74 = 0LL;
  id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v22,  1LL,  &v74));
  id v70 = v74;

  __int128 v24 = g_signpostLog;
  int v25 = (os_log_s *)v24;
  os_signpost_id_t v26 = *(void *)(a1 + 80);
  if (v26 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v24))
  {
    id v27 = [v23 length];
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)__int128 v82 = v27;
    _os_signpost_emit_with_name_impl( &dword_0,  v25,  OS_SIGNPOST_INTERVAL_END,  v26,  "Replayer-6-high",  "%{xcode:size-in-bytes}lu",  buf,  0xCu);
  }

  uint64_t v28 = (__CFString *)*(id *)(a1 + 64);
  id v29 = (void *)objc_claimAutoreleasedReturnValue([&off_5A0290 objectForKeyedSubscript:v28]);
  __int128 v72 = v23;
  if (v29)
  {
    __int16 v30 = -[NSMutableData initWithLength:]( [NSMutableData alloc],  "initWithLength:",  [v23 length]);
    id v31 = g_signpostLog;
    id v32 = (os_log_s *)v31;
    os_signpost_id_t v33 = *(void *)(a1 + 80);
    if (v33 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v31))
    {
      int v34 = *(_DWORD *)(a1 + 96);
      id v35 = -[__CFString UTF8String](v28, "UTF8String");
      id v36 = [v72 length];
      *(_DWORD *)__int128 buf = 67109634;
      *(_DWORD *)__int128 v82 = v34;
      *(_WORD *)&v82[4] = 2082;
      *(void *)&void v82[6] = v35;
      id v23 = v72;
      __int16 v83 = 2048;
      id v84 = v36;
      _os_signpost_emit_with_name_impl( &dword_0,  v32,  OS_SIGNPOST_INTERVAL_BEGIN,  v33,  "Replayer-6-high",  "%u. %{public}s %{xcode:size-in-bytes}lu",  buf,  0x1Cu);
    }

    uint64_t v37 = v30;
    uint64_t v38 = -[NSMutableData mutableBytes](v37, "mutableBytes");
    NSUInteger v39 = -[NSMutableData length](v37, "length");
    id v40 = v23;
    size_t v41 = compression_encode_buffer( v38,  v39,  (const uint8_t *)[v40 bytes],  (size_t)objc_msgSend(v40, "length"),  0,  (compression_algorithm)objc_msgSend(v29, "unsignedIntValue"));
    id v42 = g_signpostLog;
    id v43 = (os_log_s *)v42;
    os_signpost_id_t v44 = *(void *)(a1 + 80);
    if (v44 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v42))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)__int128 v82 = v41;
      _os_signpost_emit_with_name_impl( &dword_0,  v43,  OS_SIGNPOST_INTERVAL_END,  v44,  "Replayer-6-high",  "%{xcode:size-in-bytes}zu",  buf,  0xCu);
    }

    -[NSMutableData setLength:](v37, "setLength:", v41);
    id v23 = v72;
  }

  else
  {
    uint64_t v37 = 0LL;
  }

  if (!-[NSMutableData length](v37, "length"))
  {

    uint64_t v45 = v23;
    uint64_t v28 = @"none";
    uint64_t v37 = v45;
  }

  id v46 = g_signpostLog;
  char v47 = (os_log_s *)v46;
  os_signpost_id_t v48 = *(void *)(a1 + 80);
  if (v48 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v46))
  {
    int v49 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)__int128 v82 = v49;
    _os_signpost_emit_with_name_impl( &dword_0,  v47,  OS_SIGNPOST_INTERVAL_BEGIN,  v48,  "Replayer-6-high",  "%u. archivedDataWithRootObject",  buf,  8u);
  }

  v80[0] = v28;
  v79[0] = @"compressed";
  v79[1] = @"stream";
  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v23 length]));
  void v79[2] = @"object";
  v80[1] = v50;
  id v80[2] = v37;
  id v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v80,  v79,  3LL));
  id v73 = v70;
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v51,  1LL,  &v73));
  id v53 = v73;

  id v54 = g_signpostLog;
  id v55 = (os_log_s *)v54;
  os_signpost_id_t v56 = *(void *)(a1 + 80);
  if (v56 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v54))
  {
    id v57 = [v72 length];
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)__int128 v82 = v57;
    _os_signpost_emit_with_name_impl( &dword_0,  v55,  OS_SIGNPOST_INTERVAL_END,  v56,  "Replayer-6-high",  "%{xcode:size-in-bytes}lu",  buf,  0xCu);
  }

  id v58 = g_signpostLog;
  id v59 = (os_log_s *)v58;
  os_signpost_id_t v60 = *(void *)(a1 + 80);
  if (v60 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v58))
  {
    id v61 = [v52 length];
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)__int128 v82 = v61;
    _os_signpost_emit_with_name_impl( &dword_0,  v59,  OS_SIGNPOST_INTERVAL_END,  v60,  "Replayer-4-parallel",  "%{xcode:size-in-bytes}lu",  buf,  0xCu);
  }

  objc_autoreleasePoolPop(context);
  __int128 v62 = g_signpostLog;
  uint64_t v63 = (os_log_s *)v62;
  os_signpost_id_t v64 = *(void *)(a1 + 80);
  if (v64 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v62))
  {
    int v65 = *(_DWORD *)(a1 + 96);
    id v66 = [v52 length];
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)__int128 v82 = v65;
    *(_WORD *)&v82[4] = 2048;
    *(void *)&void v82[6] = v66;
    _os_signpost_emit_with_name_impl( &dword_0,  v63,  OS_SIGNPOST_INTERVAL_BEGIN,  v64,  "Replayer-5-network",  "%u. send compressedData %{xcode:size-in-bytes}lu",  buf,  0x12u);
  }

  (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
  __int128 v67 = g_signpostLog;
  id v68 = (os_log_s *)v67;
  os_signpost_id_t v69 = *(void *)(a1 + 80);
  if (v69 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v67))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v68,  OS_SIGNPOST_INTERVAL_END,  v69,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
  }
}

void std::vector<BOOL>::resize(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v9 = v8 << 6;
    if (v8 << 6 < v6 || v5 > (v8 << 6) - v6)
    {
      __dst = 0LL;
      __int128 v20 = 0uLL;
      if ((a2 & 0x8000000000000000LL) != 0) {
        abort();
      }
      unint64_t v11 = v8 << 7;
      if (v11 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0LL)) {
        unint64_t v11 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0LL;
      }
      if (v9 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve((uint64_t)&__dst, v12);
      id v13 = *(void **)a1;
      uint64_t v14 = *(void *)(a1 + 8);
      *(void *)&__int128 v20 = v14 + v6;
      id v15 = (char *)__dst;
      if (v14 < 1)
      {
        LODWORD(v1_Block_object_dispose(va, 8) = 0;
        uint64_t v17 = (char *)__dst;
      }

      else
      {
        uint64_t v16 = v14 >> 6;
        uint64_t v18 = v14 - (v16 << 6);
        uint64_t v17 = &v15[8 * v16];
        if (v18 < 1) {
          LODWORD(v1_Block_object_dispose(va, 8) = 0;
        }
        else {
          *(void *)uint64_t v17 = *(void *)v17 & ~(0xFFFFFFFFFFFFFFFFLL >> -(char)v18) | *((void *)v13 + v16) & (0xFFFFFFFFFFFFFFFFLL >> -(char)v18);
        }
        id v13 = *(void **)a1;
      }

      *(void *)a1 = v15;
      *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = v20;
      if (v13) {
        operator delete(v13);
      }
    }

    else
    {
      uint64_t v17 = (char *)(*(void *)a1 + 8 * (v5 >> 6));
      uint64_t v18 = *(void *)(a1 + 8) & 0x3FLL;
      *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    }

    if (a2 != v5)
    {
      if (a3)
      {
        __dst = v17;
        LODWORD(v20) = v18;
        std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(&__dst, v6);
      }

      else
      {
        __dst = v17;
        LODWORD(v20) = v18;
        std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&__dst, v6);
      }
    }
  }

void sub_162028( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2 <= *(void *)(a1 + 16) << 6) {
    return;
  }
  if ((a2 & 0x8000000000000000LL) != 0) {
    abort();
  }
  uint64_t v19 = 0LL;
  __int128 v20 = 0uLL;
  std::vector<BOOL>::__vallocate[abi:nn180100](&v19, a2);
  int v3 = *(void **)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = v20;
  unint64_t v6 = v20 + v4;
  *(void *)&__int128 v20 = v20 + v4;
  if (!v5)
  {
    unint64_t v7 = v6 - 1;
    goto LABEL_7;
  }

  unint64_t v7 = v6 - 1;
  if (((v6 - 1) ^ (v5 - 1)) > 0x3F)
  {
LABEL_7:
    uint64_t v8 = v19;
    unint64_t v9 = v7 >> 6;
    if (v6 >= 0x41) {
      unint64_t v10 = v9;
    }
    else {
      unint64_t v10 = 0LL;
    }
    *(void *)(v19 + 8 * v10) = 0LL;
    goto LABEL_11;
  }

  uint64_t v8 = v19;
LABEL_11:
  int v11 = v4 & 0x3F;
  if (v4 > 0x3F || (v4 & 0x3F) != 0)
  {
    int v12 = 0;
    id v13 = &v3[v4 >> 6];
    int v14 = v5 & 0x3F;
    id v15 = (uint64_t *)(v8 + 8 * (v5 >> 6));
    do
    {
      uint64_t v16 = 1LL << v14;
      if (((*v3 >> v12) & 1) != 0) {
        uint64_t v17 = *v15 | v16;
      }
      else {
        uint64_t v17 = *v15 & ~v16;
      }
      *id v15 = v17;
      v3 += v12 == 63;
      if (v12 == 63) {
        int v12 = 0;
      }
      else {
        ++v12;
      }
      v15 += v14 == 63;
      if (v14 == 63) {
        int v14 = 0;
      }
      else {
        ++v14;
      }
    }

    while (v3 != v13 || v12 != v11);
  }

  uint64_t v18 = *(void **)a1;
  *(void *)a1 = v8;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = v20;
  if (v18) {
    operator delete(v18);
  }
}

void sub_16216C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *,false>( unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7 = result;
LABEL_2:
  uint64_t v8 = (int *)(a2 - 24);
  unint64_t i = v7;
  while (2)
  {
    uint64_t v7 = i;
    uint64_t v10 = a2 - i;
    uint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - i) >> 3);
    switch(v11)
    {
      case 0LL:
      case 1LL:
        return result;
      case 2LL:
        int v61 = *v8;
        int v62 = *(_DWORD *)i;
        if (*v8 >= *(_DWORD *)i)
        {
          if (v62 < v61) {
            return result;
          }
          unint64_t v64 = *(void *)(a2 - 16);
          unint64_t v63 = *(void *)(i + 8);
          if (v64 >= v63 && (v63 < v64 || *(void *)(a2 - 8) >= *(void *)(i + 16))) {
            return result;
          }
        }

        else
        {
          unint64_t v63 = *(void *)(i + 8);
          unint64_t v64 = *(void *)(a2 - 16);
        }

        *(_DWORD *)unint64_t i = v61;
        *(_DWORD *)(a2 - 24) = v62;
        uint64_t v103 = *(void *)(i + 16);
        uint64_t v104 = *(void *)(a2 - 8);
        *(void *)(i + _Block_object_dispose(va, 8) = v64;
        *(void *)(i + 16) = v104;
        *(void *)(a2 - 16) = v63;
        *(void *)(a2 - _Block_object_dispose(va, 8) = v103;
        return result;
      case 3LL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)i,  (int *)(i + 24),  (int *)(a2 - 24));
      case 4LL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( i,  i + 24,  i + 48,  a2 - 24);
      case 5LL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( i,  i + 24,  i + 48,  i + 72,  (int *)(a2 - 24));
      default:
        if (v10 > 575)
        {
          if (!a3)
          {
            if (i == a2) {
              return result;
            }
            int64_t v83 = (unint64_t)(v11 - 2) >> 1;
            int64_t v84 = v83;
            while (1)
            {
              int64_t v85 = v84;
              if (v83 >= v84)
              {
                uint64_t v86 = (2 * v84) | 1;
                unint64_t v87 = i + 24 * v86;
                if (2 * v85 + 2 < v11)
                {
                  int v88 = *(_DWORD *)(v87 + 24);
                  if (*(_DWORD *)v87 < v88
                    || v88 >= *(_DWORD *)v87
                    && ((unint64_t v101 = *(void *)(v87 + 8), v102 = *(void *)(v87 + 32), v101 < v102)
                     || v102 >= v101 && *(void *)(v87 + 16) < *(void *)(v87 + 40)))
                  {
                    v87 += 24LL;
                    uint64_t v86 = 2 * v85 + 2;
                  }
                }

                unint64_t v89 = i + 24 * v85;
                int v90 = *(_DWORD *)v87;
                int v91 = *(_DWORD *)v89;
                if (*(_DWORD *)v87 >= *(_DWORD *)v89)
                {
                  if (v91 < v90)
                  {
                    unint64_t v92 = *(void *)(v89 + 8);
                    unint64_t v93 = *(void *)(v87 + 8);
LABEL_156:
                    unint64_t v94 = *(void *)(v89 + 16);
                    do
                    {
                      *(_DWORD *)unint64_t v89 = v90;
                      uint64_t v95 = *(void *)(v87 + 16);
                      *(void *)(v89 + _Block_object_dispose(va, 8) = v93;
                      *(void *)(v89 + 16) = v95;
                      if (v83 < v86) {
                        goto LABEL_171;
                      }
                      unint64_t v89 = v87;
                      uint64_t v96 = 2 * v86;
                      uint64_t v86 = (2 * v86) | 1;
                      unint64_t v87 = i + 24 * v86;
                      uint64_t v97 = v96 + 2;
                      if (v97 < v11)
                      {
                        int v98 = *(_DWORD *)(v87 + 24);
                        if (*(_DWORD *)v87 < v98
                          || v98 >= *(_DWORD *)v87
                          && ((unint64_t v99 = *(void *)(v87 + 8), v100 = *(void *)(v87 + 32), v99 < v100)
                           || v100 >= v99 && *(void *)(v87 + 16) < *(void *)(v87 + 40)))
                        {
                          v87 += 24LL;
                          uint64_t v86 = v97;
                        }
                      }

                      int v90 = *(_DWORD *)v87;
                      if (*(_DWORD *)v87 < v91) {
                        break;
                      }
                      unint64_t v93 = *(void *)(v87 + 8);
                    }

                    while (v91 < v90 || v93 >= v92 && (v92 < v93 || *(void *)(v87 + 16) >= v94));
                    unint64_t v87 = v89;
LABEL_171:
                    *(_DWORD *)unint64_t v87 = v91;
                    *(void *)(v87 + _Block_object_dispose(va, 8) = v92;
                    *(void *)(v87 + 16) = v94;
                    goto LABEL_173;
                  }

                  unint64_t v93 = *(void *)(v87 + 8);
                  unint64_t v92 = *(void *)(v89 + 8);
                  if (v93 >= v92 && (v92 < v93 || *(void *)(v87 + 16) >= *(void *)(v89 + 16))) {
                    goto LABEL_156;
                  }
                }
              }

LABEL_203:
            uint64_t v65 = v7 + 24;
            if (v7 + 24 == a2) {
              return result;
            }
          }

          unint64_t v109 = *(void *)(v106 + 32);
LABEL_195:
          unint64_t v111 = *(void *)(v106 + 40);
          for (iunint64_t i = n; ; iunint64_t i = (_OWORD *)((char *)ii - 24))
          {
            *((_DWORD *)ii - 2) = v108;
            *iunint64_t i = *(_OWORD *)((char *)ii - 24);
            int v108 = *((_DWORD *)ii - 14);
            if (v107 >= v108)
            {
              if (v108 < v107) {
                break;
              }
              unint64_t v113 = *((void *)ii - 6);
              if (v109 >= v113 && (v113 < v109 || v111 >= *((void *)ii - 5))) {
                break;
              }
            }
          }

          id v114 = ii - 2;
          *((_DWORD *)ii - _Block_object_dispose(va, 8) = v107;
          *((void *)v114 + 1) = v109;
          *((void *)v114 + 2) = v111;
          goto LABEL_203;
        }

        if (v67) {
          return result;
        }
        uint64_t v68 = 0LL;
        unint64_t v69 = i;
        do
        {
          unint64_t v70 = v69;
          unint64_t v69 = v65;
          int v71 = *(_DWORD *)(v70 + 24);
          int v72 = *(_DWORD *)v70;
          if (v71 >= *(_DWORD *)v70)
          {
            if (v72 < v71) {
              goto LABEL_144;
            }
            unint64_t v73 = *(void *)(v70 + 32);
            unint64_t v74 = *(void *)(v70 + 8);
            if (v73 >= v74 && (v74 < v73 || *(void *)(v70 + 40) >= *(void *)(v70 + 16))) {
              goto LABEL_144;
            }
          }

          else
          {
            unint64_t v73 = *(void *)(v70 + 32);
            unint64_t v74 = *(void *)(v70 + 8);
          }

          unint64_t v75 = *(void *)(v70 + 40);
          *(_DWORD *)(v70 + 24) = v72;
          uint64_t v76 = *(void *)(v70 + 16);
          *(void *)(v69 + _Block_object_dispose(va, 8) = v74;
          *(void *)(v69 + 16) = v76;
          unint64_t v77 = i;
          if (v70 == i) {
            goto LABEL_143;
          }
          uint64_t v78 = v68;
          while (1)
          {
            int v79 = *(_DWORD *)(i + v78 - 24);
            if (v71 < v79)
            {
              unint64_t v80 = *(void *)(i + v78 - 16);
              goto LABEL_140;
            }

            if (v79 < v71) {
              goto LABEL_142;
            }
            unint64_t v80 = *(void *)(i + v78 - 16);
            if (v73 >= v80) {
              break;
            }
LABEL_140:
            v70 -= 24LL;
            uint64_t v81 = i + v78;
            *(_DWORD *)uint64_t v81 = v79;
            uint64_t v82 = *(void *)(i + v78 - 8);
            *(void *)(v81 + _Block_object_dispose(va, 8) = v80;
            *(void *)(v81 + 16) = v82;
            v78 -= 24LL;
            if (!v78)
            {
              unint64_t v77 = i;
              goto LABEL_143;
            }
          }

          if (v80 >= v73)
          {
            unint64_t v77 = i + v78;
            uint64_t result = *(void *)(i + v78 - 8);
            if (v75 >= result) {
              goto LABEL_143;
            }
            goto LABEL_140;
          }

LABEL_142:
          unint64_t v77 = v70;
LABEL_143:
          *(_DWORD *)unint64_t v77 = v71;
          *(void *)(v77 + _Block_object_dispose(va, 8) = v73;
          *(void *)(v77 + 16) = v75;
LABEL_144:
          uint64_t v65 = v69 + 24;
          v68 += 24LL;
        }

        while (v69 + 24 != a2);
        return result;
    }
  }

int *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( int *result, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *result;
  if (*a2 < *result
    || v4 >= v3
    && ((unint64_t v13 = *((void *)a2 + 1), v14 = *((void *)result + 1), v13 < v14)
     || v14 >= v13 && *((void *)a2 + 2) < *((void *)result + 2)))
  {
    int v5 = *a3;
    if (*a3 < v3)
    {
      unint64_t v6 = *((void *)a3 + 1);
LABEL_4:
      *uint64_t result = v5;
      *a3 = v4;
      uint64_t v7 = *((void *)a3 + 2);
      __int128 v8 = *(_OWORD *)(result + 2);
      *((void *)result + 1) = v6;
      *((void *)result + 2) = v7;
      *(_OWORD *)(a3 + 2) = v8;
      return result;
    }

    if (v3 >= v5)
    {
      unint64_t v6 = *((void *)a3 + 1);
      unint64_t v12 = *((void *)a2 + 1);
      if (v6 < v12 || v12 >= v6 && *((void *)a3 + 2) < *((void *)a2 + 2)) {
        goto LABEL_4;
      }
    }

    else
    {
      unint64_t v12 = *((void *)a2 + 1);
    }

    *uint64_t result = v3;
    *a2 = v4;
    unint64_t v21 = *((void *)result + 1);
    unint64_t v22 = *((void *)result + 2);
    uint64_t v23 = *((void *)a2 + 2);
    *((void *)result + 1) = v12;
    *((void *)result + 2) = v23;
    *((void *)a2 + 1) = v21;
    *((void *)a2 + 2) = v22;
    int v24 = *a3;
    if (*a3 >= v4)
    {
      if (v4 < v24) {
        return result;
      }
      unint64_t v25 = *((void *)a3 + 1);
      if (v25 >= v21 && (v21 < v25 || *((void *)a3 + 2) >= v22)) {
        return result;
      }
    }

    else
    {
      unint64_t v25 = *((void *)a3 + 1);
    }

    *a2 = v24;
    *a3 = v4;
    uint64_t v28 = *((void *)a3 + 2);
    *((void *)a2 + 1) = v25;
    *((void *)a2 + 2) = v28;
    *((void *)a3 + 1) = v21;
    *((void *)a3 + 2) = v22;
    return result;
  }

  int v9 = *a3;
  if (*a3 >= v3)
  {
    if (v3 < v9) {
      return result;
    }
    unint64_t v11 = *((void *)a3 + 1);
    unint64_t v10 = *((void *)a2 + 1);
    if (v11 >= v10 && (v10 < v11 || *((void *)a3 + 2) >= *((void *)a2 + 2))) {
      return result;
    }
  }

  else
  {
    unint64_t v10 = *((void *)a2 + 1);
    unint64_t v11 = *((void *)a3 + 1);
  }

  *a2 = v9;
  *a3 = v3;
  uint64_t v15 = *((void *)a2 + 2);
  uint64_t v16 = *((void *)a3 + 2);
  *((void *)a2 + 1) = v11;
  *((void *)a2 + 2) = v16;
  *((void *)a3 + 1) = v10;
  *((void *)a3 + 2) = v15;
  int v17 = *a2;
  int v18 = *result;
  if (*a2 < *result)
  {
    unint64_t v19 = *((void *)result + 1);
    unint64_t v20 = *((void *)a2 + 1);
LABEL_29:
    *uint64_t result = v17;
    *a2 = v18;
    uint64_t v26 = *((void *)result + 2);
    uint64_t v27 = *((void *)a2 + 2);
    *((void *)result + 1) = v20;
    *((void *)result + 2) = v27;
    *((void *)a2 + 1) = v19;
    *((void *)a2 + 2) = v26;
    return result;
  }

  if (v18 >= v17)
  {
    unint64_t v20 = *((void *)a2 + 1);
    unint64_t v19 = *((void *)result + 1);
    if (v20 < v19 || v19 >= v20 && *((void *)a2 + 2) < *((void *)result + 2)) {
      goto LABEL_29;
    }
  }

  return result;
}

int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)a1,  (int *)a2,  (int *)a3);
  int v9 = *(_DWORD *)a4;
  int v10 = *(_DWORD *)a3;
  if (*(_DWORD *)a4 >= *(_DWORD *)a3)
  {
    if (v10 < v9) {
      return result;
    }
    unint64_t v12 = *(void *)(a4 + 8);
    unint64_t v11 = *(void *)(a3 + 8);
    if (v12 >= v11 && (v11 < v12 || *(void *)(a4 + 16) >= *(void *)(a3 + 16))) {
      return result;
    }
  }

  else
  {
    unint64_t v11 = *(void *)(a3 + 8);
    unint64_t v12 = *(void *)(a4 + 8);
  }

  *(_DWORD *)a3 = v9;
  *(_DWORD *)a4 = v10;
  uint64_t v13 = *(void *)(a3 + 16);
  uint64_t v14 = *(void *)(a4 + 16);
  *(void *)(a3 + _Block_object_dispose(va, 8) = v12;
  *(void *)(a3 + 16) = v14;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v11;
  *(void *)(a4 + 16) = v13;
  int v15 = *(_DWORD *)a3;
  int v16 = *(_DWORD *)a2;
  if (*(_DWORD *)a3 >= *(_DWORD *)a2)
  {
    if (v16 < v15) {
      return result;
    }
    unint64_t v18 = *(void *)(a3 + 8);
    unint64_t v17 = *(void *)(a2 + 8);
    if (v18 >= v17 && (v17 < v18 || *(void *)(a3 + 16) >= *(void *)(a2 + 16))) {
      return result;
    }
  }

  else
  {
    unint64_t v17 = *(void *)(a2 + 8);
    unint64_t v18 = *(void *)(a3 + 8);
  }

  *(_DWORD *)a2 = v15;
  *(_DWORD *)a3 = v16;
  uint64_t v19 = *(void *)(a2 + 16);
  uint64_t v20 = *(void *)(a3 + 16);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v18;
  *(void *)(a2 + 16) = v20;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v17;
  *(void *)(a3 + 16) = v19;
  int v21 = *(_DWORD *)a2;
  int v22 = *(_DWORD *)a1;
  if (*(_DWORD *)a2 < *(_DWORD *)a1)
  {
    unint64_t v23 = *(void *)(a1 + 8);
    unint64_t v24 = *(void *)(a2 + 8);
LABEL_19:
    *(_DWORD *)a1 = v21;
    *(_DWORD *)a2 = v22;
    uint64_t v25 = *(void *)(a1 + 16);
    uint64_t v26 = *(void *)(a2 + 16);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v24;
    *(void *)(a1 + 16) = v26;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v23;
    *(void *)(a2 + 16) = v25;
    return result;
  }

  if (v22 >= v21)
  {
    unint64_t v24 = *(void *)(a2 + 8);
    unint64_t v23 = *(void *)(a1 + 8);
    if (v24 < v23 || v23 >= v24 && *(void *)(a2 + 16) < *(void *)(a1 + 16)) {
      goto LABEL_19;
    }
  }

  return result;
}

int *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( a1,  a2,  a3,  a4);
  int v11 = *a5;
  int v12 = *(_DWORD *)a4;
  if (*a5 >= *(_DWORD *)a4)
  {
    if (v12 < v11) {
      return result;
    }
    unint64_t v14 = *((void *)a5 + 1);
    unint64_t v13 = *(void *)(a4 + 8);
    if (v14 >= v13 && (v13 < v14 || *((void *)a5 + 2) >= *(void *)(a4 + 16))) {
      return result;
    }
  }

  else
  {
    unint64_t v13 = *(void *)(a4 + 8);
    unint64_t v14 = *((void *)a5 + 1);
  }

  *(_DWORD *)a4 = v11;
  *a5 = v12;
  uint64_t v15 = *(void *)(a4 + 16);
  uint64_t v16 = *((void *)a5 + 2);
  *(void *)(a4 + _Block_object_dispose(va, 8) = v14;
  *(void *)(a4 + 16) = v16;
  *((void *)a5 + 1) = v13;
  *((void *)a5 + 2) = v15;
  int v17 = *(_DWORD *)a4;
  int v18 = *(_DWORD *)a3;
  if (*(_DWORD *)a4 >= *(_DWORD *)a3)
  {
    if (v18 < v17) {
      return result;
    }
    unint64_t v20 = *(void *)(a4 + 8);
    unint64_t v19 = *(void *)(a3 + 8);
    if (v20 >= v19 && (v19 < v20 || *(void *)(a4 + 16) >= *(void *)(a3 + 16))) {
      return result;
    }
  }

  else
  {
    unint64_t v19 = *(void *)(a3 + 8);
    unint64_t v20 = *(void *)(a4 + 8);
  }

  *(_DWORD *)a3 = v17;
  *(_DWORD *)a4 = v18;
  uint64_t v21 = *(void *)(a3 + 16);
  uint64_t v22 = *(void *)(a4 + 16);
  *(void *)(a3 + _Block_object_dispose(va, 8) = v20;
  *(void *)(a3 + 16) = v22;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v19;
  *(void *)(a4 + 16) = v21;
  int v23 = *(_DWORD *)a3;
  int v24 = *(_DWORD *)a2;
  if (*(_DWORD *)a3 >= *(_DWORD *)a2)
  {
    if (v24 < v23) {
      return result;
    }
    unint64_t v26 = *(void *)(a3 + 8);
    unint64_t v25 = *(void *)(a2 + 8);
    if (v26 >= v25 && (v25 < v26 || *(void *)(a3 + 16) >= *(void *)(a2 + 16))) {
      return result;
    }
  }

  else
  {
    unint64_t v25 = *(void *)(a2 + 8);
    unint64_t v26 = *(void *)(a3 + 8);
  }

  *(_DWORD *)a2 = v23;
  *(_DWORD *)a3 = v24;
  uint64_t v27 = *(void *)(a2 + 16);
  uint64_t v28 = *(void *)(a3 + 16);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v26;
  *(void *)(a2 + 16) = v28;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v25;
  *(void *)(a3 + 16) = v27;
  int v29 = *(_DWORD *)a2;
  int v30 = *(_DWORD *)a1;
  if (*(_DWORD *)a2 < *(_DWORD *)a1)
  {
    unint64_t v31 = *(void *)(a1 + 8);
    unint64_t v32 = *(void *)(a2 + 8);
LABEL_26:
    *(_DWORD *)a1 = v29;
    *(_DWORD *)a2 = v30;
    uint64_t v33 = *(void *)(a1 + 16);
    uint64_t v34 = *(void *)(a2 + 16);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v32;
    *(void *)(a1 + 16) = v34;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v31;
    *(void *)(a2 + 16) = v33;
    return result;
  }

  if (v30 >= v29)
  {
    unint64_t v32 = *(void *)(a2 + 8);
    unint64_t v31 = *(void *)(a1 + 8);
    if (v32 < v31 || v31 >= v32 && *(void *)(a2 + 16) < *(void *)(a1 + 16)) {
      goto LABEL_26;
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      int v6 = *(_DWORD *)(a2 - 24);
      int v7 = *(_DWORD *)a1;
      if (v6 < *(_DWORD *)a1)
      {
        unint64_t v8 = *(void *)(a1 + 8);
        unint64_t v9 = *(void *)(a2 - 16);
LABEL_4:
        *(_DWORD *)a1 = v6;
        *(_DWORD *)(a2 - 24) = v7;
        uint64_t v10 = *(void *)(a1 + 16);
        uint64_t v11 = *(void *)(a2 - 8);
        *(void *)(a1 + _Block_object_dispose(va, 8) = v9;
        *(void *)(a1 + 16) = v11;
        *(void *)(a2 - 16) = v8;
        *(void *)(a2 - _Block_object_dispose(va, 8) = v10;
        return result;
      }

      if (v7 >= v6)
      {
        unint64_t v9 = *(void *)(a2 - 16);
        unint64_t v8 = *(void *)(a1 + 8);
        if (v9 < v8 || v8 >= v9 && *(void *)(a2 - 8) < *(void *)(a1 + 16)) {
          goto LABEL_4;
        }
      }

      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)a1,  (int *)(a1 + 24),  (int *)(a2 - 24));
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( a1,  a1 + 24,  a1 + 48,  a2 - 24);
      return 1LL;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( a1,  a1 + 24,  a1 + 48,  a1 + 72,  (int *)(a2 - 24));
      return 1LL;
    default:
      uint64_t v12 = a1 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( (int *)a1,  (int *)(a1 + 24),  (int *)(a1 + 48));
      uint64_t v13 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1LL;
      }
      uint64_t v14 = 0LL;
      int v15 = 0;
      break;
  }

id DEVICEOBJECT(id a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  while ((objc_opt_respondsToSelector(a1, "baseObject") & 1) != 0)
    a1 = [a1 performSelector:"baseObject"];
  objc_autoreleasePoolPop(v2);
  return a1;
}

void GTMTLReplaySupport_init(void *a1)
{
  id v1 = DEVICEOBJECT(a1);
  id v56 = (id)objc_claimAutoreleasedReturnValue(v1);
  GT_SUPPORT_0 = 0LL;
  GT_SUPPORT_0 = NSClassFromString(@"MTLTileRenderPipelineDescriptor") != 0LL;
  char v2 = objc_opt_respondsToSelector(v56, "supportsVertexAmplification");
  uint64_t v3 = 2LL;
  if ((v2 & 1) == 0) {
    uint64_t v3 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFFDLL | v3;
  unint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  char v5 = objc_opt_respondsToSelector(v4, "setAdditionalCompilerArguments:");
  uint64_t v6 = 4LL;
  if ((v5 & 1) == 0) {
    uint64_t v6 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFFBLL | v6;

  Class v7 = NSClassFromString(@"MTLIndirectCommandBufferDescriptor");
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFF7LL | (8LL * (v7 != 0LL));
  if (v7)
  {
    unint64_t v8 = objc_alloc_init(&OBJC_CLASS___MTLIndirectCommandBufferDescriptor);
    char v9 = objc_opt_respondsToSelector(v8, "maxKernelBufferBindCount");
    uint64_t v10 = 16LL;
    if ((v9 & 1) == 0) {
      uint64_t v10 = 0LL;
    }
    GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFEFLL | v10;
  }

  uint64_t v11 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  if ([v56 supportsTessellation])
  {
    char v12 = objc_opt_respondsToSelector(v11, "tessellationControlPointIndexType");
    uint64_t v13 = 32LL;
    if ((v12 & 1) == 0) {
      uint64_t v13 = 0LL;
    }
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFDFLL | v13;

  uint64_t v14 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
  char v15 = objc_opt_respondsToSelector(v14, "defaultColorSampleCount");
  uint64_t v16 = 64LL;
  if ((v15 & 1) == 0) {
    uint64_t v16 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFFBFLL | v16;
  unsigned int v17 = [v56 supportsLayeredRendering];
  uint64_t v18 = 128LL;
  if (!v17) {
    uint64_t v18 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFF7FLL | v18;

  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFEFFLL | ((unint64_t)(NSClassFromString(@"MTLRasterizationRateMapDescriptor") != 0LL) << 8);
  unsigned int v19 = [v56 supportsImageBlocks];
  uint64_t v20 = 512LL;
  if (!v19) {
    uint64_t v20 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFDFFLL | v20;
  char v21 = objc_opt_respondsToSelector(v56, "maxRasterizationRateLayerCount");
  uint64_t v22 = 1024LL;
  if ((v21 & 1) == 0) {
    uint64_t v22 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFFBFFLL | v22;
  char v23 = objc_opt_respondsToSelector(v56, "sparseTileSizeWithTextureType:pixelFormat:sampleCount:");
  uint64_t v24 = 2048LL;
  if ((v23 & 1) == 0) {
    uint64_t v24 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFF7FFLL | v24;
  __int16 v25 = dword_5B9DE4;
  unint64_t v26 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  uint64_t v27 = v26;
  uint64_t v28 = 0LL;
  if ((v25 & 0x4000) == 0)
  {
    char v29 = objc_opt_respondsToSelector(v26, "setDriverCompilerOptions:");
    uint64_t v28 = 0x8000LL;
    if ((v29 & 1) == 0) {
      uint64_t v28 = 0LL;
    }
  }

  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFF7FFFLL | v28;

  int v30 = objc_alloc_init(&OBJC_CLASS___MTLComputePipelineDescriptor);
  char v31 = objc_opt_respondsToSelector(v30, "setMaxTotalThreadsPerThreadgroup:");
  uint64_t v32 = 0x4000LL;
  if ((v31 & 1) == 0) {
    uint64_t v32 = 0LL;
  }
  unint64_t v33 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFBFFFLL | v32;
  GT_SUPPORT_0 = v33;
  if ((v25 & 0x4000) != 0)
  {
    uint64_t v34 = 0LL;
  }

  else
  {
    if ((objc_opt_respondsToSelector(v30, "setDriverCompilerOptions:") & 1) != 0) {
      uint64_t v34 = 0x10000LL;
    }
    else {
      uint64_t v34 = 0LL;
    }
    unint64_t v33 = GT_SUPPORT_0;
  }

  GT_SUPPORT_0 = v33 & 0xFFFFFFFFFFFEFFFFLL | v34;

  BOOL v35 = [v56 argumentBuffersSupport] != 0;
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFFDFFFLL | ((unint64_t)v35 << 13);
  int v36 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  char v37 = objc_opt_respondsToSelector(v36, "openGLModeEnabled");
  uint64_t v38 = 0x20000LL;
  if ((v37 & 1) == 0) {
    uint64_t v38 = 0LL;
  }
  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFDFFFFLL | v38;

  char v39 = objc_opt_respondsToSelector(v56, "supportsGlobalVariableRelocation");
  uint64_t v40 = 0LL;
  if ((v39 & 1) != 0)
  {
    unsigned int v41 = [v56 supportsGlobalVariableRelocation];
    uint64_t v40 = 0x40000LL;
    if (!v41) {
      uint64_t v40 = 0LL;
    }
  }

  GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFFBFFFFLL | v40;
  Class v42 = NSClassFromString(@"MTLBufferDescriptor");
  id v43 = DEVICEOBJECT(v56);
  unint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
  char v45 = objc_opt_respondsToSelector(v44, "resourcePatchingTypeForResourceType:");

  if ((v45 & 1) != 0 && v42)
  {
    id v46 = DEVICEOBJECT(v56);
    int v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
    BOOL v48 = [v47 resourcePatchingTypeForResourceType:3] != (char *)&dword_0 + 2;

    uint64_t v49 = 0x80000LL;
    GT_SUPPORT_0 = v49 | GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }

  id v50 = DEVICEOBJECT(v56);
  int v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
  char v52 = objc_opt_respondsToSelector(v51, "resourcePatchingTypeForResourceType:");

  if ((v52 & 1) != 0)
  {
    id v53 = DEVICEOBJECT(v56);
    __int128 v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
    BOOL v55 = [v54 resourcePatchingTypeForResourceType:8] == (char *)&dword_0 + 1;

    GT_SUPPORT_0 = GT_SUPPORT_0 & 0xFFFFFFFFFFEFFFFFLL | ((unint64_t)v55 << 20);
  }
}

unsigned int *ExpectedState(uint64_t a1)
{
  uint64_t v2 = **(void **)a1;
  size_t FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename(v2, "XPState");
  if (FileWithFilename)
  {
    unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", *FileWithFilename));
    uint64_t v5 = *(void *)(a1 + 152);
    id v6 = v4;
    GTCaptureArchive_fillBufferCompressedDeflate( v2,  v5,  (uint64_t)FileWithFilename,  [v6 mutableBytes],  *FileWithFilename,  0);
    uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSDictionary, v7);
    uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSArray, v9);
    uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSString, v11);
    uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSNumber, v13);
    uint64_t v16 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v8,  v10,  v12,  v14,  objc_opt_class(&OBJC_CLASS___NSNull, v15),  0LL);
    unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v17,  v6,  0LL));

    if (v18) {
      size_t FileWithFilename = (unsigned int *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"XPState"]);
    }
    else {
      size_t FileWithFilename = 0LL;
    }
  }

  return FileWithFilename;
}

void sub_163B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GetIOAccelerator()
{
  v0 = IOServiceMatching("IOAccelerator");
  uint64_t result = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (!(_DWORD)result)
  {
    uint64_t v2 = IOServiceMatching("IOAcceleratorES");
    return IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  }

  return result;
}

id GetMetalPluginName(io_registry_entry_t a1, _DWORD *a2)
{
  CFProperty = (void *)IORegistryEntryCreateCFProperty(a1, @"MetalPluginName", 0LL, 0);
  uint64_t v5 = CFProperty;
  if (CFProperty)
  {
    CFRelease(CFProperty);
    if (a2)
    {
      id v6 = (void *)IORegistryEntryCreateCFProperty(a1, @"GPUConfigurationVariable", 0LL, 0);
      uint64_t v7 = v6;
      if (v6)
      {
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"gpu_gen"]);
        uint64_t v9 = v8;
        if (v8)
        {
          unsigned int v10 = [v8 intValue];
          if (v10 == 15)
          {
            uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"num_cores"]);
            else {
              unsigned int v10 = 15;
            }
          }

          *a2 = v10 - 10;
        }
      }
    }
  }

  return v5;
}

void sub_163CF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFTypeRef GTProfilerConfigurationVariables(io_registry_entry_t a1)
{
  return (id)IORegistryEntryCreateCFProperty(a1, @"GPUConfigurationVariable", 0LL, 0);
}

uint64_t MetalPluginTarget(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1 && ([v1 hasPrefix:@"AGXMetal"] & 1) != 0)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "substringFromIndex:", objc_msgSend(@"AGXMetal", "length")));
    unint64_t v4 = v3;
    if (v3)
    {
      if (([v3 hasPrefix:@"S4"] & 1) != 0
        || ([v4 hasPrefix:@"S5"] & 1) != 0
        || ([v4 hasPrefix:@"S6"] & 1) != 0)
      {
        uint64_t v5 = 1LL;
LABEL_18:

        goto LABEL_19;
      }

      if (([v4 hasPrefix:@"G"] & 1) != 0
        || ([v4 hasPrefix:@"A"] & 1) != 0
        || [v4 hasPrefix:@"1"])
      {
        id v6 = v4;
        uint64_t v7 = (char *)[v6 UTF8String];
        int v8 = 0;
        for (unint64_t i = [v6 hasPrefix:@"1"] ^ 1;
              i < (unint64_t)[v6 length];
              ++i)
        {
          if (v7[i] < 0) {
            break;
          }
          uint64_t v10 = v7[i];
          if ((_DefaultRuneLocale.__runetype[v10] & 0x400) == 0) {
            break;
          }
          int v8 = v10 + 10 * v8 - 48;
        }

        if (v8 == 15)
        {
          if (i < (unint64_t)[v6 length]
            && [v6 characterAtIndex:i] == 95
            || (id)i == [v6 length])
          {
            int v8 = 14;
          }

          else
          {
            int v8 = 15;
          }
        }

        else {
          int v12 = -10;
        }
        int v13 = v12 + v8;
        if (v13 <= -2) {
          uint64_t v5 = 0x80000000LL;
        }
        else {
          uint64_t v5 = v13;
        }
        goto LABEL_18;
      }
    }

    uint64_t v5 = 0x80000000LL;
    goto LABEL_18;
  }

  uint64_t v5 = 0x80000000LL;
LABEL_19:

  return v5;
}

void sub_163F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id IsAGXMetalPlugin(void *a1, const char *a2)
{
  return [a1 containsString:@"AGXMetal"];
}

id ProcessEncoderTimeData(void *a1, void *a2, void *a3, unint64_t a4)
{
  id v7 = a1;
  id v8 = a2;
  id v10 = a3;
  __int128 v54 = v10;
  if (!v7) {
    id v7 = (id)objc_opt_new(&OBJC_CLASS___NSArray, v9);
  }
  int v57 = v8;
  if (!v8) {
    int v57 = (void *)objc_opt_new(&OBJC_CLASS___NSArray, v9);
  }
  unint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"activePerEncoderDrawCallCount"]);
  int v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", @"perEncoderKickCount", v7));
  unint64_t v11 = (unint64_t)[v7 count];
  unint64_t v12 = v11;
  id v58 = v8;
  if (v11)
  {
    if (v11 >> 61) {
      abort();
    }
    int v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v11);
    uint64_t v15 = (uint64_t)&v13[8 * v14];
    memset_pattern16(v13, &unk_318420, 8 * v12);
    uint64_t v16 = &v13[8 * v12];
  }

  else
  {
    uint64_t v16 = 0LL;
    uint64_t v15 = 0LL;
    int v13 = 0LL;
  }

  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  id v17 = v7;
  unint64_t v18 = 0LL;
  id v19 = [v17 countByEnumeratingWithState:&v69 objects:v76 count:16];
  if (v19)
  {
    uint64_t v20 = *(void *)v70;
    do
    {
      for (unint64_t i = 0LL; i != v19; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v70 != v20) {
          objc_enumerationMutation(v17);
        }
        v18 += (unint64_t)[*(id *)(*((void *)&v69 + 1) + 8 * (void)i) unsignedLongLongValue];
      }

      id v19 = [v17 countByEnumeratingWithState:&v69 objects:v76 count:16];
    }

    while (v19);
  }

  if (a4)
  {
    double v23 = (double)a4 / (double)v18;
    unint64_t v24 = (v16 - v13) >> 3;
    if (v24 <= (v15 - (uint64_t)v13) >> 3)
    {
      if (v16 != v13)
      {
        uint64_t v29 = 0LL;
        do
          *(double *)&v13[8 * v29++] = v23;
        while (v24 != v29);
      }
    }

    else
    {
      if (v13)
      {
        operator delete(v13);
        uint64_t v15 = 0LL;
      }

      if (v16 - v13 < 0) {
        goto LABEL_60;
      }
      uint64_t v25 = v15 >> 2;
      if (v15 >> 2 <= v24) {
        uint64_t v25 = (v16 - v13) >> 3;
      }
      unint64_t v26 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8LL ? 0x1FFFFFFFFFFFFFFFLL : v25;
      if (v26 >> 61) {
LABEL_60:
      }
        abort();
      uint64_t v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v26);
      int v13 = v27;
      uint64_t v28 = 0LL;
      do
      {
        *(double *)&v27[v28] = v23;
        v28 += 8LL;
      }

      while (8 * v24 != v28);
    }
  }

  if (!v61)
  {
    v75[0] = v17;
    v75[1] = v57;
    char v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v75, 2LL));
    goto LABEL_56;
  }

  unint64_t v60 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v22);
  BOOL v55 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v30);
  id v56 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v31);
  unint64_t v59 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v32);
  unsigned int v33 = 0;
  unsigned int v62 = 0;
  while (1)
  {
    if ((unint64_t)[v63 count] <= v33)
    {
      v73[0] = v59;
      v73[1] = v56;
      v73[2] = v60;
      v73[3] = v55;
      char v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v73, 4LL));
      goto LABEL_55;
    }

    uint64_t v64 = v33;
    uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v63, "objectAtIndexedSubscript:"));
    unsigned int v35 = [v34 unsignedIntValue];

    int v36 = (void *)objc_claimAutoreleasedReturnValue([v61 objectAtIndexedSubscript:v64]);
    unsigned int v37 = [v36 unsignedIntValue];

    if (!v35 && v37 == 1)
    {
      [v59 addObject:&off_5A0AD8];
      [v60 addObject:&off_5A0AD8];
      if (v58)
      {
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](&OBJC_CLASS___NSArray, "arrayWithObject:", &off_5A0AD8));
        [v56 addObject:v38];

        char v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObject:](&OBJC_CLASS___NSArray, "arrayWithObject:", &off_5A0AD8));
        [v55 addObject:v39];
      }

      goto LABEL_51;
    }

    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:v62]);
    [v60 addObject:v40];

    if (v58)
    {
      Class v42 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v41);
      __int128 v67 = 0u;
      __int128 v68 = 0u;
      __int128 v65 = 0u;
      __int128 v66 = 0u;
      id v43 = (void *)objc_claimAutoreleasedReturnValue([v57 objectAtIndexedSubscript:v62]);
      id v44 = [v43 countByEnumeratingWithState:&v65 objects:v74 count:16];
      if (v44)
      {
        uint64_t v45 = *(void *)v66;
        do
        {
          for (unint64_t j = 0LL; j != v44; unint64_t j = (char *)j + 1)
          {
            if (*(void *)v66 != v45) {
              objc_enumerationMutation(v43);
            }
            int v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)(*(double *)&v13[8 * v62] * (double)(unint64_t)objc_msgSend( *(id *)(*((void *)&v65 + 1)
                                                                                   + 8LL * (void)j),
                                                                             "unsignedLongLongValue"))));
            [v42 addObject:v47];
          }

          id v44 = [v43 countByEnumeratingWithState:&v65 objects:v74 count:16];
        }

        while (v44);
      }

      [v56 addObject:v42];
      BOOL v48 = (void *)objc_claimAutoreleasedReturnValue([v57 objectAtIndexedSubscript:v62]);
      [v55 addObject:v48];
    }

    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:v62]);
    id v50 = [v49 unsignedLongLongValue];

    int v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)(*(double *)&v13[8 * v62] * (double)(unint64_t)v50)));
    [v59 addObject:v51];

    ++v62;
LABEL_51:
    unsigned int v33 = v64 + 1;
  }

  char v52 = 0LL;
LABEL_55:

LABEL_56:
  if (v13) {
    operator delete(v13);
  }

  return v52;
}

void sub_1645B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19)
{
  if (v19) {
    operator delete(v19);
  }

  _Unwind_Resume(a1);
}

id ProcessDerivedCounterDataFromDevice(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v107 = a2;
  id v126 = a3;
  int v108 = v5;
  if (!v5) {
    goto LABEL_114;
  }
  unint64_t v105 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v6);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"counters"]);
  unint64_t v137 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"NormalizedCounters"]);
  if (!v7)
  {
    id v5 = 0LL;
    goto LABEL_113;
  }

  [v7 count];
  int64_t v124 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v8);
  if (v137)
  {
    __int128 v154 = 0u;
    __int128 v155 = 0u;
    __int128 v152 = 0u;
    __int128 v153 = 0u;
    obunint64_t j = v7;
    id v9 = [obj countByEnumeratingWithState:&v152 objects:v166 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v153;
      do
      {
        for (unint64_t i = 0LL; i != v9; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v153 != v10) {
            objc_enumerationMutation(obj);
          }
          unint64_t v12 = *(void **)(*((void *)&v152 + 1) + 8LL * (void)i);
          if ([v137 containsObject:v12])
          {
            int v13 = (void *)objc_claimAutoreleasedReturnValue([v12 stringByAppendingString:@"_norm"]);
            [v124 addObject:v13];
          }
        }

        id v9 = [obj countByEnumeratingWithState:&v152 objects:v166 count:16];
      }

      while (v9);
    }
  }

  memset(__p, 0, sizeof(__p));
  __int128 v147 = 0u;
  __int128 v148 = 0u;
  __int128 v149 = 0u;
  __int128 v150 = 0u;
  id obja = v7;
  id v14 = [obja countByEnumeratingWithState:&v147 objects:v165 count:16];
  if (v14)
  {
    uint64_t v15 = *(void *)v148;
    do
    {
      for (unint64_t j = 0LL; j != v14; unint64_t j = (char *)j + 1)
      {
        if (*(void *)v148 != v15) {
          objc_enumerationMutation(obja);
        }
        LOBYTE(v171[0]) = [v137 containsObject:*(void *)(*((void *)&v147 + 1) + 8 * (void)j)];
        std::vector<BOOL>::push_back((uint64_t *)__p, v171);
      }

      id v14 = [obja countByEnumeratingWithState:&v147 objects:v165 count:16];
    }

    while (v14);
  }

  id v17 = (id)objc_claimAutoreleasedReturnValue( +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  @"MTLStatDataMaster",  @"MTLStat_nSec",  0LL));
  id objb = obja;
  id v19 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v18);
  v171[0] = _NSConcreteStackBlock;
  v171[1] = 3221225472LL;
  v171[2] = ___ZL28CounterIndicesFromCounterSetP5NSSetP7NSArray_block_invoke;
  v171[3] = &unk_58F3D0;
  id v20 = v17;
  id v172 = v20;
  id v21 = v19;
  id v173 = v21;
  [objb enumerateObjectsUsingBlock:v171];
  uint64_t v22 = v173;
  id v106 = v21;

  double v23 = (NSNumber *)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"MTLStatDataMaster"]);
  unsigned int v140 = CounterIndex(v23);

  unint64_t v24 = (NSNumber *)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"MTLStat_nSec"]);
  unsigned int v138 = CounterIndex(v24);

  id v5 = 0LL;
  if (v140 == -1 || v138 == -1) {
    goto LABEL_110;
  }
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([objb arrayByAddingObjectsFromArray:v124]);

  unsigned int v135 = [v25 count];
  id v26 = v25;
  id objb = v26;
  unint64_t v142 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  4 * (void)[v26 count]);
  __int128 v162 = 0u;
  __int128 v163 = 0u;
  __int128 v160 = 0u;
  __int128 v161 = 0u;
  id v27 = [&off_59FAA0 countByEnumeratingWithState:&v160 objects:v171 count:16];
  if (v27)
  {
    uint64_t v28 = *(void *)v161;
    do
    {
      for (unint64_t k = 0LL; k != v27; unint64_t k = (char *)k + 1)
      {
        if (*(void *)v161 != v28) {
          objc_enumerationMutation(&off_59FAA0);
        }
        uint64_t v30 = *(void *)(*((void *)&v160 + 1) + 8LL * (void)k);
        __int128 v156 = 0u;
        __int128 v157 = 0u;
        __int128 v158 = 0u;
        __int128 v159 = 0u;
        id v31 = v26;
        id v32 = [v31 countByEnumeratingWithState:&v156 objects:&v167 count:16];
        if (v32)
        {
          uint64_t v33 = *(void *)v157;
          do
          {
            for (unint64_t m = 0LL; m != v32; unint64_t m = (char *)m + 1)
            {
              if (*(void *)v157 != v33) {
                objc_enumerationMutation(v31);
              }
              unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v156 + 1) + 8 * (void)m) stringByAppendingString:v30]);
              -[NSMutableArray addObject:](v142, "addObject:", v35);
            }

            id v32 = [v31 countByEnumeratingWithState:&v156 objects:&v167 count:16];
          }

          while (v32);
        }

        id v26 = objb;
      }

      id v27 = [&off_59FAA0 countByEnumeratingWithState:&v160 objects:v171 count:16];
    }

    while (v27);
  }

  LODWORD(v160) = 0;
  DWORD1(v160) = v135;
  DWORD2(v160) = 2 * v135;
  HIDWORD(v160) = 3 * v135;
  unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v108 objectForKeyedSubscript:@"AverageSamples"]);
  int v91 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v36);
  uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"perCommandBufferEncoderCount"]);
  int v98 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"activePerEncoderDrawCallCount"]);
  unint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v107 objectForKeyedSubscript:@"perEncoderKickCount"]);
  unsigned int v37 = 0;
  unsigned int v38 = 0;
  unsigned int v95 = 0;
  uint64_t v103 = 4 * v135;
  uint64_t v110 = v140;
  uint64_t v122 = v138;
  while (1)
  {
    if ((unint64_t)[v104 count] <= v37)
    {
      [v105 setObject:v142 forKeyedSubscript:@"counters"];
      [v105 setObject:v91 forKeyedSubscript:@"AverageSamples"];
      int v88 = (void *)objc_claimAutoreleasedReturnValue([v108 objectForKeyedSubscript:@"counterLists"]);
      id v89 = [v88 copy];
      [v105 setObject:v89 forKeyedSubscript:@"counterLists"];

      id v5 = v105;
      goto LABEL_109;
    }

    unsigned int v96 = v37;
    char v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "objectAtIndexedSubscript:"));
    unsigned int v40 = [v39 unsignedIntValue];

    if (v40) {
      break;
    }
LABEL_104:
    unsigned int v37 = v96 + 1;
  }

  uint64_t v97 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v101, "objectAtIndexedSubscript:"));
  unint64_t v93 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v41);
  unsigned int v102 = 0;
  unsigned int v92 = v38 + v40;
  char v94 = 1;
  while (1)
  {
    unint64_t v119 = v38;
    Class v42 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v99, "objectAtIndexedSubscript:"));
    unsigned int v43 = [v42 unsignedIntValue];

    id v44 = (void *)objc_claimAutoreleasedReturnValue([v98 objectAtIndexedSubscript:v38]);
    unsigned int v45 = [v44 unsignedIntValue];

    if (v45 || v43 != 1) {
      break;
    }
    id v113 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v46);
LABEL_47:
    unint64_t v100 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v47);
    id v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v103));
    if ((_DWORD)v103)
    {
      uint64_t v48 = v103;
      do
      {
        [v112 addObject:&off_5A0B20];
        --v48;
      }

      while (v48);
    }

    __int128 v145 = 0u;
    __int128 v146 = 0u;
    __int128 v143 = 0u;
    __int128 v144 = 0u;
    id v114 = v113;
    id v49 = [v114 countByEnumeratingWithState:&v143 objects:v164 count:16];
    if (v49)
    {
      unsigned int v117 = 0;
      uint64_t v109 = *(void *)v144;
      do
      {
        uint64_t v118 = 0LL;
        id v111 = v49;
        do
        {
          if (*(void *)v144 != v109) {
            objc_enumerationMutation(v114);
          }
          id v50 = *(void **)(*((void *)&v143 + 1) + 8LL * (void)v118);
          id v136 = v112;
          id v125 = v126;
          id v51 = v50;
          id v123 = v114;
          id v115 = objb;
          uint64_t v116 = v142;
          unint64_t v130 = v51;
          char v52 = (void *)objc_claimAutoreleasedReturnValue([v51 objectAtIndexedSubscript:0]);
          uint64_t v54 = objc_opt_class(&OBJC_CLASS___NSArray, v53);
          char isKindOfClass = objc_opt_isKindOfClass(v52, v54);

          if ((isKindOfClass & 1) != 0)
          {
            BOOL v55 = (void *)objc_claimAutoreleasedReturnValue([v130 objectAtIndexedSubscript:v110]);
            id v56 = (void *)objc_claimAutoreleasedReturnValue([v55 objectAtIndexedSubscript:0]);
          }

          else
          {
            id v56 = (void *)objc_claimAutoreleasedReturnValue([v130 objectAtIndexedSubscript:v110]);
            BOOL v55 = v56;
          }

          id v128 = [v56 unsignedLongLongValue];
          if ((isKindOfClass & 1) != 0) {

          }
          if ((unint64_t)v128 < 4)
          {
            unsigned int v120 = [v130 count];
            unint64_t v121 = v117;
            if (v126 && (unint64_t)[v125 count] > v119)
            {
              int v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "objectAtIndexedSubscript:"));
              id v58 = [v57 count];
              else {
                unint64_t v59 = (unint64_t)v58;
              }

              unint64_t v121 = v117 % v59;
            }

            unint64_t v60 = 0LL;
            uint64_t v127 = 0LL;
            while (v60 < (unint64_t)[v130 count])
            {
              unint64_t v134 = (void *)objc_claimAutoreleasedReturnValue([v130 objectAtIndexedSubscript:v60]);
              if ((isKindOfClass & 1) != 0) {
                id v139 = (id)objc_claimAutoreleasedReturnValue([v134 objectAtIndexedSubscript:0]);
              }
              else {
                id v139 = v134;
              }
              if (v126 && v60 == v122 && (unint64_t)[v125 count] > v119)
              {
                int v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v125, "objectAtIndexedSubscript:"));
                uint64_t v62 = objc_claimAutoreleasedReturnValue([v61 objectAtIndexedSubscript:v121]);

                id v139 = (id)v62;
              }

              unint64_t v63 = (char *)[v139 unsignedLongLongValue];
              unint64_t v64 = v60 + HIDWORD(v160);
              __int128 v65 = (void *)objc_claimAutoreleasedReturnValue([v136 objectAtIndexedSubscript:v64]);
              __int128 v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  &v63[(void)[v65 unsignedLongLongValue]]));
              [v136 setObject:v66 atIndexedSubscript:v64];

              [v136 setObject:v139 atIndexedSubscript:v60 + *((unsigned int *)&v160 + (void)v128)];
              if ((isKindOfClass & 1) != 0
                && ((*(void *)((char *)__p[0] + ((v60 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v60) & 1) != 0)
              {
                id v67 = [v139 unsignedLongLongValue];
                __int128 v68 = (void *)objc_claimAutoreleasedReturnValue([v134 objectAtIndexedSubscript:1]);
                id v69 = [v68 unsignedLongLongValue];

                else {
                  unint64_t v70 = (unint64_t)v69;
                }
                double v71 = (double)(unint64_t)v67 * 100.0 / (double)v70;
                __int128 v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v71));
                [v136 setObject:v72 atIndexedSubscript:v127 + *((_DWORD *)&v160 + (void)v128) + v120];

                id v73 = [v123 count];
                if (v121 || (unint64_t)v73 < 2)
                {
                  if ([v123 count] == (char *)&dword_0 + 1)
                  {
                    unint64_t v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v71));
                    [v136 setObject:v87 atIndexedSubscript:v127 + HIDWORD(v160) + v120];
                    goto LABEL_97;
                  }
                }

                else
                {
                  __int128 v170 = 0u;
                  __int128 v169 = 0u;
                  __int128 v168 = 0u;
                  __int128 v167 = 0u;
                  id v141 = v123;
                  id v74 = [v141 countByEnumeratingWithState:&v167 objects:v171 count:16];
                  if (!v74)
                  {

                    double v86 = 0.0;
                    goto LABEL_95;
                  }

                  unint64_t v75 = 0LL;
                  unint64_t v76 = 0LL;
                  uint64_t v77 = *(void *)v168;
                  do
                  {
                    for (uint64_t n = 0LL; n != v74; uint64_t n = (char *)n + 1)
                    {
                      if (*(void *)v168 != v77) {
                        objc_enumerationMutation(v141);
                      }
                      int v79 = *(void **)(*((void *)&v167 + 1) + 8LL * (void)n);
                      unint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v79 objectAtIndexedSubscript:v60]);
                      uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue([v80 objectAtIndexedSubscript:0]);
                      id v82 = [v81 unsignedLongLongValue];

                      int64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v79 objectAtIndexedSubscript:v60]);
                      int64_t v84 = (void *)objc_claimAutoreleasedReturnValue([v83 objectAtIndexedSubscript:1]);
                      id v85 = [v84 unsignedLongLongValue];

                      v76 += (unint64_t)v82;
                      v75 += (unint64_t)v85;
                    }

                    id v74 = [v141 countByEnumeratingWithState:&v167 objects:v171 count:16];
                  }

                  while (v74);

                  double v86 = (double)v76 * 100.0;
                  if (!v75) {
LABEL_95:
                  }
                    unint64_t v75 = 1LL;
                  unint64_t v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  v86 / (double)v75));
                  [v136 setObject:v87 atIndexedSubscript:v127 + HIDWORD(v160) + v120];
LABEL_97:
                }

                ++v127;
              }

              ++v60;
              continue;
            }
          }

          ++v117;
          uint64_t v118 = (char *)v118 + 1;
        }

        while (v118 != v111);
        id v49 = [v123 countByEnumeratingWithState:&v143 objects:v164 count:16];
      }

      while (v49);
    }

    [v100 addObject:v112];
    [v93 addObject:v100];

    unsigned int v38 = v119 + 1;
    if ((_DWORD)v119 + 1 == v92)
    {
      [v91 addObject:v93];

      v95 += (v94 & 1) == 0;
      unsigned int v38 = v92;
      goto LABEL_104;
    }
  }

  if ((unint64_t)[v97 count] > v102)
  {
    id v113 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v97, "objectAtIndexedSubscript:"));
    char v94 = 0;
    ++v102;
    goto LABEL_47;
  }

LABEL_108:
  id v5 = 0LL;
LABEL_109:

LABEL_110:
  if (__p[0]) {
    operator delete(__p[0]);
  }

LABEL_113:
LABEL_114:

  return v5;
}

void sub_16563C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, void *a25, void *a26, void *a27, void *a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, void *a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,void *a56)
{
  if (STACK[0x208]) {
    operator delete((void *)STACK[0x208]);
  }

  _Unwind_Resume(a1);
}

void std::vector<BOOL>::push_back(uint64_t *a1, _BYTE *a2)
{
  unint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  if (v4 == v5 << 6)
  {
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0LL) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0LL) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    std::vector<BOOL>::reserve((uint64_t)a1, v7);
    unint64_t v4 = a1[1];
  }

  a1[1] = v4 + 1;
  uint64_t v8 = *a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1LL << v4;
  if (*a2) {
    uint64_t v11 = *(void *)(v8 + 8 * v9) | v10;
  }
  else {
    uint64_t v11 = *(void *)(v8 + 8 * v9) & ~v10;
  }
  *(void *)(v8 + 8 * v9) = v11;
}

void ___ZL28CounterIndicesFromCounterSetP5NSSetP7NSArray_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:"))
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", a3));
    [*(id *)(a1 + 40) setObject:v5 forKeyedSubscript:v6];
  }
}

void sub_165B70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t CounterIndex(NSNumber *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1) {
    uint64_t v3 = -[NSNumber unsignedIntValue](v1, "unsignedIntValue");
  }
  else {
    uint64_t v3 = 0xFFFFFFFFLL;
  }

  return v3;
}

void sub_165BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL IsGPUPerformanceStateInduced(void *a1)
{
  uint64_t v6 = 0LL;
  id v4 = 0LL;
  char v5 = 0;
  id v1 = (void *)objc_claimAutoreleasedReturnValue([a1 defaultDevice]);
  GTAGXPerfStateControl::InitWithDevice((uint64_t)&v4, v1);

  BOOL v2 = GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)&v4);
  GTAGXPerfStateControl::~GTAGXPerfStateControl(&v4);
  return v2;
}

void sub_165C40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)va);
  _Unwind_Resume(a1);
}

id ConsistentPerformanceStateInfo(uint64_t a1)
{
  BOOL v2 = ExpectedState(a1);
  uint64_t v3 = (NSNumber *)objc_claimAutoreleasedReturnValue(v2);
  uint64_t v10 = 0LL;
  id v8 = 0LL;
  char v9 = 0;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) defaultDevice]);
  GTAGXPerfStateControl::InitWithDevice((uint64_t)&v8, v4);

  char v5 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)&v8, v3);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  GTAGXPerfStateControl::~GTAGXPerfStateControl(&v8);

  return v6;
}

void sub_165CE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)va);
  _Unwind_Resume(a1);
}

NSString *GTShaderProfilerGenerateComputedKey(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%08u%09u%09llu_%@",  a1,  a2,  a3,  v7);

  return v8;
}

void sub_165D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_init(uint64_t a1, void *a2)
{
  __int128 v27 = 0u;
  uint64_t v23 = 0LL;
  __int128 v22 = 0u;
  __int128 v21 = 0u;
  __int128 v20 = 0u;
  __int128 v19 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  id v7 = a2;
  *(void *)&__int128 v12 = 0xFF0000FF00FF00FFLL;
  *((void *)&v12 + 1) = 1082130432LL;
  *(void *)&__int128 v13 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  128LL);
  unint64_t v24 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
  uint64_t v25 = objc_alloc_init(&OBJC_CLASS___NSOperationQueue);
  id v26 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 16LL);
  __copy_assignment_8_8_t0w88_s88_S_s96_s104_t112w8_s120_s128_s136_t144w8_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288( a1,  (uint64_t)&v7);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
  id v4 = (__CFString *)objc_claimAutoreleasedReturnValue([v3 objectForInfoDictionaryKey:@"CFBundleName"]);

  if (!v4) {
    id v4 = @"MTLReplayController";
  }
  char v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"gputools.%@.parallelQueue",  v4,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  (void)v16,  *((void *)&v16 + 1),  (void)v17,  *((void *)&v17 + 1),  (void)v18,  *((void *)&v18 + 1),  (void)v19,  *((void *)&v19 + 1),  (void)v20,  *((void *)&v20 + 1),  (void)v21,  *((void *)&v21 + 1),  (void)v22,  *((void *)&v22 + 1),  v23,  v24,  v25));
  [*(id *)(a1 + 264) setName:v5];

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"gputools.%@.serialQueue",  v4));
  [*(id *)(a1 + 256) setName:v6];

  [*(id *)(a1 + 256) setMaxConcurrentOperationCount:1];
  __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288(&v7);
}

void sub_165F18(_Unwind_Exception *a1)
{
  __destructor_8_s0_s8_s24_s32_s40_s56_s64_s72_s80_s88_s96_s104_s112_s120_s128_s136_s144_s152((id *)(v3 + 96));
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_setDisplayDelegate(uint64_t a1, void *a2)
{
}

GTMTLReplayService *GTMTLReplayClient_createNewTransport( uint64_t a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  dispatch_queue_t v5 = dispatch_queue_create("com.apple.gputools.replay", 0LL);
  dispatch_suspend(v5);
  uint64_t v6 = GTTransportServiceDaemonConnectionNew(v5);
  uint64_t v7 = objc_claimAutoreleasedReturnValue(v6);
  __int128 v8 = (void *)GTMTLReplayClient_createNewTransport_connection;
  GTMTLReplayClient_createNewTransport_connectiouint64_t n = v7;

  objc_initWeak(&location, (id)GTMTLReplayClient_createNewTransport_connection);
  __int128 v9 = (void *)GTMTLReplayClient_createNewTransport_connection;
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  v22[2] = __GTMTLReplayClient_createNewTransport_block_invoke;
  v22[3] = &unk_58F3F8;
  objc_copyWeak(&v23, &location);
  [v9 activateWithMessageHandler:v22 andErrorHandler:&__block_literal_global_6078];
  id v10 = objc_alloc_init(&OBJC_CLASS___GTBulkDataService);
  objc_storeStrong((id *)(a1 + 288), v10);
  id v11 = [[GTServiceProperties alloc] initWithProtocol:&OBJC_PROTOCOL___GTBulkDataService];
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([(id)GTMTLReplayClient_createNewTransport_connection connection]);
  char v13 = registerService(v12, v11);

  if ((v13 & 1) != 0)
  {
    id v14 = [[GTBulkDataServiceXPCDispatcher alloc] initWithService:v10 properties:v11];
    objc_msgSend( (id)GTMTLReplayClient_createNewTransport_connection,  "registerDispatcher:forPort:",  v14,  objc_msgSend(v11, "servicePort"));
    __int128 v15 = -[GTMTLReplayService initWithContext:](objc_alloc(&OBJC_CLASS___GTMTLReplayService), "initWithContext:", a1);
    objc_storeStrong((id *)&_observer, v15);
    id v16 = [[GTServiceProperties alloc] initWithProtocol:&OBJC_PROTOCOL___GTMTLReplayService];
    __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([(id)GTMTLReplayClient_createNewTransport_connection connection]);
    char v18 = registerService(v17, v16);

    if ((v18 & 1) != 0)
    {
      id v19 = [[GTMTLReplayServiceXPCDispatcher alloc] initWithService:v15 properties:v16 bulkDataService:v10 bulkDataServiceProperties:v11];
      objc_msgSend( (id)GTMTLReplayClient_createNewTransport_connection,  "registerDispatcher:forPort:",  v19,  objc_msgSend(v16, "servicePort"));
      dispatch_resume(v5);
      __int128 v20 = v15;
    }

    else
    {
      __int128 v20 = 0LL;
    }
  }

  else
  {
    __int128 v20 = 0LL;
  }

  objc_destroyWeak(&v23);
  objc_destroyWeak(&location);

  return v20;
}

void sub_1661D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

id GTMTLReplayHost_computeDerivedCountersFromData(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v165 = a2;
  id v10 = &off_59FA70;
  id v164 = a3;
  id v11 = a4;
  id v12 = a5;
  char v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"DerivedCounterScript"]);
  if (v13)
  {
    id v169 = (id)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"]);
    __int128 v163 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  (char *)[v11 count]
           + (void)[v9 count]
           + (unint64_t)[&off_59FA70 count]);
    [v9 count];
    __chkstk_darwin();
    __int128 v160 = (char *)&v152 - v14;
    __int128 v15 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v9 count]);
    if ([v9 count])
    {
      unint64_t v16 = 0LL;
      do
      {
        __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([v9 objectAtIndexedSubscript:v16]);
        char v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v16));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v15, "setObject:forKeyedSubscript:", v18, v17);

        ++v16;
      }

      while (v16 < (unint64_t)[v9 count]);
    }

    id v155 = v12;
    id v19 = (void *)objc_claimAutoreleasedReturnValue([v9 sortedArrayUsingSelector:"compare:"]);
    id v20 = [v19 count];
    __int128 v21 = v160;
    if (v20)
    {
      unint64_t v22 = 0LL;
      do
      {
        id v23 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndexedSubscript:v22]);
        unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v15, "objectForKeyedSubscript:", v23));
        *(_DWORD *)&v21[4 * v22] = [v24 intValue];

        ++v22;
      }

      while (v22 < (unint64_t)[v19 count]);
    }

    uint64_t v25 = v163;
    id v156 = v11;
    -[NSMutableArray addObjectsFromArray:](v163, "addObjectsFromArray:", v11);
    -[NSMutableArray addObjectsFromArray:](v25, "addObjectsFromArray:", v19);
    -[NSMutableArray addObjectsFromArray:](v25, "addObjectsFromArray:", &off_59FA70);

    id v26 = objc_alloc(&OBJC_CLASS___NSMutableArray);
    id v27 = v165;
    __int128 v162 = -[NSMutableArray initWithCapacity:](v26, "initWithCapacity:", [v165 count]);
    __int128 v161 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v27 count]);
    uint64_t v28 = objc_alloc_init(&OBJC_CLASS___JSVirtualMachine);
    uint64_t v29 = objc_alloc(&OBJC_CLASS___JSContext);
    __int128 v152 = v28;
    uint64_t v30 = -[JSContext initWithVirtualMachine:](v29, "initWithVirtualMachine:", v28);
    -[JSContext setObject:forKeyedSubscript:]( v30,  "setObject:forKeyedSubscript:",  &__block_literal_global_6102,  @"ErrorLog");
    -[JSContext setExceptionHandler:](v30, "setExceptionHandler:", &__block_literal_global_20);
    __int128 v153 = v13;
    id v31 = -[JSContext evaluateScript:](v30, "evaluateScript:", v13);
    id v32 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v182 = 0u;
    __int128 v183 = 0u;
    __int128 v184 = 0u;
    __int128 v185 = 0u;
    id v33 = v9;
    id v34 = [v33 countByEnumeratingWithState:&v182 objects:v199 count:16];
    if (v34)
    {
      id v35 = v34;
      uint64_t v36 = *(void *)v183;
      do
      {
        for (unint64_t i = 0LL; i != v35; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v183 != v36) {
            objc_enumerationMutation(v33);
          }
          unsigned int v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"var %@ = 0;",
                            *(void *)(*((void *)&v182 + 1) + 8LL * (void)i)));
          -[NSMutableArray addObject:](v32, "addObject:", v38);
        }

        id v35 = [v33 countByEnumeratingWithState:&v182 objects:v199 count:16];
      }

      while (v35);
    }

    id v154 = v9;

    -[NSMutableArray addObject:](v32, "addObject:", @"function _SetRawCounterValues() {");
    if ([v33 count])
    {
      unint64_t v39 = 0LL;
      do
      {
        unsigned int v40 = (void *)objc_claimAutoreleasedReturnValue([v33 objectAtIndexedSubscript:v39]);
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\t%@ = _RawCounterValues[%lu];",
                          v40,
                          v39));
        -[NSMutableArray addObject:](v32, "addObject:", v41);

        ++v39;
      }

      while (v39 < (unint64_t)[v33 count]);
    }

    -[NSMutableArray addObject:](v32, "addObject:", @"}");
    __int128 v180 = 0u;
    __int128 v181 = 0u;
    __int128 v178 = 0u;
    __int128 v179 = 0u;
    Class v42 = &off_59FA70;
    id v43 = [&off_59FA70 countByEnumeratingWithState:&v178 objects:v198 count:16];
    if (v43)
    {
      id v44 = v43;
      uint64_t v45 = *(void *)v179;
      do
      {
        for (unint64_t j = 0LL; j != v44; unint64_t j = (char *)j + 1)
        {
          if (*(void *)v179 != v45) {
            objc_enumerationMutation(&off_59FA70);
          }
          uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"var %@ = 0;",
                            *(void *)(*((void *)&v178 + 1) + 8LL * (void)j)));
          -[NSMutableArray addObject:](v32, "addObject:", v47);
        }

        id v44 = [&off_59FA70 countByEnumeratingWithState:&v178 objects:v198 count:16];
      }

      while (v44);
    }

    -[NSMutableArray addObject:](v32, "addObject:", @"function _SetSoftwareCounterValues() {");
    if ([&off_59FA70 count])
    {
      unint64_t v48 = 0LL;
      do
      {
        id v49 = (void *)objc_claimAutoreleasedReturnValue([&off_59FA70 objectAtIndexedSubscript:v48]);
        id v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\t%@ = _SoftwareCounterValues[%lu];",
                          v49,
                          v48));
        -[NSMutableArray addObject:](v32, "addObject:", v50);

        ++v48;
      }

      while (v48 < (unint64_t)[&off_59FA70 count]);
    }

    -[NSMutableArray addObject:](v32, "addObject:", @"}");
    -[NSMutableArray addObject:](v32, "addObject:", @"var _DerivedCounterResult = [];");
    -[NSMutableArray addObject:](v32, "addObject:", @"function _EvaluteDerivedCounters() {");
    -[NSMutableArray addObject:](v32, "addObject:", @"\t_DerivedCounterResult = [];");
    __int128 v176 = 0u;
    __int128 v177 = 0u;
    __int128 v174 = 0u;
    __int128 v175 = 0u;
    __int128 v167 = (NSMutableArray *)v156;
    id v51 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v167,  "countByEnumeratingWithState:objects:count:",  &v174,  v197,  16LL);
    if (v51)
    {
      id v52 = v51;
      uint64_t v53 = *(void *)v175;
      do
      {
        for (unint64_t k = 0LL; k != v52; unint64_t k = (char *)k + 1)
        {
          if (*(void *)v175 != v53) {
            objc_enumerationMutation(v167);
          }
          BOOL v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"\ttry { value = %@(); if (!isFinite(value)) { value = 0; } _DerivedCounterResult.push(value); } catch(err) { ErrorLog(err); _DerivedCounterResult.push(0); }",
                            *(void *)(*((void *)&v174 + 1) + 8LL * (void)k)));
          -[NSMutableArray addObject:](v32, "addObject:", v55);
        }

        id v52 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v167,  "countByEnumeratingWithState:objects:count:",  &v174,  v197,  16LL);
      }

      while (v52);
    }

    -[NSMutableArray addObject:](v32, "addObject:", @"}");
    id v56 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v32, "componentsJoinedByString:", @"\n"));
    id v57 = -[JSContext evaluateScript:](v30, "evaluateScript:", v56);

    __int128 v172 = 0u;
    __int128 v173 = 0u;
    __int128 v170 = 0u;
    __int128 v171 = 0u;
    id v58 = v169;
    id v59 = [v58 countByEnumeratingWithState:&v170 objects:v196 count:16];
    id v169 = v58;
    if (v59)
    {
      id v60 = v59;
      uint64_t v61 = *(void *)v171;
      do
      {
        for (unint64_t m = 0LL; m != v60; unint64_t m = (char *)m + 1)
        {
          if (*(void *)v171 != v61) {
            objc_enumerationMutation(v58);
          }
          uint64_t v63 = *(void *)(*((void *)&v170 + 1) + 8LL * (void)m);
          unint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v58 objectForKeyedSubscript:v63]);
          __int128 v65 = (void *)objc_claimAutoreleasedReturnValue( +[JSValue valueWithObject:inContext:]( &OBJC_CLASS___JSValue,  "valueWithObject:inContext:",  v64,  v30));
          -[JSContext setObject:forKeyedSubscript:](v30, "setObject:forKeyedSubscript:", v65, v63);

          id v58 = v169;
        }

        id v60 = [v169 countByEnumeratingWithState:&v170 objects:v196 count:16];
      }

      while (v60);
    }

    exception[0] = 0LL;
    __int128 v66 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
    id v67 = (void *)objc_claimAutoreleasedReturnValue( -[JSContext objectForKeyedSubscript:]( v30,  "objectForKeyedSubscript:",  @"_SetSoftwareCounterValues"));
    JSObjectRef v157 = JSValueToObject(v66, (JSValueRef)[v67 JSValueRef], exception);

    __int128 v68 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
    id v69 = (void *)objc_claimAutoreleasedReturnValue( -[JSContext objectForKeyedSubscript:]( v30,  "objectForKeyedSubscript:",  @"_SetRawCounterValues"));
    JSObjectRef v159 = JSValueToObject(v68, (JSValueRef)[v69 JSValueRef], exception);

    unint64_t v70 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
    double v71 = (void *)objc_claimAutoreleasedReturnValue( -[JSContext objectForKeyedSubscript:]( v30,  "objectForKeyedSubscript:",  @"_EvaluteDerivedCounters"));
    JSObjectRef v158 = JSValueToObject(v70, (JSValueRef)[v71 JSValueRef], exception);

    __int128 v72 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
    LogException(v72, exception[0]);
    id v73 = [v165 count];
    id v74 = v164;
    if (v73)
    {
      unint64_t v75 = 0LL;
      do
      {
        __int128 v166 = (NSMutableArray *)objc_autoreleasePoolPush();
        if ([v74 count])
        {
          unint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([v74 objectAtIndexedSubscript:v75]);
          uint64_t v77 = (void *)objc_claimAutoreleasedReturnValue( +[JSValue valueWithObject:inContext:]( &OBJC_CLASS___JSValue,  "valueWithObject:inContext:",  v76,  v30));
          -[JSContext setObject:forKeyedSubscript:]( v30,  "setObject:forKeyedSubscript:",  v77,  @"_SoftwareCounterValues");

          uint64_t v78 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
          JSObjectCallAsFunction(v78, v157, 0LL, 0LL, 0LL, exception);
          int v79 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
          LogException(v79, exception[0]);
        }

        unint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v165 objectAtIndexedSubscript:v75]);
        uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue( +[JSValue valueWithObject:inContext:]( &OBJC_CLASS___JSValue,  "valueWithObject:inContext:",  v80,  v30));
        -[JSContext setObject:forKeyedSubscript:](v30, "setObject:forKeyedSubscript:", v81, @"_RawCounterValues");

        id v82 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
        JSObjectCallAsFunction(v82, v159, 0LL, 0LL, 0LL, exception);
        int64_t v83 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
        LogException(v83, exception[0]);
        int64_t v84 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
        JSObjectCallAsFunction(v84, v158, 0LL, 0LL, 0LL, exception);
        id v85 = (void *)objc_claimAutoreleasedReturnValue( -[JSContext objectForKeyedSubscript:]( v30,  "objectForKeyedSubscript:",  @"_DerivedCounterResult"));
        double v86 = (void *)objc_claimAutoreleasedReturnValue([v85 toArray]);

        unint64_t v87 = -[JSContext JSGlobalContextRef](v30, "JSGlobalContextRef");
        LogException(v87, exception[0]);
        -[NSMutableArray addObject:](v162, "addObject:", v86);
        id v88 = [v86 count];
        if (v88 != -[NSMutableArray count](v167, "count"))
        {
          id v89 = [v86 count];
          int v90 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"derivedCounterResult contains %lu results, %lu expected (derivedCounterNames)",  v89,  -[NSMutableArray count](v167, "count")));
          int v91 = __stdoutp;
          if (g_runningInCI) {
            unsigned int v92 = "#CI_ERROR# ";
          }
          else {
            unsigned int v92 = "";
          }
          id v93 = v90;
          fprintf( v91,  "%s%s %u: %s\n",  v92,  "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray * __strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)",  190,  (const char *)[v93 UTF8String]);
          id v94 = v93;
          GTMTLReplay_handleError( 101,  (uint64_t)[v94 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m",  (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData",  190,  2);
        }

        id v168 = v86;
        id v95 = [v86 mutableCopy];
        unsigned int v96 = (void *)objc_claimAutoreleasedReturnValue([v165 objectAtIndexedSubscript:v75]);
        id v97 = [v33 count];
        int v98 = v160;
        if (v97)
        {
          unint64_t v99 = 0LL;
          do
          {
            unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v96 objectAtIndexedSubscript:*(int *)&v98[4 * v99]]);
            [v95 addObject:v100];

            ++v99;
          }

          while (v99 < (unint64_t)[v33 count]);
        }

        id v74 = v164;
        unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v164 objectAtIndexedSubscript:v75]);
        [v95 addObjectsFromArray:v101];

        -[NSMutableArray addObject:](v161, "addObject:", v95);
        id v102 = [v95 count];
        if (v102 != -[NSMutableArray count](v163, "count"))
        {
          id v103 = [v168 count];
          uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"resultsForAnalysis contains %lu results, %lu expected (counterNamesForAnalysis)",  v103,  -[NSMutableArray count](v163, "count")));
          unint64_t v105 = __stdoutp;
          if (g_runningInCI) {
            id v106 = "#CI_ERROR# ";
          }
          else {
            id v106 = "";
          }
          id v107 = v104;
          fprintf( v105,  "%s%s %u: %s\n",  v106,  "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray * __strong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)",  208,  (const char *)[v107 UTF8String]);
          id v108 = v107;
          GTMTLReplay_handleError( 101,  (uint64_t)[v108 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m",  (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData",  208,  2);

          id v74 = v164;
        }

        objc_autoreleasePoolPop(v166);
        ++v75;
      }

      while (v75 < (unint64_t)[v165 count]);
    }

    if (!-[NSMutableArray count](v162, "count"))
    {
      uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"derivedDataResults contains no results"));
      uint64_t v110 = __stdoutp;
      if (g_runningInCI) {
        id v111 = "#CI_ERROR# ";
      }
      else {
        id v111 = "";
      }
      id v112 = v109;
      fprintf( v110,  "%s%s %u: %s\n",  v111,  "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__st rong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)",  216,  (const char *)[v112 UTF8String]);
      id v113 = v112;
      GTMTLReplay_handleError( 101,  (uint64_t)[v113 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m",  (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData",  216,  2);
    }

    id v114 = -[NSMutableArray count](v161, "count");
    id v115 = v155;
    if (!v114)
    {
      uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"derivedDataResultsForBottleNeckAnalysis contains no results"));
      unsigned int v117 = __stdoutp;
      if (g_runningInCI) {
        uint64_t v118 = "#CI_ERROR# ";
      }
      else {
        uint64_t v118 = "";
      }
      id v119 = v116;
      fprintf( v117,  "%s%s %u: %s\n",  v118,  "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__st rong, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)",  221,  (const char *)[v119 UTF8String]);
      id v120 = v119;
      GTMTLReplay_handleError( 101,  (uint64_t)[v120 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m",  (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData",  221,  2);
    }

    __int128 v160 = (char *)objc_claimAutoreleasedReturnValue([v115 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    id v168 = (id)objc_claimAutoreleasedReturnValue([v160 objectForKeyedSubscript:@"DerivedCounters"]);
    unint64_t v121 = v167;
    __int128 v167 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 0LL);
    uint64_t v122 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 0LL);
    id v123 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 0LL);
    __int128 v186 = 0u;
    __int128 v187 = 0u;
    __int128 v188 = 0u;
    __int128 v189 = 0u;
    __int128 v166 = v121;
    id v124 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v166,  "countByEnumeratingWithState:objects:count:",  &v186,  exception,  16LL);
    if (v124)
    {
      id v125 = v124;
      uint64_t v126 = *(void *)v187;
      do
      {
        for (uint64_t n = 0LL; n != v125; uint64_t n = (char *)n + 1)
        {
          if (*(void *)v187 != v126) {
            objc_enumerationMutation(v166);
          }
          id v128 = (void *)objc_claimAutoreleasedReturnValue( [v168 objectForKeyedSubscript:*(void *)(*((void *)&v186 + 1) + 8 * (void)n)]);
          unint64_t v129 = (__CFString *)objc_claimAutoreleasedReturnValue([v128 objectForKeyedSubscript:@"name"]);
          unint64_t v130 = (__CFString *)objc_claimAutoreleasedReturnValue([v128 objectForKeyedSubscript:@"description"]);
          unint64_t v131 = (__CFString *)objc_claimAutoreleasedReturnValue([v128 objectForKeyedSubscript:@"type"]);
          if (v129) {
            int v132 = v129;
          }
          else {
            int v132 = @"Unknown";
          }
          -[NSMutableArray addObject:](v167, "addObject:", v132);
          if (v130) {
            int v133 = v130;
          }
          else {
            int v133 = &stru_591D98;
          }
          -[NSMutableArray addObject:](v122, "addObject:", v133);
          if (v131) {
            unint64_t v134 = v131;
          }
          else {
            unint64_t v134 = @"Value";
          }
          -[NSMutableArray addObject:](v123, "addObject:", v134);
        }

        id v125 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v166,  "countByEnumeratingWithState:objects:count:",  &v186,  exception,  16LL);
      }

      while (v125);
    }

    unsigned int v135 = v166;

    id v136 = v167;
    v200[0] = v135;
    v200[1] = v167;
    v200[2] = v122;
    v200[3] = v123;
    unint64_t v137 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v200, 4LL));

    id v12 = v155;
    unsigned int v138 = (void *)objc_claimAutoreleasedReturnValue([v155 objectForKeyedSubscript:@"DerivedCounterAnalysis"]);
    unsigned int v140 = (void *)objc_claimAutoreleasedReturnValue([v160 objectForKeyedSubscript:@"Bottlenecks"]);
    if (!v140) {
      unsigned int v140 = (void *)objc_opt_new(&OBJC_CLASS___NSDictionary, v139);
    }
    v194[0] = @"derivedCounterDataForBottleneckAnalysis";
    v192[0] = @"AverageSamples";
    v192[1] = @"counters";
    v193[0] = v161;
    v193[1] = v163;
    id v141 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v193,  v192,  2LL));
    v195[0] = v141;
    v194[1] = @"derivedCounterData";
    v190[0] = @"AverageSamples";
    v190[1] = @"counters";
    v191[0] = v162;
    v191[1] = v137;
    unint64_t v142 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v191,  v190,  2LL));
    v195[1] = v142;
    v195[2] = v138;
    v194[2] = @"DerivedCounterAnalysis";
    v194[3] = @"DerivedCounterAnalysisFunctions";
    v195[3] = v140;
    __int128 v143 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v195,  v194,  4LL));

    id v144 = v169;
    if (v169)
    {
      id v145 = [v143 mutableCopy];
      [v145 setObject:v144 forKeyedSubscript:@"DerivedCounterConfigurationVariables"];

      __int128 v143 = v145;
    }

    id v9 = v154;
    id v11 = v156;

    char v13 = v153;
  }

  else
  {
    __int128 v146 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"derivedScriptCode missing"));
    __int128 v147 = __stdoutp;
    if (g_runningInCI) {
      __int128 v148 = "#CI_ERROR# ";
    }
    else {
      __int128 v148 = "";
    }
    id v149 = v146;
    fprintf( v147,  "%s%s %u: %s\n",  v148,  "NSDictionary *GTMTLReplayHost_computeDerivedCountersFromData(NSArray *__strong, NSArray *__strong, NSArray *__stro ng, NSArray *__strong, NSArray *__strong, NSDictionary *__strong)",  59,  (const char *)[v149 UTF8String]);
    id v150 = v149;
    GTMTLReplay_handleError( 101,  (uint64_t)[v150 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/launcher/DYJavaScriptHelper.m",  (uint64_t)"GTMTLReplayHost_computeDerivedCountersFromData",  59,  2);

    __int128 v143 = &__NSDictionary0__struct;
  }

  return v143;
}

void LogException(const OpaqueJSContext *a1, const OpaqueJSValue *a2)
{
  if (a2)
  {
    BOOL v2 = JSValueToStringCopy(a1, a2, 0LL);
    JSStringGetMaximumUTF8CStringSize(v2);
    __chkstk_darwin();
    id v4 = (char *)&v7 - v3;
    JSStringGetUTF8CString(v2, (char *)&v7 - v3, v5);
    JSStringRelease(v2);
    uint64_t v6 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v4);
    NSLog(@"[DYJSScripting] %@", v6);
  }

void sub_167A74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_167BA8(_Unwind_Exception *a1)
{
}

void sub_167DC4(_Unwind_Exception *a1)
{
}

void sub_167EF4(_Unwind_Exception *a1)
{
}

void sub_16806C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

id GTMTLReplayClient_loadDerivedCounterInfo(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  size_t v5 = objc_alloc(&OBJC_CLASS___NSURL);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 stringByAppendingString:@"-counters.plist"]);

  uint64_t v7 = -[NSURL initFileURLWithPath:isDirectory:](v5, "initFileURLWithPath:isDirectory:", v6, 0LL);
  __int128 v8 = -[NSDictionary initWithContentsOfURL:error:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithContentsOfURL:error:",  v7,  0LL);
  if (v8)
  {
    id v9 = objc_alloc(&OBJC_CLASS___NSString);
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 stringByAppendingString:@"-derived.js"]);
    id v11 = -[NSString initWithContentsOfFile:encoding:error:]( v9,  "initWithContentsOfFile:encoding:error:",  v10,  4LL,  0LL);

    id v12 = objc_alloc(&OBJC_CLASS___NSString);
    char v13 = (void *)objc_claimAutoreleasedReturnValue([v3 stringByAppendingString:@"-analysis.js"]);
    uint64_t v14 = -[NSString initWithContentsOfFile:encoding:error:]( v12,  "initWithContentsOfFile:encoding:error:",  v13,  4LL,  0LL);

    v18[0] = @"DerivedCounterDictionary";
    v18[1] = @"DerivedCounterScript";
    v19[0] = v8;
    v19[1] = v11;
    void v18[2] = @"DerivedCounterAnalysis";
    __int128 v15 = &stru_591D98;
    if (v14) {
      __int128 v15 = v14;
    }
    v19[2] = v15;
    unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v19,  v18,  3LL));
  }

  else
  {
    unint64_t v16 = 0LL;
  }

  return v16;
}

id GTMTLReplayClient_mergeDerivedCounterInfo(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 mutableCopy];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    verifyCounterDictionary(v7);
    id v8 = MergeDictionaries(v7, v6);
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    [v5 setObject:v9 forKeyedSubscript:@"DerivedCounterDictionary"];
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"DerivedCounterScript"]);
  if (v10)
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"DerivedCounterScript"]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 stringByAppendingString:v10]);
    [v5 setObject:v12 forKeyedSubscript:@"DerivedCounterScript"];
  }

  char v13 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"DerivedCounterAnalysis"]);
  if (v13)
  {
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"DerivedCounterAnalysis"]);
    __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v14 stringByAppendingString:v13]);
    [v5 setObject:v15 forKeyedSubscript:@"DerivedCounterAnalysis"];
  }

  id v16 = [v5 copy];

  return v16;
}

uint64_t verifyCounterDictionary(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:@"DerivedCounters"]);

  if (v2)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:@"DerivedCounters"]);
    id v4 = [v3 count];

    if (v4)
    {
      uint64_t v5 = 1LL;
      goto LABEL_10;
    }

    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No derived counters in plist"));
    uint64_t v7 = 982LL;
  }

  else
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ missing in plist",  @"DerivedCounters"));
    uint64_t v7 = 977LL;
  }

  id v8 = __stdoutp;
  if (g_runningInCI) {
    id v9 = "#CI_ERROR# ";
  }
  else {
    id v9 = "";
  }
  id v10 = v6;
  fprintf( v8,  "%s%s %u: %s\n",  v9,  "_Bool verifyCounterDictionary(NSDictionary *__strong)",  v7,  (const char *)[v10 UTF8String]);
  id v11 = v10;
  GTMTLReplay_handleError( 101,  (uint64_t)[v11 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"verifyCounterDictionary",  v7,  1);

  uint64_t v5 = 0LL;
LABEL_10:

  return v5;
}

id MergeDictionaries(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472LL;
  id v11 = __MergeDictionaries_block_invoke;
  id v12 = &unk_58F6E8;
  id v13 = v3;
  uint64_t v14 = -[NSMutableDictionary initWithDictionary:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithDictionary:",  v3);
  uint64_t v5 = v14;
  id v6 = v3;
  [v4 enumerateKeysAndObjectsUsingBlock:&v9];

  id v7 = -[NSMutableDictionary copy](v5, "copy", v9, v10, v11, v12);
  return v7;
}

void __MergeDictionaries_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v14 = a2;
  id v5 = a3;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v14]);
  if (!v7) {
    goto LABEL_7;
  }
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSDictionary, v6);
  if ((objc_opt_isKindOfClass(v7, v8) & 1) == 0)
  {
    uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSArray, v9);
    if ((objc_opt_isKindOfClass(v7, v12) & 1) != 0)
    {
      uint64_t v11 = objc_claimAutoreleasedReturnValue([v7 arrayByAddingObjectsFromArray:v5]);
      goto LABEL_6;
    }

void __debugDumpCounterDictionary_block_invoke(id a1, NSString *a2, NSDictionary *a3, BOOL *a4)
{
  if (g_runningInCI)
  {
    id v5 = a2;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](a3, "objectForKeyedSubscript:", @"counters"));
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 componentsJoinedByString:@","]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Counter %@:%@",  v5,  v7));

    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( [v8 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);
    uint64_t v10 = __stdoutp;
    id v11 = v9;
    fprintf(v10, "#CI-INFO# %s\n", (const char *)[v11 UTF8String]);
  }

id DYMTLReplayFrameProfiler_loadAnalysis(void *a1)
{
  id v1 = DEVICEOBJECT(a1);
  unint64_t v130 = (void *)objc_claimAutoreleasedReturnValue(v1);
  io_registry_entry_t v2 = [v130 acceleratorPort];
  CFProperty = (void *)IORegistryEntryCreateCFProperty(v2, @"GPUConfigurationVariable", 0LL, 0);
  if (g_runningInCI)
  {
    id v4 = CFProperty;
    id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Configuration Variables=%@",  CFProperty));
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( [v5 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    id v7 = __stdoutp;
    id v8 = v6;
    fprintf(v7, "#CI-INFO# %s\n", (const char *)[v8 UTF8String]);

    CFProperty = v4;
  }

  CFTypeRef v9 = IORegistryEntryCreateCFProperty(v2, @"MetalStatisticsName", 0LL, 0);
  unint64_t v129 = CFProperty;
  if (!v9)
  {
    if (CFProperty)
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue([CFProperty objectForKeyedSubscript:@"gpu_gen"]);
      id v15 = [v14 unsignedIntValue];

      id v16 = (void *)objc_claimAutoreleasedReturnValue([v129 objectForKeyedSubscript:@"num_cores"]);
      unsigned int v17 = [v16 unsignedIntValue];

      char v18 = (void *)objc_claimAutoreleasedReturnValue([v129 objectForKeyedSubscript:@"num_mgpus"]);
      unsigned int v19 = [v18 unsignedIntValue];

      id v20 = (void *)objc_claimAutoreleasedReturnValue([v129 objectForKeyedSubscript:@"usc_gen"]);
      uint64_t v21 = v20;
      if (v20 && [v20 unsignedIntValue] > 2)
      {

        goto LABEL_18;
      }

      if (v15 < 0xE)
      {
        id v13 = 0LL;
      }

      else
      {
        id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableString stringWithFormat:]( &OBJC_CLASS___NSMutableString,  "stringWithFormat:",  @"AGXMetalStatisticsG%u",  v15));
        id v32 = v31;
        id v33 = @"D";
        id v34 = @"P";
        if (v17 > 6) {
          id v34 = @"G";
        }
        if (v19 == 4) {
          id v34 = @"C";
        }
        if (v19 != 8) {
          id v33 = v34;
        }
        if (v19 == 2) {
          id v35 = @"S";
        }
        else {
          id v35 = v33;
        }
        [v31 appendString:v35];
        id v13 = [v32 copy];
      }
    }

    else
    {
      id v13 = 0LL;
    }

NSString *AddShaderBinary(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = objc_alloc(&OBJC_CLASS___NSString);
  uLong v6 = crc32(0LL, 0LL, 0);
  id v7 = v4;
  id v8 = -[NSString initWithFormat:]( v5,  "initWithFormat:",  @"%0.8x",  crc32(v6, (const Bytef *)[v7 bytes], (uInt)objc_msgSend(v7, "length")));
  if (v7)
  {
    CFTypeID v11 = @"binary";
    id v12 = v7;
    CFTypeRef v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v12,  &v11,  1LL));
    [v3 setObject:v9 forKeyedSubscript:v8];
  }

  else
  {
    [v3 setObject:&__NSDictionary0__struct forKeyedSubscript:v8];
  }

  return v8;
}

id GTMTLReplayClient_collectPipelinePerformanceStatistics(uint64_t a1, uint64_t a2)
{
  p = **(apr_pool_t ***)(a1 + 152);
  uint64_t v3 = *(void *)a1;
  uint64_t v61 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, a2);
  id v60 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v4);
  uint64_t v6 = objc_opt_new(&OBJC_CLASS___NSMutableSet, v5);
  id v7 = (void *)v6;
  id v8 = (unsigned int *)(a1 + 22480);
  if (*(_DWORD *)(a1 + 22480) < *(_DWORD *)(*(void *)(v3 + 120) + 12LL))
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = (uint64_t *)(a1 + 19912);
    uint64_t v62 = (void *)v6;
    do
    {
      CFTypeID v11 = v10;
      id context = objc_autoreleasePoolPush();
      uint64_t v12 = *(void *)(*(void *)(v3 + 120) + 24LL) + ((unint64_t)*v8 << 6);
      id v13 = (int *)(v12 + 8);
      GTMTLReplayController_updateCommandEncoder(a1, v12);
      GTMTLReplayController_defaultDispatchFunction(a1, v12);
      unint64_t v14 = *v8;
      unint64_t v15 = *(void *)(v3 + 96);
      BOOL v16 = v15 <= v14 && *(void *)(v3 + 104) + v15 > v14;
      if (v16
        && ((int v17 = *v13, (IsFuncEnumDrawCall(*v13) & 1) != 0)
         || ((v17 + 16079) >= 2 ? (BOOL v18 = v17 == -16220) : (BOOL v18 = 1),
             !v18 ? (BOOL v19 = v17 == -16327) : (BOOL v19 = 1),
             v19)))
      {
        int v20 = *(_DWORD *)(a1 + 11312);
        if (v20 == 28)
        {
          uint64_t v28 = objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 11376)));
          unsigned int v63 = v9 + 1;
          id v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v9));
          v69[0] = v29;
          v69[1] = v28;
          id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v69, 2LL));
          [v61 addObject:v30];

          id v7 = v62;
          unint64_t v64 = (void *)v28;
          if ([v62 containsObject:v28])
          {
            uint64_t v10 = v11;
          }

          else
          {
            [v62 addObject:v28];
            uint64_t v31 = GTMTLSMContext_getObject(**(void **)(v3 + 40), *(void *)(a1 + 11376), *(void *)v12)[8];
            uint64_t v25 = (uint64_t *)(v31 + 56);
            id v26 = (uint64_t *)(v31 + 64);
            id v27 = (uint64_t *)(a1 + 11376);
            uint64_t v10 = v11;
LABEL_26:
            uint64_t v32 = *v27;
            uint64_t v33 = *v25;
            uint64_t v34 = *v26;
            id v35 = v60;
            if (v33)
            {
              uint64_t v57 = v32;
              id v59 = v35;
              uint64_t v36 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytesNoCopy:length:freeWhenDone:",  v33,  v34,  0LL);
              uint64_t v38 = objc_opt_class(&OBJC_CLASS___NSDictionary, v37);
              uint64_t v40 = objc_opt_class(&OBJC_CLASS___NSNumber, v39);
              uint64_t v42 = objc_opt_class(&OBJC_CLASS___NSArray, v41);
              uint64_t v44 = objc_opt_class(&OBJC_CLASS___NSNull, v43);
              uint64_t v56 = v42;
              uint64_t v46 = v36;
              uint64_t v47 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v38,  v40,  v56,  v44,  objc_opt_class(&OBJC_CLASS___NSString, v45),  0LL);
              unint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
              id v66 = 0LL;
              uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v48,  v36,  &v66));
              id v50 = v66;

              if (v49)
              {
                uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v57));
                v71[0] = v51;
                v71[1] = v49;
                uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v71,  2LL));
                [v59 addObject:v52];
              }

              uint64_t v10 = v11;
              id v35 = v59;
            }

            apr_pool_clear(p);
            id v7 = v62;
          }

void validateSubdividedCounterLists(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (g_runningValidationCI)
  {
    uint64_t v5 = &CATransform3DIdentity_ptr;
    if (g_runningInCI)
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Required counters: %@, divided list: %@",  v3,  v4));
      id v7 = (void *)objc_claimAutoreleasedReturnValue( [v6 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

      id v8 = __stdoutp;
      id v9 = v7;
      fprintf(v8, "#CI-INFO# %s\n", (const char *)[v9 UTF8String]);
    }

    uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    id v29 = v4;
    id v11 = v4;
    id v12 = [v11 countByEnumeratingWithState:&v35 objects:v40 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v36;
      do
      {
        for (unint64_t i = 0LL; i != v13; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v14) {
            objc_enumerationMutation(v11);
          }
          -[NSMutableSet addObjectsFromArray:]( v10,  "addObjectsFromArray:",  *(void *)(*((void *)&v35 + 1) + 8LL * (void)i));
        }

        id v13 = [v11 countByEnumeratingWithState:&v35 objects:v40 count:16];
      }

      while (v13);
    }

    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    id v30 = v3;
    id v16 = v3;
    id v17 = [v16 countByEnumeratingWithState:&v31 objects:v39 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v32;
      do
      {
        for (unint64_t j = 0LL; j != v18; unint64_t j = (char *)j + 1)
        {
          if (*(void *)v32 != v19) {
            objc_enumerationMutation(v16);
          }
          uint64_t v21 = *(void *)(*((void *)&v31 + 1) + 8LL * (void)j);
          if ((-[NSMutableSet containsObject:](v10, "containsObject:", v21) & 1) == 0)
          {
            id v22 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D stringWithFormat:]( (id)v5[288],  "stringWithFormat:",  @"Counter %@ missing from subdivided counter list",  v21));
            id v23 = __stdoutp;
            uint64_t v24 = v5;
            if (g_runningInCI) {
              uint64_t v25 = "#CI_ERROR# ";
            }
            else {
              uint64_t v25 = "";
            }
            id v26 = v22;
            uint64_t v28 = v25;
            uint64_t v5 = v24;
            fprintf( v23,  "%s%s %u: %s\n",  v28,  "void validateSubdividedCounterLists(NSArray *__strong, NSArray *__strong)",  1531,  (const char *)[v26 UTF8String]);
            id v27 = v26;
            GTMTLReplay_handleError( 101,  (uint64_t)[v27 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"validateSubdividedCounterLists",  1531,  1);
          }
        }

        id v18 = [v16 countByEnumeratingWithState:&v31 objects:v39 count:16];
      }

      while (v18);
    }

    id v4 = v29;
    id v3 = v30;
  }
}

NSMutableDictionary *GTMTLReplayClient_queryShaderInfo(uint64_t a1, id *a2, void *a3)
{
  id v40 = a3;
  uint64_t v41 = objc_alloc_init(&OBJC_CLASS___NSOperation);
  v82[0] = @"MTLStatCommandBufferIndex";
  v82[1] = @"MTLStatEncoderIndex";
  void v82[2] = @"MTLStatCommandIndex";
  v82[3] = @"MTLStat_nSec";
  v82[4] = @"MTLStatVertexCost";
  v82[5] = @"MTLStatFragmentCost";
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v82, 6LL));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"GPUState"]);
  id v7 = objc_autoreleasePoolPush();
  if (v6)
  {
    id v8 = objc_alloc(&OBJC_CLASS___GTPMController);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) defaultDevice]);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 name]);
    id v11 = -[GTPMController initWithGPUFamily:](v8, "initWithGPUFamily:", v10);
  }

  else
  {
    id v11 = 0LL;
  }

  objc_autoreleasePoolPop(v7);
  uint64_t v74 = 0LL;
  id v75 = (double *)&v74;
  uint64_t v76 = 0x2020000000LL;
  unint64_t v77 = 0xBFF0000000000000LL;
  uint64_t v68 = 0LL;
  BOOL v69 = &v68;
  uint64_t v70 = 0x3032000000LL;
  double v71 = __Block_byref_object_copy__6463;
  __int128 v72 = __Block_byref_object_dispose__6464;
  id v73 = 0LL;
  id v12 = objc_alloc_init(&OBJC_CLASS___NSOperation);
  id v13 = *a2;
  v60[0] = _NSConcreteStackBlock;
  v60[1] = 3221225472LL;
  v60[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke;
  void v60[3] = &unk_58F670;
  id v14 = v6;
  id v61 = v14;
  unint64_t v15 = v11;
  uint64_t v62 = v15;
  uint64_t v66 = a1;
  id v39 = v5;
  id v63 = v39;
  id v65 = &v68;
  id v16 = v12;
  unint64_t v64 = v16;
  id v67 = a2;
  [v13 addOperationWithBlock:v60];
  -[NSOperation addDependency:](v41, "addDependency:", v16);

  uint64_t v54 = 0LL;
  uint64_t v55 = &v54;
  uint64_t v56 = 0x3032000000LL;
  uint64_t v57 = __Block_byref_object_copy__6463;
  id v58 = __Block_byref_object_dispose__6464;
  id v59 = 0LL;
  v53[0] = _NSConcreteStackBlock;
  v53[1] = 3221225472LL;
  v53[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke_2;
  void v53[3] = &unk_58F698;
  v53[4] = &v54;
  v53[5] = a1;
  id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v53));
  [v17 setQueuePriority:-8];
  [*a2 addOperation:v17];
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3221225472LL;
  uint64_t v49[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke_3;
  v49[3] = &unk_58F6C0;
  id v18 = v14;
  id v50 = v18;
  uint64_t v52 = &v74;
  uint64_t v19 = v15;
  uint64_t v51 = v19;
  int v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v49));
  [v20 addDependency:v17];
  [a2[1] addOperation:v20];
  -[NSOperation addDependency:](v41, "addDependency:", v20);

  uint64_t v43 = 0LL;
  uint64_t v44 = &v43;
  uint64_t v45 = 0x3032000000LL;
  uint64_t v46 = __Block_byref_object_copy__6463;
  uint64_t v47 = __Block_byref_object_dispose__6464;
  id v48 = 0LL;
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472LL;
  v42[2] = __GTMTLReplayClient_queryShaderInfo_block_invoke_4;
  v42[3] = &unk_58F698;
  v42[4] = &v43;
  v42[5] = a1;
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v42));
  [a2[1] addOperation:v21];
  -[NSOperation addDependency:](v41, "addDependency:", v21);

  [a2[1] addOperation:v41];
  -[NSOperation waitUntilFinished](v41, "waitUntilFinished");
  if (v19) {
    -[GTPMController tearDown](v19, "tearDown");
  }
  id v22 = (void *)objc_claimAutoreleasedReturnValue([(id)v55[5] objectForKeyedSubscript:@"frametime"]);
  id v23 = (void *)objc_claimAutoreleasedReturnValue([(id)v44[5] objectForKeyedSubscript:@"MetalPluginName"]);
  uint64_t v25 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v24);
  id v26 = v25;
  if (v6)
  {
    id v27 = (void *)objc_claimAutoreleasedReturnValue( +[GTPMController stateFromWeightedAverage:]( &OBJC_CLASS___GTPMController,  "stateFromWeightedAverage:",  v75[3]));
    if (v75[3] <= -2.22044605e-16) {
      uint64_t v28 = &__kCFBooleanFalse;
    }
    else {
      uint64_t v28 = &__kCFBooleanTrue;
    }
    [v26 setObject:v28 forKeyedSubscript:@"enabled"];
    else {
      uint64_t v29 = [v27 isEqualToString:@"none"] ^ 1;
    }
    id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v29));
    [v26 setObject:v30 forKeyedSubscript:@"consistent"];

    [v26 setObject:v18 forKeyedSubscript:@"level"];
  }

  else
  {
    [v25 setObject:&__kCFBooleanFalse forKeyedSubscript:@"enabled"];
  }

  __int128 v31 = objc_alloc(&OBJC_CLASS___NSMutableDictionary);
  v78[0] = @"frame counters";
  v78[1] = @"frame profile data";
  uint64_t v32 = v69[5];
  v79[0] = v39;
  v79[1] = v32;
  v80[0] = @"frameProfile";
  __int128 v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v79,  v78,  2LL));
  v81[0] = v33;
  v81[1] = v22;
  v80[1] = @"frametime";
  id v80[2] = @"Frame Consistent Perf Info";
  uint64_t v34 = v44[5];
  void v81[2] = v26;
  v81[3] = v34;
  void v80[3] = @"derivedCounterData";
  void v80[4] = @"BatchingFilteringAvailable";
  v81[4] = &__kCFBooleanFalse;
  __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v81,  v80,  5LL));
  __int128 v36 = -[NSMutableDictionary initWithDictionary:](v31, "initWithDictionary:", v35);

  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([(id)v55[5] objectForKeyedSubscript:@"frameGPUTime"]);
  if (v37) {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v36, "setObject:forKeyedSubscript:", v37, @"frameGPUTime");
  }
  if (v23) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v36,  "setObject:forKeyedSubscript:",  v23,  @"MetalPluginName");
  }
  -[NSMutableDictionary addEntriesFromDictionary:](v36, "addEntriesFromDictionary:", &__NSDictionary0__struct);
  -[NSMutableDictionary addEntriesFromDictionary:](v36, "addEntriesFromDictionary:", &__NSDictionary0__struct);

  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v54, 8);

  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(&v74, 8);

  return v36;
}

void sub_16ABD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

uint64_t __Block_byref_object_copy__6463(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__6464(uint64_t a1)
{
}

void sub_16B6F4(_Unwind_Exception *a1)
{
}

void __performFrameTimingDesktop_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 GPUStartTime];
  **(void **)(a1 + 32) = v4;
  [v3 GPUEndTime];
  uint64_t v6 = v5;

  *(void *)(*(void *)(a1 + 32) + 8LL) = v6;
}

uint64_t CommandBufferTimeInfo_compare(double *a1, double *a2)
{
  if (*a1 == *a2)
  {
    double v3 = a1[1];
    double v4 = a2[1];
    if (v3 < v4) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v3 != v4;
    }
  }

  else if (*a1 >= *a2)
  {
    return 1LL;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }

int64_t __performFrameTimingDesktop_block_invoke_321(id a1, NSNumber *a2, NSNumber *a3)
{
  return -[NSNumber compare:](a2, "compare:", a3);
}

id CollectFrameCounters(uint64_t a1, id *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v10 = a3;
  id v11 = a4;
  id v12 = a6;
  uint64_t v44 = a1;
  id v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) defaultCommandQueue]);
  id v14 = (char *)[v11 count];
  unint64_t v15 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v14);
  if (v14)
  {
    id v16 = v14;
    do
    {
      id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 0x10000LL));
      -[NSMutableArray addObject:](v15, "addObject:", v17);

      --v16;
    }

    while (v16);
  }

  id v18 = &CATransform3DIdentity_ptr;
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472LL;
  v63[2] = __CollectFrameCounters_block_invoke;
  v63[3] = &unk_58F710;
  id v39 = v12;
  id v64 = v39;
  id v41 = v10;
  id v65 = v41;
  id v19 = v11;
  id v66 = v19;
  int v20 = v15;
  id v67 = v20;
  uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](&OBJC_CLASS___NSBlockOperation, "blockOperationWithBlock:", v63));
  id v22 = (void *)v21;
  if (v14)
  {
    id v23 = 0LL;
    id v42 = v19;
    uint64_t v43 = (void *)v21;
    do
    {
      uint64_t v24 = (os_log_s *)g_signpostLog;
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v20, "objectAtIndexedSubscript:", v23, v39, v41));
      os_signpost_id_t v26 = os_signpost_id_make_with_pointer(v24, v25);

      id v27 = (CATransform3D *)v18[256];
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 3221225472LL;
      v57[2] = __CollectFrameCounters_block_invoke_311;
      v57[3] = &unk_58F738;
      os_signpost_id_t v60 = v26;
      id v61 = v23;
      uint64_t v62 = v14;
      uint64_t v28 = v20;
      id v58 = v28;
      id v29 = v19;
      id v30 = v20;
      __int128 v31 = v13;
      id v32 = v29;
      id v59 = v29;
      __int128 v33 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D blockOperationWithBlock:](v27, "blockOperationWithBlock:", v57));
      [v22 addDependency:v33];
      v46[0] = _NSConcreteStackBlock;
      v46[1] = 3221225472LL;
      v46[2] = __CollectFrameCounters_block_invoke_312;
      v46[3] = &unk_58F788;
      id v34 = v32;
      id v13 = v31;
      int v20 = v30;
      id v47 = v34;
      uint64_t v51 = v23;
      uint64_t v52 = a5;
      os_signpost_id_t v53 = v26;
      uint64_t v54 = v14;
      uint64_t v55 = v44;
      id v48 = v28;
      id v35 = v13;
      uint64_t v56 = a2;
      id v49 = v35;
      id v50 = v33;
      id v36 = v33;
      id v19 = v42;
      id v22 = v43;
      __int128 v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v46));
      [v37 setQueuePriority:-8];
      [*a2 addOperation:v37];

      id v18 = &CATransform3DIdentity_ptr;
      ++v23;
    }

    while (v14 != v23);
  }

  objc_msgSend(a2[1], "addOperation:", v22, v39);

  return v22;
}

void __ProfileFrame_block_invoke(uint64_t a1)
{
  os_signpost_id_t v2 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, *(const void **)(a1 + 32));
  double v3 = g_signpostLog;
  double v4 = (os_log_s *)v3;
  unint64_t v44 = v2 - 1;
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v3))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v4,  OS_SIGNPOST_INTERVAL_BEGIN,  v2,  "Replayer-4-parallel",  "ProcessFrameData",  buf,  2u);
  }

  os_signpost_id_t spid = v2;

  uint64_t v5 = *(void **)(a1 + 40);
  uint64_t v43 = *(void **)(a1 + 32);
  uint64_t v6 = *(void **)(a1 + 48);
  id v7 = [*(id *)(a1 + 56) count];
  id v8 = v5;
  id v9 = v6;
  id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  (unint64_t)[v8 length] >> 3));
  id v11 = v8;
  id v12 = [v11 bytes];
  id v13 = v11;
  id v14 = [v13 bytes];
  id v42 = v13;
  unint64_t v15 = (char *)[v13 length] + (void)v14;
  id v41 = v9;
  id v16 = (char *)[v41 bytes];
  unint64_t v47 = (unint64_t)v15;
  if (&v12[2 * (void)v7] <= (void *)v15)
  {
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v45 = 2LL * (void)v7;
    id v46 = v7;
    uint64_t v19 = 8LL * (void)v7;
    uint64_t v20 = -1LL;
    uint64_t v51 = 8LL * (void)v7;
    uint64_t v55 = v10;
    do
    {
      unint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      for (unint64_t i = v12;
            *(void *)((char *)i + v19) == *i && *(void *)((char *)i + v19 + 8) == i[1];
            unint64_t i = (void *)((char *)i + v19))
      {
        unint64_t v21 = *(void *)((char *)i + v19 + 24) + v21 - i[3];
        ++v22;
      }

      if (v20 == *v12) {
        uint64_t v25 = v18;
      }
      else {
        uint64_t v25 = 0LL;
      }
      if (v20 != *v12) {
        ++v17;
      }
      uint64_t v49 = *v12;
      uint64_t v50 = v17;
      id v48 = &v16[8 * (void)v7];
      if (v22)
      {
        uint64_t v26 = 0LL;
        double v27 = (double)v21;
        double v28 = (double)(unint64_t)(*(void *)&v16[8 * (void)v7 + 24] - *((void *)v16 + 3));
        uint64_t v52 = v17 - 1;
        uint64_t v53 = v25;
        uint64_t v54 = v22;
        do
        {
          id v29 = (void *)((char *)v12 + v19);
          double v30 = (double)(unint64_t)(*(void *)((char *)v12 + v19 + 24) - v12[3]) / v27 * v28;
          __int128 v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v52,  spid));
          *(void *)__int128 buf = v31;
          id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v25));
          uint64_t v57 = v32;
          __int128 v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v26));
          id v58 = v33;
          id v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)v30));
          id v59 = v34;
          id v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v29[4]));
          os_signpost_id_t v60 = v35;
          id v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v29[5]));
          id v61 = v36;
          __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", buf, 6LL));
          [v55 addObjectsFromArray:v37];

          uint64_t v25 = v53;
          uint64_t v19 = v51;
          ++v26;
          id v12 = v29;
        }

        while (v54 != v26);
      }

      else
      {
        id v29 = v12;
      }

      id v7 = v46;
      id v16 = &v48[8 * (void)v46];
      uint64_t v18 = v25 + 1;
      id v12 = &v29[(void)v46];
      uint64_t v20 = v49;
      uint64_t v17 = v50;
      id v10 = v55;
    }

    while ((unint64_t)&v12[v45] <= v47);
  }

  [v43 setArray:v10];
  __int128 v38 = g_signpostLog;
  id v39 = (os_log_s *)v38;
  if (v44 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v38))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v39,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-4-parallel",  (const char *)&unk_3189BB,  buf,  2u);
  }
}

void __CollectFrameCounters_block_invoke(uint64_t a1)
{
  os_signpost_id_t v2 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, *(const void **)(a1 + 32));
  double v3 = g_signpostLog;
  double v4 = (os_log_s *)v3;
  unint64_t v5 = v2 - 1;
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v3))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v4,  OS_SIGNPOST_INTERVAL_BEGIN,  v2,  "Replayer-4-parallel",  "MergeCounterData",  buf,  2u);
  }

  id v7 = *(void **)(a1 + 32);
  uint64_t v6 = *(void **)(a1 + 40);
  id v9 = *(void **)(a1 + 48);
  id v8 = *(void **)(a1 + 56);
  id v10 = v6;
  id v11 = v9;
  id v45 = v8;
  unint64_t v44 = (char *)[v11 count];
  if (v44 == (_BYTE *)&dword_0 + 1
    && (id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:0]),
        unsigned int v13 = [v12 isEqualToArray:v10],
        v12,
        v13))
  {
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:0]);

    unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v45 objectAtIndexedSubscript:0]);
  }

  else
  {
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v45 objectAtIndexedSubscript:0]);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:0]);
    unint64_t v18 = (unint64_t)[v16 length];
    unint64_t v41 = 8 * (void)[v17 count];
    unint64_t v42 = v18;
    unint64_t v19 = v18 / v41;

    id v20 = [v10 count];
    uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", 8 * v19 * (void)v20));
    unint64_t v15 = (void *)v21;
    if (v44)
    {
      id v40 = (id)v21;
      uint64_t v43 = v11;
      id v36 = v7;
      unint64_t v37 = v2 - 1;
      os_signpost_id_t v38 = v2;
      uint64_t v22 = 0LL;
      if (v19 <= 1) {
        uint64_t v23 = 1LL;
      }
      else {
        uint64_t v23 = v19;
      }
      do
      {
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "objectAtIndexedSubscript:", v22, v36, v37, v38));
        id v25 = [v24 count];
        if (v25)
        {
          for (unint64_t i = 0LL; i != v25; unint64_t i = (char *)i + 1)
          {
            double v27 = (void *)objc_claimAutoreleasedReturnValue([v24 objectAtIndexedSubscript:i]);
            *(void *)&buf[8 * (void)i] = [v10 indexOfObject:v27];
          }
        }

        id v28 = objc_claimAutoreleasedReturnValue([v45 objectAtIndexedSubscript:v22]);
        id v29 = (char *)[v28 bytes];
        id v39 = v40;
        double v30 = (char *)[v39 mutableBytes];
        if (v41 <= v42)
        {
          for (uint64_t j = 0LL; j != v23; ++j)
          {
            if (v25)
            {
              for (unint64_t k = 0LL; k != v25; unint64_t k = (char *)k + 1)
              {
                uint64_t v33 = *(void *)&buf[8 * (void)k];
                if (v33 != 0x7FFFFFFFFFFFFFFFLL) {
                  *(void *)&v30[8 * v33] = *(void *)&v29[8 * (void)k];
                }
              }
            }

            v30 += 8 * (void)v20;
            v29 += 8 * (void)v25;
          }
        }

        ++v22;
      }

      while (v22 != v44);
      os_signpost_id_t v2 = v38;
      unint64_t v15 = v39;
      id v7 = v36;
      unint64_t v5 = v37;
      id v11 = v43;
    }
  }

  [v7 setData:v15];
  id v34 = g_signpostLog;
  id v35 = (os_log_s *)v34;
  if (v5 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v34))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v35,  OS_SIGNPOST_INTERVAL_END,  v2,  "Replayer-4-parallel",  (const char *)&unk_3189BB,  buf,  2u);
  }
}

void __CollectFrameCounters_block_invoke_311(uint64_t a1)
{
  os_signpost_id_t v2 = g_signpostLog;
  double v3 = (os_log_s *)v2;
  os_signpost_id_t v4 = *(void *)(a1 + 48);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v2))
  {
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v6 = *(void *)(a1 + 64);
    int v17 = 134218240;
    uint64_t v18 = v5;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    _os_signpost_emit_with_name_impl( &dword_0,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Replayer-4-parallel",  "SortCounterData %lu/%lu",  (uint8_t *)&v17,  0x16u);
  }

  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 56)]);
  id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectAtIndexedSubscript:*(void *)(a1 + 56)]);
  size_t v9 = 8 * (void)[v8 count];
  id v10 = v7;
  size_t v11 = (unint64_t)[v10 length] / v9;
  id v12 = v10;
  id v13 = [v12 mutableBytes];

  qsort(v13, v11, v9, (int (__cdecl *)(const void *, const void *))compareSampleData);
  id v14 = g_signpostLog;
  unint64_t v15 = (os_log_s *)v14;
  os_signpost_id_t v16 = *(void *)(a1 + 48);
  if (v16 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v14))
  {
    LOWORD(v17) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v15,  OS_SIGNPOST_INTERVAL_END,  v16,  "Replayer-4-parallel",  (const char *)&unk_3189BB,  (uint8_t *)&v17,  2u);
  }
}

id __CollectFrameCounters_block_invoke_312(uint64_t a1)
{
  id v1 = (void *)g_activityLog;
  os_signpost_id_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 64)]);
  [v1 enterCollectCounters:v2 statLocations:*(void *)(a1 + 72) withIndex:*(void *)(a1 + 64)];

  double v3 = g_signpostLog;
  os_signpost_id_t v4 = (os_log_s *)v3;
  os_signpost_id_t v5 = *(void *)(a1 + 80);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v3))
  {
    uint64_t v6 = *(void *)(a1 + 64);
    uint64_t v7 = *(void *)(a1 + 88);
    v83[0] = 134218240;
    *(void *)&v83[1] = v6;
    LOWORD(v83[3]) = 2048;
    *(void *)((char *)&v83[3] + 2) = v7;
    _os_signpost_emit_with_name_impl( &dword_0,  v4,  OS_SIGNPOST_INTERVAL_BEGIN,  v5,  "Replayer-1-serial",  "CollectCounterData %lu/%lu",  (uint8_t *)v83,  0x16u);
  }

  uint64_t v68 = *(_DWORD **)(a1 + 96);
  id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 64)]);
  size_t v9 = *(void **)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 64);
  uint64_t v59 = *(void *)(a1 + 72);
  id v61 = v8;
  id v60 = v9;
  GTMTLReplayController_prePlayForProfiling((uint64_t)v68);
  [v61 count];
  id v57 = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  size_t v11 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v68 + 1) defaultCommandQueue]);
  [v11 setStatEnabled:1];
  [v11 setStatOptions:1];
  [v11 setStatOptions:0x10000000];
  [v11 setGPUPriority:0];
  [v11 setStatLocations:v59];
  id v12 = [v11 requestCounters:v61 withIndex:v10];
  uint64_t v62 = v11;
  if ((_DWORD)v12)
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"CollectCounterData requestCounters on index %d failed with error %d",  v10,  v12));
    id v14 = __stdoutp;
    int v15 = g_runningInCI;
    id v16 = v13;
    int v17 = (const char *)[v16 UTF8String];
    uint64_t v18 = "#CI_ERROR# ";
    if (!v15) {
      uint64_t v18 = "";
    }
    fprintf( v14,  "%s%s %u: %s\n",  v18,  "void CollectCounterData(GTMTLReplayController *, NSArray *__strong, uint64_t, NSArray *__strong, NSUInteger)",  294,  v17);
    id v19 = v16;
    GTMTLReplay_handleError( 101,  (uint64_t)[v19 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_frameProfiler.m",  (uint64_t)"CollectCounterData",  294,  1);
  }

  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472LL;
  v72[2] = __CollectCounterData_block_invoke;
  v72[3] = &unk_58F7B0;
  id v73 = (id)objc_claimAutoreleasedReturnValue([v60 objectAtIndexedSubscript:v10]);
  id v20 = v73;
  [v62 addPerfSampleHandler:v72];

  uint64_t v21 = v68 + 5620;
  id v58 = *(uint64_t **)v68;
  unint64_t v67 = v58[13] + v58[12];
  if (v67 > v68[5620])
  {
    uint64_t v63 = 0LL;
    uint64_t v66 = v58[15];
    uint64_t v56 = (uint64_t)(v68 + 2842);
    do
    {
      uint64_t v22 = objc_autoreleasePoolPush();
      uint64_t v23 = *(void *)(v66 + 24);
      uint64_t v24 = *v21;
      uint64_t v25 = v23 + (v24 << 6);
      uint64_t v26 = (int *)(v25 + 8);
      GTMTLReplayController_updateCommandEncoder((uint64_t)v68, v23 + (v24 << 6));
      unsigned int v27 = *v26;
      if (v63)
      {
        if (IsFuncEnumCreateCommandEncoder(*v26))
        {
          __int128 v31 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v68 + 1) commandBufferForKey:v63]);
          [v31 commit];
          [v62 setStatLocations:v59];
          id v32 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v68 + 1) defaultCommandQueue]);
          uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v32 commandBuffer]);

          [*((id *)v68 + 1) setCommandBuffer:v33 forKey:v63];
          uint64_t v63 = 0LL;
          unsigned int v27 = *v26;
        }
      }

      else
      {
        uint64_t v63 = 0LL;
      }

      if (v27 == -15673)
      {
        id v34 = GTTraceFunc_argumentBytesWithMap( (void *)(v23 + (v24 << 6)),  *(unsigned __int8 *)(v23 + (v24 << 6) + 13),  v58[2]);
        id v35 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v68 + 1) commandBufferForKey:*(void *)v34]);
        [v35 commit];
        [v62 setStatLocations:0];
        id v36 = (void *)objc_claimAutoreleasedReturnValue([v62 commandBuffer]);

        [*((id *)v68 + 1) setCommandBuffer:v36 forKey:*(void *)v34];
        uint64_t v63 = *(void *)v34;
        unsigned int v27 = *v26;
      }

      if (v27 >> 2 == 1073737833)
      {
        uint64_t v37 = *(void *)v68;
        GetExecuteCommandsInBufferArgs((uint64_t)&v75, v23 + (v24 << 6), *(void *)(*(void *)v68 + 16LL));
        v84.locatiouint64_t n = 0LL;
        v84.NSUInteger length = -1LL;
        NSRange v38 = NSIntersectionRange(v84, range2);
        NSUInteger length = v38.length;
        if (v38.length)
        {
          p = (apr_pool_t *)**((void **)v68 + 19);
          GTMTLSMContext_indirectCommandBufferResources((uint64_t)v80, *(_DWORD ***)(v37 + 40), *(void *)v25, p);
          uint64_t Object = GTMTLSMContext_getObject(**(void **)(v37 + 40), v75, *(void *)v25);
          GTMTLCreateIndirectCommandEncoder((uint64_t)v78, Object[13]);
          memcpy(v83, v68 + 2828, 0x2B90uLL);
          id v65 = *((id *)v68 + 1);
          int v41 = v68[2828];
          if (v41 == 28)
          {
            if ((GT_SUPPORT_0 & 0x10) != 0)
            {
              unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v68 + 1) computeCommandEncoderForKey:*((void *)v68 + 1415)]);
              uint64_t v47 = v77;
              uint64_t v48 = v79;
              int64_t v49 = v38.location << 32;
              do
              {
                uint64_t v81 = v47 + v48 * (v49 >> 32);
                memcpy(__dst, &v83[14], 0x8D0uLL);
                if (GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)&v83[14], v78, v81, v80))
                {
                  GTMTLReplayController_restoreComputeCommandEncoder(v42, (uint64_t)__dst, (uint64_t)&v83[14], v65);
                  DYMTLDispatchComputeCommandEncoder(v42, (uint64_t)v78, v47 + v48 * (v49 >> 32));
                }

                v49 += 0x100000000LL;
                --length;
              }

              while (length);
              GTMTLReplayController_restoreComputeCommandEncoder(v42, (uint64_t)&v83[14], v56, v65);
LABEL_44:
            }
          }

          else if (v41 == 70)
          {
            unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v65 executeIndirectCommandBufferMap]);
            uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v68 + 1) renderCommandEncoderForKey:*((void *)v68 + 1415)]);
            uint64_t v44 = v77;
            uint64_t v45 = v79;
            int64_t v46 = v38.location << 32;
            do
            {
              uint64_t v81 = v44 + v45 * (v46 >> 32);
              memcpy(__dst, &v83[14], sizeof(__dst));
              if (GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)&v83[14], v78, v81, v80))
              {
                GTMTLReplayController_restoreRenderCommandEncoder(v43, (uint64_t)__dst, (uint64_t)&v83[14], v65);
                DYMTLDrawRenderCommandEncoder(v43, (uint64_t)v78, v44 + v45 * (v46 >> 32), (uint64_t)v80, v42);
              }

              v46 += 0x100000000LL;
              --length;
            }

            while (length);
            GTMTLReplayController_restoreRenderCommandEncoder(v43, (uint64_t)&v83[14], v56, v65);

            goto LABEL_44;
          }

          apr_pool_clear(p);
        }
      }

      else
      {
        GTMTLReplayController_defaultDispatchFunction((uint64_t)v68, v23 + (v24 << 6));
      }

void sub_16CE18(_Unwind_Exception *a1)
{
}

id *__CollectCounterData_block_invoke(id *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a4) {
      return (id *)objc_msgSend(result[4], "appendData:");
    }
  }

  return result;
}

id __CollectFrameCounters_block_invoke_315(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 40) + 8) addOperation:*(void *)(a1 + 32)];
}

uint64_t compareSampleData(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    unint64_t v3 = *(void *)(a1 + v2);
    unint64_t v4 = *(void *)(a2 + v2);
    if (v3 < v4) {
      return 0xFFFFFFFFLL;
    }
    if (v4 < v3) {
      break;
    }
    v2 += 8LL;
    if (v2 == 24) {
      return 0LL;
    }
  }

  return 1LL;
}

id GTMTLReplayClient_derivedCounterData(id *a1, id *a2, void *a3)
{
  id v30 = a3;
  id v4 = (id)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:@"profileCounters"]);
  v47[0] = @"MTLStatCommandBufferIndex";
  v47[1] = @"MTLStatEncoderIndex";
  v47[2] = @"MTLStatCommandIndex";
  _OWORD v47[3] = @"MTLStatDataMaster";
  v47[4] = @"MTLStatSampleLocation";
  v47[5] = @"MTLStatTotalGPUCycles";
  v47[6] = @"MTLStat_nSec";
  os_signpost_id_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v47, 7LL));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  (char *)[v5 count] + (void)objc_msgSend(v4, "count")));
  [v6 addObjectsFromArray:v5];
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  id v7 = v4;
  id v8 = [v7 countByEnumeratingWithState:&v33 objects:&v39 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v34;
    do
    {
      for (unint64_t i = 0LL; i != v8; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v34 != v9) {
          objc_enumerationMutation(v7);
        }
        uint64_t v11 = *(void *)(*((void *)&v33 + 1) + 8LL * (void)i);
      }

      id v8 = [v7 countByEnumeratingWithState:&v33 objects:&v39 count:16];
    }

    while (v8);
  }

  id v12 = v6;
  *(void *)&__int128 v33 = 0LL;
  *((void *)&v33 + 1) = &v33;
  *(void *)&__int128 v34 = 0x3032000000LL;
  *((void *)&v34 + 1) = __Block_byref_object_copy__6463;
  *(void *)&__int128 v35 = __Block_byref_object_dispose__6464;
  *((void *)&v35 + 1) = 0LL;
  id v39 = _NSConcreteStackBlock;
  uint64_t v40 = 3221225472LL;
  int v41 = __SubdivideCounterList_block_invoke;
  unint64_t v42 = &unk_58F838;
  uint64_t v44 = &v33;
  uint64_t v45 = (NSMutableData *)a1;
  id v13 = (NSMutableArray *)v12;
  uint64_t v43 = v13;
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v39));
  [v14 setQueuePriority:8];
  [*a2 addOperation:v14];
  [v14 waitUntilFinished];
  id v15 = *(id *)(*((void *)&v33 + 1) + 40LL);

  _Block_object_dispose(&v33, 8);
  __int128 v31 = objc_alloc_init(&OBJC_CLASS___NSOperation);
  id v16 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  int v17 = v13;
  uint64_t v18 = v16;
  id v19 = v15;
  id v20 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  id v21 = CollectFrameCounters((uint64_t)a1, a2, v17, v19, 63LL, v20);
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);

  id v39 = _NSConcreteStackBlock;
  uint64_t v40 = 3221225472LL;
  int v41 = __ProfileFrameWithCounterListsForProfileInfo_block_invoke;
  unint64_t v42 = &unk_58F860;
  uint64_t v43 = v18;
  uint64_t v44 = (__int128 *)v17;
  uint64_t v45 = v20;
  int64_t v46 = a1;
  uint64_t v23 = v18;
  uint64_t v24 = v17;
  uint64_t v25 = v20;
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v39));
  [v26 addDependency:v22];
  [a2[1] addOperation:v26];

  -[NSOperation addDependency:](v31, "addDependency:", v26);
  [a2[1] addOperation:v31];
  -[NSOperation waitUntilFinished](v31, "waitUntilFinished");
  v37[0] = @"numberOfPasses";
  unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v19 count]));
  v38[0] = v27;
  v38[1] = v19;
  v37[1] = @"counterLists";
  v37[2] = @"counters";
  v37[3] = @"AverageSamples";
  v38[2] = v24;
  v38[3] = v23;
  id v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v38,  v37,  4LL));

  return v28;
}

void sub_16D354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void __SubdivideCounterList_block_invoke(uint64_t a1)
{
  id v9 = (id)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 48) + 8) defaultCommandQueue]);
  if (g_runningInCI)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"SubdivideCounterList - subdividing counter list"));
    unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( [v2 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    id v4 = __stdoutp;
    id v5 = v3;
    fprintf(v4, "#CI-INFO# %s\n", (const char *)[v5 UTF8String]);
  }

  uint64_t v6 = objc_claimAutoreleasedReturnValue([v9 subdivideCounterList:*(void *)(a1 + 32)]);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  validateSubdividedCounterLists(*(void **)(a1 + 32), *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
}

void __ProfileFrameWithCounterListsForProfileInfo_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 56) + 8) defaultCommandQueue]);
  os_signpost_id_t v3 = os_signpost_id_make_with_pointer((os_log_t)g_signpostLog, *(const void **)(a1 + 32));
  id v4 = g_signpostLog;
  id v5 = (os_log_s *)v4;
  unint64_t v49 = v3 - 1;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v4))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v5,  OS_SIGNPOST_INTERVAL_BEGIN,  v3,  "Replayer-4-parallel",  "FormatSampleData",  buf,  2u);
  }

  os_signpost_id_t spid = v3;

  uint64_t v6 = *(void **)(a1 + 40);
  uint64_t v50 = v2;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v2 counterInfo]);
  id v8 = *(void **)(a1 + 48);
  id v9 = *(void **)(a1 + 32);
  id v10 = v6;
  id v11 = v7;
  id v12 = v10;
  id v13 = v11;
  id v14 = v8;
  id v52 = v9;
  unint64_t v15 = (unint64_t)[v12 count];
  id v16 = v14;
  unint64_t v17 = (unint64_t)[v14 length];
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  *(_OWORD *)__int128 buf = 0u;
  __int128 v58 = 0u;
  uint64_t v55 = v15;
  unint64_t v56 = v15;
  unint64_t v51 = v17 / (8 * v15);
  if (v15)
  {
    unint64_t v18 = 0LL;
    do
    {
      id v19 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v18]);
      id v20 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:v19]);
      id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"type"]);
      uint64_t v22 = (char *)[v21 unsignedIntegerValue];

      *(void *)&buf[(v18 >> 3) & 0x1FFFFFFFFFFFFFF8LL] |= (unint64_t)(v22 == (_BYTE *)&dword_0 + 1) << v18;
      unint64_t v15 = v56;
      ++v18;
    }

    while (v56 != v18);
  }

  uint64_t v48 = v13;
  id v23 = v16;
  uint64_t v24 = [v23 bytes];
  uint64_t v25 = v50;
  if (v51 >= 2)
  {
    uint64_t v26 = v24;
    id v46 = v23;
    unsigned int v27 = 0LL;
    id v28 = 0LL;
    unint64_t v29 = v15 - 3;
    uint64_t v30 = 1LL;
    __int128 v31 = &CATransform3DIdentity_ptr;
    while (1)
    {
      id v32 = v26;
      uint64_t v26 = (void *)((char *)v26 + v55 * 8);
      if (*v26 == *v32) {
        break;
      }

      id v28 = 0LL;
      unsigned int v27 = 0LL;
      if (v26[2]) {
        goto LABEL_16;
      }
LABEL_27:
      if (++v30 == v51)
      {

        uint64_t v25 = v50;
        id v23 = v46;
        goto LABEL_29;
      }
    }

    if (v26[1] != v32[1])
    {

      id v28 = 0LL;
    }

    if (!v26[2]) {
      goto LABEL_27;
    }
    if (!v27)
    {
LABEL_16:
      unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D array]((id)v31[273], "array"));
      [v52 addObject:v27];
    }

    uint64_t v53 = v26;
    if (!v28)
    {
      id v28 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D array]((id)v31[273], "array"));
      [v27 addObject:v28];
    }

    __int128 v33 = v28;
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D arrayWithCapacity:]((id)v31[273], "arrayWithCapacity:", v15));
    [v33 addObject:v34];
    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  (char *)[v52 count] - 1));
    [v34 addObject:v35];

    __int128 v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  (char *)[v27 count] - 1));
    [v34 addObject:v36];

    uint64_t v54 = v33;
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  (char *)[v33 count] - 1));
    [v34 addObject:v37];

    uint64_t v26 = v53;
    if (v15 >= 4)
    {
      uint64_t v38 = 0LL;
      do
      {
        unint64_t v39 = v32[v55 + 3 + v38];
        if (((*(void *)&buf[((unint64_t)(v38 + 3) >> 3) & 0x1FFFFFFFFFFFFFF8LL] >> (v38 + 3)) & 1) != 0)
        {
          unint64_t v40 = v32[v38 + 3];
          BOOL v41 = v39 >= v40;
          unint64_t v42 = v39 - v40;
          if (v41) {
            unint64_t v39 = v42;
          }
          else {
            unint64_t v39 = 0LL;
          }
        }

        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v39));
        [v34 addObject:v43];

        ++v38;
      }

      while (v29 != v38);
    }

    unint64_t v15 = v56;
    id v28 = v54;
    __int128 v31 = &CATransform3DIdentity_ptr;
    goto LABEL_27;
  }

id GTShaderDebuggerMakeError(unsigned int a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  id v12 = a2;
  id v13 = -[NSMutableDictionary initWithObjectsAndKeys:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithObjectsAndKeys:",  v12,  NSLocalizedDescriptionKey,  0LL);

  if (v9) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v13,  "setObject:forKeyedSubscript:",  v9,  NSLocalizedRecoverySuggestionErrorKey);
  }
  if (v10) {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v13, "setObject:forKeyedSubscript:", v10, NSUnderlyingErrorKey);
  }
  if (v11) {
    -[NSMutableDictionary setObject:forKeyedSubscript:](v13, "setObject:forKeyedSubscript:", v11, @"ErrorInfo");
  }
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"GTShaderDebuggerErrorDomain",  a1,  v13));

  return v14;
}

void GTShaderDebuggerContextDeinit(void *a1)
{
  if (*a1) {
    [*(id *)(*a1 + 8) commitCommandBuffers];
  }
  uint64_t v2 = (apr_pool_t *)a1[27];
  if (v2) {
    apr_pool_destroy(v2);
  }
  *a1 = 0LL;
  a1[27] = 0LL;
  os_signpost_id_t v3 = (void *)a1[24];
  a1[24] = 0LL;

  id v4 = (void *)a1[25];
  a1[25] = 0LL;

  a1[10] = 0LL;
  a1[11] = 0LL;
  id v5 = (void *)a1[1];
  a1[1] = 0LL;

  uint64_t v6 = (void *)a1[2];
  a1[2] = 0LL;

  uint64_t v7 = (void *)a1[3];
  a1[3] = 0LL;

  id v8 = (void *)a1[4];
  a1[4] = 0LL;

  id v9 = (void *)a1[5];
  a1[5] = 0LL;

  id v10 = (void *)a1[6];
  a1[6] = 0LL;

  id v11 = (void *)a1[7];
  a1[7] = 0LL;

  id v12 = (void *)a1[12];
  a1[12] = 0LL;

  id v13 = (void *)a1[13];
  a1[13] = 0LL;

  id v14 = (void *)a1[14];
  a1[14] = 0LL;

  unint64_t v15 = (void *)a1[15];
  a1[15] = 0LL;

  id v16 = (void *)a1[16];
  a1[16] = 0LL;

  unint64_t v17 = (void *)a1[17];
  a1[17] = 0LL;

  unint64_t v18 = (void *)a1[19];
  a1[19] = 0LL;

  id v19 = (void *)a1[21];
  a1[21] = 0LL;

  id v20 = (void *)a1[22];
  a1[22] = 0LL;

  id v21 = (void *)a1[23];
  a1[23] = 0LL;
}

id GTShaderDebuggerSanitizeResponse(void *a1, void *a2, _DWORD *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = v7;
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"ProtocolVersion"]);
  unsigned int v11 = [v10 intValue];

  BOOL v12 = v11 > 2 || v11 == 2;
  id v13 = v9;
  if (v12)
  {
    if (!a4) {
      goto LABEL_33;
    }
    goto LABEL_31;
  }

  id v72 = v8;
  id v73 = a4;
  id v71 = v9;
  id v14 = v9;
  BOOL v69 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"TraceData"]);
  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"TraceMetadata"]);
  id v70 = v14;
  unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"ResourceMapping"]);
  uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"Bytes"]);
  id v16 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"Buffers"]);
  id v65 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"Textures"]);
  id v64 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"Samplers"]);
  unint64_t v67 = v15;
  unint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"ConstantSamplers"]);
  unint64_t v18 = &CATransform3DIdentity_ptr;
  if (-[NSMutableDictionary count](v16, "count"))
  {
    int v19 = a3[5620];
    uint64_t v20 = *(void *)(*(void *)(*(void *)a3 + 120LL) + 24LL);
    id v21 = *(uint64_t **)(*(void *)a3 + 40LL);
    uint64_t v74 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    __int128 v81 = 0u;
    __int128 v82 = 0u;
    uint64_t v22 = v16;
    id v23 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v79,  v91,  16LL);
    if (v23)
    {
      id v24 = v23;
      uint64_t v25 = (unint64_t *)(v20 + ((unint64_t)(v19 - 1) << 6));
      uint64_t v26 = *(void *)v80;
      do
      {
        for (unint64_t i = 0LL; i != v24; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v80 != v26) {
            objc_enumerationMutation(v22);
          }
          id v28 = *(void **)(*((void *)&v79 + 1) + 8LL * (void)i);
          uint64_t Object = GTMTLSMContext_getObject(*v21, (uint64_t)[v28 unsignedLongLongValue], *v25);
          if (Object)
          {
            uint64_t v30 = Object;
            __int128 v31 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v22, "objectForKeyedSubscript:", v28));
            id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v30[14]));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v74, "setObject:forKeyedSubscript:", v31, v32);
          }
        }

        id v24 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v79,  v91,  16LL);
      }

      while (v24);
    }

    unint64_t v18 = &CATransform3DIdentity_ptr;
  }

  else
  {
    uint64_t v74 = v16;
  }

  if ([v17 count])
  {
    id v33 = objc_alloc_init((Class)v18[275]);
    __int128 v75 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    __int128 v78 = 0u;
    id v34 = v17;
    id v35 = [v34 countByEnumeratingWithState:&v75 objects:v90 count:16];
    if (v35)
    {
      id v36 = v35;
      uint64_t v37 = *(void *)v76;
      do
      {
        for (uint64_t j = 0LL; j != v36; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v76 != v37) {
            objc_enumerationMutation(v34);
          }
          uint64_t v39 = *(void *)(*((void *)&v75 + 1) + 8LL * (void)j);
          __int128 v88 = 0u;
          __int128 v89 = 0u;
          __int128 v86 = 0u;
          __int128 v87 = 0u;
          unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:v39]);
          BOOL v41 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"borderColor"]);
          BYTE2(v89) = [v41 unsignedCharValue];

          unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"compareFunction"]);
          BYTE3(v89) = [v42 unsignedCharValue];

          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"lodMinClamp"]);
          [v43 floatValue];
          HIDWORD(v8_Block_object_dispose(va, 8) = v44;

          uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"lodMaxClamp"]);
          [v45 floatValue];
          DWORD2(v8_Block_object_dispose(va, 8) = v46;

          uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"lodAverage"]);
          BYTE6(v89) = [v47 unsignedCharValue];

          uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"minFilter"]);
          BYTE8(v89) = [v48 unsignedCharValue];

          unint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"magFilter"]);
          BYTE7(v89) = [v49 unsignedCharValue];

          uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"mipFilter"]);
          BYTE9(v89) = [v50 unsignedCharValue];

          unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"maxAnisotropy"]);
          *((void *)&v86 + 1) = [v51 unsignedCharValue];

          id v52 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"normalizedCoordinates"]);
          BYTE10(v89) = [v52 unsignedCharValue];

          uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"pixelFormat"]);
          LOWORD(v89) = (unsigned __int16)[v53 unsignedShortValue];

          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"reductionMode"]);
          BYTE12(v89) = [v54 unsignedCharValue];

          uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"rAddressMode"]);
          BYTE11(v89) = [v55 unsignedCharValue];

          unint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"sAddressMode"]);
          BYTE13(v89) = [v56 unsignedCharValue];

          id v57 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:@"tAddressMode"]);
          HIBYTE(v89) = [v57 unsignedCharValue];

          unint64_t v58 = EncodeDYMTLSamplerDescriptor((uint64_t)&v86, 0LL, 0LL);
          __int128 v59 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", v58);
          EncodeDYMTLSamplerDescriptor((uint64_t)&v86, (uint64_t)-[NSMutableData mutableBytes](v59, "mutableBytes"), v58);
          id v60 = -[NSMutableData copy](v59, "copy");
          [v33 setObject:v60 forKeyedSubscript:v39];
        }

        id v36 = [v34 countByEnumeratingWithState:&v75 objects:v90 count:16];
      }

      while (v36);
    }
  }

  else
  {
    id v33 = v17;
  }

  v84[0] = @"DYMTLShaderDebuggerTrace";
  v84[1] = @"DYMTLShaderDebuggerMetadata";
  v85[0] = v69;
  v85[1] = v68;
  v84[2] = @"DYMTLShaderDebuggerResourceResolutionRemappingTables";
  v83[0] = @"DYMTLShaderDebuggerResourceResolutionRemappingTablesBytes";
  v83[1] = @"DYMTLShaderDebuggerResourceResolutionRemappingTablesTextures";
  *(void *)&__int128 v86 = v66;
  *((void *)&v86 + 1) = v65;
  v83[2] = @"DYMTLShaderDebuggerResourceResolutionRemappingTablesSamplers";
  v83[3] = @"DYMTLShaderDebuggerResourceResolutionRemappingTablesBuffers";
  *(void *)&__int128 v87 = v64;
  *((void *)&v87 + 1) = v74;
  v83[4] = @"DYMTLShaderDebuggerResourceResolutionRemappingTablesConstantSamplersReflection";
  *(void *)&__int128 v88 = v33;
  id v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v86,  v83,  5LL));
  void v85[2] = v61;
  id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v85,  v84,  3LL));

  id v8 = v72;
  a4 = v73;
  id v9 = v71;
  if (v73)
  {
LABEL_31:
    if (!v13)
    {
      id Error = GTShaderDebuggerMakeError(1u, @"Internal error: Unexpected response", 0LL, 0LL, 0LL);
      *a4 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }

uint64_t __GTShaderDebuggerMakeRuntimeLibrariesFromSources_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v5]);
  id v8 = (unsigned __int8 *)[v7 pointerValue];

  id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v6]);
  id v10 = (unsigned __int8 *)[v9 pointerValue];

  unsigned int v11 = v8[160];
  unsigned int v12 = v10[160];
  if (v11 == v12)
  {
    uint64_t v13 = (uint64_t)[v5 compare:v6];
  }

  else if (v11 > v12)
  {
    uint64_t v13 = -1LL;
  }

  else
  {
    uint64_t v13 = 1LL;
  }

  return v13;
}

uint64_t _FindDylibObjectIDForParentLibrary( unint64_t **a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  id v6 = newpool;
  id v7 = apr_array_make(newpool, 32, 8);
  GTMTLSMContext_getObjects(*(_DWORD **)(*(void *)(**a1 + 40) + 96LL), *a1[11], v7);
  uint64_t nelts = v7->nelts;
  if ((int)nelts < 1)
  {
LABEL_5:
    uint64_t v10 = 0LL;
  }

  else
  {
    elts = v7->elts;
    while (*(void *)(*(void *)elts + 48LL) != *(void *)(a2 + 8))
    {
      elts += 8;
      if (!--nelts) {
        goto LABEL_5;
      }
    }

    uint64_t v10 = *(void *)(*(void *)elts + 8LL);
  }

  apr_pool_destroy(v6);
  return v10;
}

uint64_t GTShaderDebuggerMakeRuntimeLibrariesFromMetallibs(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  BOOL v41 = (unint64_t **)a1;
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([*((id *)*a1 + 1) defaultDevice]);
  uint64_t v39 = (unint64_t *)a1[11];
  unint64_t v40 = *(uint64_t **)(*(void *)*a1 + 40LL);
  id v6 = [a1[12] mutableCopy];
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  id v7 = v5;
  id v36 = [v7 countByEnumeratingWithState:&v45 objects:v49 count:16];
  if (!v36)
  {
    id v8 = 0LL;
    goto LABEL_20;
  }

  id v35 = a3;
  id v8 = 0LL;
  uint64_t v37 = *(void *)v46;
  uint64_t v38 = v6;
  while (2)
  {
    for (unint64_t i = 0LL; i != v36; unint64_t i = (char *)i + 1)
    {
      if (*(void *)v46 != v37) {
        objc_enumerationMutation(v7);
      }
      uint64_t v10 = *(void **)(*((void *)&v45 + 1) + 8LL * (void)i);
      AliasStreaunint64_t m = (uint64_t *)GetAliasStream( *(void *)(**v41 + 24),  (uint64_t)[v10 unsignedIntegerValue],  *v41[11]);
      if (AliasStream) {
        uint64_t v12 = *AliasStream;
      }
      else {
        uint64_t v12 = 0LL;
      }
      uint64_t Object = GTMTLSMContext_lastObject(*v40, v12, *v39);
      if (!Object)
      {
        if (v35)
        {
          id Error = GTShaderDebuggerMakeError(1u, @"Internal error: Library not found", 0LL, 0LL, 0LL);
          uint64_t v28 = 0LL;
          *id v35 = (id)objc_claimAutoreleasedReturnValue(Error);
        }

        else
        {
          uint64_t v28 = 0LL;
        }

        unsigned int v27 = (unint64_t *)v7;
        id v6 = v38;
        goto LABEL_37;
      }

      uint64_t v14 = Object;
      id v15 = v7;
      id v16 = objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v10]);
      dispatch_data_t v17 = dispatch_data_create([v16 bytes], (size_t)objc_msgSend(v16, "length"), 0, 0);
      id v44 = v8;
      id v18 = [v42 newLibraryWithData:v17 error:&v44];
      id v19 = v44;

      if (!v18)
      {
        id v6 = v38;
        if (v35)
        {
          id v30 = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to set up runtime library", 0LL, v19, 0LL);
          id v18 = 0LL;
          *id v35 = (id)objc_claimAutoreleasedReturnValue(v30);
        }

        else
        {
          id v18 = 0LL;
        }

        id v8 = v19;
        id v7 = v15;
        goto LABEL_36;
      }

      if (*(_BYTE *)(v14 + 160) == 1)
      {
        id v43 = v19;
        id v20 = [v42 newDynamicLibrary:v18 error:&v43];
        id v8 = v43;

        if (v20)
        {
          uint64_t DylibObjectIDForParentLibrary = _FindDylibObjectIDForParentLibrary(v41, v14, v21, v22);
          id v7 = v15;
          if (DylibObjectIDForParentLibrary)
          {
            id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  DylibObjectIDForParentLibrary));
            [v38 setObject:v20 forKeyedSubscript:v24];

            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v14 + 8)));
            [v38 setObject:v18 forKeyedSubscript:v25];

            goto LABEL_16;
          }

          id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Failed to resolve dynamic library identifier %@",  v10));
          if (v35)
          {
            id v33 = GTShaderDebuggerMakeError(1u, v32, 0LL, 0LL, 0LL);
            *id v35 = (id)objc_claimAutoreleasedReturnValue(v33);
          }
        }

        else
        {
          id v7 = v15;
          if (v35)
          {
            id v31 = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to set up runtime dynamic library",  0LL,  v8,  0LL);
            id v20 = 0LL;
            *id v35 = (id)objc_claimAutoreleasedReturnValue(v31);
          }

          else
          {
            id v20 = 0LL;
          }
        }

        id v6 = v38;

LABEL_36:
        uint64_t v28 = 0LL;
        unsigned int v27 = (unint64_t *)v7;
        goto LABEL_37;
      }

      id v20 = (id)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v14 + 8)));
      [v38 setObject:v18 forKeyedSubscript:v20];
      id v8 = v19;
      id v7 = v15;
LABEL_16:
    }

    id v6 = v38;
    id v36 = [v7 countByEnumeratingWithState:&v45 objects:v49 count:16];
    if (v36) {
      continue;
    }
    break;
  }

uint64_t GTShaderDebuggerMakeRuntimeLibrariesFromDependentLibs(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  uint64_t v36 = a1;
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)a1 + 8) defaultDevice]);
  id v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  id v8 = v4;
  id v9 = [v8 countByEnumeratingWithState:&v42 objects:v46 count:16];
  if (v9)
  {
    id v10 = v9;
    id v11 = 0LL;
    uint64_t v39 = *(void *)v43;
    uint64_t v37 = v7;
    obuint64_t j = v8;
    while (2)
    {
      for (unint64_t i = 0LL; i != v10; unint64_t i = (char *)i + 1)
      {
        uint64_t v13 = v6;
        if (*(void *)v43 != v39) {
          objc_enumerationMutation(obj);
        }
        id v14 = *(id *)(*((void *)&v42 + 1) + 8LL * (void)i);
        dispatch_data_t v15 = dispatch_data_create([v14 bytes], (size_t)objc_msgSend(v14, "length"), 0, 0);
        id v41 = v11;
        id v16 = [v5 newLibraryWithData:v15 error:&v41];
        id v17 = v41;

        if (!v16)
        {
          id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 domain]);
          unsigned int v19 = [v18 isEqualToString:MTLLibraryErrorDomain];

          if (!v19) {
            goto LABEL_23;
          }
          uint64_t v20 = GTShaderDebuggerMakeRuntimeLibrariesFromDependentLibs_lib_index++;
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(@"dylib-", "stringByAppendingFormat:", @"%llu.metallib", v20));
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v36 + 200) stringByAppendingPathComponent:v21]);
          if (([v14 writeToFile:v22 options:0 error:0] & 1) == 0)
          {

LABEL_23:
            if (a3)
            {
              id Error = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to set up dependent dynamic library",  0LL,  v17,  0LL);
              *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
            }

            id v11 = v17;
            id v6 = v13;
LABEL_26:
            id v7 = v37;
            id v8 = obj;

            uint64_t v31 = 0LL;
            id v30 = obj;
            goto LABEL_27;
          }

          id v23 = -[NSURL initFileURLWithPath:isDirectory:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithPath:isDirectory:",  v22,  0LL);
          id v16 = [v5 newLibraryWithURL:v23 error:0];

          if (!v16) {
            goto LABEL_23;
          }
        }

        id v24 = (void *)objc_claimAutoreleasedReturnValue([v16 installName]);
        unsigned __int8 v25 = [v24 containsString:@"libtracepoint"];

        if ((v25 & 1) == 0) {
          -[NSMutableArray addObject:](v37, "addObject:", v16);
        }
        id v40 = v17;
        id v26 = [v5 newDynamicLibrary:v16 error:&v40];
        id v11 = v40;

        if (!v26)
        {
          id v6 = v13;
          if (a3)
          {
            id v32 = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to set up dependent dynamic library",  0LL,  v11,  0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v32);
          }

          goto LABEL_26;
        }

        id v6 = v13;
        -[NSMutableArray addObject:](v13, "addObject:", v26);
      }

      id v8 = obj;
      id v10 = [obj countByEnumeratingWithState:&v42 objects:v46 count:16];
      id v7 = v37;
      if (v10) {
        continue;
      }
      break;
    }
  }

  else
  {
    id v11 = 0LL;
  }

  id v27 = -[NSMutableArray copy](v6, "copy");
  uint64_t v28 = *(void **)(v36 + 112);
  *(void *)(v36 + 112) = v27;

  id v29 = -[NSMutableArray copy](v7, "copy");
  id v30 = *(void **)(v36 + 120);
  *(void *)(v36 + 120) = v29;
  uint64_t v31 = 1LL;
LABEL_27:

  return v31;
}

uint64_t GTShaderDebuggerMakeRuntimeFunctions(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if ([v5 count])
  {
    id v6 = [*(id *)(a1 + 96) mutableCopy];
    id v7 = *(uint64_t **)(**(void **)a1 + 40LL);
    unint64_t v74 = **(void **)(a1 + 88);
    __int128 v85 = 0u;
    __int128 v86 = 0u;
    __int128 v87 = 0u;
    __int128 v88 = 0u;
    id v65 = v5;
    id v8 = v5;
    id v70 = [v8 countByEnumeratingWithState:&v85 objects:v90 count:16];
    if (v70)
    {
      id v9 = &selRef_getTextureAccessCounters_region_mipLevel_slice_resetCounters_countersBuffer_countersBufferOffset_;
      uint64_t v71 = *(void *)v86;
      uint64_t v68 = v7;
      uint64_t v69 = a1;
      id v66 = v8;
      unint64_t v67 = a3;
      do
      {
        uint64_t v10 = 0LL;
        id v64 = v9[324];
        do
        {
          if (*(void *)v86 != v71) {
            objc_enumerationMutation(v8);
          }
          id v11 = *(void **)(*((void *)&v85 + 1) + 8 * v10);
          id v12 = _ObjectUIDsWithAliasID((void **)a1, (uint64_t)[v11 unsignedLongLongValue]);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
          if (![v13 count]
            || (uint64_t v75 = v10,
                id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 firstObject]),
                uint64_t Object = (uint64_t *)GTMTLSMContext_lastObject( *v7,  (uint64_t)[v14 unsignedLongLongValue],  v74),  v14,  !Object))
          {
            id v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Function '%@' not found",  v11));
            if (a3)
            {
              id Error = GTShaderDebuggerMakeError(1u, v61, 0LL, 0LL, 0LL);
              *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
            }

LABEL_60:
            uint64_t v59 = 0LL;
            goto LABEL_61;
          }

          __int128 v76 = v13;
          id v16 = *(void **)(a1 + 96);
          id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  Object[5]));
          uint64_t v18 = objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v17]);

          unsigned int v19 = (void *)v18;
          if (v18)
          {
            uint64_t v20 = Object[15];
            id v73 = v19;
            if (v20)
            {
              uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)a1 + 8) functionMap]);
              MTLIntersectionFunctionDescriptor = MakeMTLIntersectionFunctionDescriptor(v20, v21);
              id v23 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionDescriptor);
              id v84 = 0LL;
              id v24 = [v19 newIntersectionFunctionWithDescriptor:v23 error:&v84];
              id v72 = v84;

              goto LABEL_17;
            }

            uint64_t v20 = Object[14];
            if (v20)
            {
              id v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)a1 + 8) functionMap]);
              MTLFunctionDescriptor = MakeMTLFunctionDescriptor(v20, v29);
              uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);
              id v83 = 0LL;
              id v24 = [v19 newFunctionWithDescriptor:v31 error:&v83];
              id v72 = v83;

LABEL_17:
              id v32 = *(_BYTE **)(v20 + 8);
LABEL_18:
              if (v24)
              {
                __int128 v79 = 0u;
                __int128 v80 = 0u;
                __int128 v77 = 0u;
                __int128 v78 = 0u;
                id v33 = v76;
                id v34 = [v33 countByEnumeratingWithState:&v77 objects:v89 count:16];
                if (v34)
                {
                  id v35 = v34;
                  uint64_t v36 = *(void *)v78;
                  do
                  {
                    for (unint64_t i = 0LL; i != v35; unint64_t i = (char *)i + 1)
                    {
                      if (*(void *)v78 != v36) {
                        objc_enumerationMutation(v33);
                      }
                      id v38 = [*(id *)(*((void *)&v77 + 1) + 8 * (void)i) unsignedLongLongValue];
                      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v38));
                      id v40 = (void *)objc_claimAutoreleasedReturnValue([v39 stringValue]);
                      [v24 setLabel:v40];

                      id v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v38));
                      [v6 setObject:v24 forKeyedSubscript:v41];
                    }

                    id v35 = [v33 countByEnumeratingWithState:&v77 objects:v89 count:16];
                  }

                  while (v35);
                }

                int v42 = 0;
                id v8 = v66;
                a3 = v67;
                id v7 = v68;
                a1 = v69;
                __int128 v43 = v72;
LABEL_37:

                uint64_t v28 = v76;
                unsigned int v19 = v73;
                goto LABEL_38;
              }

              id v7 = v68;
              a1 = v69;
            }

            else
            {
              id v32 = (_BYTE *)Object[7];
              if (v32 && *v32)
              {
                uint64_t v47 = Object[9];
                __int128 v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  Object[7]));
                if (v47)
                {
                  MTLFunctionConstantValues = MakeMTLFunctionConstantValues((void *)Object[9]);
                  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
                  id v82 = 0LL;
                  id v24 = [v73 newFunctionWithName:v48 constantValues:v50 error:&v82];
                  id v72 = v82;
                }

                else
                {
                  id v52 = [v73 newFunctionWithName:v48];

                  id v53 = v52;
                  if ((objc_opt_respondsToSelector(v53, v64) & 1) != 0
                    && [v53 needsFunctionConstantValues])
                  {
                    uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v32));
                    uint64_t v55 = objc_alloc_init(&OBJC_CLASS___MTLFunctionConstantValues);
                    id v81 = 0LL;
                    id v56 = [v73 newFunctionWithName:v54 constantValues:v55 error:&v81];
                    id v72 = v81;

                    id v24 = v53;
                    if (v56)
                    {
                      id v24 = v56;
                    }
                  }

                  else
                  {
                    id v72 = 0LL;
                    id v24 = v53;
                  }
                }

                goto LABEL_18;
              }

              id v51 = GTShaderDebuggerMakeError(1u, @"Capture did not resolve function name", 0LL, 0LL, 0LL);
              id v72 = (id)objc_claimAutoreleasedReturnValue(v51);
            }

            if (v32)
            {
              __int128 v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v32));
              id v24 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Failed to set up function '%@' (%@)",  v44,  v11));
            }

            else
            {
              id v24 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Failed to set up function '%@' (%@)",  @"NULL",  v11));
            }

            __int128 v43 = v72;
            if (a3)
            {
              id v46 = GTShaderDebuggerMakeError(2u, v24, 0LL, v72, 0LL);
              *a3 = (id)objc_claimAutoreleasedReturnValue(v46);
            }

            int v42 = 1;
            goto LABEL_37;
          }

          uint64_t v25 = GTMTLSMContext_lastObject(*v7, Object[5], v74);
          if (v25)
          {
            unint64_t v26 = *(unsigned __int8 *)(v25 + 161);
            id v27 = @"Unknown";
            uint64_t v28 = v76;
            if (v26 <= 6) {
              id v27 = off_58F960[v26];
            }
          }

          else
          {
            id v27 = @"NULL";
            uint64_t v28 = v76;
          }

          __int128 v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Failed to find runtime library (%@) for function '%@'",  v27,  v11));
          int v42 = 1;
          if (a3)
          {
            id v45 = GTShaderDebuggerMakeError(1u, v43, 0LL, 0LL, 0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v45);
          }

id _ObjectUIDsWithAliasID(void **a1, uint64_t a2)
{
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  apr_pool_create_ex(&p, 0LL, 0LL, v5);
  id v6 = p;
  id v7 = apr_array_make(p, 32, 8);
  uint64_t v8 = *(void *)(**a1 + 24LL);
  unint64_t v9 = *a1[11];
  uint64_t v22 = a2;
  entry = find_entry(v8, &v22, 8uLL, 0LL);
  if (*entry)
  {
    for (unint64_t i = *(void **)(*entry + 32LL); i; unint64_t i = (void *)i[4])
    {
      if (i[2] <= v9 && i[3] >= v9)
      {
        uint64_t v12 = i[1];
        *(void *)apr_array_push(v7) = v12;
      }
    }
  }

  uint64_t nelts = v7->nelts;
  if ((int)nelts >= 1)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = 8 * nelts;
    do
    {
      id v16 = *(uint64_t **)&v7->elts[v14];
      if (v16) {
        uint64_t v17 = *v16;
      }
      else {
        uint64_t v17 = 0LL;
      }
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v17));
      -[NSMutableArray addObject:](v4, "addObject:", v18);

      v14 += 8LL;
    }

    while (v15 != v14);
  }

  apr_pool_destroy(v6);
  id v19 = -[NSMutableArray copy](v4, "copy");

  return v19;
}

uint64_t GTShaderDebuggerMakeDebugMetadata(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v280 = a2;
  id v7 = a3;
  if ((*(_BYTE *)(a1 + 208) & 1) == 0) {
    goto LABEL_2;
  }
  uint64_t v277 = a4;
  id v279 = v7;
  uint64_t v288 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __s = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v291 = a1;
  uint64_t v281 = *(uint64_t **)(**(void **)a1 + 40LL);
  unint64_t v282 = **(void **)(a1 + 88);
  __int128 v303 = 0u;
  __int128 v304 = 0u;
  __int128 v305 = 0u;
  __int128 v306 = 0u;
  unint64_t k = (unint64_t)v280;
  id v10 = [(id)k countByEnumeratingWithState:&v303 objects:v345 count:16];
  if (v10)
  {
    uint64_t v284 = *(void *)v304;
    do
    {
      for (unint64_t i = 0LL; i != v10; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v304 != v284) {
          objc_enumerationMutation((id)k);
        }
        uint64_t v12 = *(void **)(*((void *)&v303 + 1) + 8LL * (void)i);
        AliasStreaunint64_t m = (uint64_t *)GetAliasStream( *(void *)(**(void **)v291 + 24),  (uint64_t)[v12 unsignedIntegerValue],  **(void **)(v291 + 88));
        if (AliasStream) {
          uint64_t v14 = *AliasStream;
        }
        else {
          uint64_t v14 = 0LL;
        }
        uint64_t v15 = *(void **)(v291 + 96);
        id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v14));
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v16]);

        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 bitcodeData]);
        if (!v18)
        {
          if (v277)
          {
            id Error = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to process executable debug information",  0LL,  0LL,  0LL);
            void *v277 = (id)objc_claimAutoreleasedReturnValue(Error);
          }

          uint64_t v8 = 0LL;
          id v7 = v279;
          goto LABEL_176;
        }

        if ((*(_BYTE *)(v291 + 208) & 8) != 0)
        {
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v17 name]);
          v344[0] = v19;
          v344[1] = v12;
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v344,  2LL));
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 componentsJoinedByString:@"_"]);

          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 stringByAppendingPathExtension:@"bc"]);
          id v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v291 + 200) stringByAppendingPathComponent:v22]);
          uint64_t v302 = 0LL;
          [v18 writeToFile:v23 options:1 error:&v302];
        }

        uint64_t Object = GTMTLSMContext_lastObject(*v281, v14, v282);
        if (Object
          && ((uint64_t v25 = *(void *)(Object + 120)) != 0 || (uint64_t v25 = *(void *)(Object + 112)) != 0)
          && *(void *)(v25 + 8))
        {
          uint64_t v26 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
        }

        else
        {
          uint64_t v26 = objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }

        id v27 = (void *)v26;
        -[NSMutableArray addObject:](__s, "addObject:", v26);

        -[NSMutableArray addObject:](v288, "addObject:", v18);
      }

      id v10 = [(id)k countByEnumeratingWithState:&v303 objects:v345 count:16];
    }

    while (v10);
  }

  __int128 v301 = 0u;
  __int128 v299 = 0u;
  __int128 v300 = 0u;
  __int128 v298 = 0u;
  id v28 = v279;
  id v29 = [v28 countByEnumeratingWithState:&v298 objects:v343 count:16];
  if (v29)
  {
    uint64_t v30 = *(void *)v299;
    unint64_t k = (unint64_t)&CATransform3DIdentity_ptr;
    do
    {
      for (uint64_t j = 0LL; j != v29; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v299 != v30) {
          objc_enumerationMutation(v28);
        }
        id v32 = *(void **)(*((void *)&v298 + 1) + 8LL * (void)j);
        id v33 = (uint64_t *)GetAliasStream( *(void *)(**(void **)v291 + 24),  (uint64_t)[v32 unsignedIntegerValue],  **(void **)(v291 + 88));
        if (v33) {
          uint64_t v34 = *v33;
        }
        else {
          uint64_t v34 = 0LL;
        }
        id v35 = *(void **)(v291 + 96);
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v34));
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v35 objectForKeyedSubscript:v36]);

        if (v37 && [v37 type])
        {
          id v38 = (void *)objc_claimAutoreleasedReturnValue([v37 bitcodeData]);
          if (v38)
          {
            if ((*(_BYTE *)(v291 + 208) & 8) != 0)
            {
              uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v37 installName]);
              v342[0] = v39;
              v342[1] = v32;
              id v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v342,  2LL));
              id v41 = (void *)objc_claimAutoreleasedReturnValue([v40 componentsJoinedByString:@"_"]);

              int v42 = (void *)objc_claimAutoreleasedReturnValue([v41 stringByAppendingPathExtension:@"bc"]);
              __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v291 + 200) stringByAppendingPathComponent:v42]);
              uint64_t v297 = 0LL;
              [v38 writeToFile:v43 options:1 error:&v297];
            }

            -[NSMutableArray addObject:](v288, "addObject:", v38);
            __int128 v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
            -[NSMutableArray addObject:](__s, "addObject:", v44);
          }
        }
      }

      id v29 = [v28 countByEnumeratingWithState:&v298 objects:v343 count:16];
    }

    while (v29);
  }

  __int128 v295 = 0u;
  __int128 v296 = 0u;
  __int128 v293 = 0u;
  __int128 v294 = 0u;
  id v45 = *(id *)(v291 + 120);
  id v46 = [v45 countByEnumeratingWithState:&v293 objects:v341 count:16];
  if (v46)
  {
    uint64_t v47 = *(void *)v294;
    do
    {
      for (unint64_t k = 0LL; (id)k != v46; ++k)
      {
        if (*(void *)v294 != v47) {
          objc_enumerationMutation(v45);
        }
        __int128 v48 = *(void **)(*((void *)&v293 + 1) + 8 * k);
        unint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v48 bitcodeData]);
        if (v49)
        {
          if ((*(_BYTE *)(v291 + 208) & 8) != 0)
          {
            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v48 installName]);
            id v51 = (void *)objc_claimAutoreleasedReturnValue([v50 stringByAppendingPathExtension:@"bc"]);
            id v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v291 + 200) stringByAppendingPathComponent:v51]);
            uint64_t v292 = 0LL;
            [v49 writeToFile:v52 options:1 error:&v292];
          }

          -[NSMutableArray addObject:](v288, "addObject:", v49);
          id v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
          -[NSMutableArray addObject:](__s, "addObject:", v53);
        }
      }

      id v46 = [v45 countByEnumeratingWithState:&v293 objects:v341 count:16];
    }

    while (v46);
  }

  id v54 = *(id *)(v291 + 104);
  uint64_t v55 = v288;
  id v283 = __s;
  id v276 = v54;
  int v350 = 0;
  __int128 v348 = 0u;
  __int128 v349 = 0u;
  __int128 v347 = 0u;
  __int128 v351 = 0u;
  __int128 v352 = 0u;
  __int128 v353 = 0u;
  __int128 v354 = 0u;
  uint64_t v355 = 0LL;
  v356[0] = v357;
  v356[1] = (char *)0x400000000LL;
  os_signpost_id_t v285 = v55;
  llvm::LLVMContext::LLVMContext((llvm::LLVMContext *)v327);
  int64x2_t v325 = 0uLL;
  unsigned int v326 = 0LL;
  __int128 v323 = 0u;
  __int128 __p = 0u;
  float v324 = 1.0;
  id v56 = (char *)-[NSMutableArray count](v55, "count");
  if (v56)
  {
    id v289 = v56;
    id v278 = 0LL;
    id v57 = 0LL;
    while (1)
    {
      id v58 = objc_claimAutoreleasedReturnValue( -[NSMutableArray objectAtIndexedSubscript:]( v55, "objectAtIndexedSubscript:", v57));
      llvm::MemoryBuffer::getMemBuffer(v358, [v58 bytes], objc_msgSend(v58, "length"), "", 0, 0);
      llvm::MemoryBuffer::getMemBufferRef((llvm::MemoryBuffer *)v358[0].__r_.__value_.__l.__data_);
      llvm::parseIR( v346,  v321,  &v347,  v327,  llvm::function_ref<llvm::Optional<std::string> ()(llvm::StringRef)>::callback_fn<llvm::$_0>,  &v314);
      uint64_t v59 = v346[0];
      if (v346[0])
      {
        id v60 = (void *)v325.i64[1];
        id v61 = (void *)v325.i64[0];
        unint64_t v62 = v325.i64[1] - v325.i64[0];
        uint64_t v63 = (v325.i64[1] - v325.i64[0]) >> 3;
        if (v325.i64[1] >= (unint64_t)v326)
        {
          unint64_t v69 = v63 + 1;
          uint64_t v70 = (uint64_t)&v326[-v325.i64[0]];
          else {
            unint64_t k = v69;
          }
          if (k)
          {
            if (k >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v71 = (char *)operator new(8 * k);
          }

          else
          {
            uint64_t v71 = 0LL;
          }

          id v72 = (llvm::Module **)&v71[8 * v63];
          v346[0] = 0LL;
          void *v72 = v59;
          id v64 = v72 + 1;
          if (v60 == v61)
          {
            int64x2_t v74 = vdupq_n_s64((unint64_t)v60);
          }

          else
          {
            do
            {
              id v73 = (llvm::Module *)*--v60;
              *id v60 = 0LL;
              *--id v72 = v73;
            }

            while (v60 != v61);
            int64x2_t v74 = v325;
          }

          v325.i64[0] = (uint64_t)v72;
          v325.i64[1] = (uint64_t)v64;
          unsigned int v326 = &v71[8 * k];
          __int128 v76 = (llvm::Module **)v74.i64[1];
          uint64_t v75 = (llvm::Module **)v74.i64[0];
          while (v76 != v75)
            std::unique_ptr<llvm::Module>::reset[abi:nn180100](--v76);
          if (v75) {
            operator delete(v75);
          }
        }

        else
        {
          v346[0] = 0LL;
          *(void *)v325.i64[1] = v59;
          id v64 = v60 + 1;
        }

        v325.i64[1] = (uint64_t)v64;
        unint64_t v67 = (NSString *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v283, "objectAtIndexedSubscript:", v57));
        __int128 v77 = (NSString *)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
        BOOL v78 = v67 == v77;

        if (!v78)
        {
          unint64_t v67 = v67;
          __sa = -[NSString UTF8String](v67, "UTF8String");
          unint64_t v79 = (v62 >> 3);
          unint64_t v80 = *((void *)&__p + 1);
          if (*((void *)&__p + 1))
          {
            uint8x8_t v81 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&__p + 8));
            v81.i16[0] = vaddlv_u8(v81);
            if (v81.u32[0] > 1uLL)
            {
              unint64_t k = (v62 >> 3);
              if (*((void *)&__p + 1) <= v79) {
                unint64_t k = v79 % *((void *)&__p + 1);
              }
            }

            else
            {
              unint64_t k = (DWORD2(__p) - 1) & v79;
            }

            id v82 = *(void ***)(__p + 8 * k);
            if (v82)
            {
              id v83 = (std::string *)*v82;
              if (*v82)
              {
                do
                {
                  std::string::size_type size = v83->__r_.__value_.__l.__size_;
                  if (size == v79)
                  {
                    if (LODWORD(v83->__r_.__value_.__r.__words[2]) == (_DWORD)v63)
                    {
                      id v107 = __sa;
                      goto LABEL_156;
                    }
                  }

                  else
                  {
                    if (v81.u32[0] > 1uLL)
                    {
                      if (size >= *((void *)&__p + 1)) {
                        size %= *((void *)&__p + 1);
                      }
                    }

                    else
                    {
                      size &= *((void *)&__p + 1) - 1LL;
                    }

                    if (size != k) {
                      break;
                    }
                  }

                  id v83 = (std::string *)v83->__r_.__value_.__r.__words[0];
                }

                while (v83);
              }
            }
          }

          id v83 = (std::string *)operator new(0x30uLL);
          v83->__r_.__value_.__r.__words[0] = 0LL;
          v83->__r_.__value_.__l.__size_ = v79;
          LODWORD(v83->__r_.__value_.__r.__words[2]) = v63;
          v83[1].__r_.__value_.__r.__words[0] = 0LL;
          v83[1].__r_.__value_.__l.__size_ = 0LL;
          v83[1].__r_.__value_.__l.__cap_ = 0LL;
          float v85 = (float)(unint64_t)(*((void *)&v323 + 1) + 1LL);
          if (v80 && (float)(v324 * (float)v80) >= v85)
          {
            id v107 = __sa;
            goto LABEL_146;
          }

          BOOL v86 = (v80 & (v80 - 1)) != 0;
          if (v80 < 3) {
            BOOL v86 = 1LL;
          }
          unint64_t v87 = v86 | (2 * v80);
          unint64_t v88 = vcvtps_u32_f32(v85 / v324);
          if (v87 <= v88) {
            int8x8_t prime = (int8x8_t)v88;
          }
          else {
            int8x8_t prime = (int8x8_t)v87;
          }
          if (*(void *)&prime == 1LL)
          {
            int8x8_t prime = (int8x8_t)2LL;
          }

          else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
          {
            int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
            unint64_t v80 = *((void *)&__p + 1);
          }

          if (*(void *)&prime <= v80)
          {
            if (*(void *)&prime >= v80) {
              goto LABEL_140;
            }
            unint64_t v96 = vcvtps_u32_f32((float)*((unint64_t *)&v323 + 1) / v324);
            if (v80 < 3 || (uint8x8_t v97 = (uint8x8_t)vcnt_s8((int8x8_t)v80), v97.i16[0] = vaddlv_u8(v97), v97.u32[0] > 1uLL))
            {
              unint64_t v96 = std::__next_prime(v96);
            }

            else
            {
              uint64_t v98 = 1LL << -(char)__clz(v96 - 1);
              if (v96 >= 2) {
                unint64_t v96 = v98;
              }
            }

            if (*(void *)&prime <= v96) {
              int8x8_t prime = (int8x8_t)v96;
            }
            if (*(void *)&prime >= v80)
            {
              unint64_t v80 = *((void *)&__p + 1);
              goto LABEL_140;
            }

            if (prime) {
              goto LABEL_111;
            }
            id v108 = (void *)__p;
            *(void *)&__int128 __p = 0LL;
            id v107 = __sa;
            if (v108) {
              operator delete(v108);
            }
            unint64_t v80 = 0LL;
            *((void *)&__p + 1) = 0LL;
          }

          else
          {
LABEL_111:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            int v90 = operator new(8LL * *(void *)&prime);
            id v91 = (void *)__p;
            *(void *)&__int128 __p = v90;
            if (v91) {
              operator delete(v91);
            }
            uint64_t v92 = 0LL;
            *((int8x8_t *)&__p + 1) = prime;
            do
              *(void *)(__p + 8 * v92++) = 0LL;
            while (*(void *)&prime != v92);
            id v93 = (void **)v323;
            if ((void)v323)
            {
              unint64_t v94 = *(void *)(v323 + 8);
              uint8x8_t v95 = (uint8x8_t)vcnt_s8(prime);
              v95.i16[0] = vaddlv_u8(v95);
              if (v95.u32[0] > 1uLL)
              {
                if (v94 >= *(void *)&prime) {
                  v94 %= *(void *)&prime;
                }
              }

              else
              {
                v94 &= *(void *)&prime - 1LL;
              }

              *(void *)(__p + 8 * v94) = &v323;
              for (unint64_t m = *v93; m; v94 = v100)
              {
                unint64_t v100 = m[1];
                if (v95.u32[0] > 1uLL)
                {
                  if (v100 >= *(void *)&prime) {
                    v100 %= *(void *)&prime;
                  }
                }

                else
                {
                  v100 &= *(void *)&prime - 1LL;
                }

                if (v100 != v94)
                {
                  if (!*(void *)(__p + 8 * v100))
                  {
                    *(void *)(__p + 8 * v100) = v93;
                    goto LABEL_136;
                  }

                  void *v93 = (void *)*m;
                  *unint64_t m = **(void **)(__p + 8 * v100);
                  **(void **)(__p + 8 * v100) = m;
                  unint64_t m = v93;
                }

                unint64_t v100 = v94;
LABEL_136:
                id v93 = (void **)m;
                unint64_t m = (void *)*m;
              }
            }

            unint64_t v80 = (unint64_t)prime;
LABEL_140:
            id v107 = __sa;
          }

          if ((v80 & (v80 - 1)) != 0)
          {
            if (v80 <= v79) {
              unint64_t k = v79 % v80;
            }
            else {
              unint64_t k = v79;
            }
          }

          else
          {
            unint64_t k = ((_DWORD)v80 - 1) & v79;
          }

LABEL_261:
      if ((v148 & (v148 - 1)) != 0)
      {
        if (v147 >= v148) {
          uint64_t v118 = (std::string *)(v147 % v148);
        }
        else {
          uint64_t v118 = (std::string *)v147;
        }
      }

      else
      {
        uint64_t v118 = (std::string *)((v148 - 1) & v147);
      }
    }

    uint64_t v175 = v338;
    __int128 v176 = *(void **)(v338 + 8LL * (void)v118);
    if (v176)
    {
      *id v154 = *v176;
LABEL_274:
      *__int128 v176 = v154;
      goto LABEL_275;
    }

    *id v154 = v339;
    *(void *)&__int128 v339 = v154;
    *(void *)(v175 + 8LL * (void)v11_Block_object_dispose(va, 8) = &v339;
    if (*v154)
    {
      unint64_t v177 = *(void *)(*v154 + 8LL);
      if ((v148 & (v148 - 1)) != 0)
      {
        if (v177 >= v148) {
          v177 %= v148;
        }
      }

      else
      {
        v177 &= v148 - 1;
      }

      __int128 v176 = (void *)(v338 + 8 * v177);
      goto LABEL_274;
    }

LABEL_275:
    ++*((void *)&v339 + 1);
LABEL_276:
    ++v139;
  }

  while (v139 != 20);
  uint64_t v179 = 1120LL;
  do
  {
    __int128 v180 = (void **)((char *)&v358[0].__r_.__value_.__l.__data_ + v179);
    __int128 v181 = *(_BYTE **)&v357[v179 + 160];
    if (&v357[v179 + 136] == v181)
    {
      __int128 v181 = &v357[v179 + 136];
      uint64_t v182 = 4LL;
    }

    else
    {
      if (!v181) {
        goto LABEL_292;
      }
      uint64_t v182 = 5LL;
    }

    (*(void (**)(void))(*(void *)v181 + 8 * v182))();
LABEL_292:
    v179 -= 56LL;
  }

  while (v179);
  if (((v325.i64[1] - v325.i64[0]) & 0x7FFFFFFF8LL) != 0)
  {
    unint64_t v183 = 0LL;
    __int128 v180 = (void **)v363;
    uint64_t v290 = ((unint64_t)(v325.i64[1] - v325.i64[0]) >> 3);
    do
    {
      uint64_t v184 = v325.i64[0];
      v358[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v358[0].__r_.__value_.__l.__cap_;
      v358[0].__r_.__value_.__l.__size_ = 0x800000000LL;
      uint64_t v361 = v363;
      uint64_t v362 = 0x800000000LL;
      uint64_t v365 = v367;
      uint64_t v366 = 0x800000000LL;
      v369 = v371;
      uint64_t v370 = 0x800000000LL;
      uint64_t v373 = v375;
      uint64_t v374 = 0x800000000LL;
      v377 = v381;
      v378 = v381;
      uint64_t v379 = 32LL;
      int v380 = 0;
      llvm::DebugInfoFinder::processModule( (llvm::DebugInfoFinder *)v358,  *(const llvm::Module **)(v325.i64[0] + 8 * v183));
      if ((_DWORD)v362)
      {
        if (*((void *)&__p + 1))
        {
          uint8x8_t v185 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&__p + 8));
          v185.i16[0] = vaddlv_u8(v185);
          if (v185.u32[0] > 1uLL)
          {
            unint64_t v186 = v183;
            if (*((void *)&__p + 1) <= v183) {
              unint64_t v186 = v183 % *((void *)&__p + 1);
            }
          }

          else
          {
            unint64_t v186 = (*((void *)&__p + 1) + 0xFFFFFFFFLL) & v183;
          }

          __int128 v187 = *(uint64_t ***)(__p + 8 * v186);
          if (v187)
          {
            for (kunint64_t k = *v187; kk; kunint64_t k = (uint64_t *)*kk)
            {
              unint64_t v189 = kk[1];
              if (v189 == v183)
              {
                if (v183 == *((_DWORD *)kk + 4))
                {
                  id v227 = (std::string *)(kk + 3);
                  goto LABEL_315;
                }
              }

              else
              {
                if (v185.u32[0] > 1uLL)
                {
                  if (v189 >= *((void *)&__p + 1)) {
                    v189 %= *((void *)&__p + 1);
                  }
                }

                else
                {
                  v189 &= *((void *)&__p + 1) - 1LL;
                }

                if (v189 != v186) {
                  break;
                }
              }
            }
          }
        }

        id v227 = (std::string *)(*(void *)(v184 + 8 * v183) + 192LL);
LABEL_315:
        if ((char)v227->__r_.__value_.__s.__size_ < 0) {
          std::string::__init_copy_ctor_external( &v337,  v227->__r_.__value_.__l.__data_,  v227->__r_.__value_.__l.__size_);
        }
        else {
          std::string v337 = *v227;
        }
        std::string::basic_string[abi:nn180100]<0>(&v334, "__trace.base_id");
        if ((v336 & 0x80u) == 0) {
          size_t v190 = v336;
        }
        else {
          size_t v190 = v335;
        }
        std::string::basic_string[abi:nn180100]((uint64_t)&v329, v190 + 1);
        if ((v329.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          signed int v191 = &v329;
        }
        else {
          signed int v191 = (std::string *)v329.__r_.__value_.__r.__words[0];
        }
        if (v190)
        {
          if ((v336 & 0x80u) == 0) {
            uint64_t v192 = &v334;
          }
          else {
            uint64_t v192 = v334;
          }
          memmove(v191, v192, v190);
        }

        *(_WORD *)((char *)&v191->__r_.__value_.__l.__data_ + v190) = 46;
        if ((v337.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          id v193 = &v337;
        }
        else {
          id v193 = (std::string *)v337.__r_.__value_.__r.__words[0];
        }
        if ((v337.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v194 = v337.__r_.__value_.__s.__size_;
        }
        else {
          std::string::size_type v194 = v337.__r_.__value_.__l.__size_;
        }
        BOOL v195 = std::string::append(&v329, (const std::string::value_type *)v193, v194);
        std::string::size_type cap = v195->__r_.__value_.__l.__cap_;
        __int128 v332 = *(_OWORD *)&v195->__r_.__value_.__l.__data_;
        int64_t v333 = cap;
        v195->__r_.__value_.__l.__size_ = 0LL;
        v195->__r_.__value_.__l.__cap_ = 0LL;
        v195->__r_.__value_.__r.__words[0] = 0LL;
        int v331 = 0;
        if (v333 >= 0) {
          char v197 = &v332;
        }
        else {
          char v197 = (__int128 *)v332;
        }
        if (v333 >= 0) {
          uint64_t v198 = HIBYTE(v333);
        }
        else {
          uint64_t v198 = *((void *)&v332 + 1);
        }
        uint64_t GlobalVariable = llvm::Module::getGlobalVariable(*(void *)(v184 + 8 * v183), v197, v198, 1LL);
        if (GlobalVariable
          || ((v336 & 0x80u) == 0 ? (uint64_t v200 = &v334) : (uint64_t v200 = v334),
              (v336 & 0x80u) == 0 ? (size_t v201 = v336) : (size_t v201 = v335),
              (uint64_t GlobalVariable = llvm::Module::getGlobalVariable(*(void *)(v184 + 8 * v183), v200, v201, 1LL)) != 0))
        {
          uint64_t v202 = *(void *)(GlobalVariable - 32);
          if (v202)
          {
            unsigned int v203 = *(_DWORD *)(v202 + 32);
            if (v203 > 0x40) {
              uint64_t v204 = **(void **)(v202 + 24);
            }
            else {
              uint64_t v204 = (uint64_t)(*(void *)(v202 + 24) << -(char)v203) >> -(char)v203;
            }
            int v331 = v204;
          }
        }

        uint64_t v205 = *(void *)(v184 + 8 * v183);
        v329.__r_.__value_.__r.__words[0] = (std::string::size_type)"tracepoint_library_version";
        __int16 v330 = 259;
        NamedMetadata = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(v205, &v329);
        if (NamedMetadata)
        {
          uint64_t Operand = llvm::NamedMDNode::getOperand(NamedMetadata, 0);
          uint64_t v208 = *(void *)(*(void *)(Operand - 8LL * *(unsigned int *)(Operand + 8)) + 128LL);
          unsigned int v209 = *(_DWORD *)(v208 + 32);
          if (v209 > 0x40) {
            LODWORD(v20_Block_object_dispose(va, 8) = **(_DWORD **)(v208 + 24);
          }
          else {
            uint64_t v208 = (uint64_t)(*(void *)(v208 + 24) << -(char)v209) >> -(char)v209;
          }
          id v320 = (void **)v208;
        }

        v328[0] = &v331;
        v328[1] = (int *)&v338;
        v328[2] = (int *)v358;
        uint64_t v210 = *(void *)(v184 + 8 * v183);
        v329.__r_.__value_.__r.__words[0] = (std::string::size_type)"tracepoint.sets";
        __int16 v330 = 259;
        id v211 = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(v210, &v329);
        if (v211)
        {
          uint64_t v212 = v211;
          int NumOperands = llvm::NamedMDNode::getNumOperands(v211);
          if (NumOperands)
          {
            int v214 = NumOperands;
            for (munint64_t m = 0; mm != v214; ++mm)
            {
              uint64_t v216 = llvm::NamedMDNode::getOperand(v212, mm);
              if (v216)
              {
                uint64_t v217 = *(void *)(v216 - 8LL * *(unsigned int *)(v216 + 8) + 16);
                if (v217) {
                  int v218 = (uint64_t *)(v217 - 8LL * *(unsigned int *)(v217 + 8));
                }
                else {
                  int v218 = 0LL;
                }
                while (v218 != (uint64_t *)v217)
                {
                  uint64_t v219 = *v218++;
                  ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeModules(std::vector<std::unique_ptr<llvm::Module>> const&,std::unordered_map<unsigned int,std::string> const&,unsigned long long *)::$_0::operator()( v328,  v219);
                }
              }
            }
          }
        }

        else
        {
          uint64_t v220 = *(void *)(v184 + 8 * v183);
          v329.__r_.__value_.__r.__words[0] = (std::string::size_type)"tracepoint";
          __int16 v330 = 259;
          BOOL v221 = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(v220, &v329);
          if (v221)
          {
            id v222 = v221;
            int v223 = llvm::NamedMDNode::getNumOperands(v221);
            if (v223)
            {
              int v224 = v223;
              for (nuint64_t n = 0; nn != v224; ++nn)
              {
                uint64_t v226 = llvm::NamedMDNode::getOperand(v222, nn);
                ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeModules(std::vector<std::unique_ptr<llvm::Module>> const&,std::unordered_map<unsigned int,std::string> const&,unsigned long long *)::$_0::operator()( v328,  v226);
              }
            }
          }
        }

        if (SHIBYTE(v333) < 0) {
          operator delete((void *)v332);
        }
        __int128 v180 = (void **)v363;
      }

      if (v378 != v377) {
        free(v378);
      }
      if (v373 != v375) {
        free(v373);
      }
      if (v369 != v371) {
        free(v369);
      }
      if (v365 != v367) {
        free(v365);
      }
      if (v361 != v363) {
        free(v361);
      }
      if ((std::string::size_type *)v358[0].__r_.__value_.__l.__data_ != &v358[0].__r_.__value_.__r.__words[2]) {
        free(v358[0].__r_.__value_.__l.__data_);
      }
      ++v183;
    }

    while (v183 != v290);
  }

  os_signpost_id_t v307 = 0LL;
  id v308 = 0LL;
  unint64_t v309 = 0LL;
  if (v316)
  {
    v358[0].__r_.__value_.__r.__words[0] = 4LL;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, v358);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, &v320);
    id v228 = v314;
    if (v314 != &v315)
    {
      do
      {
        id v229 = v228[5];
        v358[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v228[4];
        v329.__r_.__value_.__r.__words[0] = v228[6] - v229;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, v358);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, &v329);
        BOOL v230 = (char *)v228[11];
        id v231 = v228[12];
        uint64_t v232 = v231 - v230;
        if (v231 - v230 >= 1)
        {
          uint64_t v233 = v308;
          if (v309 - v308 >= v232)
          {
            if (v232 <= 0)
            {
              uint64_t v240 = v308;
              id v241 = &v308[-v232];
              id v242 = v308;
              if (&v308[-v232] < v308)
              {
                uint64_t v243 = v231 - v230 - (v232 & ~(v232 >> 63));
                id v242 = v308;
                do
                {
                  char v244 = *v241++;
                  *v242++ = v244;
                  --v243;
                }

                while (v243);
              }

              id v308 = v242;
              if (v240 != &v233[v232]) {
                memmove(&v233[v232], v233, v240 - &v233[v232]);
              }
              if (v231 != v230) {
                memmove(v233, v230, v231 - v230);
              }
            }

            else
            {
              if (v231 != v230) {
                memmove(v308, v228[11], v231 - v230);
              }
              id v308 = &v233[v231 - v230];
            }
          }

          else
          {
            v234 = (char *)v307;
            int64_t v235 = v308 - (_BYTE *)v307;
            uint64_t v236 = v308 - (_BYTE *)v307 + v232;
            if (v236 < 0) {
              abort();
            }
            unint64_t v237 = v309 - (_BYTE *)v307;
            if (v237 >= 0x3FFFFFFFFFFFFFFFLL) {
              size_t v238 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              size_t v238 = v236;
            }
            if (v238) {
              os_signpost_id_t v239 = (char *)operator new(v238);
            }
            else {
              os_signpost_id_t v239 = 0LL;
            }
            id v245 = &v239[v235];
            id v246 = &v239[v235 + v232];
            int64_t v247 = v235;
            do
            {
              char v248 = *v230++;
              v239[v247++] = v248;
              --v232;
            }

            while (v232);
            if (v233 != v234)
            {
              do
              {
                v239[v235 - 1] = v234[v235 - 1];
                --v235;
              }

              while (v235);
              id v245 = v239;
            }

            uint64_t v249 = v307;
            os_signpost_id_t v307 = v245;
            id v308 = v246;
            unint64_t v309 = &v239[v238];
            if (v249) {
              operator delete(v249);
            }
          }
        }

        id v250 = v228[1];
        if (v250)
        {
          do
          {
            __int128 v251 = (void **)v250;
            id v250 = (void *)*v250;
          }

          while (v250);
        }

        else
        {
          do
          {
            __int128 v251 = (void **)v228[2];
            BOOL v252 = *v251 == v228;
            id v228 = v251;
          }

          while (!v252);
        }

        id v228 = v251;
      }

      while (v251 != &v315);
    }

    v358[0].__r_.__value_.__r.__words[0] = -1LL;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, v358);
    v358[0].__r_.__value_.__r.__words[0] = *((void *)&v318 + 1);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, v358);
    for (uint64_t i1 = (uint64_t *)v318; i1; uint64_t i1 = (uint64_t *)*i1)
    {
      std::string::size_type v254 = *((unsigned __int8 *)i1 + 39);
      if ((v254 & 0x80u) != 0LL) {
        std::string::size_type v254 = i1[3];
      }
      v358[0].__r_.__value_.__r.__words[0] = v254;
      ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, v358);
      int v255 = *((char *)i1 + 39);
      if (v255 >= 0) {
        __int128 v256 = i1 + 2;
      }
      else {
        __int128 v256 = (_BYTE *)i1[2];
      }
      if (v255 >= 0) {
        uint64_t v257 = *((unsigned __int8 *)i1 + 39);
      }
      else {
        uint64_t v257 = i1[3];
      }
      ShaderDebugger::Metadata::MDSerializer::write((unint64_t *)&v307, v256, v257);
      std::string::size_type v258 = *((unsigned __int8 *)i1 + 63);
      if ((v258 & 0x80u) != 0LL) {
        std::string::size_type v258 = i1[6];
      }
      v358[0].__r_.__value_.__r.__words[0] = v258;
      ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)&v307, v358);
      int v259 = *((char *)i1 + 63);
      if (v259 >= 0) {
        __int128 v260 = i1 + 5;
      }
      else {
        __int128 v260 = (_BYTE *)i1[5];
      }
      if (v259 >= 0) {
        uint64_t v261 = *((unsigned __int8 *)i1 + 63);
      }
      else {
        uint64_t v261 = i1[6];
      }
      ShaderDebugger::Metadata::MDSerializer::write((unint64_t *)&v307, v260, v261);
    }

    __int128 v180 = v320;
  }

  __int128 v263 = (void *)v339;
  if ((void)v339)
  {
    do
    {
      __int128 v264 = (void *)*v263;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>>,0>((uint64_t)(v263 + 2));
      operator delete(v263);
      __int128 v263 = v264;
    }

    while (v264);
  }

  __int128 v265 = (void *)v338;
  *(void *)&__int128 v338 = 0LL;
  if (v265) {
    operator delete(v265);
  }
  __int128 v266 = v307;
  if (v307 == v308)
  {
    id v275 = GTShaderDebuggerMDSerializerError(2u, @"Metadata serialization error");
    id v278 = (id)objc_claimAutoreleasedReturnValue(v275);
    __int128 v180 = 0LL;
    __int128 v262 = 0LL;
    if (v266) {
LABEL_458:
    }
      operator delete(v266);
  }

  else
  {
    __int128 v262 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  v307,  v308 - (_BYTE *)v307));
    if (v266) {
      goto LABEL_458;
    }
  }

  ShaderDebugger::Metadata::MDSerializer::~MDSerializer((ShaderDebugger::Metadata::MDSerializer *)&v314);
LABEL_460:
  std::__hash_table<std::__hash_value_type<unsigned int,std::string>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::string>>>::~__hash_table((uint64_t)&__p);
  v358[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v325;
  std::vector<std::unique_ptr<llvm::Module>>::__destroy_vector::operator()[abi:nn180100]((void ***)v358);
  llvm::LLVMContext::~LLVMContext((llvm::LLVMContext *)v327);
  llvm::SmallVector<llvm::SMFixIt,4u>::~SmallVector(v356);
  if ((void)v354)
  {
    *((void *)&v354 + 1) = v354;
    operator delete((void *)v354);
  }

  if (SHIBYTE(v353) < 0) {
    operator delete(*((void **)&v352 + 1));
  }
  if (SBYTE7(v352) < 0) {
    operator delete((void *)v351);
  }
  if (SBYTE7(v349) < 0) {
    operator delete((void *)v348);
  }

  id v267 = v278;
  unsigned int v268 = v267;
  if (v262)
  {
    objc_storeStrong((id *)(v291 + 152), v262);
    *(void *)(v291 + 160) = v180;
  }

  else
  {
    uint64_t v269 = objc_claimAutoreleasedReturnValue([v267 localizedDescription]);
    __int128 v270 = (void *)v269;
    __int128 v271 = @"Unknown error";
    if (v269) {
      __int128 v271 = (__CFString *)v269;
    }
    __int128 v272 = v271;

    NSErrorUserInfoKey v273 = (void *)objc_claimAutoreleasedReturnValue([@"Failed to process debug information: " stringByAppendingString:v272]);
    if (v277)
    {
      id v274 = GTShaderDebuggerMakeError( 4u,  v273,  @"Try updating your target device to the latest OS version or try matching your deployment target version to the target device",  0LL,  0LL);
      void *v277 = (id)objc_claimAutoreleasedReturnValue(v274);
    }
  }

  id v7 = v279;
  if (!v262)
  {
    uint64_t v8 = 0LL;
    goto LABEL_176;
  }

void sub_1717B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char **a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (v66) {
    operator delete(v66);
  }
  ShaderDebugger::Metadata::MDSerializer::~MDSerializer((ShaderDebugger::Metadata::MDSerializer *)&a66);
  std::__hash_table<std::__hash_value_type<unsigned int,std::string>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::string>>>::~__hash_table((uint64_t)&STACK[0x230]);
  STACK[0x6A8] = (unint64_t)&STACK[0x260];
  std::vector<std::unique_ptr<llvm::Module>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x6A8]);
  llvm::LLVMContext::~LLVMContext((llvm::LLVMContext *)&STACK[0x280]);
  llvm::SmallVector<llvm::SMFixIt,4u>::~SmallVector(a11);
  id v68 = (void *)STACK[0x5D8];
  if (STACK[0x5D8])
  {
    STACK[0x5E0] = (unint64_t)v68;
    operator delete(v68);
  }

  if (SLOBYTE(STACK[0x5D7]) < 0) {
    operator delete((void *)STACK[0x5C0]);
  }
  if (SLOBYTE(STACK[0x5BF]) < 0) {
    operator delete((void *)STACK[0x5A8]);
  }
  if (SLOBYTE(STACK[0x597]) < 0) {
    operator delete((void *)STACK[0x580]);
  }

  _Unwind_Resume(a1);
}

uint64_t GTShaderDebuggerMakePSOCompute(uint64_t a1, void *a2, uint64_t a3, apr_allocator_t *a4)
{
  id v6 = *(void **)a1;
  id v74 = *(id *)(*(void *)a1 + 8LL);
  id v73 = (void *)objc_claimAutoreleasedReturnValue([v74 defaultDevice]);
  id v7 = *(uint64_t **)(*v6 + 40LL);
  id v8 = [*(id *)(a1 + 96) mutableCopy];
  uint64_t v70 = v6[1422];
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(*v6 + 40LL), v70, **(void **)(a1 + 88));
  GTMTLSMComputePipelineState_computePipelineDescriptor(v7, (uint64_t)Object, v83, newpool);
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v74 computePipelineDescriptorMap]);
  id v11 = [v10 mutableCopy];

  __int128 v81 = 0u;
  __int128 v82 = 0u;
  __int128 v79 = 0u;
  __int128 v80 = 0u;
  id v12 = v8;
  id v13 = [v12 countByEnumeratingWithState:&v79 objects:v86 count:16];
  if (v13)
  {
    uint64_t v14 = *(void *)v80;
    do
    {
      for (uint64_t i = 0LL; (id)i != v13; ++i)
      {
        if (*(void *)v80 != v14) {
          objc_enumerationMutation(v12);
        }
        uint64_t v15 = *(void *)(*((void *)&v79 + 1) + 8 * i);
        id v16 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v15]);
        if (([v16 conformsToProtocol:&OBJC_PROTOCOL___MTLFunction] & 1) != 0
          || [v16 conformsToProtocol:&OBJC_PROTOCOL___MTLDynamicLibrary])
        {
          [v11 setObject:v16 forKeyedSubscript:v15];
        }
      }

      id v13 = [v12 countByEnumeratingWithState:&v79 objects:v86 count:16];
    }

    while (v13);
  }

  MTLComputePipelineDescriptorWithoutResourceIndex = MakeMTLComputePipelineDescriptorWithoutResourceIndex( (uint64_t)v83,  v11);
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptorWithoutResourceIndex);
  id v19 = (void *)objc_claimAutoreleasedReturnValue([v74 computePipelineStateForKey:v70]);
  objc_msgSend(v18, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v19, "maxTotalThreadsPerThreadgroup"));

  if ((GT_SUPPORT_0 & 0x10000) != 0) {
    [v18 setDriverCompilerOptions:(unint64_t)&off_5A0330 & ((uint64_t)(*(void *)(a1 + 208) << 59) >> 63)];
  }
  uint64_t v20 = *(void *)(a1 + 208);
  if ((v20 & 4) != 0)
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v18 computeFunction]);
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v18 preloadedLibraries]);
    PreloadedDylibsForGlobalRelocatiouint64_t n = _GetPreloadedDylibsForGlobalRelocation(a1, v21, v22, a2);
    id v24 = (void *)objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalRelocation);

    if (!v24) {
      goto LABEL_28;
    }
    [v18 setPreloadedLibraries:v24];
    uint64_t v25 = (char *)[v24 count];
    if (v84 <= 1u) {
      uint64_t v26 = 1LL;
    }
    else {
      uint64_t v26 = v84;
    }
    [v18 setMaxCallStackDepth:&v25[v26]];

    uint64_t v20 = *(void *)(a1 + 208);
  }

  if ((v20 & 2) == 0) {
    goto LABEL_25;
  }
  id v27 = (void *)objc_claimAutoreleasedReturnValue([v18 preloadedLibraries]);
  id PreloadedDylibsForGlobalBinding = _GetPreloadedDylibsForGlobalBinding(a1, v27, a2);
  id v29 = (void *)objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalBinding);

  if (v29)
  {
    [v18 setPreloadedLibraries:v29];
    uint64_t v30 = (char *)[v29 count];
    if (v84 <= 1u) {
      uint64_t v31 = 1LL;
    }
    else {
      uint64_t v31 = v84;
    }
    [v18 setMaxCallStackDepth:&v30[v31]];

    uint64_t v20 = *(void *)(a1 + 208);
LABEL_25:
    if ((v20 & 6) == 0)
    {
      id v32 = (void *)objc_claimAutoreleasedReturnValue([v74 computePipelineDescriptorMap]);
      id v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v83[106]));
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:v33]);

      if (v34) {
        uint64_t i = (uint64_t)[v73 loadDynamicLibrariesForFunction:v34 insertLibraries:&__NSArray0__struct error:0];
      }
      else {
        uint64_t i = 0LL;
      }
      if ([(id)i count])
      {
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v18 preloadedLibraries]);
        id v38 = [v37 mutableCopy];

        [v38 addObjectsFromArray:i];
        id v39 = [v38 copy];
        [v18 setPreloadedLibraries:v39];

        id v40 = (char *)[v38 count];
        if (v84 <= 1u) {
          uint64_t v41 = 1LL;
        }
        else {
          uint64_t v41 = v84;
        }
        [v18 setMaxCallStackDepth:&v40[v41]];
      }
    }

    id v77 = 0LL;
    id v78 = 0LL;
    id v42 = [v73 newComputePipelineStateWithDescriptor:v18 options:0x200000 reflection:&v78 error:&v77];
    id v72 = v78;
    id v43 = v77;
    id v35 = v43;
    if (v42 || [v43 code] != (char *)&dword_0 + 3)
    {
      int v44 = 0;
    }

    else
    {
      uint64_t i = objc_claimAutoreleasedReturnValue([v35 domain]);
      if ([(id)i containsString:@"CompilerError"])
      {

        goto LABEL_50;
      }

      int v44 = 1;
    }

    if ([v35 code] != &dword_4)
    {
      if ((v44 & 1) != 0) {
LABEL_53:
      }

LABEL_54:
      if (v42)
      {
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v70));
        [v12 setObject:v42 forKeyedSubscript:v50];

        unsigned int v51 = [v72 traceBufferIndex];
        if (v51 == -1) {
          uint64_t CurrentEncoderFreeBindingSlotIndex = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t CurrentEncoderFreeBindingSlotIndex = v51;
        }
        if ((*(_BYTE *)(a1 + 208) & 2) != 0) {
          uint64_t CurrentEncoderFreeBindingSlotIndex = _GetCurrentEncoderFreeBindingSlotIndex((void *)(a1 + 8));
        }
        if (CurrentEncoderFreeBindingSlotIndex != 0x7FFFFFFFFFFFFFFFLL || (*(_BYTE *)(a1 + 208) & 4) != 0)
        {
          id v54 = [v12 copy];
          uint64_t v55 = *(void **)(a1 + 96);
          *(void *)(a1 + 96) = v54;

          id v56 = (void *)objc_claimAutoreleasedReturnValue([v72 constantSamplerUniqueIdentifiers]);
          id v57 = (void *)objc_claimAutoreleasedReturnValue([v72 constantSamplerDescriptors]);
          ConstantSamplers = _MakeConstantSamplers(v56, v57);
          uint64_t v59 = objc_claimAutoreleasedReturnValue(ConstantSamplers);
          id v60 = *(void **)(a1 + 136);
          *(void *)(a1 + 136) = v59;

          id v61 = (void *)objc_claimAutoreleasedReturnValue([v72 bindings]);
          id Bindings = _MakeBindings(v61);
          uint64_t v63 = objc_claimAutoreleasedReturnValue(Bindings);
          id v64 = *(void **)(a1 + 128);
          *(void *)(a1 + 12_Block_object_dispose(va, 8) = v63;

          *(void *)(a1 + 144) = CurrentEncoderFreeBindingSlotIndex;
          uint64_t v36 = 1LL;
          goto LABEL_74;
        }

        if (a2)
        {
          id Error = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to set up GPU data buffer",  0LL,  0LL,  0LL);
          uint64_t v36 = 0LL;
          *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
LABEL_74:

          goto LABEL_75;
        }
      }

      else if (a2)
      {
        id v65 = (void *)objc_claimAutoreleasedReturnValue([v35 description]);
        if ([v65 localizedCaseInsensitiveContainsString:@"Undefined symbol"])
        {
          *a2 = v35;
        }

        else
        {
          if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
            unsigned int v66 = 4;
          }
          else {
            unsigned int v66 = 2;
          }
          id v67 = GTShaderDebuggerMakeError( v66,  @"Failed to set up compute pipeline state for debugging",  0LL,  v35,  0LL);
          id v68 = objc_claimAutoreleasedReturnValue(v67);
          *a2 = v68;
        }
      }

      uint64_t v36 = 0LL;
      goto LABEL_74;
    }

    id v45 = (void *)objc_claimAutoreleasedReturnValue([v35 domain]);
    unsigned int v46 = [v45 containsString:@"AGXMetal"];

    if (v44)
    {

      if ((v46 & 1) == 0) {
        goto LABEL_54;
      }
    }

    else if (!v46)
    {
      goto LABEL_54;
    }

LABEL_50:
    if ((GT_SUPPORT_0 & 0x4000) != 0 && [v18 maxTotalThreadsPerThreadgroup] == &stru_3D8.size)
    {
      [v18 setMaxTotalThreadsPerThreadgroup:512];
      id v75 = v35;
      id v76 = v72;
      id v47 = [v73 newComputePipelineStateWithDescriptor:v18 options:0x200000 reflection:&v76 error:&v75];
      id v48 = v76;

      id v49 = v75;
      uint64_t i = (uint64_t)v42;
      id v35 = v49;
      id v72 = v48;
      id v42 = v47;
      goto LABEL_53;
    }

    goto LABEL_54;
  }

    llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput>::operator++(&v41);
    this = v41;
    a3 = v42;
    if (v41 == v4 && v42 == v5) {
      return this;
    }
  }

  this = (void ***)fwrite("Unexpected instruction found", 0x1CuLL, 1uLL, __stderrp);
  if (v9) {
    return (void ***)(*(uint64_t (**)(char *))(*(void *)v9 + 8LL))(v9);
  }
  return this;
}

void sub_1720CC(_Unwind_Exception *a1)
{
}

id _GetPreloadedDylibsForGlobalRelocation(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = *(id *)(*(void *)a1 + 8LL);
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 defaultDevice]);
  id v11 = *(id *)(a1 + 112);
  if (![v11 count])
  {
    if (a4)
    {
      if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
        unsigned int v18 = 4;
      }
      else {
        unsigned int v18 = 1;
      }
      id Error = GTShaderDebuggerMakeError(v18, @"Internal error: debug dylib not found", 0LL, 0LL, 0LL);
      uint64_t v20 = 0LL;
      *a4 = (id)objc_claimAutoreleasedReturnValue(Error);
    }

    else
    {
      uint64_t v20 = 0LL;
    }

    goto LABEL_44;
  }

  id v54 = a4;
  uint64_t v55 = a1;
  id v57 = 0LL;
  id v12 = v10;
  id v13 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  -[MTLCompileOptions setLibraryType:](v13, "setLibraryType:", 1LL);
  -[MTLCompileOptions setLanguageVersion:](v13, "setLanguageVersion:", 131076LL);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"@executable_path/%@.metallib",  @"libtracebuffer_gr"));
  -[MTLCompileOptions setInstallName:](v13, "setInstallName:", v14);

  -[MTLCompileOptions setCompileSymbolVisibility:](v13, "setCompileSymbolVisibility:", 1LL);
  -[MTLCompileOptions setAdditionalCompilerArguments:]( v13,  "setAdditionalCompilerArguments:",  @"-fexternally-initialized");
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "extern device void * constant trace_buffer [[ clang::externally_initialized ]] __asm(trace.buffer);\n"
                    "extern C {\n"
                    "  [[gnu::visibility(default)]] device void *__tracepoint_get_trace_buffer() {\n"
                    "    return trace_buffer;\n"
                    "  }\n"
                    "}\n"));
  id v16 = [v12 newLibraryWithSource:v15 options:v13 error:&v57];

  if (v16) {
    id v17 = [v12 newDynamicLibrary:v16 error:&v57];
  }
  else {
    id v17 = 0LL;
  }

  id v21 = v57;
  if (!v17)
  {
    if (v54)
    {
      if ((*(void *)(v55 + 208) & 0x10LL) != 0) {
        unsigned int v41 = 4;
      }
      else {
        unsigned int v41 = 1;
      }
      id v42 = GTShaderDebuggerMakeError(v41, @"Internal error: debug dylib setup failed", 0LL, v21, 0LL);
      uint64_t v20 = 0LL;
      *id v54 = (id)objc_claimAutoreleasedReturnValue(v42);
    }

    else
    {
      uint64_t v20 = 0LL;
    }

    id v39 = v21;
    goto LABEL_43;
  }

  uint64_t v22 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  -[NSMutableArray addObjectsFromArray:](v22, "addObjectsFromArray:", v8);
  -[NSMutableArray addObjectsFromArray:](v22, "addObjectsFromArray:", v11);
  id v53 = v17;
  -[NSMutableArray addObject:](v22, "addObject:", v17);
  id v23 = [[MTLBufferRelocation alloc] initWithSymbolName:@"trace.buffer" buffer:*(void *)(v55 + 184) offset:0];
  unsigned int v51 = v21;
  id v56 = v21;
  id v24 = v23;
  id v52 = v22;
  id v25 = [v12 loadDynamicLibrariesForFunction:v7 insertLibraries:v22 error:&v56];
  uint64_t v20 = v25;
  if (!v25) {
    goto LABEL_27;
  }
  id v47 = v11;
  id v48 = v10;
  id v49 = v9;
  id v50 = v8;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  id v46 = v25;
  id v26 = v25;
  id v27 = [v26 countByEnumeratingWithState:&v58 objects:v63 count:16];
  if (!v27) {
    goto LABEL_26;
  }
  id v28 = v27;
  uint64_t v29 = *(void *)v59;
  do
  {
    for (uint64_t i = 0LL; i != v28; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v59 != v29) {
        objc_enumerationMutation(v26);
      }
      uint64_t v31 = *(void **)(*((void *)&v58 + 1) + 8LL * (void)i);
      id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 installName]);
      if ([v32 containsString:@"libtracepoint"])
      {
      }

      else
      {
        id v33 = (void *)objc_claimAutoreleasedReturnValue([v31 installName]);
        unsigned int v34 = [v33 containsString:@"libtracebuffer_gr"];

        if (!v34) {
          continue;
        }
      }

      id v35 = (void *)objc_claimAutoreleasedReturnValue([v31 relocations]);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = objc_claimAutoreleasedReturnValue([v35 arrayByAddingObject:v24]);
      }

      else
      {
        id v62 = v24;
        uint64_t v37 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v62, 1LL));
      }

      id v38 = (void *)v37;
      [v31 setRelocations:v37];
    }

    id v28 = [v26 countByEnumeratingWithState:&v58 objects:v63 count:16];
  }

  while (v28);
LABEL_26:

  id v8 = v50;
  id v10 = v48;
  id v9 = v49;
  uint64_t v20 = v46;
  id v11 = v47;
LABEL_27:

  id v39 = v56;
  if (v20)
  {
    id v40 = v20;
  }

  else if (v54)
  {
    if ((*(void *)(v55 + 208) & 0x10LL) != 0) {
      unsigned int v43 = 4;
    }
    else {
      unsigned int v43 = 1;
    }
    id v44 = GTShaderDebuggerMakeError(v43, @"Internal error: could not load debug dylib", 0LL, v39, 0LL);
    *id v54 = (id)objc_claimAutoreleasedReturnValue(v44);
  }

  id v17 = v53;
LABEL_43:

LABEL_44:
  return v20;
}

id _GetPreloadedDylibsForGlobalBinding(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = *(id *)(*(void *)a1 + 8LL);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 defaultDevice]);
  id v8 = *(id *)(a1 + 112);
  if (![v8 count])
  {
    if (a3)
    {
      if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
        unsigned int v11 = 4;
      }
      else {
        unsigned int v11 = 1;
      }
      id v10 = @"Internal error: debug dylib not found";
      goto LABEL_10;
    }

uint64_t _GetCurrentEncoderFreeBindingSlotIndex(void *a1)
{
  uint64_t v2 = 30LL;
  while (1)
  {
    os_signpost_id_t v3 = (void *)a1[3];
    id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v4]);
    if (!v5) {
      break;
    }
LABEL_7:

LABEL_8:
    uint64_t v2 = (v2 - 1);
    if ((_DWORD)v2 == -1) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  id v6 = (void *)a1[2];
  id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v5]);
  if (v7)
  {
LABEL_6:

    goto LABEL_7;
  }

  id v8 = (void *)a1[6];
  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v9]);
  if (v10)
  {

    id v7 = 0LL;
    goto LABEL_6;
  }

  unsigned int v11 = (void *)a1[7];
  id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
  id v13 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v12]);

  if (v13) {
    goto LABEL_8;
  }
  if ((v2 & 0x80000000) == 0) {
    return v2;
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

NSMutableDictionary *_MakeConstantSamplers(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 count];
  if (v5 == [v4 count])
  {
    id v6 = (char *)[v4 count];
    id v7 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  v6);
    id v8 = v7;
    if (v6)
    {
      id v9 = 0LL;
      id v22 = v7;
      do
      {
        id v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "objectAtIndexedSubscript:", v9, v22));
        MakeGTMTLSamplerDescriptor((uint64_t)v34, v10);

        id v33 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v9]);
        v50[0] = @"borderColor";
        id v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v39));
        v51[0] = v32;
        v50[1] = @"compareFunction";
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v40));
        v51[1] = v31;
        v50[2] = @"lodMinClamp";
        LODWORD(v11) = v37;
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v11));
        v51[2] = v30;
        v50[3] = @"lodMaxClamp";
        LODWORD(v12) = v36;
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v12));
        v51[3] = v29;
        v50[4] = @"lodAverage";
        id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v41));
        v51[4] = v28;
        v50[5] = @"minFilter";
        id v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v43));
        v51[5] = v27;
        v50[6] = @"magFilter";
        id v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v42));
        v51[6] = v26;
        v50[7] = @"mipFilter";
        unsigned int v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v44));
        v51[7] = v25;
        v50[8] = @"maxAnisotropy";
        id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v35));
        v51[8] = v24;
        v50[9] = @"normalizedCoordinates";
        id v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v45));
        v51[9] = v23;
        v50[10] = @"pixelFormat";
        id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v38));
        v51[10] = v13;
        v50[11] = @"reductionMode";
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v47));
        v51[11] = v14;
        v50[12] = @"rAddressMode";
        id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v46));
        v51[12] = v15;
        v50[13] = @"sAddressMode";
        id v16 = v4;
        id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v48));
        v51[13] = v17;
        v50[14] = @"tAddressMode";
        id v18 = v3;
        id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v49));
        v51[14] = v19;
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v51,  v50,  15LL));

        id v3 = v18;
        id v4 = v16;

        id v8 = v22;
        -[NSMutableDictionary setObject:forKeyedSubscript:](v22, "setObject:forKeyedSubscript:", v20, v33);

        ++v9;
      }

      while (v6 != v9);
    }
  }

  else
  {
    id v8 = (NSMutableDictionary *)&__NSDictionary0__struct;
  }

  return v8;
}

id _MakeBindings(void *a1)
{
  id v1 = a1;
  id v18 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  id v2 = v1;
  id v3 = [v2 countByEnumeratingWithState:&v19 objects:v25 count:16];
  if (v3)
  {
    id v4 = v3;
    id v5 = @"__resource_tracking_impl_trace_buffer";
    uint64_t v6 = *(void *)v20;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v20 != v6) {
          objc_enumerationMutation(v2);
        }
        id v8 = *(void **)(*((void *)&v19 + 1) + 8LL * (void)i);
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 name]);
        if (([v9 isEqualToString:@"trace.buffer"] & 1) == 0
          && ([v9 isEqualToString:v5] & 1) == 0)
        {
          v23[0] = @"index";
          id v10 = v2;
          double v11 = v5;
          double v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v8 index]));
          v24[0] = v12;
          v23[1] = @"type";
          id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInteger:]( NSNumber,  "numberWithInteger:",  [v8 type]));
          v24[1] = v13;
          v23[2] = @"used";
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  [v8 isUsed]));
          v23[3] = @"name";
          v24[2] = v14;
          v24[3] = v9;
          id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v24,  v23,  4LL));
          -[NSMutableArray addObject:](v18, "addObject:", v15);

          id v5 = v11;
          id v2 = v10;
        }
      }

      id v4 = [v2 countByEnumeratingWithState:&v19 objects:v25 count:16];
    }

    while (v4);
  }

  id v16 = -[NSMutableArray copy](v18, "copy");
  return v16;
}

uint64_t GTShaderDebuggerMakePSORender(id *a1, void *a2)
{
  id v3 = *a1;
  id v4 = *((id *)*a1 + 1);
  BOOL v221 = (void *)objc_claimAutoreleasedReturnValue([v4 defaultDevice]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([a1[24] objectForKeyedSubscript:@"ROI"]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"Type"]);
  uint64_t v216 = (char *)[v6 integerValue];

  id v7 = [a1[12] mutableCopy];
  uint64_t v220 = (uint64_t)a1;
  uint64_t v218 = v3[2489];
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(*(void *)*a1 + 40LL), v218, *(void *)a1[11]);
  uint64_t v217 = v4;
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v4 renderPipelineDescriptorMap]);
  id v10 = [v9 mutableCopy];

  __int128 v232 = 0u;
  __int128 v233 = 0u;
  __int128 v230 = 0u;
  __int128 v231 = 0u;
  id v11 = v7;
  id v12 = [v11 countByEnumeratingWithState:&v230 objects:v234 count:16];
  if (v12)
  {
    id v13 = v12;
    uint64_t v14 = *(void *)v231;
    do
    {
      for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v231 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v16 = *(void *)(*((void *)&v230 + 1) + 8LL * (void)i);
        id v17 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v16]);
        if (([v17 conformsToProtocol:&OBJC_PROTOCOL___MTLFunction] & 1) != 0
          || [v17 conformsToProtocol:&OBJC_PROTOCOL___MTLDynamicLibrary])
        {
          [v10 setObject:v17 forKeyedSubscript:v16];
        }
      }

      id v13 = [v11 countByEnumeratingWithState:&v230 objects:v234 count:16];
    }

    while (v13);
  }

  uint64_t v18 = Object[8];
  if (!v18)
  {
    uint64_t v42 = Object[9];
    __int128 v21 = v217;
    if (!v42)
    {
      id v67 = (unsigned __int16 *)Object[6];
      id v68 = v216;
      if (!v67)
      {

        id v110 = 0LL;
        id v24 = v221;
        goto LABEL_182;
      }

      MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex( Object[6],  v10);
      __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);
      uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v217 renderPipelineDescriptorMap]);
      id v24 = v221;
      id v215 = v70;
      if (v216 == (_BYTE *)&dword_0 + 2)
      {
        id v71 = _ObjectArrayWithMap(*((uint64_t **)v67 + 135), *((void *)v67 + 136), v70);
        id v72 = (void *)objc_claimAutoreleasedReturnValue(v71);
        id v73 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexLinkedFunctions]);
        [v73 setFunctions:v72];

        id v74 = _ObjectArrayWithMap(*((uint64_t **)v67 + 139), *((void *)v67 + 140), v70);
        id v75 = (void *)objc_claimAutoreleasedReturnValue(v74);
        id v76 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexLinkedFunctions]);
        [v76 setPrivateFunctions:v75];

        id v77 = _ObjectArrayWithMap(*((uint64_t **)v67 + 133), *((void *)v67 + 134), v70);
        id v78 = (void *)objc_claimAutoreleasedReturnValue(v77);
        __int128 v79 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexLinkedFunctions]);
        [v79 setBinaryFunctions:v78];

        id v80 = _ObjectArrayWithMap(*((uint64_t **)v67 + 163), *((void *)v67 + 164), v70);
        __int128 v81 = (void *)objc_claimAutoreleasedReturnValue(v80);
        [v20 setVertexPreloadedLibraries:v81];
      }

      else
      {
        id v111 = _ObjectArrayWithMap(*((uint64_t **)v67 + 111), *((void *)v67 + 112), v70);
        id v112 = (void *)objc_claimAutoreleasedReturnValue(v111);
        uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v113 setFunctions:v112];

        id v114 = _ObjectArrayWithMap(*((uint64_t **)v67 + 115), *((void *)v67 + 116), v70);
        id v115 = (void *)objc_claimAutoreleasedReturnValue(v114);
        id v116 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v116 setPrivateFunctions:v115];

        id v117 = _ObjectArrayWithMap(*((uint64_t **)v67 + 109), *((void *)v67 + 110), v70);
        uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue(v117);
        uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v119 setBinaryFunctions:v118];

        id v120 = _ObjectArrayWithMap(*((uint64_t **)v67 + 148), *((void *)v67 + 149), v70);
        __int128 v81 = (void *)objc_claimAutoreleasedReturnValue(v120);
        [v20 setFragmentPreloadedLibraries:v81];
      }

      id v23 = (void *)v220;
      if ((GT_SUPPORT_0 & 0x8000) != 0) {
        [v20 setDriverCompilerOptions:(unint64_t)&off_5A0380 & ((uint64_t)(*(void *)(v220 + 208) << 59) >> 63)];
      }
      uint64_t v121 = *(void *)(v220 + 208);
      if ((v121 & 4) != 0)
      {
        if (v216 == (_BYTE *)&dword_0 + 2)
        {
          id v102 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentFunction]);
          id v122 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentPreloadedLibraries]);
        }

        else
        {
          id v102 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexFunction]);
          id v122 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexPreloadedLibraries]);
        }

        int v141 = v122;
        PreloadedDylibsForGlobalRelocatiouint64_t n = _GetPreloadedDylibsForGlobalRelocation(v220, v102, v122, a2);
        uint64_t v146 = objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalRelocation);
        if (!v146) {
          goto LABEL_80;
        }
        unint64_t v147 = (void *)v146;
        if (v216 == (_BYTE *)&dword_0 + 2)
        {
          [v20 setFragmentPreloadedLibraries:v146];
          unint64_t v148 = (char *)[v147 count];
          if (v67[672] <= 1u) {
            uint64_t v149 = 1LL;
          }
          else {
            uint64_t v149 = v67[672];
          }
          [v20 setMaxFragmentCallStackDepth:&v148[v149]];
        }

        else
        {
          [v20 setVertexPreloadedLibraries:v146];
          id v155 = (char *)[v147 count];
          if (v67[675] <= 1u) {
            uint64_t v156 = 1LL;
          }
          else {
            uint64_t v156 = v67[675];
          }
          [v20 setMaxVertexCallStackDepth:&v155[v156]];
        }

        id v23 = (void *)v220;
        uint64_t v121 = *(void *)(v220 + 208);
        id v68 = v216;
      }

      if ((v121 & 2) != 0)
      {
        if (v68 == (_BYTE *)&dword_0 + 2) {
          JSObjectRef v157 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentPreloadedLibraries]);
        }
        else {
          JSObjectRef v157 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexPreloadedLibraries]);
        }
        id v102 = v157;
        id PreloadedDylibsForGlobalBinding = _GetPreloadedDylibsForGlobalBinding((uint64_t)v23, v157, a2);
        uint64_t v159 = objc_claimAutoreleasedReturnValue(PreloadedDylibsForGlobalBinding);
        if (!v159) {
          goto LABEL_119;
        }
        BOOL v160 = (void *)v159;
        if (v68 == (_BYTE *)&dword_0 + 2)
        {
          [v20 setFragmentPreloadedLibraries:v159];
          unint64_t v161 = (char *)[v160 count];
          if (v67[672] <= 1u) {
            uint64_t v162 = 1LL;
          }
          else {
            uint64_t v162 = v67[672];
          }
          [v20 setMaxFragmentCallStackDepth:&v161[v162]];
        }

        else
        {
          [v20 setVertexPreloadedLibraries:v159];
          int8x8_t v163 = (char *)[v160 count];
          if (v67[675] <= 1u) {
            uint64_t v164 = 1LL;
          }
          else {
            uint64_t v164 = v67[675];
          }
          [v20 setMaxVertexCallStackDepth:&v163[v164]];
        }

        id v23 = (void *)v220;
        uint64_t v121 = *(void *)(v220 + 208);
      }

      if ((v121 & 6) == 0)
      {
        uint64_t v165 = 648LL;
        if (v68 == (_BYTE *)&dword_0 + 2) {
          uint64_t v165 = 588LL;
        }
        uint64_t v166 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)&v67[v165]));
        __int128 v167 = (void *)objc_claimAutoreleasedReturnValue([v215 objectForKeyedSubscript:v166]);

        if (v167) {
          id v168 = [v221 loadDynamicLibrariesForFunction:v167 insertLibraries:&__NSArray0__struct error:0];
        }
        else {
          id v168 = 0LL;
        }
        if ([v168 count])
        {
          int v214 = v167;
          if (v216 == (_BYTE *)&dword_0 + 2)
          {
            __int128 v180 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentPreloadedLibraries]);
            id v181 = [v180 mutableCopy];

            id v213 = v181;
            [v181 addObjectsFromArray:v168];
            id v182 = [v168 copy];
            [v20 setFragmentPreloadedLibraries:v182];

            unint64_t v183 = (char *)[v168 count];
            if (v67[672] <= 1u) {
              uint64_t v184 = 1LL;
            }
            else {
              uint64_t v184 = v67[672];
            }
            [v20 setMaxFragmentCallStackDepth:&v183[v184]];
          }

          else
          {
            uint8x8_t v185 = (void *)objc_claimAutoreleasedReturnValue([v20 vertexPreloadedLibraries]);
            id v186 = [v185 mutableCopy];

            id v213 = v186;
            [v186 addObjectsFromArray:v168];
            id v187 = [v168 copy];
            [v20 setVertexPreloadedLibraries:v187];

            __int128 v188 = (char *)[v168 count];
            if (v67[675] <= 1u) {
              uint64_t v189 = 1LL;
            }
            else {
              uint64_t v189 = v67[675];
            }
            [v20 setMaxVertexCallStackDepth:&v188[v189]];
          }

          __int128 v167 = v214;
        }

        id v68 = v216;
      }

      if ([v221 supportsFamily:1009])
      {
        if (v68 == (_BYTE *)&dword_0 + 2) {
          objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v20, "maxFragmentCallStackDepth") + 1);
        }
        else {
          objc_msgSend(v20, "setMaxVertexCallStackDepth:", (char *)objc_msgSend(v20, "maxVertexCallStackDepth") + 1);
        }
      }

      id v222 = 0LL;
      id v223 = 0LL;
      id v109 = [v221 newRenderPipelineStateWithDescriptor:v20 options:0x200000 reflection:&v223 error:&v222];
      id v110 = v223;
      uint64_t v179 = v222;
      goto LABEL_169;
    }

    MTLMeshRenderPipelineDescriptorWithoutResourceIndex = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex( Object[9],  v10);
    __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptorWithoutResourceIndex);
    [v20 setMaxTotalThreadsPerObjectThreadgroup:*(unsigned __int16 *)(v42 + 406)];
    [v20 setMaxTotalThreadsPerMeshThreadgroup:*(unsigned __int16 *)(v42 + 404)];
    uint64_t v44 = *(void *)(v42 + 336);
    __int128 v226 = *(_OWORD *)(v42 + 320);
    uint64_t v227 = v44;
    [v20 setMaxThreadgroupsPerMeshGrid:&v226];
    id v23 = (void *)v220;
    unsigned __int8 v45 = v216;
    if ((GT_SUPPORT_0 & 0x8000) != 0) {
      [v20 setDriverCompilerOptions:(unint64_t)&off_5A0358 & ((uint64_t)(*(void *)(v220 + 208) << 59) >> 63)];
    }
    unsigned __int8 v46 = (void *)objc_claimAutoreleasedReturnValue([v217 renderPipelineDescriptorMap]);
    id v215 = v46;
    if (v216 == (_BYTE *)&dword_0 + 2)
    {
      id v47 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 272), *(void *)(v42 + 280), v46);
      unsigned __int8 v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
      unsigned __int8 v49 = (void *)objc_claimAutoreleasedReturnValue([v20 objectLinkedFunctions]);
      [v49 setFunctions:v48];

      id v50 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 304), *(void *)(v42 + 312), v46);
      unsigned int v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
      id v52 = (void *)objc_claimAutoreleasedReturnValue([v20 objectLinkedFunctions]);
      [v52 setPrivateFunctions:v51];

      id v53 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 256), *(void *)(v42 + 264), v46);
      id v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v20 objectLinkedFunctions]);
      [v55 setBinaryFunctions:v54];

      id v56 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 208), *(void *)(v42 + 216), v46);
      id v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
      __int128 v58 = (void *)objc_claimAutoreleasedReturnValue([v20 meshLinkedFunctions]);
      [v58 setFunctions:v57];

      id v59 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 240), *(void *)(v42 + 248), v46);
      __int128 v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
      __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v20 meshLinkedFunctions]);
      [v61 setPrivateFunctions:v60];

      id v62 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 192), *(void *)(v42 + 200), v46);
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
      id v64 = (void *)objc_claimAutoreleasedReturnValue([v20 meshLinkedFunctions]);
      [v64 setBinaryFunctions:v63];

      id v23 = (void *)v220;
      unsigned int v66 = (uint64_t *)(v220 + 208);
      uint64_t v65 = *(void *)(v220 + 208);
      if ((v65 & 4) == 0)
      {
        if ((v65 & 2) == 0)
        {
          if ((v65 & 6) != 0)
          {
            goto LABEL_146;
          }

          int v101 = 0;
          goto LABEL_132;
        }

        int v101 = 0;
        goto LABEL_86;
      }

      id v102 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentFunction]);
      uint64_t v103 = objc_claimAutoreleasedReturnValue([v20 fragmentPreloadedLibraries]);
    }

    else
    {
      if (v216 == (_BYTE *)&dword_4 + 2)
      {
        id v123 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 272), *(void *)(v42 + 280), v46);
        id v124 = (void *)objc_claimAutoreleasedReturnValue(v123);
        id v125 = (void *)objc_claimAutoreleasedReturnValue([v20 objectLinkedFunctions]);
        [v125 setFunctions:v124];

        id v126 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 304), *(void *)(v42 + 312), v46);
        uint64_t v127 = (void *)objc_claimAutoreleasedReturnValue(v126);
        id v128 = (void *)objc_claimAutoreleasedReturnValue([v20 objectLinkedFunctions]);
        [v128 setPrivateFunctions:v127];

        id v129 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 256), *(void *)(v42 + 264), v46);
        unint64_t v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
        unint64_t v131 = (void *)objc_claimAutoreleasedReturnValue([v20 objectLinkedFunctions]);
        [v131 setBinaryFunctions:v130];

        id v132 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 144), *(void *)(v42 + 152), v46);
        __int128 v133 = (void *)objc_claimAutoreleasedReturnValue(v132);
        __int128 v134 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v134 setFunctions:v133];

        id v135 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 176), *(void *)(v42 + 184), v46);
        __int128 v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
        __int128 v137 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v137 setPrivateFunctions:v136];

        id v138 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 128), *(void *)(v42 + 136), v46);
        uint64_t v139 = (void *)objc_claimAutoreleasedReturnValue(v138);
        __int128 v140 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v140 setBinaryFunctions:v139];

        id v23 = (void *)v220;
        unsigned int v66 = (uint64_t *)(v220 + 208);
        uint64_t v100 = *(void *)(v220 + 208);
        if ((v100 & 4) == 0)
        {
          int v101 = 1;
          goto LABEL_84;
        }

        id v102 = (void *)objc_claimAutoreleasedReturnValue([v20 meshFunction]);
        int v141 = (void *)objc_claimAutoreleasedReturnValue([v20 meshPreloadedLibraries]);
        int v101 = 1;
        goto LABEL_66;
      }

      if (v216 == (_BYTE *)&dword_4 + 1)
      {
        id v82 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 208), *(void *)(v42 + 216), v46);
        id v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
        unsigned __int16 v84 = (void *)objc_claimAutoreleasedReturnValue([v20 meshLinkedFunctions]);
        [v84 setFunctions:v83];

        id v85 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 240), *(void *)(v42 + 248), v46);
        BOOL v86 = (void *)objc_claimAutoreleasedReturnValue(v85);
        unint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v20 meshLinkedFunctions]);
        [v87 setPrivateFunctions:v86];

        id v88 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 192), *(void *)(v42 + 200), v46);
        __int128 v89 = (void *)objc_claimAutoreleasedReturnValue(v88);
        int v90 = (void *)objc_claimAutoreleasedReturnValue([v20 meshLinkedFunctions]);
        [v90 setBinaryFunctions:v89];

        id v91 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 144), *(void *)(v42 + 152), v46);
        uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue(v91);
        id v93 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v93 setFunctions:v92];

        id v94 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 176), *(void *)(v42 + 184), v46);
        uint8x8_t v95 = (void *)objc_claimAutoreleasedReturnValue(v94);
        unint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v96 setPrivateFunctions:v95];

        id v97 = _ObjectArrayWithMap(*(uint64_t **)(v42 + 128), *(void *)(v42 + 136), v46);
        uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue(v97);
        BOOL v99 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentLinkedFunctions]);
        [v99 setBinaryFunctions:v98];

        id v23 = (void *)v220;
      }

      unsigned int v66 = v23 + 26;
      uint64_t v100 = v23[26];
      if ((v100 & 4) == 0)
      {
        int v101 = 0;
        goto LABEL_84;
      }

      id v102 = (void *)objc_claimAutoreleasedReturnValue([v20 objectFunction]);
      uint64_t v103 = objc_claimAutoreleasedReturnValue([v20 objectPreloadedLibraries]);
    }

    int v141 = (void *)v103;
    int v101 = 0;
LABEL_66:
    id v142 = _GetPreloadedDylibsForGlobalRelocation((uint64_t)v23, v102, v141, a2);
    uint64_t v143 = objc_claimAutoreleasedReturnValue(v142);
    if (v143)
    {
      id v144 = (void *)v143;
      if (v216 == (_BYTE *)&dword_0 + 2)
      {
        [v20 setFragmentPreloadedLibraries:v143];
        objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v144, "count") + 1);
      }

      else if (v101)
      {
        [v20 setMeshPreloadedLibraries:v143];
        objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v144, "count") + 1);
      }

      else
      {
        [v20 setObjectPreloadedLibraries:v143];
        objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v144, "count") + 1);
      }

      uint64_t v100 = *v66;
      id v23 = (void *)v220;
      unsigned __int8 v45 = v216;
LABEL_84:
      if ((v100 & 2) == 0) {
        goto LABEL_99;
      }
      if (v45 != (_BYTE *)&dword_0 + 2)
      {
        if (v101)
        {
          id v102 = (void *)objc_claimAutoreleasedReturnValue([v20 meshPreloadedLibraries]);
          int v101 = 1;
LABEL_91:
          id v151 = _GetPreloadedDylibsForGlobalBinding((uint64_t)v23, v102, a2);
          uint64_t v152 = objc_claimAutoreleasedReturnValue(v151);
          if (v152)
          {
            unint64_t v153 = (void *)v152;
            if (v45 == (_BYTE *)&dword_0 + 2)
            {
              [v20 setFragmentPreloadedLibraries:v152];
              objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v153, "count") + 1);
            }

            else if (v101)
            {
              [v20 setMeshPreloadedLibraries:v152];
              objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v153, "count") + 1);
            }

            else
            {
              [v20 setObjectPreloadedLibraries:v152];
              objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v153, "count") + 1);
            }

            uint64_t v100 = *v66;
            id v23 = (void *)v220;
LABEL_99:
            if ((v100 & 6) != 0)
            {
LABEL_144:
              if (([v221 supportsFamily:1009] & 1) == 0)
              {
LABEL_150:
                int v224 = 0LL;
                id v225 = 0LL;
                id v24 = v221;
                id v109 = [v221 newRenderPipelineStateWithMeshDescriptor:v20 options:0x200000 reflection:&v225 error:&v224];
                id v110 = v225;
                uint64_t v179 = v224;
LABEL_169:
                id v67 = v179;

                goto LABEL_170;
              }

              if (v45 != (_BYTE *)&dword_0 + 2)
              {
                if (v101) {
                  objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v20, "maxMeshCallStackDepth") + 1);
                }
                else {
                  objc_msgSend( v20,  "setMaxObjectCallStackDepth:",  (char *)objc_msgSend(v20, "maxObjectCallStackDepth") + 1);
                }
                goto LABEL_150;
              }

LABEL_86:
      uint64_t v150 = objc_claimAutoreleasedReturnValue([v20 fragmentPreloadedLibraries]);
      goto LABEL_90;
    }

    id v24 = v221;
LABEL_80:

    goto LABEL_119;
  }

  MTLTileRenderPipelineDescriptor = MakeMTLTileRenderPipelineDescriptor(Object[8], v10);
  __int128 v20 = (void *)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);
  __int128 v21 = v217;
  __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([v217 renderPipelineStateForKey:v218]);
  objc_msgSend(v20, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v22, "maxTotalThreadsPerThreadgroup"));

  id v23 = (void *)v220;
  id v24 = v221;
  uint64_t v25 = *(void *)(v220 + 208);
  if ((v25 & 4) != 0)
  {
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v20 tileFunction]);
    id v27 = (void *)objc_claimAutoreleasedReturnValue([v20 preloadedLibraries]);
    id v28 = _GetPreloadedDylibsForGlobalRelocation(v220, v26, v27, a2);
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);

    if (!v29) {
      goto LABEL_120;
    }
    [v20 setPreloadedLibraries:v29];
    uint64_t v30 = (char *)[v29 count];
    else {
      uint64_t v31 = *(unsigned __int16 *)(v18 + 130);
    }
    [v20 setMaxCallStackDepth:&v30[v31]];

    uint64_t v25 = *(void *)(v220 + 208);
    id v23 = (void *)v220;
  }

  if ((v25 & 2) != 0)
  {
    id v32 = (void *)objc_claimAutoreleasedReturnValue([v20 preloadedLibraries]);
    id v33 = _GetPreloadedDylibsForGlobalBinding((uint64_t)v23, v32, a2);
    unsigned int v34 = v23;
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(v33);

    if (v35)
    {
      [v20 setPreloadedLibraries:v35];
      int v36 = (char *)[v35 count];
      else {
        uint64_t v37 = *(unsigned __int16 *)(v18 + 130);
      }
      [v20 setMaxCallStackDepth:&v36[v37]];

      uint64_t v25 = v34[26];
      id v23 = v34;
      goto LABEL_24;
    }

LABEL_120:
    id v67 = 0LL;
    id v110 = 0LL;
LABEL_190:
    id v109 = 0LL;
    goto LABEL_191;
  }

LABEL_191:
    uint64_t v194 = 0LL;
    goto LABEL_199;
  }

  switch((unint64_t)v216)
  {
    case 1uLL:
    case 4uLL:
      uint64_t v195 = objc_claimAutoreleasedReturnValue([v110 vertexBindings]);
      goto LABEL_197;
    case 2uLL:
      uint64_t v195 = objc_claimAutoreleasedReturnValue([v110 fragmentBindings]);
      goto LABEL_197;
    case 3uLL:
      uint64_t v195 = objc_claimAutoreleasedReturnValue([v110 tileBindings]);
      goto LABEL_197;
    case 5uLL:
      uint64_t v195 = objc_claimAutoreleasedReturnValue([v110 objectBindings]);
      goto LABEL_197;
    case 6uLL:
      uint64_t v195 = objc_claimAutoreleasedReturnValue([v110 meshBindings]);
LABEL_197:
      uint64_t v200 = (void *)v195;
      break;
    default:
      uint64_t v200 = 0LL;
      break;
  }

  id v201 = [v11 copy];
  uint64_t v202 = (void *)v23[12];
  v23[12] = v201;

  unsigned int v203 = (void *)objc_claimAutoreleasedReturnValue([v110 constantSamplerUniqueIdentifiers]);
  uint64_t v204 = v23;
  uint64_t v205 = (void *)objc_claimAutoreleasedReturnValue([v110 constantSamplerDescriptors]);
  ConstantSamplers = _MakeConstantSamplers(v203, v205);
  uint64_t v207 = objc_claimAutoreleasedReturnValue(ConstantSamplers);
  uint64_t v208 = (void *)v204[17];
  v204[17] = v207;

  id Bindings = _MakeBindings(v200);
  uint64_t v210 = objc_claimAutoreleasedReturnValue(Bindings);
  id v211 = (void *)v204[16];
  v204[16] = v210;

  v204[18] = CurrentEncoderFreeBindingSlotIndex;
  uint64_t v194 = 1LL;
  id v24 = v221;
LABEL_199:

  return v194;
}

id _ObjectArrayWithMap(uint64_t *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  for (uint64_t i = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2); a2; --a2)
  {
    uint64_t v7 = *a1++;
    id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v7));
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v8]);

    if (v9) {
      -[NSMutableArray addObject:](i, "addObject:", v9);
    }
  }

  id v10 = -[NSMutableArray copy](i, "copy");

  return v10;
}

void GTShaderDebuggerJITResources(void *a1)
{
  id v1 = a1;
  id v125 = *(id *)(*a1 + 8LL);
  uint64_t v123 = objc_claimAutoreleasedReturnValue([v125 defaultDevice]);
  id v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  unint64_t v145 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v3 = (id)v1[3];
  id v4 = (id)v1[16];
  id v132 = v1;
  uint64_t v127 = v2;
  if ([v3 count] && objc_msgSend(v4, "count", v123))
  {
    id v140 = v3;
    id v142 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*v1 + 8) defaultDevice]);
    __int128 v168 = 0u;
    __int128 v169 = 0u;
    __int128 v170 = 0u;
    __int128 v171 = 0u;
    id v5 = v3;
    id v6 = [v5 countByEnumeratingWithState:&v168 objects:&v172 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v169;
      do
      {
        for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v169 != v8) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = *(void *)(*((void *)&v168 + 1) + 8LL * (void)i);
          id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v10]);
          id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 firstObject]);
          id v13 = [v12 unsignedLongLongValue];

          if (v13)
          {
            uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v11 lastObject]);
            id v15 = [v14 unsignedLongLongValue];

            if (v15)
            {
              *(void *)&__int128 v161 = _NSConcreteStackBlock;
              *((void *)&v161 + 1) = 3221225472LL;
              *(void *)&__int128 v162 = ___MakeBytesBufferReplacementsForPipeline_block_invoke;
              *((void *)&v162 + 1) = &unk_58F8E8;
              *(void *)&__int128 v163 = v10;
              uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "gt_firstObjectPassingTest:", &v161));
              if (v16)
              {
                id v17 = [v142 newBufferWithBytes:v13 length:v15 options:0];
                -[NSMutableDictionary setObject:forKeyedSubscript:](v145, "setObject:forKeyedSubscript:", v17, v10);
              }
            }
          }
        }

        id v7 = [v5 countByEnumeratingWithState:&v168 objects:&v172 count:16];
      }

      while (v7);
    }

    id v1 = v132;
    id v2 = v127;
    id v3 = v140;
  }

  id v18 = -[NSMutableDictionary copy](v145, "copy", v123);

  __int128 v152 = 0u;
  __int128 v153 = 0u;
  __int128 v154 = 0u;
  __int128 v155 = 0u;
  id v19 = v18;
  id v20 = [v19 countByEnumeratingWithState:&v152 objects:v167 count:16];
  if (v20)
  {
    id v21 = v20;
    uint64_t v22 = *(void *)v153;
    do
    {
      for (uint64_t j = 0LL; j != v21; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v153 != v22) {
          objc_enumerationMutation(v19);
        }
        uint64_t v24 = *(void *)(*((void *)&v152 + 1) + 8LL * (void)j);
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:v24]);
        -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v25, v24);
      }

      id v21 = [v19 countByEnumeratingWithState:&v152 objects:v167 count:16];
    }

    while (v21);
  }

  id v126 = v19;

  uint64_t v143 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v26 = (id)v1[4];
  id v27 = (id)v1[16];
  char v28 = *((_BYTE *)v1 + 72);
  __int128 v161 = 0u;
  __int128 v162 = 0u;
  __int128 v163 = 0u;
  __int128 v164 = 0u;
  id v29 = [v26 countByEnumeratingWithState:&v161 objects:&v172 count:16];
  if (v29)
  {
    id v30 = v29;
    uint64_t v31 = *(void *)v162;
    int v146 = v28 & 1;
    do
    {
      for (unint64_t k = 0LL; k != v30; unint64_t k = (char *)k + 1)
      {
        if (*(void *)v162 != v31) {
          objc_enumerationMutation(v26);
        }
        uint64_t v33 = *(void *)(*((void *)&v161 + 1) + 8LL * (void)k);
        unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue([v26 objectForKeyedSubscript:v33]);
        id v35 = [v34 unsignedLongLongValue];

        if (!v35)
        {
          v160[0] = _NSConcreteStackBlock;
          v160[1] = 3221225472LL;
          v160[2] = ___MakeDummyBufferReplacementsForPipeline_block_invoke;
          v160[3] = &unk_58F8E8;
          void v160[4] = v33;
          int v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v27, "gt_firstObjectPassingTest:", v160));
          uint64_t v37 = v36;
          if (v36)
          {
            unsigned __int16 v38 = (void *)objc_claimAutoreleasedReturnValue([v36 objectForKeyedSubscript:@"used"]);
            unsigned int v39 = [v38 BOOLValue];

            if (!v39 || v146)
            {
              unsigned __int8 v40 = (void *)objc_claimAutoreleasedReturnValue([v37 objectForKeyedSubscript:@"index"]);
              -[NSMutableArray addObject:](v143, "addObject:", v40);
            }
          }
        }
      }

      id v30 = [v26 countByEnumeratingWithState:&v161 objects:&v172 count:16];
    }

    while (v30);
  }

  if (-[NSMutableArray count](v143, "count"))
  {
    id v41 = (uint64_t **)v132;
    id v42 = *(id *)(*v132 + 8LL);
    unsigned __int8 v43 = (void *)objc_claimAutoreleasedReturnValue([v42 defaultDevice]);
    id v44 = [v43 newBufferWithLength:1024 options:0];
    if (v44)
    {
      unsigned __int8 v45 = v44;
      unsigned __int8 v46 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      __int128 v156 = 0u;
      __int128 v157 = 0u;
      __int128 v158 = 0u;
      __int128 v159 = 0u;
      id v47 = v143;
      id v48 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v47,  "countByEnumeratingWithState:objects:count:",  &v156,  &v168,  16LL);
      if (v48)
      {
        id v49 = v48;
        uint64_t v50 = *(void *)v157;
        do
        {
          for (unint64_t m = 0LL; m != v49; unint64_t m = (char *)m + 1)
          {
            if (*(void *)v157 != v50) {
              objc_enumerationMutation(v47);
            }
            -[NSMutableDictionary setObject:forKeyedSubscript:]( v46,  "setObject:forKeyedSubscript:",  v45,  *(void *)(*((void *)&v156 + 1) + 8LL * (void)m));
          }

          id v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v47,  "countByEnumeratingWithState:objects:count:",  &v156,  &v168,  16LL);
        }

        while (v49);
      }

      id v52 = -[NSMutableDictionary copy](v46, "copy");
      id v53 = v126;
    }

    else
    {
      id v52 = 0LL;
      id v53 = v126;
    }

    id v54 = v127;
  }

  else
  {
    id v52 = 0LL;
    id v41 = (uint64_t **)v132;
    id v53 = v126;
    id v54 = v127;
  }

  __int128 v148 = 0u;
  __int128 v149 = 0u;
  __int128 v150 = 0u;
  __int128 v151 = 0u;
  id v55 = v52;
  id v56 = [v55 countByEnumeratingWithState:&v148 objects:v166 count:16];
  if (v56)
  {
    id v57 = v56;
    uint64_t v58 = *(void *)v149;
    do
    {
      for (uint64_t n = 0LL; n != v57; uint64_t n = (char *)n + 1)
      {
        if (*(void *)v149 != v58) {
          objc_enumerationMutation(v55);
        }
        uint64_t v60 = *(void *)(*((void *)&v148 + 1) + 8LL * (void)n);
        __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:v60]);

        if (!v61)
        {
          id v62 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:v60]);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v54, "setObject:forKeyedSubscript:", v62, v60);
        }
      }

      id v57 = [v55 countByEnumeratingWithState:&v148 objects:v166 count:16];
    }

    while (v57);
  }

  uint64_t v63 = (uint64_t *)-[NSMutableDictionary copy](v54, "copy");
  id v64 = v41[21];
  v41[21] = v63;

  unint64_t v133 = *v41[11];
  __int128 v134 = *(uint64_t **)(**v41 + 40);
  uint64_t v65 = v41[16];
  unsigned int v66 = v41[7];
  id v129 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  __int128 v161 = 0u;
  __int128 v162 = 0u;
  __int128 v163 = 0u;
  __int128 v164 = 0u;
  id v67 = v66;
  id v141 = [v67 countByEnumeratingWithState:&v161 objects:&v168 count:16];
  if (v141)
  {
    uint64_t v139 = *(void *)v162;
    unint64_t v130 = v67;
    id v131 = v55;
    id v128 = v65;
    do
    {
      for (iuint64_t i = 0LL; ii != v141; iuint64_t i = (char *)ii + 1)
      {
        if (*(void *)v162 != v139) {
          objc_enumerationMutation(v67);
        }
        uint64_t v69 = *(void *)(*((void *)&v161 + 1) + 8LL * (void)ii);
        uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v67 objectForKeyedSubscript:v69]);
        id v71 = [v70 unsignedLongLongValue];

        if (v71)
        {
          *(void *)&__int128 v156 = _NSConcreteStackBlock;
          *((void *)&v156 + 1) = 3221225472LL;
          *(void *)&__int128 v157 = ___MakeVisibleFunctionTablesForPipeline_block_invoke;
          *((void *)&v157 + 1) = &unk_58F8E8;
          uint64_t v137 = v69;
          *(void *)&__int128 v158 = v69;
          id v72 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v65, "gt_firstObjectPassingTest:", &v156));
          if (v72)
          {
            uint64_t Object = GTMTLSMContext_getObject(*v134, (uint64_t)v71, v133);
            if (Object)
            {
              id v74 = Object;
              if (*(_DWORD *)Object == 83)
              {
                id v75 = v65;
                id v135 = v72;
                id v76 = v41;
                id v77 = [v41[12] mutableCopy];
                id v78 = (void *)v74[13];
                __int128 v79 = objc_alloc_init(&OBJC_CLASS___MTLVisibleFunctionTableDescriptor);
                -[MTLVisibleFunctionTableDescriptor setFunctionCount:](v79, "setFunctionCount:", *v78);
                id v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v74[16]));
                __int128 v81 = (void *)objc_claimAutoreleasedReturnValue([v77 objectForKeyedSubscript:v80]);

                id v144 = v77;
                if (v81)
                {
                  id v82 = [v81 newVisibleFunctionTableWithDescriptor:v79 stage:*((unsigned __int8 *)v74 + 168)];
                  id v41 = v76;
                  uint64_t v65 = v75;
                }

                else
                {
                  id v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v74[15]));
                  unsigned __int16 v84 = (void *)objc_claimAutoreleasedReturnValue([v77 objectForKeyedSubscript:v83]);

                  if (v84) {
                    id v85 = [v84 newVisibleFunctionTableWithDescriptor:v79];
                  }
                  else {
                    id v85 = 0LL;
                  }
                  id v41 = v76;

                  id v55 = v131;
                  uint64_t v65 = v75;
                  id v82 = v85;
                }

                unint64_t v87 = v82;
                if (v82)
                {
                  uint64_t v88 = **v41;
                  unint64_t v147 = *v41[11];
                  apr_pool_create_ex(&newpool, 0LL, 0LL, v86);
                  __int128 v172 = 0u;
                  uint64_t v173 = 0LL;
                  __int128 v184 = 0u;
                  __int128 v182 = 0u;
                  __int128 v183 = 0u;
                  __int128 v180 = 0u;
                  __int128 v181 = 0u;
                  __int128 v178 = 0u;
                  __int128 v179 = 0u;
                  __int128 v176 = 0u;
                  __int128 v175 = 0u;
                  LODWORD(v172) = 83;
                  uint64_t v174 = -1LL;
                  WORD1(v179) = 2;
                  __int128 v177 = 0xFFFFFFFFFFFFFFFFLL;
                  *((void *)&v184 + 1) = *(void *)v74[13];
                  size_t v89 = 8LL * *((void *)&v184 + 1);
                  int v90 = apr_palloc(newpool, 8LL * *((void *)&v184 + 1));
                  id v91 = v90;
                  if (v90) {
                    bzero(v90, v89);
                  }
                  *(void *)&__int128 v184 = v91;
                  uint64_t v92 = *(void *)(v88 + 8);
                  v160[0] = v74[1];
                  uint64_t v93 = *(void *)(*(void *)(*find_entry(v92, v160, 8uLL, 0LL) + 32LL) + 32LL);
                  id v138 = v87;
                  unsigned int v94 = 0;
                  if (v93)
                  {
                    while (1)
                    {
                      unsigned int v95 = atomic_load((unsigned int *)(v93 + 4));
                      uint64_t v96 = v94 + (v95 >> 6) - 1;
                      uint64_t v93 = *(void *)(v93 + 40);
                      unsigned int v94 = v96;
                      if (!v93)
                      {
                        unsigned int v94 = v96;
                        goto LABEL_81;
                      }
                    }
                  }

                  uint64_t v96 = 0LL;
LABEL_81:
                  unint64_t v97 = v94 | (unint64_t)(v96 << 32);
LABEL_82:
                  uint64_t v98 = v93 + 64;
                  while (v93)
                  {
                    BOOL v99 = (unint64_t *)(v98 + ((uint64_t)(HIDWORD(v97) - (int)v97) << 6));
                    if (*v99 >= v147) {
                      break;
                    }
                    GTMTLSMVisibleFunctionTableStateful_processTraceFuncWithMap( (uint64_t)&v172,  *(void *)(v88 + 16),  (uint64_t)v99);
                    unsigned int v100 = atomic_load((unsigned int *)(v93 + 4));
                    int v101 = v97 + (v100 >> 6);
                    uint64_t v102 = (HIDWORD(v97) + 1);
                    unint64_t v97 = (v102 << 32) | v97;
                    if ((_DWORD)v102 == v101 - 1)
                    {
                      unint64_t v97 = (v102 << 32) | v102;
                      uint64_t v93 = *(void *)(v93 + 40);
                      goto LABEL_82;
                    }
                  }

                  id v72 = v135;
                  if (*((void *)&v184 + 1))
                  {
                    for (juint64_t j = 0LL; *((void *)&v184 + 1) > jj; ++jj)
                    {
                      uint64_t v104 = *(void *)(v184 + 8 * jj);
                      if (!v104) {
                        continue;
                      }
                      id v105 = GTMTLSMContext_getObject(**(void **)(v88 + 40), *(void *)(v184 + 8 * jj), v147);
                      if (!v105) {
                        continue;
                      }
                      id v106 = v105;
                      id v107 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v104));
                      uint64_t v108 = objc_claimAutoreleasedReturnValue([v144 objectForKeyedSubscript:v107]);
                      if (v108)
                      {
                        id v109 = (void *)v108;
                      }

                      else
                      {
                        id v110 = v144;
                        id v111 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v106[5]));
                        id v109 = (void *)objc_claimAutoreleasedReturnValue([v110 objectForKeyedSubscript:v111]);

                        __int128 v136 = v109;
                        if (v109)
                        {
                          id v112 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v106[7]));
                          uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v110 objectForKeyedSubscript:v112]);

                          if (v113)
                          {
                            uint64_t v114 = *((unsigned __int8 *)v106 + 64);
                            id v115 = v136;
                            id v109 = (void *)objc_claimAutoreleasedReturnValue([v113 functionHandleWithFunction:v136 stage:v114]);
                          }

                          else
                          {
                            id v116 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v106[6]));
                            id v117 = (void *)objc_claimAutoreleasedReturnValue([v110 objectForKeyedSubscript:v116]);

                            if (v117) {
                              id v109 = (void *)objc_claimAutoreleasedReturnValue([v117 functionHandleWithFunction:v136]);
                            }
                            else {
                              id v109 = 0LL;
                            }

                            id v115 = v136;
                          }
                        }

                        else
                        {
                          id v115 = 0LL;
                        }

                        id v72 = v135;
                        if (!v109)
                        {
                          id v109 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*v132 + 8) functionHandleForKey:v104]);
                          if (!v109) {
                            continue;
                          }
                          goto LABEL_105;
                        }
                      }

                      uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v104));
                      [v144 setObject:v109 forKeyedSubscript:v118];

LABEL_105:
                      [v138 setFunction:v109 atIndex:jj];
                    }
                  }

                  apr_pool_destroy(newpool);
                  id v119 = [v144 copy];
                  id v41 = (uint64_t **)v132;
                  id v120 = (void *)v132[12];
                  v132[12] = v119;

                  unint64_t v87 = v138;
                  -[NSMutableDictionary setObject:forKeyedSubscript:](v129, "setObject:forKeyedSubscript:", v138, v137);
                  id v55 = v131;
                  uint64_t v65 = v128;
                }

                else
                {

                  id v72 = v135;
                }

                id v67 = v130;
              }
            }
          }
        }
      }

      id v141 = [v67 countByEnumeratingWithState:&v161 objects:&v168 count:16];
    }

    while (v141);
  }

  uint64_t v121 = (uint64_t *)-[NSMutableDictionary copy](v129, "copy");
  id v122 = v41[22];
  v41[22] = v121;
}

uint64_t GTShaderDebuggerEncodeResourcesRender(void *a1, void *a2)
{
  uint64_t v4 = *a1;
  id v5 = (void *)a1[12];
  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*a1 + 19912LL)));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v6]);

  if (v7)
  {
    id v8 = *(id *)(*a1 + 8LL);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 renderCommandEncoderForKey:*(void *)(v4 + 11320)]);
    uint64_t v10 = v9 != 0LL;
    if (v9)
    {
      uint64_t v11 = a1[18];
      id v12 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[24] objectForKeyedSubscript:@"ROI"]);
      id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"Type"]);
      id v14 = [v13 integerValue];

      id v70 = v8;
      switch((unint64_t)v14)
      {
        case 1uLL:
        case 4uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL) {
            [v9 setVertexBuffer:a1[23] offset:0 atIndex:v11];
          }
          BOOL v69 = v9 != 0LL;
          id v15 = (id)a1[21];
          __int128 v99 = 0u;
          __int128 v100 = 0u;
          __int128 v101 = 0u;
          __int128 v102 = 0u;
          id v16 = [v15 countByEnumeratingWithState:&v99 objects:v110 count:16];
          if (v16)
          {
            id v17 = v16;
            uint64_t v18 = *(void *)v100;
            do
            {
              for (uint64_t i = 0LL; i != v17; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v100 != v18) {
                  objc_enumerationMutation(v15);
                }
                id v20 = *(void **)(*((void *)&v99 + 1) + 8LL * (void)i);
                id v21 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v20]);
                objc_msgSend(v9, "setVertexBuffer:offset:atIndex:", v21, 0, objc_msgSend(v20, "unsignedIntegerValue"));
              }

              id v17 = [v15 countByEnumeratingWithState:&v99 objects:v110 count:16];
            }

            while (v17);
          }

          id v22 = (id)a1[22];
          __int128 v95 = 0u;
          __int128 v96 = 0u;
          __int128 v97 = 0u;
          __int128 v98 = 0u;
          id v23 = [v22 countByEnumeratingWithState:&v95 objects:v109 count:16];
          if (v23)
          {
            id v24 = v23;
            uint64_t v25 = *(void *)v96;
            do
            {
              for (uint64_t j = 0LL; j != v24; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v96 != v25) {
                  objc_enumerationMutation(v22);
                }
                id v27 = *(void **)(*((void *)&v95 + 1) + 8LL * (void)j);
                char v28 = (void *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:v27]);
                objc_msgSend( v9,  "setVertexVisibleFunctionTable:atBufferIndex:",  v28,  objc_msgSend(v27, "unsignedIntegerValue"));
              }

              id v24 = [v22 countByEnumeratingWithState:&v95 objects:v109 count:16];
            }

            while (v24);
          }

          goto LABEL_60;
        case 2uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL) {
            [v9 setFragmentBuffer:a1[23] offset:0 atIndex:v11];
          }
          BOOL v69 = v9 != 0LL;
          id v15 = (id)a1[21];
          __int128 v91 = 0u;
          __int128 v92 = 0u;
          __int128 v93 = 0u;
          __int128 v94 = 0u;
          id v31 = [v15 countByEnumeratingWithState:&v91 objects:v108 count:16];
          if (v31)
          {
            id v32 = v31;
            uint64_t v33 = *(void *)v92;
            do
            {
              for (unint64_t k = 0LL; k != v32; unint64_t k = (char *)k + 1)
              {
                if (*(void *)v92 != v33) {
                  objc_enumerationMutation(v15);
                }
                id v35 = *(void **)(*((void *)&v91 + 1) + 8LL * (void)k);
                int v36 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v35]);
                objc_msgSend( v9,  "setFragmentBuffer:offset:atIndex:",  v36,  0,  objc_msgSend(v35, "unsignedIntegerValue"));
              }

              id v32 = [v15 countByEnumeratingWithState:&v91 objects:v108 count:16];
            }

            while (v32);
          }

          id v22 = (id)a1[22];
          __int128 v87 = 0u;
          __int128 v88 = 0u;
          __int128 v89 = 0u;
          __int128 v90 = 0u;
          id v37 = [v22 countByEnumeratingWithState:&v87 objects:v107 count:16];
          if (v37)
          {
            id v38 = v37;
            uint64_t v39 = *(void *)v88;
            do
            {
              for (unint64_t m = 0LL; m != v38; unint64_t m = (char *)m + 1)
              {
                if (*(void *)v88 != v39) {
                  objc_enumerationMutation(v22);
                }
                id v41 = *(void **)(*((void *)&v87 + 1) + 8LL * (void)m);
                id v42 = (void *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:v41]);
                objc_msgSend( v9,  "setFragmentVisibleFunctionTable:atBufferIndex:",  v42,  objc_msgSend(v41, "unsignedIntegerValue"));
              }

              id v38 = [v22 countByEnumeratingWithState:&v87 objects:v107 count:16];
            }

            while (v38);
          }

          goto LABEL_60;
        case 3uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL) {
            [v9 setTileBuffer:a1[23] offset:0 atIndex:v11];
          }
          BOOL v69 = v9 != 0LL;
          id v15 = (id)a1[21];
          __int128 v83 = 0u;
          __int128 v84 = 0u;
          __int128 v85 = 0u;
          __int128 v86 = 0u;
          id v43 = [v15 countByEnumeratingWithState:&v83 objects:v106 count:16];
          if (v43)
          {
            id v44 = v43;
            uint64_t v45 = *(void *)v84;
            do
            {
              for (uint64_t n = 0LL; n != v44; uint64_t n = (char *)n + 1)
              {
                if (*(void *)v84 != v45) {
                  objc_enumerationMutation(v15);
                }
                id v47 = *(void **)(*((void *)&v83 + 1) + 8LL * (void)n);
                id v48 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v47]);
                objc_msgSend(v9, "setTileBuffer:offset:atIndex:", v48, 0, objc_msgSend(v47, "unsignedIntegerValue"));
              }

              id v44 = [v15 countByEnumeratingWithState:&v83 objects:v106 count:16];
            }

            while (v44);
          }

          id v22 = (id)a1[22];
          __int128 v79 = 0u;
          __int128 v80 = 0u;
          __int128 v81 = 0u;
          __int128 v82 = 0u;
          id v49 = [v22 countByEnumeratingWithState:&v79 objects:v105 count:16];
          if (v49)
          {
            id v50 = v49;
            uint64_t v51 = *(void *)v80;
            do
            {
              for (iuint64_t i = 0LL; ii != v50; iuint64_t i = (char *)ii + 1)
              {
                if (*(void *)v80 != v51) {
                  objc_enumerationMutation(v22);
                }
                id v53 = *(void **)(*((void *)&v79 + 1) + 8LL * (void)ii);
                id v54 = (void *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:v53]);
                objc_msgSend( v9,  "setTileVisibleFunctionTable:atBufferIndex:",  v54,  objc_msgSend(v53, "unsignedIntegerValue"));
              }

              id v50 = [v22 countByEnumeratingWithState:&v79 objects:v105 count:16];
            }

            while (v50);
          }

LABEL_60:
          uint64_t v10 = v69;
          goto LABEL_81;
        case 5uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL) {
            [v9 setObjectBuffer:a1[23] offset:0 atIndex:v11];
          }
          id v55 = (id)a1[21];
          __int128 v71 = 0u;
          __int128 v72 = 0u;
          __int128 v73 = 0u;
          __int128 v74 = 0u;
          id v56 = [v55 countByEnumeratingWithState:&v71 objects:v103 count:16];
          if (v56)
          {
            id v57 = v56;
            uint64_t v58 = *(void *)v72;
            do
            {
              for (juint64_t j = 0LL; jj != v57; juint64_t j = (char *)jj + 1)
              {
                if (*(void *)v72 != v58) {
                  objc_enumerationMutation(v55);
                }
                uint64_t v60 = *(void **)(*((void *)&v71 + 1) + 8LL * (void)jj);
                __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:v60]);
                objc_msgSend(v9, "setObjectBuffer:offset:atIndex:", v61, 0, objc_msgSend(v60, "unsignedIntegerValue"));
              }

              id v57 = [v55 countByEnumeratingWithState:&v71 objects:v103 count:16];
            }

            while (v57);
          }

          goto LABEL_80;
        case 6uLL:
          if (v11 != 0x7FFFFFFFFFFFFFFFLL) {
            [v9 setMeshBuffer:a1[23] offset:0 atIndex:v11];
          }
          id v55 = (id)a1[21];
          __int128 v75 = 0u;
          __int128 v76 = 0u;
          __int128 v77 = 0u;
          __int128 v78 = 0u;
          id v62 = [v55 countByEnumeratingWithState:&v75 objects:v104 count:16];
          if (v62)
          {
            id v63 = v62;
            uint64_t v64 = *(void *)v76;
            do
            {
              for (kunint64_t k = 0LL; kk != v63; kunint64_t k = (char *)kk + 1)
              {
                if (*(void *)v76 != v64) {
                  objc_enumerationMutation(v55);
                }
                unsigned int v66 = *(void **)(*((void *)&v75 + 1) + 8LL * (void)kk);
                id v67 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:v66]);
                objc_msgSend(v9, "setMeshBuffer:offset:atIndex:", v67, 0, objc_msgSend(v66, "unsignedIntegerValue"));
              }

              id v63 = [v55 countByEnumeratingWithState:&v75 objects:v104 count:16];
            }

            while (v63);
          }

      if ((*((_BYTE *)v8 + 33) & 0x20) != 0) {
        goto LABEL_63;
      }
    }

    if ((_DWORD)v53 != 101)
    {
      if ((_DWORD)v53 == 109)
      {
        if (!v11) {
          uint64_t v45 = a2[20];
        }
        uint64_t v18 = v55[0];
        if (v55[0])
        {
          id v19 = strlen(v55[0]);
          id v20 = (char *)a2[23];
          id v21 = v20;
          id v22 = v19 + 1;
          if (v19 != -1LL) {
            goto LABEL_40;
          }
        }

        else
        {
          id v22 = 0LL;
          id v20 = (char *)a2[23];
        }

        id v21 = 0LL;
LABEL_40:
        a2[23] = &v20[v22];
        if (a3)
        {
          memcpy(v21, v18, v22);
          uint64_t v33 = a2[20];
          unsigned int v34 = (int)__s[0];
          id v35 = (char)__s[1];
          int v36 = (char)v55[1];
          *(void *)uint64_t v33 = v21;
          *(_DWORD *)(v33 + _Block_object_dispose(va, 8) = v34;
          *(_BYTE *)(v33 + 12) = v35;
          *(_BYTE *)(v33 + 13) = v36;
          *(_WORD *)(v33 + 14) = 0;
        }

        ++v11;
        a2[20] += 16LL;
        goto LABEL_60;
      }

      goto LABEL_60;
    }

    char v28 = v55[0];
    WORD2(v47) = __s[0];
    if (v55[0])
    {
      id v29 = strlen(v55[0]);
      id v30 = (char *)a2[23];
      __dst = v30;
      id v31 = v29 + 1;
      if (v29 != -1LL)
      {
LABEL_50:
        a2[23] = &v30[v31];
        if (a3) {
          memcpy(__dst, v28, v31);
        }
        id v14 = v55[1];
        LOWORD(v47) = __s[1];
        if (v55[1])
        {
          id v41 = strlen(v55[1]);
          id v42 = (char *)a2[23];
          id v12 = v42;
          id v17 = v41 + 1;
          if (v41 != -1LL)
          {
LABEL_57:
            a2[23] = &v42[v17];
            if (a3)
            {
              id v32 = v12;
              goto LABEL_59;
            }

            goto LABEL_60;
          }
        }

        else
        {
          id v17 = 0LL;
          id v42 = (char *)a2[23];
        }

        id v12 = 0LL;
        goto LABEL_57;
      }
    }

    else
    {
      id v31 = 0LL;
      id v30 = (char *)a2[23];
    }

    __dst = 0LL;
    goto LABEL_50;
  }

uint64_t GTShaderDebuggerEncodeResourcesCompute(void *a1, void *a2)
{
  uint64_t v4 = *a1;
  id v5 = (void *)a1[12];
  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*a1 + 11376LL)));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v6]);

  if (v7)
  {
    id v8 = *(id *)(*a1 + 8LL);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 computeCommandEncoderForKey:*(void *)(v4 + 11320)]);
    uint64_t v10 = v9;
    uint64_t v11 = v9 != 0LL;
    if (v9)
    {
      id v29 = v8;
      if (a1[18] != 0x7FFFFFFFFFFFFFFFLL) {
        objc_msgSend(v9, "setBuffer:offset:atIndex:", a1[23], 0);
      }
      id v12 = (id)a1[21];
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      id v13 = [v12 countByEnumeratingWithState:&v36 objects:v41 count:16];
      if (v13)
      {
        id v14 = v13;
        uint64_t v15 = *(void *)v37;
        do
        {
          for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v37 != v15) {
              objc_enumerationMutation(v12);
            }
            id v17 = *(void **)(*((void *)&v36 + 1) + 8LL * (void)i);
            uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "objectForKeyedSubscript:", v17, v29));
            objc_msgSend(v10, "setBuffer:offset:atIndex:", v18, 0, objc_msgSend(v17, "unsignedIntegerValue"));
          }

          id v14 = [v12 countByEnumeratingWithState:&v36 objects:v41 count:16];
        }

        while (v14);
      }

      unsigned int v31 = v11;
      id v19 = (id)a1[22];
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      id v20 = [v19 countByEnumeratingWithState:&v32 objects:v40 count:16];
      if (v20)
      {
        id v21 = v20;
        uint64_t v22 = *(void *)v33;
        do
        {
          for (uint64_t j = 0LL; j != v21; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v33 != v22) {
              objc_enumerationMutation(v19);
            }
            id v24 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)j);
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", v24, v29));
            objc_msgSend(v10, "setVisibleFunctionTable:atBufferIndex:", v25, objc_msgSend(v24, "unsignedIntegerValue"));
          }

          id v21 = [v19 countByEnumeratingWithState:&v32 objects:v40 count:16];
        }

        while (v21);
      }

      objc_msgSend(v10, "useResource:usage:", a1[23], 2, v29);
      [v10 setComputePipelineState:v7];

      uint64_t v11 = v31;
      id v8 = v30;
    }

    else if (a2)
    {
      id Error = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to resolve compute encoder", 0LL, 0LL, 0LL);
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }

  else if (a2)
  {
    id v26 = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to resolve compute pipeleine", 0LL, 0LL, 0LL);
    uint64_t v11 = 0LL;
    *a2 = (id)objc_claimAutoreleasedReturnValue(v26);
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  return v11;
}

uint64_t GTShaderDebuggerExecuteEncoder(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[10];
  if (v4)
  {
    int v6 = *(_DWORD *)(v3 + 11312);
    uint64_t v7 = *(void *)(v3 + 11320);
    id v8 = *(id *)(v3 + 8);
    id v9 = v8;
    if (v6 == 70)
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 renderCommandEncoderForKey:v7]);
      uint64_t v11 = *(void *)(v4 + 200);
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v9 executeIndirectCommandBufferMap]);
      uint64_t v13 = DYMTLDrawRenderCommandEncoder(v10, v4, v11, v4 + 112, v12);

      id v9 = v12;
    }

    else
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 computeCommandEncoderForKey:v7]);
      uint64_t v13 = DYMTLDispatchComputeCommandEncoder(v10, v4, *(void *)(v4 + 200));
    }

    if (a2 && (v13 & 1) == 0)
    {
      id Error = GTShaderDebuggerMakeError( 1u,  @"Internal error: Problem encountered during execution",  0LL,  0LL,  0LL);
      uint64_t v13 = 0LL;
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }

  else
  {
    GTMTLReplayController_defaultDispatchFunction(v3, a1[11]);
    return 1LL;
  }

  return v13;
}

uint64_t GTShaderDebuggerValidateUserComputeDispatch(void *a1, void *a2)
{
  uint64_t v4 = *a1;
  int v5 = *(_DWORD *)(*a1 + 11312LL);
  if (v5 == 70)
  {
    int v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 8) renderPipelineStateForKey:*(void *)(v4 + 19912)]);
    id v16 = [v6 maxTotalThreadsPerThreadgroup];
    if (!v16) {
      goto LABEL_25;
    }
    id v17 = v16;
    uint64_t v18 = a1[11];
    if (*(_DWORD *)(v18 + 8) != -16137) {
      goto LABEL_25;
    }
    id v19 = GTTraceFunc_argumentBytesWithMap( (void *)v18,  *(unsigned __int8 *)(v18 + 13),  *(void *)(*(void *)*a1 + 16LL));
    uint64_t v20 = *((void *)v19 + 1);
    uint64_t v21 = *((void *)v19 + 2);
    uint64_t v22 = *((void *)v19 + 3);
    unint64_t v23 = v21 * v20 * v22;
    if (!v23)
    {
      id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Dispatched total threads per tile (width(%llu) * height(%llu) * depth(%llu)) must not be 0",  v20,  v21,  v22));
      if (a2)
      {
        uint64_t v25 = @"Failed to launch tile kernel: Dispatched total threads per tile is 0";
        goto LABEL_30;
      }

      goto LABEL_31;
    }

    id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Dispatched total threads per tile (%llu: (width(%llu) * height(%llu) * depth(%llu))) must not be greater than the pipeline's maximum total threads per threadgroup (%llu)",  v21 * v20 * v22,  v20,  v21,  v22,  v17));
    if (!a2) {
      goto LABEL_31;
    }
    uint64_t v25 = @"Failed to launch tile kernel: Maximum total threads per threadgroup size limit exceeded";
    goto LABEL_30;
  }

  if (v5 == 28)
  {
    int v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 8) computePipelineStateForKey:*(void *)(v4 + 11376)]);
    id v7 = [v6 maxTotalThreadsPerThreadgroup];
    if (!v7) {
      goto LABEL_25;
    }
    id v8 = v7;
    uint64_t v9 = a1[11];
    uint64_t v10 = *(void *)(*(void *)*a1 + 16LL);
    int v11 = *(_DWORD *)(v9 + 8);
    if (v11 != -16078)
    {
      if (v11 == -16220)
      {
        __int128 v32 = GTTraceFunc_argumentBytesWithMap((void *)v9, *(unsigned __int8 *)(v9 + 13), v10);
        uint64_t v13 = (uint64_t *)(v32 + 24);
        id v14 = (uint64_t *)(v32 + 32);
        uint64_t v15 = (uint64_t *)(v32 + 40);
      }

      else
      {
        if (v11 != -16327) {
          goto LABEL_25;
        }
        id v12 = GTTraceFunc_argumentBytesWithMap((void *)v9, *(unsigned __int8 *)(v9 + 13), v10);
        uint64_t v13 = (uint64_t *)(v12 + 32);
        id v14 = (uint64_t *)(v12 + 40);
        uint64_t v15 = (uint64_t *)(v12 + 48);
      }

      uint64_t v29 = *v13;
      uint64_t v30 = *v14;
      uint64_t v31 = *v15;
      goto LABEL_21;
    }

    id v27 = GTTraceFunc_argumentBytesWithMap((void *)v9, *(unsigned __int8 *)(v9 + 13), v10);
    uint64_t v28 = *((void *)v27 + 1);
    uint64_t v29 = *((void *)v27 + 4);
    uint64_t v30 = *((void *)v27 + 5);
    uint64_t v31 = *((void *)v27 + 6);
    if (v28 == -1 || *((void *)v27 + 3) * v28 * *((void *)v27 + 2))
    {
LABEL_21:
      unint64_t v33 = v30 * v31 * v29;
      if (!v33)
      {
        id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Dispatched total threads per threadgroup (width(%llu) * height(%llu) * depth(%llu)) must not be 0",  v29,  v30,  v31));
        if (a2)
        {
          uint64_t v25 = @"Failed to launch compute kernel: Dispatched total threads per threadgroup is 0";
          goto LABEL_30;
        }

        goto LABEL_31;
      }

      if (v33 > (unint64_t)v8)
      {
        id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Dispatched total threads per threadgroup (%llu: (width(%llu) * height(%llu) * depth(%llu))) must not be greater than the pipeline's maximum total threads per threadgroup (%llu)",  v30 * v31 * v29,  v29,  v30,  v31,  v8));
        if (a2)
        {
          uint64_t v25 = @"Failed to launch compute kernel: Maximum total threads per threadgroup size limit exceeded";
          goto LABEL_30;
        }

BOOL GTShaderDebuggerValidateUserEncoderBindings(uint64_t a1, void *a2)
{
  id v4 = *(id *)(a1 + 128);
  if ([v4 count])
  {
    uint64_t v26 = a2;
    id v28 = *(id *)(a1 + 24);
    __int128 v42 = *(_OWORD *)(a1 + 32);
    v41[0] = &off_5A0B50;
    v41[1] = &off_5A0B68;
    v41[2] = &off_5A0B80;
    uint64_t v43 = *(void *)(a1 + 48);
    __int128 v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v42,  v41,  3LL));
    v39[0] = &off_5A0B50;
    v39[1] = &off_5A0B68;
    v40[0] = @"buffer";
    v40[1] = @"texture";
    v39[2] = &off_5A0B80;
    v40[2] = @"sampler";
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v40,  v39,  3LL));
    uint64_t v29 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    id v27 = v4;
    obuint64_t j = v4;
    id v5 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
    if (v5)
    {
      id v6 = v5;
      id v7 = @"used";
      uint64_t v8 = *(void *)v35;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v35 != v8) {
            objc_enumerationMutation(obj);
          }
          uint64_t v10 = *(void **)(*((void *)&v34 + 1) + 8LL * (void)i);
          int v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v7]);
          unsigned int v12 = [v11 BOOLValue];

          if (v12)
          {
            uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"type"]);
            id v14 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:v13]);
            if (v14)
            {
              uint64_t v15 = v7;
              id v16 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"index"]);
              id v17 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v16]);
              if (![v17 unsignedIntegerValue])
              {
                if ([v13 integerValue]
                  || (uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v28 objectForKeyedSubscript:v16]),
                      v20,
                      !v20))
                {
                  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:v13]);
                  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"name"]);
                  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Function argument '%@' does not have a valid %@ binding at index '%@'",  v18,  v31,  v16));
                  -[NSMutableArray addObject:](v29, "addObject:", v19);
                }
              }

              id v7 = v15;
            }
          }
        }

        id v6 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
      }

      while (v6);
    }

    id v21 = -[NSMutableArray count](v29, "count");
    BOOL v22 = v21 == 0LL;
    id v4 = v27;
    if (v21)
    {
      unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v29, "componentsJoinedByString:", @"\n"));
      if (v26)
      {
        id Error = GTShaderDebuggerMakeError( 4u,  v23,  @"Ensure all function arguments have valid resource bindings",  0LL,  0LL);
        void *v26 = (id)objc_claimAutoreleasedReturnValue(Error);
      }
    }
  }

  else
  {
    BOOL v22 = 1LL;
  }

  return v22;
}

uint64_t GTShaderDebuggerMakeTraceBuffer(uint64_t a1, void *a2)
{
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)a1 + 8) defaultDevice]);
  id v5 = [v4 maxBufferLength];
  id v6 = v5;
  else {
    uint64_t v7 = (uint64_t)v5;
  }
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 192) objectForKeyedSubscript:@"Options"]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"TraceBufferSize"]);
  id v10 = [v9 unsignedIntegerValue];

  if (v6 >= v10) {
    unint64_t v11 = (unint64_t)v10;
  }
  else {
    unint64_t v11 = (unint64_t)v6;
  }
  if (v11 >= 0xFFFFFFFF) {
    unint64_t v11 = 0xFFFFFFFFLL;
  }
  if (v10) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = v7;
  }
  id v71 = [v4 newBufferWithLength:v12 options:0];
  if (v71)
  {
    unint64_t v13 = *(void *)(a1 + 160);
    id v14 = v71;
    uint64_t v15 = (char *)[v14 contents];
    *(_DWORD *)uint64_t v15 = 1;
    obuint64_t j = v14;
    *((_DWORD *)v15 + 1) = [v14 length];
    id v16 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 192) objectForKeyedSubscript:@"ROI"]);
    id v17 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"Type"));
    id v18 = [v17 integerValue];

    switch((unint64_t)v18)
    {
      case 1uLL:
        id v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"InstanceID"));
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"AmplificationID"));
        id v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"VertexIDs"));
        if (v13)
        {
          uint64_t v64 = v20;
          id v67 = v19;
          *(void *)(v15 + 12) = -1LL;
          *((_DWORD *)v15 + 5) = -1;
          *((_DWORD *)v15 + 3) = [v19 unsignedIntValue];
          unsigned int v29 = [v21 count];
          *((_DWORD *)v15 + 5) = v29;
          if (v29)
          {
            unint64_t v30 = 0LL;
            do
            {
              uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:v30]);
              *(_DWORD *)&v15[4 * v30 + 24] = [v31 unsignedIntValue];

              ++v30;
            }

            while (v30 < *((unsigned int *)v15 + 5));
          }

          uint64_t v20 = v64;
          *((_DWORD *)v15 + 4) = [v64 unsignedIntValue];
          int v32 = 4 * *((_DWORD *)v15 + 5) + 24;
          id v19 = v67;
          goto LABEL_46;
        }

        *(void *)(v15 + 12) = -1LL;
        *((_DWORD *)v15 + 3) = [v19 unsignedIntValue];
        unsigned int v49 = [v21 count];
        *((_DWORD *)v15 + 4) = v49;
        if (!v49) {
          goto LABEL_44;
        }
        uint64_t v65 = v20;
        id v68 = v19;
        unint64_t v50 = 0LL;
        do
        {
          uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:v50]);
          *(_DWORD *)&v15[4 * v50 + 20] = [v51 unsignedIntValue];

          ++v50;
          unint64_t v52 = *((unsigned int *)v15 + 4);
        }

        while (v50 < v52);
        goto LABEL_42;
      case 2uLL:
        id v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionX"));
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionY"));
        id v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionX"));
        unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionY"));
        id v59 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinSampleID"));
        __int128 v61 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxSampleID"));
        __int128 v34 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"RenderTargetArrayIndex"));
        *(void *)&__int128 v35 = -1LL;
        *((void *)&v35 + 1) = -1LL;
        *(_OWORD *)(v15 + 12) = v35;
        *(_OWORD *)(v15 + 2_Block_object_dispose(va, 8) = v35;
        *(_OWORD *)(v15 + 44) = v35;
        *((_DWORD *)v15 + 15) = -1;
        [v19 floatValue];
        *((_DWORD *)v15 + 4) = v36;
        [v20 floatValue];
        int32x4_t v37 = vdupq_n_s32(0xCE6E6B28);
        v37.i32[0] = *((_DWORD *)v15 + 4);
        v37.i32[1] = v38;
        *((int32x4_t *)v15 + 1) = v37;
        [v21 floatValue];
        *((_DWORD *)v15 + _Block_object_dispose(va, 8) = v39;
        [v33 floatValue];
        int32x4_t v40 = vdupq_n_s32(0x4E6E6B28u);
        v40.i32[0] = *((_DWORD *)v15 + 8);
        v40.i32[1] = v41;
        *((int32x4_t *)v15 + 2) = v40;
        *((_DWORD *)v15 + 12) = [v59 unsignedIntValue];
        *((_DWORD *)v15 + 13) = [v61 unsignedIntValue];
        if (v13 >= 2) {
          *((_DWORD *)v15 + 14) = [v34 unsignedIntValue];
        }
        *((_DWORD *)v15 + 2) = 64;

        goto LABEL_47;
      case 3uLL:
      case 5uLL:
        id v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionX"));
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionY"));
        id v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MinPositionZ"));
        BOOL v22 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionX"));
        unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionY"));
        id v24 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"MaxPositionZ"));
        *(void *)&__int128 v25 = -1LL;
        *((void *)&v25 + 1) = -1LL;
        *(_OWORD *)(v15 + 12) = v25;
        *(_OWORD *)(v15 + 2_Block_object_dispose(va, 8) = v25;
        *((_DWORD *)v15 + 11) = -1;
        *((_DWORD *)v15 + 4) = [v19 unsignedIntValue];
        *((_DWORD *)v15 + 5) = [v20 unsignedIntValue];
        *((_DWORD *)v15 + 6) = [v21 unsignedIntValue];
        *((_DWORD *)v15 + _Block_object_dispose(va, 8) = [v22 unsignedIntValue];
        *((_DWORD *)v15 + 9) = [v23 unsignedIntValue];
        *((_DWORD *)v15 + 10) = [v24 unsignedIntValue];
        *((_DWORD *)v15 + 2) = 48;

        goto LABEL_47;
      case 4uLL:
        id v19 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"InstanceID"));
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( -[__CFString objectForKeyedSubscript:]( v16,  "objectForKeyedSubscript:",  @"AmplificationID"));
        id v21 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"PatchIDs"));
        if (v13)
        {
          *(void *)(v15 + 12) = -1LL;
          *((_DWORD *)v15 + 5) = -1;
          *((_DWORD *)v15 + 3) = [v19 unsignedIntValue];
          *((_DWORD *)v15 + 4) = [v20 unsignedIntValue];
          unsigned int v42 = [v21 count];
          *((_DWORD *)v15 + 5) = v42;
          if (v42)
          {
            uint64_t v65 = v20;
            id v68 = v19;
            unint64_t v43 = 0LL;
            do
            {
              id v44 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:v43]);
              *(_DWORD *)&v15[4 * v43 + 24] = [v44 unsignedIntValue];

              ++v43;
              unint64_t v45 = *((unsigned int *)v15 + 5);
            }

            while (v43 < v45);
            int v32 = 4 * v45 + 24;
LABEL_43:
            uint64_t v20 = v65;
            id v19 = v68;
            goto LABEL_46;
          }

          int v32 = 24;
        }

        else
        {
          *(void *)(v15 + 12) = -1LL;
          *((_DWORD *)v15 + 3) = [v19 unsignedIntValue];
          unsigned int v53 = [v21 count];
          *((_DWORD *)v15 + 4) = v53;
          if (v53)
          {
            uint64_t v65 = v20;
            id v68 = v19;
            unint64_t v54 = 0LL;
            do
            {
              id v55 = (void *)objc_claimAutoreleasedReturnValue([v21 objectAtIndexedSubscript:v54]);
              *(_DWORD *)&v15[4 * v54 + 20] = [v55 unsignedIntValue];

              ++v54;
              unint64_t v52 = *((unsigned int *)v15 + 4);
            }

            while (v54 < v52);
LABEL_42:
            int v32 = 4 * v52 + 20;
            goto LABEL_43;
          }

id GTShaderDebuggerMakeTraceData(uint64_t a1, void *a2)
{
  id v4 = *(id *)(a1 + 184);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 192) objectForKeyedSubscript:@"ROI"]);
  id v6 = v4;
  uint64_t v7 = [v6 contents];
  id v8 = [v6 length];
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"Type"]);
  unsigned int v10 = [v9 integerValue];

  if (*v7 == 1)
  {
    int v11 = *(_DWORD *)(*(void *)(a1 + 88) + 8LL);
    else {
      id v27 = @"draw";
    }
    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No thread execution data for the %@ call",  v27));
    if (!a2) {
      goto LABEL_33;
    }
    if (v10 == 3) {
      uint64_t v15 = @"Select a different threadgroup to debug and try again";
    }
    else {
      uint64_t v15 = 0LL;
    }
    if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
      unsigned int v16 = 4;
    }
    else {
      unsigned int v16 = 3;
    }
    id v17 = v14;
    goto LABEL_32;
  }

  if (v8 != (id)v7[1])
  {
    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Corrupt GPU data buffer [%u:%llu]",  v7[1],  v8));
    if (!a2)
    {
LABEL_33:

      goto LABEL_34;
    }

    if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
      unsigned int v16 = 4;
    }
    else {
      unsigned int v16 = 1;
    }
    id v17 = v14;
    uint64_t v15 = 0LL;
LABEL_32:
    id Error = GTShaderDebuggerMakeError(v16, v17, v15, 0LL, 0LL);
    *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    goto LABEL_33;
  }

  if ((unint64_t)v8 >= v7[2])
  {
    unsigned int v28 = v10 - 1;
    uint64_t v26 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v28,  4LL);
    -[NSMutableData appendBytes:length:](v26, "appendBytes:length:", v7, v7[2]);
    id v24 = -[NSMutableData copy](v26, "copy");

    goto LABEL_35;
  }

  id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"GPU data buffer limits exceeded [%u]",  v7[2]));
  if (a2)
  {
    if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
      unsigned int v19 = 4;
    }
    else {
      unsigned int v19 = 3;
    }
    unsigned int v29 = @"RequiredTraceBufferSize";
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v7[2]));
    unint64_t v30 = v20;
    id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL));
    id v22 = GTShaderDebuggerMakeError(v19, v18, 0LL, 0LL, v21);
    *a2 = (id)objc_claimAutoreleasedReturnValue(v22);
  }

LABEL_34:
  id v24 = 0LL;
LABEL_35:

  return v24;
}

id GTShaderDebuggerMakeResourceMappings(uint64_t **a1)
{
  id v2 = (id)(*a1)[1];
  uint64_t v3 = **a1;
  id v109 = *(uint64_t **)(v3 + 40);
  id v111 = v2;
  uint64_t v107 = *(void *)(v3 + 8);
  unint64_t v108 = *a1[11];
  __int128 v133 = 0u;
  __int128 v134 = 0u;
  __int128 v95 = a1;
  id v115 = a1[16];
  if ([v115 count])
  {
    __int128 v101 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v102 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    __int128 v96 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    __int128 v94 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    v167[0] = &off_5A0B50;
    v167[1] = &off_5A0B68;
    v168[0] = v102;
    v168[1] = v96;
    v167[2] = &off_5A0B80;
    v168[2] = v94;
    id v112 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v168,  v167,  3LL));
    __int128 v165 = *((_OWORD *)a1 + 2);
    v164[0] = &off_5A0B50;
    v164[1] = &off_5A0B68;
    v164[2] = &off_5A0B80;
    uint64_t v166 = a1[6];
    __int128 v152 = 0u;
    __int128 v153 = 0u;
    __int128 v150 = 0u;
    __int128 v151 = 0u;
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v165,  v164,  3LL));
    __int128 v98 = (apr_pool_t *)[obj countByEnumeratingWithState:&v150 objects:v163 count:16];
    if (v98)
    {
      uint64_t v97 = *(void *)v151;
      do
      {
        for (p = 0LL; p != v98; p = (apr_pool_t *)((char *)p + 1))
        {
          if (*(void *)v151 != v97) {
            objc_enumerationMutation(obj);
          }
          uint64_t v4 = *(void *)(*((void *)&v150 + 1) + 8LL * (void)p);
          id v5 = (void *)objc_claimAutoreleasedReturnValue([obj objectForKeyedSubscript:v4]);
          __int128 v148 = 0u;
          __int128 v149 = 0u;
          __int128 v146 = 0u;
          __int128 v147 = 0u;
          id v6 = [v5 countByEnumeratingWithState:&v146 objects:v162 count:16];
          if (v6)
          {
            uint64_t v7 = *(void *)v147;
            do
            {
              for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v147 != v7) {
                  objc_enumerationMutation(v5);
                }
                uint64_t v9 = *(void *)(*((void *)&v146 + 1) + 8LL * (void)i);
                unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v9]);
                id v11 = [v10 unsignedLongLongValue];

                if (v11)
                {
                  v145[0] = _NSConcreteStackBlock;
                  v145[1] = 3221225472LL;
                  v145[2] = ___GetCurrentEncoderBoundResources_block_invoke;
                  v145[3] = &unk_58F910;
                  v145[4] = v4;
                  v145[5] = v9;
                  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v115, "gt_firstObjectPassingTest:", v145));
                  if (v12)
                  {
                    unint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v112 objectForKeyedSubscript:v4]);
                    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v11));
                    [v13 addObject:v14];
                  }
                }
              }

              id v6 = [v5 countByEnumeratingWithState:&v146 objects:v162 count:16];
            }

            while (v6);
          }
        }

        __int128 v98 = (apr_pool_t *)[obj countByEnumeratingWithState:&v150 objects:v163 count:16];
      }

      while (v98);
    }

    uint64_t v15 = a1[3];
    __int128 v141 = 0u;
    __int128 v142 = 0u;
    __int128 v143 = 0u;
    __int128 v144 = 0u;
    id v16 = [v15 countByEnumeratingWithState:&v141 objects:v161 count:16];
    if (v16)
    {
      uint64_t v17 = *(void *)v142;
      do
      {
        for (uint64_t j = 0LL; j != v16; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v142 != v17) {
            objc_enumerationMutation(v15);
          }
          uint64_t v19 = *(void *)(*((void *)&v141 + 1) + 8LL * (void)j);
          v140[0] = _NSConcreteStackBlock;
          v140[1] = 3221225472LL;
          v140[2] = ___GetCurrentEncoderBoundResources_block_invoke_2;
          v140[3] = &unk_58F8E8;
          v140[4] = v19;
          uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v115, "gt_firstObjectPassingTest:", v140));
          if (v20) {
            -[NSMutableArray addObject:](v101, "addObject:", v19);
          }
        }

        id v16 = [v15 countByEnumeratingWithState:&v141 objects:v161 count:16];
      }

      while (v16);
    }

    unint64_t v21 = *v95[11];
    uint64_t v22 = *(void *)(**v95 + 40);
    unint64_t v23 = v95[2];
    __int128 v136 = 0u;
    __int128 v137 = 0u;
    __int128 v138 = 0u;
    __int128 v139 = 0u;
    id v24 = [v23 countByEnumeratingWithState:&v136 objects:v160 count:16];
    if (v24)
    {
      uint64_t v25 = *(void *)v137;
      do
      {
        for (unint64_t k = 0LL; k != v24; unint64_t k = (char *)k + 1)
        {
          if (*(void *)v137 != v25) {
            objc_enumerationMutation(v23);
          }
          id v27 = *(void **)(*((void *)&v136 + 1) + 8LL * (void)k);
          uint64_t Object = GTMTLSMContext_getObject(*(void *)v22, (uint64_t)[v27 unsignedLongLongValue], v21);
          if (Object)
          {
            int v29 = *(_DWORD *)Object;
            unint64_t v30 = v102;
            if (v29 != 22)
            {
              if (v29 != 80) {
                continue;
              }
              unint64_t v30 = v96;
            }

            -[NSMutableSet addObject:](v30, "addObject:", v27);
          }
        }

        id v24 = [v23 countByEnumeratingWithState:&v136 objects:v160 count:16];
      }

      while (v24);
    }

    uint64_t v113 = v95[1];
    if ([v113 count])
    {
      apr_pool_create_ex(&newpool, 0LL, 0LL, v31);
      pa = newpool;
      int v32 = apr_array_make(newpool, 32, 8);
      GTMTLSMContext_getObjects(*(_DWORD **)(v22 + 8), v21, v32);
      if (v32->nelts >= 1)
      {
        uint64_t v33 = 0LL;
        do
        {
          uint64_t v34 = *(void *)&v32->elts[8 * v33];
          if (v34)
          {
            if (*(void *)(v34 + 48))
            {
              __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:"));
              unsigned int v36 = [v113 containsObject:v35];

              if (v36)
              {
                int32x4_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v34 + 8)));
                -[NSMutableSet addObject:](v102, "addObject:", v37);
              }
            }
          }

          ++v33;
        }

        while (v33 < v32->nelts);
      }

      v32->uint64_t nelts = 0;
      GTMTLSMContext_getObjects(*(_DWORD **)(v22 + 16), v21, v32);
      if (v32->nelts >= 1)
      {
        uint64_t v38 = 0LL;
        do
        {
          uint64_t v39 = *(void *)&v32->elts[8 * v38];
          if (v39)
          {
            if (*(void *)(v39 + 48))
            {
              int32x4_t v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:"));
              unsigned int v41 = [v113 containsObject:v40];

              if (v41)
              {
                unsigned int v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v39 + 8)));
                -[NSMutableSet addObject:](v96, "addObject:", v42);
              }
            }
          }

          ++v38;
        }

        while (v38 < v32->nelts);
      }

      apr_pool_destroy(pa);
    }

    *((void *)&v99 + 1) = -[NSMutableArray copy](v101, "copy");
    id v43 = -[NSMutableSet copy](v102, "copy");
    *(void *)&__int128 v133 = v43;
    pb = (apr_pool_t *)-[NSMutableSet copy](v96, "copy");
    *((void *)&v133 + 1) = pb;
    *(void *)&__int128 v99 = -[NSMutableSet copy](v94, "copy");
    __int128 v134 = v99;
  }

  else
  {
    __int128 v99 = 0uLL;
    pb = 0LL;
    id v43 = 0LL;
  }

  id v116 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [v43 count]);
  __int128 v131 = 0u;
  __int128 v132 = 0u;
  __int128 v129 = 0u;
  __int128 v130 = 0u;
  id v44 = v43;
  id v45 = [v44 countByEnumeratingWithState:&v129 objects:v159 count:16];
  if (v45)
  {
    uint64_t v46 = *(void *)v130;
    do
    {
      for (unint64_t m = 0LL; m != v45; unint64_t m = (char *)m + 1)
      {
        if (*(void *)v130 != v46) {
          objc_enumerationMutation(v44);
        }
        id v48 = [*(id *)(*((void *)&v129 + 1) + 8 * (void)m) unsignedLongLongValue];
        unsigned int v49 = (void *)objc_claimAutoreleasedReturnValue([v111 bufferForKey:v48]);
        id v50 = DEVICEOBJECT(v49);
        uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(v50);

        if (v51)
        {
          unint64_t v52 = GTMTLSMContext_getObject(*v109, (uint64_t)v48, v108);
          if (v52)
          {
            unsigned int v53 = v52;
            unint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [v51 gpuAddress]));
            v163[0] = v53[1];
            id v55 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(*find_entry(v107, v163, 8uLL, 0LL) + 32LL) + 8LL));
            id v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v116, "setObject:forKeyedSubscript:", v54, v56);
          }
        }
      }

      id v45 = [v44 countByEnumeratingWithState:&v129 objects:v159 count:16];
    }

    while (v45);
  }

  uint64_t v114 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  -[apr_pool_t count](pb, "count"));
  __int128 v127 = 0u;
  __int128 v128 = 0u;
  __int128 v125 = 0u;
  __int128 v126 = 0u;
  id v57 = pb;
  id v58 = -[apr_pool_t countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v125,  v158,  16LL);
  if (v58)
  {
    uint64_t v59 = *(void *)v126;
    do
    {
      for (uint64_t n = 0LL; n != v58; uint64_t n = (char *)n + 1)
      {
        if (*(void *)v126 != v59) {
          objc_enumerationMutation(v57);
        }
        id v61 = [*(id *)(*((void *)&v125 + 1) + 8 * (void)n) unsignedLongLongValue];
        id v62 = (void *)objc_claimAutoreleasedReturnValue([v111 textureForKey:v61]);
        id v63 = DEVICEOBJECT(v62);
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(v63);

        if (v64)
        {
          uint64_t v65 = GTMTLSMContext_getObject(*v109, (uint64_t)v61, v108);
          if (v65)
          {
            v163[0] = v65[1];
            unsigned int v66 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(*find_entry(v107, v163, 8uLL, 0LL) + 32LL) + 8LL));
            id v67 = (void *)objc_claimAutoreleasedReturnValue(v66);
            id v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v64 uniqueIdentifier]));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v114, "setObject:forKeyedSubscript:", v67, v68);
          }
        }
      }

      id v58 = -[apr_pool_t countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v125,  v158,  16LL);
    }

    while (v58);
  }

  pc = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [(id)v99 count]);
  __int128 v123 = 0u;
  __int128 v124 = 0u;
  __int128 v121 = 0u;
  __int128 v122 = 0u;
  id v69 = (id)v99;
  id v70 = [v69 countByEnumeratingWithState:&v121 objects:v157 count:16];
  if (v70)
  {
    uint64_t v71 = *(void *)v122;
    do
    {
      for (iuint64_t i = 0LL; ii != v70; iuint64_t i = (char *)ii + 1)
      {
        if (*(void *)v122 != v71) {
          objc_enumerationMutation(v69);
        }
        id v73 = [*(id *)(*((void *)&v121 + 1) + 8 * (void)ii) unsignedLongLongValue];
        __int128 v74 = (void *)objc_claimAutoreleasedReturnValue([v111 samplerStateForKey:v73]);
        id v75 = DEVICEOBJECT(v74);
        __int128 v76 = (void *)objc_claimAutoreleasedReturnValue(v75);

        if (v76)
        {
          __int128 v77 = GTMTLSMContext_getObject(*v109, (uint64_t)v73, v108);
          if (v77)
          {
            v163[0] = v77[1];
            __int128 v78 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(*find_entry(v107, v163, 8uLL, 0LL) + 32LL) + 8LL));
            __int128 v79 = (void *)objc_claimAutoreleasedReturnValue(v78);
            __int128 v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v76 uniqueIdentifier]));
            -[NSMutableDictionary setObject:forKeyedSubscript:](pc, "setObject:forKeyedSubscript:", v79, v80);
          }
        }
      }

      id v70 = [v69 countByEnumeratingWithState:&v121 objects:v157 count:16];
    }

    while (v70);
  }

  id v110 = v95[17];
  __int128 v81 = -[NSMutableDictionary initWithCapacity:]( [NSMutableDictionary alloc],  "initWithCapacity:",  [*((id *)&v99 + 1) count]);
  __int128 v82 = v95[21];
  __int128 v117 = 0u;
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  id v83 = *((id *)&v99 + 1);
  id v84 = [v83 countByEnumeratingWithState:&v117 objects:v156 count:16];
  if (v84)
  {
    uint64_t v85 = *(void *)v118;
    do
    {
      for (juint64_t j = 0LL; jj != v84; juint64_t j = (char *)jj + 1)
      {
        if (*(void *)v118 != v85) {
          objc_enumerationMutation(v83);
        }
        uint64_t v87 = *(void *)(*((void *)&v117 + 1) + 8LL * (void)jj);
        __int128 v88 = (void *)objc_claimAutoreleasedReturnValue([v82 objectForKeyedSubscript:v87]);
        id v89 = DEVICEOBJECT(v88);
        __int128 v90 = (void *)objc_claimAutoreleasedReturnValue(v89);

        if (v90)
        {
          __int128 v91 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  [v90 gpuAddress]));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v81, "setObject:forKeyedSubscript:", v91, v87);
        }
      }

      id v84 = [v83 countByEnumeratingWithState:&v117 objects:v156 count:16];
    }

    while (v84);
  }

  v154[0] = @"Bytes";
  v154[1] = @"Buffers";
  v155[0] = v81;
  v155[1] = v116;
  v154[2] = @"Textures";
  void v154[3] = @"Samplers";
  v155[2] = v114;
  v155[3] = pc;
  v154[4] = @"ConstantSamplers";
  v155[4] = v110;
  __int128 v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v155,  v154,  5LL));

  __destructor_8_s0_s8_s16_s24((id *)&v133);
  return v92;
}

void sub_178280( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,id a57)
{
}

void __destructor_8_s0_s8_s16_s24(id *a1)
{
}

void ShaderDebugger::Metadata::MDSerializer::~MDSerializer(ShaderDebugger::Metadata::MDSerializer *this)
{
  id v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      id v2 = v3;
    }

    while (v3);
  }

  uint64_t v4 = (void *)*((void *)this + 3);
  *((void *)this + 3) = 0LL;
  if (v4) {
    operator delete(v4);
  }
  std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy(*((void **)this + 1));
}

void ShaderDebugger::Metadata::MDSerializer::addReferencedSourceFile( uint64_t a1, std::string *a2, const std::string *a3)
{
  id v6 = (uint64_t *)(a1 + 24);
  int size = (char)a2->__r_.__value_.__s.__size_;
  if (size >= 0) {
    id v8 = (uint64_t *)a2;
  }
  else {
    id v8 = (uint64_t *)a2->__r_.__value_.__r.__words[0];
  }
  if (size >= 0) {
    unint64_t v9 = a2->__r_.__value_.__s.__size_;
  }
  else {
    unint64_t v9 = a2->__r_.__value_.__l.__size_;
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  int8x8_t v11 = *(int8x8_t *)(a1 + 32);
  if (v11)
  {
    unint64_t v12 = v10;
    uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v15 = v10;
      if (v10 >= *(void *)&v11) {
        unint64_t v15 = v10 % *(void *)&v11;
      }
    }

    else
    {
      unint64_t v15 = (*(void *)&v11 - 1LL) & v10;
    }

    id v16 = *(unsigned __int8 ***)(*v6 + 8 * v15);
    if (v16)
    {
      for (uint64_t i = *v16; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v18 = *((void *)i + 1);
        if (v18 == v12)
        {
        }

        else
        {
          if (v14 > 1)
          {
            if (v18 >= *(void *)&v11) {
              v18 %= *(void *)&v11;
            }
          }

          else
          {
            v18 &= *(void *)&v11 - 1LL;
          }

          if (v18 != v15) {
            break;
          }
        }
      }
    }
  }

  std::string::size_type v19 = a3->__r_.__value_.__s.__size_;
  if ((v19 & 0x80u) != 0LL) {
    std::string::size_type v19 = a3->__r_.__value_.__l.__size_;
  }
  if (v19)
  {
    uint64_t v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>( v6,  (uint64_t)a2,  (uint64_t)a2);
    std::string::operator=((std::string *)(v20 + 40), a3);
  }

  else
  {
    memset(&v25, 0, sizeof(v25));
    int v26 = -1;
    unsigned int v28 = 0LL;
    int v29 = 0LL;
    __uint64_t n = 0LL;
    std::string::operator=(&v25, a2);
    if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unint64_t v21 = (const char *)a2;
    }
    else {
      unint64_t v21 = (const char *)a2->__r_.__value_.__r.__words[0];
    }
    if (!stat(v21, &v30) && (v30.st_mode & 0xF000) == 0x8000)
    {
      __uint64_t n = v30.st_size;
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v22 = (const char *)a2;
      }
      else {
        uint64_t v22 = (const char *)a2->__r_.__value_.__r.__words[0];
      }
      int v26 = open(v22, 0, 0LL);
      unsigned int v28 = mmap(0LL, __n, 1, 2, v26, 0LL);
      int v29 = v28;
    }

    if (v26 != -1)
    {
      memset(&v30, 0, 24);
      if (__n)
      {
        std::string::resize((std::string *)&v30, __n, 0);
        if ((v30.st_gid & 0x80000000) == 0) {
          unint64_t v23 = &v30;
        }
        else {
          unint64_t v23 = *(stat **)&v30.st_dev;
        }
        memcpy(v23, v28, __n);
      }

      id v24 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>( v6,  (uint64_t)a2,  (uint64_t)a2);
      std::string::operator=((std::string *)(v24 + 40), (const std::string *)&v30);
      if (SHIBYTE(v30.st_gid) < 0) {
        operator delete(*(void **)&v30.st_dev);
      }
      if (v26 != -1)
      {
        munmap(v28, __n);
        close(v26);
        int v26 = -1;
      }
    }
  }

char *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>( uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    id v8 = (uint64_t *)a2;
  }
  else {
    id v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = a1[1];
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }

    unint64_t v15 = *(void ***)(*a1 + 8 * v3);
    if (v15)
    {
      id v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          unint64_t v17 = *((void *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]( (unsigned __int8 *)v16 + 16,  (unsigned __int8 *)a2))
            {
              return v16;
            }
          }

          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12) {
                v17 %= v12;
              }
            }

            else
            {
              v17 &= v12 - 1;
            }

            if (v17 != v3) {
              break;
            }
          }

          id v16 = *(char **)v16;
        }

        while (v16);
      }
    }
  }

  unint64_t v18 = a1 + 2;
  id v16 = (char *)operator new(0x40uLL);
  *(void *)id v16 = 0LL;
  *((void *)v16 + 1) = v11;
  std::string::size_type v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v16 + 4) = *(void *)(a3 + 16);
  }

  *((void *)v16 + 5) = 0LL;
  *((void *)v16 + 6) = 0LL;
  *((void *)v16 + 7) = 0LL;
  float v20 = (float)(unint64_t)(a1[3] + 1);
  float v21 = *((float *)a1 + 8);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1LL;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1LL)
    {
      int8x8_t prime = (int8x8_t)2LL;
    }

    else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }

    unint64_t v12 = a1[1];
    if (*(void *)&prime > v12) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v12)
    {
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }

      else
      {
        uint64_t v34 = 1LL << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }

      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = a1[1];
      }

      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v26 = operator new(8LL * *(void *)&prime);
          id v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27) {
            operator delete(v27);
          }
          uint64_t v28 = 0LL;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v28++) = 0LL;
          while (*(void *)&prime != v28);
          int v29 = (void *)*v18;
          if (*v18)
          {
            unint64_t v30 = v29[1];
            uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&prime) {
                v30 %= *(void *)&prime;
              }
            }

            else
            {
              v30 &= *(void *)&prime - 1LL;
            }

            *(void *)(*a1 + 8 * v30) = v18;
            __int128 v35 = (void *)*v29;
            if (*v29)
            {
              do
              {
                unint64_t v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(void *)&prime) {
                    v36 %= *(void *)&prime;
                  }
                }

                else
                {
                  v36 &= *(void *)&prime - 1LL;
                }

                if (v36 != v30)
                {
                  if (!*(void *)(*a1 + 8 * v36))
                  {
                    *(void *)(*a1 + 8 * v36) = v29;
                    goto LABEL_64;
                  }

                  *int v29 = *v35;
                  *__int128 v35 = **(void **)(*a1 + 8 * v36);
                  **(void **)(*a1 + 8 * v36) = v35;
                  __int128 v35 = v29;
                }

                unint64_t v36 = v30;
LABEL_64:
                int v29 = v35;
                __int128 v35 = (void *)*v35;
                unint64_t v30 = v36;
              }

              while (v35);
            }
          }

          unint64_t v12 = (unint64_t)prime;
          goto LABEL_68;
        }

        unsigned int v41 = (void *)*a1;
        *a1 = 0LL;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v12 = 0LL;
        a1[1] = 0LL;
      }
    }

void ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(unint64_t *a1, _BYTE *a2)
{
  uint64_t v4 = (_BYTE *)a1[1];
  unint64_t v5 = a1[2] - *a1;
  if (v5 < (unint64_t)&v4[-*a1 + 8])
  {
    std::vector<unsigned char>::reserve(a1, (2 * v5) | 1);
    uint64_t v4 = (_BYTE *)a1[1];
  }

  uint64_t v6 = 8LL;
  do
  {
    unint64_t v7 = a1[2];
    if ((unint64_t)v4 >= v7)
    {
      unint64_t v9 = *a1;
      unint64_t v10 = &v4[-*a1];
      unint64_t v11 = (unint64_t)(v10 + 1);
      unint64_t v12 = v7 - v9;
      if (2 * v12 > v11) {
        unint64_t v11 = 2 * v12;
      }
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v13 = v11;
      }
      if (v13) {
        unint64_t v14 = (char *)operator new(v13);
      }
      else {
        unint64_t v14 = 0LL;
      }
      unint64_t v15 = &v10[(void)v14];
      id v16 = &v10[(void)v14];
      *id v16 = *a2;
      id v8 = v16 + 1;
      if (v4 != (_BYTE *)v9)
      {
        unint64_t v17 = &v4[~v9];
        do
        {
          char v18 = *--v4;
          (v17--)[(void)v14] = v18;
        }

        while (v4 != (_BYTE *)v9);
        uint64_t v4 = (_BYTE *)*a1;
        unint64_t v15 = v14;
      }

      *a1 = (unint64_t)v15;
      a1[1] = (unint64_t)v8;
      a1[2] = (unint64_t)&v14[v13];
      if (v4) {
        operator delete(v4);
      }
    }

    else
    {
      *uint64_t v4 = *a2;
      id v8 = v4 + 1;
    }

    ++a2;
    a1[1] = (unint64_t)v8;
    uint64_t v4 = v8;
    --v6;
  }

  while (v6);
}

void ShaderDebugger::Metadata::MDSerializer::write(unint64_t *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  unint64_t v6 = a1[2] - *a1;
  if (v6 < a3 - *a1 + a1[1]) {
    std::vector<unsigned char>::reserve(a1, (2 * v6) | 1);
  }
  if (v3)
  {
    unint64_t v7 = (_BYTE *)a1[1];
    do
    {
      unint64_t v8 = a1[2];
      if ((unint64_t)v7 >= v8)
      {
        unint64_t v10 = *a1;
        unint64_t v11 = &v7[-*a1];
        unint64_t v12 = (unint64_t)(v11 + 1);
        unint64_t v13 = v8 - v10;
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v14 = v12;
        }
        if (v14) {
          unint64_t v15 = (char *)operator new(v14);
        }
        else {
          unint64_t v15 = 0LL;
        }
        id v16 = &v11[(void)v15];
        unint64_t v17 = &v11[(void)v15];
        *unint64_t v17 = *a2;
        unint64_t v9 = v17 + 1;
        if (v7 != (_BYTE *)v10)
        {
          char v18 = &v7[~v10];
          do
          {
            char v19 = *--v7;
            (v18--)[(void)v15] = v19;
          }

          while (v7 != (_BYTE *)v10);
          unint64_t v7 = (_BYTE *)*a1;
          id v16 = v15;
        }

        *a1 = (unint64_t)v16;
        a1[1] = (unint64_t)v9;
        a1[2] = (unint64_t)&v15[v14];
        if (v7) {
          operator delete(v7);
        }
      }

      else
      {
        *unint64_t v7 = *a2;
        unint64_t v9 = v7 + 1;
      }

      ++a2;
      a1[1] = (unint64_t)v9;
      unint64_t v7 = v9;
      --v3;
    }

    while (v3);
  }

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000LL) != 0) {
      abort();
    }
    unint64_t v5 = (char *)a1[1];
    unint64_t v6 = operator new(__sz);
    unint64_t v7 = &v5[(void)v6 - v2];
    unint64_t v8 = v7;
    if (v5 != (char *)v2)
    {
      unint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }

      while (v5 != (char *)v2);
      unint64_t v8 = v6;
    }

    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2) {
      operator delete((void *)v2);
    }
  }

uint64_t ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(uint64_t a1, uint64_t a2)
{
  int isMetadataIdReserved = ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)a1, a2);
  unint64_t v5 = *(char **)a1;
  unint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(char **)a1;
  if (*(char **)a1 != v6)
  {
    unint64_t v7 = *(char **)a1;
    while (*(void *)v7 != a2)
    {
      v7 += 8;
      if (v7 == v6)
      {
        unint64_t v7 = *(char **)(a1 + 8);
        break;
      }
    }
  }

  if (v7 == v6) {
    unint64_t v8 = -1LL;
  }
  else {
    unint64_t v8 = (v7 - v5) >> 3;
  }
  if (v8 == -1LL) {
    int v9 = 1;
  }
  else {
    int v9 = isMetadataIdReserved;
  }
  if (v9 != 1) {
    return -1LL;
  }
  if (!isMetadataIdReserved)
  {
    unint64_t v10 = *(void *)(a1 + 16);
    if ((unint64_t)v6 >= v10)
    {
      uint64_t v12 = (v6 - v5) >> 3;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
LABEL_34:
      }
        abort();
      uint64_t v14 = v10 - (void)v5;
      if (v14 >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      BOOL v15 = (unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8LL;
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v15) {
        unint64_t v16 = v13;
      }
      if (v16)
      {
        unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v16);
        unint64_t v5 = *(char **)a1;
        unint64_t v6 = *(char **)(a1 + 8);
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      char v18 = (uint64_t *)(v16 + 8 * v12);
      unint64_t v19 = v16 + 8 * v17;
      *char v18 = a2;
      unint64_t v11 = v18 + 1;
      while (v6 != v5)
      {
        uint64_t v20 = *((void *)v6 - 1);
        v6 -= 8;
        *--char v18 = v20;
      }

      *(void *)a1 = v18;
      *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
      *(void *)(a1 + 16) = v19;
      if (v5) {
        operator delete(v5);
      }
    }

    else
    {
      *(void *)unint64_t v6 = a2;
      unint64_t v11 = v6 + 8;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v11;
    char v22 = 0;
    std::vector<BOOL>::push_back((uint64_t *)(a1 + 24), &v22);
    return ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3) - 1;
  }

  if (*(void *)(a1 + 32) <= v8) {
    goto LABEL_34;
  }
  *(void *)(*(void *)(a1 + 24) + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= ~(1LL << v8);
  return v8;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved(char **a1, uint64_t a2)
{
  unint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v4 = *a1;
  if (*a1 != v3)
  {
    while (*(void *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v3)
      {
        uint64_t v4 = a1[1];
        break;
      }
    }
  }

  if (v4 == v3) {
    return 0LL;
  }
  unint64_t v5 = v4 - v2;
  unint64_t v6 = (v4 - v2) >> 3;
  return (*(void *)&a1[3][(v6 >> 3) & 0x1FFFFFFFFFFFFFF8LL] >> (v5 >> 3)) & 1LL;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeLocation( uint64_t **a1, uint64_t a2, std::string *a3, std::string *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v57 = a5;
  uint64_t v56 = a6;
  __str.__r_.__value_.__r.__words[0] = 1LL;
  unint64_t v10 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  1uLL,  &__str);
  unint64_t v11 = v10;
  uint64_t v13 = (uint64_t)(v10 + 40);
  uint64_t v12 = (void *)*((void *)v10 + 5);
  uint64_t v14 = (void *)*((void *)v10 + 6);
  BOOL v15 = v12;
  if (v12 != v14)
  {
    while (*v15 != a2)
    {
      if (++v15 == v14)
      {
        BOOL v15 = (void *)*((void *)v10 + 6);
        break;
      }
    }
  }

  uint64_t v16 = v15 - v12;
  if (v15 == v14) {
    uint64_t v17 = -1LL;
  }
  else {
    uint64_t v17 = v16;
  }
  if (v17 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v10 + 5, a2))
  {
    uint64_t v17 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v13, a2);
    uint64_t v55 = v17;
    else {
      std::string __str = *a3;
    }
    else {
      std::string v53 = *a4;
    }
    int size = (char)a3->__r_.__value_.__s.__size_;
    if (size < 0)
    {
      std::string::__init_copy_ctor_external(&v52, a3->__r_.__value_.__l.__data_, a3->__r_.__value_.__l.__size_);
      int size = (char)a3->__r_.__value_.__s.__size_;
      if (size < 0)
      {
        uint64_t v20 = (std::string *)a3->__r_.__value_.__r.__words[0];
        std::string::size_type v19 = a3->__r_.__value_.__l.__size_;
        goto LABEL_20;
      }
    }

    else
    {
      std::string v52 = *a3;
    }

    std::string::size_type v19 = size;
    uint64_t v20 = a3;
LABEL_20:
    float v21 = (unint64_t *)(v11 + 88);
    if (v19)
    {
      char v22 = (std::string *)((char *)v20 + v19);
      unint64_t v23 = v20;
      while (v23->__r_.__value_.__s.__data_[0] != 47)
      {
        unint64_t v23 = (std::string *)((char *)v23 + 1);
        if (!--v19) {
          goto LABEL_27;
        }
      }

      if (v23 != v22 && v23 == v20)
      {
LABEL_56:
        p_str = &__str;
        if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        std::string::size_type v36 = __str.__r_.__value_.__s.__size_;
        if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          std::string::size_type v36 = __str.__r_.__value_.__l.__size_;
        }
        while (v36)
        {
          int v37 = p_str->__r_.__value_.__s.__data_[--v36];
          if (v37 == 47)
          {
            if (v36 != -1LL)
            {
              std::string::size_type v38 = v36 + 1;
              std::string::basic_string(&v51, &__str, 0LL, v36 + 1, (std::allocator<char> *)&v58);
              std::string v53 = v51;
              std::string::basic_string(&v51, &__str, v38, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v58);
              std::string v52 = v51;
            }

            break;
          }
        }

        if ((char)v53.__r_.__value_.__s.__size_ < 0)
        {
          std::string::size_type v39 = v53.__r_.__value_.__l.__size_;
          if (!v53.__r_.__value_.__l.__size_) {
            goto LABEL_75;
          }
          int32x4_t v40 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }

        else
        {
          std::string::size_type v39 = v53.__r_.__value_.__s.__size_;
          if (!v53.__r_.__value_.__s.__size_) {
            goto LABEL_75;
          }
          int32x4_t v40 = &v53;
        }

        if (v40->__r_.__value_.__s.__data_[v39 - 1] != 47) {
          std::string::append(&v53, "/");
        }
LABEL_75:
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v55);
        int v41 = (char)v52.__r_.__value_.__s.__size_;
        if ((v52.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v42 = v52.__r_.__value_.__s.__size_;
        }
        else {
          uint64_t v42 = v52.__r_.__value_.__l.__size_;
        }
        v51.__r_.__value_.__r.__words[0] = v42;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v51);
        id v43 = (void *)v52.__r_.__value_.__r.__words[0];
        if (v41 >= 0) {
          id v44 = &v52;
        }
        else {
          id v44 = (std::string *)v52.__r_.__value_.__r.__words[0];
        }
        ShaderDebugger::Metadata::MDSerializer::write(v21, v44, v42);
        std::string::size_type v45 = v53.__r_.__value_.__s.__size_;
        if ((v53.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          std::string::size_type v45 = v53.__r_.__value_.__l.__size_;
        }
        v51.__r_.__value_.__r.__words[0] = v45;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v51);
        if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v46 = &v53;
        }
        else {
          uint64_t v46 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v47 = v53.__r_.__value_.__s.__size_;
        }
        else {
          uint64_t v47 = v53.__r_.__value_.__l.__size_;
        }
        ShaderDebugger::Metadata::MDSerializer::write(v21, v46, v47);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v57);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v21, &v56);
        std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>( (uint64_t)&v51,  (const void **)&v53.__r_.__value_.__l.__data_,  (const void **)&v52.__r_.__value_.__l.__data_);
        std::string::size_type v48 = v51.__r_.__value_.__s.__size_;
        unsigned __int8 v49 = v51.__r_.__value_.__s.__size_;
        if ((v51.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          std::string::size_type v48 = v51.__r_.__value_.__l.__size_;
        }
        if (v48)
        {
          memset(&v58, 0, sizeof(v58));
          ShaderDebugger::Metadata::MDSerializer::addReferencedSourceFile((uint64_t)a1, &v51, &v58);
          unsigned __int8 v49 = v51.__r_.__value_.__s.__size_;
        }

        if ((v49 & 0x80) != 0)
        {
          operator delete(v51.__r_.__value_.__l.__data_);
          if ((v41 & 0x80000000) == 0) {
            goto LABEL_97;
          }
        }

        else if ((v41 & 0x80000000) == 0)
        {
LABEL_97:
          return v17;
        }

        operator delete(v43);
        goto LABEL_97;
      }
    }

uint64_t std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>( uint64_t a1, const void **a2, const void **a3)
{
  else {
    size_t v5 = (size_t)a2[1];
  }
  else {
    size_t v6 = (size_t)a3[1];
  }
  uint64_t result = std::string::basic_string[abi:nn180100](a1, v6 + v5);
  else {
    unint64_t v8 = *(char **)result;
  }
  if (v5)
  {
    else {
      int v9 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }

  unint64_t v10 = &v8[v5];
  if (v6)
  {
    else {
      unint64_t v11 = *a3;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }

  v10[v6] = 0;
  return result;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeSubprogram( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = a4;
  uint64_t v21 = 0LL;
  size_t v6 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  0LL,  &v21);
  unint64_t v7 = v6;
  uint64_t v9 = (uint64_t)(v6 + 40);
  unint64_t v8 = (void *)*((void *)v6 + 5);
  unint64_t v10 = (void *)*((void *)v6 + 6);
  unint64_t v11 = v8;
  if (v8 != v10)
  {
    while (*v11 != a2)
    {
      if (++v11 == v10)
      {
        unint64_t v11 = (void *)*((void *)v6 + 6);
        break;
      }
    }
  }

  uint64_t v12 = v11 - v8;
  if (v11 == v10) {
    uint64_t v13 = -1LL;
  }
  else {
    uint64_t v13 = v12;
  }
  if (v13 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v6 + 5, a2))
  {
    uint64_t v13 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v9, a2);
    uint64_t v19 = v13;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v7 + 11, &v19);
    uint64_t v14 = *(unsigned __int8 *)(a3 + 23);
    if ((v14 & 0x80u) != 0LL) {
      uint64_t v14 = *(void *)(a3 + 8);
    }
    uint64_t v21 = v14;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v7 + 11, &v21);
    int v15 = *(char *)(a3 + 23);
    if (v15 >= 0) {
      uint64_t v16 = (_BYTE *)a3;
    }
    else {
      uint64_t v16 = *(_BYTE **)a3;
    }
    if (v15 >= 0) {
      uint64_t v17 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v17 = *(void *)(a3 + 8);
    }
    ShaderDebugger::Metadata::MDSerializer::write((unint64_t *)v7 + 11, v16, v17);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v7 + 11, &v20);
  }

  return v13;
}

void ShaderDebugger::Metadata::MDSerializer::serializeFunctionTracepoint( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v20 = a5;
  uint64_t v21 = a3;
  uint64_t v18 = -1LL;
  uint64_t v19 = a6;
  uint64_t v17 = 6LL;
  unint64_t v8 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  6uLL,  &v17);
  uint64_t v9 = v8;
  uint64_t v11 = (uint64_t)(v8 + 40);
  unint64_t v10 = (char *)*((void *)v8 + 5);
  uint64_t v12 = (char *)*((void *)v8 + 6);
  uint64_t v13 = v10;
  if (v10 != v12)
  {
    while (*(void *)v13 != a2)
    {
      v13 += 8;
      if (v13 == v12)
      {
        uint64_t v13 = (char *)*((void *)v8 + 6);
        break;
      }
    }
  }

  uint64_t v14 = (char *)(v13 - v10);
  BOOL v15 = v13 == v12 || v14 + 8 == 0LL;
  if (v15 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v8 + 5, a2))
  {
    uint64_t v17 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v11, a2);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v17);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v21);
    uint64_t v16 = a4;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v16);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v20);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v19);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v9 + 11, &v18);
  }

void ShaderDebugger::Metadata::MDSerializer::write<unsigned int>(unint64_t *a1, _BYTE *a2)
{
  uint64_t v4 = (_BYTE *)a1[1];
  unint64_t v5 = a1[2] - *a1;
  if (v5 < (unint64_t)&v4[-*a1 + 4])
  {
    std::vector<unsigned char>::reserve(a1, (2 * v5) | 1);
    uint64_t v4 = (_BYTE *)a1[1];
  }

  uint64_t v6 = 4LL;
  do
  {
    unint64_t v7 = a1[2];
    if ((unint64_t)v4 >= v7)
    {
      unint64_t v9 = *a1;
      unint64_t v10 = &v4[-*a1];
      unint64_t v11 = (unint64_t)(v10 + 1);
      unint64_t v12 = v7 - v9;
      if (2 * v12 > v11) {
        unint64_t v11 = 2 * v12;
      }
      if (v12 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v13 = v11;
      }
      if (v13) {
        uint64_t v14 = (char *)operator new(v13);
      }
      else {
        uint64_t v14 = 0LL;
      }
      BOOL v15 = &v10[(void)v14];
      uint64_t v16 = &v10[(void)v14];
      *uint64_t v16 = *a2;
      unint64_t v8 = v16 + 1;
      if (v4 != (_BYTE *)v9)
      {
        uint64_t v17 = &v4[~v9];
        do
        {
          char v18 = *--v4;
          (v17--)[(void)v14] = v18;
        }

        while (v4 != (_BYTE *)v9);
        uint64_t v4 = (_BYTE *)*a1;
        BOOL v15 = v14;
      }

      *a1 = (unint64_t)v15;
      a1[1] = (unint64_t)v8;
      a1[2] = (unint64_t)&v14[v13];
      if (v4) {
        operator delete(v4);
      }
    }

    else
    {
      *uint64_t v4 = *a2;
      unint64_t v8 = v4 + 1;
    }

    ++a2;
    a1[1] = (unint64_t)v8;
    uint64_t v4 = v8;
    --v6;
  }

  while (v6);
}

void ShaderDebugger::Metadata::MDSerializer::serializeVariableBase( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v14 = a4;
  uint64_t v15 = a2;
  uint64_t v13 = a5;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v15);
  uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
  if ((v9 & 0x80u) != 0LL) {
    uint64_t v9 = *(void *)(a3 + 8);
  }
  uint64_t v16 = v9;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v16);
  int v10 = *(char *)(a3 + 23);
  if (v10 >= 0) {
    unint64_t v11 = (_BYTE *)a3;
  }
  else {
    unint64_t v11 = *(_BYTE **)a3;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a3 + 8);
  }
  ShaderDebugger::Metadata::MDSerializer::write(a1, v11, v12);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v14);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v13);
  uint64_t v16 = a6;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v16);
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeLocalVariable( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v34 = 2LL;
  unint64_t v11 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  2uLL,  &v34);
  uint64_t v12 = (unint64_t *)v11;
  uint64_t v14 = (uint64_t)(v11 + 40);
  uint64_t v13 = (void *)*((void *)v11 + 5);
  uint64_t v15 = (void *)*((void *)v11 + 6);
  uint64_t v16 = v13;
  if (v13 != v15)
  {
    while (*v16 != a2)
    {
      if (++v16 == v15)
      {
        uint64_t v16 = (void *)*((void *)v11 + 6);
        break;
      }
    }
  }

  uint64_t v17 = v16 - v13;
  if (v16 == v15) {
    uint64_t v18 = -1LL;
  }
  else {
    uint64_t v18 = v17;
  }
  if (v18 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v11 + 5, a2))
  {
    uint64_t v18 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v14, a2);
    uint64_t v19 = v12 + 11;
    ShaderDebugger::Metadata::MDSerializer::serializeVariableBase(v12 + 11, v18, a3, a4, a5, 0LL);
    uint64_t v21 = (_BYTE *)v12[12];
    unint64_t v20 = v12[13];
    unint64_t v22 = v12[11];
    if (v20 - v22 < (unint64_t)&v21[-v22 + 1])
    {
      std::vector<unsigned char>::reserve(v12 + 11, (2 * (v20 - v22)) | 1);
      uint64_t v21 = (_BYTE *)v12[12];
      unint64_t v20 = v12[13];
    }

    if ((unint64_t)v21 >= v20)
    {
      unint64_t v24 = *v19;
      std::string v25 = &v21[-*v19];
      unint64_t v26 = (unint64_t)(v25 + 1);
      unint64_t v27 = v20 - v24;
      if (2 * v27 > v26) {
        unint64_t v26 = 2 * v27;
      }
      if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v28 = v26;
      }
      if (v28) {
        unint64_t v29 = (unint64_t)operator new(v28);
      }
      else {
        unint64_t v29 = 0LL;
      }
      unint64_t v30 = (char *)(v29 + v28);
      v25[v29] = a6;
      uint64_t v23 = (uint64_t)&v25[v29 + 1];
      if (v21 == (_BYTE *)v24)
      {
        v29 += (unint64_t)v25;
      }

      else
      {
        std::string::size_type v31 = &v21[~v24];
        do
        {
          char v32 = *--v21;
          (v31--)[v29] = v32;
        }

        while (v21 != (_BYTE *)v24);
        uint64_t v21 = (_BYTE *)*v19;
      }

      v12[11] = v29;
      v12[12] = v23;
      v12[13] = (unint64_t)v30;
      if (v21) {
        operator delete(v21);
      }
    }

    else
    {
      _BYTE *v21 = a6;
      uint64_t v23 = (uint64_t)(v21 + 1);
    }

    v12[12] = v23;
  }

  return v18;
}

uint64_t ShaderDebugger::Metadata::MDSerializer::serializeGlobalVariable( uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = 2LL;
  uint64_t v9 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  2uLL,  &v18);
  int v10 = v9;
  uint64_t v12 = (uint64_t)(v9 + 40);
  unint64_t v11 = (void *)*((void *)v9 + 5);
  uint64_t v13 = (void *)*((void *)v9 + 6);
  uint64_t v14 = v11;
  if (v11 != v13)
  {
    while (*v14 != a2)
    {
      if (++v14 == v13)
      {
        uint64_t v14 = (void *)*((void *)v9 + 6);
        break;
      }
    }
  }

  uint64_t v15 = v14 - v11;
  if (v14 == v13) {
    uint64_t v16 = -1LL;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16 == -1 || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v9 + 5, a2))
  {
    uint64_t v16 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v12, a2);
    ShaderDebugger::Metadata::MDSerializer::serializeVariableBase((unint64_t *)v10 + 11, v16, a3, a4, a5, 1LL);
  }

  return v16;
}

void ShaderDebugger::Metadata::MDSerializer::serializeTypeBase( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9)
{
  uint64_t v19 = a4;
  uint64_t v20 = a2;
  uint64_t v17 = a6;
  uint64_t v18 = a5;
  uint64_t v16 = a7;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v20);
  uint64_t v12 = *(unsigned __int8 *)(a3 + 23);
  if ((v12 & 0x80u) != 0LL) {
    uint64_t v12 = *(void *)(a3 + 8);
  }
  uint64_t v21 = v12;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v21);
  int v13 = *(char *)(a3 + 23);
  if (v13 >= 0) {
    uint64_t v14 = (_BYTE *)a3;
  }
  else {
    uint64_t v14 = *(_BYTE **)a3;
  }
  if (v13 >= 0) {
    uint64_t v15 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v15 = *(void *)(a3 + 8);
  }
  ShaderDebugger::Metadata::MDSerializer::write(a1, v14, v15);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v19);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v18);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v17);
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v16);
  uint64_t v21 = a8;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v21);
  uint64_t v21 = a9;
  ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(a1, &v21);
}

void sub_179F5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17A168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17A1FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_17A32C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_17A3D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_17A5F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17AA34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17AB54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_17ACF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17AE40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17B05C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17B2B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17B348( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_17B51C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17BA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17BC0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_17BCE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17BD70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17BDBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_17BE98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()( unint64_t **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = **a1;
  unint64_t v7 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( a1[2],  v6);
  if (v6 == -1LL || v7 != 0LL)
  {
    *(_DWORD *)a1[1] = v7[3];
    return;
  }

  uint64_t v9 = *a1[4];
  unint64_t v10 = *(void *)(v9 + 80) + a2;
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[3][1] - *a1[3]) >> 4);
  if (a3 != 4294950959LL)
  {
    if (a3 != 4294951017LL) {
      goto LABEL_17;
    }
    uint64_t Object = GTMTLSMContext_getObject(**(void **)(v9 + 40), v6, v10);
    uint64_t v13 = Object[6];
    if (v13)
    {
      AddFunctionIfExist(*a1[4], (char **)a1[3], *(void *)(v13 + 1296), v10, (void *)*a1[5], 1);
      AddFunctionIfExist(*a1[4], (char **)a1[3], *(void *)(Object[6] + 1176LL), v10, (void *)*a1[5], 2);
    }

    uint64_t v14 = Object[8];
    if (v14) {
      AddFunctionIfExist(*a1[4], (char **)a1[3], *(void *)(v14 + 120), v10, (void *)*a1[5], 3);
    }
    uint64_t v15 = Object[9];
    if (!v15) {
      goto LABEL_17;
    }
    AddFunctionIfExist(*a1[4], (char **)a1[3], *(void *)(v15 + 360), v10, (void *)*a1[5], 7);
    uint64_t v16 = (char **)a1[3];
    uint64_t v17 = *a1[4];
    uint64_t v18 = *(void *)(Object[9] + 368LL);
    uint64_t v19 = (void *)*a1[5];
    unint64_t v20 = v10;
    int v21 = 8;
    goto LABEL_16;
  }

  unint64_t v22 = GTMTLSMContext_getObject(**(void **)(v9 + 40), v6, v10);
  AddFunctionIfExist(*a1[4], (char **)a1[3], v22[6], v10, (void *)*a1[5], 3);
  uint64_t v23 = v22[7];
  if (v23)
  {
    uint64_t v16 = (char **)a1[3];
    uint64_t v17 = *a1[4];
    uint64_t v18 = *(void *)(v23 + 848);
    uint64_t v19 = (void *)*a1[5];
    unint64_t v20 = v10;
    int v21 = 3;
LABEL_16:
    AddFunctionIfExist(v17, v16, v18, v20, v19, v21);
  }

void AddFunctionIfExist(uint64_t a1, char **a2, uint64_t a3, unint64_t a4, void *a5, int a6)
{
  id v39 = a5;
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(a1 + 40), a3, a4);
  if (!Object) {
    goto LABEL_34;
  }
  uint64_t v12 = Object;
  uint64_t v13 = Object + 1;
  uint64_t v38 = Object[1];
  uint64_t v14 = *(void *)(*(void *)(*find_entry(*(void *)(a1 + 8), (_BYTE *)Object + 8, 8uLL, 0LL) + 32LL) + 8LL);
  uint64_t v37 = v13[4];
  uint64_t v15 = *a2;
  uint64_t v16 = a2[1];
  uint64_t v17 = v13[6];
  if (v17) {
    uint64_t v18 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v17));
  }
  else {
    uint64_t v18 = &stru_591D98;
  }
  unsigned int v19 = [v39 addString:v18];
  if (v17) {

  }
  uint64_t v20 = v12[10];
  if (v20)
  {
    if (*(void *)(v20 + 8))
    {
      int v21 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
      unsigned int v22 = [v39 addString:v21];
    }

    else
    {
      uint64_t v23 = *(void *)(v20 + 16);
      if (v23) {
        int v21 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(v20 + 16)));
      }
      else {
        int v21 = &stru_591D98;
      }
      unsigned int v22 = [v39 addString:v21];
      if (!v23) {
        goto LABEL_16;
      }
    }
  }

  else
  {
    unsigned int v22 = 0;
  }

void sub_17C674( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  if (v13) {

  }
  _Unwind_Resume(a1);
}

id GTShaderProfilerStreamDataFromReplayDataSource(uint64_t **a1, uint64_t a2, uint64_t a3, apr_allocator_t *a4)
{
  if ((shared_initialized & 1) != 0) {
    goto LABEL_11;
  }
  if (initialized++) {
    goto LABEL_11;
  }
  if ((apr_pools_shared_initialized & 1) != 0
    || (int v7 = apr_pools_initialized, ++apr_pools_initialized, v7))
  {
LABEL_5:
    if (!apr_pool_create_ex((apr_pool_t **)&v178, 0LL, 0LL, a4)) {
      *(void *)(v178 + 80) = "apr_initialize";
    }
    goto LABEL_11;
  }

  uint64_t v4 = &unk_5B9000;
  global_allocator = 0LL;
  vm_address_t v8 = GTCoreAlloc(0xC8uLL);
  if (!v8)
  {
LABEL_10:
    apr_pools_initialized = 0;
    goto LABEL_11;
  }

  *(_OWORD *)vm_address_t v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(void *)(v8 + 192) = 0LL;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 144) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)(v8 + 4_Block_object_dispose(va, 8) = 0u;
  global_allocator = v8;
  *(int64x2_t *)(v8 + _Block_object_dispose(va, 8) = vdupq_n_s64(0x8000uLL);
  if (apr_pool_create_ex((apr_pool_t **)&global_pool, 0LL, (apr_abortfunc_t)v8, a4))
  {
    apr_allocator_destroy((apr_allocator_t *)global_allocator);
    global_allocator = 0LL;
    goto LABEL_10;
  }

  __int128 v136 = (apr_pool_t *)global_pool;
  *(void *)(global_pool + 80) = "apr_global_pool";
  if (hash_mutex)
  {
LABEL_258:
    uint64_t v139 = global_allocator;
    uint64_t v140 = global_pool;
    *(void *)(global_allocator + 24) = v178;
    *(void *)(v139 + 32) = v140;
    goto LABEL_5;
  }

  hash_mutex = (uint64_t)apr_palloc(v136, 0x38uLL);
  apr_pool_cleanup_register(v136, (const void *)hash_mutex, (apr_status_t (__cdecl *)(void *))atomic_cleanup, v137);
  uint64_t v138 = 0LL;
  while (!apr_thread_mutex_create((apr_thread_mutex_t **)(hash_mutex + v138), v136, v9))
  {
    v138 += 8LL;
    if (v138 == 56)
    {
      LODWORD(v136) = global_pool;
      goto LABEL_258;
    }
  }

LABEL_111:
              int v53 = 2;
              goto LABEL_112;
            }

            int v71 = v152;
            if (v50 != -15486)
            {
              int v72 = -15297;
              goto LABEL_107;
            }
          }

            uint64_t v95 = *((void *)__p + v74) + 8 * HIDWORD(v74);
            if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v133,  *(_DWORD *)(v95 + 32)))
            {
              if (!v73) {
                __int128 v125 = *(void *)(v95 + 8);
              }
              if ((*(_BYTE *)(v95 + 24) & 1) != 0) {
                --v73;
              }
              else {
                ++v73;
              }
              if (!v73) {
                unint64_t v127 = v127 - v125 + *(void *)(v95 + 8);
              }
            }

            unint64_t v96 = (NSData *)objc_claimAutoreleasedReturnValue([v41 objectAtIndexedSubscript:v74]);
            unint64_t v97 = FindNextMarker(v96, HIDWORD(v74) + 8, *(void *)(v128 + 8));

            __int128 v98 = v60 - 8;
            if (v97 != -1)
            {
              if (v98 >= v61)
              {
                __int128 v101 = (v98 - v59) >> 3;
                __int128 v102 = v101 + 1;
                if ((v61 - v59) >> 2 > v102) {
                  __int128 v102 = (v61 - v59) >> 2;
                }
                else {
                  uint64_t v103 = v102;
                }
                if (v103 >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                __int128 v104 = (char *)operator new(8 * v103);
                __int128 v100 = &v104[8 * v101];
                *(_DWORD *)__int128 v100 = v74;
                *((_DWORD *)v100 + 1) = v97;
                __int128 v99 = (uint64_t)v100;
                if (v98 != v59)
                {
                  __int128 v99 = (uint64_t)v100;
                  do
                  {
                    __int128 v105 = *((void *)v98 - 1);
                    v98 -= 8;
                    *(void *)(v99 - _Block_object_dispose(va, 8) = v105;
                    v99 -= 8LL;
                  }

                  while (v98 != v59);
                }

                unint64_t v61 = &v104[8 * v103];
                operator delete(v59);
                uint64_t v59 = (char *)v99;
              }

              else
              {
                *((_DWORD *)v60 - 2) = v74;
                *((_DWORD *)v60 - 1) = v97;
                __int128 v99 = (uint64_t)v59;
                __int128 v100 = v60 - 8;
              }

              __int128 v98 = v100 + 8;
              p_p = &__p;
              std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>( v99,  (uint64_t)(v100 + 8),  (uint64_t **)&p_p,  (uint64_t)&v100[-v99 + 8] >> 3);
            }

            unsigned int v60 = v98;
            if (v59 == v98)
            {
LABEL_139:
              operator delete(v98);
              unint64_t v57 = (char *)__p;
              goto LABEL_140;
            }
          }
        }

        unint64_t v127 = 0LL;
        if (v60)
        {
          __int128 v98 = v60;
          goto LABEL_139;
        }

LABEL_112:
          int v78 = v53;
          uint64_t v79 = (v17 - v16) >> 5;
          if (v53 == 4) {
            unsigned int v80 = -1;
          }
          else {
            unsigned int v80 = v174;
          }
          if ((unint64_t)v17 >= v161)
          {
            unint64_t v81 = v79 + 1;
            else {
              unint64_t v82 = v81;
            }
            if (v82) {
              unint64_t v82 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v82);
            }
            else {
              uint64_t v83 = 0LL;
            }
            unint64_t v84 = v82 + 32 * v79;
            *(_DWORD *)unint64_t v84 = v79;
            *(_DWORD *)(v84 + 4) = v52;
            *(_DWORD *)(v84 + _Block_object_dispose(va, 8) = v160;
            *(_DWORD *)(v84 + 12) = v80;
            *(void *)(v84 + 16) = v41;
            *(_DWORD *)(v84 + 24) = v78;
            *(_DWORD *)(v84 + 2_Block_object_dispose(va, 8) = -1;
            if (v17 == v16)
            {
              uint64_t v87 = (char *)(v82 + 32 * v79);
            }

            else
            {
              unint64_t v85 = v82 + 32 * v79;
              do
              {
                __int128 v86 = *((_OWORD *)v17 - 1);
                uint64_t v87 = (char *)(v85 - 32);
                *(_OWORD *)(v85 - 32) = *((_OWORD *)v17 - 2);
                *(_OWORD *)(v85 - 16) = v86;
                v17 -= 32;
                v85 -= 32LL;
              }

              while (v17 != v16);
            }

            unint64_t v161 = v82 + 32 * v83;
            uint64_t v17 = (char *)(v84 + 32);
            if (v16) {
              operator delete(v16);
            }
            uint64_t v16 = v87;
          }

          else
          {
            *(_DWORD *)uint64_t v17 = v79;
            *((_DWORD *)v17 + 1) = v52;
            *((_DWORD *)v17 + 2) = v160;
            *((_DWORD *)v17 + 3) = v80;
            *((void *)v17 + 2) = v41;
            *((_DWORD *)v17 + 6) = v53;
            *((_DWORD *)v17 + 7) = -1;
            v17 += 32;
          }

          int v152 = v78;
          if (v80 != -1) {
            ++v186[10 * v80 + 7];
          }
          ++*(_DWORD *)&__p[40 * v52 + 36];
LABEL_165:
          ++v41;
        }

        while (v41 < *(void *)(v143 + 8));
      }

      int v109 = *(_DWORD *)(v143 + 20) + v154;
      unsigned int v19 = v156;
      uint64_t v15 = v145;
LABEL_232:
      int v20 = v109 + 1;
      if (v20 >= *((_DWORD *)v15 + 3)) {
        goto LABEL_242;
      }
    }

    __int128 v182 = 0u;
    __int128 v181 = 0u;
    __int128 v180 = 0u;
    __int128 v179 = 0u;
    __int128 v178 = 0u;
    uint64_t v36 = (uint64_t)v195[2];
    int v37 = *v28;
    if (*v28 > -16203)
    {
      uint64_t v38 = v155;
      if (v37 <= -15702)
      {
        BOOL v107 = v37 == -16202;
        int v108 = -15908;
      }

      else
      {
        if (v37 == -15701)
        {
          __int128 v130 = GTTraceFunc_argumentBytesWithMap(v153, *(unsigned __int8 *)(v24 + (v25 << 6) + 13), (uint64_t)v195[2]);
          __int128 v178 = 0u;
          __int128 v179 = 0u;
          __int128 v180 = 0u;
          __int128 v181 = 0u;
          __int128 v182 = 0u;
          uint64_t v131 = *((void *)v130 + 1);
          if (v131)
          {
            LODWORD(v17_Block_object_dispose(va, 8) = 25;
            *((void *)&v178 + 1) = v131;
            *(void *)&__int128 v179 = *v153;
            *((void *)&v179 + 1) = -1LL;
            *(void *)&__int128 v181 = *(void *)v130;
            __int128 v132 = GTTraceFunc_argumentBytesWithMap(v153, v130[16], v36);
            *(void *)&__int128 v182 = v132;
            if (v132) {
              BYTE9(v182) = v132[9];
            }
          }

          goto LABEL_206;
        }

        BOOL v107 = v37 == -15318;
        int v108 = -15316;
      }

      if (!v107 && v37 != v108) {
        goto LABEL_206;
      }
    }

    else
    {
      uint64_t v38 = v155;
      if (v37 <= -16362)
      {
        if (v37 == -16365)
        {
          __int128 v129 = GTTraceFunc_argumentBytesWithMap(v153, *(unsigned __int8 *)(v24 + (v25 << 6) + 13), (uint64_t)v195[2]);
          *((void *)&v181 + 1) = GTTraceFunc_argumentBytesWithMap(v153, v129[8], v36);
        }

        else if (v37 == -16364)
        {
          BYTE8(v182) = *((_DWORD *)GTTraceFunc_argumentBytesWithMap( v153,  *(unsigned __int8 *)(v24 + (v25 << 6) + 13),  (uint64_t)v195[2])
                        + 2);
        }

        goto LABEL_206;
      }

      if (v37 != -16361)
      {
        if (v37 == -16343)
        {
          id v39 = GTTraceFunc_argumentBytesWithMap(v153, *(unsigned __int8 *)(v24 + (v25 << 6) + 13), (uint64_t)v195[2]);
          __int128 v178 = 0u;
          __int128 v179 = 0u;
          __int128 v180 = 0u;
          __int128 v181 = 0u;
          __int128 v182 = 0u;
          uint64_t v133 = *((void *)v39 + 1);
          if (!v133) {
            goto LABEL_206;
          }
          LODWORD(v17_Block_object_dispose(va, 8) = 25;
          *((void *)&v178 + 1) = v133;
          *(void *)&__int128 v179 = *v153;
          *((void *)&v179 + 1) = -1LL;
          BYTE9(v182) = 1;
          goto LABEL_240;
        }

        if (v37 == -16342)
        {
          id v39 = GTTraceFunc_argumentBytesWithMap(v153, *(unsigned __int8 *)(v24 + (v25 << 6) + 13), (uint64_t)v195[2]);
          __int128 v178 = 0u;
          __int128 v179 = 0u;
          __int128 v180 = 0u;
          __int128 v181 = 0u;
          __int128 v182 = 0u;
          uint64_t v40 = *((void *)v39 + 1);
          if (v40)
          {
            LODWORD(v17_Block_object_dispose(va, 8) = 25;
            *((void *)&v178 + 1) = v40;
            *(void *)&__int128 v179 = *v153;
            *((void *)&v179 + 1) = -1LL;
LABEL_240:
            *(void *)&__int128 v181 = *(void *)v39;
          }
        }

LABEL_207:
        *(void *)uint64_t v114 = v35;
        *((void *)v114 + 1) = v112;
        *((void *)v114 + 2) = v113;
        *((_DWORD *)v114 + 6) = v115;
        *((_DWORD *)v114 + 7) = 0;
        __int128 v151 = v114 + 32;
LABEL_208:
        unsigned int v19 = v156;
        goto LABEL_230;
      }
    }

    *((void *)&v179 + 1) = *v153;
    goto LABEL_206;
  }

  uint64_t v16 = 0LL;
  __int128 __p = 0LL;
  unsigned int v19 = 0LL;
  __int128 v151 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v142 = 0LL;
LABEL_242:
  [v193 addGPUCommands:v16 count:(v17 - v16) >> 5];
  objc_msgSend(v193, "addEncoders:count:");
  objc_msgSend(v193, "addPipelineStates:count:");
  [v193 addCommandBuffers:v19 count:(v151 - v19) >> 5];
  objc_msgSend(v193, "addShaderFunctionInfo:count:");
  [v193 setNumBlitCalls:v142];
  apr_pool_destroy(v194);
  id v134 = v193;
  if (v183)
  {
    __int128 v184 = v183;
    operator delete(v183);
  }

  if (v19) {
    operator delete(v19);
  }
  if (v186)
  {
    id v187 = v186;
    operator delete(v186);
  }

  if (__p) {
    operator delete(__p);
  }
  if (v16) {
    operator delete(v16);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v189);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v191);

  objc_msgSend(v134, "setDataSourceHasUnusedResources:captureRange:", 0, v141[10], v141[11]);
  apr_pool_destroy(newpool);
  return v134;
}

void sub_17DAD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, uint64_t a32, void *a33)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayController_tileMemoryFree(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0LL;

  uint64_t v3 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = 0LL;

  uint64_t v4 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = 0LL;

  unint64_t v5 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = 0LL;

  unint64_t v6 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = 0LL;

  int v7 = *(void **)(a1 + 88);
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;

  vm_address_t v8 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0LL;
}

void AddMemorylessTexture(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = *a1;
  id v15 = (id)a1[5];
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(v6 + 40), a2, a3);
  if (Object && *(_DWORD *)Object == 80)
  {
    GTMTLSMContext_getTextureDescriptor(*(uint64_t **)(v6 + 40), a2, a3, (uint64_t)v16);
    vm_address_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
    __int16 v9 = v18;
    if ((v18 & 0xF0) == 0x30)
    {
      unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v8]);

      if (!v10)
      {
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[1] defaultDevice]);
        __int16 v18 = v9 & 0xFF0F | 0x20;
        v17 |= 1u;
        MTLTextureDescriptorWithoutResourceIndex = MakeMTLTextureDescriptorWithoutResourceIndex((uint64_t)v16);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorWithoutResourceIndex);
        id v14 = [v11 newTextureWithDescriptor:v13];
        [v15 setObject:v14 forKeyedSubscript:v8];
      }
    }
  }
}

void std::unique_ptr<GRCPerFrameData>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    [*(id *)(v2 + 496) cancelAllOperations];

    std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v2 + 488), 0LL);
    std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::~__hash_table(v2 + 448);
    uint64_t v3 = *(void **)(v2 + 424);
    if (v3)
    {
      *(void *)(v2 + 432) = v3;
      operator delete(v3);
    }

    unint64_t v5 = (void **)(v2 + 328);
    std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__destroy_vector::operator()[abi:nn180100](&v5);
    unint64_t v5 = (void **)(v2 + 304);
    std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__destroy_vector::operator()[abi:nn180100](&v5);
    for (uint64_t i = 264LL; i != 144; i -= 40LL)
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + i);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 144);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 104);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 64);
    std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table(v2 + 24);
    unint64_t v5 = (void **)v2;
    std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](&v5);
    operator delete((void *)v2);
  }

void sub_17DED0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v10 + 488), 0LL);
  std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::~__hash_table(v10 + 448);
  id v12 = *(void **)(v10 + 424);
  if (v12)
  {
    *(void *)(v10 + 432) = v12;
    operator delete(v12);
  }

  a10 = (void **)(v10 + 328);
  std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 304);
  std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__destroy_vector::operator()[abi:nn180100](&a10);
  for (uint64_t i = 264LL; i != 144; i -= 40LL)
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + i);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 144);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 104);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 64);
  std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table(v10 + 24);
  a10 = (void **)v10;
  std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

void std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {

    uint64_t v3 = *(void **)(v2 + 256);
    if (v3)
    {
      *(void *)(v2 + 264) = v3;
      operator delete(v3);
    }

    uint64_t v4 = *(void **)(v2 + 232);
    if (v4)
    {
      *(void *)(v2 + 240) = v4;
      operator delete(v4);
    }

    unint64_t v5 = *(void **)(v2 + 208);
    if (v5) {
      operator delete(v5);
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 168);
    std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(v2 + 128);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 88);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 48);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 + 8);

    operator delete((void *)v2);
  }

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      RingBufferSampledData::~RingBufferSampledData((RingBufferSampledData *)(v2 + 3));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }

void std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = *v2;
      std::__tree<llvm::DIType *>::destroy(v2[4]);
      operator delete(v2);
      uint64_t v2 = (void **)v3;
    }

    while (v3);
  }

  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88LL;
        std::allocator<ProgramAddressHelper::PerRingBufferProgramInfo>::destroy[abi:nn180100](v4);
      }

      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void ProgramAddressHelper::~ProgramAddressHelper(void **this)
{
  for (uint64_t i = 33LL; i != 18; i -= 5LL)
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&this[i]);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(this + 18));
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(this + 13));
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)(this + 8));
  std::__hash_table<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::set<ProgramAddressHelper::ProgramAddressInfo>>>>::~__hash_table((uint64_t)(this + 3));
  uint64_t v3 = this;
  std::vector<ProgramAddressHelper::PerRingBufferProgramInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
}

uint64_t std::allocator<ProgramAddressHelper::PerRingBufferProgramInfo>::destroy[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }

  std::__tree<llvm::DIType *>::destroy(*(void **)(a1 + 48));
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1);
}

void std::vector<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::__clear[abi:nn180100]( uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 104LL)
  {
    uint64_t v4 = *(void **)(i - 32);
    if (v4)
    {
      *(void *)(i - 24) = v4;
      operator delete(v4);
    }
  }

  a1[1] = v2;
}

void std::vector<std::pair<unsigned int,SampleInfoWithPayload>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 96LL)
  {
    uint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }

  a1[1] = v2;
}

void RingBufferSampledData::~RingBufferSampledData(RingBufferSampledData *this)
{
  uint64_t v2 = (void *)*((void *)this + 8);
  *((void *)this + _Block_object_dispose(va, 8) = 0LL;

  uint64_t v3 = (void *)*((void *)this + 9);
  *((void *)this + 9) = 0LL;

  uint64_t v4 = (void *)*((void *)this + 11);
  if (v4)
  {
    *((void *)this + 12) = v4;
    operator delete(v4);
  }

  unint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }

uint64_t FindNextMarker(NSData *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v5 = a1;
  unsigned int v6 = -[NSData length](v5, "length");
  int v7 = v5;
  vm_address_t v8 = -[NSData bytes](v7, "bytes");
  unsigned int v9 = (v6 - 64) >> 3;
  BOOL v10 = v9 >= a2;
  unsigned int v11 = v9 - a2;
  if (v10)
  {
    uint64_t v12 = a2;
    unsigned int v13 = v11 + 1;
    while (v8[v12] != a3)
    {
      ++v12;
      if (!--v13) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t v12 = 0xFFFFFFFFLL;
  }

  return v12;
}

void sub_17E444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>( uint64_t result, uint64_t a2, uint64_t **a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 < 2) {
    return result;
  }
  unint64_t v5 = v4 >> 1;
  unsigned int v6 = (unsigned int *)(result + 8 * (v4 >> 1));
  uint64_t v7 = **a3;
  vm_address_t v8 = (void *)(*(void *)(v7 + 8LL * *v6) + 8LL * v6[1]);
  unsigned int v9 = (void *)(*(void *)(v7 + 8LL * *(unsigned int *)(a2 - 8)) + 8LL * *(unsigned int *)(a2 - 4));
  unint64_t v10 = v8[1];
  unint64_t v11 = v9[1];
  BOOL v12 = v10 > v11;
  if (v10 == v11
    && (unint64_t v13 = v8[4], v14 = v9[4], v12 = v13 > v14, v13 == v14)
    && (unint64_t v15 = v8[5], v16 = v9[5], v12 = v15 > v16, v15 == v16))
  {
    unint64_t v17 = v8[3];
    uint64_t v18 = v9[3];
    if (v17 <= v10 || v17 == v18) {
      return result;
    }
  }

  else if (!v12)
  {
    return result;
  }

  unint64_t v20 = *(void *)(a2 - 8);
  *(void *)(a2 - _Block_object_dispose(va, 8) = *(void *)v6;
  if (v4 >= 2)
  {
    while (1)
    {
      unint64_t v22 = v5 - 1;
      unint64_t v5 = (v5 - 1) >> 1;
      uint64_t v21 = (unsigned int *)(result + 8 * v5);
      uint64_t v23 = **a3;
      uint64_t v24 = (void *)(*(void *)(v23 + 8LL * *v21) + 8LL * v21[1]);
      uint64_t v25 = (void *)(*(void *)(v23 + 8LL * v20) + 8 * HIDWORD(v20));
      unint64_t v26 = v24[1];
      unint64_t v27 = v25[1];
      BOOL v28 = v26 > v27;
      if (v26 == v27
        && (unint64_t v29 = v24[4], v30 = v25[4], v28 = v29 > v30, v29 == v30)
        && (unint64_t v31 = v24[5], v32 = v25[5], v28 = v31 > v32, v31 == v32))
      {
        unint64_t v33 = v24[3];
        uint64_t v34 = v25[3];
        if (v33 <= v26 || v33 == v34) {
          break;
        }
      }

      else if (!v28)
      {
        break;
      }

      *(void *)unsigned int v6 = *(void *)v21;
      unsigned int v6 = (unsigned int *)(result + 8 * v5);
      if (v22 <= 1) {
        goto LABEL_27;
      }
    }
  }

  uint64_t v21 = v6;
LABEL_27:
  *(void *)uint64_t v21 = v20;
  return result;
}

__n128 __Block_byref_object_copy__7447(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__7448(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>::reserve( void **a1, unint64_t a2)
{
  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59) {
      abort();
    }
    int64_t v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    unint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(a2);
    unint64_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFE0LL];
    uint64_t v7 = &v4[32 * v6];
    unsigned int v9 = (char *)*a1;
    vm_address_t v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        __int128 v11 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 32;
        v8 -= 32;
      }

      while (v8 != v9);
      vm_address_t v8 = (char *)*a1;
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void ___ZN16GRCFrameTimeData26ProcessFrameTimeSampleDataERd_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v32 = a2;
  id v5 = a3;
  unint64_t v31 = v5;
  unsigned int v6 = [v32 unsignedIntValue];
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectAtIndexedSubscript:0]);
  unsigned int v8 = [v7 unsignedIntValue];

  unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue([v5 objectAtIndexedSubscript:1]);
  unsigned int v33 = [v9 unsignedIntValue];

  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectAtIndexedSubscript:2]);
  unsigned int v11 = [v10 unsignedIntValue];

  if ((unint64_t)[v5 count] < 4)
  {
    id v13 = 0LL;
    if (!v11) {
      goto LABEL_24;
    }
  }

  else
  {
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue([v5 objectAtIndexedSubscript:3]);
    id v13 = [v12 unsignedLongLongValue];

    if (!v11) {
      goto LABEL_24;
    }
  }

  for (uint64_t i = 0LL; i != v11; ++i)
  {
    uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8LL * (v8 + i));
    if (v15)
    {
      uint64_t v16 = v33 + i;
      unint64_t v17 = *(void **)(*(void *)(a1 + 32) + 8LL);
      unsigned int v19 = (char *)v17[7];
      unint64_t v18 = v17[8];
      if ((unint64_t)v19 >= v18)
      {
        uint64_t v21 = (char *)v17[6];
        uint64_t v22 = (v19 - v21) >> 5;
        unint64_t v23 = v22 + 1;
        uint64_t v24 = v18 - (void)v21;
        if (v24 >> 4 > v23) {
          unint64_t v23 = v24 >> 4;
        }
        BOOL v25 = (unint64_t)v24 >= 0x7FFFFFFFFFFFFFE0LL;
        unint64_t v26 = 0x7FFFFFFFFFFFFFFLL;
        if (!v25) {
          unint64_t v26 = v23;
        }
        if (v26)
        {
          unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v26);
          uint64_t v21 = (char *)v17[6];
          unsigned int v19 = (char *)v17[7];
        }

        else
        {
          uint64_t v27 = 0LL;
        }

        BOOL v28 = (void *)(v26 + 32 * v22);
        void *v28 = v15;
        v28[1] = v6;
        v28[2] = v16;
        v28[3] = v13;
        unint64_t v29 = v28;
        if (v19 != v21)
        {
          do
          {
            __int128 v30 = *((_OWORD *)v19 - 1);
            *((_OWORD *)v29 - 2) = *((_OWORD *)v19 - 2);
            *((_OWORD *)v29 - 1) = v30;
            v29 -= 4;
            v19 -= 32;
          }

          while (v19 != v21);
          uint64_t v21 = (char *)v17[6];
        }

        unint64_t v20 = v28 + 4;
        v17[6] = v29;
        v17[7] = v28 + 4;
        v17[8] = v26 + 32 * v27;
        if (v21) {
          operator delete(v21);
        }
      }

      else
      {
        *(void *)unsigned int v19 = v15;
        *((void *)v19 + 1) = v6;
        unint64_t v20 = v19 + 32;
        *((void *)v19 + 2) = v16;
        *((void *)v19 + 3) = v13;
      }

      v17[7] = v20;
    }
  }

void sub_17E874( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, id a11)
{
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *,false>( uint64_t result, char *a2, uint64_t a3, char a4)
{
  uint64_t v7 = (uint64_t *)result;
LABEL_2:
  unsigned int v8 = (uint64_t *)(a2 - 32);
  unsigned int v9 = (uint64_t *)(a2 - 64);
  unint64_t v10 = (uint64_t *)(a2 - 96);
  uint64_t i = v7;
  int v154 = a2;
  while (2)
  {
    uint64_t v7 = i;
    uint64_t v12 = a2 - (char *)i;
    uint64_t v13 = (a2 - (char *)i) >> 5;
    switch(v13)
    {
      case 0LL:
      case 1LL:
        return result;
      case 2LL:
        __n128 result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( v8,  v7);
        if ((_DWORD)result)
        {
          uint64_t v76 = *v7;
          *uint64_t v7 = *((void *)a2 - 4);
          *((void *)a2 - 4) = v76;
          uint64_t v77 = v7[1];
          v7[1] = *((void *)a2 - 3);
          *((void *)a2 - 3) = v77;
          uint64_t v78 = v7[2];
          v7[2] = *((void *)a2 - 2);
          *((void *)a2 - 2) = v78;
          uint64_t v79 = v7[3];
          v7[3] = *((void *)a2 - 1);
          *((void *)a2 - 1) = v79;
        }

        return result;
      case 3LL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7,  v7 + 4,  v8);
      case 4LL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7,  v7 + 4,  v7 + 8,  v8);
      case 5LL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7,  v7 + 4,  v7 + 8,  v7 + 12,  v8);
      default:
        if (v12 > 767)
        {
          if (!a3)
          {
            if (v7 != (uint64_t *)a2)
            {
              int64_t v97 = (unint64_t)(v13 - 2) >> 1;
              int64_t v152 = v97;
              do
              {
                int64_t v98 = v97;
                if (v152 >= v97)
                {
                  uint64_t v99 = (2 * v97) | 1;
                  __int128 v100 = &v7[4 * v99];
                  if (2 * v97 + 2 < v13
                    && std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( &v7[4 * v99],  v100 + 4))
                  {
                    v100 += 4;
                    uint64_t v99 = 2 * v98 + 2;
                  }

                  __int128 v101 = &v7[4 * v98];
                  __n128 result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( v100,  v101);
                  a2 = v154;
                  if ((result & 1) == 0)
                  {
                    unint64_t v103 = *v101;
                    unint64_t v102 = v101[1];
                    unint64_t v104 = v101[2];
                    unint64_t v147 = v101[3];
                    *__int128 v101 = *v100;
                    v101[1] = v100[1];
                    v101[2] = v100[2];
                    v101[3] = v100[3];
                    if (v152 >= v99)
                    {
                      unint64_t v148 = v102;
                      int64_t v150 = v98;
                      while (1)
                      {
                        __int128 v105 = v100;
                        uint64_t v106 = 2 * v99;
                        uint64_t v99 = (2 * v99) | 1;
                        __int128 v100 = &v7[4 * v99];
                        uint64_t v107 = v106 + 2;
                        if (v106 + 2 < v13)
                        {
                          unint64_t v108 = v103;
                          __n128 result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( &v7[4 * v99],  v100 + 4);
                          unint64_t v103 = v108;
                          unint64_t v102 = v148;
                          int64_t v98 = v150;
                          if ((_DWORD)result)
                          {
                            v100 += 4;
                            uint64_t v99 = v107;
                          }
                        }

                        unint64_t v109 = *v100;
                        if (*v100 < v103) {
                          break;
                        }
                        if (v103 >= v109)
                        {
                          unint64_t v110 = v100[1];
                          if (v110 < v102) {
                            break;
                          }
                          if (v102 >= v110)
                          {
                            unint64_t v111 = v100[2];
                            if (v111 < v104 || v104 >= v111 && v100[3] < v147) {
                              break;
                            }
                          }
                        }

                        uint64_t *v105 = v109;
                        v105[1] = v100[1];
                        v105[2] = v100[2];
                        v105[3] = v100[3];
                        if (v152 < v99) {
                          goto LABEL_178;
                        }
                      }

                      __int128 v100 = v105;
                    }