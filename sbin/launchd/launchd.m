uint64_t sub_100001084(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!result) {
    sub_100046E84(0LL, a2, a3, a4);
  }
  return result;
}

uint64_t sub_10000109C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(_DWORD)a1) {
    sub_100046E9C(a1, a2, a3, a4);
  }
  return 0LL;
}

uint64_t sub_1000010B8()
{
  return os_map_32_init(&unk_100069AF0, 0LL, 1LL);
}

_DWORD *sub_1000010EC(const char *a1, unsigned int a2)
{
  v4 = sub_100010B00(55LL * a2 + 32);
  *(void *)v4 = sub_10000F3B8();
  v4[2] = a2;
  *((void *)v4 + 3) = sub_1000126A0(a1);
  v4[5] = 0;
  return v4;
}

void sub_100001148(uint64_t a1)
{
  while (*(_DWORD *)(a1 + 16))
    sub_1000011CC(a1);
  *(_DWORD *)(a1 + 20) = 0;
  sub_10000F510(*(void **)a1);
  free(*(void **)(a1 + 24));
  free((void *)a1);
}

void sub_100001194(uint64_t a1)
{
  while (*(_DWORD *)(a1 + 16))
    sub_1000011CC(a1);
  *(_DWORD *)(a1 + 20) = 0;
}

double sub_1000011CC(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 16)) {
    sub_100046EB4();
  }
  uint64_t v2 = a1 + 55LL * *(unsigned int *)(a1 + 12);
  sub_10000F4A8(*(void *)a1, *(void *)(v2 + 32));
  *(void *)(v2 + 79) = 0LL;
  double result = 0.0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  int v4 = *(_DWORD *)(a1 + 16) - 1;
  *(_DWORD *)(a1 + 12) = (*(_DWORD *)(a1 + 12) + 1) % *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = v4;
  return result;
}

uint64_t sub_100001238(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_100001240(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_100001248(_DWORD *a1, unsigned int a2)
{
  if (a1[4] < a2) {
    sub_100046EB4();
  }
  return (uint64_t)a1 + 55 * ((a1[3] + a2) % a1[2]) + 32;
}

unint64_t sub_100001284(uint64_t a1, uint64_t a2)
{
  unint64_t result = os_map_32_count(&unk_100069AF0);
  if (result > 0x7CF) {
    return result;
  }
  unint64_t result = os_map_str_count(&unk_100069AD8);
  if (result)
  {
    if (a2)
    {
LABEL_5:
      if (os_map_32_find(&unk_100069AF0, a1)) {
        sub_100039448("launch_service_stats_record_spawn() must not be called twice with the same pid (%d)", a1);
      }
      return os_map_32_insert(&unk_100069AF0, a1, a2);
    }

LABEL_11:
    sub_100039448("launch_service_stats_record_spawn() must not be called with a zero timestamp");
  }

  if (dword_100069B08 == 500)
  {
    os_map_32_destroy(&unk_100069AF0);
    unint64_t result = os_map_32_init(&unk_100069AF0, 0LL, 1LL);
    ++dword_100069B08;
    return result;
  }

  if (dword_100069B08 <= 0x1F3)
  {
    ++dword_100069B08;
    if (a2) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }

  return result;
}

    v11 = 0;
    goto LABEL_12;
  }

  *(void *)(v7 + 8) = a3;
LABEL_10:
  v11 = 1;
LABEL_12:
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) |= v11;
  *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) |= v11 ^ 1;
  return 1LL;
}

    v9 = *(void (**)(uint64_t, const char *, ...))(v2 + 24);
    if (v9) {
      v9(v2, "[%s]: %s\n", "string_prefix_allowed_iterate", "Unexpected type to match against during iteration");
    }
    return 1LL;
  }

  if (v5 != 4) {
    goto LABEL_11;
  }
  v6 = *(const void **)(v4 + 8);
  v7 = *(void *)(v4 + 16);
LABEL_6:
  v8 = a1[7];
  v15 = *((_OWORD *)a1 + 6);
  v16 = 0LL;
  v17 = 0LL;
  if ((ccder_blob_decode_range(&v15, 12LL, &v16) & 1) != 0)
  {
  }

  else
  {
    v10 = *(void (**)(unint64_t, const char *, ...))(v8 + 24);
    if (v10)
    {
      v10(v8, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      v11 = *(void (**)(unint64_t, const char *, ...))(v8 + 24);
      if (v11)
      {
        if (v8 && v8 >= v8 + 64)
        {
LABEL_28:
          __break(0x5519u);
          goto LABEL_29;
        }

        v11(v8, "[%s]: %s\n", "der_vm_execute_match_string_prefix", "string decode failure");
      }
    }
  }

  v8 = a1[7];
  v15 = *((_OWORD *)a1 + 6);
  v16 = 0LL;
  v17 = 0LL;
  if ((ccder_blob_decode_range(&v15, 12LL, &v16) & 1) != 0)
  {
    if (!v7 || v7 <= v17 - (uint64_t)v16 && !memcmp(v6, v16, v7))
    {
LABEL_23:
      unint64_t result = 0LL;
      *(_BYTE *)(*v3 + 33LL) = 1;
      return result;
    }

    return 1LL;
  }

  v13 = *(void (**)(unint64_t, const char *, ...))(v8 + 24);
  if (v13) {
    v13(v8, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
  }
  if (v8 && v8 >= v8 + 64) {
    goto LABEL_28;
  }
LABEL_29:
  v14 = (*(uint64_t (**)(unint64_t, const char *, ...))(v8 + 32))( v8,  "[%s]: %s\n",  "der_vm_string_from_context",  "Attempting to select a string value from a non-string DER object");
  return sub_100045FC8(v14);
}

uint64_t sub_100001384(uint64_t a1)
{
  return os_map_32_delete(&unk_100069AF0, a1);
}

size_t sub_100001394( size_t result, int a2, const char *a3, int a4, uint64_t a5, uint64_t a6, char a7, uint64_t a8, int a9, int a10, int a11, __int16 a12)
{
  if (a5)
  {
    size_t v18 = result;
    unsigned int v19 = *(_DWORD *)(result + 16);
    unsigned int v20 = *(_DWORD *)(result + 8);
    if (v19 == v20)
    {
      v21 = a3;
      sub_1000011CC(result);
      a3 = v21;
      unsigned int v19 = *(_DWORD *)(v18 + 16);
      ++*(_DWORD *)(v18 + 20);
      unsigned int v20 = *(_DWORD *)(v18 + 8);
    }

    if (v19 >= v20) {
      sub_100046EB4();
    }
    uint64_t v22 = a6;
    size_t v23 = v18 + 55LL * ((*(_DWORD *)(v18 + 12) + v19) % v20);
    unint64_t result = sub_10000F3EC(*(void *)v18, a3);
    *(void *)(v23 + 32) = result;
    *(void *)(v23 + 40) = a5;
    *(_DWORD *)(v23 + 56) = a2;
    *(_DWORD *)(v23 + 60) = a4;
    *(void *)(v23 + 48) = v22;
    *(_BYTE *)(v23 + 64) = a7;
    *(void *)(v23 + 65) = a8;
    *(_DWORD *)(v23 + 73) = a9;
    *(_DWORD *)(v23 + 77) = a10;
    *(_DWORD *)(v23 + 81) = a11;
    *(_WORD *)(v23 + 85) = a12;
    ++*(_DWORD *)(v18 + 16);
  }

  return result;
}

uint64_t sub_1000014A4(const char *a1, unsigned int a2)
{
  if (os_map_str_find(&unk_100069AD8, a1)) {
    return 17LL;
  }
  v5 = sub_1000010EC(a1, a2);
  os_map_str_insert(&unk_100069AD8, *((void *)v5 + 3), v5);
  return 0LL;
}

uint64_t sub_100001504(uint64_t a1)
{
  uint64_t v1 = os_map_str_delete(&unk_100069AD8, a1);
  if (!v1) {
    return 2LL;
  }
  sub_100001148(v1);
  return 0LL;
}

uint64_t sub_100001538(uint64_t a1)
{
  return os_map_str_find(&unk_100069AD8, a1);
}

uint64_t sub_100001548(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000LL;
  v2[2] = sub_1000015A0;
  v2[3] = &unk_100061158;
  v2[4] = a1;
  return os_map_str_foreach(&unk_100069AD8, v2);
}

uint64_t sub_1000015A0(uint64_t a1)
{
  return 1LL;
}

uint64_t sub_1000015C0()
{
  return _os_assert_log(0LL);
}

uint64_t sub_1000015C8(char *key)
{
  uint64_t v6 = 0LL;
  if (qword_100069B10)
  {
    xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100069B10, key);
    if (value)
    {
      uint64_t v2 = value;
      if (!sub_10000167C(value, "SampleRate", &v6)) {
        sub_10003AB08(7, "Probabilistic Guard Malloc SampleRate has the wrong format");
      }
      if (!sub_10000167C(v2, "ActivationRate", (_DWORD *)&v6 + 1)) {
        sub_10003AB08(7, "Probabilistic Guard Malloc ActivationRate has the wrong format");
      }
    }
  }

  if ((_DWORD)v6) {
    uint64_t v3 = v6;
  }
  else {
    uint64_t v3 = qword_100069B18;
  }
  if (HIDWORD(v6)) {
    uint64_t v4 = HIDWORD(v6);
  }
  else {
    uint64_t v4 = HIDWORD(qword_100069B18);
  }
  return v3 | (v4 << 32);
}

BOOL sub_10000167C(void *a1, const char *a2, _DWORD *a3)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unint64_t int64 = xpc_dictionary_get_int64(a1, a2);
    BOOL result = HIDWORD(int64) == 0;
  }

  else
  {
    LODWORD(int64) = 0;
    BOOL result = 0LL;
  }

  *a3 = int64;
  return result;
}

void sub_1000016F4()
{
  byte_100069B28 = sub_1000017BC(&qword_100069B20);
  int has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.xpc.launchd");
  uint64_t v1 = 0x3E800000000LL;
  qword_100069B18 = v1;
  qword_100069B10 = 0LL;
  xpc_object_t v2 = sub_1000411E4("ProbGuardPolicy");
  if (!v2)
  {
    uint64_t v4 = "Probabilistic Guard Malloc config absent";
    int v5 = 7;
    goto LABEL_7;
  }

  uint64_t v3 = (uint64_t)v2;
  if (xpc_get_type(v2) != (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v4 = "Probabilistic Guard Malloc configuration file plist is not a dictionary";
    int v5 = 5;
LABEL_7:
    sub_10003AB08(v5, v4);
    return;
  }

  qword_100069B10 = v3;
  qword_100069B18 = sub_1000015C8("GlobalPolicy");
}

BOOL sub_1000017BC(unint64_t *a1)
{
  xpc_object_t v2 = getenv("MallocProbGuard");
  BOOL v3 = sub_1000129FC(v2, "1");
  if (v3)
  {
    uint64_t v4 = getenv("MallocProbGuardSampleRate");
    *a1 = 500LL;
    if (v4) {
      *a1 = strtoul(v4, 0LL, 10);
    }
  }

  return v3;
}

void sub_100001824(uint64_t a1)
{
  if (!byte_100069B28)
  {
    uint32_t v2 = *(_DWORD *)(a1 + 1328);
    if (v2)
    {
      if (!arc4random_uniform(v2))
      {
        byte_100069B28 = 1;
        *(void *)(a1 + 1352) |= 0x100000000000000uLL;
        sub_100003218(a1, "MallocProbGuardViaLaunchd", "1", 1);
        int v8 = *(_DWORD *)(a1 + 900);
        int v9 = *(_DWORD *)(a1 + 904);
        if (v8 >= 1) {
          *(_DWORD *)(a1 + 900) = v8 + 2;
        }
        if (v9 >= 1) {
          *(_DWORD *)(a1 + 904) = v9 + 2;
        }
        int v10 = *(_DWORD *)(a1 + 1324);
        if (v10)
        {
          *(_DWORD *)&__str[7] = 0;
          *(void *)__str = 0LL;
          snprintf(__str, 0xBuLL, "%u", v10);
          sub_100003218(a1, "MallocProbGuardSampleRate", __str, 0);
        }

        sub_10001A4D8(a1, 5, "Enabling Probabilistic Guard Malloc", v3, v4, v5, v6, v7, v11);
      }
    }
  }
}

void sub_100001940( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = *(void *)(a1 + 1352);
  if ((v9 & 0x100000000000000LL) != 0)
  {
    if (!byte_100069B28) {
      sub_100046EC8();
    }
    byte_100069B28 = 0;
    *(void *)(a1 + 1352) = v9 & 0xFEFFFFFFFFFFFFFFLL;
    uint64_t v11 = a1 + 984;
    uint64_t v12 = a1 + 984;
    do
      uint64_t v12 = *(void *)v12;
    while (v12 && !sub_100012944((const char *)(v12 + 32), "MallocProbGuardViaLaunchd"));
    while (1)
    {
      uint64_t v11 = *(void *)v11;
      if (!v11) {
        break;
      }
      if (sub_100012944((const char *)(v11 + 32), "MallocProbGuardSampleRate"))
      {
        if (v12)
        {
          sub_1000031B0(a1, (char *)v12);
          uint64_t v12 = v11;
          goto LABEL_11;
        }

LABEL_17:
        sub_100046EC8();
      }
    }

    if (!v12) {
      goto LABEL_17;
    }
LABEL_11:
    sub_1000031B0(a1, (char *)v12);
    int v18 = *(_DWORD *)(a1 + 900);
    int v19 = *(_DWORD *)(a1 + 904);
    if (v18 >= 3) {
      *(_DWORD *)(a1 + 900) = v18 - 2;
    }
    if (v19 >= 3) {
      *(_DWORD *)(a1 + 904) = v19 - 2;
    }
    sub_10001A4D8(a1, 5, "Probabilistic Guard Malloc-enabled process exited", v13, v14, v15, v16, v17, a9);
  }

        sub_10002587C( a1,  5,  "could not find endpoint in pid namespace: pid = %d, name = %s",  v18,  v19,  v20,  v21,  v22,  a3);
      }

      else
      {
LABEL_36:
        sub_10002587C( a1,  5,  "could not find active service for lookup: pid = %d, name = %s",  v18,  v19,  v20,  v21,  v22,  a3);
      }
    }

    else
    {
      if ((a4 & 0x10) == 0)
      {
        if ((a4 & 0x24) != 0)
        {
          if (*(void **)(a1 + 104) != qword_100069750)
          {
LABEL_41:
            v33 = sub_10002AE24(a1, a2);
            uint64_t v16 = v33;
            v28 = v34;
            if ((_DWORD)v34)
            {
              if ((_DWORD)v34 != 3) {
                goto LABEL_46;
              }
              v33 = sub_1000307B4(a1, a2);
              if (!v33) {
                goto LABEL_46;
              }
            }

            if (*(void *)(v33 + 72))
            {
              sub_10002587C(a1, 3, "Cannot look up instances for shared endpoints.", v18, v19, v20, v21, v22, v67);
LABEL_86:
              uint64_t v16 = 0LL;
              v28 = 137LL;
              goto LABEL_46;
            }

            v59 = sub_10003FDE0(v33);
            v65 = v59;
            if ((*(_BYTE *)(v59 + 369) & 2) != 0)
            {
              sub_10001A4D8(v59, 3, "Cannot look up instances for sub-instances.", v60, v61, v62, v63, v64, v67);
              goto LABEL_86;
            }

            v66 = sub_1000208F0(v59, a5);
            if (!v66)
            {
              if (sub_1000208CC(v65, 1))
              {
                uint64_t v16 = 0LL;
                v28 = 45LL;
                goto LABEL_46;
              }

              *(void *)&v71 = 0LL;
              v70 = a6;
              LODWORD(v69) = 0;
              v66 = (uint64_t)sub_1000268C8( *(_DWORD **)(v65 + 248),  v65,  a5,  (a4 >> 5) & 1,  (uint64_t *)&v70,  (_OWORD *)a7,  (int *)&v69);
              if (!v66)
              {
                uint64_t v16 = 0LL;
                if ((_DWORD)v69) {
                  v28 = v69;
                }
                else {
                  v28 = 137LL;
                }
                goto LABEL_46;
              }
            }

            uint64_t v16 = *(void *)(v66 + 184);
            if (v16)
            {
              v28 = 3LL;
              while ((*(_BYTE *)(v16 + 88) & 0x40) != 0 || !sub_1000129FC((char *)(v16 + 168), a2))
              {
                uint64_t v16 = *(void *)(v16 + 16);
                if (!v16) {
                  goto LABEL_46;
                }
              }

              goto LABEL_23;
            }

            goto LABEL_38;
          }

    sub_100028BC8(qword_10006A400, a5, v11, "domain creation");
    uint64_t v13 = 0LL;
    *a6 = v11;
    return v13;
  }

  uint64_t v11 = v7(0LL, 1LL, 0LL, a2, a5, 0LL, 0LL);
  if ((_DWORD)v11) {
    goto LABEL_17;
  }
  memset(v31, 0, sizeof(v31));
  uint64_t v17 = "(premature birth)";
  if (!(a2 >> 31))
  {
    int v18 = *(unsigned int *)(a5 + 20);
    if ((v18 & 0x80000000) == 0 && v18 == a2)
    {
      int v19 = sub_10001CB68(a2);
      if (v19) {
        unsigned int v20 = sub_10001E3C0(v19);
      }
      else {
        unsigned int v20 = sub_100039990(a5, (char *)v31);
      }
      uint64_t v17 = v20;
    }
  }

  if (sub_10002A7D4(qword_100069750, a2))
  {
    uint64_t v13 = 0LL;
    if (sub_1000129FC(a3, 0LL)) {
      uint64_t v14 = 37;
    }
    else {
      uint64_t v14 = 134;
    }
    goto LABEL_8;
  }

  size_t v23 = sub_10002997C((uint64_t)qword_100069750, a2, v17, v22, 0, qword_10006A400, a5);
  uint64_t v13 = v23;
  if ((a4 & 1) != 0)
  {
    sub_10002587C((uint64_t)v23, 5, "Will be pending launches until told otherwise", v24, v25, v26, v27, v28, v30);
    *((_WORD *)v13 + 484) |= 0x2000u;
  }

  if (*((_UNKNOWN **)v13 + 13) == &unk_1000695B8 && qword_10006A970 != 0) {
    sub_100014618(v13, 1, 0LL, (void *)qword_10006A970, a5, 0x2000LL, v27, v28);
  }
  return v13;
}

size_t sub_100001A44(int a1, char *__s)
{
  uint64_t v4 = 0LL;
  while (dword_100069268[v4] != a1)
  {
    v4 += 6LL;
    if (v4 == 18) {
      sub_100039448("unrecognized launch diagnostic thread type: %u", a1);
    }
  }

  uint64_t v5 = (unsigned int *)&dword_100069268[v4 + 1];
  do
  {
    unsigned int v6 = __ldxr(v5);
    unsigned int v7 = v6 + 1;
  }

  while (__stxr(v7, v5));
  int v8 = &dword_100069268[v4];
  unsigned int v9 = dword_100069268[v4 + 4];
  if (v7 > v9)
  {
    sub_10003AB08(4, "Exceeded max diagnostic thread count for type %s (%u)", *((const char **)v8 + 1), v9);
    do
      unsigned int v10 = __ldxr(v5);
    while (__stxr(v10 - 1, v5));
    return 0LL;
  }

  size_t v12 = strlen(__s);
  size_t v13 = v12 + 16;
  BOOL v14 = v12 >= 0xFFFFFFFFFFFFFFF0LL;
  size_t result = v12 + 17;
  uint64_t v16 = v13 == -1LL;
  uint64_t v17 = v16 << 63 >> 63;
  BOOL v18 = v17 != v16;
  if (!v14 && !v18 && (v17 & 0x8000000000000000LL) == 0)
  {
    uint64_t v11 = sub_100010B00(result);
    *(void *)uint64_t v11 = dispatch_semaphore_create(0LL);
    v11[2] = a1;
    size_t v19 = strlen(__s);
    memcpy(v11 + 3, __s, v19);
    memset(&v25, 0, sizeof(v25));
    int v20 = pthread_attr_init(&v25);
    if (v20) {
      sub_100046EE0(v20);
    }
    int v21 = pthread_attr_setdetachstate(&v25, 2);
    if (v21) {
      sub_100046EE0(v21);
    }
    pthread_t v24 = 0LL;
    int v22 = pthread_create(&v24, &v25, (void *(__cdecl *)(void *))sub_100001CB0, v11);
    int v23 = pthread_attr_destroy(&v25);
    if (v23) {
      sub_100046EE0(v23);
    }
    if (v22)
    {
      sub_100001C1C((uint64_t)v11);
      return 0LL;
    }

    return (size_t)v11;
  }

  __break(1u);
  return result;
}

void sub_100001C1C(uint64_t a1)
{
  uint64_t v2 = 0LL;
  while (dword_100069268[v2] != *(_DWORD *)(a1 + 8))
  {
    v2 += 6LL;
    if (v2 == 18) {
      sub_100039448("unrecognized launch diagnostic thread type: %u", *(_DWORD *)(a1 + 8));
    }
  }

  dispatch_release(*(dispatch_object_t *)a1);
  free((void *)a1);
  uint64_t v3 = (unsigned int *)&dword_100069268[v2 + 1];
  do
    unsigned int v4 = __ldxr(v3);
  while (__stxr(v4 - 1, v3));
}

uint64_t sub_100001CA8(dispatch_semaphore_t *a1)
{
  return dispatch_semaphore_signal(*a1);
}

uint64_t sub_100001CB0(dispatch_semaphore_t *a1)
{
  int v2 = pthread_setname_np((const char *)v4);
  if (v2) {
    sub_100046EE0(v2);
  }
  dispatch_semaphore_wait(*a1, 0xFFFFFFFFFFFFFFFFLL);
  sub_100001C1C((uint64_t)a1);
  return 0LL;
}

uint64_t sub_100001D48(int a1)
{
  return _os_assert_log(a1);
}

void sub_100001D50(uint64_t a1, uint64_t (*a2)(const char *, void **))
{
  if (qword_100069B30) {
    sub_100046EB4();
  }
  if (dword_100069B38) {
    sub_100046EB4();
  }
  dword_100069B38 = 1;
  unsigned int v4 = 0LL;
  uint64_t v2 = a2("hw.osenvironment", &v4);
  uint64_t v3 = v4;
  if (v2 && v4 && *(_BYTE *)v4)
  {
    sub_10003AB08(65541, "boot-mode set by sysctl: %s", (const char *)v4);
    sub_100001DF8((const char *)v4);
    dword_100069B38 = 2;
    uint64_t v3 = v4;
  }

  free(v3);
}

void sub_100001DF8(const char *a1)
{
  if (!a1) {
    sub_100046EB4();
  }
  if (dword_100069B38 < 2)
  {
    free((void *)qword_100069B30);
    qword_100069B30 = (uint64_t)sub_1000126A0(a1);
  }

  else if (dword_100069B38 == 2)
  {
    if (!qword_100069B30) {
      sub_100046EB4();
    }
    sub_10003AB08(65541, "boot-mode forced to (%s) skipping set: %s", (const char *)qword_100069B30, a1);
  }

  else if (dword_100069B38 == 3)
  {
    sub_100039448("Cannot set boot-mode after it has been committed: (%s, %s)", (const char *)qword_100069B30, a1);
  }

char *sub_100001E9C(int a1)
{
  if (!a1) {
    sub_100039448("can't ask for the string for 'none' boot mode!");
  }
  uint64_t v1 = 0LL;
  while (LODWORD((&off_1000692B0)[v1 + 1]) != a1)
  {
    v1 += 2LL;
    if (v1 == 14) {
      sub_100039448("Unknown boot-mode: %d", a1);
    }
  }

  return (&off_1000692B0)[v1];
}

void sub_100001F00()
{
  if (dword_100069B38 == 3) {
    sub_100046EB4();
  }
  dword_100069B38 = 3;
  sub_10003AB08(65541, "boot-mode committed: %s", (const char *)qword_100069B30);
}

uint64_t sub_100001F54()
{
  if (dword_100069B38 != 3) {
    sub_100046EB4();
  }
  return qword_100069B30;
}

uint64_t sub_100001F80(char *a1)
{
  if (!a1) {
    sub_100046EB4();
  }
  if (dword_100069B38 != 3) {
    sub_100046EB4();
  }
  uint64_t result = qword_100069B30;
  if (qword_100069B30) {
    return strcasecmp((const char *)qword_100069B30, a1) == 0;
  }
  return result;
}

uint64_t sub_100001FC8(int a1)
{
  uint64_t v1 = sub_100001E9C(a1);
  return sub_100001F80(v1);
}

double xpc_binprefs_alloc()
{
  v0 = sub_100010B00(0x24uLL);
  double result = 0.0;
  _OWORD *v0 = 0u;
  v0[1] = 0u;
  *((_DWORD *)v0 + 8) = 0;
  return result;
}

double xpc_binprefs_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void *xpc_binprefs_copy(const void *a1)
{
  return sub_100012670(a1, 0x24uLL);
}

uint64_t xpc_binprefs_add(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(result + 32);
  *(_DWORD *)(result + 4 * v3) = a2;
  *(_DWORD *)(result + 4LL * (*(_DWORD *)(result + 32))++ + 16) = a3;
  return result;
}

uint64_t xpc_binprefs_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t xpc_binprefs_cpu_type(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 32) <= a2) {
    sub_100046EC8();
  }
  return *(unsigned int *)(a1 + 4LL * a2);
}

uint64_t xpc_binprefs_cpu_subtype(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 32) <= a2) {
    sub_100046EC8();
  }
  return *(unsigned int *)(a1 + 4LL * a2 + 16);
}

BOOL xpc_binprefs_equal(uint64_t a1, uint64_t a2)
{
  BOOL result = (a1 | a2) == 0;
  if (a1 && a2)
  {
    int v5 = *(_DWORD *)(a1 + 32);
    if (v5 == *(_DWORD *)(a2 + 32))
    {
      if (!v5) {
        return 1LL;
      }
      unsigned int v6 = 0;
      while (1)
      {
        int v7 = xpc_binprefs_cpu_type(a1, v6);
        int v8 = xpc_binprefs_cpu_subtype(a1, v6);
        if (++v6 >= *(_DWORD *)(a1 + 32)) {
          return 1LL;
        }
      }
    }

    return 0LL;
  }

  return result;
}

char *xpc_binprefs_copy_description(uint64_t a1)
{
  if (!a1) {
    return sub_1000126A0("(null)");
  }
  uint64_t v2 = (const char **)sub_10000D8E8(0x80uLL);
  sub_10000D960((uint64_t)v2, "%d: [", v3, v4, v5, v6, v7, v8, *(_DWORD *)(a1 + 32));
  if (*(_DWORD *)(a1 + 32))
  {
    unsigned int v15 = 0;
    do
    {
      if (v15) {
        sub_10000D960((uint64_t)v2, ", ", v9, v10, v11, v12, v13, v14, v25);
      }
      char v16 = xpc_binprefs_cpu_type(a1, v15);
      xpc_binprefs_cpu_subtype(a1, v15);
      sub_10000D960((uint64_t)v2, "%d.%d", v17, v18, v19, v20, v21, v22, v16);
      ++v15;
    }

    while (v15 < *(_DWORD *)(a1 + 32));
  }

  sub_10000D960((uint64_t)v2, "]", v9, v10, v11, v12, v13, v14, v25);
  int v23 = sub_10000D930(v2);
  sub_10000D938((void **)v2);
  return v23;
}

uint64_t xpc_binprefs_set_psattr(cpu_type_t *a1, posix_spawnattr_t *a2)
{
  uint64_t result = posix_spawnattr_setarchpref_np(a2, a1[8], a1, a1 + 4, 0LL);
  if ((_DWORD)result) {
    sub_100046EF4(result);
  }
  return result;
}

size_t sub_100002290(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 248);
  uint64_t v126 = 0LL;
  v127 = 0LL;
  int v7 = *(_DWORD *)(a1 + 1272);
  BOOL v8 = v7 != 0;
  BOOL v56 = v7 == 0;
  uint64_t v9 = 1LL;
  if (!v56) {
    uint64_t v9 = 2LL;
  }
  else {
    uint64_t v10 = v8;
  }
  if (*(void *)(a1 + 864))
  {
    uint64_t v11 = sub_1000297F8(v6);
    if (v11)
    {
      uint64_t v18 = sub_10003F1E0(v11, 1, v12, v13, v14, v15, v16, v17);
      ++v10;
      goto LABEL_11;
    }

    sub_10001A4D8( a1,  3,  "Could not find exception endpoint for service: %s",  v13,  v14,  v15,  v16,  v17,  *(void *)(a1 + 864));
  }

  uint64_t v18 = 0LL;
LABEL_11:
  uint64_t v125 = 0LL;
  sub_10002AF84(v6, &v126, &v127, &v125, v10);
  uint64_t v19 = *(unsigned int *)(a1 + 1272);
  if ((_DWORD)v19)
  {
    xpc_array_set_mach_send(v126, -1LL, v19);
    uint64_t v20 = v125++;
    *((_DWORD *)v127 + v20) = 129;
  }

  uint64_t v21 = *(unsigned int *)(a1 + 1316);
  if ((v21 + 1) >= 2)
  {
    xpc_array_set_mach_send(v126, -1LL, v21);
    uint64_t v24 = v125++;
    *((_DWORD *)v127 + v24) = 130;
    if ((_DWORD)v18) {
      goto LABEL_15;
    }
  }

  else if ((_DWORD)v18)
  {
LABEL_15:
    xpc_array_set_mach_send(v126, -1LL, v18);
    uint64_t v22 = v125;
    uint64_t v23 = ++v125;
    *((_DWORD *)v127 + v22) = 128;
    goto LABEL_18;
  }

  uint64_t v23 = v125;
LABEL_18:
  size_t v25 = *(void *)(a1 + 592) + 4 * v23;
  for (uint64_t i = qword_10006A9F8; i; uint64_t i = *(void *)i)
    v25 += strlen((const char *)(i + 32)) + 1;
  for (uint64_t j = qword_10006AA00; j; uint64_t j = *(void *)j)
    v25 += strlen((const char *)(j + 32)) + 1;
  for (k = *(const char **)(*(void *)(a1 + 248) + 88LL); k; k = *(const char **)k)
  {
  }

  size_t v122 = v25;
  if ((*(_BYTE *)(a1 + 1298) & 4) != 0)
  {
    if (*(void *)(a1 + 1232))
    {
      v29 = (const char *)sub_10001A098(a1);
      size_t v30 = strlen(v29);
      size_t v25 = strlen(*(const char **)(a1 + 1232)) + v25 - v30;
      size_t v122 = v25;
    }

    v31 = *(void **)(a1 + 1240);
    if (v31)
    {
      uint64_t v32 = *(unsigned int *)(a1 + 428);
      if ((_DWORD)v32)
      {
        v33 = *(const char ***)(a1 + 432);
        do
        {
          v34 = *v33++;
          v25 += ~strlen(v34);
          --v32;
        }

        while (v32);
      }

      if (xpc_array_get_count(v31))
      {
        size_t v35 = 0LL;
        do
        {
          string = xpc_array_get_string(*(xpc_object_t *)(a1 + 1240), v35);
          if (string) {
            v25 += strlen(string) + 1;
          }
          ++v35;
        }

        while (v35 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1240)));
      }

      size_t v122 = v25;
    }

    v37 = *(const char **)(a1 + 1248);
    if (v37)
    {
      v38 = *(const char **)(a1 + 440);
      if (v38) {
        v25 += ~strlen(v38);
      }
      size_t v122 = v25 + strlen(v37) + 1;
    }

    uint64_t v39 = *(void *)(a1 + 1256);
    if (v39) {
      xpc_dictionary_apply_f(v39);
    }
    uint64_t v40 = *(void *)(a1 + 1264);
    if (v40)
    {
      if (*(void *)(a1 + 880))
      {
        v122 -= _xpc_spawnattr_binprefs_size(*(void *)(a1 + 880));
        uint64_t v40 = *(void *)(a1 + 1264);
      }

      size_t v25 = v122 + _xpc_spawnattr_binprefs_size(v40);
    }

    else
    {
      size_t v25 = v122;
    }
  }

  for (m = *(void **)(a1 + 656); m; m = (void *)*m)
    v25 += 20LL;
  v42 = (unsigned int *)sub_100010B00(v25);
  unsigned int v124 = 0;
  size_t v123 = v25 - 240;
  unsigned int *v42 = v25;
  v42[1] = 0;
  v43 = *(char **)(a1 + 1232);
  if (!v43) {
    v43 = (char *)sub_10001A098(a1);
  }
  _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v43);
  *((_BYTE *)v42 + 230) = 0;
  size_t v44 = *(unsigned int *)(a1 + 624);
  if ((_DWORD)v44)
  {
    v42[2] = v124;
    v42[3] = v44;
    _xpc_spawnattr_pack_bytes((uint64_t)v42, &v124, &v123, *(void **)(a1 + 616), v44);
  }

  v45 = *(void **)(a1 + 1240);
  if (v45)
  {
    unsigned int count = xpc_array_get_count(v45);
    v42[4] = count;
    if (count)
    {
      size_t v47 = 0LL;
      v42[5] = v124;
      do
      {
        v48 = (char *)xpc_array_get_string(*(xpc_object_t *)(a1 + 1240), v47);
        if (v48) {
          _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v48);
        }
        ++v47;
      }

      while (v47 < v42[4]);
    }
  }

  else
  {
    unsigned int v49 = *(_DWORD *)(a1 + 428);
    if (v49)
    {
      unint64_t v50 = 0LL;
      unsigned int v51 = v124;
      v42[4] = v49;
      v42[5] = v51;
      do
        _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, *(char **)(*(void *)(a1 + 432) + 8 * v50++));
      while (v50 < *(unsigned int *)(a1 + 428));
    }

    else
    {
      v42[4] = 0;
    }
  }

  v52 = *(void **)(*(void *)(a1 + 248) + 88LL);
  if (v52)
  {
    uint64_t v53 = 0LL;
    do
    {
      v53 += sub_10001A8EC();
      v52 = (void *)*v52;
    }

    while (v52);
  }

  else
  {
    uint64_t v53 = 0LL;
  }

  uint64_t v54 = qword_10006A9F8;
  uint64_t v55 = *(void *)(a1 + 1256);
  if (*(_WORD *)(a1 + 992)) {
    BOOL v56 = 0;
  }
  else {
    BOOL v56 = qword_10006AA00 == 0;
  }
  if (v56 && qword_10006A9F8 == 0 && v55 == 0 && v53 == 0)
  {
    v42[7] = 0;
  }

  else
  {
    v42[7] = v124;
    if (v55)
    {
      xpc_dictionary_apply_f(v55);
      uint64_t v54 = qword_10006A9F8;
    }

    for (; v54; uint64_t v54 = *(void *)v54)
    {
      _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, (char *)(v54 + 32));
      ++v42[6];
    }

    for (n = *(char **)(a1 + 984); n; n = *(char **)n)
    {
      _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, n + 32);
      ++v42[6];
    }

    for (iuint64_t i = *(char **)(*(void *)(a1 + 248) + 88LL); ii; iuint64_t i = *(char **)ii)
    {
      if (sub_10001A8EC())
      {
        _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, ii + 32);
        ++v42[6];
      }
    }

    for (juint64_t j = qword_10006AA00; jj; juint64_t j = *(void *)jj)
    {
      _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, (char *)(jj + 32));
      ++v42[6];
    }
  }

  uint64_t v63 = *(void *)(a1 + 1264);
  if (v63 || (uint64_t v63 = *(void *)(a1 + 880)) != 0) {
    _xpc_spawnattr_binprefs_pack((uint64_t)v42, v63, &v124, &v123);
  }
  else {
    v42[9] = 0;
  }
  v64 = *(char **)(a1 + 776);
  if (v64)
  {
    v42[10] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v64);
  }

  else
  {
    v42[10] = 0;
  }

  v65 = *(char **)(a1 + 784);
  if (v65)
  {
    v42[11] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v65);
  }

  else
  {
    v42[11] = 0;
  }

  if ((*(_BYTE *)(a1 + 1356) & 1) != 0)
  {
    *((_WORD *)v42 + 26) = *(_WORD *)(a1 + 792);
    int v66 = 0x2000;
  }

  else
  {
    int v66 = 0;
  }

  uint64_t v67 = *(void *)(a1 + 248);
  v42[12] = *(_DWORD *)(v67 + 56);
  v42[59] = v42[59] & 0xFFF7FFFF | ((*(_BYTE *)(v67 + 96) & 1) << 19);
  unsigned int v68 = sub_100020A9C(a1);
  if (v68 != -1)
  {
    v42[59] |= 0x1000000u;
    v42[53] = v68;
  }

  if ((_UNKNOWN *)sub_10002A994(v6) == &unk_100069750) {
    *((void *)v42 + 7) = sub_10002A99C(*(void *)(a1 + 248));
  }
  v74 = *(char **)(a1 + 1248);
  if (v74 || (v74 = *(char **)(a1 + 440)) != 0LL)
  {
    v42[16] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v74);
  }

  else
  {
    v42[16] = 0;
  }

  v75 = *(char **)(a1 + 448);
  if (v75)
  {
    v42[17] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v75);
  }

  else
  {
    v42[17] = 0;
  }

  v76 = *(char **)(a1 + 456);
  if (v76)
  {
    v42[18] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v76);
  }

  else
  {
    v42[18] = 0;
  }

  v77 = *(char **)(a1 + 464);
  if (v77)
  {
    v42[19] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v77);
  }

  else
  {
    v42[19] = 0;
  }

  v78 = *(char **)(a1 + 472);
  if (v78)
  {
    v42[20] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v78);
  }

  else
  {
    v42[20] = 0;
  }

  v79 = *(char **)(a1 + 480);
  if (v79)
  {
    v42[21] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v79);
  }

  else
  {
    v42[21] = 0;
  }

  v80 = *(char **)(a1 + 488);
  if (v80)
  {
    v42[22] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v80);
  }

  else
  {
    v42[22] = 0;
  }

  v81 = *(char **)(a1 + 1336);
  if (v81)
  {
    v42[26] = v124;
    _xpc_spawnattr_pack_string((uint64_t)v42, &v124, &v123, v81);
  }

  *((void *)v42 + 14) = *(void *)(a1 + 872);
  *((_BYTE *)v42 + 196) = *(_BYTE *)(a1 + 960);
  unsigned int v82 = *(__int16 *)(a1 + 1296);
  if (!*(_WORD *)(a1 + 1296)) {
    unsigned int v82 = *(_DWORD *)(a1 + 892);
  }
  v42[30] = v82;
  unsigned int v83 = *(_DWORD *)(a1 + 1288);
  if ((v83 & 0x80000000) != 0) {
    unsigned int v83 = *(_DWORD *)(a1 + 896);
  }
  v42[31] = v83;
  unsigned int v84 = *(_DWORD *)(a1 + 1292);
  unsigned int v85 = v84;
  if (!v84)
  {
    unsigned int v84 = *(_DWORD *)(a1 + 900);
    unsigned int v85 = *(_DWORD *)(a1 + 904);
  }

  v42[32] = v84;
  v42[33] = v85;
  unsigned int v86 = *(_DWORD *)(a1 + 908);
  if ((v86 & 0x80000000) == 0) {
    v42[34] = v86;
  }
  *(void *)(v42 + 35) = *(void *)(a1 + 912);
  *(_OWORD *)(v42 + 37) = *(_OWORD *)(a1 + 920);
  *(void *)(v42 + 41) = *(void *)(a1 + 936);
  v42[43] = *(_DWORD *)(a1 + 944);
  sub_10001AA88(a1, (uint64_t)v42, v69, (uint64_t)v81, v70, v71, v72, v73, v120);
  v42[48] = sub_10001A9FC(a1);
  v42[47] = sub_10001A91C(a1);
  unint64_t v87 = *(void *)(a1 + 1352);
  unsigned int v88 = (v87 >> 22) & 0x2000000 | v42[59] & 0xF9FFFFFF | (v87 >> 23) & 0x4000000;
  v42[59] = v88;
  unsigned int v89 = *(_DWORD *)(a1 + 996);
  char v90 = *(_BYTE *)(a1 + 994);
  if (v89 || *(_BYTE *)(a1 + 994))
  {
    v88 |= 0x200000u;
    v42[59] = v88;
    v42[56] = v89;
    *((_BYTE *)v42 + 228) = v90;
  }

  v42[50] = *(_DWORD *)(a1 + 888);
  uint64_t v91 = 1LL;
  v92 = (void *)(a1 + 656);
  do
  {
    v92 = (void *)*v92;
    --v91;
  }

  while (v92);
  if (v91)
  {
    int v93 = -(int)v91;
    unsigned int v94 = v124;
    v42[51] = v93;
    v42[52] = v94;
    v95 = *(uint64_t **)(a1 + 656);
    if (v95)
    {
      size_t v96 = v123;
      do
      {
        int v97 = *((_DWORD *)v95 + 8);
        uint64_t v98 = (uint64_t)v42 + v94 + 240;
        *(_OWORD *)uint64_t v98 = *((_OWORD *)v95 + 1);
        *(_DWORD *)(v98 + 16) = v97;
        v94 += 20;
        v96 -= 20LL;
        v95 = (uint64_t *)*v95;
      }

      while (v95);
      unsigned int v124 = v94;
      size_t v123 = v96;
    }

    if ((v87 & 0x800) == 0) {
      goto LABEL_158;
    }
  }

  else
  {
    v42[51] = 0;
    v42[52] = 0;
    if ((v87 & 0x800) == 0)
    {
LABEL_158:
      char v99 = *(_BYTE *)(a1 + 1298) & 1;
      goto LABEL_161;
    }
  }

  char v99 = 1;
LABEL_161:
  *((_BYTE *)v42 + 108) = v99;
  uint64_t v100 = v125;
  v42[55] = v125;
  if (v100)
  {
    unsigned int v101 = v124;
    v42[54] = v124;
    v102 = (unsigned int *)v127;
    size_t v103 = v123;
    uint64_t v104 = 4 * v100;
    do
    {
      unsigned int v105 = *v102++;
      *(unsigned int *)((char *)v42 + v101 + 240) = v105;
      v101 += 4;
      unsigned int v124 = v101;
      --v100;
    }

    while (v100);
    size_t v123 = v103 - v104;
  }

  else
  {
    v42[54] = 0;
  }

  int v106 = (8 * v87) & 0x10 | (v87 >> 12) & 3 | (v87 >> 3) & 0x20 | (v87 >> 23) & 0x800000 | v88 & 0xFF7FF200;
  int v107 = *(_DWORD *)(a1 + 1136) == 11;
  unsigned int v108 = (v87 >> 3) & 0xC | (v87 >> 11) & 0x100 | (((*(_DWORD *)(a1 + 368) >> 5) & 1) << 7);
  *((_BYTE *)v42 + 229) = *(_BYTE *)(a1 + 1308);
  v42[59] = (v87 >> 13) & 0x800 | (((v87 >> 9) & 1) << 10) | v108 | v106 | (v107 << 6);
  unint64_t v109 = *(void *)(a1 + 1352);
  if ((v109 & 0x2000000) != 0 || (*(_BYTE *)(a1 + 1298) & 0x10) != 0) {
    v42[59] |= 0x20000u;
  }
  if ((v109 & 0x4000000) != 0)
  {
    unsigned int v110 = v42[59];
    goto LABEL_176;
  }

  unsigned int v110 = v42[59];
  if ((*(_BYTE *)(a1 + 1298) & 0x20) != 0) {
LABEL_176:
  }
    v110 |= 0x40000u;
  v42[59] = (v109 >> 11) & 0x400000 | v66 | (v109 >> 39) & 0x8000 | v110 & 0xFFBF5FFF;
  int v111 = sub_10001A204(a1);
  if ((v109 & 0x10000000000000LL) != 0)
  {
    if (v111) {
      sub_10001A4D8( a1,  3,  "Conflicting request: resliding disabled, but requesting a shared cache reslide. No reslide will be performed.",  v112,  v113,  v114,  v115,  v116,  v121);
    }
    unsigned int v118 = v42[59] & 0xF7FFFFFF;
  }

  else
  {
    if (v111) {
      int v117 = 0x8000000;
    }
    else {
      int v117 = 0;
    }
    unsigned int v118 = v42[59] & 0xF7FFFFFF | v117;
  }

  v42[59] = (*(void *)(a1 + 1352) >> 18) & 0x10000 | (*(void *)(a1 + 1352) >> 20) & 0x100000 | v118 & 0xFFEEFFFF;
  if (v123 || v124 + 240LL != v25) {
    sub_100039448( "failed to marshall spawnattrs: offset = %u, left = %lu, expected = %lu",  v124,  v123,  *(void *)(a1 + 592));
  }
  free(v127);
  *a3 = v42;
  *a2 = v126;
  return v25;
}

void *sub_100002DE0(char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = (_DWORD *)a3[1];
  int v7 = (void *)a3[2];
  uint64_t result = xpc_get_type(object);
  if (result == &_xpc_type_string)
  {
    _xpc_spawnattr_pack_string_fragment(v5, v6, v7, a1);
    _xpc_spawnattr_pack_string_fragment(v5, v6, v7, "=");
    string_ptr = (char *)xpc_string_get_string_ptr(object);
    uint64_t result = (void *)_xpc_spawnattr_pack_string(v5, v6, v7, string_ptr);
    ++*(_DWORD *)(v5 + 24);
  }

  return result;
}

char *sub_100002E84(const char *a1, xpc_object_t object, void *a3)
{
  uint64_t result = (char *)xpc_get_type(object);
  if (result == (char *)&_xpc_type_string)
  {
    size_t v7 = strlen(a1);
    uint64_t result = (char *)xpc_string_get_length(object);
    *a3 += &result[v7 + 2];
  }

  return result;
}

void sub_100002EF0(uint64_t a1)
{
  kern_return_t v17;
  if (*(_BYTE *)(a1 + 424)) {
    sub_100039448("deallocation of active service");
  }
  if (*(void *)(a1 + 24) != -1LL || *(void *)(a1 + 32) != -1LL) {
    sub_100039448("service disposal while still in list");
  }
  if (*(void *)(a1 + 40) != -1LL || *(void *)(a1 + 48) != -1LL) {
    sub_100039448("service disposal while in parent instance list");
  }
  if (*(void *)(a1 + 512)) {
    sub_100039448("Service: %s has leaked pended requests", (const char *)(a1 + 1360));
  }
  if (*(void *)(a1 + 848)) {
    sub_100046EB4();
  }
  if (*(void *)(a1 + 136)) {
    sub_100046EB4();
  }
  if (*(void *)(a1 + 144)) {
    sub_100046EB4();
  }
  uint64_t v2 = *(void *)(a1 + 1352);
  if ((v2 & 0x100000000000000LL) != 0) {
    sub_100046F0C(v2 & 0x100000000000000LL);
  }
  uint64_t v3 = *(void **)(a1 + 576);
  free(*(void **)(a1 + 584));
  sub_10001685C(*(void **)(a1 + 16));
  free(*(void **)(a1 + 600));
  free(*(void **)(a1 + 432));
  free(*(void **)(a1 + 440));
  free(*(void **)(a1 + 864));
  free(*(void **)(a1 + 616));
  free(*(void **)(a1 + 472));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 488));
  free(*(void **)(a1 + 448));
  free(*(void **)(a1 + 456));
  free(*(void **)(a1 + 464));
  free(*(void **)(a1 + 776));
  free(*(void **)(a1 + 784));
  free(*(void **)(a1 + 880));
  free(*(void **)(a1 + 1336));
  free(*(void **)(a1 + 1344));
  free(*(void **)(a1 + 304));
  uint64_t v4 = *(void **)(a1 + 952);
  if (v4) {
    j__free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 632);
  if (v5) {
    xpc_release(v5);
  }
  uint64_t v6 = *(void **)(a1 + 640);
  if (v6) {
    xpc_release(v6);
  }
  size_t v7 = *(void **)(a1 + 496);
  if (v7) {
    xpc_release(v7);
  }
  BOOL v8 = *(void **)(a1 + 504);
  if (v8) {
    xpc_release(v8);
  }
  if (*(void *)(a1 + 688)) {
    sub_100003174(a1);
  }
  while (1)
  {
    uint64_t v9 = *(char **)(a1 + 984);
    if (!v9) {
      break;
    }
    sub_1000031B0(a1, v9);
  }

  while (1)
  {
    uint64_t v11 = *(uint64_t **)(a1 + 648);
    if (!v11) {
      break;
    }
    uint64_t v10 = *v11;
    if (*v11) {
      *(void *)(v10 + 8) = v11[1];
    }
    *(void *)v11[1] = v10;
    free(v11);
  }

  while (1)
  {
    uint64_t v13 = *(uint64_t **)(a1 + 656);
    if (!v13) {
      break;
    }
    uint64_t v12 = *v13;
    if (*v13) {
      *(void *)(v12 + 8) = v13[1];
    }
    *(void *)v13[1] = v12;
    free(v13);
  }

  uint64_t v14 = *(void **)(a1 + 1032);
  if (v14) {
    xpc_release(v14);
  }
  uint64_t v15 = *(void **)(a1 + 1040);
  if (v15) {
    xpc_release(v15);
  }
  mach_port_name_t v16 = *(_DWORD *)(a1 + 1316);
  if (v16 + 1 >= 2)
  {
    uint64_t v17 = mach_port_mod_refs(mach_task_self_, v16, 0, -1);
    if (v17) {
      sub_100046EF4(v17);
    }
  }

  sub_100037440(a1);
}

void sub_100003174(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(a1 + 688);
  if (!v2) {
    sub_100046EB4();
  }
  dispatch_set_context(v2, v2);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 688));
  *(void *)(a1 + 688) = 0LL;
}

void sub_1000031B0(uint64_t a1, char *a2)
{
  *(void *)(a1 + 592) += ~strlen(a2 + 32);
  uint64_t v3 = *(void *)a2;
  if (*(void *)a2) {
    *(void *)(v3 + 8) = *((void *)a2 + 1);
  }
  **((void **)a2 + 1) = v3;
  *(void *)a2 = -1LL;
  *((void *)a2 + 1) = -1LL;
  j__free(a2);
}

void sub_100003218(uint64_t a1, char *__s, const char *a3, char a4)
{
  size_t v7 = 0LL;
  uint64_t v5 = sub_1000168AC(__s, a3, 0LL, &v7, a4);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 984);
    *(void *)uint64_t v5 = v6;
    if (v6) {
      *(void *)(v6 + 8) = v5;
    }
    *(void *)(a1 + 984) = v5;
    ++*(_WORD *)(a1 + 992);
    *(void *)(a1 + 592) += v7;
    *((void *)v5 + 1) = a1 + 984;
    *((void *)v5 + 2) = a1;
  }

uint64_t sub_1000032C4(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      unint64_t v4 = *(void *)(a1 + 1352);
      if ((v4 & 0x40400000000LL) != 0)
      {
        if ((sub_10000D114(a1 + 376, 30LL) & 1) != 0) {
          goto LABEL_17;
        }
        unint64_t v4 = *(void *)(a1 + 1352);
      }

      uint64_t v2 = (v4 >> 44) & 1;
      return v2 & 1;
    case 1:
    case 2:
    case 3:
    case 5:
      LODWORD(v2) = (*(unsigned __int8 *)(a1 + 1357) >> 4) & 1;
      return v2 & 1;
    case 4:
      LOBYTE(v2) = (*(_BYTE *)(a1 + 1357) & 1) == 0;
      return v2 & 1;
    case 6:
      LOBYTE(v2) = *(_BYTE *)(a1 + 1357) & 1;
      return v2 & 1;
    case 7:
      uint64_t v5 = *(unsigned __int8 *)(a1 + 960);
      if (!*(_BYTE *)(a1 + 960)) {
        goto LABEL_17;
      }
      if ((_DWORD)v5 == 2) {
        goto LABEL_14;
      }
      xpc_object_t v6 = sub_10003A4FC(a1 + 376);
      if (!v6) {
        goto LABEL_14;
      }
      size_t v7 = v6;
      if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t array = xpc_dictionary_get_array(v7, "com.apple.private.xpc.allowed-launch-types");
        if (xpc_array_get_count(array))
        {
          size_t v11 = 0LL;
          do
          {
            int64_t int64 = xpc_array_get_int64(array, v11);
            LOBYTE(v2) = int64 == v5;
            ++v11;
          }

          while (v11 < xpc_array_get_count(array));
        }

        else
        {
          LOBYTE(v2) = 0;
        }

        xpc_release(v7);
      }

      else
      {
        xpc_release(v7);
LABEL_14:
        LOBYTE(v2) = 0;
      }

      break;
    case 8:
      unint64_t v8 = *(void *)(a1 + 1352);
      if ((v8 & 0x40400000000LL) == 0) {
        goto LABEL_19;
      }
      if ((sub_10000D114(a1 + 376, 31LL) & 1) != 0)
      {
LABEL_17:
        LOBYTE(v2) = 1;
      }

      else
      {
        unint64_t v8 = *(void *)(a1 + 1352);
LABEL_19:
        uint64_t v2 = (v8 >> 44) & 1;
      }

      break;
    default:
      return v2 & 1;
  }

  return v2 & 1;
}

void sub_100003444(uint64_t a1, char *a2)
{
  if (!strcasecmp(a2, "Interactive"))
  {
    int v10 = 1024;
    goto LABEL_14;
  }

  if (!strcasecmp(a2, "Adaptive"))
  {
    int v10 = 1536;
    goto LABEL_14;
  }

  if (!strcasecmp(a2, "Standard"))
  {
    int v10 = 768;
    goto LABEL_14;
  }

  if (!strcasecmp(a2, "Background"))
  {
    int v10 = 1280;
    goto LABEL_14;
  }

  if (!strcasecmp(a2, "SystemApp"))
  {
    *(_DWORD *)(a1 + 872) = 256;
    uint64_t v9 = *(void *)(a1 + 1352) | 0x3000LL;
    goto LABEL_17;
  }

  if (!strcasecmp(a2, "App"))
  {
    *(_DWORD *)(a1 + 872) = 256;
    uint64_t v9 = *(void *)(a1 + 1352) | 0x1000LL;
    goto LABEL_17;
  }

  if (strcasecmp(a2, "_AdaptiveUtility"))
  {
    if (strcasecmp(a2, "Driver"))
    {
      sub_10001A4D8(a1, 4, "Unknown ProcessType: %s", v4, v5, v6, v7, v8, (char)a2);
      uint64_t v9 = *(void *)(a1 + 1352) | 1LL;
LABEL_17:
      *(void *)(a1 + 1352) = v9;
      return;
    }

    int v10 = 1792;
LABEL_14:
    *(_DWORD *)(a1 + 872) = v10;
    return;
  }

  *(_DWORD *)(a1 + 872) = 1536;
  *(_DWORD *)(a1 + 888) = 17;
}

uint64_t sub_100003598(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  if ((*(_BYTE *)(a1 + 1356) & 0x40) == 0) {
    return 0LL;
  }
  uint64_t v3 = sub_10001198C(*(void *)(a1 + 248), (const char *)(a1 + 1360));
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void, _BYTE *, void))(a1 + 544))( a1,  a1 + 1360,  &_xpc_BOOL_true,  0LL,  v3,  *(void *)(a1 + 568));
  if (!v2)
  {
    *(void *)(a1 + 1352) |= 1uLL;
    sub_100011A84(v3, 3LL, "Failed to create the implicit endpoint");
  }

  sub_100011A50((uint64_t)v3);
  *(void *)(a1 + 1352) &= ~0x4000000000uLL;
  return v2;
}

uint64_t sub_100003668( _DWORD *a1, xpc_object_t object, char *a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10002587C((uint64_t)a1, 3, "Root node of launchd.plist is not a dictionary.", v14, v15, v16, v17, v18, v73);
LABEL_3:
    uint64_t v19 = 0LL;
    int v20 = 109;
LABEL_16:
    *a7 = v20;
    return v19;
  }

  string = xpc_dictionary_get_string(object, "Label");
  if (!string)
  {
    v31 = "Service plist does not specify a label.";
LABEL_15:
    sub_10002587C((uint64_t)a1, 3, v31, v22, v23, v24, v25, v26, v73);
    uint64_t v19 = 0LL;
    int v20 = 110;
    goto LABEL_16;
  }

  v27 = string;
  size_t v28 = strlen(string);
  if (!v28)
  {
    v31 = "Service plist has an empty label.";
    goto LABEL_15;
  }

  size_t v29 = v28;
  uint64_t v74 = a4;
  uint64_t v75 = a5;
  __s1 = a3;
  uint64_t v30 = 0LL;
  v31 = "Service plist has an empty label.";
  while (1)
  {
    __darwin_ct_rune_t v32 = v27[v30];
    if (v32 < 0) {
      break;
    }
    if ((_DefaultRuneLocale.__runetype[v32] & 0x4000) == 0) {
      goto LABEL_18;
    }
LABEL_11:
    if (v29 == ++v30) {
      goto LABEL_15;
    }
  }

  if (__maskrune(v32, 0x4000uLL)) {
    goto LABEL_11;
  }
LABEL_18:
  v34 = sub_1000051B8(object, (uint64_t)a1, v27);
  if (!v34) {
    goto LABEL_3;
  }
  size_t v35 = v34;
  v36 = sub_10001198C((uint64_t)a1, v27);
  v37 = xpc_dictionary_get_string(v35, "Label");
  if (!v37)
  {
    sub_100011A84(v36, 3LL, "Service plist does not specify a label.");
    uint64_t v19 = 0LL;
    int v43 = 110;
    goto LABEL_74;
  }

  v38 = (char *)v37;
  BOOL v39 = xpc_dictionary_get_BOOL(v35, "Disabled");
  BOOL v40 = xpc_dictionary_get_BOOL(v35, "ForceEnableHack");
  xpc_object_t v41 = sub_10002AB0C((uint64_t)a1, v38);
  xpc_object_t value = xpc_dictionary_get_value(v35, "_Conclave");
  if ((a6 & 0x800) == 0 && value)
  {
    sub_100011A84(v36, 3LL, "Only LaunchDaemons are allowed to use the _Conclave key");
    uint64_t v19 = 0LL;
    int v43 = 109;
    goto LABEL_74;
  }

  if (v41) {
    BOOL v44 = v41 == &_xpc_BOOL_true;
  }
  else {
    BOOL v44 = v39;
  }
  if ((a6 & 0x20) == 0 && v44 && !((a6 >> 1) & 1 | v40))
  {
    uint64_t v19 = 0LL;
    int v43 = 119;
    goto LABEL_74;
  }

  if ((a6 >> 1) & 1 | v40) {
    sub_100029130((uint64_t)a1, v38, 2);
  }
  xpc_dictionary_get_value(v35, "LimitLoadToSessionType");
  xpc_object_t v45 = xpc_dictionary_get_value(v35, "LimitLoadToHardware");
  if (v45 && (v46 = v45, xpc_get_type(v45) == (xpc_type_t)&_xpc_type_dictionary) && (sub_1000066D4(v46) & 1) == 0
    || (xpc_object_t v47 = xpc_dictionary_get_value(v35, "LimitLoadFromHardware")) != 0LL
    && (v48 = v47, xpc_get_type(v47) == (xpc_type_t)&_xpc_type_dictionary)
    && sub_1000066D4(v48))
  {
LABEL_39:
    uint64_t v19 = 0LL;
    int v43 = 138;
    goto LABEL_74;
  }

  xpc_object_t v49 = xpc_dictionary_get_value(v35, "_LimitLoadToVariant");
  if (v49 && (sub_10000675C(v49) & 1) == 0
    || (xpc_object_t v50 = xpc_dictionary_get_value(v35, "_LimitLoadFromVariant")) != 0LL && sub_10000675C(v50))
  {
    uint64_t v19 = 0LL;
    int v43 = 158;
    goto LABEL_74;
  }

  xpc_object_t v51 = xpc_dictionary_get_value(v35, "_LimitLoadToBootMode");
  if (v51 && (sub_100006830(v51) & 1) == 0) {
    goto LABEL_73;
  }
  xpc_object_t v52 = xpc_dictionary_get_value(v35, "_LimitLoadFromBootMode");
  if (v52)
  {
  }

  if (xpc_dictionary_get_BOOL(v35, "_LimitLoadToClarityMode") && (sub_1000068F8() & 1) == 0) {
    goto LABEL_73;
  }
  BOOL v53 = xpc_dictionary_get_BOOL(v35, "LimitLoadToDeveloperMode");
  xpc_object_t v54 = xpc_dictionary_get_value(v35, "_LimitLoadToDeviceTree");
  if (v54 && (sub_100006930(v54, v36) & 1) == 0) {
    goto LABEL_39;
  }
  xpc_object_t v55 = xpc_dictionary_get_value(v35, "_LimitLoadFromDeviceTree");
  if (v55)
  {
  }

  xpc_object_t v56 = xpc_dictionary_get_value(v35, "_LimitLoadToBootarg");
  if (v56 && (sub_100006A48(v56, v36) & 1) == 0
    || (xpc_object_t v57 = xpc_dictionary_get_value(v35, "_LimitLoadFromBootarg")) != 0LL && sub_100006A48(v57, v36))
  {
    uint64_t v19 = 0LL;
    int v43 = 160;
    goto LABEL_74;
  }

  if (byte_10006A930 && !xpc_dictionary_get_BOOL(v35, "MinimalBootProfile"))
  {
LABEL_73:
    uint64_t v19 = 0LL;
    int v43 = 152;
    goto LABEL_74;
  }

  v58 = sub_100028EF4(a1, v38);
  if (v58)
  {
    v59 = (const char *)sub_10001A0A4((uint64_t)v58);
    if (!strcmp(__s1, v59))
    {
      int v43 = 37;
    }

    else
    {
      if (*v59 == 47 && *__s1 == 47) {
        sub_10002587C( (uint64_t)a1,  4,  "Attempt to re-bootstrap service from different path, will use existing: service = %s, existing = %s, conflicting = %s",  v60,  v61,  v62,  v63,  v64,  (char)v38);
      }
      int v43 = 17;
    }

    uint64_t v19 = 0LL;
LABEL_74:
    *a7 = v43;
  }

  else
  {
    v65 = sub_100006B60(v35, __s1, v74, a6, v75, a7, v36);
    uint64_t v19 = (uint64_t)v65;
    if (v65)
    {
      int v66 = sub_100004578((uint64_t)v65, (uint64_t)a1, v36);
      *a7 = v66;
      if (v66)
      {
        sub_10001685C((void *)v19);
        uint64_t v19 = 0LL;
      }

      else
      {
        sub_100007244(v19, (uint64_t)a1, v67, v68, v69, v70, v71, v72);
        if (*(_DWORD *)(v19 + 872) == 768 && !byte_10006A9BB) {
          *(_DWORD *)(v19 + 888) = 17;
        }
        if (byte_10006A97F)
        {
          *(void *)(v19 + 900) = -1LL;
          *(_DWORD *)(v19 + 892) &= 0xFFFFFFF3;
        }
      }
    }
  }

  sub_100011A50((uint64_t)v36);
  xpc_release(v35);
  return v19;
}

BOOL sub_100003C1C(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 1353) & 0x40) != 0 || *(_BYTE *)(a1 + 1320) != 0;
}

char *sub_100003C3C( uint64_t a1, unsigned __int8 *uu, uint64_t a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, int *a8)
{
  uint64_t v9 = *(void *)(a1 + 1352);
  if ((v9 & 0x20000) != 0
    || *(void *)(*(void *)(a1 + 248) + 64LL) == a1
    || (v9 & 0x20000000) != 0
    || (~v9 & 0x40000001000LL) == 0
    || (v9 & 0x80) != 0
    || *(void *)(a1 + 144))
  {
    size_t v11 = 0LL;
    int v12 = 136;
LABEL_8:
    *a8 = v12;
    return v11;
  }

  if ((v9 & 0x4000) == 0 && !*(_BYTE *)(a1 + 1320) || (v9 & 0x8000) != 0 || (*(_BYTE *)(a1 + 368) & 0x20) != 0) {
    goto LABEL_28;
  }
  if ((v9 & 0x4000000000LL) != 0) {
    sub_100039448("multiple-instance service has no initialized endpoints");
  }
  mach_port_name_t v20 = *(_DWORD *)(a1 + 1316);
  if (v20 + 1 >= 2)
  {
    if (sub_10000AC54(v20))
    {
LABEL_28:
      size_t v11 = 0LL;
      int v12 = 137;
      goto LABEL_8;
    }
  }

  memset(out, 0, 37);
  uuid_unparse(uu, out);
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v27 = 0u;
  snprintf(__str, 0x100uLL, "%s.%s", (const char *)(a1 + 1360), out);
  uint64_t v21 = sub_10001198C(*(void *)(a1 + 248), __str);
  uint64_t v22 = sub_100003E70(a1, uu, __str, a3, a5, a6, a7, v21, a8);
  size_t v11 = v22;
  if (a4)
  {
    if (*(void *)a4) {
      sub_1000044A4((uint64_t)v22, *(const void **)a4);
    }
    uint64_t v23 = *(const char **)(a4 + 8);
    if (v23) {
      sub_100004504((uint64_t)v11, v23);
    }
    uint64_t v24 = *(void *)(a4 + 16);
    if (v24) {
      xpc_dictionary_apply_f(v24);
    }
  }

  if (v11)
  {
    int v25 = sub_100004578((uint64_t)v11, *(void *)(a1 + 248), v21);
    *a8 = v25;
    if (v25)
    {
      sub_10001685C(v11);
      size_t v11 = 0LL;
    }
  }

  sub_100011A50((uint64_t)v21);
  return v11;
}

char *sub_100003E70( uint64_t a1, const unsigned __int8 *a2, char *a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, _BYTE *a8, int *a9)
{
  if (*(_DWORD *)(a1 + 428))
  {
    xpc_object_t v17 = xpc_array_create(0LL, 0LL);
    if (*(_DWORD *)(a1 + 428))
    {
      unsigned int v86 = a2;
      unint64_t v18 = 0LL;
      do
        xpc_array_set_string(v17, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(*(void *)(a1 + 432) + 8 * v18++));
      while (v18 < *(unsigned int *)(a1 + 428));
      a2 = v86;
    }
  }

  else
  {
    xpc_object_t v17 = 0LL;
  }

  uint64_t v22 = sub_100005228(*(void **)(a1 + 16), a5, a3, v17, a6, a7 | 4, a9, a8);
  if (v17) {
    xpc_release(v17);
  }
  if (v22)
  {
    if ((_DWORD)a4 == -1
      || (int v23 = sub_10001AE98( v22,  *(void *)(a1 + 448),  *(void *)(a1 + 456),  *(void *)(a1 + 464),  a4,  v19,  v20,  v21)) == 0)
    {
      if (!a5)
      {
        __int128 v30 = *(_OWORD *)(a1 + 392);
        *(_OWORD *)(v22 + 376) = *(_OWORD *)(a1 + 376);
        *(_OWORD *)(v22 + 392) = v30;
      }

      __int128 v31 = *(const char **)(a1 + 576);
      if (v31) {
        *((void *)v22 + 72) = sub_1000126A0(v31);
      }
      __int128 v32 = *(const char **)(a1 + 440);
      if (v32) {
        *((void *)v22 + 55) = sub_1000126A0(v32);
      }
      __int128 v33 = *(const char **)(a1 + 864);
      if (v33) {
        *((void *)v22 + 108) = sub_1000126A0(v33);
      }
      __int128 v34 = *(const char **)(a1 + 448);
      if (v34) {
        *((void *)v22 + 56) = sub_1000126A0(v34);
      }
      __int128 v35 = *(const char **)(a1 + 456);
      if (v35) {
        *((void *)v22 + 57) = sub_1000126A0(v35);
      }
      __int128 v36 = *(const char **)(a1 + 464);
      if (v36) {
        *((void *)v22 + 58) = sub_1000126A0(v36);
      }
      sub_1000387B4(a1, (uint64_t)v22);
      sub_100038840(a1, (uint64_t)v22);
      __int128 v37 = *(const char **)(a1 + 480);
      if (v37) {
        *((void *)v22 + 60) = sub_1000126A0(v37);
      }
      __int128 v38 = *(const char **)(a1 + 472);
      if (v38) {
        *((void *)v22 + 74) += ~strlen(v38);
      }
      __int128 v39 = *(const char **)(a1 + 488);
      if (v39) {
        *((void *)v22 + 61) = sub_1000126A0(v39);
      }
      uuid_copy((unsigned __int8 *)v22 + 408, a2);
      xpc_object_t v45 = *(const char **)(a1 + 776);
      if (v45) {
        *((void *)v22 + 97) = sub_1000126A0(v45);
      }
      v46 = *(const char **)(a1 + 784);
      if (v46) {
        *((void *)v22 + 98) = sub_1000126A0(v46);
      }
      *((void *)v22 + 109) = *(void *)(a1 + 872);
      unint64_t v47 = *((void *)v22 + 169) & 0xEFFFFFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 60) & 1LL) << 60);
      *((void *)v22 + 169) = v47;
      *(_OWORD *)(v22 + 892) = *(_OWORD *)(a1 + 892);
      *((_DWORD *)v22 + 227) = *(_DWORD *)(a1 + 908);
      *((void *)v22 + 114) = *(void *)(a1 + 912);
      *(_OWORD *)(v22 + 920) = *(_OWORD *)(a1 + 920);
      *((void *)v22 + 117) = *(void *)(a1 + 936);
      *((_DWORD *)v22 + 236) = *(_DWORD *)(a1 + 944);
      v22[960] = *(_BYTE *)(a1 + 960);
      *((void *)v22 + 169) = v47 | 0x20000000000LL;
      v22[356] = *(_BYTE *)(a1 + 356);
      v22[1006] = *(_BYTE *)(a1 + 1006);
      *((void *)v22 + 169) = v47 & 0xFBFFFDFFFFFFFFFFLL | 0x20000000000LL | (((*(void *)(a1 + 1352) >> 58) & 1LL) << 58);
      v22[994] = *(_BYTE *)(a1 + 994);
      *((_DWORD *)v22 + 249) = *(_DWORD *)(a1 + 996);
      v48 = *(const void **)(a1 + 880);
      if (v48) {
        *((void *)v22 + 110) = xpc_binprefs_copy(v48);
      }
      *((_DWORD *)v22 + 222) = *(_DWORD *)(a1 + 888);
      xpc_object_t v49 = *(void **)(a1 + 984);
      if (v49)
      {
        xpc_object_t v50 = (uint64_t *)(v22 + 984);
        do
        {
          out[0] = 0LL;
          xpc_object_t v51 = (void *)sub_1000169A0((uint64_t)v49, out);
          uint64_t v52 = *v50;
          *xpc_object_t v51 = *v50;
          if (v52) {
            *(void *)(v52 + 8) = v51;
          }
          *((void *)v22 + 123) = v51;
          v51[1] = v50;
          ++*((_WORD *)v22 + 496);
          *((void *)v22 + 74) += out[0];
          xpc_object_t v49 = (void *)*v49;
        }

        while (v49);
      }

      unint64_t v53 = *((void *)v22 + 169) & 0xFFFFFFFFFFFFFFFELL | *(void *)(a1 + 1352) & 1LL;
      *((void *)v22 + 169) = v53;
      unint64_t v54 = v53 & 0xFFFFFFFFFFFFFFFDLL | (2 * ((*(void *)(a1 + 1352) >> 1) & 1LL));
      *((void *)v22 + 169) = v54;
      unint64_t v55 = v54 & 0xFFFFFFFFFFFFFFFBLL | (4 * ((*(void *)(a1 + 1352) >> 2) & 1LL));
      *((void *)v22 + 169) = v55;
      unint64_t v56 = v55 & 0xFFFFFFFFFFFFFFF7LL | (8 * ((*(void *)(a1 + 1352) >> 3) & 1LL));
      *((void *)v22 + 169) = v56;
      unint64_t v57 = v56 & 0xFFFFFFFFFFFFFFDFLL | (32 * ((*(void *)(a1 + 1352) >> 5) & 1LL));
      *((void *)v22 + 169) = v57;
      unint64_t v58 = v57 & 0xFFFFFFFFFFFFFFBFLL | (((*(void *)(a1 + 1352) >> 6) & 1LL) << 6);
      *((void *)v22 + 169) = v58;
      v22[1308] = *(_BYTE *)(a1 + 1308);
      unint64_t v59 = v58 & 0xFFFFFFFFFFFFFEFFLL | (((*(void *)(a1 + 1352) >> 8) & 1LL) << 8);
      *((void *)v22 + 169) = v59;
      unint64_t v60 = v59 & 0xFFFFFFFFFFFFFDFFLL | (((*(void *)(a1 + 1352) >> 9) & 1LL) << 9);
      *((void *)v22 + 169) = v60;
      unint64_t v61 = v60 & 0xFFFFFFFFFFFFFBFFLL | (((*(void *)(a1 + 1352) >> 10) & 1LL) << 10);
      *((void *)v22 + 169) = v61;
      unint64_t v62 = v61 & 0xFFFFFFFFFFFEFFFFLL | (((*(void *)(a1 + 1352) >> 16) & 1LL) << 16);
      *((void *)v22 + 169) = v62;
      unint64_t v63 = v62 & 0xFFFFFFFFFF7FFFFFLL | (((*(void *)(a1 + 1352) >> 23) & 1LL) << 23);
      *((void *)v22 + 169) = v63;
      unint64_t v64 = v63 & 0xFFFFFFFFFEFFFFFFLL | (((*(void *)(a1 + 1352) >> 24) & 1LL) << 24);
      *((void *)v22 + 169) = v64;
      unint64_t v65 = v64 & 0xFFBFFFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 54) & 1LL) << 54);
      *((void *)v22 + 169) = v65;
      unint64_t v66 = v65 & 0xFFFFFFFFBFFFFFFFLL | (((*(void *)(a1 + 1352) >> 30) & 1LL) << 30);
      *((void *)v22 + 169) = v66;
      *((void *)v22 + 121) = *(void *)(a1 + 968);
      *((void *)v22 + 122) = *(void *)(a1 + 976);
      unint64_t v67 = v66 & 0xFFFFFFFDFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 33) & 1LL) << 33);
      *((void *)v22 + 169) = v67;
      v22[1016] = *(_BYTE *)(a1 + 1016);
      unint64_t v68 = v67 & 0xFFEFFFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 52) & 1LL) << 52);
      *((void *)v22 + 169) = v68;
      *((_WORD *)v22 + 502) = *(_WORD *)(a1 + 1004);
      unint64_t v69 = v68 & 0xFFF7FFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 51) & 1LL) << 51);
      *((void *)v22 + 169) = v69;
      unint64_t v70 = v69 & 0xFFFFFFFBFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 34) & 1LL) << 34);
      *((void *)v22 + 169) = v70;
      uint64_t v71 = *(const char **)(a1 + 584);
      if (v71)
      {
        *((void *)v22 + 73) = sub_1000126A0(v71);
        unint64_t v70 = *((void *)v22 + 169);
      }

      *((_DWORD *)v22 + 211) = *(_DWORD *)(a1 + 844);
      unint64_t v72 = v70 & 0xFFFFFEFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 40) & 1LL) << 40);
      *((void *)v22 + 169) = v72;
      unint64_t v73 = v72 & 0xFFFFF7FFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 43) & 1LL) << 43);
      *((void *)v22 + 169) = v73;
      unint64_t v74 = v73 & 0xFFFFEFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 44) & 1LL) << 44);
      *((void *)v22 + 169) = v74;
      *((_DWORD *)v22 + 326) = *(_DWORD *)(a1 + 1304);
      unint64_t v75 = v74 & 0xFFFFDFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 45) & 1LL) << 45);
      *((void *)v22 + 169) = v75;
      unint64_t v76 = v75 & 0xFFFFBFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 46) & 1LL) << 46);
      *((void *)v22 + 169) = v76;
      unint64_t v77 = v76 & 0xFFFF7FFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 47) & 1LL) << 47);
      *((void *)v22 + 169) = v77;
      *((void *)v22 + 169) = v77 & 0xFFFDFFFFFFFFFFFFLL | (((*(void *)(a1 + 1352) >> 49) & 1LL) << 49);
      *((_DWORD *)v22 + 329) = *(_DWORD *)(a1 + 1316);
      v78 = *(void **)(a1 + 640);
      if (v78) {
        *((void *)v22 + 80) = xpc_retain(v78);
      }
      v79 = *(void **)(a1 + 496);
      if (v79)
      {
        if (*(_BYTE *)(a1 + 1320) == 2) {
          *((void *)v22 + 62) = xpc_retain(v79);
        }
        else {
          sub_10001A4D8((uint64_t)v22, 4, "Service instances do not support XPC events.", v40, v41, v42, v43, v44, v85);
        }
      }

      v80 = *(const char **)(a1 + 1336);
      if (v80) {
        *((void *)v22 + 167) = sub_1000126A0(v80);
      }
      v81 = *(const char **)(a1 + 1344);
      if (v81) {
        *((void *)v22 + 168) = sub_1000126A0(v81);
      }
      unsigned int v82 = *(const void **)(a1 + 600);
      if (v82)
      {
        *((void *)v22 + 75) = sub_100012670(v82, *(unsigned int *)(a1 + 608));
        *((_DWORD *)v22 + 152) = *(_DWORD *)(a1 + 608);
      }

      unsigned int v83 = *(const void **)(a1 + 616);
      if (v83)
      {
        *((void *)v22 + 77) = sub_100012670(v83, *(unsigned int *)(a1 + 624));
        *((_DWORD *)v22 + 156) = *(_DWORD *)(a1 + 624);
      }

      *((void *)v22 + 74) = *(void *)(a1 + 592);
      memset(out, 0, 37);
      uuid_unparse(a2, (char *)out);
      sub_100003218((uint64_t)v22, "LaunchInstanceID", (const char *)out, 1);
    }

    else
    {
      char v24 = v23;
      *a9 = v23;
      strerror(v23);
      sub_10001A4D8(a1, 3, "Could not set up nowait inetd service: %d: %s", v25, v26, v27, v28, v29, v24);
      sub_10001685C(v22);
      return 0LL;
    }
  }

  return v22;
}

uint64_t sub_1000044A4(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 880);
  if (v4)
  {
    *(void *)(a1 + 592) -= _xpc_spawnattr_binprefs_size(v4);
    free(*(void **)(a1 + 880));
  }

  *(void *)(a1 + 880) = xpc_binprefs_copy(a2);
  uint64_t result = _xpc_spawnattr_binprefs_size((uint64_t)a2);
  *(void *)(a1 + 592) += result;
  return result;
}

size_t sub_100004504(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(void **)(a1 + 480);
  if (v4)
  {
    *(void *)(a1 + 592) += ~strlen(*(const char **)(a1 + 480));
    free(v4);
  }

  *(void *)(a1 + 480) = sub_1000126A0(a2);
  size_t result = strlen(a2);
  *(void *)(a1 + 592) += result + 1;
  return result;
}

uint64_t sub_100004578(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  if (!sub_100025D50(a2))
  {
    uint64_t v7 = (void *)sub_10002A994(a2);
    uint64_t v8 = v7;
    unint64_t v9 = *(void *)(a1 + 1352);
    if ((v9 & 0x40000000) != 0 && v7 != &unk_100069750)
    {
      sub_100011A84(a3, 3LL, "_AbandonCoalition is only available to Application services.");
      unint64_t v9 = *(void *)(a1 + 1352) & 0xFFFFFFFFBFFFFFFFLL;
      *(void *)(a1 + 1352) = v9;
    }

    if ((v9 & 0x80000000000LL) != 0 && v8 != &unk_1000695B8)
    {
      sub_100011A84(a3, 3LL, "DisallowAllLookups is not supported for non-System services.");
      *(void *)(a1 + 1352) &= ~0x80000000000uLL;
    }

    if (!sub_1000259FC(a2))
    {
      if (*(void *)(a1 + 776))
      {
        int v10 = (*(void *)(a1 + 1352) & 2LL) != 0 ? "_RoleAccount" : "UserName";
        sub_100011A84(a3, 3LL, "%s is not supported by the domain, ignoring.", v10);
        size_t v11 = *(void **)(a1 + 776);
        if (v11)
        {
          *(void *)(a1 + 592) += ~strlen(*(const char **)(a1 + 776));
          free(v11);
          *(void *)(a1 + 776) = 0LL;
        }
      }

      if (*(void *)(a1 + 784))
      {
        sub_100011A84(a3, 3LL, "GroupName is not supported by the domain, ignoring.");
        int v12 = *(char **)(a1 + 784);
        *(void *)(a1 + 592) += ~strlen(v12);
        free(v12);
        *(void *)(a1 + 784) = 0LL;
      }
    }

    uint64_t v13 = *(void *)(a1 + 1352);
    if ((v13 & 0x200000000000LL) != 0)
    {
      if ((v13 & 0x40400000000LL) == 0)
      {
        uint64_t v6 = 144LL;
        sub_100011A84(a3, 3LL, "persona can only be set on submitted jobs and extensions");
        return v6;
      }

      if ((sub_10000D114(a1 + 376, 3LL) & 1) == 0 && !sub_10000D114(a1 + 376, 15LL))
      {
        uint64_t v6 = 144LL;
        sub_100011A84(a3, 3LL, "setting persona requires an entitlement");
        return v6;
      }
    }

    uint64_t v14 = *(void *)(a1 + 1352);
    if ((v14 & 0x800000000000000LL) != 0)
    {
      if ((v14 & 0x40400000000LL) == 0
        || (v15 = sub_10000D114(a1 + 376, 30LL), uint64_t v14 = *(void *)(a1 + 1352), (v15 & 1) == 0))
      {
        if ((v14 & 0x100000000000LL) == 0)
        {
          uint64_t v6 = 1LL;
          sub_100011A84(a3, 3LL, "_Cryptex can only be set on trusted services");
          return v6;
        }
      }
    }

    if (*(void *)(a1 + 1344))
    {
      if ((v14 & 0x40400000000LL) == 0
        || (v16 = sub_10000D114(a1 + 376, 31LL), uint64_t v14 = *(void *)(a1 + 1352), (v16 & 1) == 0))
      {
        if ((v14 & 0x100000000000LL) == 0)
        {
          uint64_t v6 = 1LL;
          sub_100011A84(a3, 3LL, "_Conclave can only be set on trusted services");
          return v6;
        }
      }
    }

    if ((v14 & 0x8000000) != 0) {
      sub_100046F28(v14 & 0x8000000);
    }
    *(void *)(a1 + 1352) = v14 | 0x8000000;
    *(void *)(a1 + 248) = a2;
    (*(void (**)(uint64_t, void))(a1 + 560))(a1, *(void *)(a1 + 568));
    uint64_t v22 = *(char **)(*(void *)(a1 + 248) + 48LL);
    while (v22)
    {
      int v23 = (char **)v22;
      uint64_t v22 = *(char **)v22;
      if (sub_1000129FC(v23[2], (const char *)(a1 + 1360)))
      {
        sub_10001A4D8(a1, 5, "matched domain attach request on creation", v17, v18, v19, v20, v21, v39);
        sub_10003E5F8(dword_10006A940, v23[3]);
        xpc_release(v23[3]);
        char v24 = *v23;
        if (*v23) {
          *((void *)v24 + 1) = v23[1];
        }
        *(void *)v23[1] = v24;
        free(v23);
        break;
      }
    }

    if (*(void *)(a1 + 496))
    {
      if (sub_10001C0CC())
      {
        sub_10001A4D8(a1, 5, "Ignoring events for retain only services", v25, v26, v27, v28, v29, v39);
      }

      else
      {
        if (byte_10006A9B1) {
          sub_10001A4D8(a1, 5, "Operating in pure on-demand mode. Ignoring events", v25, v26, v27, v28, v29, v39);
        }
        else {
          xpc_dictionary_apply_f(*(void *)(a1 + 496));
        }
        if ((*(_BYTE *)(a1 + 1353) & 0x40) == 0 && !*(_BYTE *)(a1 + 1320))
        {
          xpc_release(*(xpc_object_t *)(a1 + 496));
          *(void *)(a1 + 496) = 0LL;
        }
      }
    }

    __int128 v30 = *(void **)(a1 + 504);
    if (v30)
    {
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000LL;
      applier[2] = sub_10000573C;
      applier[3] = &unk_100061178;
      applier[4] = a1;
      xpc_dictionary_apply(v30, applier);
      xpc_release(*(xpc_object_t *)(a1 + 504));
      *(void *)(a1 + 504) = 0LL;
      __int128 v31 = sub_100010B00(0x28uLL);
      v31[32] = 1;
      *((void *)v31 + 2) = sub_10001A334;
      *((void *)v31 + 3) = "provides events";
      __int128 v32 = (void *)(a1 + 648);
      uint64_t v33 = *(void *)(a1 + 648);
      *(void *)__int128 v31 = v33;
      if (v33) {
        *(void *)(v33 + 8) = v31;
      }
      *__int128 v32 = v31;
      *((void *)v31 + 1) = v32;
    }

    uint64_t v34 = *(void *)(a1 + 1352);
    if ((v34 & 0x400001000LL) == 0)
    {
      uint64_t v6 = 0LL;
      *(void *)(a1 + 1352) = v34 | 0x1000000000000LL;
      return v6;
    }

    if ((v34 & 0x80000) != 0)
    {
      __int128 v35 = "it has a roleaccount set";
    }

    else if (*(void *)(a1 + 656))
    {
      __int128 v35 = "it has limits set";
    }

    else if (*(void *)(a1 + 440))
    {
      __int128 v35 = "it set a non standard working directory";
    }

    else if ((v34 & 0x100000000LL) != 0)
    {
      __int128 v35 = "it set a non standard umask";
    }

    else if ((v34 & 0x60) != 0)
    {
      __int128 v35 = "it set an io priority";
    }

    else
    {
      __int128 v38 = (const char *)sub_10001A098(a1);
      if (access(v38, 1))
      {
        __int128 v35 = "its binary is missing or not executable";
      }

      else if (*(void *)(a1 + 1336))
      {
        __int128 v35 = "is from a cryptex";
      }

      else if ((*(_BYTE *)(a1 + 1355) & 0x80) != 0)
      {
        __int128 v35 = "it disabled initgroups";
      }

      else
      {
        sub_100005904(a1);
        if (!v35)
        {
          if (byte_100069A6C)
          {
            __int128 v36 = "service will attempt to elide xpcproxy";
          }

          else
          {
            *(void *)(a1 + 1352) |= 0x1000000000000uLL;
            __int128 v36 = "service will always use xpcproxy, elision was disabled by boot-arg";
          }

          goto LABEL_62;
        }
      }
    }

    *(void *)(a1 + 1352) |= 0x1000000000000uLL;
    char v39 = (char)v35;
    __int128 v36 = "service will always use xpcproxy because %s";
LABEL_62:
    sub_10001A4D8(a1, 5, v36, v17, v18, v19, v20, v21, v39);
    return 0LL;
  }

  return 124LL;
}

void sub_100004AB0(void *guard)
{
  uint64_t v1 = guard[169];
  if ((v1 & 0x10000000) != 0) {
    sub_100039448("attempted to petrify a service twice");
  }
  guard[169] = v1 | 0x10000000;
  if ((v1 & 0x8000000) == 0) {
    sub_100039448("attempted to petrify a service that hasn't been animated");
  }
  uint64_t v3 = (void *)guard[17];
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)v3[2];
      sub_100035ECC(v3);
      sub_10001685C(v3);
      uint64_t v3 = v4;
    }

    while (v4);
  }

  uint64_t v5 = (void *)guard[18];
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)v5[2];
      sub_1000359A0((uint64_t)v5);
      sub_10001685C(v5);
      uint64_t v5 = v6;
    }

    while (v6);
  }

  sub_100020978((mach_port_context_t)guard);
  sub_10001A394((uint64_t)guard, 9LL, 0LL);
}

char *sub_100004B74(uint64_t a1, uint64_t a2, _OWORD *a3, void *a4, uint64_t a5, unint64_t a6, int *a7)
{
  uint64_t property = xpc_bundle_get_property(a2, 2LL);
  if (!property)
  {
    *a7 = 107;
    uint64_t v43 = "Could not get path for service bundle.";
LABEL_18:
    sub_10002587C(a1, 3, v43, v15, v16, v17, v18, v19, v74);
    return 0LL;
  }

  char v20 = property;
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!info_dictionary)
  {
    *a7 = 107;
    char v74 = v20;
    uint64_t v43 = "Could not get Info.plist for bundle at %s";
    goto LABEL_18;
  }

  uint64_t v22 = info_dictionary;
  string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier");
  if (!string)
  {
    sub_10002587C(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v24, v25, v26, v27, v28, v20);
    goto LABEL_20;
  }

  uint64_t v29 = string;
  xpc_object_t value = xpc_dictionary_get_value(v22, "XPCService");
  if (value)
  {
    __int128 v31 = sub_1000051B8(value, a1, v29);
    if (v31)
    {
      __int128 v32 = v31;
      xpc_dictionary_set_value(v22, "XPCService", v31);
      xpc_release(v32);
      goto LABEL_7;
    }

LABEL_20:
    uint64_t v44 = 0LL;
    *a7 = 107;
    return v44;
  }

    uint64_t v14 = xpc_BOOL_get_value(value);
    if (v10 == 1 && v13 != v14)
    {
      sub_100011A84(a3, 3LL, "EnablePressuredExit is not compatible with KeepAlive=true. Ignoring EnablePressuredExit.");
      goto LABEL_25;
    }

    __break(1u);
    return;
  }

  uint64_t v17 = *(char **)a1;
  uint64_t v18 = *(void *)(a1 + 8);
LABEL_13:
  uint64_t v19 = strlcat(v17, __source[0], v18);
  *(void *)(a1 + 16) = v19;
  if (v19 >= *(void *)(a1 + 8)) {
    sub_100046EB4();
  }
  free(__source[0]);
}

    sub_10001A4D8(a1, 4, "Skipping remaining event endpoints for importance boosting.", v3, v4, v5, v6, v7, v96);
    goto LABEL_21;
  }

    if (!v15) {
      goto LABEL_27;
    }
    goto LABEL_21;
  }

  return result;
}

      sub_100011A84(v5, 3LL, "Unrecognized MachService property: %s");
      return 1LL;
    }

    if (!strcasecmp(a2, "TaskSpecialPort"))
    {
      xpc_string_get_string_ptr(object);
      int v12 = mach_task_special_port_for_id();
      if (v12 <= 0) {
        sub_100011A84(v5, 3LL, "Tried to set an unknown task-special port: %s");
      }
    }

    else
    {
      if (strcasecmp(a2, "HostSpecialPort")) {
        goto LABEL_20;
      }
      xpc_string_get_string_ptr(object);
      int v12 = mach_host_special_port_for_id();
      if (v12 <= 0) {
        sub_100011A84(v5, 3LL, "Tried to set an unknown host-special port: %s");
      }
    }

    int v10 = v6;
    xpc_object_t value = v12;
LABEL_34:
    sub_100040664(v10, value, v5);
    return 1LL;
  }

  if (!strcasecmp(a2, "TaskSpecialPort"))
  {
    xpc_object_t value = xpc_int64_get_value(object);
    int v10 = v6;
    goto LABEL_34;
  }

  if (strcasecmp(a2, "HostSpecialPort")) {
    goto LABEL_20;
  }
  uint64_t v8 = xpc_int64_get_value(object);
  if (v8 < 8)
  {
    mach_host_special_port_description(v8);
    sub_100011A84(v5, 3LL, "Tried to set a reserved host-special port: %lld: %s");
  }

  else if ((unint64_t)v8 > 0x23)
  {
    sub_100011A84(v5, 3LL, "Tried to set an invalid host-special port: %lld");
  }

  else
  {
    *(_DWORD *)(v6 + 84) = v8;
  }

  return 1LL;
}

LABEL_7:
  uint64_t v33 = sub_10001198C(a1, v29);
  uint64_t v34 = xpc_bundle_get_property(a2, 2LL);
  if (!v34) {
    sub_100046EB4();
  }
  __int128 v35 = (const char *)v34;
  __int128 v36 = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!v36) {
    sub_100046EB4();
  }
  __int128 v37 = v36;
  v78 = (char *)xpc_dictionary_get_string(v36, "CFBundleIdentifier");
  if (!v78) {
    sub_100046EB4();
  }
  uint64_t executable_path = xpc_bundle_get_executable_path(a2);
  if (!executable_path)
  {
    sub_100011A84(v33, 3LL, "Bundle has no executable");
LABEL_26:
    *a7 = 107;
    goto LABEL_27;
  }

  char v39 = (char *)executable_path;
  v79 = v33;
  xpc_object_t v40 = xpc_dictionary_get_value(v37, "XPCService");
  if (!v40)
  {
    xpc_object_t v45 = "XPC Service Info.plist is missing XPCService dictionary";
LABEL_25:
    uint64_t v33 = v79;
    sub_100011A84(v79, 3LL, v45);
    goto LABEL_26;
  }

  uint64_t v41 = v40;
  xpc_type_t type = xpc_get_type(v40);
  if (v41 == &_xpc_BOOL_false && type == (xpc_type_t)&_xpc_type_BOOL)
  {
    *a7 = 107;
LABEL_15:
    uint64_t v33 = v79;
LABEL_27:
    uint64_t v46 = (uint64_t)v33;
LABEL_28:
    sub_100011A50(v46);
    return 0LL;
  }

  if (xpc_get_type(v41) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v45 = "XPCService must be dictionary";
    goto LABEL_25;
  }

  if ((a6 & 0x40) != 0)
  {
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(v37, "EXAppExtensionAttributes");
    if (dictionary)
    {
      xpc_object_t v50 = xpc_dictionary_get_string(dictionary, "EXExtensionPointIdentifier");
      if (!v50)
      {
        xpc_object_t v45 = "App Extension Info.plist is missing EXExtentionPointIdentifier";
        goto LABEL_25;
      }
    }

    else
    {
      xpc_object_t v51 = xpc_dictionary_get_dictionary(v37, "NSExtension");
      if (!v51 || (xpc_object_t v50 = xpc_dictionary_get_string(v51, "NSExtensionPointIdentifier")) == 0LL)
      {
        xpc_object_t v45 = "App Extension Info.plist is missing NSExtentionPointIdentifier";
        goto LABEL_25;
      }
    }

    if (a4 && (xpc_object_t v52 = xpc_dictionary_get_value(a4, "XPCService")) != 0LL) {
      xpc_object_t v76 = xpc_dictionary_get_value(v52, "ProgramArguments");
    }
    else {
      xpc_object_t v76 = 0LL;
    }
    unint64_t v75 = v50;
    xpc_object_t v48 = sub_10000C5B8(v50);
  }

  else
  {
    xpc_object_t v48 = sub_10000C634(v78, v41);
    unint64_t v75 = 0LL;
    xpc_object_t v76 = 0LL;
  }

  sub_10000BB08(v48, v79);
  sub_1000059FC(v41, v48, v79, 1);
  xpc_object_t object = v48;
  xpc_object_t v53 = xpc_dictionary_get_value(v48, "ExecuteAllowed");
  if (v53)
  {
    unint64_t v54 = v53;
    if (xpc_get_type(v53) == (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL v72 = xpc_BOOL_get_value(v54);
      if ((a6 & 0x200) == 0 && !v72)
      {
        *a7 = 157;
        goto LABEL_62;
      }
    }
  }

  unint64_t v55 = sub_10003CCD8((uint64_t)v41);
  unint64_t v56 = sub_100019FB4((uint64_t)v78, v39, v35, v55);
  sub_10001685C(v55);
  uint64_t v44 = sub_100005228(v56, a3, v78, v76, a5, a6, a7, v79);
  sub_10001685C(v56);
  if (!v44)
  {
LABEL_62:
    xpc_release(object);
    goto LABEL_15;
  }

  *((void *)v44 + 169) |= 0x4000000002uLL;
  if ((a6 & 0x40) != 0)
  {
    BOOL v66 = sub_100012944(v78, "com.apple.");
    uint64_t v67 = *((void *)v44 + 169);
    if (!v66) {
      v67 |= 0x8000000000uLL;
    }
    *((void *)v44 + 169) = v67 | 0x40000000;
    unint64_t v68 = sub_10001675C(v44, 1LL, (uint64_t)v79, 0LL);
    xpc_dictionary_apply_f(v41);
    sub_100016828(v68);
    unint64_t v58 = v79;
    sub_100006360((uint64_t)v44, v41);
    sub_10000BC6C((uint64_t)v44, object, (uint64_t)v79);
    nullsub_23(v44, object);
    xpc_release(object);
    if (v75) {
      *((void *)v44 + 73) = sub_1000126A0(v75);
    }
    if (a4)
    {
      xpc_object_t v69 = xpc_dictionary_get_value(a4, "XPCService");
      if (v69)
      {
        xpc_object_t v70 = xpc_dictionary_get_value(v69, "PersonaEnterprise");
        if (v70)
        {
          *((_DWORD *)v44 + 326) = xpc_int64_get_value(v70);
          *((void *)v44 + 169) |= 0x200000000000uLL;
        }
      }
    }

    unint64_t v65 = *((void *)v44 + 169) & 0xFFFFFFFFFFFFFCFFLL;
  }

  else
  {
    unint64_t v57 = sub_10001675C(v44, 1LL, (uint64_t)v79, 0LL);
    xpc_dictionary_apply_f(v41);
    sub_100016828(v57);
    unint64_t v58 = v79;
    sub_100006360((uint64_t)v44, v41);
    sub_10000BC6C((uint64_t)v44, object, (uint64_t)v79);
    nullsub_23(v44, object);
    xpc_release(object);
    unint64_t v65 = *((void *)v44 + 169);
  }

  *((void *)v44 + 72) = v44 + 1360;
  *((void *)v44 + 169) = v65 | 0x1000000000LL;
  sub_1000063F8((uint64_t)v44, a6, v59, v60, v61, v62, v63, v64);
  sub_100006480((uint64_t)v44);
  int v71 = sub_100004578((uint64_t)v44, a1, v58);
  *a7 = v71;
  if (v71)
  {
    sub_10001685C(v44);
    uint64_t v46 = (uint64_t)v58;
    goto LABEL_28;
  }

  if (*((void *)v44 + 62))
  {
    sub_100011A84(v58, 4LL, "Ignoring launch events for a bundle");
    xpc_release(*((xpc_object_t *)v44 + 62));
    *((void *)v44 + 62) = 0LL;
  }

  sub_100011A50((uint64_t)v58);
  int v73 = byte_10006A97F;
  if ((v44[1356] & 4) != 0) {
    int v73 = byte_10006A980 | byte_10006A97F;
  }
  if (v73)
  {
    *(void *)(v44 + 900) = -1LL;
    *((_DWORD *)v44 + 223) &= 0xFFFFFFF3;
  }

  return v44;
}

    xpc_type_t type = xpc_get_type(a3);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v15 = *(void *)(a1 + 32);
      string_ptr = xpc_string_get_string_ptr(a3);
      size_t v11 = v15;
      int v12 = (char *)a2;
      uint64_t v14 = 1LL;
    }

    else
    {
      if (type != (xpc_type_t)&_xpc_type_null) {
        return 1LL;
      }
      size_t v11 = *(void *)(a1 + 32);
      int v12 = (char *)a2;
      string_ptr = 0LL;
      uint64_t v14 = 0LL;
    }

    sub_100031474(v11, v12, string_ptr, v14);
    return 1LL;
  }

  uint64_t v8 = 124LL;
LABEL_6:
  sub_100028BC8(v6, v7, v8, "set dyld environment variable");
  return 1LL;
}

uint64_t *sub_1000051B8(void *a1, uint64_t a2, const char *a3)
{
  uint64_t v4 = sub_10001198C(a2, a3);
  int v10 = sub_100034728(a1, v4);
  if (*((_BYTE *)v4 + 16))
  {
    sub_10003B008((const char *)v4[1], 3, "Plist preprocessing failed, rejecting", v5, v6, v7, v8, v9, v12);
    xpc_release(v10);
    int v10 = 0LL;
  }

  sub_100011A50((uint64_t)v4);
  return v10;
}

char *sub_100005228( void *a1, _OWORD *a2, char *__s1, void *a4, uint64_t a5, unint64_t a6, int *a7, _BYTE *a8)
{
  uint64_t v13 = __s1;
  if (!strcmp(__s1, "shell"))
  {
    uint64_t v16 = 0LL;
    int v17 = 140;
    goto LABEL_7;
  }

  if (!a4)
  {
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    int v43 = 0;
LABEL_23:
    uint64_t v16 = sub_100016EF8(v13);
    *((void *)v16 + 2) = sub_1000167B0(a1);
    if (a2)
    {
      __int128 v34 = a2[1];
      *(_OWORD *)(v16 + 376) = *a2;
      *(_OWORD *)(v16 + 392) = v34;
    }

    v16[424] = 0;
    __int128 v35 = (const char *)sub_10001A098((uint64_t)v16);
    *((void *)v16 + 74) = v19 + strlen(v35) + 241;
    *((_DWORD *)v16 + 107) = v43;
    *((void *)v16 + 54) = v18;
    *((_DWORD *)v16 + 203) = 10;
    *((_DWORD *)v16 + 202) = dword_100069A38;
    *(_OWORD *)(v16 + 1176) = 0u;
    *(_OWORD *)(v16 + 1192) = 0u;
    *(_OWORD *)(v16 + 1208) = 0u;
    *((void *)v16 + 153) = 0LL;
    *((_DWORD *)v16 + 210) = 5;
    *((_DWORD *)v16 + 211) = dword_100069A40;
    *((void *)v16 + 109) = 1536LL;
    *((_WORD *)v16 + 648) = 0;
    *((void *)v16 + 161) = 0xFFFFFFFFLL;
    *((_DWORD *)v16 + 226) = -1;
    v16[994] = 0;
    *((_DWORD *)v16 + 249) = 0;
    *(_OWORD *)(v16 + 888) = xmmword_100049400;
    __int128 v36 = *(_OWORD *)(a5 + 32);
    *(_OWORD *)(v16 + 536) = *(_OWORD *)(a5 + 16);
    *(_OWORD *)(v16 + 552) = v36;
    *(_OWORD *)(v16 + 520) = *(_OWORD *)a5;
    *((void *)v16 + 71) = *(void *)(a5 + 48);
    *((void *)v16 + 83) = -1LL;
    *((_DWORD *)v16 + 168) = -1;
    v16[1017] = 1;
    *((void *)v16 + 169) |= 0x300uLL;
    *(void *)(v16 + 1324) = sub_1000015C8(v16 + 1360);
    uint64_t v37 = *((void *)v16 + 169) | 0x4000000000000LL;
    *((void *)v16 + 169) = v37;
    *((void *)v16 + 25) = 0LL;
    *((_WORD *)v16 + 502) = 10;
    *((_DWORD *)v16 + 60) = *((_DWORD *)v16 + 56);
    *((void *)v16 + 29) = *((void *)v16 + 27);
    *((_DWORD *)v16 + 56) = 3044;
    *((void *)v16 + 26) = v16 + 200;
    *((void *)v16 + 27) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/service_create.c";
    *(void *)&__int128 v38 = -1LL;
    *((void *)&v38 + 1) = -1LL;
    *(_OWORD *)(v16 + 24) = v38;
    *(_OWORD *)(v16 + 40) = v38;
    if ((a6 & 4) == 0)
    {
      sub_100003218((uint64_t)v16, "XPC_SERVICE_NAME", v13, 1);
      uint64_t v37 = *((void *)v16 + 169);
    }

    uint64_t v39 = (a6 << 27) & 0x100000000000LL | v37 | (a6 << 33) & 0x10000000000LL;
    if ((a6 & 0x202C0) != 0) {
      *((void *)v16 + 169) = (a6 << 33) & 0x40000000000LL | (((a6 >> 6) & 1) << 34) | v39;
    }
    *((_DWORD *)v16 + 329) = 0;
    v16[960] = (v39 & 0x100000000000LL) != 0;
    if ((a6 & 0x8000) != 0) {
      sub_100005604((uint64_t)v16, "com.apple.cryptex.app");
    }
    return v16;
  }

  if (xpc_get_type(a4) != (xpc_type_t)&_xpc_type_array)
  {
    sub_100011A84(a8, 3LL, "ProgramArguments is not an array.");
LABEL_5:
    uint64_t v16 = 0LL;
    int v17 = 111;
LABEL_7:
    *a7 = v17;
    return v16;
  }

  xpc_object_t v40 = a2;
  uint64_t v41 = a1;
  uint64_t v42 = v13;
  if (xpc_array_get_count(a4))
  {
    size_t v20 = 0LL;
    uint64_t v19 = 0LL;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(a4, v20);
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string) {
        break;
      }
      v19 += xpc_string_get_length(value) + 1;
      if (++v20 >= xpc_array_get_count(a4)) {
        goto LABEL_15;
      }
    }

    sub_100011A84(a8, 3LL, "ProgramArguments is not an array of strings.", a2);
    goto LABEL_5;
  }

  uint64_t v19 = 0LL;
LABEL_15:
  size_t result = (char *)xpc_array_get_count(a4);
  uint64_t v23 = result + 1LL;
  uint64_t v24 = v23 << 31 >> 31;
  if (v24 == v23 && (v24 & 0x8000000000000000LL) == 0)
  {
    uint64_t v25 = (uint64_t)result;
    uint64_t v26 = v24 & 0x1FFFFFFFFLL;
    size_t result = (char *)(v19 + 8 * v26);
    a1 = v41;
    uint64_t v13 = v42;
    if (!__CFADD__(v19, 8 * v26))
    {
      uint64_t v27 = (char *)sub_100010B00((size_t)result);
      uint64_t v18 = v27;
      uint64_t v28 = v25;
      int v43 = v25;
      if ((_DWORD)v25)
      {
        size_t v29 = 0LL;
        __int128 v30 = &v27[(8 * v25 + 8) & 0x7FFFFFFF8LL];
        do
        {
          xpc_object_t v31 = xpc_array_get_value(a4, v29);
          string_ptr = xpc_string_get_string_ptr(v31);
          size_t length = xpc_string_get_length(v31);
          *(void *)&v18[8 * v29] = v30;
          strcpy(v30, string_ptr);
          v30 += length + 1;
          ++v29;
        }

        while (v28 != v29);
        a1 = v41;
        uint64_t v13 = v42;
      }

      a2 = v40;
      goto LABEL_23;
    }
  }

  __break(1u);
  return result;
}

size_t sub_100005604(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(void **)(a1 + 1336);
  if (v4)
  {
    *(void *)(a1 + 592) += ~strlen(*(const char **)(a1 + 1336));
    free(v4);
    *(void *)(a1 + 1336) = 0LL;
  }

  *(void *)(a1 + 1336) = sub_1000126A0(a2);
  size_t result = strlen(a2);
  *(void *)(a1 + 592) += result + 1;
  return result;
}

void sub_10000567C(char *a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    if ((*(_BYTE *)(a3 + 1356) & 0x80) != 0 || !sub_100016B08(a1))
    {
      string_ptr = xpc_string_get_string_ptr(object);
      sub_100003218(a3, a1, string_ptr, 0);
    }

    else
    {
      sub_10001A4D8(a3, 3, "Disallowing environment variable: %s", v12, v13, v14, v15, v16, (char)a1);
    }
  }

  else
  {
    xpc_type_t type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_10001A4D8( a3,  3,  "Invalid type for environment variable value (env/type): %s/%s",  v7,  v8,  v9,  v10,  v11,  (char)a1);
  }

uint64_t sub_10000573C(uint64_t a1, const void *a2, xpc_object_t object)
{
  uint64_t v6 = *(void *)(a1 + 32);
  char value = xpc_uint64_get_value(object);
  sub_100035544(v6, a2, value, 0LL);
  return 1LL;
}

void sub_1000057A8(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_100005864;
    applier[3] = &unk_100061198;
    applier[4] = a3;
    void applier[5] = a1;
    xpc_dictionary_apply(object, applier);
  }

  else
  {
    xpc_type_t type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_10001A4D8(a3, 3, "Invalid type for event stream (stream/type): %s/%s", v7, v8, v9, v10, v11, a1);
    *(void *)(a3 + 1352) |= 1uLL;
  }

uint64_t sub_100005864(uint64_t a1, const char *a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  uint64_t v7 = *(void *)(a1 + 32);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100035CE8(*(void **)(a1 + 32), *(const void **)(a1 + 40), a2, object);
  }

  else
  {
    uint64_t v8 = xpc_get_type(object);
    xpc_type_get_name(v8);
    sub_10001A4D8(v7, 3, "Invalid type for event (event/type): %s/%s", v9, v10, v11, v12, v13, (char)a2);
    *(void *)(*(void *)(a1 + 32) + 1352LL) |= 1uLL;
  }

  return 1LL;
}

double sub_100005904(uint64_t a1)
{
  *(void *)(a1 + 696) = 0x6400000064LL;
  bzero(v7, 0x1090uLL);
  uint64_t v2 = *(const char **)(a1 + 776);
  if (!v2)
  {
    uint64_t v3 = *(void *)(a1 + 248);
    if ((*(_BYTE *)(v3 + 96) & 1) != 0)
    {
      goto LABEL_6;
    }
  }

  if (!sub_100017180(v2, *(const char **)(a1 + 784), (uint64_t)v7))
  {
LABEL_6:
    *(void *)(a1 + 696) = v8;
    __int128 v5 = v10;
    *(_OWORD *)(a1 + 704) = v9;
    *(_OWORD *)(a1 + 720) = v5;
    double result = *(double *)&v11;
    __int128 v6 = v12;
    *(_OWORD *)(a1 + 736) = v11;
    *(_OWORD *)(a1 + 752) = v6;
    *(_DWORD *)(a1 + 768) = v13;
  }

  return result;
}

void sub_1000059FC(void *a1, xpc_object_t xdict, _BYTE *a3, int a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "EnablePressuredExit");
  xpc_object_t v9 = xpc_dictionary_get_value(xdict, "EnableTransactions");
  if (xpc_dictionary_get_BOOL(a1, "KeepAlive"))
  {
    if (a4) {
      sub_100039448("XPC bundles can't have KeepAlive, they can't even set it as a plist key, how did we get here?");
    }
    int v10 = 1;
    if (!v9)
    {
      int v11 = 4;
      int v12 = 1;
      goto LABEL_19;
    }

LABEL_18:
    int v12 = xpc_BOOL_get_value(v9);
    int v11 = 0;
LABEL_19:
    int v13 = 0;
    if (!value) {
      goto LABEL_23;
    }
    goto LABEL_20;
  }

  if (value)
  {
    int v10 = 0;
    if (xpc_BOOL_get_value(value))
    {
      int v11 = 3;
      int v12 = 1;
      int v13 = 1;
    }

    else
    {
      if (v9) {
        goto LABEL_18;
      }
      int v13 = 0;
      if (a4) {
        int v11 = 5;
      }
      else {
        int v11 = 4;
      }
      int v12 = 1;
    }

  int v11 = sub_10000C394(v10, (uint64_t)a1, (uint64_t)&unk_100069328 + 32 * v7);
  free(v10);
  return v11;
}

  sub_10001685C(v3);
  return v5;
}

LABEL_23:
    if (v10 == 2) {
      sub_100011A84(a3, 4LL, "Assuming EnablePressuredExit=false given EnableTransactions=false.");
    }
LABEL_25:
    if (!v9) {
      goto LABEL_29;
    }
    goto LABEL_26;
  }

  if (!v9)
  {
    LOBYTE(v13) = 1;
    LOBYTE(v12) = 1;
    goto LABEL_29;
  }

  if (!xpc_BOOL_get_value(v9))
  {
    int v10 = 2;
    goto LABEL_18;
  }

  int v11 = 3;
  LOBYTE(v13) = 1;
  int v12 = 1;
LABEL_26:
  int v15 = xpc_BOOL_get_value(v9);
  if (v11 == 3 && v12 != v15) {
    sub_100011A84( a3,  3LL,  "Service sets EnableTransactions=false and EnablePressuredExit=true, which makes no sense. Enabling Transactions.");
  }
LABEL_29:
  xpc_dictionary_set_BOOL(xdict, "EnablePressuredExit", v13);
  xpc_dictionary_set_BOOL(xdict, "EnableTransactions", v12);
}

        uint64_t v19 = sub_10000D6C0(v17, fts_path, fts_errno);
        if (v19)
        {
          sub_10000E4D8(v7, v19);
          sub_10001685C(v19);
        }

        goto LABEL_25;
      }

    int v17 = v15;
    if (!v15) {
      return 148LL;
    }
LABEL_28:
    LODWORD(v6) = *(unsigned __int8 *)(a1 + 56);
    if ((v6 - 1) >= 2)
    {
      if (*(_BYTE *)(a1 + 56)) {
        goto LABEL_36;
      }
      uint64_t v21 = (uint64_t *)(a1 + 88);
    }

    else
    {
      uint64_t v21 = (uint64_t *)(a1 + 80);
    }

    _BYTE *v21 = v17;
    *(_BYTE *)(a1 + 264) |= 1u;
    *(_DWORD *)(a1 + 240) = 0;
    uint64_t v22 = unk_100069480;
    *(_OWORD *)(a1 + 128) = xmmword_100069470;
    *(_OWORD *)(a1 + 144) = v22;
    uint64_t v23 = unk_100069460;
    *(_OWORD *)(a1 + 96) = xmmword_100069450;
    *(_OWORD *)(a1 + 112) = v23;
    uint64_t v24 = unk_1000694A0;
    *(_OWORD *)(a1 + 160) = xmmword_100069490;
    *(_OWORD *)(a1 + 176) = v24;
    uint64_t v25 = unk_1000694C0;
    *(_OWORD *)(a1 + 192) = xmmword_1000694B0;
    *(_OWORD *)(a1 + 208) = v25;
    *(_OWORD *)(a1 + 224) = xmmword_1000694D0;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
    (*(void (**)(void))(*(void *)(a1 + 256) + 16LL))();
    return 0LL;
  }

  if (v2 == 2)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s", *(const char **)(a1 + 64));
    int v14 = strrchr(__str, 47);
    if (v14) {
      *int v14 = 0;
    }
    if (sub_100012984(__str, ".appex"))
    {
      int v13 = __str;
      goto LABEL_14;
    }

    goto LABEL_15;
  }

  if (v2 != 3) {
    goto LABEL_16;
  }
  uint64_t v3 = strlen(*(const char **)(a1 + 64));
  uint64_t v4 = v3 + 2;
  __int128 v5 = v3 >= 0xFFFFFFFFFFFFFFFELL;
  __int128 v6 = v5 << 63 >> 63;
  if (v6 != v5 || v6 < 0)
  {
    __break(1u);
LABEL_36:
    sub_100039448("unsupported cached entry type %d", v6);
  }

  uint64_t v7 = (char *)sub_100010B00(v3 + 2);
  strlcpy(v7, *(const char **)(a1 + 64), v4);
  *(_WORD *)&v7[v4 - 2] = 47;
  uint64_t v8 = sub_10000E454();
  *(void *)__str = _NSConcreteStackBlock;
  uint64_t v27 = 0x40000000LL;
  uint64_t v28 = sub_1000162E0;
  size_t v29 = &unk_100064220;
  __int128 v30 = v7;
  xpc_object_t v31 = v8;
  sub_10003CB60((rb_tree_t **)qword_10006A900, (uint64_t)__str);
  xpc_object_t v9 = unk_100069550;
  *(_OWORD *)(a1 + 192) = xmmword_100069540;
  *(_OWORD *)(a1 + 208) = v9;
  *(_OWORD *)(a1 + 224) = xmmword_100069560;
  int v10 = unk_100069510;
  *(_OWORD *)(a1 + 128) = xmmword_100069500;
  *(_OWORD *)(a1 + 144) = v10;
  int v11 = unk_100069530;
  *(_OWORD *)(a1 + 160) = xmmword_100069520;
  *(_OWORD *)(a1 + 176) = v11;
  int v12 = *(_OWORD *)algn_1000694F0;
  *(_OWORD *)(a1 + 96) = xmmword_1000694E0;
  *(_OWORD *)(a1 + 112) = v12;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
  (*(void (**)(void))(*(void *)(a1 + 256) + 16LL))();
  sub_10001685C(v8);
  free(v7);
  return 0LL;
}

void sub_100005BC0(char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v5 = *a3;
  __int128 v6 = (_BYTE *)a3[1];
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL value = xpc_BOOL_get_value(object);
    int v22 = *a1;
    switch(v22)
    {
      case 'j':
        goto LABEL_14;
      case '_':
        BOOL v36 = value;
        if (!strcmp(a1, "_MultipleInstances"))
        {
          *(_BYTE *)(v5 + 1320) = v36;
          return;
        }

        if (!strcmp(a1, "_JoinGUISession")) {
          return;
        }
        if (!strcmp(a1, "_AbandonCoalition"))
        {
          uint64_t v65 = 0x40000000LL;
          if (!v36) {
            uint64_t v65 = 0LL;
          }
          unint64_t v66 = *(void *)(v5 + 1352) & 0xFFFFFFFFBFFFFFFFLL;
        }

        else
        {
          if (!strcmp(a1, "_OmitSandboxParameters")) {
            return;
          }
          if (strcasecmp(a1, "_HighBitsASLR"))
          {
            if (!strcasecmp(a1, "_ExponentialThrottling"))
            {
              unint64_t v37 = *(void *)(v5 + 1352) & 0xFFF3FFFFFFFFFFFFLL;
              *(_WORD *)(v5 + 1004) = 3;
              uint64_t v38 = 0x8000000000000LL;
              if (v36) {
                uint64_t v38 = 0xC000000000000LL;
              }
              uint64_t v39 = v38 | v37;
              goto LABEL_70;
            }

            break;
          }

          uint64_t v65 = 0x200000000LL;
          if (!v36) {
            uint64_t v65 = 0LL;
          }
          unint64_t v66 = *(void *)(v5 + 1352) & 0xFFFFFFFDFFFFFFFFLL;
        }

        uint64_t v39 = v66 | v65;
        goto LABEL_70;
      case 'J':
LABEL_14:
        if (!strcmp(a1, "JoinExistingSession")) {
          return;
        }
        break;
    }

    sub_10001A4D8(v5, 4, "Unknown key for Boolean: %s", v17, v18, v19, v20, v21, (char)a1);
    goto LABEL_69;
  }

  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    int64_t v23 = xpc_int64_get_value(object);
    int v24 = *a1;
    if (v24 == 80 || v24 == 112)
    {
      if (!strcasecmp(a1, "PersonaEnterprise") || !strcasecmp(a1, "Platform")) {
        return;
      }
    }

    else if (v24 == 95)
    {
      unint64_t v25 = v23;
      if (!strcasecmp(a1, "_VoluntaryExitTimeOut"))
      {
        *(_DWORD *)(v5 + 840) = v25;
        return;
      }

      if (!strcasecmp(a1, "_LaunchWatchdogTimeOut"))
      {
        sub_10001A4D8(v5, 4, "setting launch watchdog timeout to %u secs from overlay", v26, v27, v28, v29, v30, v25);
        *(_DWORD *)(v5 + 844) = v25;
        return;
      }

      if (!strcasecmp(a1, "_ThrottleInterval"))
      {
        if ((v25 & 0x8000000000000000LL) != 0)
        {
          char v83 = (char)a1;
          int v13 = "%s less than zero. Ignoring.";
        }

        else
        {
          if (!HIDWORD(v25))
          {
            if (v25)
            {
              *(_DWORD *)(v5 + 812) = v25;
            }

            else
            {
              sub_10001A4D8( v5,  3,  "_ThrottleInterval set to zero. You're not that important. Ignoring.",  v8,  v9,  v10,  v11,  v12,  v82);
              *(_DWORD *)(v5 + 812) = 1;
            }

            return;
          }

          char v83 = (char)a1;
          int v13 = "%s is too large. Ignoring.";
        }

        uint64_t v14 = v5;
        int v15 = 4;
        goto LABEL_10;
      }
    }

    sub_10001A4D8(v5, 4, "Unknown key for integer: %s", v8, v9, v10, v11, v12, (char)a1);
LABEL_69:
    uint64_t v39 = *(void *)(v5 + 1352) | 1LL;
LABEL_70:
    *(void *)(v5 + 1352) = v39;
    return;
  }

  if (type == (xpc_type_t)&_xpc_type_double)
  {
    xpc_double_get_value(object);
    sub_10001A4D8(v5, 4, "Unknown key for double: %s", v31, v32, v33, v34, v35, (char)a1);
    goto LABEL_69;
  }

  if (type == (xpc_type_t)&_xpc_type_data)
  {
    xpc_data_get_bytes_ptr(object);
    xpc_data_get_length(object);
    sub_10001A4D8(v5, 4, "Unknown key for data: %s", v40, v41, v42, v43, v44, (char)a1);
    goto LABEL_69;
  }

  if (type == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    int v51 = *a1;
    if (v51 <= 94)
    {
      if (v51 == 82) {
        goto LABEL_60;
      }
      if (v51 == 83)
      {
LABEL_54:
        unint64_t v58 = "ServiceType";
        goto LABEL_61;
      }
    }

    else
    {
      if (v51 != 95)
      {
        if (v51 != 114)
        {
          if (v51 != 115) {
            goto LABEL_62;
          }
          goto LABEL_54;
        }

LABEL_60:
        unint64_t v58 = "RunLoopType";
LABEL_61:
        if (sub_1000129FC(a1, v58)) {
          return;
        }
        goto LABEL_62;
      }

      uint64_t v67 = (char *)string_ptr;
      if (sub_100012A34(a1, "_RoleAccount"))
      {
        if (sub_1000129FC(v67, "root"))
        {
          uint64_t v39 = *(void *)(v5 + 1352) | 0x80000LL;
          goto LABEL_70;
        }

        int v73 = (char **)(v5 + 776);
LABEL_96:
        *(void *)(v5 + 592) += strlen(v67) + 1;
        char v74 = j__strdup(v67);
        *int v73 = v74;
        if (!v74)
        {
          sub_10001A4D8(v5, 3, "Could not set string argument for key: %s", v75, v76, v77, v78, v79, (char)a1);
          goto LABEL_69;
        }

        return;
      }

      if (sub_100012A34(a1, "_SandboxProfile"))
      {
        sub_100004504(v5, v67);
        return;
      }

      if (sub_100012A34(a1, "_SandboxContainer"))
      {
        int v73 = (char **)(v5 + 472);
        goto LABEL_96;
      }

      if (sub_100012A34(a1, "_ProcessType")) {
        return;
      }
      if (sub_1000129FC(a1, "_Cryptex"))
      {
        sub_100005604(v5, v67);
        uint64_t v39 = *(void *)(v5 + 1352) | 0x800000000000000LL;
        goto LABEL_70;
      }

      if (sub_1000129FC(a1, "_ManagedBy"))
      {
        xpc_object_t v81 = xpc_string_create(v67);
        sub_1000386C8(v5, v81);
        xpc_release(v81);
        return;
      }

      if (sub_1000129FC(a1, "_Conclave"))
      {
        sub_1000064CC(v5, v67);
        return;
      }
    }

LABEL_62:
    sub_10001A4D8(v5, 4, "Unknown key for string: %s", v46, v47, v48, v49, v50, (char)a1);
    goto LABEL_69;
  }

  if (type != (xpc_type_t)&_xpc_type_array)
  {
    if (type != (xpc_type_t)&_xpc_type_dictionary)
    {
      char v83 = (char)a1;
      xpc_type_get_name(type);
      int v13 = "Invalid type for service dictionary (key/type): %s/%s";
LABEL_9:
      uint64_t v14 = v5;
      int v15 = 3;
LABEL_10:
      sub_10001A4D8(v14, v15, v13, v8, v9, v10, v11, v12, v83);
      return;
    }

    __darwin_ct_rune_t v59 = __tolower(*a1);
    if (v59 != 95)
    {
      if (v59 == 101 && !strcmp(a1, "EnvironmentVariables"))
      {
        xpc_dictionary_apply_f(object);
        return;
      }

      goto LABEL_58;
    }

    if (!strcmp(a1, "_LaunchEvents"))
    {
      char v83 = (char)a1;
      int v13 = "The %s key is not yet implemented. %s";
      goto LABEL_9;
    }

    if (!strcmp(a1, "_AdditionalServices"))
    {
      sub_10001A4D8(v5, 3, "The %s key is no longer respected. %s", v68, v69, v70, v71, v72, (char)a1);
      v85[0] = _NSConcreteStackBlock;
      v85[1] = 0x40000000LL;
      v85[2] = sub_1000065E0;
      v85[3] = &unk_1000611B8;
      v85[4] = v5;
      v85[5] = v6;
      v80 = v85;
    }

    else
    {
      if (strcmp(a1, "_AdditionalSubServices"))
      {
        if (!strcasecmp(a1, "_AdditionalProperties"))
        {
          *(void *)(v5 + 640) = xpc_retain(object);
          return;
        }

LABEL_58:
        sub_10001A4D8(v5, 4, "Unknown key for dictionary: %s", v60, v61, v62, v63, v64, (char)a1);
        goto LABEL_69;
      }

      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000LL;
      applier[2] = sub_100006600;
      applier[3] = &unk_1000611D8;
      applier[4] = v5;
      void applier[5] = v6;
      v80 = applier;
    }

    xpc_dictionary_apply(object, v80);
    return;
  }

  __darwin_ct_rune_t v52 = __tolower(*a1);
  if (v52 == 112)
  {
    if (sub_1000129FC(a1, "ProgramArguments")) {
      return;
    }
    goto LABEL_68;
  }

  if (v52 != 95)
  {
LABEL_68:
    sub_10001A4D8(v5, 4, "Unknown key for array: %s", v53, v54, v55, v56, v57, (char)a1);
    goto LABEL_69;
  }

  if (!strcmp(a1, "_AdditionalServices"))
  {
    sub_100006544(v5, a1, (uint64_t)&_xpc_BOOL_true, v6);
    return;
  }

  if (strcmp(a1, "_AllowedClients"))
  {
    if (!strcmp(a1, "_ManagedBy"))
    {
      sub_1000386C8(v5, object);
      return;
    }

    if (!strcmp(a1, "_ManagedBy_Services"))
    {
      sub_1000387D4(v5, object);
      return;
    }

    goto LABEL_68;
  }

  if ((v37 & 0xFE) != 4 || (v4 - 107) > 0x15 || ((1 << (v4 - 107)) & 0x200005) == 0)
  {
LABEL_62:
    if (!(_DWORD)v4) {
      return;
    }
    goto LABEL_63;
  }

  LODWORD(v4) = 121;
LABEL_63:
  sub_100015500(a1, *(const char **)(a2 + 16), v4);
}

void sub_100006360(uint64_t a1, xpc_object_t xdict)
{
  if ((*(void *)(a1 + 1352) & 0x400000000LL) != 0) {
    int v4 = 1024;
  }
  else {
    int v4 = 1536;
  }
  string = xpc_dictionary_get_string(xdict, "RunLoopType");
  if (string && !strcmp(string, "_UIApplicationMain")) {
    int v4 = 256;
  }
  *(_DWORD *)(a1 + 872) = v4;
  __int128 v6 = (char *)xpc_dictionary_get_string(xdict, "_ProcessType");
  if (v6) {
    sub_100003444(a1, v6);
  }
}

void sub_1000063F8( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x400) != 0)
  {
    char v8 = 3;
  }

  else if ((a2 & 0x800) != 0)
  {
    char v8 = 1;
  }

  else if ((a2 & 0x1000) != 0)
  {
    char v8 = 2;
  }

  else if ((a2 & 0x40) != 0)
  {
    char v8 = 6;
  }

  else if ((*(_BYTE *)(a1 + 1352) & 2) != 0)
  {
    char v8 = 5;
  }

  else if ((a2 & 0x40000) != 0)
  {
    char v8 = 7;
  }

  else
  {
    if ((a2 & 0x200) == 0)
    {
      sub_10001A4D8(a1, 3, "Unknown service type. flags: %llx", a4, a5, a6, a7, a8, a2);
      return;
    }

    char v8 = 4;
  }

  *(_BYTE *)(a1 + 356) = v8;
}

uint64_t sub_100006480(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 872);
  if (v1 == 256)
  {
    uint64_t v3 = *(void *)(result + 1352);
    *(void *)(result + 1352) = v3 | 0x2000000;
    if ((v3 & 0x1000000000000000LL) != 0) {
      return result;
    }
    *(_DWORD *)(result + 876) = 1;
    uint64_t v2 = v3 | 0x1000000002000000LL;
  }

  else
  {
    if (v1 != 1792) {
      return result;
    }
    uint64_t v2 = *(void *)(result + 1352) | 0x80000000000000LL;
  }

  *(void *)(result + 1352) = v2;
  return result;
}

void sub_1000064CC(uint64_t a1, char *__s)
{
  if (strlen(__s) < 0x80)
  {
    uint64_t v9 = *(void **)(a1 + 1344);
    if (v9)
    {
      free(v9);
      *(void *)(a1 + 1344) = 0LL;
    }

    *(void *)(a1 + 1344) = sub_1000126A0(__s);
  }

  else
  {
    sub_10001A4D8(a1, 3, "%s failed: conclave id too long", v4, v5, v6, v7, v8, (char)"_launch_service_set_conclave");
  }

void sub_100006544(uint64_t a1, char *__s1, uint64_t a3, _BYTE *a4)
{
  if ((*(_BYTE *)(a1 + 1356) & 0x40) != 0 && !strcmp(__s1, (const char *)(a1 + 1360)))
  {
    sub_100011A84(a4, 4LL, "MachService endpoint name specified was same as implicitly created endpoint: %s", __s1);
  }

  else if ((*(uint64_t (**)(uint64_t, char *, uint64_t, void, _BYTE *, void))(a1 + 544))( a1,  __s1,  a3,  0LL,  a4,  *(void *)(a1 + 568)))
  {
    return;
  }

  *(void *)(a1 + 1352) |= 1uLL;
}

uint64_t sub_1000065E0(uint64_t a1, char *a2, uint64_t a3)
{
  return 1LL;
}

uint64_t sub_100006600(uint64_t a1, const char *a2, uint64_t a3)
{
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  uint64_t v5 = (const char *)(*(void *)(a1 + 32) + 1360LL);
  *(_OWORD *)__str = 0u;
  __int128 v8 = 0u;
  snprintf(__str, 0x200uLL, "%s.%s", v5, a2);
  sub_100006544(*(void *)(a1 + 32), __str, a3, *(_BYTE **)(a1 + 40));
  return 1LL;
}

uint64_t sub_1000066D4(void *a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000LL;
  char v7 = 0;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000LL;
  applier[2] = sub_1000072A8;
  applier[3] = &unk_100061200;
  applier[4] = &v4;
  xpc_dictionary_apply(a1, applier);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

size_t sub_10000675C(void *a1)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v4 = 0LL;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v4);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string && (sub_10000675C(value) & 1) != 0) {
          break;
        }
        if (++v4 >= xpc_array_get_count(a1)) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return os_variant_check("com.apple.xpc.launchd", string_ptr);
  }

  else
  {
    return 0LL;
  }

  return result;
}

size_t sub_100006830(void *a1)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v4 = 0LL;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v4);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string && (sub_100006830(value) & 1) != 0) {
          break;
        }
        if (++v4 >= xpc_array_get_count(a1)) {
          return 0LL;
        }
      }

      return 1LL;
    }
  }

  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = (char *)xpc_string_get_string_ptr(a1);
    return sub_100001F80(string_ptr);
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t sub_1000068F8()
{
  uint64_t result = j___os_feature_enabled_impl("Accessibility", "ClarityUI");
  if ((_DWORD)result) {
    return sub_100036F2C("/var/mobile/Library/Accessibility/ClarityBoardEnabled");
  }
  return result;
}

size_t sub_100006930(void *a1, _BYTE *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_10003934C((BOOL)string_ptr);
  }

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v6 = 0LL;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v6);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
        {
          __int128 v8 = xpc_string_get_string_ptr(value);
          if (sub_10003934C((BOOL)v8)) {
            return 1LL;
          }
        }

        else
        {
          sub_100011A84(a2, 4LL, "Unsupported type for index %lu of _LimitLoadToDeviceTree", v6);
        }

        if (++v6 >= xpc_array_get_count(a1)) {
          return 0LL;
        }
      }
    }
  }

  else
  {
    sub_100011A84(a2, 4LL, "Unsupported type for _LimitLoadToDeviceTree");
    return 0LL;
  }

  return result;
}

size_t sub_100006A48(void *a1, _BYTE *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_10004083C((uint64_t)string_ptr);
  }

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v6 = 0LL;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v6);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
        {
          if ((sub_100006A48(value, a2) & 1) != 0) {
            return 1LL;
          }
        }

        else
        {
          sub_100011A84(a2, 4LL, "Unsupported type for index: %lu of _LimitLoadToBootarg", v6);
        }

        if (++v6 >= xpc_array_get_count(a1)) {
          return 0LL;
        }
      }
    }
  }

  else
  {
    sub_100011A84(a2, 4LL, "Unsupported type for _LimitLoadToBootarg");
    return 0LL;
  }

  return result;
}

char *sub_100006B60( void *a1, const char *a2, uint64_t a3, unint64_t a4, uint64_t a5, int *a6, _BYTE *a7)
{
  string = xpc_dictionary_get_string(a1, "Label");
  if (!string) {
    sub_100046EB4();
  }
  __int128 v15 = (char *)string;
  __int128 v16 = xpc_dictionary_get_string(a1, "Program");
  if (v16)
  {
    __int128 v17 = v16;
    uint64_t v63 = a5;
    if (*v16 == 47)
    {
LABEL_4:
      uint64_t v64 = a2;
      xpc_object_t value = xpc_dictionary_get_value(a1, "ProgramArguments");
      uint64_t v19 = 0LL;
      goto LABEL_5;
    }

    BOOL v29 = xpc_dictionary_get_BOOL(a1, "ResolveProgramIdentifier");
    __int128 v30 = (char *)xpc_dictionary_get_string(a1, "BundleProgram");
    if (v29 || v30)
    {
      if (!v30 || sub_1000129FC(v30, v17)) {
        goto LABEL_4;
      }
      sub_100011A84(a7, 3LL, "BundleProgram(%s) is not the same as Program(%s). Bug in ServiceManagement?");
    }

    else
    {
      sub_100011A84(a7, 3LL, "Service specifies non-absolute Program path.");
    }

LABEL_56:
    __int128 v37 = 0LL;
    int v38 = 111;
LABEL_57:
    *a6 = v38;
    return v37;
  }

  uint64_t v64 = a2;
  xpc_object_t v28 = xpc_dictionary_get_value(a1, "ProgramArguments");
  if (!v28 || (xpc_object_t value = v28, xpc_get_type(v28) != (xpc_type_t)&_xpc_type_array))
  {
    sub_100011A84(a7, 3LL, "Service specifies neither Program nor ProgramArguments.");
    goto LABEL_56;
  }

  if (!xpc_array_get_count(value))
  {
    sub_100011A84(a7, 3LL, "Service specifies no Program and empty ProgramArguments.");
    goto LABEL_56;
  }

  __int128 v32 = xpc_array_get_string(value, 0LL);
  if (!v32)
  {
    sub_100011A84(a7, 3LL, "Service does not specify a valid argument array.");
    goto LABEL_56;
  }

  __int128 v17 = v32;
  uint64_t v63 = a5;
  uint64_t v19 = 0x1000000LL;
LABEL_5:
  xpc_object_t v20 = xpc_dictionary_get_value(a1, "ProcessType");
  if (v20) {
    xpc_dictionary_set_value(a1, "POSIXSpawnType", v20);
  }
  if ((a4 & 0x400) != 0) {
    xpc_dictionary_set_BOOL(a1, "__Angel", 1);
  }
  __int128 v21 = (char *)xpc_dictionary_get_string(a1, "POSIXSpawnType");
  if (sub_1000129FC(v21, "Driver") && (sub_10000D114(a3, 24LL) & 1) == 0)
  {
    if (a3) {
      int v31 = *(_DWORD *)(a3 + 20);
    }
    else {
      int v31 = 0;
    }
    sub_100011A84(a7, 3LL, "Service (pid %d) does not have spawn driver entitlement", v31);
    __int128 v37 = 0LL;
    int v38 = 144;
    goto LABEL_57;
  }

  uint64_t v60 = v19;
  if ((a4 & 0x200) == 0 && xpc_dictionary_get_string(a1, "_JetsamPropertiesIdentifier"))
  {
    sub_100011A84(a7, 3LL, "Ignoring _JetsamPropertiesIdentifier on a service which isn't submitted");
    xpc_dictionary_set_value(a1, "_JetsamPropertiesIdentifier", 0LL);
  }

  xpc_object_t v22 = sub_10000C16C(a1);
  sub_10000BB08(v22, a7);
  sub_1000059FC(a1, v22, a7, 0);
  xpc_object_t v23 = xpc_dictionary_get_value(v22, "ExecuteAllowed");
  if (v23)
  {
    __int128 v24 = v23;
    if (xpc_get_type(v23) == (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL v33 = xpc_BOOL_get_value(v24);
      if ((a4 & 0x200) == 0 && !v33)
      {
        int v34 = 157;
LABEL_40:
        *a6 = v34;
        xpc_release(v22);
        return 0LL;
      }
    }
  }

  xpc_object_t v25 = xpc_dictionary_get_value(a1, "_StandardInFd");
  if (v25 && (__int128 v26 = v25, xpc_get_type(v25) == (xpc_type_t)&_xpc_type_fd)) {
    int v27 = xpc_fd_dup(v26);
  }
  else {
    int v27 = -1;
  }
  if (xpc_dictionary_get_string(a1, "StandardInPath") && v27 != -1)
  {
    close(v27);
    sub_100011A84(a7, 3LL, "Service specifies both standard out file descriptor and path.");
    int v34 = 111;
    goto LABEL_40;
  }

  int v62 = v27;
  xpc_object_t v35 = xpc_dictionary_get_value(a1, "_StandardOutFd");
  if (v35 && (__int128 v36 = v35, xpc_get_type(v35) == (xpc_type_t)&_xpc_type_fd)) {
    int v61 = xpc_fd_dup(v36);
  }
  else {
    int v61 = -1;
  }
  if (xpc_dictionary_get_string(a1, "StandardOutPath") && v61 != -1)
  {
    close(v61);
    sub_100011A84(a7, 3LL, "Service specifies both standard out file descriptor and path.");
    *a6 = 111;
    xpc_release(v22);
    if (v62 == -1) {
      return 0LL;
    }
    int v39 = v62;
LABEL_75:
    close(v39);
    return 0LL;
  }

  xpc_object_t v40 = xpc_dictionary_get_value(a1, "_StandardErrorFd");
  if (v40 && (uint64_t v41 = v40, xpc_get_type(v40) == (xpc_type_t)&_xpc_type_fd)) {
    int v59 = xpc_fd_dup(v41);
  }
  else {
    int v59 = -1;
  }
  if (xpc_dictionary_get_string(a1, "StandardErrorPath") && v59 != -1)
  {
    close(v59);
    sub_100011A84(a7, 3LL, "Service specifies both standard out file descriptor and path.");
    *a6 = 111;
    xpc_release(v22);
    if (v62 != -1) {
      close(v62);
    }
    int v39 = v61;
    goto LABEL_74;
  }

  uint64_t v42 = sub_100019F7C((uint64_t)v15, v17, v64);
  __int128 v37 = sub_100005228(v42, (_OWORD *)a3, v15, value, v63, a4, a6, a7);
  sub_10001685C(v42);
  if (!v37)
  {
    xpc_release(v22);
    if (v62 != -1) {
      close(v62);
    }
    if (v61 != -1) {
      close(v61);
    }
    int v39 = v59;
LABEL_74:
    if (v39 == -1) {
      return 0LL;
    }
    goto LABEL_75;
  }

  int v43 = sub_10000D114(a3, 3LL);
  uint64_t v44 = *((void *)v37 + 169);
  if (v43) {
    v44 |= 0x8000000000uLL;
  }
  *((void *)v37 + 169) = v44 & 0xFFFFFFFFFEFFFFFFLL | v60;
  xpc_object_t v45 = sub_10001675C(v37, 1LL, (uint64_t)a7, 0LL);
  xpc_dictionary_apply_f(a1);
  sub_100016828(v45);
  sub_10000BC6C((uint64_t)v37, v22, (uint64_t)a7);
  nullsub_23(v37, v22);
  xpc_release(v22);
  uint64_t v52 = *((void *)v37 + 169);
  if ((v52 & 0x80000000) != 0)
  {
    int v53 = v61;
    int v54 = v59;
    if (!*((void *)v37 + 97))
    {
      v52 &= ~0x80000000uLL;
      *((void *)v37 + 169) = v52;
    }
  }

  else
  {
    int v53 = v61;
    int v54 = v59;
  }

  uint64_t v56 = v52 & 0x20000 | a4 & 0x10;
  if (v56) {
    v52 |= 0x200000uLL;
  }
  unint64_t v57 = v52 & 0x20000000;
  unint64_t v58 = v52 | (v57 >> 7);
  if (v56 | v57) {
    *((void *)v37 + 169) = v58;
  }
  if (((v57 == 0) & ~v43) == 0 && *((_DWORD *)v37 + 218) != 1792)
  {
    *((_DWORD *)v37 + 218) = 256;
    if (v57) {
      *((_DWORD *)v37 + 224) = 160;
    }
    *((void *)v37 + 169) = v58 & 0xFFFFFFFFFFFFECFFLL | 0x1000;
  }

  if (v62 != -1) {
    *((_DWORD *)v37 + 166) = v62;
  }
  if (v53 != -1) {
    *((_DWORD *)v37 + 167) = v53;
  }
  if (v54 != -1) {
    *((_DWORD *)v37 + 168) = v54;
  }
  sub_1000063F8((uint64_t)v37, a4, v46, v47, v48, v49, v50, v51);
  if ((v37[1359] & 2) != 0) {
    sub_1000208C4((uint64_t)v37, 15);
  }
  sub_100006480((uint64_t)v37);
  return v37;
}

void sub_100007244( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a1 + 1355) & 0x20) != 0)
  {
    uint64_t v9 = *(void *)(a2 + 64);
    if (v9)
    {
      sub_10001A4D8(a1, 3, "Service tried to claim home screen from: %s", a4, a5, a6, a7, a8, v9 + 80);
      *(void *)(a1 + 1352) &= ~0x20000000uLL;
    }

    else
    {
      *(void *)(a2 + 64) = a1;
    }
  }

uint64_t sub_1000072A8(uint64_t a1, const char *a2, void *a3)
{
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v9 = 0u;
  snprintf(__str, 0x80uLL, "hw.%s", a2);
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(a3))
    {
      size_t v6 = 0LL;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a3, v6);
        if ((sub_1000073B4(__str, value) & 1) != 0) {
          break;
        }
        if (++v6 >= xpc_array_get_count(a3)) {
          return 1LL;
        }
      }

      goto LABEL_3;
    }
  }

  else if (sub_1000073B4(__str, a3))
  {
LABEL_3:
    uint64_t result = 0LL;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return result;
  }

  return 1LL;
}

size_t sub_1000073B4(const char *a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_string)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_int64)
    {
      __s2[0] = 0LL;
      if (sub_100039C44(a1, __s2))
      {
        xpc_object_t value = (char *)xpc_int64_get_value(object);
        return value == __s2[0];
      }
    }

    else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
    {
      __s2[0] = 0LL;
      __s2[1] = 0LL;
      size_t v13 = 16LL;
      int v4 = sysctlbyname(a1, __s2, &v13, 0LL, 0LL);
      size_t v5 = 0LL;
      if (v4 != -1 && v13)
      {
        BOOL v6 = xpc_BOOL_get_value(object);
        BOOL v8 = v13 < 9 && __s2[0] == 0LL;
        return v6 ^ v8;
      }

      return v5;
    }

    return 0LL;
  }

  __s2[0] = 0LL;
  size_t v5 = sub_100039AB8(a1, __s2);
  if (v5)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    __int128 v10 = __s2[0];
    size_t v5 = strncmp(string_ptr, __s2[0], v5) == 0;
    free(v10);
  }

  return v5;
}

uint64_t sub_100007524(const char *a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = a2;
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  char v7 = (uint64_t *)qword_100069B40;
  if (!qword_100069B40)
  {
    qword_100069B40 = (uint64_t)sub_10000B004("plist");
    sub_10000B0B0(qword_100069B40, "AbandonProcessGroup", (char *)&stru_100061240);
    sub_10000B0B0(qword_100069B40, "AuxiliaryBootstrapper", (char *)&stru_100061280);
    sub_10000B0B0(qword_100069B40, "AuxiliaryBootstrapperAllowDemand", (char *)&stru_1000612C0);
    sub_10000B0B0(qword_100069B40, "BootShell", (char *)&stru_100061300);
    sub_10000B0B0(qword_100069B40, "DisabledInSafeBoot", (char *)&stru_100061340);
    sub_10000B0B0(qword_100069B40, "KeepAlive", (char *)&stru_100061380);
    sub_10000B0B0(qword_100069B40, "OnDemand", (char *)&stru_1000613C0);
    sub_10000B0B0(qword_100069B40, "Debug", (char *)&stru_100061400);
    sub_10000B2D0(qword_100069B40, "Disabled");
    sub_10000B0B0(qword_100069B40, "DisableASLR", (char *)&stru_100061440);
    sub_10000B0B0(qword_100069B40, "DisallowAllLookups", (char *)&stru_100061480);
    sub_10000B0B0(qword_100069B40, "DrainMessagesOnFailedInit", (char *)&stru_1000614C0);
    sub_10000B0B0(qword_100069B40, "DisableReslide", (char *)&stru_100061500);
    sub_10000B0B0(qword_100069B40, "HopefullyExitsLast", (char *)&stru_100061540);
    sub_10000B0B0(qword_100069B40, "SessionCreate", (char *)&stru_100061580);
    sub_10000B0B0(qword_100069B40, "StartOnMount", (char *)&stru_1000615C0);
    sub_10000B0B0(qword_100069B40, "ServiceIPC", (char *)&stru_100061600);
    sub_10000B0B0(qword_100069B40, "ShutdownMonitor", (char *)&stru_100061640);
    sub_10000B0B0(qword_100069B40, "LowPriorityIO", (char *)&stru_100061680);
    sub_10000B0B0(qword_100069B40, "LowPriorityBackgroundIO", (char *)&stru_1000616C0);
    sub_10000B0B0(qword_100069B40, "LegacyTimers", (char *)&stru_100061700);
    sub_10000B0B0(qword_100069B40, "LaunchOnlyOnce", (char *)&stru_100061740);
    sub_10000B0B0(qword_100069B40, "MachExceptionHandler", (char *)&stru_100061780);
    sub_10000B0B0(qword_100069B40, "MultipleInstances", (char *)&stru_1000617C0);
    sub_10000B0B0(qword_100069B40, "MaterializeDatalessFiles", (char *)&stru_100061800);
    sub_10000B2D0(qword_100069B40, "MinimalBootProfile");
    sub_10000B0B0(qword_100069B40, "InitGroups", (char *)&stru_100061840);
    sub_10000B0B0(qword_100069B40, "IgnoreProcessGroupAtShutdown", (char *)&stru_100061880);
    sub_10000B0B0(qword_100069B40, "RunAtLoad", (char *)&stru_1000618C0);
    sub_10000B0B0(qword_100069B40, "ResolveProgramIdentifier", (char *)&stru_100061900);
    sub_10000B1B0(qword_100069B40, "BundleProgram", (char *)&stru_100061940);
    sub_10000B0B0(qword_100069B40, "ReslideSharedCache", (char *)&stru_100061980);
    sub_10000B0B0(qword_100069B40, "EnableGlobbing", (char *)&stru_1000619C0);
    sub_10000B0B0(qword_100069B40, "EnableTransactions", (char *)&stru_100061A00);
    sub_10000B0B0(qword_100069B40, "EnterKernelDebuggerBeforeKill", (char *)&stru_100061A40);
    sub_10000B0B0(qword_100069B40, "EmbeddedHomeScreen", (char *)&stru_100061A80);
    sub_10000B0B0(qword_100069B40, "EventMonitor", (char *)&stru_100061AC0);
    sub_10000B0B0(qword_100069B40, "_InitialSystemSupport", (char *)&stru_100061B00);
    sub_10000B0B0(qword_100069B40, "EnablePressuredExit", (char *)&stru_100061B40);
    sub_10000B2D0(qword_100069B40, "ExecuteAllowed");
    sub_10000B0B0(qword_100069B40, "WaitForDebugger", (char *)&stru_100061B80);
    sub_10000B2D0(qword_100069B40, "ForceEnableHack");
    sub_10000B0B0(qword_100069B40, "NSBuiltWithThreadSanitizer", (char *)&stru_100061BC0);
    sub_10000B0B0(qword_100069B40, "_NullBootstrapPort", (char *)&stru_100061C00);
    sub_10000B2D0(qword_100069B40, "_Protected");
    sub_10000B0B0(qword_100069B40, "_ExponentialThrottling", (char *)&stru_100061C40);
    sub_10000B2D0(qword_100069B40, "__Proxyless");
    sub_10000B0B0(qword_100069B40, "_DisablePointerAuth", (char *)&stru_100061C80);
    sub_10000B168(qword_100069B40, "ExitTimeOut", (char *)&stru_100061CC0);
    sub_10000B168(qword_100069B40, "EmbeddedMainThreadPriority", (char *)&stru_100061D00);
    sub_10000B168(qword_100069B40, "CPUMonitorPercentage", (char *)&stru_100061D40);
    sub_10000B168(qword_100069B40, "CPUMonitorInterval", (char *)&stru_100061D80);
    sub_10000B168(qword_100069B40, "PersonaEnterprise", (char *)&stru_100061DC0);
    sub_10000B168(qword_100069B40, "Platform", (char *)&stru_100061E00);
    sub_10000B168(qword_100069B40, "JetsamPriority", (char *)&stru_100061E40);
    sub_10000B168(qword_100069B40, "JetsamMemoryLimit", (char *)&stru_100061E80);
    sub_10000B168(qword_100069B40, "Nice", (char *)&stru_100061EC0);
    sub_10000B168(qword_100069B40, "TimeOut", (char *)&stru_100061F00);
    sub_10000B168(qword_100069B40, "ThrottleInterval", (char *)&stru_100061F40);
    sub_10000B168(qword_100069B40, "Umask", (char *)&stru_100061F80);
    sub_10000B1B0(qword_100069B40, "Umask", (char *)&stru_100061FC0);
    sub_10000B168(qword_100069B40, "StartInterval", (char *)&stru_100062000);
    sub_10000B168(qword_100069B40, "SandboxFlags", (char *)&stru_100062040);
    sub_10000B2D0(qword_100069B40, "ActiveHardMemoryLimit");
    sub_10000B2D0(qword_100069B40, "ActiveSoftMemoryLimit");
    sub_10000B2D0(qword_100069B40, "InactiveHardMemoryLimit");
    sub_10000B2D0(qword_100069B40, "InactiveSoftMemoryLimit");
    sub_10000B168(qword_100069B40, "InitialTaskRole", (char *)&stru_100062080);
    sub_10000B1B0(qword_100069B40, "CFBundleIdentifier", (char *)&stru_1000620C0);
    sub_10000B1B0(qword_100069B40, "ContainingBundleID", (char *)&stru_100062100);
    sub_10000B288(qword_100069B40, "_BTMItemUUID", (char *)&stru_100062140);
    sub_10000B288(qword_100069B40, "_LightweightCodeRequirement", (char *)&stru_100062180);
    sub_10000B288(qword_100069B40, "_ProvenanceData", (char *)&stru_1000621C0);
    sub_10000B1B0(qword_100069B40, "ContainingBundleVersion", (char *)&stru_100062200);
    sub_10000B1B0(qword_100069B40, "MachExceptionHandler", (char *)&stru_100062240);
    sub_10000B1B0(qword_100069B40, "MultipleInstances", (char *)&stru_100062280);
    sub_10000B2D0(qword_100069B40, "Program");
    sub_10000B1B0(qword_100069B40, "POSIXSpawnType", (char *)&stru_1000622C0);
    sub_10000B1B0(qword_100069B40, "ProcessType", (char *)&stru_1000622C0);
    sub_10000B1B0(qword_100069B40, "PublishesEvents", (char *)&stru_100062300);
    sub_10000B2D0(qword_100069B40, "Label");
    sub_10000B1B0(qword_100069B40, "LimitLoadToHosts", (char *)&stru_100062340);
    sub_10000B1B0(qword_100069B40, "LimitLoadFromHosts", (char *)&stru_100062380);
    sub_10000B2D0(qword_100069B40, "LimitLoadToSessionType");
    sub_10000B1B0(qword_100069B40, "LoginWindowUserName", (char *)&stru_1000623C0);
    sub_10000B1B0(qword_100069B40, "RootDirectory", (char *)&stru_100062400);
    sub_10000B1B0(qword_100069B40, "WorkingDirectory", (char *)&stru_100062440);
    sub_10000B1B0(qword_100069B40, "UserName", (char *)&stru_100062480);
    sub_10000B1B0(qword_100069B40, "GroupName", (char *)&stru_1000624C0);
    sub_10000B1B0(qword_100069B40, "StandardOutPath", (char *)&stru_100062500);
    sub_10000B1B0(qword_100069B40, "StandardErrorPath", (char *)&stru_100062540);
    sub_10000B1B0(qword_100069B40, "StandardInPath", (char *)&stru_100062580);
    sub_10000B1B0(qword_100069B40, "SandboxProfile", (char *)&stru_1000625C0);
    sub_10000B1B0(qword_100069B40, "SandboxContainer", (char *)&stru_100062600);
    sub_10000B2D0(qword_100069B40, "_LimitLoadToDeviceTree");
    sub_10000B2D0(qword_100069B40, "_LimitLoadFromDeviceTree");
    sub_10000B2D0(qword_100069B40, "_LimitLoadToVariant");
    sub_10000B2D0(qword_100069B40, "_LimitLoadFromVariant");
    sub_10000B1B0(qword_100069B40, "_ResourceCoalition", (char *)&stru_100062640);
    sub_10000B2D0(qword_100069B40, "_LimitLoadToBootMode");
    sub_10000B2D0(qword_100069B40, "_LimitLoadFromBootMode");
    sub_10000B2D0(qword_100069B40, "_LimitLoadToClarityMode");
    sub_10000B2D0(qword_100069B40, "_LimitLoadFromClarityMode");
    sub_10000B2D0(qword_100069B40, "_LimitLoadToBootarg");
    sub_10000B2D0(qword_100069B40, "_LimitLoadFromBootarg");
    sub_10000B1B0(qword_100069B40, "_ManagedBy", (char *)&stru_100062680);
    sub_10000B1F8(qword_100069B40, "_ManagedBy", (char *)&stru_1000626C0);
    sub_10000B1F8(qword_100069B40, "_ManagedBy_Services", (char *)&stru_100062700);
    sub_10000B1B0(qword_100069B40, "_SubsystemRoot", (char *)&stru_100062740);
    sub_10000B2D0(qword_100069B40, "ProgramArguments");
    sub_10000B1F8(qword_100069B40, "PublishesEvents", (char *)&stru_100062780);
    sub_10000B1F8(qword_100069B40, "LimitLoadToHosts", (char *)&stru_1000627E0);
    sub_10000B1F8(qword_100069B40, "LimitLoadFromHosts", (char *)&stru_100062820);
    sub_10000B2D0(qword_100069B40, "LimitLoadToSessionType");
    sub_10000B1F8(qword_100069B40, "BinaryOrderPreference", (char *)&stru_100062860);
    sub_10000B1F8(qword_100069B40, "StartCalendarInterval", (char *)&stru_1000628A0);
    sub_10000B1F8(qword_100069B40, "QueueDirectories", (char *)&stru_1000628E0);
    sub_10000B1F8(qword_100069B40, "WatchPaths", (char *)&stru_100062920);
    sub_10000B240(qword_100069B40, "Policies", (char *)&stru_100062960);
    sub_10000B240(qword_100069B40, "PublishesEvents", (char *)&stru_1000629A0);
    sub_10000B240(qword_100069B40, "KeepAlive", (char *)&stru_100062A00);
    sub_10000B240(qword_100069B40, "inetdCompatibility", (char *)&stru_100062A60);
    sub_10000B240(qword_100069B40, "JetsamProperties", (char *)&stru_100062AA0);
    sub_10000B240(qword_100069B40, "EnvironmentVariables", (char *)&stru_100062AE0);
    sub_10000B240(qword_100069B40, "UserEnvironmentVariables", (char *)&stru_100062B20);
    sub_10000B240(qword_100069B40, "Sockets", (char *)&stru_100062B60);
    sub_10000B240(qword_100069B40, "StartCalendarInterval", (char *)&stru_100062BC0);
    sub_10000B240(qword_100069B40, "SoftResourceLimits", (char *)&stru_100062C00);
    sub_10000B240(qword_100069B40, "SandboxFlags", (char *)&stru_100062C40);
    sub_10000B240(qword_100069B40, "HardResourceLimits", (char *)&stru_100062C80);
    sub_10000B240(qword_100069B40, "MachServices", (char *)&stru_100062CC0);
    sub_10000B240(qword_100069B40, "LaunchEvents", (char *)&stru_100062D20);
    sub_10000B2D0(qword_100069B40, "LimitLoadToHardware");
    sub_10000B2D0(qword_100069B40, "LimitLoadFromHardware");
    sub_10000B240(qword_100069B40, "Datastores", (char *)&stru_100062D80);
    sub_10000B240(qword_100069B40, "RemoteServices", (char *)&stru_100062DE0);
    sub_10000B240(qword_100069B40, "_AdditionalProperties", (char *)&stru_100062E40);
    sub_10000B288(qword_100069B40, "_DextCheckInPort", (char *)&stru_100062E80);
    sub_10000B0B0(qword_100069B40, "__Angel", (char *)&stru_100062EC0);
    sub_10000B2D0(qword_100069B40, "_StandardInFd");
    sub_10000B2D0(qword_100069B40, "_StandardOutFd");
    sub_10000B2D0(qword_100069B40, "_StandardErrorFd");
    sub_10000B0B0(qword_100069B40, "_PanicOnCrash", (char *)&stru_100062F00);
    sub_10000B240(qword_100069B40, "_PanicOnCrash", (char *)&stru_100062F40);
    sub_10000B1B0(qword_100069B40, "_Cryptex", (char *)&stru_100062F80);
    sub_10000B1B0(qword_100069B40, "_Conclave", (char *)&stru_100062FC0);
    sub_10000B2D0(qword_100069B40, "AssociatedBundleIdentifiers");
    sub_10000B168(qword_100069B40, "_LaunchType", (char *)&stru_100063000);
    sub_10000B240(qword_100069B40, "SpawnConstraint", (char *)&stru_100063040);
    sub_10000B0B0(qword_100069B40, "_NeedsSystemThreadGroup", (char *)&stru_100063080);
    uint64_t v3 = a2;
    char v7 = (uint64_t *)qword_100069B40;
  }

  uint64_t result = sub_10000B3CC(v7, v5, a1, v3, v6);
  if ((result & 1) == 0) {
    *(void *)(v5 + 1352) |= 1uLL;
  }
  return result;
}

void sub_1000082C8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x10000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFEFFFFLL | v4;
}

void sub_1000082F8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3)
  {
    sub_10001A4D8( (uint64_t)a2,  5,  "This service is defined to be constantly running and is inherently inefficient.",  (uint64_t)a4,  v4,  v5,  v6,  v7,  v9);
    *((void *)&a2->var4 + 122) |= 4uLL;
  }

void sub_100008338(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3)
  {
    sub_10001A4D8((uint64_t)a2, 5, "This key does not do anything: OnDemand", (uint64_t)a4, v4, v5, v6, v7, v10);
  }

  else
  {
    sub_10001A4D8((uint64_t)a2, 5, "Please switch away from OnDemand to KeepAlive.", (uint64_t)a4, v4, v5, v6, v7, v9);
    *((void *)&a2->var4 + 122) |= 4uLL;
  }

void sub_100008394(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_1000083D4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_100008414(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x80000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFF7FFFFFFFFFFLL | v4;
}

void sub_100008434(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x1000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFEFFFFFFFFFLL | v4;
}

void sub_100008454(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x10000000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFEFFFFFFFFFFFFFLL | v4;
}

void sub_100008474(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_1000084BC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_1000084FC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_10000853C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 32LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFFDFLL | v4;
}

void sub_10000855C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 64LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFFBFLL | v4;
}

void sub_100008580(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x100000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFEFFFFFLL | v4;
}

void sub_1000085A0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 128LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFF7FLL | v4;
}

void sub_1000085C0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  a2->var4.var89 = a3;
}

void sub_1000085C8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    unsigned __int8 v4 = 2;
  }
  else {
    unsigned __int8 v4 = 1;
  }
  a2->var4.var86 = v4;
}

void sub_1000085DC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x80000000LL;
  if (a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFF7FFFFFFFLL | v4;
}

void sub_1000085FC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_10000863C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 16LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFFEFLL | v4;
}

void sub_100008664(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  a2->var4.var80.var0 = a3;
}

void sub_10000866C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
}

void sub_1000086B0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 1024LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFBFFLL | v4;
}

void sub_1000086D0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 122) |= 0x20000000uLL;
}

void sub_1000086E0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x20000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFDFFFFLL | v4;
}

void sub_100008700(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x400000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFBFFFFFLL | v4;
}

void sub_100008724(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 2048LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFF7FFLL | v4;
}

void sub_100008744(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x800000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFF7FFFFFFFFFFFLL | v4;
}

void sub_100008764(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x2000000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFDFFFFFFFFFFFFLL | v4;
}

void sub_100008784(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x4000000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFBFFFFFFFFFFFFLL | v4;
  a2->var4.var77 = 3;
}

void sub_1000087AC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v8 = *((void *)&a2->var4 + 122);
  if ((v8 & 0x40000000000LL) != 0)
  {
    uint64_t v9 = 0x40000000000000LL;
    if (!a3) {
      uint64_t v9 = 0LL;
    }
    *((void *)&a2->var4 + 122) = v8 & 0xFFBFFFFFFFFFFFFFLL | v9;
  }

  else
  {
    sub_10001A4D8( (uint64_t)a2,  3,  "%s not permitted to be set on non-submitted jobs",  (uint64_t)a4,  v4,  v5,  v6,  v7,  (char)"_DisablePointerAuth");
  }

void sub_100008808(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  if (a3 < 0)
  {
    sub_10001A4D8((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ExitTimeOut");
  }

  else
  {
    unsigned int v9 = a3;
    if ((unint64_t)a3 >> 31)
    {
      sub_10001A4D8((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ExitTimeOut");
    }

    else
    {
      int v10 = a3 + dword_100069A3C + 2;
      if (dword_100069A44) {
        BOOL v11 = v10 <= dword_100069A44;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11)
      {
        sub_10001A4D8( (uint64_t)a2,  4,  "Service has increased maximum shutdown time to %d seconds. This will create a poor experience for the user.",  (uint64_t)a4,  v4,  v5,  v6,  v7,  a3 + dword_100069A3C + 2);
        dword_100069A44 = v10;
      }

      a2->var4.var41 = v9;
    }
  }

void sub_1000088D8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var85 = a3;
  *((void *)&a2->var4 + 122) |= 0x200000000000uLL;
}

void sub_1000088F0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
}

void sub_100008930(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
}

void sub_100008974(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
}

void sub_1000089B4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  if (a3 < 0)
  {
    sub_10001A4D8((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ThrottleInterval");
  }

  else if (HIDWORD(a3))
  {
    sub_10001A4D8((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ThrottleInterval");
  }

  else if (a3)
  {
    a2->var4.var42 = a3;
  }

  else
  {
    sub_10001A4D8( (uint64_t)a2,  3,  "ThrottleInterval set to zero. You're not that important. Ignoring.",  (uint64_t)a4,  v4,  v5,  v6,  v7,  v9);
    a2->var4.var42 = 1;
  }

void sub_100008A48(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 122) |= (unint64_t)&_mh_execute_header;
  a2->var4.var38 = a3;
}

void sub_100008A5C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  unsigned __int16 v5 = strtoul(a3, 0LL, 0);
  *((void *)&a2->var4 + 122) |= (unint64_t)&_mh_execute_header;
  a2->var4.var38 = v5;
}

void sub_100008A98(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var49 = a3;
}

void sub_100008AA0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
}

void sub_100008AE0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var52 = a3;
  *((void *)&a2->var4 + 122) |= 0x1000000000000000uLL;
}

void sub_100008AF4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var16 = sub_1000126A0(a3);
}

void sub_100008B28(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_data)
  {
    if (!(xpc_data_get_length(a3) >> 32))
    {
      sub_10001C1E4(a2, a3);
      return;
    }

    sub_100011A84(a4, 3LL, "Provenance data too big: %zu");
  }

  else
  {
    xpc_type_t type = xpc_get_type(a3);
    xpc_type_get_name(type);
    sub_100011A84(a4, 3LL, "Invalid type (%s) for _ProvenanceData");
  }

  *((void *)&a2->var4 + 122) |= 1uLL;
}

void sub_100008BE4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var50 = sub_1000126A0(a3);
}

void sub_100008C0C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (sub_1000129FC(a3, "Managed"))
  {
    a2->var4.var89 = 2;
    sub_1000208C4((uint64_t)a2, 16);
  }

  else
  {
    sub_100011A84(a4, 3LL, "Invalid value for MultipleInstances '%s'", a3);
  }

void sub_100008C90(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_100008C9C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v7 = xpc_BOOL_create(1);
  sub_100008CE0((uint64_t)a2, a3, v7, (uint64_t)a4);
}

void sub_100008CE0(uint64_t a1, const char *a2, xpc_object_t object, uint64_t a4)
{
  if (!*(void *)(a1 + 504)) {
    *(void *)(a1 + 504) = xpc_dictionary_create(0LL, 0LL, 0LL);
  }
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (xpc_BOOL_get_value(object)) {
      xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 504), a2, 0LL);
    }
  }

  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v9 = 0LL;
    int v10 = &v9;
    uint64_t v11 = 0x2000000000LL;
    int v12 = 0;
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_10000A654;
    applier[3] = &unk_1000630A8;
    applier[4] = &v9;
    void applier[5] = a4;
    void applier[6] = a1;
    xpc_dictionary_apply(object, applier);
    xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 504), a2, *((unsigned int *)v10 + 6));
    _Block_object_dispose(&v9, 8);
  }

void sub_100008E0C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_100008E4C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_100008E8C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var36 = sub_1000126A0(a3);
  a2->var4.var18 += strlen(a3) + 1;
  *((void *)&a2->var4 + 122) |= 0x20000000000000uLL;
}

void sub_100008EDC(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_100008F1C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000126A0(a3);
  a2->var4.var5 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_100008F58(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (strcmp(a3, "root"))
  {
    a2->var4.var36 = sub_1000126A0(a3);
    a2->var4.var18 += strlen(a3) + 1;
  }

void sub_100008FB0(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (strcmp(a3, "wheel"))
  {
    a2->var4.var37 = sub_1000126A0(a3);
    a2->var4.var18 += strlen(a3) + 1;
  }

void sub_100009008(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000126A0(a3);
  a2->var4.var7 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_100009044(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000126A0(a3);
  a2->var4.var8 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_100009080(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000126A0(a3);
  a2->var4.var6 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_1000090BC(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_1000090C8(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var9 = sub_1000126A0(a3);
  a2->var4.var18 += strlen(a3) + 1;
}

void sub_10000910C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var3.var19 = sub_1000126A0(a3);
}

void sub_100009134(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5 = xpc_string_create(a3);
  sub_1000386C8((uint64_t)a2, v5);
  xpc_release(v5);
}

void sub_10000916C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009178(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009184(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5 = sub_100012884("%s/", a3);
  a2->var4.var11 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_1000091D0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100009224;
  v4[3] = &unk_1000627A0;
  _OWORD v4[4] = a2;
  v4[5] = a4;
  xpc_array_apply(a3, v4);
}

uint64_t sub_100009224(uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(object);
    xpc_object_t v10 = xpc_BOOL_create(1);
    sub_100008CE0(v8, string_ptr, v10, *(void *)(a1 + 40));
  }

  else
  {
    xpc_object_t v5 = *(_BYTE **)(a1 + 40);
    xpc_type_t type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100011A84(v5, 3LL, "Invalid item type %s in PublishesEvents, expected string", name);
    *(void *)(*(void *)(a1 + 32) + 1352LL) |= 1uLL;
  }

  return 1LL;
}

void sub_1000092D8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009318(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009358(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  int v19 = 0;
  memset(v18, 0, sizeof(v18));
  xpc_binprefs_init((uint64_t)v18);
  if (xpc_array_get_count(a3))
  {
    for (size_t i = 0LL; i < xpc_array_get_count(a3); ++i)
    {
      xpc_object_t value = xpc_array_get_value(a3, i);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
      {
        int v10 = xpc_int64_get_value(value);
        int v11 = -1;
      }

      else
      {
        if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_type_t type = xpc_get_type(value);
          xpc_type_get_name(type);
          sub_100011A84(a4, 3LL, "Invalid CPU type value type specified: %s");
          continue;
        }

        xpc_object_t v12 = xpc_dictionary_get_value(value, "CPUType");
        if (!v12)
        {
          sub_100011A84(a4, 3LL, "Missing CPUType", v17);
          continue;
        }

        size_t v13 = v12;
        if (xpc_get_type(v12) != (xpc_type_t)&_xpc_type_int64)
        {
          sub_100011A84(a4, 3LL, "Wrong CPUType type - expecting int64", v17);
          continue;
        }

        int v14 = xpc_int64_get_value(v13);
        xpc_object_t v15 = xpc_dictionary_get_value(value, "CPUSubtype");
        if (v15)
        {
          __int128 v16 = v15;
          if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_int64)
          {
            sub_100011A84(a4, 3LL, "Wrong CPUSubtype type - expecting int64");
            continue;
          }

          int v11 = xpc_int64_get_value(v16);
        }

        else
        {
          int v11 = -1;
        }

        int v10 = v14;
      }

      xpc_binprefs_add((uint64_t)v18, v10, v11);
    }
  }

  sub_1000044A4((uint64_t)a2, v18);
}

void sub_100009520(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_array_get_count(a3))
  {
    size_t v6 = 0LL;
    do
    {
      xpc_object_t value = xpc_array_get_value(a3, v6);
      sub_100009584((uint64_t)a2, value);
      ++v6;
    }

    while (v6 < xpc_array_get_count(a3));
  }

void sub_100009584(uint64_t a1, void *a2)
{
  uint64_t v4 = qword_100069320++;
  snprintf(__str, 0x400uLL, "%s.%llu", (const char *)(a1 + 1360), v4);
  sub_10000969C(a1, "com.apple.launchd.calendarinterval", __str, a2);
}

void sub_100009630(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_value(v6, "QueueDirectories", a3);
  sub_10000969C((uint64_t)a2, "com.apple.fsevents.matching", "com.apple.launchd.QueueDirectories", v6);
  xpc_release(v6);
}

void sub_10000969C(uint64_t a1, char *key, const char *a3, void *a4)
{
  xpc_object_t v8 = *(xpc_object_t *)(a1 + 496);
  if (!v8)
  {
    xpc_object_t v8 = xpc_dictionary_create(0LL, 0LL, 0LL);
    *(void *)(a1 + 496) = v8;
  }

  xpc_object_t value = xpc_dictionary_get_value(v8, key);
  if (!value)
  {
    xpc_object_t value = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 496), key, value);
    xpc_release(value);
  }

  xpc_dictionary_set_value(value, a3, a4);
}

void sub_100009730(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_value(v6, "WatchPaths", a3);
  sub_10000969C((uint64_t)a2, "com.apple.fsevents.matching", "com.apple.launchd.WatchPaths", v6);
  xpc_release(v6);
}

void sub_10000979C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_1000097DC(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100009830;
  v4[3] = &unk_1000629C0;
  _OWORD v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_100009830(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    sub_100008CE0(*(void *)(a1 + 32), a2, object, *(void *)(a1 + 40));
  }

  else
  {
    sub_100011A84(*(_BYTE **)(a1 + 40), 3LL, "Invalid item %s in PublishesEvents, expected dictionary or BOOL", a2);
    *(void *)(*(void *)(a1 + 32) + 1352LL) |= 1uLL;
  }

  return 1LL;
}

void sub_1000098D4(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100009928;
  v4[3] = &unk_100062A20;
  _OWORD v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_100009928(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(_BYTE **)(a1 + 40);
  *(void *)(v5 + 1352) |= 8uLL;
  __darwin_ct_rune_t v7 = __tolower(*a2);
  switch(v7)
  {
    case 'n':
      xpc_object_t v8 = "NetworkState";
      goto LABEL_10;
    case 'o':
      if (strcasecmp(a2, "OtherJobActive"))
      {
        xpc_object_t v8 = "OtherJobEnabled";
LABEL_10:
        if (strcasecmp(a2, v8)) {
          goto LABEL_19;
        }
      }

      sub_10001A4D8(v5, 3, "The %s key is no longer respected. %s", v10, v11, v12, v13, v14, (char)a2);
      return 1LL;
    case 'p':
      if (strcmp(a2, "PathState")) {
        goto LABEL_19;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary) {
        goto LABEL_24;
      }
      xpc_object_t v15 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_value(v15, "PathState", a3);
      sub_10000969C(v5, "com.apple.fsevents.matching", "com.apple.launchd.PathState", v15);
      xpc_release(v15);
      return 1LL;
    case 'q':
    case 'r':
      goto LABEL_19;
    case 's':
      if (strcmp(a2, "SuccessfulExit")) {
        goto LABEL_19;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_BOOL) {
        goto LABEL_24;
      }
      __int128 v16 = sub_100010B00(0x28uLL);
      uint64_t v17 = sub_10001A288;
      BOOL v18 = a3 == &_xpc_BOOL_true;
      int v19 = "successful exit";
      goto LABEL_26;
    default:
      if (v7 != 99)
      {
        if (v7 == 97 && !strcasecmp(a2, "AfterInitialDemand"))
        {
          if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_BOOL)
          {
            unint64_t v9 = *(void *)(v5 + 1352) & 0xFFFFFFFFFF7FFFFFLL | ((unint64_t)(a3 != 0LL) << 23);
LABEL_21:
            *(void *)(v5 + 1352) = v9;
            return 1LL;
          }

          goto LABEL_24;
        }

LABEL_19:
        sub_100011A84(v6, 3LL, "Unknown key for KeepAlive: %s");
LABEL_20:
        unint64_t v9 = *(void *)(v5 + 1352) | 1LL;
        goto LABEL_21;
      }

      if (strcasecmp(a2, "Crashed")) {
        goto LABEL_19;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_BOOL)
      {
LABEL_24:
        sub_100011A84(v6, 3LL, "Improper type for KeepAlive key: %s");
        goto LABEL_20;
      }

      __int128 v16 = sub_100010B00(0x28uLL);
      uint64_t v17 = sub_10001A234;
      BOOL v18 = a3 == &_xpc_BOOL_true;
      int v19 = "after crash";
LABEL_26:
      v16[32] = v18;
      *((void *)v16 + 2) = v17;
      *((void *)v16 + 3) = v19;
      __int128 v21 = (void *)(v5 + 648);
      uint64_t v22 = *(void *)(v5 + 648);
      *(void *)__int128 v16 = v22;
      if (v22) {
        *(void *)(v22 + 8) = v16;
      }
      void *v21 = v16;
      *((void *)v16 + 1) = v21;
      return 1LL;
  }

  xpc_object_t v28 = sub_10000D7F0(a2);
  BOOL v29 = 0x20000LL;
  if (!v28) {
    BOOL v29 = 0LL;
  }
  __int128 v30 = v29 | v15;
  if ((v15 & 0x40) != 0)
  {
    xpc_object_t value = xpc_dictionary_get_value(v13, "XPCService");
    int v31 = a2 + 16;
    if (value && (int v34 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary))
    {
      string = xpc_dictionary_get_string(v34, "_RoleAccount");
      __int128 v32 = v82;
      if (string && !strcmp(string, "mobile")) {
        __int128 v32 = v14 | 0x10;
      }
    }

    else
    {
      __int128 v32 = v82;
    }

    v30 &= ~0x80uLL;
  }

  else
  {
    int v31 = a2 + 16;
    __int128 v32 = v82;
  }

  xpc_object_t v35 = sub_100028AF4(v81, 3LL, v32, v31, (uint64_t)property, v9);
  LODWORD(v85) = v35;
  if ((_DWORD)v35)
  {
    __int128 v36 = *(void *)(*(void *)(v81 + 104) + 112LL);
    xpc_strerror(v35);
    sub_10002587C( a1,  3,  "Path not allowed in target domain: xpc_type_t type = %s, path = %s error = %d: %s, origin = %s",  v37,  v38,  v39,  v40,  v41,  v36);
    goto LABEL_29;
  }

  int v43 = *(_DWORD *)(a2 + 48);
  v84[0] = sub_100026D10;
  v84[1] = sub_1000270F8;
  v84[2] = sub_10002723C;
  v84[3] = sub_1000273D4;
  v84[4] = sub_10002742C;
  v84[5] = sub_100027520;
  v84[6] = v81;
  uint64_t v44 = (char *)xpc_dictionary_get_string(v13, "CFBundleIdentifier");
  if (!v44)
  {
    sub_10002587C( a1,  3,  "Bundle Info.plist at %s does not have a CFBundleIdentifier",  v45,  v46,  v47,  v48,  v49,  (char)property);
    uint64_t v12 = 0LL;
    xpc_object_t v25 = 107;
    goto LABEL_16;
  }

  uint64_t v50 = (char)v44;
  uint64_t v51 = sub_100028EF4((_DWORD *)v81, v44);
  if (v51)
  {
    uint64_t v12 = v51;
    uint64_t v52 = (const char *)sub_10001A0A4((uint64_t)v51);
    if (strcmp(property, v52))
    {
      sub_10001A0A4((uint64_t)v12);
      sub_10002587C( a1,  4,  "Attempt to re-bootstrap service from different path, will use existing: service = %s, existing = %s, conflicting = %s",  v53,  v54,  v55,  v56,  v57,  v50);
    }

    unint64_t v58 = 121;
    LODWORD(v85) = 121;
    a4 = v83;
  }

  else
  {
    if ((*(_BYTE *)(a2 + 49) & 0x40) == 0 && *(void **)(a1 + 104) == qword_100069750)
    {
      uint64_t v72 = sub_10000D81C(a2);
      *(void *)&v86[0] = 0LL;
      if (!sub_10002CC20(a1, v72, v86) && *(void **)&v86[0] == qword_100069750)
      {
        int v73 = (void *)xpc_bundle_get_info_dictionary(v72);
        char v74 = xpc_dictionary_get_value(v73, "XPCService");
        if (v74)
        {
          uint64_t v75 = v74;
          if (xpc_get_type(v74) == (xpc_type_t)&_xpc_type_dictionary
            && !xpc_dictionary_get_value(v75, "_AdditionalSubServices")
            && !xpc_dictionary_get_value(v75, "_AdditionalServices")
            && !byte_10006A97E)
          {
            if (v81 != a1) {
              sub_100046EB4();
            }
            sub_10003DD44(a1, v8, (uint64_t)v80, (2 * v43) & 0x200LL | v30, &v85);
            if (v76)
            {
              uint64_t v77 = v76;
              uint64_t v78 = sub_10003DD90(v76);
              os_map_str_insert(a1 + 488, v78, v77);
              uint64_t v12 = 0LL;
              xpc_object_t v25 = 123;
              goto LABEL_16;
            }

    if (!v1 || v1 < v1 + 64) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  if (v10 - (unint64_t)v9 >= 9)
  {
    uint64_t v5 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v5)
    {
      uint64_t v6 = "number too large";
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  if ((unint64_t)v9 < v10)
  {
    uint64_t v2 = 0LL;
    uint64_t result = 0LL;
    while (1)
    {
      if (!v2 && (*v9 & 0x80u) != 0) {
        uint64_t result = -1LL;
      }
      uint64_t v4 = &v9[v2];
      uint64_t result = *v4 | (unint64_t)(result << 8);
      if (v10 - (void)v9 == ++v2) {
        return result;
      }
    }

void sub_100009BC0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 122) |= 0x14000uLL;
  xpc_dictionary_apply_f(a3);
}

int64_t sub_100009BE4(const char *a1, void *a2, uint64_t a3)
{
  if (!strcasecmp(a1, "Wait"))
  {
    int64_t result = xpc_BOOL_get_value(a2);
    uint64_t v7 = 0x8000LL;
    if (!(_DWORD)result) {
      uint64_t v7 = 0LL;
    }
    *(void *)(a3 + 1352) = *(void *)(a3 + 1352) & 0xFFFFFFFFFFFF7FFFLL | v7;
  }

  else
  {
    int64_t result = strcasecmp(a1, "Instances");
    if (!(_DWORD)result)
    {
      int64_t result = xpc_int64_get_value(a2);
      *(_DWORD *)(a3 + 268) = result;
    }
  }

  return result;
}

void sub_100009C6C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009C7C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009CBC(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100009D10;
  v4[3] = &unk_100062B80;
  _OWORD v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_100009D10(uint64_t a1, uint64_t a2, xpc_object_t object)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_array)
    {
      sub_10001A4D8(v5, 3, "Socket entry is not a dictionary or array. Skipping: %s", v7, v8, v9, v10, v11, a2);
LABEL_5:
      *(void *)(v5 + 1352) |= 1uLL;
      return 1LL;
    }

    if (!xpc_array_get_count(object)) {
      return 1LL;
    }
    size_t v12 = 0LL;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(object, v12);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
      {
        if ((*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, uint64_t, void))(v5 + 552))( v5,  a2,  value,  v6,  *(void *)(v5 + 568)))
        {
          goto LABEL_12;
        }
      }

      else
      {
        sub_10001A4D8(v5, 3, "Socket entry is not a dictionary. Skipping: %s", v14, v15, v16, v17, v18, a2);
      }

      *(void *)(v5 + 1352) |= 1uLL;
LABEL_12:
      if (++v12 >= xpc_array_get_count(object)) {
        return 1LL;
      }
    }
  }

  if (!(*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, uint64_t, void))(v5 + 552))( v5,  a2,  object,  v6,  *(void *)(v5 + 568))) {
    goto LABEL_5;
  }
  return 1LL;
}

void sub_100009E60(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009E6C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

uint64_t sub_100009E7C(const char *a1, xpc_object_t object, uint64_t a3)
{
  uint64_t result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_int64)
  {
    int64_t value = xpc_int64_get_value(object);
    uint64_t v8 = 0LL;
    while (1)
    {
      uint64_t result = strcasecmp((&off_1000630C8)[v8], a1);
      if (!(_DWORD)result) {
        break;
      }
      v8 += 2LL;
      if (v8 == 18) {
        return result;
      }
    }

    int v9 = LOWORD((&off_1000630C8)[v8 + 1]);
    uint64_t v10 = *(void *)(a3 + 1352);
    uint64_t v11 = (uint64_t *)(a3 + 656);
    uint64_t result = (uint64_t)v11;
    while (1)
    {
      uint64_t result = *(void *)result;
      if (!result) {
        break;
      }
    }

    uint64_t result = (uint64_t)sub_100010B00(0x28uLL);
    *(_WORD *)(result + 32) = v9;
    uint64_t v12 = *v11;
    *(void *)uint64_t result = *v11;
    if (v12) {
      *(void *)(v12 + 8) = result;
    }
    *uint64_t v11 = result;
    *(void *)(result + 8) = v11;
LABEL_13:
    if ((v10 & 0x800000000LL) != 0)
    {
      *(_BYTE *)(result + 34) = 1;
      uint64_t v13 = (int64_t *)(result + 24);
    }

    else
    {
      *(_BYTE *)(result + 35) = 1;
      uint64_t v13 = (int64_t *)(result + 16);
    }

    *uint64_t v13 = value;
  }

  return result;
}

void sub_100009F70(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_100009FB0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 122) |= 0x800000000uLL;
  xpc_dictionary_apply_f(a3);
  *((void *)&a2->var4 + 122) &= ~0x800000000uLL;
}

void sub_100009FF4(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10000A048;
  v4[3] = &unk_100062CE0;
  _OWORD v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000A048(uint64_t a1, char *a2, uint64_t a3)
{
  return 1LL;
}

void sub_10000A068(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10000A0BC;
  v4[3] = &unk_100062D40;
  _OWORD v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000A0BC(uint64_t a1, const char *a2, xpc_object_t object)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(_BYTE **)(a1 + 40);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_10000A74C;
    applier[3] = &unk_100063158;
    applier[4] = object;
    void applier[5] = v5;
    void applier[6] = a2;
    void applier[7] = v6;
    xpc_dictionary_apply(object, applier);
  }

  else
  {
    xpc_type_t type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100011A84( v5,  3LL,  "Invalid type for a LaunchEvent stream, should be a dictionary (stream/type): %s/%s",  a2,  name);
    *(void *)(v6 + 1352) |= 1uLL;
  }

  return 1LL;
}

void sub_10000A180(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10000A1D4;
  v4[3] = &unk_100062DA0;
  _OWORD v4[4] = a4;
  v4[5] = a2;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000A1D4(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_dictionary_get_int64(object, "SizeLimit"))
    {
      sub_10000969C(*(void *)(a1 + 40), "com.apple.xpc.datastores.publish", a2, object);
      return 1LL;
    }

    sub_100011A84(*(_BYTE **)(a1 + 32), 3LL, "Size limit for Datastore entry not specified: %s");
  }

  else
  {
    uint64_t v6 = *(_BYTE **)(a1 + 32);
    xpc_type_t type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_100011A84(v6, 3LL, "Invalid type for a Datastores entry, should be a dictionary (key/type): %s/%s");
  }

  *(void *)(*(void *)(a1 + 40) + 1352LL) |= 1uLL;
  return 1LL;
}

void sub_10000A2A0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10000A2F4;
  v4[3] = &unk_100062E00;
  _OWORD v4[4] = a4;
  v4[5] = a2;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000A2F4(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000969C(*(void *)(a1 + 40), "com.apple.remoted.service", a2, object);
  }

  else
  {
    uint64_t v6 = *(_BYTE **)(a1 + 32);
    xpc_type_t type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100011A84( v6,  3LL,  "Invalid type for a RemoteServices entry, should be a dictionary (key/type): %s/%s",  a2,  name);
    *(void *)(*(void *)(a1 + 40) + 1352LL) |= 1uLL;
  }

  return 1LL;
}

void sub_10000A398(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  a2->var4.var24 = xpc_retain(a3);
}

void sub_10000A3C0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_mach_send) {
    a2->var4.var88 = xpc_mach_send_copy_right(a3);
  }
  else {
    sub_100046F44((uint64_t)a2);
  }
}

void sub_10000A410(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x200000000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFDFFFFFFFFFFFFFFLL | v4;
}

void sub_10000A430(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    a2->var4.var78 = 1;
  }
}

void sub_10000A440(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v19 = 0LL;
  xpc_object_t v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  char v22 = 1;
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  char v18 = 0;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 0;
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000LL;
  applier[2] = sub_10000A7FC;
  applier[3] = &unk_100063180;
  void applier[7] = &v11;
  void applier[8] = a4;
  applier[4] = &v7;
  void applier[5] = &v19;
  void applier[6] = &v15;
  xpc_dictionary_apply(a3, applier);
  if (!*((_BYTE *)v16 + 24))
  {
    if (*((_BYTE *)v12 + 24))
    {
      *((void *)&a2->var4 + 122) |= 0x400000000000000uLL;
      unint64_t v5 = v8[3];
      if (!v5) {
        unint64_t v5 = qword_100069A50;
      }
    }

    else
    {
      a2->var4.var78 = *((_BYTE *)v20 + 24);
      unint64_t v5 = v8[3];
    }

    a2->var4.var79 = v5;
  }

  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
}

void sub_10000A580(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 122) |= 0x800000000000000uLL;
}

void sub_10000A5B4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_10000A5C0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  unsigned __int8 var69 = a2->var4.var69;
  a2->var4.unsigned __int8 var69 = a3;
  if ((sub_1000032C4((uint64_t)a2, 7) & 1) == 0)
  {
    sub_100011A84(a4, 3LL, "Supplied value (%lld) for _LaunchType key not allowed", a3);
    a2->var4.unsigned __int8 var69 = var69;
  }

void sub_10000A628(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_10000A634(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x4000000000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xBFFFFFFFFFFFFFFFLL | v4;
}

uint64_t sub_10000A654(uint64_t a1, char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (sub_100012A34(a2, "DomainInternal"))
    {
      if (!xpc_BOOL_get_value(object)) {
        return 1LL;
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
      int v8 = *(_DWORD *)(v7 + 24) | 1;
    }

    else
    {
      if (!sub_100012A34(a2, "RequireTrusted"))
      {
        sub_100011A84(*(_BYTE **)(a1 + 40), 3LL, "Unknown property %s for PublishesEvents");
        goto LABEL_3;
      }

      if (!xpc_BOOL_get_value(object)) {
        return 1LL;
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
      int v8 = *(_DWORD *)(v7 + 24) | 2;
    }

    *(_DWORD *)(v7 + 24) = v8;
    return 1LL;
  }

  sub_100011A84(*(_BYTE **)(a1 + 40), 3LL, "Invalid type for PublishesEvents property %s, expected BOOL");
LABEL_3:
  *(void *)(*(void *)(a1 + 48) + 1352LL) |= 1uLL;
  return 1LL;
}

uint64_t sub_10000A74C(uint64_t a1, const char *a2, void *a3)
{
  xpc_type_t type = xpc_get_type(*(xpc_object_t *)(a1 + 32));
  uint64_t v7 = *(const char **)(a1 + 48);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000969C(*(void *)(a1 + 56), *(char **)(a1 + 48), a2, a3);
  }

  else
  {
    int v8 = *(_BYTE **)(a1 + 40);
    uint64_t v9 = xpc_get_type(a3);
    name = xpc_type_get_name(v9);
    sub_100011A84(v8, 3LL, "Invalid type for a LaunchEvent (stream/name/type): %s/%s/%s", v7, a2, name);
    *(void *)(*(void *)(a1 + 56) + 1352LL) |= 1uLL;
  }

  return 1LL;
}

uint64_t sub_10000A7FC(uint64_t a1, char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_int64)
  {
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_BOOL)
    {
      sub_100011A84(*(_BYTE **)(a1 + 64), 3LL, "Improper type for _PanicOnCrash key: %s");
      return 1LL;
    }

    if (object == &_xpc_BOOL_false) {
      return 1LL;
    }
    if (sub_100012A34(a2, "PanicOnNonZeroExit"))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
      char v10 = 3;
LABEL_25:
      *(_BYTE *)(v9 + 24) = v10;
      return 1LL;
    }

    if (sub_100012A34(a2, "InternalOnly"))
    {
      if (byte_10006A99E) {
        return 1LL;
      }
      sub_100011A84(*(_BYTE **)(a1 + 64), 4LL, "_PanicOnCrash key: InternalOnly not enabled in the current environment");
    }

    else
    {
      if (!sub_100012A34(a2, "AutomationOnly"))
      {
        if (!sub_100012A34(a2, "PanicOnConsecutiveCrash")) {
          return 1LL;
        }
        uint64_t v12 = *(void *)(a1 + 56);
        goto LABEL_24;
      }

      if (byte_10006A99F) {
        return 1LL;
      }
      sub_100011A84( *(_BYTE **)(a1 + 64),  4LL,  "_PanicOnCrash key: AutomationOnly not enabled in the current environment");
    }

    uint64_t v12 = *(void *)(a1 + 48);
LABEL_24:
    uint64_t v9 = *(void *)(v12 + 8);
    char v10 = 1;
    goto LABEL_25;
  }

  int64_t value = xpc_int64_get_value(object);
  if (sub_100012A34(a2, "PanicOnCrashDeadline"))
  {
    if (value < 0)
    {
      uint64_t v7 = *(_BYTE **)(a1 + 64);
      int v8 = "_PanicOnCrash key: PanicOnCrashDeadline less than zero. Ignoring.";
    }

    else
    {
      if (is_mul_ok(value, 0x3B9ACA00uLL))
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1000000000 * value;
        return 1LL;
      }

      uint64_t v7 = *(_BYTE **)(a1 + 64);
      int64_t v13 = value;
      int v8 = "_PanicOnCrash key: PanicOnCrashDeadline overflowed converting to ns (%lld)";
    }

    sub_100011A84(v7, 4LL, v8, v13);
  }

  return 1LL;
}

uint64_t sub_10000A9C0(uint64_t a1)
{
  unint64_t v1 = mach_absolute_time() - a1;
  return sub_10000A9E4(v1);
}

uint64_t sub_10000A9E4(unint64_t a1)
{
  if (qword_100069B48 != -1) {
    dispatch_once_f(&qword_100069B48, 0LL, (dispatch_function_t)sub_10000AFE0);
  }
  if (dword_100069B50 != *(_DWORD *)algn_100069B54) {
    return __udivti3(dword_100069B50 * a1, (dword_100069B50 * (unsigned __int128)a1) >> 64);
  }
  return a1;
}

void sub_10000AA5C(unint64_t a1)
{
  if (qword_100069B48 != -1) {
    dispatch_once_f(&qword_100069B48, 0LL, (dispatch_function_t)sub_10000AFE0);
  }
  if (dword_100069B50 != *(_DWORD *)algn_100069B54
    && !is_mul_ok(a1 / dword_100069B50, *(unsigned int *)algn_100069B54))
  {
    __break(1u);
  }

uint64_t sub_10000AAD4(mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  do
  {
    uint64_t v6 = mach_port_construct(mach_task_self_, options, context, name);
    uint64_t v7 = v6;
    BOOL v8 = (_DWORD)v6 == 6 || (_DWORD)v6 == 3;
  }

  while (v8 && sub_100012654());
  return v7;
}

uint64_t sub_10000AB40(mach_port_options_t *a1, mach_port_context_t a2)
{
  mach_port_name_t name = 0;
  int v2 = sub_10000AAD4(a1, a2, &name);
  if (v2) {
    sub_100046F80(v2);
  }
  return name;
}

uint64_t sub_10000AB70(uint32_t a1, mach_port_msgcount_t a2, mach_port_context_t a3)
{
  v4.flags = a1;
  v4.mpl.mpl_qlimit = a2;
  v4.reserved[0] = 0LL;
  v4.reserved[1] = 0LL;
  return sub_10000AB40(&v4, a3);
}

uint64_t sub_10000AB9C(mach_port_name_t name, mach_port_context_t guard)
{
  return mach_port_unguard(mach_task_self_, name, guard);
}

uint64_t sub_10000ABB4(mach_port_name_t name, uint64_t a2)
{
  *(void *)info = a2;
  uint64_t result = mach_port_assert_attributes(mach_task_self_, name, 8, info, 2u);
  if ((_DWORD)result) {
    sub_100046FA8(result);
  }
  return result;
}

uint64_t sub_10000ABFC(mach_port_name_t name)
{
  return mach_port_insert_right(mach_task_self_, name, name, 0x14u);
}

uint64_t sub_10000AC18(mach_port_name_t name, mach_port_t *poly)
{
  mach_msg_type_name_t polyPoly = 0;
  return mach_port_extract_right(mach_task_self_, name, 0x15u, poly, &polyPoly);
}

uint64_t sub_10000AC54(mach_port_name_t name)
{
  return mach_port_mod_refs(mach_task_self_, name, 0, 1);
}

uint64_t sub_10000AC70(mach_port_name_t name)
{
  return mach_port_deallocate(mach_task_self_, name);
}

uint64_t sub_10000AC84(mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return mach_port_destruct(mach_task_self_, name, srdelta, guard);
}

uint64_t sub_10000ACA0(mach_port_name_t name)
{
  return mach_port_set_attributes(mach_task_self_, name, 4, 0LL, 0);
}

uint64_t sub_10000ACC0(mach_port_name_t name, mach_port_t notify, mach_port_t *previous)
{
  if (notify) {
    mach_msg_type_name_t v3 = 21;
  }
  else {
    mach_msg_type_name_t v3 = 18;
  }
  return mach_port_request_notification(mach_task_self_, name, 69, 0, notify, v3, previous);
}

uint64_t sub_10000ACF4(uint64_t a1)
{
  return a1 + ((*(unsigned int *)(a1 + 4) + 3LL) & 0x1FFFFFFFCLL) + 20;
}

uint64_t sub_10000AD0C()
{
  if (_os_alloc_once_table[2] == -1LL) {
    uint64_t v0 = _os_alloc_once_table[3];
  }
  else {
    uint64_t v0 = _os_alloc_once(&_os_alloc_once_table[2], 216LL, 0LL);
  }
  if (*(_BYTE *)(v0 + 41))
  {
    if (*(void *)(v0 + 48) != -1LL) {
      dispatch_once_f((dispatch_once_t *)(v0 + 48), (void *)(v0 + 56), (dispatch_function_t)sub_10000AD90);
    }
  }

  else
  {
    sub_10000AD90((task_info_t)(v0 + 56));
  }

  return v0 + 56;
}

uint64_t sub_10000AD90(task_info_t task_info_out)
{
  mach_msg_type_number_t task_info_outCnt = 8;
  if (task_info(mach_task_self_, 0xFu, task_info_out, &task_info_outCnt)) {
    sub_100046FD0();
  }
  integer_t v2 = task_info_out[5];
  uint64_t result = getpid();
  if (v2 != (_DWORD)result || !task_info_out[7]) {
    sub_100046FD0();
  }
  return result;
}

uint64_t sub_10000ADFC(posix_spawnattr_t *a1, mach_port_t new_port)
{
  if (_os_alloc_once_table[2] == -1LL) {
    uint64_t v4 = _os_alloc_once_table[3];
  }
  else {
    uint64_t v4 = _os_alloc_once(&_os_alloc_once_table[2], 216LL, 0LL);
  }
  if (*(_BYTE *)(v4 + 42)) {
    exception_mask_t v5 = 7168;
  }
  else {
    exception_mask_t v5 = 10240;
  }
  if (!a1) {
    return task_set_exception_ports(mach_task_self_, v5, new_port, -1610612732, 1);
  }
  uint64_t result = posix_spawnattr_setexceptionports_np(a1, v5, new_port, -1610612732, 1);
  if ((_DWORD)result) {
    sub_100046EE0(result);
  }
  return result;
}

uint64_t sub_10000AEA8(task_inspect_t task)
{
  kern_return_t exception_ports;
  mach_port_t v5;
  mach_msg_type_number_t masksCnt;
  thread_state_flavor_t old_flavors[4];
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  exception_behavior_t old_behaviors[4];
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  _OWORD old_handlers[3];
  uint64_t v17;
  _OWORD masks[3];
  uint64_t v19;
  if (_os_alloc_once_table[2] == -1LL) {
    uint64_t v2 = _os_alloc_once_table[3];
  }
  else {
    uint64_t v2 = _os_alloc_once(&_os_alloc_once_table[2], 216LL, 0LL);
  }
  uint64_t v19 = 0LL;
  memset(masks, 0, sizeof(masks));
  masksCnt = 0;
  uint64_t v17 = 0LL;
  memset(old_handlers, 0, sizeof(old_handlers));
  uint64_t v15 = 0LL;
  int64_t v13 = 0u;
  char v14 = 0u;
  *(_OWORD *)old_behaviors = 0u;
  uint64_t v11 = 0LL;
  uint64_t v9 = 0u;
  char v10 = 0u;
  *(_OWORD *)old_flavors = 0u;
  if (*(_BYTE *)(v2 + 42)) {
    exception_mask_t v3 = 1024;
  }
  else {
    exception_mask_t v3 = 0x2000;
  }
  if (mach_task_self_ == task)
  {
    exception_ports = task_get_exception_ports( task,  v3,  (exception_mask_array_t)masks,  &masksCnt,  (exception_handler_array_t)old_handlers,  old_behaviors,  old_flavors);
  }

  else
  {
    exception_mask_t v5 = mach_host_self();
    exception_ports = host_get_exception_ports( v5,  v3,  (exception_mask_array_t)masks,  &masksCnt,  (exception_handler_array_t)old_handlers,  old_behaviors,  old_flavors);
  }

  if (exception_ports) {
    sub_100046EE0(exception_ports);
  }
  return LODWORD(old_handlers[0]);
}

uint64_t sub_10000AFE0()
{
  uint64_t result = mach_timebase_info((mach_timebase_info_t)&dword_100069B50);
  if ((_DWORD)result) {
    sub_100046EE0(result);
  }
  return result;
}

void *sub_10000B004(const char *a1)
{
  uint64_t v2 = sub_100010B00(0xB0uLL);
  *uint64_t v2 = sub_1000126A0(a1);
  os_map_str_init(v2 + 1, 0LL, 1LL);
  os_map_str_init(v2 + 4, 0LL, 1LL);
  os_map_str_init(v2 + 7, 0LL, 1LL);
  os_map_str_init(v2 + 10, 0LL, 1LL);
  os_map_str_init(v2 + 13, 0LL, 1LL);
  os_map_str_init(v2 + 16, 0LL, 1LL);
  os_map_str_init(v2 + 19, 0LL, 1LL);
  return v2;
}

uint64_t sub_10000B0B0(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100010B00(0x10uLL);
  v6[1] = a3;
  return sub_10000B0F8(a1, a1 + 8, a2, v6);
}

uint64_t sub_10000B0F8(uint64_t a1, uint64_t a2, const char *a3, char **a4)
{
  uint64_t v7 = sub_10000B37C(a3);
  if (os_map_str_find(a1 + 152, v7)) {
    sub_100046EB4();
  }
  if (os_map_str_find(a2, v7)) {
    sub_100046EB4();
  }
  *a4 = v7;
  return os_map_str_insert(a2, v7, a4);
}

uint64_t sub_10000B168(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100010B00(0x10uLL);
  v6[1] = a3;
  return sub_10000B0F8(a1, a1 + 32, a2, v6);
}

uint64_t sub_10000B1B0(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100010B00(0x10uLL);
  v6[1] = a3;
  return sub_10000B0F8(a1, a1 + 56, a2, v6);
}

uint64_t sub_10000B1F8(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100010B00(0x10uLL);
  v6[1] = a3;
  return sub_10000B0F8(a1, a1 + 80, a2, v6);
}

uint64_t sub_10000B240(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100010B00(0x10uLL);
  v6[1] = a3;
  return sub_10000B0F8(a1, a1 + 104, a2, v6);
}

uint64_t sub_10000B288(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100010B00(0x10uLL);
  v6[1] = a3;
  return sub_10000B0F8(a1, a1 + 128, a2, v6);
}

uint64_t sub_10000B2D0(uint64_t a1, const char *a2)
{
  exception_mask_t v3 = sub_10000B37C(a2);
  if (os_map_str_find(a1 + 8, v3)) {
    sub_100046EB4();
  }
  if (os_map_str_find(a1 + 32, v3)) {
    sub_100046EB4();
  }
  if (os_map_str_find(a1 + 56, v3)) {
    sub_100046EB4();
  }
  if (os_map_str_find(a1 + 80, v3)) {
    sub_100046EB4();
  }
  if (os_map_str_find(a1 + 104, v3)) {
    sub_100046EB4();
  }
  if (os_map_str_find(a1 + 128, v3)) {
    sub_100046EB4();
  }
  return os_map_str_insert(a1 + 152, v3, 1LL);
}

char *sub_10000B37C(const char *a1)
{
  unint64_t v1 = sub_1000126A0(a1);
  if (*v1)
  {
    size_t v2 = 0LL;
    do
    {
      v1[v2] = __tolower(v1[v2]);
      ++v2;
    }

    while (v2 < strlen(v1));
  }

  return v1;
}

uint64_t sub_10000B3CC(uint64_t *a1, uint64_t a2, const char *a3, void *a4, uint64_t a5)
{
  uint64_t v9 = sub_10000B37C(a3);
  if (os_map_str_find(a1 + 19, v9)) {
    goto LABEL_2;
  }
  xpc_type_t type = xpc_get_type(a4);
  if (type != (xpc_type_t)&_xpc_type_BOOL)
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      uint64_t v17 = os_map_str_find(a1 + 4, v9);
      if (!v17) {
        goto LABEL_22;
      }
      uint64_t v18 = *(void *)(v17 + 8);
      int64_t value = xpc_int64_get_value(a4);
      xpc_object_t v20 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v18 + 16);
      uint64_t v21 = v18;
    }

    else
    {
      if (type != (xpc_type_t)&_xpc_type_string)
      {
        if (type == (xpc_type_t)&_xpc_type_array)
        {
          int64_t v13 = a1 + 10;
        }

        else if (type == (xpc_type_t)&_xpc_type_dictionary)
        {
          int64_t v13 = a1 + 13;
        }

        else
        {
          int64_t v13 = a1 + 16;
        }

        uint64_t v25 = os_map_str_find(v13, v9);
        if (v25)
        {
          uint64_t v21 = *(void *)(v25 + 8);
          xpc_object_t v20 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v21 + 16);
          uint64_t v24 = a2;
          int64_t value = (int64_t)a4;
          goto LABEL_21;
        }

LABEL_22:
        __int128 v26 = xpc_get_type(a4);
        int v27 = (void **)sub_10000D8E8(0x80uLL);
        uint64_t v28 = *a1;
        xpc_type_get_name(v26);
        sub_10000D960( (uint64_t)v27,  "Invalid type for %s importer (key: %s type: %s), accepted types: [",  v29,  v30,  v31,  v32,  v33,  v34,  v28);
        uint64_t v35 = os_map_str_find(a1 + 1, v9);
        BOOL v42 = v35 != 0;
        if (v35) {
          sub_10000D960((uint64_t)v27, "BOOL, ", v36, v37, v38, v39, v40, v41, v90);
        }
        if (os_map_str_find(a1 + 4, v9))
        {
          sub_10000D960((uint64_t)v27, "integer, ", v43, v44, v45, v46, v47, v48, v90);
          BOOL v42 = 1;
        }

        if (os_map_str_find(a1 + 7, v9))
        {
          sub_10000D960((uint64_t)v27, "string, ", v49, v50, v51, v52, v53, v54, v90);
          BOOL v42 = 1;
        }

        if (os_map_str_find(a1 + 10, v9))
        {
          sub_10000D960((uint64_t)v27, "array, ", v55, v56, v57, v58, v59, v60, v90);
          BOOL v42 = 1;
        }

        if (os_map_str_find(a1 + 13, v9))
        {
          sub_10000D960((uint64_t)v27, "dictionary, ", v61, v62, v63, v64, v65, v66, v90);
          if (!os_map_str_find(a1 + 16, v9)) {
            goto LABEL_35;
          }
        }

        else if (!os_map_str_find(a1 + 16, v9))
        {
          if (!v42)
          {
            uint64_t v84 = *a1;
            xpc_type_get_name(v26);
            sub_10001A4D8(a2, 3, "Unknown key for %s importer (key: %s type: %s)", v85, v86, v87, v88, v89, v84);
            goto LABEL_36;
          }

          fts_path = (uint64_t)v13->fts_path;
          uint64_t v17 = 4;
          fts_errno = 108;
        }

LABEL_35:
          sub_10000DA60(v27, 2uLL);
          sub_10000D960((uint64_t)v27, "]", v73, v74, v75, v76, v77, v78, v90);
          sub_10001A4D8(a2, 3, "%s", v79, v80, v81, v82, v83, (char)*v27);
LABEL_36:
          sub_10000D938(v27);
          uint64_t v10 = 0LL;
          goto LABEL_3;
        }

        sub_10000D960((uint64_t)v27, "object, ", v67, v68, v69, v70, v71, v72, v90);
        goto LABEL_35;
      }

      uint64_t v22 = os_map_str_find(a1 + 7, v9);
      if (!v22) {
        goto LABEL_22;
      }
      uint64_t v23 = v22;
      int64_t value = (int64_t)xpc_string_get_string_ptr(a4);
      uint64_t v21 = *(void *)(v23 + 8);
      xpc_object_t v20 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v21 + 16);
    }

    uint64_t v24 = a2;
LABEL_21:
    v20(v21, v24, value, a5);
    goto LABEL_2;
  }

  uint64_t v14 = os_map_str_find(a1 + 1, v9);
  if (!v14) {
    goto LABEL_22;
  }
  uint64_t v15 = *(void *)(v14 + 8);
  BOOL v16 = xpc_BOOL_get_value(a4);
  (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t))(v15 + 16))(v15, a2, v16, a5);
LABEL_2:
  uint64_t v10 = 1LL;
LABEL_3:
  free(v9);
  return v10;
}

void sub_10000B700(const void *a1)
{
  if (dword_10006AE08)
  {
    size_t v2 = (dispatch_queue_s *)sub_100011938();
    exception_mask_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 1uLL, v2);
    dispatch_time_t v4 = dispatch_time(0LL, 1000000000LL * dword_10006AE08);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_source_set_event_handler_f(v3, (dispatch_function_t)sub_10000B7B8);
    exception_mask_t v5 = _Block_copy(a1);
    dispatch_set_context(v3, v5);
    dispatch_activate(v3);
  }

void sub_10000B7B8()
{
  uint64_t v0 = sub_10002A7C8();
  uint64_t v1 = mach_absolute_time();
  if (!*(_DWORD *)(v0 + 156)) {
    sub_10003AB08(65541, "Shutdown stall event fired with no activations (skipping report)");
  }
  uint64_t v2 = mach_absolute_time();
  uint64_t v3 = sub_10000AA58(v2 - v1);
  sub_10001587C(v3);
}

uint64_t sub_10000B808(void *a1)
{
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(a1, "Version4");
  if (!dictionary) {
    return 22LL;
  }
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  v3[2] = sub_10000B8D4;
  v3[3] = &unk_1000631A0;
  v3[4] = dictionary;
  sub_10000B874((uint64_t)v3);
  return 0LL;
}

uint64_t sub_10000B874(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = 0LL; i != 256; i += 32LL)
  {
    if ((*((_BYTE *)&unk_100069328 + i + 16) & 2) != 0)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(v1 + 16))(v1);
    }
  }

  return result;
}

void *sub_10000B8D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const char **)(a2 + 24);
  uint64_t result = xpc_dictionary_get_dictionary(*(xpc_object_t *)(a1 + 32), v3);
  if (result)
  {
    exception_mask_t v5 = result;
    uint64_t result = xpc_get_type(result);
    if (result == &_xpc_type_dictionary)
    {
      uint64_t v6 = 0LL;
      char v7 = 1;
      do
      {
        char v8 = v7;
        uint64_t result = xpc_dictionary_get_dictionary(v5, off_100063220[v6]);
        if (result)
        {
          uint64_t v9 = result;
          uint64_t result = xpc_get_type(result);
          if (result == &_xpc_type_dictionary)
          {
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000LL;
            applier[2] = sub_10000C6EC;
            applier[3] = &unk_100063230;
            applier[4] = a2;
            void applier[5] = v3;
            int v11 = v6;
            uint64_t result = (void *)xpc_dictionary_apply(v9, applier);
          }
        }

        char v7 = 0;
        uint64_t v6 = 1LL;
      }

      while ((v8 & 1) != 0);
    }
  }

  return result;
}

uint64_t sub_10000B9CC(const char *a1)
{
  uint64_t v2 = sub_100012884("%s%s", a1, "/Library/JetsamProperties/com.apple.jetsamproperties.DDI.plist");
  sub_10003AB08(5, "Loading DDI overlay plist from: %s", v2);
  uint64_t v3 = sub_10000BA94(v2);
  free(v2);
  if ((_DWORD)v3 == 2)
  {
    dispatch_time_t v4 = sub_100012884("%s%s", a1, "/System/Library/JetsamProperties/com.apple.jetsamproperties.cryptex.plist");
    sub_10003AB08(5, "Loading Cryptex overlay plist from: %s", v4);
    LODWORD(v3) = sub_10000BA94(v4);
    free(v4);
    if ((_DWORD)v3 == 2) {
      return 0LL;
    }
    else {
      return v3;
    }
  }

  return v3;
}

uint64_t sub_10000BA94(const char *a1)
{
  uint64_t v2 = sub_100036DB4(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = sub_10000B808(v2);
    xpc_release(v3);
    return v4;
  }

  else
  {
    sub_10003AB08(3, "Overlay plist is missing.");
    return 2LL;
  }

void sub_10000BB08(void *a1, _BYTE *a2)
{
  unint64_t int64 = xpc_dictionary_get_int64(a1, "CPUMonitorInterval");
  unint64_t v5 = xpc_dictionary_get_int64(a1, "CPUMonitorPercentage");
  if (int64 >= 0x100)
  {
    sub_100011A84(a2, 3LL, "CPUMonitorInterval is out of range, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorInterval", 0LL);
    unint64_t int64 = 0LL;
  }

  if (v5 >= 0x65)
  {
    sub_100011A84(a2, 3LL, "CPUMonitorPercentage is out of range, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorPercentage", 0LL);
LABEL_11:
    sub_100011A84(a2, 3LL, "incomplete CPUMonitor, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorInterval", 0LL);
    xpc_dictionary_set_value(a1, "CPUMonitorPercentage", 0LL);
    return;
  }

  else {
    BOOL v6 = v5 == 100;
  }
}

BOOL sub_10000BC6C(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10000BCC4;
  v4[3] = &unk_1000631C0;
  _OWORD v4[4] = a1;
  v4[5] = a3;
  return xpc_dictionary_apply(xdict, v4);
}

uint64_t sub_10000BCC4(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  char v7 = (uint64_t *)qword_100069B58;
  if (!qword_100069B58)
  {
    qword_100069B58 = (uint64_t)sub_10000B004("JetsamProperties");
    sub_10000B0B0(qword_100069B58, "EnableTransactions", (char *)&stru_100063270);
    sub_10000B0B0(qword_100069B58, "EnablePressuredExit", (char *)&stru_1000632B0);
    sub_10000B2D0(qword_100069B58, "ExecuteAllowed");
    sub_10000B0B0(qword_100069B58, "EnableIdleHysteresis", (char *)&stru_1000632F0);
    sub_10000B0B0(qword_100069B58, "MallocSpaceEfficient", (char *)&stru_100063330);
    sub_10000B0B0(qword_100069B58, "MallocNanoZone", (char *)&stru_100063370);
    sub_10000B0B0(qword_100069B58, "MallocLargeCache", (char *)&stru_1000633B0);
    sub_10000B0B0(qword_100069B58, "MallocAggressiveMadvise", (char *)&stru_1000633F0);
    sub_10000B0B0(qword_100069B58, "MallocMediumZone", (char *)&stru_100063430);
    sub_10000B168(qword_100069B58, "MallocMaxMagazines", (char *)&stru_100063470);
    sub_10000B168(qword_100069B58, "ActiveSoftMemoryLimit", (char *)&stru_1000634B0);
    sub_10000B168(qword_100069B58, "ActiveHardMemoryLimit", (char *)&stru_1000634F0);
    sub_10000B168(qword_100069B58, "AddressLimit", (char *)&stru_100063530);
    sub_10000B168(qword_100069B58, "CPUMonitorInterval", (char *)&stru_100063570);
    sub_10000B168(qword_100069B58, "CPUMonitorPercentage", (char *)&stru_1000635B0);
    sub_10000B168(qword_100069B58, "SoftFileDescriptorLimit", (char *)&stru_1000635F0);
    sub_10000B168(qword_100069B58, "HardFileDescriptorLimit", (char *)&stru_100063630);
    sub_10000B168(qword_100069B58, "SoftKqWorkloopLimit", (char *)&stru_100063670);
    sub_10000B168(qword_100069B58, "HardKqWorkloopLimit", (char *)&stru_1000636B0);
    sub_10000B168(qword_100069B58, "InactiveSoftMemoryLimit", (char *)&stru_1000636F0);
    sub_10000B168(qword_100069B58, "InactiveHardMemoryLimit", (char *)&stru_100063730);
    sub_10000B168(qword_100069B58, "JetsamPriority", (char *)&stru_100063770);
    sub_10000B168(qword_100069B58, "LogicalWritesLimit", (char *)&stru_1000637B0);
    sub_10000B168(qword_100069B58, "SoftPortLimit", (char *)&stru_1000637F0);
    sub_10000B168(qword_100069B58, "HardPortLimit", (char *)&stru_100063830);
    sub_10000B168(qword_100069B58, "ThreadLimit", (char *)&stru_100063870);
    sub_10000B1B0(qword_100069B58, "EnergyEfficiencyMode", (char *)&stru_1000638B0);
    sub_10000B168(qword_100069B58, "WiredMemoryLimit", (char *)&stru_1000638F0);
    char v7 = (uint64_t *)qword_100069B58;
  }

  sub_10000B3CC(v7, v6, a2, a3, v5);
  return 1LL;
}

uint64_t sub_10000BFC8()
{
  return sub_10000B874((uint64_t)&stru_100063200);
}

void sub_10000BFD4(id a1, $B5BF7358088BABAD5B1E8071C31DCF54 *a2)
{
  a2->var1 &= ~4u;
}

void sub_10000BFE4()
{
  if (!qword_10006A988) {
    sub_100039448("sysctl hw.targettype was not set");
  }
  uint64_t v0 = sub_100036DB4("/System/Library/LaunchDaemons/com.apple.jetsamproperties.NonUI.plist");
  uint64_t v1 = sub_100012884( "%s.%s%s.plist",  "/AppleInternal/Library/LaunchDaemons/com.apple.jetsamproperties",  (const char *)qword_10006A988,  (const char *)qword_10006A990);
  uint64_t v2 = sub_100036DB4(v1);
  if (v2
    || (free(v1),
        v1 = sub_100012884( "%s.%s%s.plist",  "/System/Library/LaunchDaemons/com.apple.jetsamproperties",  (const char *)qword_10006A988,  (const char *)qword_10006A990),  (uint64_t v2 = sub_100036DB4(v1)) != 0LL))
  {
    uint64_t v3 = v2;
    if (v0) {
      sub_100039448( "both NonUI & target-specific JetsamProperties plists are present. This is an error in the OS build configuration.");
    }
  }

  else
  {
    free(v1);
    if (!v0) {
      return;
    }
    uint64_t v1 = "/System/Library/LaunchDaemons/com.apple.jetsamproperties.NonUI.plist";
    uint64_t v3 = v0;
  }

  qword_10006A8A8 = (uint64_t)v1;
  if (xpc_get_type(v3) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100039448("JetsamProperties plist is malformed");
  }
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(v3, "Version4");
  if (!dictionary) {
    sub_100039448("JetsamProperties plist is malformed - missing Version4 dictionary");
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_10000CC84;
  v5[3] = &unk_100063910;
  v5[4] = dictionary;
  sub_10000B874((uint64_t)v5);
  xpc_release(v3);
}

xpc_object_t sub_10000C16C(void *a1)
{
  string = (char *)xpc_dictionary_get_string(a1, "POSIXSpawnType");
  if (!string) {
    string = (char *)xpc_dictionary_get_string(a1, "ProcessType");
  }
  if (xpc_dictionary_get_BOOL(a1, "__Angel"))
  {
    unsigned int v3 = 1;
  }

  else if (sub_1000129FC(string, "Driver"))
  {
    unsigned int v3 = 3;
  }

  else
  {
    uint64_t v4 = xpc_dictionary_get_string(a1, "Label");
    if (!sub_100012944(v4, "lockdown.")
      && ((uint64_t v5 = xpc_dictionary_get_string(a1, "Label"), sub_100012944(v5, "UIKitApplication:"))
       || (uint64_t v6 = xpc_dictionary_get_string(a1, "Label"), sub_100012944(v6, "AlternateSystemApplication:"))))
    {
      if (sub_1000129FC(string, "SystemApp")) {
        unsigned int v3 = 7;
      }
      else {
        unsigned int v3 = 2;
      }
    }

    else
    {
      unsigned int v3 = 0;
    }
  }

  uint64_t v7 = v3;
  if ((*((_BYTE *)&unk_100069328 + 32 * v3 + 16) & 2) == 0) {
    sub_100039448("invalid jetsam property category type: 0x%x", v3);
  }
  char v8 = xpc_dictionary_get_string(a1, "_JetsamPropertiesIdentifier");
  if (v8) {
    goto LABEL_16;
  }
  int64_t v13 = xpc_dictionary_get_string(a1, "Label");
  if (sub_100012944(v13, "lockdown."))
  {
    uint64_t v14 = strchr(v13 + 9, 46);
    if (v14)
    {
      char v8 = v14 + 1;
LABEL_16:
      uint64_t v9 = sub_1000126A0(v8);
LABEL_17:
      uint64_t v10 = v9;
      goto LABEL_18;
    }
  }

  if (!sub_100012944(v13, "UIKitApplication:") && !sub_100012944(v13, "AlternateSystemApplication:"))
  {
    uint64_t v9 = strdup(v13);
    goto LABEL_17;
  }

  uint64_t v15 = strchr(v13, 58);
  uint64_t v10 = sub_1000126A0(v15 + 1);
  BOOL v16 = strrchr(v10, 91);
  if (v16)
  {
    *BOOL v16 = 0;
    uint64_t v17 = strrchr(v10, 91);
    if (v17) {
      *uint64_t v17 = 0;
    }
  }

xpc_object_t sub_10000C394(const void *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_apply_f(a2);
  uint64_t v7 = 0LL;
  char v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  if ((*(_BYTE *)(a3 + 16) & 4) != 0)
  {
    uint64_t v11 = 0LL;
    char v12 = 1;
    do
    {
      char v13 = v12;
      uint64_t v14 = *(rb_tree_t ***)(a3 + 8 * v11);
      uint64_t v15 = (uint64_t)sub_10003CB2C(v14, "Global");
      if (v15) {
        uint64_t v15 = sub_10003CD44(v15);
      }
      *((void *)&v28 + 2 * v11) = v15;
      uint64_t v16 = (uint64_t)sub_10003CB2C(v14, a1);
      if (v16) {
        uint64_t v16 = sub_10003CD44(v16);
      }
      char v12 = 0;
      *((void *)&v28 + 2 * v11 + 1) = v16;
      uint64_t v11 = 1LL;
    }

    while ((v13 & 1) != 0);
    uint64_t v10 = (void *)*((void *)&v29 + 1);
    uint64_t v9 = (void *)v29;
    char v8 = (void *)*((void *)&v28 + 1);
    uint64_t v7 = (void *)v28;
  }

  xpc_object_t v17 = xpc_dictionary_create(0LL, 0LL, 0LL);
  for (uint64_t i = 0LL; i != 28; ++i)
  {
    uint64_t v19 = (&off_100063950)[i];
    if (v10)
    {
      xpc_object_t value = xpc_dictionary_get_value(v10, (&off_100063950)[i]);
      if (!v9) {
        goto LABEL_16;
      }
    }

    else
    {
      xpc_object_t value = 0LL;
      if (!v9) {
        goto LABEL_16;
      }
    }

    if (!value) {
      xpc_object_t value = xpc_dictionary_get_value(v9, v19);
    }
LABEL_16:
    if (!value)
    {
      xpc_object_t v21 = xpc_dictionary_get_value(v6, v19);
      xpc_object_t value = v21;
      if (v8 && !v21) {
        xpc_object_t value = xpc_dictionary_get_value(v8, v19);
      }
      if (v7 && !value) {
        xpc_object_t value = xpc_dictionary_get_value(v7, v19);
      }
    }

    xpc_dictionary_set_value(v17, v19, value);
  }

  uint64_t v22 = 0LL;
  char v23 = 1;
  do
  {
    char v24 = v23;
    uint64_t v25 = &v28 + v22;
    __int128 v26 = (void *)*((void *)v25 + 1);
    if (v26) {
      xpc_release(v26);
    }
    if (*(void *)v25) {
      xpc_release(*(xpc_object_t *)v25);
    }
    char v23 = 0;
    uint64_t v22 = 1LL;
  }

  while ((v24 & 1) != 0);
  xpc_release(v6);
  return v17;
}

xpc_object_t sub_10000C5B8(const void *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
  if ((byte_1000693B8 & 2) == 0) {
    sub_100039448("invalid jetsam property category type: 0x%x", 4);
  }
  unsigned int v3 = v2;
  xpc_object_t v4 = sub_10000C394(a1, (uint64_t)v2, (uint64_t)&unk_1000693A8);
  xpc_release(v3);
  return v4;
}

xpc_object_t sub_10000C634(const void *a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "ServiceType");
  unsigned int v4 = 5;
  if (string)
  {
    if (!strcasecmp(string, "System")) {
      unsigned int v4 = 6;
    }
    else {
      unsigned int v4 = 5;
    }
  }

  unsigned int v5 = v4;
  xpc_object_t v6 = (char *)&unk_100069328 + 32 * v4;
  if ((v6[16] & 2) == 0) {
    sub_100039448("invalid jetsam property category type: 0x%x", v5);
  }
  xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_object_t v8 = sub_10000C394(a1, (uint64_t)v7, (uint64_t)v6);
  xpc_release(v7);
  return v8;
}

uint64_t sub_10000C6EC(uint64_t a1, char *__s1, void *a3)
{
  if (!sub_1000129FC(__s1, "Global") && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v6 = sub_10003CCD8((uint64_t)a3);
    uint64_t v7 = *(void *)(a1 + 32);
    if ((*(_BYTE *)(v7 + 16) & 4) == 0) {
      sub_100039448("jetsam property category (%s) is not initialized", *(const char **)(a1 + 40));
    }
    xpc_object_t v8 = v6;
    sub_10003CA78(*(void *)(v7 + 8LL * *(unsigned int *)(a1 + 48)), __s1, v6);
    sub_10001685C(v8);
  }

  return 1LL;
}

void sub_10000C7A4(void *a1, const char *a2, const char *a3, _BYTE *a4)
{
  int v8 = sub_10000C89C(a1, a2, a4);
  int v9 = sub_10000C89C(a1, a3, a4);
  int v10 = v9;
  if (v8 >= 1 && v9 >= 1)
  {
    if (v9 >= v8)
    {
      sub_100011A84(a4, 6LL, "%s is ignored in favor of %s", a3, a2);
    }

    else
    {
      sub_100011A84(a4, 6LL, "%s is ignored in favor of %s", a2, a3);
      a3 = a2;
    }

    goto LABEL_11;
  }

  if (v8 < 0)
  {
    xpc_dictionary_set_value(a1, a2, 0LL);
    if (v10 < 0) {
LABEL_11:
    }
      xpc_dictionary_set_value(a1, a3, 0LL);
  }

  else if (v9 < 0)
  {
    goto LABEL_11;
  }

int64_t sub_10000C89C(void *a1, const char *a2, _BYTE *a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    uint64_t v7 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
    {
      int64_t result = xpc_int64_get_value(v7);
      sub_100011A84(a3, 3LL, "%s is out of range, ignoring");
    }

    else
    {
      sub_100011A84(a3, 3LL, "%s is not an int, ignoring");
    }

    xpc_dictionary_set_value(a1, a2, 0LL);
  }

  return 0xFFFFFFFFLL;
}

void sub_10000C948(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 256LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFEFFLL | v4;
}

void sub_10000C968(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 512LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFFFFFFFFFFDFFLL | v4;
}

void sub_10000C988(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x400000000000LL;
  if (!a3) {
    uint64_t v4 = 0LL;
  }
  *((void *)&a2->var4 + 122) = *((void *)&a2->var4 + 122) & 0xFFFFBFFFFFFFFFFFLL | v4;
}

void sub_10000C9A8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_100003218((uint64_t)a2, "MallocSpaceEfficient", v4, 0);
}

void sub_10000C9D4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_100003218((uint64_t)a2, "MallocNanoZone", v4, 0);
}

void sub_10000CA00(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_100003218((uint64_t)a2, "MallocLargeCache", v4, 0);
}

void sub_10000CA2C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_100003218((uint64_t)a2, "MallocAggressiveMadvise", v4, 0);
}

void sub_10000CA58(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_100003218((uint64_t)a2, "MallocMediumZone", v4, 0);
}

void sub_10000CA84(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  if (a3 < 0)
  {
    sub_10001A4D8( (uint64_t)a2,  4,  "%s less than zero. Ignoring.",  (uint64_t)a4,  v4,  v5,  v6,  v7,  (char)"MallocMaxMagazines");
  }

  else if (HIDWORD(a3))
  {
    sub_10001A4D8((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"MallocMaxMagazines");
  }

  else
  {
    uint64_t v11 = sub_100012884("%u", a3);
    if (v11)
    {
      char v12 = v11;
      sub_100003218((uint64_t)a2, "MallocMaxMagazines", v11, 0);
      free(v12);
    }

    else
    {
      sub_100011A84(a4, 3LL, "Could not convert value for MallocMaxMagazines to str: %lld", a3);
    }
  }

void sub_10000CB60(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var57 = a3;
}

void sub_10000CB68(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var57 = a3;
  a2->var4.var55 |= 4u;
}

void sub_10000CB7C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var60 = a3;
}

void sub_10000CB84(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var75 = a3;
}

void sub_10000CB8C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var74 = a3;
}

void sub_10000CB94(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var63 = a3;
}

void sub_10000CB9C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var64 = a3;
}

void sub_10000CBA4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var65 = a3;
}

void sub_10000CBAC(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var66 = a3;
}

void sub_10000CBB4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var58 = a3;
}

void sub_10000CBBC(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var58 = a3;
  a2->var4.var55 |= 8u;
}

void sub_10000CBD0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var56 = a3;
}

void sub_10000CBD8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var71 = (int)a3;
}

void sub_10000CBE4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var61 = a3;
}

void sub_10000CBEC(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var62 = a3;
}

void sub_10000CBF4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var59 = a3;
}

void sub_10000CBFC(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (sub_100012A34(a3, "Efficient"))
  {
    a2->var4.var70 = 1LL;
  }

  else if (!sub_100012A34(a3, "UserInterface"))
  {
    sub_100011A84(a4, 3LL, "Unsupported value for EnergyEfficiencyMode: %s", a3);
  }

void sub_10000CC7C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var67 = a3;
}

void sub_10000CC84(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 16) & 4) != 0) {
    sub_100039448("found multiple jetsam property plists for category %s", *(const char **)(a2 + 24));
  }
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(*(xpc_object_t *)(a1 + 32), *(const char **)(a2 + 24));
  if (dictionary)
  {
    uint64_t v4 = dictionary;
    uint64_t v5 = 0LL;
    char v6 = 1;
    do
    {
      char v7 = v6;
      int v8 = off_100063220[v5];
      int v9 = sub_10003CBF8();
      *(void *)(a2 + 8 * v5) = v9;
      xpc_object_t v10 = xpc_dictionary_get_dictionary(v4, v8);
      if (v10)
      {
        uint64_t v11 = v10;
        if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
        {
          applier[0] = _NSConcreteStackBlock;
          applier[1] = 0x40000000LL;
          applier[2] = sub_10000CDC0;
          applier[3] = &unk_100063930;
          applier[4] = v9;
          xpc_dictionary_apply(v11, applier);
        }
      }

      char v6 = 0;
      uint64_t v5 = 1LL;
    }

    while ((v7 & 1) != 0);
    *(_DWORD *)(a2 + 16) |= 4u;
  }

  else
  {
    sub_10003AB08(65540, "did not initialize jetsam properties category: %s", *(const char **)(a2 + 24));
  }

uint64_t sub_10000CDC0(uint64_t a1, const void *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    char v6 = sub_10003CCD8((uint64_t)object);
    sub_10003CA78(*(void *)(a1 + 32), a2, v6);
    sub_10001685C(v6);
  }

  return 1LL;
}

void sub_10000CE38(char *a1, void *a2, void *a3)
{
  uint64_t v6 = 0LL;
  while (1)
  {
    char v7 = (&off_100063950)[v6];
    if (!strcasecmp(a1, v7)) {
      break;
    }
    if (++v6 == 28) {
      return;
    }
  }

  xpc_dictionary_set_value(a3, v7, a2);
}

void sub_10000CEB8(const char *a1)
{
  uint64_t v1 = sub_1000126A0(a1);
  if (qword_100069B68 != -1) {
    dispatch_once(&qword_100069B68, &stru_100063A50);
  }
  dispatch_sync_f((dispatch_queue_t)qword_100069B60, v1, (dispatch_function_t)sub_10000CF14);
}

void sub_10000CF14(char *__s)
{
  int v2 = dword_100069428;
  if (dword_100069428 == -1)
  {
    int v2 = open("/dev/console", 131073);
    dword_100069428 = v2;
  }

  ssize_t v3 = strlen(__s);
  if (write(v2, __s, v3) < v3 && *__error() == 5)
  {
    sub_100036D70((int *)dword_100069428);
    dword_100069428 = -1;
  }

  free(__s);
}

void sub_10000CFAC(char *a1, ...)
{
  context[0] = 0LL;
  va_copy((va_list)&context[1], va);
  if (vasprintf((char **)context, a1, va) != -1)
  {
    if (qword_100069B68 != -1) {
      dispatch_once(&qword_100069B68, &stru_100063A50);
    }
    dispatch_async_f((dispatch_queue_t)qword_100069B60, context[0], (dispatch_function_t)sub_10000CF14);
  }

void sub_10000D024(char *a1, ...)
{
  v1[0] = 0LL;
  va_copy((va_list)&v1[1], va);
  if (vasprintf((char **)v1, a1, va) != -1)
  {
    sub_10000CEB8((const char *)v1[0]);
    free(v1[0]);
  }

void sub_10000D06C(id a1)
{
  qword_100069B60 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.serialq", 0LL);
}

uint64_t sub_10000D094()
{
  return 49197LL;
}

uint64_t sub_10000D0A0()
{
  return sub_10000D094();
}

uint64_t sub_10000D0AC()
{
  return sub_10000D094();
}

double sub_10000D0D0()
{
  double result = 0.0;
  xmmword_100069C10 = 0u;
  unk_100069C20 = 0u;
  xmmword_100069BF0 = 0u;
  unk_100069C00 = 0u;
  xmmword_100069BD0 = 0u;
  unk_100069BE0 = 0u;
  xmmword_100069BB0 = 0u;
  unk_100069BC0 = 0u;
  xmmword_100069B90 = 0u;
  unk_100069BA0 = 0u;
  xmmword_100069B70 = 0u;
  unk_100069B80 = 0u;
  qword_100069C30 = 0LL;
  xmmword_10006942C = 0uLL;
  qword_10006943C = 0x7FFFFFFF00000000LL;
  unk_100069444 = 0LL;
  return result;
}

uint64_t sub_10000D114(uint64_t result, uint64_t a2)
{
  if (result)
  {
    char v2 = a2;
    ssize_t v3 = (__int128 *)result;
    if (a2 == 7)
    {
      if ((__int128 *)result != &xmmword_10006942C)
      {
        BOOL v4 = *(void *)result == (void)xmmword_10006942C
          && *(void *)(result + 8) == *((void *)&xmmword_10006942C + 1);
        BOOL v5 = v4 && *(void *)(result + 16) == qword_10006943C;
        if (!v5 || *(void *)(result + 24) != unk_100069444)
        {
          if ((sub_10000D260(result) & 0x80) == 0) {
            return 0LL;
          }
          __int128 v16 = v3[1];
          xmmword_10006942C = *v3;
          *(_OWORD *)&qword_10006943C = v16;
        }
      }

      return 1LL;
    }

    else
    {
      uint64_t v7 = 0LL;
      while (1)
      {
        if (BYTE8(xmmword_100069B70[3 * ((qword_100069C30 + v7) & 3) + 2]))
        {
          int v8 = (void *)&xmmword_100069B70[3 * ((qword_100069C30 + v7) & 3)] + 1;
          if (v8 == (void *)result) {
            break;
          }
          BOOL v9 = *(void *)result == *v8
            && *(void *)(result + 8) == *(void *)&xmmword_100069B70[3
                                                                      * ((qword_100069C30
          BOOL v10 = v9
             && *(void *)(result + 16) == *((void *)&xmmword_100069B70[3
                                                                         * ((qword_100069C30
                                                                           + v7) & 3)
                                                                         + 1]
                                            + 1);
          if (v10
            && *(void *)(result + 24) == *(void *)&xmmword_100069B70[3
                                                                       * ((qword_100069C30
                                                                         + v7) & 3)
                                                                       + 2])
          {
            break;
          }
        }

        if (++v7 == 4)
        {
          unint64_t v12 = sub_10000D260(result);
          qword_100069C30 = ((_BYTE)qword_100069C30 - 1) & 3;
          char v13 = &xmmword_100069B70[3 * qword_100069C30];
          __int128 v14 = v3[1];
          *(__int128 *)((char *)v13 + 8) = *v3;
          *(__int128 *)((char *)v13 + 24) = v14;
          *(void *)char v13 = v12;
          *((_BYTE *)v13 + 40) = 1;
          unint64_t v15 = v12 >> v2;
          return v15 & 1;
        }
      }

      unint64_t v15 = *(void *)&xmmword_100069B70[3 * ((qword_100069C30 + v7) & 3)] >> a2;
      return v15 & 1;
    }
  }

  return result;
}

uint64_t sub_10000D260(uint64_t a1)
{
  xpc_object_t v1 = sub_10003A4FC(a1);
  if (!v1) {
    return 0LL;
  }
  char v2 = v1;
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
  do
  {
    xpc_object_t value = xpc_dictionary_get_value(v2, off_100063A70[v3]);
    if (value)
    {
      uint64_t v6 = value;
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(v6)) {
        v4 |= 1LL << v3;
      }
    }

    ++v3;
  }

  while (v3 != 39);
  xpc_release(v2);
  return v4;
}

uint64_t sub_10000D30C(unsigned int *a1)
{
  unsigned int v1 = *a1;
  if (*a1 >= 2) {
    sub_10004700C(v1 == 1);
  }
  uint64_t v7 = 0LL;
  HIDWORD(v3) = a1[6];
  LODWORD(v3) = HIDWORD(v3) - 256;
  int v4 = 512;
  switch((v3 >> 8))
  {
    case 0u:
    case 3u:
      int v4 = 1024;
      break;
    case 4u:
      break;
    case 5u:
      int v4 = 768;
      break;
    case 6u:
      if (*((_BYTE *)a1 + 48)) {
        int v4 = 256;
      }
      else {
        int v4 = 1024;
      }
      break;
    default:
      int v4 = 0;
      break;
  }

  uint64_t v5 = v4 | (16 * (v1 & 0xF));
  if (v1 == 1)
  {
    if (*((void *)a1 + 4)) {
      uint64_t v5 = v5 | 2;
    }
    else {
      uint64_t v5 = v5;
    }
  }

  return v7;
}

uint64_t sub_10000D404(uint64_t a1)
{
  uint64_t result = coalition_terminate(a1, 0LL);
  if ((_DWORD)result == -1) {
    return sub_100047024();
  }
  return result;
}

uint64_t sub_10000D42C(uint64_t a1)
{
  uint64_t result = coalition_reap(a1, 0LL);
  if ((_DWORD)result == -1) {
    return sub_100047024();
  }
  return result;
}

uint64_t sub_10000D454(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = posix_spawnattr_setcoalition_np(a2, *(void *)a4, a3, *(unsigned int *)(a4 + 8));
  if ((_DWORD)result) {
    return _os_assumes_log_ctx(sub_10001C1B0, a1);
  }
  return result;
}

void sub_10000D4A0(uint64_t a1)
{
  char v2 = *(dispatch_object_s **)(a1 + 72);
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = *(dispatch_object_s **)(a1 + 248);
  if (v3) {
    dispatch_release(v3);
  }
  int v4 = *(void **)(a1 + 80);
  if (v4) {
    xpc_release(v4);
  }
  uint64_t v5 = *(void **)(a1 + 88);
  if (v5) {
    xpc_release(v5);
  }
  _Block_release(*(const void **)(a1 + 256));
}

uint64_t sub_10000D4F8()
{
  uint64_t v0 = (dispatch_queue_s *)sub_100011950();
  qword_100069C38 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v0);
  dispatch_source_set_timer((dispatch_source_t)qword_100069C38, 0LL, 1000000000LL * dword_100069A58, 0LL);
  dispatch_source_set_event_handler_f((dispatch_source_t)qword_100069C38, (dispatch_function_t)j__sync);
  dispatch_activate((dispatch_object_t)qword_100069C38);
  qword_10006A8B0 = (uint64_t)dispatch_semaphore_create(10LL);
  uint64_t v1 = setiopolicy_np(9, 0, 1);
  if ((_DWORD)v1) {
    uint64_t v1 = _os_assumes_log((int)v1);
  }
  return nullsub_23(v1, v2);
}

void sub_10000D5A4()
{
  block = _NSConcreteStackBlock;
  uint64_t v3 = 0x40000000LL;
  int v4 = sub_10000D824;
  uint64_t v5 = &unk_100063BA8;
  dispatch_queue_t v6 = (dispatch_queue_t)sub_100011944();
  dispatch_sync(v6, &block);
  uint64_t v0 = (dispatch_queue_s *)sub_100011950();
  block = _NSConcreteStackBlock;
  uint64_t v3 = 0x40000000LL;
  int v4 = sub_10000D824;
  uint64_t v5 = &unk_100063BA8;
  dispatch_queue_t v6 = v0;
  dispatch_sync(v0, &block);
  uint64_t v1 = (dispatch_queue_s *)sub_10001195C();
  block = _NSConcreteStackBlock;
  uint64_t v3 = 0x40000000LL;
  int v4 = sub_10000D824;
  uint64_t v5 = &unk_100063BA8;
  dispatch_queue_t v6 = v1;
  dispatch_sync(v1, &block);
}

uint64_t sub_10000D648()
{
  return qword_10006A8B0;
}

_BYTE *sub_10000D654(char a1, uint64_t a2)
{
  int v4 = sub_100016E94(0LL);
  v4[56] = a1;
  if (a2)
  {
    uint64_t v5 = (const char *)xpc_bundle_copy_normalized_cryptex_path(a2);
    *((void *)v4 + 8) = v5;
    if (sub_100015ABC(v5)) {
      char v6 = 4;
    }
    else {
      char v6 = 0;
    }
    v4[264] = v4[264] & 0xFB | v6;
  }

  return v4;
}

_BYTE *sub_10000D6C0(int a1, uint64_t a2, int a3)
{
  uint64_t result = sub_10000D654(a1, a2);
  if (a1 == 4) {
    *((_DWORD *)result + 60) = a3;
  }
  return result;
}

void sub_10000D6F0(uint64_t a1, dispatch_object_t object, const void *a3)
{
  *(void *)(a1 + 248) = object;
  *(void *)(a1 + 256) = _Block_copy(a3);
  if (*(_BYTE *)(a1 + 56) == 4 || (*(_BYTE *)(a1 + 264) & 1) != 0) {
    goto LABEL_7;
  }
  if (!sub_1000162B8()) {
    goto LABEL_9;
  }
  if (!sub_100015ABC(*(const char **)(a1 + 64)))
  {
    if ((*(_BYTE *)(a1 + 264) & 4) != 0) {
      sub_100039448("refusing to read cache protected location from disk: %s", *(const char **)(a1 + 64));
    }
LABEL_9:
    sub_100011AF8(a1);
    return;
  }

  int v6 = sub_100015B0C(a1);
  if (v6)
  {
    *(_DWORD *)(a1 + 240) = v6;
LABEL_7:
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
    (*(void (**)(void))(*(void *)(a1 + 256) + 16LL))();
  }

uint64_t sub_10000D7D4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t sub_10000D7DC(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_10000D7E4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 264) & 1;
}

uint64_t sub_10000D7F0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 264) >> 2) & 1;
}

xpc_object_t sub_10000D7FC(uint64_t a1)
{
  xpc_object_t result = *(xpc_object_t *)(a1 + 88);
  if (result) {
    return xpc_retain(result);
  }
  return result;
}

uint64_t sub_10000D80C(uint64_t a1)
{
  return a1 + 96;
}

uint64_t sub_10000D814(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_10000D81C(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

void sub_10000D824(uint64_t a1)
{
}

BOOL sub_10000D82C(const char *a1, char *__s)
{
  size_t v4 = strlen(__s);
  return sysctlbyname(a1, 0LL, 0LL, __s, v4 + 1) == 0;
}

void *sub_10000D874(const char *a1)
{
  uint64_t v3 = 0LL;
  size_t v1 = sub_100039AB8(a1, (char **)&v3);
  xpc_object_t result = v3;
  if (v1)
  {
    if (!v3) {
      sub_100046EC8();
    }
  }

  else
  {
    free(v3);
    return 0LL;
  }

  return result;
}

uint64_t sub_10000D8B8(const char *a1)
{
  uint64_t v2 = 0LL;
  if (sub_100039C44(a1, &v2) == 8) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void *sub_10000D8E8(size_t a1)
{
  if (!a1) {
    sub_100046EB4();
  }
  uint64_t v2 = sub_100010B00(0x18uLL);
  uint64_t v3 = sub_100010B00(a1);
  *uint64_t v3 = 0;
  *uint64_t v2 = v3;
  v2[1] = a1;
  v2[2] = 0LL;
  return v2;
}

char *sub_10000D930(const char **a1)
{
  return sub_1000126A0(*a1);
}

void sub_10000D938(void **a1)
{
}

void sub_10000D960( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __source[0] = 0LL;
  __source[1] = &a9;
  int v10 = vasprintf(__source, a2, &a9);
  if (v10 == -1)
  {
    sub_100047024();
    return;
  }

  uint64_t v11 = *(void *)(a1 + 16);
  BOOL v12 = __CFADD__(v11, v10);
  unint64_t v13 = v11 + v10;
  if (v12) {
    uint64_t v14 = ((uint64_t)v10 >> 63) + 1;
  }
  else {
    uint64_t v14 = (uint64_t)v10 >> 63;
  }
  uint64_t v15 = v14 << 63 >> 63;
  if (v15 != v14 || v15 < 0) {
    goto LABEL_20;
  }
  unint64_t v16 = *(void *)(a1 + 8);
  if (v16 <= v13)
  {
    if ((v13 & 0x8000000000000000LL) == 0)
    {
      size_t v18 = 2 * v13;
      if (2 * v13 < 2 * v16) {
        sub_100046EB4();
      }
      xpc_object_t v17 = (char *)sub_100010B00(2 * v13);
      free(*(void **)a1);
      *(void *)a1 = v17;
      *(void *)(a1 + 8) = v18;
      goto LABEL_13;
    }

void *sub_10000DA60(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  BOOL v3 = v2 >= a2;
  unint64_t v4 = v2 - a2;
  if (!v3) {
    sub_100046EB4();
  }
  result[2] = v4;
  *(_BYTE *)(*result + v4) = 0;
  return result;
}

uint64_t sub_10000DA8C(__int128 *a1)
{
  __int128 v2 = a1[1];
  __int128 v5 = *a1;
  __int128 v6 = v2;
  __int128 v7 = a1[2];
  uint64_t v8 = *((void *)a1 + 6);
  __int128 v3 = a1[1];
  __int128 v5 = *a1;
  __int128 v6 = v3;
  __int128 v7 = a1[2];
  uint64_t v8 = *((void *)a1 + 6);
  return sub_10000DAFC((uint64_t *)&v5);
}

uint64_t sub_10000DAFC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  __int128 v3 = *((_OWORD *)a1 + 1);
  __int128 v22 = *(_OWORD *)a1;
  __int128 v23 = v3;
  __int128 v24 = *((_OWORD *)a1 + 2);
  uint64_t v25 = a1[6];
  switch(sub_100044E90((uint64_t)&v22, 0LL))
  {
    case 1u:
      __int128 v18 = *(_OWORD *)a1;
      __int128 v19 = *((_OWORD *)a1 + 1);
      __int128 v20 = *((_OWORD *)a1 + 2);
      uint64_t v21 = a1[6];
      xpc_object_t empty = xpc_dictionary_create_empty();
      goto LABEL_4;
    case 2u:
      __int128 v18 = *(_OWORD *)a1;
      __int128 v19 = *((_OWORD *)a1 + 1);
      __int128 v20 = *((_OWORD *)a1 + 2);
      uint64_t v21 = a1[6];
      xpc_object_t empty = xpc_array_create_empty();
LABEL_4:
      uint64_t v5 = (uint64_t)empty;
      __int128 v22 = v18;
      __int128 v23 = v19;
      __int128 v24 = v20;
      uint64_t v25 = v21;
      sub_100044F94((unint64_t)&v22, (uint64_t)empty, (uint64_t)sub_10000DD68);
      goto LABEL_10;
    case 3u:
      __int128 v6 = *((_OWORD *)a1 + 1);
      __int128 v22 = *(_OWORD *)a1;
      __int128 v23 = v6;
      __int128 v24 = *((_OWORD *)a1 + 2);
      uint64_t v25 = a1[6];
      int64_t v7 = sub_1000452BC((uint64_t)&v22);
      xpc_object_t no_copy = xpc_int64_create(v7);
      goto LABEL_9;
    case 4u:
      __int128 v9 = *((_OWORD *)a1 + 1);
      __int128 v22 = *(_OWORD *)a1;
      __int128 v23 = v9;
      __int128 v24 = *((_OWORD *)a1 + 2);
      uint64_t v25 = a1[6];
      int v10 = sub_10000E028((uint64_t)&v22);
      xpc_object_t no_copy = (xpc_object_t)xpc_string_create_no_copy(v10);
      goto LABEL_9;
    case 5u:
      __int128 v11 = *((_OWORD *)a1 + 1);
      __int128 v22 = *(_OWORD *)a1;
      __int128 v23 = v11;
      __int128 v24 = *((_OWORD *)a1 + 2);
      uint64_t v25 = a1[6];
      char v12 = sub_100045490((uint64_t)&v22);
      xpc_object_t no_copy = xpc_BOOL_create(v12);
      goto LABEL_9;
    case 6u:
      __int128 v13 = *((_OWORD *)a1 + 1);
      __int128 v22 = *(_OWORD *)a1;
      __int128 v23 = v13;
      __int128 v24 = *((_OWORD *)a1 + 2);
      uint64_t v25 = a1[6];
      uint64_t v14 = (const void *)sub_100045574((uint64_t)&v22);
      xpc_object_t no_copy = xpc_data_create(v14, v15);
LABEL_9:
      uint64_t v5 = (uint64_t)no_copy;
LABEL_10:
      uint64_t result = v5;
      break;
    default:
      uint64_t v17 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))( v2,  "[%s]: %s\n",  "_objectForActiveContext",  "CoreEntitlements: unknown DER type");
      uint64_t result = xpc_create_from_ce_der(v17);
      break;
  }

  return result;
}

uint64_t xpc_create_from_ce_der(unint64_t a1, uint64_t a2)
{
  __int128 v12 = 0uLL;
  uint64_t v13 = 0LL;
  uint64_t v2 = (void *)sub_100045628((uint64_t)&unk_100063BC8, (uint64_t *)&v12, a1, a1 + a2);
  uint64_t result = 0LL;
  if (v2 == &unk_100065C48)
  {
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v8 = 0u;
    __int128 v9 = 0u;
    __int128 v4 = v12;
    *(void *)&__int128 v5 = v13;
    if ((_UNKNOWN *)sub_1000459A8((uint64_t)&unk_100063BC8, &v4, (uint64_t)&v8) == &unk_100065C48)
    {
      __int128 v4 = v8;
      __int128 v5 = v9;
      __int128 v6 = v10;
      uint64_t v7 = v11;
      return sub_10000DA8C(&v4);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10000DD68(uint64_t *a1)
{
  uint64_t v2 = *a1;
  int v3 = *((_DWORD *)a1 + 29);
  if (v3 == 2)
  {
    if (*((_DWORD *)a1 + 28) == 1)
    {
      uint64_t v7 = (void *)a1[15];
      __int128 v14 = *(_OWORD *)(a1 + 7);
      __int128 v15 = *(_OWORD *)(a1 + 9);
      __int128 v16 = *(_OWORD *)(a1 + 11);
      uint64_t v17 = a1[13];
      uint64_t v25 = 0LL;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v22 = 0u;
      memset((char *)v26 + 8, 0, 248);
      __int128 v8 = *(_OWORD *)(a1 + 9);
      v20[0] = *(_OWORD *)(a1 + 7);
      v20[1] = v8;
      v20[2] = *(_OWORD *)(a1 + 11);
      uint64_t v21 = a1[13];
      *(void *)&v26[0] = 2LL;
      sub_100044E34((uint64_t)v20, (unint64_t)v26, (uint64_t)&v22);
      v26[0] = v22;
      v26[1] = v23;
      v26[2] = v24;
      *(void *)&v26[3] = v25;
      __int128 v9 = (char *)sub_10000E028((uint64_t)v26);
      v18[0] = v14;
      v18[1] = v15;
      _OWORD v18[2] = v16;
      uint64_t v19 = v17;
      v26[0] = xmmword_100049420;
      memset(&v26[1], 0, 240);
      sub_100044E34((uint64_t)v18, (unint64_t)v26, (uint64_t)v20);
      xpc_object_t empty = (xpc_object_t)sub_10000DAFC(v20);
      xpc_dictionary_set_value(v7, v9, empty);
      free(v9);
    }

    else
    {
      xpc_object_t empty = xpc_array_create_empty();
      __int128 v11 = *(_OWORD *)(a1 + 9);
      v26[0] = *(_OWORD *)(a1 + 7);
      v26[1] = v11;
      v26[2] = *(_OWORD *)(a1 + 11);
      *(void *)&v26[3] = a1[13];
      if ((_UNKNOWN *)sub_100044F94((unint64_t)v26, (uint64_t)empty, (uint64_t)sub_10000DD68) != &unk_100065C48)
      {
        uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))( v2,  "[%s]: %s\n",  "_manufacturingCallback",  "CoreEntitlements: Couldn't iterate over DER entitlements\n");
        return (uint64_t)sub_10000E028(v13);
      }

      xpc_array_set_value((xpc_object_t)a1[15], 0xFFFFFFFFFFFFFFFFLL, empty);
    }

    __int128 v6 = empty;
    goto LABEL_10;
  }

  if (v3)
  {
    if (*((_DWORD *)a1 + 28) == 2)
    {
      __int128 v4 = *(_OWORD *)(a1 + 9);
      v26[0] = *(_OWORD *)(a1 + 7);
      v26[1] = v4;
      v26[2] = *(_OWORD *)(a1 + 11);
      *(void *)&v26[3] = a1[13];
      __int128 v5 = (void *)sub_10000DAFC(v26);
      xpc_array_set_value((xpc_object_t)a1[15], 0xFFFFFFFFFFFFFFFFLL, v5);
      __int128 v6 = v5;
LABEL_10:
      xpc_release(v6);
      return 1LL;
    }

    uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))( v2,  "[%s]: %s\n",  "_manufacturingCallback",  "CoreEntitlements: not a sequence");
  }

  else
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))( v2,  "[%s]: %s\n",  "_manufacturingCallback",  "CoreEntitlements: unknown DER type");
  }

  return (uint64_t)sub_10000E028(v13);
}

void *sub_10000E028(uint64_t a1)
{
  __int128 v1 = *(_OWORD *)(a1 + 16);
  v7[0] = *(_OWORD *)a1;
  v7[1] = v1;
  v7[2] = *(_OWORD *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v2 = (const void *)sub_1000453DC((uint64_t)v7);
  size_t v4 = v3;
  __int128 v5 = sub_100010B00(v3 + 1);
  memcpy(v5, v2, v4);
  return v5;
}

void *sub_10000E094(int a1, size_t __size)
{
  return malloc(__size);
}

void sub_10000E09C(int a1, void *a2)
{
}

void sub_10000E0A4( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_10000E0D0( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  qword_100069AA0 = (uint64_t)"Data corruption: CoreEntitlements has aborted due to an unrecoverable error";
  __break(1u);
}

void sub_10000E110()
{
  qword_100069C40 = 0LL;
}

void sub_10000E11C()
{
  uint64_t v0 = (char *)sub_10000E274("ReleaseType");
  sub_10000E390("kern.osreleasetype", v0);
  if (byte_10006A9B8)
  {
    __int128 v1 = (char *)sub_10000D874("kern.osversion");
    if (v1)
    {
      uint64_t v2 = v1;
      size_t v3 = sub_10000E274("ProductBuildVersion");
      if (v3)
      {
        size_t v4 = v3;
        if (!sub_1000129FC(v2, v3)) {
          sub_1000394A4("Userspace reboot changed system version: previous %s != current %s", v2, v4);
        }
        free(v2);
      }

      else
      {
        sub_10003AB08(65539, "Missing ProductBuildVersion");
      }
    }

    else
    {
      uint64_t v7 = __error();
      sub_10003AB08(65539, "Unable to reload kern.osversion: %d", *v7);
    }
  }

  else
  {
    __int128 v5 = (char *)sub_10000E274("ProductVersion");
    sub_10000E390("kern.osproductversion", v5);
    __int128 v6 = (char *)sub_10000E274("ProductBuildVersion");
    sub_10000E390("kern.osversion", v6);
  }

const char *sub_10000E248()
{
  uint64_t result = sub_10000E274("ProductBuildVersion");
  if (!result) {
    return "99Z999";
  }
  return result;
}

const char *sub_10000E274(char *key)
{
  if (!qword_100069C40)
  {
    uint64_t v2 = sub_100036DB4("/System/Library/CoreServices/SystemVersion.plist");
    if (qword_100069C40) {
      sub_100046EC8();
    }
    size_t v3 = v2;
    xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
    qword_100069C40 = (uint64_t)v4;
    if (v3)
    {
      sub_10000E40C(v4, v3, "ProductVersion");
      sub_10000E40C((void *)qword_100069C40, v3, "ProductBuildVersion");
      sub_10000E40C((void *)qword_100069C40, v3, "iOSSupportVersion");
      sub_10000E40C((void *)qword_100069C40, v3, "ReleaseType");
      xpc_object_t v4 = (xpc_object_t)qword_100069C40;
    }

    if (!xpc_dictionary_get_string(v4, "ReleaseType")) {
      xpc_dictionary_set_string((xpc_object_t)qword_100069C40, "ReleaseType", "User");
    }
    if (v3) {
      xpc_release(v3);
    }
  }

  return xpc_dictionary_get_string((xpc_object_t)qword_100069C40, key);
}

BOOL sub_10000E364(const char *a1)
{
  uint64_t v2 = sub_10000E274("ReleaseType");
  return sub_1000129E0(v2, a1);
}

void sub_10000E390(const char *a1, char *a2)
{
  if (a2)
  {
    xpc_object_t v4 = (unsigned __int8 *)sub_10000D874(a1);
    if (v4 && (int v5 = *v4, free(v4), v5))
    {
      sub_10003AB08(4, "%s is already set, skipping", a1);
    }

    else if (!sub_10000D82C(a1, a2))
    {
      sub_100047040(a1);
    }
  }

void sub_10000E40C(void *a1, xpc_object_t xdict, char *key)
{
  string = xpc_dictionary_get_string(xdict, key);
  if (string) {
    xpc_dictionary_set_string(a1, key, string);
  }
}

void *sub_10000E454()
{
  uint64_t v0 = sub_100016C9C(0LL);
  v0[4] = 8LL;
  v0[2] = sub_100010B00(0x40uLL);
  return v0;
}

void sub_10000E490(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    unint64_t v2 = 0LL;
    do
      os_release(*(void **)(*(void *)(a1 + 16) + 8 * v2++));
    while (v2 < *(void *)(a1 + 24));
  }

  free(*(void **)(a1 + 16));
}

void *sub_10000E4D8(void *result, void *object)
{
  size_t v3 = result;
  unint64_t v4 = result[3];
  unint64_t v5 = result[4];
  if (v4 == v5)
  {
    result[4] = 2 * v4;
    if ((v4 & 0x8000000000000000LL) != 0 || (2 * v4) >> 61 || (uint64_t result = sub_100010B00(16 * v4), v6 = v3[3], v6 >> 61))
    {
      __break(1u);
      return result;
    }

    uint64_t v7 = result;
    uint64_t v8 = (void *)v3[2];
    memcpy(result, v8, 8 * v6);
    free(v8);
    v3[2] = v7;
    unint64_t v4 = v3[3];
    unint64_t v5 = v3[4];
  }

  if (v4 >= v5) {
    sub_100046EB4();
  }
  uint64_t result = os_retain(object);
  uint64_t v9 = v3[3];
  *(void *)(v3[2] + 8 * v9) = result;
  v3[3] = v9 + 1;
  return result;
}

void sub_10000E580(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 24) <= a2) {
    sub_100046EB4();
  }
  os_release(*(void **)(*(void *)(a1 + 16) + 8 * a2));
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(*(void *)(a1 + 16) + 8 * a2) = 0LL;
  *(void *)(a1 + 24) = v4 - 1;
  if (v4 - 1 > a2) {
    memmove( (void *)(*(void *)(a1 + 16) + 8 * a2),  (const void *)(*(void *)(a1 + 16) + 8 * a2 + 8),  8 * (v4 - 1 - a2));
  }
}

uint64_t sub_10000E5F0(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 24) <= a2) {
    sub_100046EB4();
  }
  return *(void *)(*(void *)(a1 + 16) + 8 * a2);
}

uint64_t sub_10000E618(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_10000E624(uint64_t a1)
{
  return kdebug_trace(a1, 0LL, 0LL, 0LL, 0LL);
}

uint64_t sub_10000E638(uint64_t a1, uint64_t a2)
{
  return kdebug_trace(a1, a2, 0LL, 0LL, 0LL);
}

uint64_t sub_10000E648(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return kdebug_trace(a1, a2, a3, 0LL, 0LL);
}

uint64_t sub_10000E654(uint64_t a1, const char *a2)
{
  return kdebug_trace(a1, *(void *)__dst, v5, v6, v7);
}

uint64_t sub_10000E6C0(void *a1)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000LL;
  xpc_object_t empty = 0LL;
  xpc_object_t empty = xpc_array_create_empty();
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000LL;
  applier[2] = sub_10000E834;
  applier[3] = &unk_100063C18;
  applier[4] = &v12;
  xpc_dictionary_apply(a1, applier);
  size_t count = xpc_array_get_count((xpc_object_t)v13[3]);
  do
  {
    if (count < 2) {
      break;
    }
    size_t v3 = 0LL;
    for (size_t i = 1LL; i != count; ++i)
    {
      xpc_object_t value = xpc_array_get_value((xpc_object_t)v13[3], i - 1);
      xpc_object_t v6 = xpc_array_get_value((xpc_object_t)v13[3], i);
      string_ptr = xpc_string_get_string_ptr(value);
      uint64_t v8 = xpc_string_get_string_ptr(v6);
      if (strcmp(string_ptr, v8) >= 1)
      {
        xpc_retain(value);
        xpc_array_set_value((xpc_object_t)v13[3], i - 1, v6);
        xpc_array_set_value((xpc_object_t)v13[3], i, value);
        xpc_release(value);
        size_t v3 = i;
      }
    }

    size_t count = v3;
  }

  while (v3);
  uint64_t v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t sub_10000E834(uint64_t a1, char *string)
{
  return 1LL;
}

xpc_object_t sub_10000E860(int64_t a1, int64_t a2, xpc_object_t object)
{
  if (object && xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0LL;
  }
  xpc_object_t empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_int64(empty, "vers", a1);
  xpc_dictionary_set_int64(empty, "comp", 1LL);
  xpc_dictionary_set_int64(empty, "ccat", a2);
  if (object) {
    xpc_dictionary_set_value(empty, "reqs", object);
  }
  return empty;
}

size_t sub_10000E90C(void *a1)
{
  if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0LL;
  }
  xpc_object_t empty = xpc_array_create_empty();
  if (sub_10000ED28(a1, empty))
  {
    xpc_release(empty);
    return 0LL;
  }

  if (!empty) {
    return 0LL;
  }
  size_t result = xpc_array_get_count(empty);
  if (!(result >> 59))
  {
    uint64_t v5 = (char *)sub_100010B00(32 * result);
    length[0] = (size_t)_NSConcreteStackBlock;
    length[1] = 0x40000000LL;
    length[2] = (size_t)sub_10000F384;
    length[3] = (size_t)&unk_100063C88;
    length[4] = (size_t)v5;
    xpc_array_apply(empty, length);
    size_t count = xpc_array_get_count(empty);
    length[0] = 0LL;
    xpc_object_t v3 = 0LL;
    if (sub_100043988(v5, count, length) == (char *)&unk_100065C48)
    {
      uint64_t v7 = sub_100010B00(length[0]);
      char v12 = 1;
      if ((_UNKNOWN *)sub_100043A64( (uint64_t)&unk_100063BC8,  &v12,  (unint64_t)v5,  count,  (unint64_t)v7,  (unint64_t)v7 + length[0]) == &unk_100065C48) {
        xpc_object_t v3 = xpc_data_create(v7, length[0]);
      }
      else {
        xpc_object_t v3 = 0LL;
      }
      free(v7);
    }

    size_t v8 = xpc_array_get_count(empty);
    if (v8)
    {
      size_t v9 = v8;
      __int128 v10 = (void **)(v5 + 8);
      do
      {
        v10 += 4;
        --v9;
      }

      while (v9);
    }

    free(v5);
    xpc_release(empty);
    return (size_t)v3;
  }

  __break(1u);
  return result;
}

uint64_t sub_10000EAC4(unint64_t a1, uint64_t a2)
{
  __int128 v13 = 0uLL;
  uint64_t v14 = 0LL;
  char v12 = 1;
  unint64_t v2 = (void *)sub_100045664((uint64_t)&unk_100063BC8, &v12, (uint64_t *)&v13, a1, a1 + a2);
  uint64_t result = 0LL;
  if (v2 == &unk_100065C48)
  {
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v8 = 0u;
    __int128 v9 = 0u;
    __int128 v4 = v13;
    *(void *)&__int128 v5 = v14;
    if ((_UNKNOWN *)sub_1000459A8((uint64_t)&unk_100063BC8, &v4, (uint64_t)&v8) == &unk_100065C48)
    {
      __int128 v4 = v8;
      __int128 v5 = v9;
      __int128 v6 = v10;
      uint64_t v7 = v11;
      return sub_10000DA8C(&v4);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

size_t sub_10000EB94(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  *((void *)&v15 + 1) = 0LL;
  xpc_object_t v6 = sub_10000ECB4(a1, a2, (int64_t *)&v15 + 1);
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = v6;
  *(void *)&__int128 v15 = 0LL;
  xpc_object_t v8 = sub_10000ECB4(a3, a4, (int64_t *)&v15);
  if (v8)
  {
    __int128 v9 = v8;
    if (v15 == 0)
    {
      xpc_object_t empty = xpc_dictionary_create_empty();
      xpc_dictionary_set_value(empty, "$and", v9);
      xpc_object_t v12 = xpc_dictionary_create_empty();
      xpc_dictionary_set_value(v12, "$and", v7);
      xpc_dictionary_set_value(v12, "$or", empty);
      xpc_release(empty);
      xpc_object_t v13 = sub_10000E860(1LL, 0LL, v12);
      xpc_release(v12);
      size_t v10 = sub_10000E90C(v13);
      xpc_release(v13);
    }

    else
    {
      size_t v10 = 0LL;
    }

    xpc_release(v7);
  }

  else
  {
    size_t v10 = 0LL;
    __int128 v9 = v7;
  }

  xpc_release(v9);
  return v10;
}

xpc_object_t sub_10000ECB4(unint64_t a1, uint64_t a2, int64_t *a3)
{
  __int128 v4 = (void *)sub_10000EAC4(a1, a2);
  if (!v4) {
    return 0LL;
  }
  __int128 v5 = v4;
  xpc_object_t value = xpc_dictionary_get_value(v4, "reqs");
  xpc_object_t v7 = value;
  if (value) {
    xpc_retain(value);
  }
  *a3 = xpc_dictionary_get_int64(v5, "ccat");
  xpc_release(v5);
  return v7;
}

uint64_t sub_10000ED28(void *a1, void *a2)
{
  uint64_t v8 = 0LL;
  __int128 v9 = &v8;
  uint64_t v10 = 0x2000000000LL;
  int v11 = 4;
  __int128 v4 = (void *)sub_10000E6C0(a1);
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t bytes = 7LL;
  uint64_t v13 = 0LL;
  xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000LL;
  applier[2] = sub_10000EE28;
  applier[3] = &unk_100063C40;
  void applier[5] = a2;
  void applier[6] = a1;
  applier[4] = &v8;
  xpc_array_apply(v4, applier);
  xpc_release(v4);
  uint64_t v5 = *((unsigned int *)v9 + 6);
  if (!(_DWORD)v5)
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t bytes = 8LL;
    uint64_t v13 = 0LL;
    xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
    uint64_t v5 = *((unsigned int *)v9 + 6);
  }

  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t sub_10000EE28(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void **)(a1 + 40);
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t bytes = 5LL;
  uint64_t v21 = 0LL;
  xpc_array_set_data(v5, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
  string_ptr = xpc_string_get_string_ptr(a3);
  v17[3] = 0LL;
  v17[0] = 3LL;
  v17[1] = sub_1000126A0(string_ptr);
  v17[2] = xpc_string_get_length(a3);
  xpc_array_set_data(*(xpc_object_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, v17, 0x20uLL);
  xpc_object_t v7 = *(void **)(a1 + 48);
  uint64_t v8 = xpc_string_get_string_ptr(a3);
  xpc_object_t value = xpc_dictionary_get_value(v7, v8);
  if (value)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_10000F05C(value, *(void **)(a1 + 40));
    if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
    {
      uint64_t bytes = 0LL;
      uint64_t v21 = 0LL;
      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
      if ((_dyld_get_image_uuid(&_mh_execute_header, &bytes) & 1) == 0)
      {
        uint64_t bytes = 0LL;
        uint64_t v21 = 0LL;
      }

      if ((_dyld_get_shared_cache_uuid(&v18) & 1) != 0)
      {
        uint64_t v16 = 0LL;
        uint64_t shared_cache_range = _dyld_get_shared_cache_range(&v16);
      }

      else
      {
        uint64_t shared_cache_range = 0LL;
        uint64_t v18 = 0LL;
        uint64_t v19 = 0LL;
      }

      uint64_t v14 = xpc_string_get_string_ptr(a3);
      _os_log_simple( &_mh_execute_header,  &bytes,  &v18,  shared_cache_range,  16LL,  0LL,  "failed to serialized value for key: %s",  v14);
      return 0LL;
    }

    else
    {
      xpc_object_t v12 = *(void **)(a1 + 40);
      uint64_t v22 = 0LL;
      uint64_t v23 = 0LL;
      uint64_t bytes = 6LL;
      uint64_t v21 = 0LL;
      xpc_array_set_data(v12, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
      return 1LL;
    }
  }

  else
  {
    uint64_t bytes = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    if ((_dyld_get_image_uuid(&_mh_execute_header, &bytes) & 1) == 0)
    {
      uint64_t bytes = 0LL;
      uint64_t v21 = 0LL;
    }

    if ((_dyld_get_shared_cache_uuid(&v18) & 1) != 0)
    {
      uint64_t v16 = 0LL;
      uint64_t v11 = _dyld_get_shared_cache_range(&v16);
    }

    else
    {
      uint64_t v11 = 0LL;
      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
    }

    uint64_t v15 = xpc_string_get_string_ptr(a3);
    _os_log_simple(&_mh_execute_header, &bytes, &v18, v11, 16LL, 0LL, "no value for key: %s", v15);
    uint64_t result = 0LL;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 2;
  }

  return result;
}

uint64_t sub_10000F05C(void *a1, void *a2)
{
  xpc_type_t type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v18 = 0LL;
    uint64_t bytes = 2LL;
    int64_t string_ptr = (int64_t)xpc_string_get_string_ptr(a1);
    size_t length = xpc_string_get_length(a1);
LABEL_12:
    uint64_t v17 = (BOOL (*)(uint64_t, uint64_t, uint64_t))length;
LABEL_16:
    LOBYTE(v18) = 0;
    xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
    return 0LL;
  }

  uint64_t v5 = type;
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t bytes = 4LL;
    uint64_t v18 = 0LL;
    int64_t string_ptr = xpc_int64_get_value(a1);
LABEL_15:
    uint64_t v17 = 0LL;
    goto LABEL_16;
  }

  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t bytes = 1LL;
    uint64_t v18 = 0LL;
    int64_t string_ptr = xpc_BOOL_get_value(a1);
    goto LABEL_15;
  }

  if (type == (xpc_type_t)&_xpc_type_data)
  {
    uint64_t v18 = 0LL;
    uint64_t bytes = 9LL;
    int64_t string_ptr = (int64_t)xpc_data_get_bytes_ptr(a1);
    size_t length = xpc_data_get_length(a1);
    goto LABEL_12;
  }

  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (type == (xpc_type_t)&_xpc_type_array)
    {
      uint64_t v11 = 0LL;
      xpc_object_t v12 = &v11;
      uint64_t v13 = 0x2000000000LL;
      int v14 = 4;
      uint64_t v17 = 0LL;
      uint64_t v18 = 0LL;
      uint64_t bytes = 5LL;
      int64_t string_ptr = 0LL;
      xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
      uint64_t bytes = (uint64_t)_NSConcreteStackBlock;
      int64_t string_ptr = 0x40000000LL;
      uint64_t v17 = sub_10000F33C;
      uint64_t v18 = &unk_100063C68;
      uint64_t v19 = &v11;
      __int128 v20 = a2;
      xpc_array_apply(a1, &bytes);
      uint64_t v8 = *((unsigned int *)v12 + 6);
      if (!(_DWORD)v8)
      {
        uint64_t v23 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v21 = 6LL;
        uint64_t v22 = 0LL;
        xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &v21, 0x20uLL);
        uint64_t v8 = *((unsigned int *)v12 + 6);
      }

      _Block_object_dispose(&v11, 8);
    }

    else
    {
      uint64_t bytes = 0LL;
      int64_t string_ptr = 0LL;
      uint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      if ((_dyld_get_image_uuid(&_mh_execute_header, &bytes) & 1) == 0)
      {
        uint64_t bytes = 0LL;
        int64_t string_ptr = 0LL;
      }

      if ((_dyld_get_shared_cache_uuid(&v21) & 1) != 0)
      {
        uint64_t v11 = 0LL;
        uint64_t shared_cache_range = _dyld_get_shared_cache_range(&v11);
      }

      else
      {
        uint64_t shared_cache_range = 0LL;
        uint64_t v21 = 0LL;
        uint64_t v22 = 0LL;
      }

      mach_port_name_t name = xpc_type_get_name(v5);
      _os_log_simple(&_mh_execute_header, &bytes, &v21, shared_cache_range, 16LL, 0LL, "unsupported type: %s", name);
      return 1LL;
    }

    return v8;
  }

  return sub_10000ED28(a1, a2);
}

BOOL sub_10000F33C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_10000F05C(a3, *(void *)(a1 + 40));
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

uint64_t sub_10000F384(uint64_t a1, uint64_t a2, xpc_object_t xdata)
{
  xpc_object_t v3 = (_OWORD *)(*(void *)(a1 + 32) + 32 * a2);
  bytes_ptr = xpc_data_get_bytes_ptr(xdata);
  __int128 v5 = bytes_ptr[1];
  *xpc_object_t v3 = *bytes_ptr;
  v3[1] = v5;
  return 1LL;
}

void *sub_10000F3B8()
{
  uint64_t v0 = sub_100010B00(0x18uLL);
  os_map_str_init(v0, 0LL, 1LL);
  return v0;
}

size_t sub_10000F3EC(uint64_t a1, const char *a2)
{
  __int128 v4 = (_DWORD *)os_map_str_find(a1, a2);
  if (v4)
  {
    ++*v4;
    return (size_t)(v4 + 1);
  }

  size_t v6 = strlen(a2);
  size_t v7 = v6 + 4;
  BOOL v8 = v6 >= 0xFFFFFFFFFFFFFFFCLL;
  size_t result = v6 + 5;
  uint64_t v10 = v7 == -1LL;
  uint64_t v11 = v10 << 63 >> 63;
  BOOL v12 = v11 != v10;
  if (!v8 && !v12 && (v11 & 0x8000000000000000LL) == 0)
  {
    uint64_t v13 = sub_100010B00(result);
    __int128 v5 = v13 + 1;
    size_t v14 = strlen(a2);
    memcpy(v13 + 1, a2, v14);
    *uint64_t v13 = 1;
    os_map_str_insert(a1, v13 + 1, v13);
    return (size_t)v5;
  }

  __break(1u);
  return result;
}

void sub_10000F4A8(uint64_t a1, uint64_t a2)
{
  __int128 v4 = (_DWORD *)os_map_str_find(a1, a2);
  if (!v4) {
    sub_100047098(0LL, v5, v6, v7);
  }
  BOOL v8 = v4;
  if ((*v4)-- == 1)
  {
    os_map_str_delete(a1, a2);
    free(v8);
  }

void sub_10000F510(void *a1)
{
  uint64_t v2 = os_map_str_count(a1);
  if (v2) {
    sub_1000470B0(v2, v3, v4, v5);
  }
  os_map_str_destroy(a1);
  free(a1);
}

_BYTE *sub_10000F544(uint64_t a1, const char *a2, const char *a3, int a4, uint64_t a5)
{
  if (!a1) {
    sub_100046EB4();
  }
  uint64_t v10 = sub_100017014(0LL);
  v10[16] = 0;
  *((_DWORD *)v10 + 5) = a4;
  *((void *)v10 + 3) = a1;
  *((void *)v10 + 4) = 1LL;
  *((void *)v10 + 5) = 0LL;
  if (a2) {
    *((void *)v10 + 5) = sub_1000126A0(a2);
  }
  *((void *)v10 + 6) = 0LL;
  if (a3) {
    *((void *)v10 + 6) = sub_1000126A0(a3);
  }
  *((void *)v10 + 7) = 0LL;
  *((void *)v10 + 8) = a5;
  return v10;
}

void sub_10000F5D4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16) != 2) {
    sub_100046EB4();
  }
  if (*(void *)(a1 + 32)) {
    sub_100046EB4();
  }
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
}

uint64_t sub_10000F620(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (!v1) {
    sub_100046EB4();
  }
  if (*(_BYTE *)(result + 16)) {
    sub_100046EB4();
  }
  *(void *)(result + 32) = v1 + 1;
  return result;
}

uint64_t sub_10000F650(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    sub_100046EB4();
  }
  if (*(_BYTE *)(a1 + 16)) {
    sub_100046EB4();
  }
  uint64_t v3 = v1 - 1;
  *(void *)(a1 + 32) = v3;
  if (!v3)
  {
    *(_BYTE *)(a1 + 16) = 1;
    (*(void (**)(void))(a1 + 64))(*(void *)(a1 + 24));
  }

  return a1;
}

void *sub_10000F6A8(void *result, const void *a2)
{
  if (result[4]) {
    sub_100046EB4();
  }
  uint64_t v2 = result;
  if (*((_BYTE *)result + 16) != 1) {
    sub_100046EB4();
  }
  *((_BYTE *)result + 16) = 2;
  if (a2)
  {
    size_t result = sub_100012670(a2, 0x160uLL);
    v2[7] = result;
  }

  return result;
}

uint64_t sub_10000F6FC(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_10000F704(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t sub_10000F70C(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_10000F714(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_10000F71C(uint64_t result, int a2)
{
  return result;
}

uint64_t sub_10000F73C()
{
  return os_map_str_init(&unk_100069C48, 0LL, 1LL);
}

void sub_10000F750(void **a1)
{
  uint64_t v2 = os_map_str_delete(&unk_100069C48, a1[4]);
  if ((void **)v2 != a1)
  {
    if (v2) {
      sub_10003AB08(65539, "SERVICE CACHE DELETE UNEXPECTEDLY DELAYED: %s replaced: %s by %s, %s by %s");
    }
    else {
      sub_10003AB08(65539, "SERVICE CACHE DELETE INVARIANT VIOLATED: %s not found");
    }
  }

  xpc_release(a1[3]);
  free(a1[2]);
  free(a1[4]);
}

void *sub_10000F7EC(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t property = xpc_bundle_get_property(a2, 2LL);
  if (!property)
  {
    *a3 = 107;
    __int128 v28 = "Could not get path for service bundle.";
LABEL_11:
    sub_10002587C(a1, 3, v28, v7, v8, v9, v10, v11, v30);
    return 0LL;
  }

  BOOL v12 = (const char *)property;
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!info_dictionary)
  {
    *a3 = 107;
    char v30 = (char)v12;
    __int128 v28 = "Could not get Info.plist for bundle at %s";
    goto LABEL_11;
  }

  size_t v14 = info_dictionary;
  string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier");
  if (!string)
  {
    sub_10002587C( a1,  3,  "Bundle Info.plist at %s does not have a CFBundleIdentifier",  v16,  v17,  v18,  v19,  v20,  (char)v12);
    __int128 v26 = 0LL;
    *a3 = 107;
    return v26;
  }

  uint64_t v21 = (char *)string;
  uint64_t executable_path = (char *)xpc_bundle_get_executable_path(a2);
  uint64_t v23 = os_map_str_find(&unk_100069C48, v12);
  if (!v23) {
    goto LABEL_8;
  }
  uint64_t v24 = (const char **)v23;
  uint64_t v25 = (const char *)(v23 + 40);
  if (!sub_1000129FC(v21, (const char *)(v23 + 40)))
  {
    sub_10003AB08(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", v12, v21, v25);
LABEL_16:
    os_map_str_delete(&unk_100069C48, v12);
    goto LABEL_8;
  }

  if (!sub_1000129FC(executable_path, v24[2]))
  {
    sub_10003AB08(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", v12, executable_path, v24[2]);
    goto LABEL_16;
  }

  __int128 v26 = sub_1000167B0(v24);
  if (!v26)
  {
LABEL_8:
    __int128 v26 = sub_10001706C(v21);
    v26[2] = sub_1000126A0(executable_path);
    v26[3] = xpc_retain(v14);
    int v27 = sub_1000126A0(v12);
    v26[4] = v27;
    os_map_str_insert(&unk_100069C48, v27, v26);
  }

  return v26;
}

uint64_t sub_10000F9AC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 1128) = 0x6400000064LL;
  int v4 = posix_spawnattr_init((posix_spawnattr_t *)a1);
  if (v4) {
    sub_100046EE0(v4);
  }
  uint64_t result = posix_spawn_file_actions_init((posix_spawn_file_actions_t *)(a1 + 8));
  if ((_DWORD)result) {
    sub_100046EE0(result);
  }
  *(void *)(a1 + 1208) = a2;
  return result;
}

void sub_10000FA00(uint64_t a1)
{
  while (1)
  {
    uint64_t v2 = *(void **)(a1 + 1824);
    if (!v2) {
      break;
    }
    *(void *)(a1 + 1824) = *v2;
    free(v2);
  }

  free(*(void **)(a1 + 1216));
  free(*(void **)(a1 + 1232));
  if (*(void *)(a1 + 1248)) {
    free(*(void **)(a1 + 1240));
  }
}

uint64_t sub_10000FA68(posix_spawnattr_t *a1, __int16 a2, __int16 a3)
{
  __int16 v8 = 0;
  int v6 = posix_spawnattr_getflags(a1, &v8);
  if (v6) {
    sub_100046EE0(v6);
  }
  __int16 v8 = v8 & ~a3 | a2;
  uint64_t result = posix_spawnattr_setflags(a1, v8);
  if ((_DWORD)result) {
    sub_100046EE0(result);
  }
  return result;
}

uint64_t sub_10000FAD4( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  if (!*(void *)(a1 + 1208))
  {
    uint64_t v25 = "Missing program";
    uint64_t v26 = 22LL;
    int v27 = 580;
    return sub_10001BC88(a1, v26, 0LL, v27, 0LL, v25, a7, a8, v156);
  }

  if (*(_BYTE *)(a2 + 108)) {
    __int16 v12 = 16512;
  }
  else {
    __int16 v12 = 0x4000;
  }
  unsigned int v13 = *(_DWORD *)(a2 + 236);
  if ((v13 & 0x4000) == 0 || MEMORY[0xFFFFF4084] == 0) {
    __int16 v15 = 1024;
  }
  else {
    __int16 v15 = 1280;
  }
  int v16 = *(_DWORD *)(a2 + 236);
  if ((v13 & 0x8000) != 0)
  {
    int v17 = posix_spawnattr_disable_ptr_auth_a_keys_np(a1, 0LL);
    if (v17) {
      sub_100046EE0(v17);
    }
    int v16 = *(_DWORD *)(a2 + 236);
  }

  if ((v16 & 0x40000) != 0)
  {
    int v18 = posix_spawnattr_set_use_sec_transition_shims_np(v8, 1LL);
    if (v18) {
      sub_100046EE0(v18);
    }
    int v16 = *(_DWORD *)(a2 + 236);
  }

  sub_10000FA68((posix_spawnattr_t *)v8, (v13 >> 8) & 0x200 | v12 | (v13 >> 7) & 0x8000 | v15 | HIWORD(v16) & 0x800, 0);
  uint64_t v19 = (cpu_type_t *)_xpc_spawnattr_binprefs_unpack(a2, a3);
  if (v19)
  {
    uint64_t v20 = v19;
    xpc_binprefs_set_psattr(v19, (posix_spawnattr_t *)v8);
    free(v20);
  }

  qos_class_t v21 = *(_DWORD *)(a2 + 200);
  if (v21)
  {
    int v22 = posix_spawnattr_set_qos_class_np((posix_spawnattr_t *)v8, v21);
    if (v22) {
      sub_100046EE0(v22);
    }
  }

  int v23 = *(_DWORD *)(a2 + 236);
  if ((v23 & 0x200000) != 0)
  {
    if (*(_BYTE *)(a2 + 228) != 100LL || *(_DWORD *)(a2 + 224))
    {
      int v29 = posix_spawnattr_setcpumonitor(v8);
      if (v29) {
        sub_100046EE0(v29);
      }
    }
  }

  else if ((v23 & 2) != 0)
  {
    int v30 = posix_spawnattr_setcpumonitor_default(v8);
    if (v30) {
      sub_100046EE0(v30);
    }
  }

  else if ((v23 & 1) == 0)
  {
    int v24 = posix_spawnattr_setcpumonitor_default(v8);
    if (v24) {
      sub_100046EE0(v24);
    }
  }

  int v31 = posix_spawnattr_setjetsam_ext( v8,  *(__int16 *)(a2 + 120),  *(unsigned int *)(a2 + 124),  *(unsigned int *)(a2 + 128),  *(unsigned int *)(a2 + 132));
  if (v31) {
    sub_100046EE0(v31);
  }
  int v32 = posix_spawnattr_set_threadlimit_ext(v8, *(unsigned int *)(a2 + 136));
  if (v32) {
    sub_100046EE0(v32);
  }
  int v33 = posix_spawnattr_set_max_addr_np(v8, *(void *)(a2 + 140));
  if (v33) {
    sub_100046EE0(v33);
  }
  int v34 = posix_spawnattr_set_portlimits_ext(v8, *(unsigned int *)(a2 + 148), *(unsigned int *)(a2 + 152));
  if (v34) {
    sub_100046EE0(v34);
  }
  int v35 = posix_spawnattr_set_filedesclimit_ext(v8, *(unsigned int *)(a2 + 156), *(unsigned int *)(a2 + 160));
  if (v35) {
    sub_100046EE0(v35);
  }
  int v36 = posix_spawnattr_set_kqworklooplimit_ext(v8, *(unsigned int *)(a2 + 164), *(unsigned int *)(a2 + 168));
  if (v36) {
    sub_100046EE0(v36);
  }
  if ((*(_BYTE *)(a2 + 239) & 2) != 0)
  {
    int v37 = posix_spawnattr_set_max_addr_np(v8, -1LL);
    if (v37) {
      sub_100046EE0(v37);
    }
  }

  int v38 = posix_spawnattr_set_crash_behavior_np(v8, *(unsigned __int8 *)(a2 + 176));
  if (v38) {
    sub_100046EE0(v38);
  }
  int v39 = posix_spawnattr_set_crash_behavior_deadline_np(v8, *(void *)(a2 + 180), 0LL);
  if (v39) {
    sub_100046EE0(v39);
  }
  int v40 = posix_spawnattr_set_launch_type_np(v8, *(unsigned __int8 *)(a2 + 196));
  if (v40) {
    sub_100046EE0(v40);
  }
  int v41 = posix_spawnattr_set_crash_count_np(v8, *(unsigned int *)(a2 + 188), *(unsigned int *)(a2 + 192));
  if (v41) {
    sub_100046EE0(v41);
  }
  int v42 = posix_spawnattr_set_darwin_role_np(v8, *(unsigned int *)(a2 + 116));
  if (v42) {
    sub_100046EE0(v42);
  }
  int v43 = *(unsigned __int8 *)(a2 + 229);
  if (v43 == 1)
  {
    int v45 = posix_spawnattr_setdataless_iopolicy_np(v8, 1LL);
    if (v45) {
      sub_100046EE0(v45);
    }
  }

  else if (v43 == 2)
  {
    int v44 = posix_spawnattr_setdataless_iopolicy_np(v8, 2LL);
    if (v44) {
      sub_100046EE0(v44);
    }
  }

  unsigned int v46 = *(_DWORD *)(a2 + 80);
  if (v46)
  {
    uint64_t v47 = _xpc_spawnattr_unpack_string(a2, a3, v46);
    if (!v47)
    {
      uint64_t v56 = "Unable to unpack container_id";
      uint64_t v57 = v8;
      int v58 = 126;
      goto LABEL_65;
    }

    uint64_t v50 = v47;
    unsigned int v51 = *(_DWORD *)(a2 + 84);
    if (!v51)
    {
      uint64_t v52 = v8 + 16;
      sandbox_spawnattrs_init(v8 + 16);
LABEL_60:
LABEL_61:
      int v55 = posix_spawnattr_setmacpolicyinfo_np(v8, "Sandbox", v52, 1104LL);
      if (v55) {
        sub_100046EE0(v55);
      }
      goto LABEL_66;
    }
  }

  else
  {
    unsigned int v51 = *(_DWORD *)(a2 + 84);
    if (!v51) {
      goto LABEL_66;
    }
    uint64_t v50 = 0LL;
  }

  uint64_t v53 = _xpc_spawnattr_unpack_string(a2, a3, v51);
  if (v53)
  {
    uint64_t v54 = v53;
    uint64_t v52 = v8 + 16;
    sandbox_spawnattrs_init(v8 + 16);
    if (!v50) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }

  uint64_t v56 = "Unable to unpack sandbox profile";
  uint64_t v57 = v8;
  int v58 = 135;
LABEL_65:
  uint64_t result = sub_10001BC88(v57, 22LL, 0LL, v58, 0LL, v56, v48, v49, v156);
  if ((_DWORD)result) {
    return result;
  }
LABEL_66:
  unsigned int v59 = *(_DWORD *)(a2 + 88);
  if (v59)
  {
    uint64_t v60 = _xpc_spawnattr_unpack_string(a2, a3, v59);
    int v61 = posix_spawnattr_set_subsystem_root_path_np(v8, v60);
    if (v61) {
      sub_100046EE0(v61);
    }
  }

  uint64_t v62 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v62)
  {
    uint64_t v63 = (const char **)sub_100010B00(8 * v62 + 8);
    *(void *)(v8 + 1216) = v63;
    if (!_xpc_spawnattr_unpack_strings(a2, a3, *(_DWORD *)(a2 + 20), v63, *(unsigned int *)(a2 + 16)))
    {
      uint64_t v79 = "Unable to unpack argv";
      uint64_t v80 = v8;
      int v81 = 537;
      goto LABEL_78;
    }

    uint64_t v66 = (void *)(*(void *)(v8 + 1216) + 8LL * *(unsigned int *)(a2 + 16));
  }

  else
  {
    uint64_t v67 = sub_100010B00(0x10uLL);
    *(void *)(v8 + 1216) = v67;
    *uint64_t v67 = *(void *)(v8 + 1208);
    uint64_t v66 = v67 + 1;
  }

  *uint64_t v66 = 0LL;
  uint64_t v68 = (const char **)sub_100010B00(8LL * *(unsigned int *)(a2 + 24) + 56);
  *(void *)(v8 + 1232) = v68;
  uint64_t v72 = *(unsigned int *)(a2 + 24);
  if (!(_DWORD)v72)
  {
LABEL_75:
    sub_100010A40((void *)v8, "XXXXXXXX%s=%llx", v69, v70, v72, v71, v64, v65, (char)"XPC_FLAGS");
    goto LABEL_79;
  }

  if (_xpc_spawnattr_unpack_strings(a2, a3, *(_DWORD *)(a2 + 28), v68, v72))
  {
    *(void *)(v8 + 1224) = *(unsigned int *)(a2 + 24);
    goto LABEL_75;
  }

  uint64_t v79 = "Unable to unpack environment";
  uint64_t v80 = v8;
  int v81 = 565;
LABEL_78:
  uint64_t result = sub_10001BC88(v80, 22LL, 0LL, v81, 0LL, v79, v64, v65, v156);
  if ((_DWORD)result) {
    return result;
  }
LABEL_79:
  if (*(_DWORD *)(v8 + 1128) != -101)
  {
    if (a4)
    {
      *(void *)(v8 + 1120) = sub_100010A40( (void *)v8,  "XXXXXXXX%s=%s",  v73,  v74,  v75,  v76,  v77,  v78,  (char)"LOGNAME")
                             + 8;
      sub_100010A40((void *)v8, "XXXXXXXX%s=%s", v82, v83, v84, v85, v86, v87, (char)"USER");
      sub_100010A40((void *)v8, "XXXXXXXX%s=%s", v88, v89, v90, v91, v92, v93, (char)"HOME");
      sub_100010A40((void *)v8, "XXXXXXXX%s=%s", v94, v95, v96, v97, v98, v99, (char)"SHELL");
      unsigned int v106 = *(_DWORD *)(v8 + 1128);
      if (v106 >= 0x1F5 && v106 != -2) {
        sub_100010A40((void *)v8, "XXXXXXXX%s=%s/tmp", v100, v101, v102, v103, v104, v105, (char)"TMPDIR");
      }
      int v107 = posix_spawnattr_set_login_np(v8, *(void *)(v8 + 1120));
      if (v107) {
        sub_100046EE0(v107);
      }
      int v108 = posix_spawnattr_set_uid_np(v8, *(unsigned int *)(v8 + 1128));
      if (v108) {
        sub_100046EE0(v108);
      }
      int v109 = posix_spawnattr_set_gid_np(v8, *(unsigned int *)(v8 + 1132));
      if (v109) {
        sub_100046EE0(v109);
      }
      int v110 = *(_DWORD *)(a2 + 236);
      if ((v110 & 0x1000) == 0)
      {
        int v111 = posix_spawnattr_set_groups_np(v8, *(unsigned int *)(v8 + 1136), v8 + 1140, 4294967195LL);
        if (v111) {
          sub_100046EE0(v111);
        }
        int v110 = *(_DWORD *)(a2 + 236);
      }

      if ((v110 & 0x1000000) != 0)
      {
        int v112 = posix_spawnattr_set_persona_uid_np(v8, *(unsigned int *)(v8 + 1128));
        if (v112) {
          sub_100046EE0(v112);
        }
        int v113 = posix_spawnattr_set_persona_gid_np(v8, *(unsigned int *)(v8 + 1132));
        if (v113) {
          sub_100046EE0(v113);
        }
        if ((*(_BYTE *)(a2 + 237) & 0x10) == 0)
        {
          int v114 = posix_spawnattr_set_persona_groups_np(v8, *(unsigned int *)(v8 + 1136), v8 + 1140, 4294967195LL);
          if (v114) {
            sub_100046EE0(v114);
          }
        }
      }
    }

    else
    {
      uint64_t result = sub_10001BC88(v8, 22LL, 0LL, 354, 0LL, "Unable to setup identify", v77, v78, v156);
      if ((_DWORD)result) {
        return result;
      }
    }
  }

  xpc_object_t v115 = xpc_dictionary_create(0LL, 0LL, 0LL);
  if (*(void *)(v8 + 1224))
  {
    uint64_t v116 = 0LL;
    uint64_t v117 = 0LL;
    while (1)
    {
      unsigned int v118 = *(const char **)(*(void *)(v8 + 1232) + 8 * v117);
      v119 = strchr(v118, 61);
      if (!v119 || v119 == v118) {
        break;
      }
      size_t v123 = sub_1000126F4(v118, v119 - v118);
      if (!xpc_dictionary_get_value(v115, v123))
      {
        xpc_dictionary_set_BOOL(v115, v123, 1);
        *(void *)(*(void *)(v8 + 1232) + 8 * v116++) = v118;
      }

      free(v123);
    }

    uint64_t result = sub_10001BC88(v8, 22LL, 0LL, 464, 0LL, "Invalid environment[%zd]: %s", v120, v121, v117);
    if ((_DWORD)result) {
      return result;
    }
  }

  else
  {
    uint64_t v116 = 0LL;
LABEL_108:
    xpc_release(v115);
    *(void *)(v8 + 1224) = v116;
    *(void *)(*(void *)(v8 + 1232) + 8 * v116) = 0LL;
  }

  unsigned int v124 = *(_DWORD *)(a2 + 64);
  if (v124)
  {
    v127 = _xpc_spawnattr_unpack_string(a2, a3, v124);
    if (!v127)
    {
      v128 = "Unable to unpack cwd";
      uint64_t v129 = v8;
      int v130 = 224;
LABEL_144:
      uint64_t result = sub_10001BC88(v129, 22LL, 0LL, v130, 0LL, v128, v125, v126, v156);
LABEL_145:
      if ((_DWORD)result) {
        return result;
      }
      goto LABEL_146;
    }
  }

  else
  {
    v127 = "/";
  }

  unsigned int v131 = *(_DWORD *)(a2 + 68);
  if (v131)
  {
    v132 = _xpc_spawnattr_unpack_string(a2, a3, v131);
    if (!v132)
    {
      v128 = "Unable to unpack stdin";
      uint64_t v129 = v8;
      int v130 = 241;
      goto LABEL_144;
    }

    v133 = (char *)v132;
    bzero(__str, 0x400uLL);
    if (*v133 != 47)
    {
      v157 = v133;
      v133 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v127, v157);
    }

    uint64_t v134 = sub_100010AA4(v133);
    if ((_DWORD)v134)
    {
      uint64_t result = sub_10001BC88(v8, v134, 0LL, 253, 0LL, "Unable to create stdin directory (%s)", v135, v136, (char)v133);
      goto LABEL_145;
    }

    int v138 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 0, v133, 131584, 0x1B6u);
    if (v138) {
      sub_100046EE0(v138);
    }
  }

  else
  {
    int v137 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 0, "/dev/null", 0x20000, 0x1B6u);
    if (v137) {
      sub_100046EE0(v137);
    }
  }

  unsigned int v139 = *(_DWORD *)(a2 + 72);
  if (v139)
  {
    v140 = _xpc_spawnattr_unpack_string(a2, a3, v139);
    if (!v140)
    {
      v128 = "Unable to unpack stdout";
      uint64_t v129 = v8;
      int v130 = 268;
      goto LABEL_144;
    }

    v141 = (char *)v140;
    bzero(__str, 0x400uLL);
    if (*v141 != 47)
    {
      v158 = v141;
      v141 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v127, v158);
    }

    uint64_t v142 = sub_100010AA4(v141);
    if ((_DWORD)v142)
    {
      uint64_t result = sub_10001BC88(v8, v142, 0LL, 280, 0LL, "Unable to create stdout directory (%s)", v143, v144, (char)v141);
      goto LABEL_145;
    }

    int v146 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 1, v141, 131594, 0x1B6u);
    if (v146) {
      sub_100046EE0(v146);
    }
  }

  else
  {
    int v145 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 1, "/dev/null", 131074, 0x1B6u);
    if (v145) {
      sub_100046EE0(v145);
    }
  }

  unsigned int v147 = *(_DWORD *)(a2 + 76);
  if (v147)
  {
    v148 = _xpc_spawnattr_unpack_string(a2, a3, v147);
    if (!v148)
    {
      v128 = "Unable to unpack stderr";
      uint64_t v129 = v8;
      int v130 = 295;
      goto LABEL_144;
    }

    v149 = (char *)v148;
    bzero(__str, 0x400uLL);
    if (*v149 != 47)
    {
      v159 = v149;
      v149 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v127, v159);
    }

    uint64_t v150 = sub_100010AA4(v149);
    if ((_DWORD)v150)
    {
      uint64_t result = sub_10001BC88(v8, v150, 0LL, 307, 0LL, "Unable to create stderr directory (%s)", v151, v152, (char)v149);
      goto LABEL_145;
    }

    int v155 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 2, v149, 131594, 0x1B6u);
    if (v155) {
      sub_100046EE0(v155);
    }
  }

  else
  {
    int v153 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 2, "/dev/null", 131074, 0x1B6u);
    if (v153) {
      sub_100046EE0(v153);
    }
  }

LABEL_146:
  if ((*(_BYTE *)(a2 + 238) & 1) != 0)
  {
    int v154 = *(_DWORD *)(v8 + 1128);
    if (!v154 || v154 == -101)
    {
      uint64_t v25 = "extensions cannot run as root";
      a1 = v8;
      uint64_t v26 = 1LL;
      int v27 = 769;
      return sub_10001BC88(a1, v26, 0LL, v27, 0LL, v25, a7, a8, v156);
    }
  }

  return 0LL;
}

uint64_t sub_1000105EC( posix_spawnattr_t *a1, uint64_t a2, uint64_t a3, xpc_object_t xarray, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a2 + 220);
  if (!(_DWORD)v8) {
    return 0LL;
  }
  uint64_t v11 = *(unsigned int *)(a2 + 216);
  unint64_t v12 = 4 * v8;
  if (v12 > a3 - v11) {
    return sub_10001BC88((uint64_t)a1, 22LL, 0LL, 797, 0LL, "No space for special ports: %zu > (%zu - %d)", a7, a8, v12);
  }
  char v15 = 0;
  size_t v16 = 0LL;
  uint64_t v17 = a2 + v11 + 240;
  while (1)
  {
    xpc_object_t value = xpc_array_get_value(xarray, v16);
    mach_port_t right = xpc_mach_send_get_right(value);
    mach_port_t v22 = right;
    if (right - 1 >= 0xFFFFFFFE)
    {
      char v29 = v16;
      uint64_t v26 = "Invalid special port[%zd]: %d";
      uint64_t v27 = (uint64_t)a1;
      int v28 = 806;
      return sub_10001BC88(v27, 22LL, 0LL, v28, 0LL, v26, v20, v21, v29);
    }

    int v23 = *(_DWORD *)(v17 + 4 * v16);
    if ((v23 - 128) > 2)
    {
      if (v23 == 4)
      {
        if ((*(_BYTE *)(a2 + 239) & 4) != 0) {
          mach_port_t v22 = 0;
        }
        else {
          mach_port_t v22 = right;
        }
      }

      int v25 = posix_spawnattr_setspecialport_np(a1, v22, v23);
      if (v25) {
        sub_100046EE0(v25);
      }
      goto LABEL_16;
    }

    int v31 = 0;
    uint64_t v30 = 0LL;
LABEL_16:
  }

  if ((v15 & 1) == 0)
  {
    LODWORD(v30) = right;
    char v15 = 1;
    int v24 = posix_spawnattr_set_registered_ports_np(a1, &v30, 1LL);
    if (v24) {
      sub_100046EE0(v24);
    }
    goto LABEL_16;
  }

  uint64_t v26 = "Already registered ports";
  uint64_t v27 = (uint64_t)a1;
  int v28 = 820;
  return sub_10001BC88(v27, 22LL, 0LL, v28, 0LL, v26, v20, v21, v29);
}

size_t sub_10001078C(uint64_t a1, xpc_object_t xarray)
{
  size_t result = xpc_array_get_count(xarray);
  if (result)
  {
    size_t v5 = 0LL;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(xarray, v5 + 1);
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
      {
        char v15 = "setup_fds bad int type";
        uint64_t v16 = a1;
        int v17 = 864;
        return sub_10001BC88(v16, 9LL, 0LL, v17, 0LL, v15, v7, v8, v18);
      }

      int64_t v9 = xpc_int64_get_value(value);
      if ((v9 & 0x80000000) != 0 || getdtablesize() <= (int)v9)
      {
        getdtablesize();
        return sub_10001BC88(a1, 9LL, 0LL, 868, 0LL, "setup_fds bad dest: %d table: %d", v13, v14, v9);
      }

      xpc_object_t v10 = xpc_array_get_value(xarray, v5);
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_fd) {
        break;
      }
      uint64_t port = _xpc_fd_get_port(v10);
      int v12 = posix_spawn_file_actions_add_fileportdup2_np(a1 + 8, port, v9);
      if (v12) {
        sub_100046EE0(v12);
      }
      v5 += 2LL;
      if (v5 >= xpc_array_get_count(xarray)) {
        return 0LL;
      }
    }

    char v15 = "setup_fds bad fd type";
    uint64_t v16 = a1;
    int v17 = 873;
    return sub_10001BC88(v16, 9LL, 0LL, v17, 0LL, v15, v7, v8, v18);
  }

  return result;
}

uint64_t sub_1000108E0(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5)
{
  size_t v8 = *(unsigned int *)(a2 + 12);
  if ((_DWORD)v8) {
    int64_t v9 = (const void *)_xpc_spawnattr_unpack_bytes(a2, a3, *(_DWORD *)(a2 + 8), v8);
  }
  else {
    int64_t v9 = 0LL;
  }
  if ((_DWORD)v8) {
    BOOL v10 = v9 == 0LL;
  }
  else {
    BOOL v10 = 1;
  }
  int v11 = !v10;
  if (!a4 || !a5)
  {
    if (!v11) {
      return 0LL;
    }
    uint64_t v20 = sub_100012670(v9, v8);
    *(void *)(a1 + 1240) = v20;
    *(void *)(a1 + 1248) = v8;
    a5 = v8;
    goto LABEL_19;
  }

  if (v11)
  {
    int v12 = (void *)sub_10000EB94((unint64_t)a4, a5, (unint64_t)v9, v8);
    if (v12)
    {
      char v15 = v12;
      size_t length = xpc_data_get_length(v12);
      *(void *)(a1 + 1248) = length;
      int v17 = sub_100010B00(length);
      *(void *)(a1 + 1240) = v17;
      size_t bytes = xpc_data_get_bytes(v15, v17, 0LL, *(void *)(a1 + 1248));
      uint64_t v19 = *(void *)(a1 + 1248);
      xpc_release(v15);
      if (bytes == v19)
      {
        uint64_t v20 = *(void **)(a1 + 1240);
        a5 = *(void *)(a1 + 1248);
        goto LABEL_19;
      }

      mach_port_t v22 = "Unable to copy merged spawn constraints";
      uint64_t v23 = a1;
      int v24 = 938;
    }

    else
    {
      mach_port_t v22 = "Unable to merge spawn constraints";
      uint64_t v23 = a1;
      int v24 = 933;
    }

    return sub_10001BC88(v23, 22LL, 0LL, v24, 0LL, v22, v13, v14, v25);
  }

  uint64_t v20 = sub_100012670(a4, a5);
  *(void *)(a1 + 1240) = v20;
  *(void *)(a1 + 1248) = a5;
LABEL_19:
  uint64_t result = amfi_launch_constraint_set_spawnattr(a1, v20, a5);
  if ((_DWORD)result) {
    sub_100046EE0(result);
  }
  return result;
}

char *sub_100010A40( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v14[0] = 0LL;
  v14[1] = &a9;
  vasprintf(v14, a2, &a9);
  BOOL v10 = v14[0];
  *(void *)v14[0] = a1[228];
  a1[228] = v10;
  uint64_t result = v10 + 8;
  uint64_t v12 = a1[154];
  uint64_t v13 = a1[153];
  a1[153] = v13 + 1;
  *(void *)(v12 + 8 * v13) = result;
  return result;
}

uint64_t sub_100010AA4(const char *a1)
{
  uint64_t v2 = strrchr(a1, 47);
  if (!v2) {
    return 22LL;
  }
  uint64_t v3 = v2;
  char v4 = *v2;
  *uint64_t v2 = 0;
  LODWORD(result) = mkpath_np(a1, 0x1F6u);
  if ((_DWORD)result == 17) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = result;
  }
  *uint64_t v3 = v4;
  return result;
}

void *sub_100010B00(size_t __size)
{
  do
  {
    uint64_t v2 = calloc(1uLL, __size);
    if (v2) {
      break;
    }
    if (*__error() != 12)
    {
      int v3 = *__error();
      if (v3) {
        sub_100046EF4(v3);
      }
    }
  }

  while (sub_100012654());
  return v2;
}

void *sub_100010B5C(void *__ptr, int a2, size_t __size)
{
  do
  {
    size_t v5 = realloc(__ptr, __size);
    if (v5) {
      break;
    }
    if (*__error() != 12)
    {
      int v6 = *__error();
      if (v6) {
        sub_100046EF4(v6);
      }
    }
  }

  while (sub_100012654());
  return v5;
}

void sub_100010BC4(uint64_t a1, int a2)
{
  if ((_UNKNOWN *)sub_10002A994(a1) == &unk_1000695B8) {
    sub_100010C04(a2, v3, v4, v5, v6, v7, v8, v9);
  }
}

void sub_100010C04( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 18)
  {
    switch(dword_100069C60)
    {
      case 0:
        if (a1 != 1) {
          goto LABEL_38;
        }
        break;
      case 1:
        break;
      case 2:
        if (a1 != 3) {
          goto LABEL_38;
        }
        break;
      case 3:
        if (a1 != 4) {
          goto LABEL_38;
        }
        break;
      case 4:
        if (a1 != 5) {
          goto LABEL_38;
        }
        break;
      case 5:
        if (a1 != 6) {
          goto LABEL_38;
        }
        break;
      case 6:
        if (a1 != 7) {
          goto LABEL_38;
        }
        break;
      case 7:
        if (a1 != 8) {
          goto LABEL_38;
        }
        break;
      case 8:
        if (a1 != 9) {
          goto LABEL_38;
        }
        break;
      case 9:
        if (a1 != 10) {
          goto LABEL_38;
        }
        break;
      case 10:
        if (a1 != 11) {
          goto LABEL_38;
        }
        break;
      case 11:
        if (a1 != 12) {
          goto LABEL_38;
        }
        break;
      case 12:
        if (a1 != 13) {
          goto LABEL_38;
        }
        break;
      case 13:
        if (a1 != 14) {
          goto LABEL_38;
        }
        break;
      case 14:
        if (a1 != 15) {
          goto LABEL_38;
        }
        break;
      case 15:
      case 18:
        if (a1 != 16) {
          goto LABEL_38;
        }
        break;
      case 16:
        if (a1 != 17) {
          goto LABEL_38;
        }
        goto LABEL_3;
      default:
LABEL_38:
        sub_100039448("Unexpected shutdown transition %s -> %s", off_100063D58[dword_100069C60], off_100063D58[a1]);
    }
  }

  sub_10003B008("shutdown", 196613, "shutdown %s -> %s", a4, a5, a6, a7, a8, (char)off_100063D58[dword_100069C60]);
LABEL_3:
  dword_100069C60 = a1;
}

void sub_100010D7C()
{
  dword_100069C60 = 0;
  dword_100069C64 = 0;
  dword_100069C68 = 0;
  byte_100069C6C = 0;
  sub_100015848();
}

void sub_100010DA0()
{
}

void sub_100010DE4(id a1)
{
}

void sub_100010DF0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = sub_1000115E4();
  sub_100010C04(18, v9, v10, v11, v12, v13, v14, v15);
  sub_100011028(v8);
  free(v8);
  uint64_t v16 = sub_10002A7C8();
  sub_100011448(v16);
}

void sub_100010E4C(id a1, unsigned int a2)
{
  if (a2 == 2)
  {
    if ((byte_100069C6C & 1) == 0) {
      sub_100046EB4();
    }
    byte_100069C6C = 0;
    if (dword_100069C60 == 14) {
      sub_10001142C();
    }
  }

  else if (a2 == 1)
  {
    if (byte_100069C6C == 1) {
      sub_100046EB4();
    }
    byte_100069C6C = 1;
  }

void sub_100010EB4()
{
  if (dword_100069C60 == 1)
  {
    sub_10003AB08(5, "shutdown already committed");
  }

  else
  {
    if (dword_100069C60) {
      sub_100039448("Attempting to commit shutdown unexpectedly: %s", off_100063D58[dword_100069C60]);
    }
    sub_10003AB08(5, "committing to system shutdown");
    uint64_t v0 = dispatch_queue_create("com.apple.xpc.launchd.system-override", 0LL);
    dispatch_async_f(v0, 0LL, (dispatch_function_t)sub_1000115B0);
    dispatch_release(v0);
    if (dword_100069C64 == 1)
    {
      uint64_t v8 = "kern.willuserspacereboot";
      goto LABEL_8;
    }

    if (!dword_100069C64)
    {
      sub_100039D0C("kern.willshutdown", 1);
      uint64_t v8 = "security.mac.asp.willshutdown";
LABEL_8:
      sub_100039D0C(v8, 1);
    }
  }

  sub_100010C04(1, v1, v2, v3, v4, v5, v6, v7);
}

uint64_t sub_100010F9C(int a1, uint64_t a2, int a3)
{
  if (dword_100069C60)
  {
    sub_10003AB08(3, "Shutdown already started: %s", off_100063D58[dword_100069C60]);
    return 37LL;
  }

  else
  {
    dword_100069C64 = a1;
    if (a2) {
      sub_100046EB4();
    }
    dword_100069C68 = a3;
    sub_100010EB4();
    return 0LL;
  }

BOOL sub_100011008(int a1)
{
  return dword_100069C60 > 0 && dword_100069C64 == a1;
}

void sub_100011028(char *a1, ...)
{
  dword_100069C64 = 0;
  v10[0] = 0LL;
  va_copy((va_list)&v10[1], va);
  vasprintf(v10, a1, va);
  uint64_t v8 = v10[0];
  char v9 = (char)v10[0];
  if (!v10[0])
  {
    _os_assumes_log(0LL);
    v10[0] = a1;
    char v9 = (char)a1;
  }

  sub_10003B008( "hard reboot",  196612,  "Could not cleanly tear down userspace. Will force a full hardware reboot. (%s)",  v3,  v4,  v5,  v6,  v7,  v9);
  free(v8);
}

uint64_t sub_1000110D0( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100069C60 != 11) {
    sub_100046EB4();
  }
  sub_10002587C((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v25);
  sub_100010C04(12, v9, v10, v11, v12, v13, v14, v15);
  sub_100041870();
  sub_100010C04(13, v16, v17, v18, v19, v20, v21, v22);
  sub_100019E94();
  uint64_t result = sub_10001119C();
  if ((result & 1) == 0)
  {
    sub_100011228((uint64_t)a1);
    int v24 = (dispatch_queue_s *)sub_100011938();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_100011310;
    block[3] = &unk_100063DF0;
    block[4] = a1;
    dispatch_async(v24, block);
    uint64_t result = (uint64_t)sub_1000167B0(a1);
    if (a1[39]) {
      sub_100046EB4();
    }
  }

  return result;
}

uint64_t sub_10001119C()
{
  if (dword_100069C60 != 13) {
    sub_100046EB4();
  }
  if (dword_100069C64)
  {
    if (byte_10006A9B9)
    {
      sub_10003AB08(65540, "Abandoning lingering coalitions");
    }

    else if (sub_1000198D4(0LL))
    {
      return 0LL;
    }
  }

  sub_100010C04(14, v0, v1, v2, v3, v4, v5, v6);
  if ((byte_100069C6C & 1) == 0) {
    sub_10001142C();
  }
  return 1LL;
}

uint64_t sub_100011228(uint64_t a1)
{
  if (dword_100069C60 != 13) {
    sub_100046EB4();
  }
  unint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  int data_np = sysctlbyname_get_data_np("kern.proc.all", &v12, &v11);
  if (data_np)
  {
    if (data_np == -1) {
      sub_100047024();
    }
  }

  else
  {
    if (v11 >= 0x288)
    {
      uint64_t v8 = 0LL;
      unint64_t v9 = v11 / 0x288;
      do
      {
        if (*(int *)((char *)v12 + v8 + 40) >= 2) {
          sub_10002587C( a1,  65540,  "Found lingering process: %d (%s)",  v3,  v4,  v5,  v6,  v7,  *(_DWORD *)((char *)v12 + v8 + 40));
        }
        v8 += 648LL;
        --v9;
      }

      while (v9);
    }

    free(v12);
  }

  return sub_10003A3EC();
}

void sub_100011310( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_100011318( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_100069C60 == 13)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    v13[2] = sub_10001179C;
    v13[3] = &unk_100063E38;
    v13[4] = a1;
    if (sub_1000198D4((uint64_t)v13))
    {
      sub_100011228(a1);
      dispatch_time_t v10 = dispatch_time(0LL, 1000000000LL);
      unint64_t v11 = (dispatch_queue_s *)sub_100011938();
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000LL;
      v12[2] = sub_1000117FC;
      v12[3] = &unk_100063E58;
      v12[4] = a1;
      dispatch_after(v10, v11, v12);
    }
  }

  else
  {
    sub_10002587C(a1, 65541, "Polling for lingering coalitions stopped", a4, a5, a6, a7, a8, a9);
  }

uint64_t sub_100011414()
{
  if (dword_100069C60 == 13) {
    return sub_10001119C();
  }
  return result;
}

void sub_10001142C()
{
  uint64_t v7 = sub_10002A7C8();
  sub_100011448(v7);
}

void sub_100011448(uint64_t a1)
{
  if (dword_100069C60 == 15 || dword_100069C60 == 18)
  {
    uint64_t v1 = a1;
    task_t v4 = mach_host_self();
    sub_10003C50C(v4, 0);
    p_vtable = &OBJC_CLASS___OS_launch_service_stub.vtable;
    char v5 = dword_100069C68;
    sub_10000A9C0(*(void *)(v1 + 240));
    sub_10002587C(v1, 5, "shutting down system: flags = 0x%x, time = %llu ms", v6, v7, v8, v9, v10, v5);
    unint64_t v11 = sub_10000A9C0(*(void *)(v1 + 240));
    sub_10002587C(v1, 196613, "Userspace teardown took: %llu ms", v12, v13, v14, v15, v16, v11 / 0xF4240);
    if (dword_100069C64)
    {
      if (dword_100069C64 == 1)
      {
        sub_10002587C(v1, 196613, "Will be re-execing for a userspace reboot", v22, v23, v24, v25, v26, v41);
        int v17 = 4;
        goto LABEL_11;
      }

LABEL_10:
      int v17 = 1;
LABEL_11:
      sub_10003AB08(196613, "Quiescing queues");
      sub_100010C04(16, v27, v28, v29, v30, v31, v32, v33);
      sub_10000D5A4();
      sub_10003AB40();
      sub_10000CEB8("launchd quiesce complete\n");
      sub_100010C04(17, v34, v35, v36, v37, v38, v39, v40);
      sub_100011598(v17);
    }
  }

  else
  {
    uint64_t v18 = _os_assert_log(dword_100069C60 == 18);
    _os_crash(v18, v19, v20, v21);
    __break(1u);
  }

  sub_10002587C( v1,  196613,  "Will be calling reboot(2) with flags: 0x%x",  v22,  v23,  v24,  v25,  v26,  *((_DWORD *)p_vtable + 794));
  goto LABEL_10;
}

  uint64_t v20 = (unint64_t *)(a1 + 1164);
  uint64_t v21 = *(void *)(a1 + 1164);
  if ((v21 & 0x1000000000LL) == 0)
  {
    uint64_t v16 = a1;
    int v17 = a3;
    uint64_t v18 = 2;
    goto LABEL_13;
  }

  if ((v21 & 0x100000000LL) != 0) {
    return 37LL;
  }
  reply = xpc_dictionary_create_reply(a3);
  buffer = 0LL;
  uint64_t v23 = sub_100002290(a1, &value, &buffer);
  uint64_t v24 = buffer;
  *uint64_t v20 = *v20 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)buffer + 108) << 34);
  uint64_t v25 = dispatch_data_create(v24, v23, 0LL, _dispatch_data_destructor_free);
  uint64_t v26 = xpc_data_create_with_dispatch_data(v25);
  dispatch_release(v25);
  xpc_dictionary_set_value(reply, "blob", v26);
  xpc_release(v26);
  xpc_dictionary_set_value(reply, "ports", value);
  xpc_release(value);
  if (!v15) {
    xpc_dictionary_set_mach_send(reply, "control", v13);
  }
  uint64_t v27 = xpc_array_create(0LL, 0LL);
  for (size_t i = 0LL; i != 3; ++i)
  {
    uint64_t v29 = *(_DWORD *)(a1 + 4 * i + 664);
    if (v29 != -1)
    {
      xpc_array_set_fd(v27, 0xFFFFFFFFFFFFFFFFLL, v29);
      xpc_array_set_int64(v27, 0xFFFFFFFFFFFFFFFFLL, i);
    }
  }

  uint64_t v30 = *(void **)(a1 + 1280);
  if (v30 && xpc_array_get_count(v30))
  {
    uint64_t v31 = 0LL;
    do
    {
      uint64_t v32 = xpc_array_get_value(*(xpc_object_t *)(a1 + 1280), v31);
      xpc_array_append_value(v27, v32);
      ++v31;
    }

    while (v31 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1280)));
  }

  xpc_dictionary_set_value(reply, "fds", v27);
  xpc_release(v27);
  sub_10000E638(570425356LL, *(int *)(a1 + 1128));
  sub_100021B6C(a1);
  uint64_t result = 0LL;
  *v20 |= (unint64_t)&_mh_execute_header;
  *a4 = reply;
  return result;
}

  *(_DWORD *)(a2 + 368) = v4 | 0x10;
  if ((v4 & 1) != 0)
  {
    uint64_t v16 = sub_10001DA70(a2);
    if ((v16 - 36) >= 2)
    {
      if (v16 != 89) {
        sub_100039448("inconsistency between domain and service semi-active state during semi-active bootout");
      }
      return 0LL;
    }

    return 36LL;
  }

  if (!*(_WORD *)(a2 + 300))
  {
    sub_10002B73C(a1, a2, v19, v20, v21, v22, v23, v24);
    return 0LL;
  }

  if (sub_1000209C0(a2) && sub_100011008(0))
  {
    sub_10002BD80(a1, a2);
    sub_10001AF8C(a2, v9, v10, v11, v12, v13, v14, v15);
    return 0LL;
  }

  uint64_t v18 = sub_10001DA70(a2);
  uint64_t result = 36LL;
  if (v18 && v18 != 37)
  {
    if (v18 == 89) {
      sub_100039448("inconsistency between domain and service semi-active state during active bootout");
    }
    _os_assumes_log_ctx(sub_10001C1B0, a2);
    return 36LL;
  }

  return result;
}

    if (!v1 || v1 < v1 + 64) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  if (v8 - (void)v7 != 1)
  {
    uint64_t v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v3)
    {
      task_t v4 = "BOOLean should be exactly 1 byte";
      goto LABEL_9;
    }

    goto LABEL_10;
  }

void sub_100011598(int a1)
{
}

uint64_t sub_1000115B0()
{
  uint64_t result = system_override(-1LL, 3LL);
  if ((_DWORD)result == -1) {
    sub_100046FF0();
  }
  return result;
}

char *sub_1000115E4()
{
  if (dword_100069C60 != 13) {
    return sub_100012884("userspace shutdown timed out: %s", off_100063D58[dword_100069C60]);
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  int v8 = 0;
  uint64_t v0 = (const char **)sub_10000D8E8(0x40uLL);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10001172C;
  v4[3] = &unk_100063E18;
  _OWORD v4[4] = &v5;
  v4[5] = v0;
  sub_1000198D4((uint64_t)v4);
  if (*((int *)v6 + 6) < 1)
  {
    uint64_t v2 = sub_100012884( "userspace shutdown timed out: %s. Unable to identify lingering coalitions.",  off_100063D58[dword_100069C60]);
  }

  else
  {
    uint64_t v1 = sub_10000D930(v0);
    uint64_t v2 = sub_100012884( "userspace shutdown timed out: %s (%d).%s",  off_100063D58[dword_100069C60],  *((_DWORD *)v6 + 6),  v1);
    free(v1);
  }

  sub_10000D938((void **)v0);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_10001172C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  char v5 = sub_10000E618(a2);
  sub_10000F6FC(a2);
  sub_10000D960(v4, " %llu (%s),", v6, v7, v8, v9, v10, v11, v5);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void sub_10001179C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = sub_10000E618(a2);
  sub_10000F6FC(a2);
  sub_10002587C(v3, 65540, "Lingering coalition: %llu (%s)", v5, v6, v7, v8, v9, v4);
}

uint64_t sub_1000117FC(uint64_t a1)
{
  return sub_100011318(*(void *)(a1 + 32));
}

uint64_t sub_100011804(uint32_t a1)
{
  *__error() = 0;
  uint64_t result = usrctl(a1);
  if ((_DWORD)result)
  {
    int v3 = result;
    char v4 = __error();
    sub_100039448("usrctl(0x%x) returned %d (errno %d)", a1, v3, *v4);
  }

  return result;
}

dispatch_queue_t sub_10001185C()
{
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0LL);
  qos_class_t v1 = qos_class_main();
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(initially_inactive, v1, 0);
  qword_100069C70 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.eventq", v2);
  qos_class_t v3 = qos_class_main();
  char v4 = dispatch_queue_attr_make_with_qos_class(0LL, v3, 0);
  qword_100069C78 = (uint64_t)dispatch_queue_create_with_target_V2("com.apple.xpc.launchd.spawn", v4, 0LL);
  qword_10006A8B8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.ioq", 0LL);
  uint64_t v5 = dispatch_queue_attr_make_with_qos_class(0LL, (dispatch_qos_class_t)5u, 0);
  qword_100069C80 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.bgioq", v5);
  dispatch_queue_t result = dispatch_queue_create("com.apple.xpc.launchd.bglogq", v5);
  qword_100069C88 = (uint64_t)result;
  return result;
}

uint64_t sub_100011938()
{
  return qword_100069C70;
}

uint64_t sub_100011944()
{
  return qword_10006A8B8;
}

uint64_t sub_100011950()
{
  return qword_100069C80;
}

uint64_t sub_10001195C()
{
  return qword_100069C88;
}

void sub_100011968()
{
}

uint64_t sub_100011974()
{
  return qword_100069C78;
}

void sub_100011980()
{
}

void *sub_10001198C(uint64_t a1, const char *a2)
{
  qos_class_t v3 = sub_1000258E0(a1, 1);
  char v4 = sub_100012884("%s/%s", v3, a2);
  free(v3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = sub_100011A24;
  _OWORD v7[3] = &unk_100063E78;
  v7[4] = v4;
  uint64_t v5 = sub_100010B00(0x18uLL);
  void *v5 = sub_1000128F4(v7);
  v5[1] = v4;
  return v5;
}

void sub_100011A24(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100011A50(uint64_t a1)
{
  *(void *)(a1 + 8) = 0LL;
  _Block_release(*(const void **)a1);
  free((void *)a1);
}

void sub_100011A84(_BYTE *a1, uint64_t a2, char *a3, ...)
{
  a1[16] = 1;
  v4[0] = 0LL;
  va_copy((va_list)&v4[1], va);
  if (vasprintf((char **)v4, a3, va) != -1)
  {
    (*(void (**)(void))(*(void *)a1 + 16LL))();
    free(v4[0]);
  }

void sub_100011AF8(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if ((v2 - 1) < 2)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v2 == 2) {
      uint64_t v6 = 2LL;
    }
    else {
      uint64_t v6 = 1LL;
    }
    *(void *)(a1 + 80) = xpc_bundle_create(v5, v6);
    sub_1000167B0((void *)a1);
    global_queue = dispatch_get_global_queue(0LL, 0LL);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = sub_100012180;
    v9[3] = &unk_100063F18;
    v9[4] = a1;
    char v4 = v9;
  }

  else if (v2 == 3)
  {
    sub_1000167B0((void *)a1);
    global_queue = (dispatch_queue_s *)sub_100011944();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_100011DD4;
    block[3] = &unk_100063EB8;
    block[4] = a1;
    char v4 = block;
  }

  else
  {
    if (*(_BYTE *)(a1 + 56)) {
      sub_100039448("unsupported IO type %d", *(unsigned __int8 *)(a1 + 56));
    }
    sub_1000167B0((void *)a1);
    global_queue = (dispatch_queue_s *)sub_100011944();
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000LL;
    v8[2] = sub_100011C64;
    v8[3] = &unk_100063E98;
    v8[4] = a1;
    char v4 = v8;
  }

  dispatch_async(global_queue, v4);
}

void sub_100011C64(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  qos_class_t v3 = (dispatch_queue_s *)sub_100011944();
  dispatch_assert_queue_V2(v3);
  uint64_t v15 = v2;
  uint64_t v4 = guarded_open_np(*(void *)(v2 + 64), &v15, 31LL, 0x1000000LL);
  if ((v4 & 0x80000000) != 0)
  {
    int v6 = *__error();
    goto LABEL_7;
  }

  uint64_t v5 = v4;
  if (fstat(v4, (stat *)(v2 + 96)))
  {
LABEL_3:
    int v6 = *__error();
    goto LABEL_4;
  }

  unsigned __int16 v7 = (*(_WORD *)(v2 + 100) & 0xF000) + 0x4000;
  if ((v7 & 0xF000u) >= 0xB000 || (unsigned int v8 = v7 >> 12, ((0x561u >> v8) & 1) == 0))
  {
    uint64_t v9 = sub_100036BD0(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      free(*(void **)(v2 + 64));
      *(void *)(v2 + 64) = v10;
      size_t v11 = *(void *)(v2 + 192);
      uint64_t v12 = sub_100010B00(v11);
      ssize_t v13 = read(v5, v12, v11);
      if (v13 < 0 || v13 == v11)
      {
        dispatch_data_t v14 = dispatch_data_create(v12, v11, 0LL, _dispatch_data_destructor_free);
        int v6 = 0;
        *(void *)(v2 + 72) = v14;
      }

      else
      {
        free(v12);
        int v6 = 5;
      }

      goto LABEL_4;
    }

    goto LABEL_3;
  }

  int v6 = dword_100049444[v8];
LABEL_4:
LABEL_7:
  sub_100012080(v2, 0LL, v6);
  sub_10001685C(*(void **)(a1 + 32));
}

void sub_100011DD4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  qos_class_t v3 = (dispatch_queue_s *)sub_100011944();
  dispatch_assert_queue_V2(v3);
  uint64_t v24 = v2;
  uint64_t v4 = guarded_open_np(*(void *)(v2 + 64), &v24, 31LL, 16809984LL);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v9 = __error();
    sub_100012080(v2, 0LL, *v9);
    goto LABEL_37;
  }

  uint64_t v5 = v4;
  if (!fstat(v4, (stat *)(v2 + 96)))
  {
    if ((*(_WORD *)(v2 + 100) & 0xF000) != 0x4000)
    {
      unsigned __int16 v7 = 0LL;
      int v8 = 20;
      goto LABEL_34;
    }

    unsigned __int16 v7 = sub_100036BD0(v5);
    if (!v7)
    {
      int v6 = __error();
      goto LABEL_4;
    }

    free(*(void **)(v2 + 64));
    *(void *)(v2 + 64) = v7;
    v25[0] = v7;
    v25[1] = 0LL;
    unsigned __int16 v7 = (char *)sub_10000E454();
    uint64_t v10 = fts_open(v25, 92, 0LL);
    if (v10)
    {
      size_t v11 = v10;
      uint64_t v12 = fts_read(v10);
      if (v12)
      {
        ssize_t v13 = v12;
        uint64_t v14 = 0LL;
        while (1)
        {
          unsigned int fts_info = v13->fts_info;
          if (fts_info > 6) {
            break;
          }
          if (fts_info == 1)
          {
            if (v14)
            {
              ++v14;
              fts_set(v11, v13, 4);
              uint64_t fts_path = (uint64_t)v13->fts_path;
              int v17 = 3;
LABEL_20:
              int fts_errno = 0;
              goto LABEL_23;
            }

            uint64_t v14 = 1LL;
          }

          else
          {
            if (fts_info != 6) {
              goto LABEL_22;
            }
            --v14;
          }

LABEL_25:
          ssize_t v13 = fts_read(v11);
          if (!v13) {
            goto LABEL_29;
          }
        }

        if (fts_info == 7)
        {
          uint64_t fts_path = (uint64_t)v13->fts_path;
          int fts_errno = v13->fts_errno;
          int v17 = 4;
        }

        else
        {
          if (fts_info == 11)
          {
            uint64_t fts_path = (uint64_t)v13->fts_path;
            int v17 = 0;
            goto LABEL_20;
          }

  uint64_t v19 = 0LL;
  if (v20) {
    goto LABEL_26;
  }
  char v41 = *(void *)v27;
LABEL_29:
  if (v41 == 15)
  {
    sub_100020C0C(a1, 5);
    if (!v19) {
      uint64_t v19 = *(unsigned int *)(a1 + 808);
    }
    int v42 = (void (__cdecl *)(void *))sub_100024874;
  }

  else if (v41 == 9)
  {
    sub_100020C0C(a1, 6);
    if (!v19) {
      uint64_t v19 = dword_100069A3C;
    }
    int v42 = (void (__cdecl *)(void *))sub_10002469C;
  }

  else
  {
    int v43 = strsignal(v41);
    sub_10001A4D8(a1, 4, "Service was sent unexpected signal: %s", v44, v45, v46, v47, v48, v43);
    int v42 = (void (__cdecl *)(void *))sub_10002469C;
    uint64_t v19 = 1LL;
  }

  if (a2 == 2) {
    uint64_t v19 = 10LL;
  }
  strsignal(*(unsigned __int8 *)(a1 + 1164));
  sub_10001A4D8(a1, 5, "scheduling cleanup in %llu sec after sending %s", v49, v50, v51, v52, v53, v19);
  if (*(void *)(a1 + 1152)) {
    sub_100039448("tried to overwrite service timeout_source");
  }
  uint64_t v54 = (dispatch_queue_s *)sub_100011938();
  *(void *)(a1 + 1152) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v54);
  sub_100016C50(a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 1152), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 1152), v42);
  int v55 = *(dispatch_source_s **)(a1 + 1152);
  uint64_t v56 = dispatch_time(0LL, 1000000000 * v19);
  dispatch_source_set_timer(v55, v56, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1152));
  return 0LL;
}

LABEL_29:
      if (fts_close(v11) == -1) {
        sub_1000470C8();
      }
    }

    else
    {
      uint64_t v20 = *(const char **)(v2 + 64);
      int v21 = *__error();
      uint64_t v22 = __error();
      uint64_t v23 = (const char *)xpc_strerror(*v22);
      sub_10003AB08(4, "failed to fts_open(%s, 0x%x): %d: %s", v20, 92, v21, v23);
    }

    int v8 = 0;
    goto LABEL_34;
  }

  int v6 = __error();
  unsigned __int16 v7 = 0LL;
LABEL_4:
  int v8 = *v6;
LABEL_34:
  sub_100012080(v2, v7, v8);
  if (v7) {
    sub_10001685C(v7);
  }
LABEL_37:
  sub_10001685C(*(void **)(a1 + 32));
}

            uint64_t v12 = 0LL;
            goto LABEL_30;
          }
        }
      }
    }

    uint64_t v12 = sub_100004B74(v81, v8, v80, v79, (uint64_t)v84, (2 * v43) & 0x200LL | v30, (int *)&v85);
    if (!v12) {
      goto LABEL_30;
    }
    int v58 = v85;
    a4 = v83;
    if (v81 == a1 && (_DWORD)v85 != 121)
    {
      uint64_t v60 = (_DWORD *)a1;
      goto LABEL_63;
    }
  }

  unsigned int v59 = *((void *)v12 + 19);
  if (v59)
  {
    do
    {
      unsigned int v59 = *(void *)(v59 + 16);
    }

    while (v59);
    int v58 = v85;
  }

  if (!v58)
  {
    uint64_t v60 = (_DWORD *)v81;
LABEL_63:
    sub_1000265C0(v60, (uint64_t)v12);
  }

  dispatch_queue_t result = qword_10006A590;
  if (qword_10006A590) {
    return fflush((FILE *)qword_10006A590);
  }
  return result;
}

void sub_100012080(uint64_t a1, void *a2, int a3)
{
  int v6 = (dispatch_queue_s *)sub_100011944();
  dispatch_assert_queue_V2(v6);
  *(_DWORD *)(a1 + 240) = a3;
  sub_1000167B0((void *)a1);
  if (a2) {
    sub_1000167B0(a2);
  }
  unsigned __int16 v7 = *(dispatch_queue_s **)(a1 + 248);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = sub_100012128;
  v8[3] = &unk_100063ED8;
  v8[4] = a1;
  void v8[5] = a2;
  dispatch_async(v7, v8);
}

void sub_100012128(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2) {
    sub_10001685C(v2);
  }
  sub_10001685C(*(void **)(a1 + 32));
}

void sub_100012180(uint64_t a1)
{
  uint64_t v2 = (dispatch_semaphore_s *)sub_10000D648();
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  xpc_bundle_resolve_sync(*(void *)(*(void *)(a1 + 32) + 80LL));
  dispatch_semaphore_signal(v2);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(dispatch_queue_s **)(v3 + 248);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100012208;
  block[3] = &unk_100063EF8;
  block[4] = v3;
  dispatch_async(v4, block);
}

void sub_100012208(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 248));
  uint64_t v3 = *(void *)(v2 + 80);
  int error = xpc_bundle_get_error(v3);
  if (!error)
  {
    uint64_t property = (_OWORD *)xpc_bundle_get_property(v3, 4LL);
    *(_OWORD *)(v2 + 96) = *property;
    __int128 v6 = property[4];
    __int128 v8 = property[1];
    __int128 v7 = property[2];
    *(_OWORD *)(v2 + 144) = property[3];
    *(_OWORD *)(v2 + 160) = v6;
    *(_OWORD *)(v2 + 112) = v8;
    *(_OWORD *)(v2 + 128) = v7;
    __int128 v9 = property[8];
    __int128 v11 = property[5];
    __int128 v10 = property[6];
    *(_OWORD *)(v2 + 208) = property[7];
    *(_OWORD *)(v2 + 224) = v9;
    *(_OWORD *)(v2 + 176) = v11;
    *(_OWORD *)(v2 + 192) = v10;
  }

  *(_DWORD *)(v2 + 240) = error;
  (*(void (**)(void))(*(void *)(v2 + 256) + 16LL))();
  sub_10001685C(*(void **)(a1 + 32));
}

uint64_t sub_1000122A8(int *a1)
{
  return _os_assert_log(*a1);
}

size_t _xpc_spawnattr_pack_string_fragment(uint64_t a1, _DWORD *a2, void *a3, char *__src)
{
  size_t result = strlen(__src);
  *a2 += result;
  *a3 -= result;
  return result;
}

size_t _xpc_spawnattr_pack_string(uint64_t a1, _DWORD *a2, void *a3, char *__src)
{
  size_t result = strlen(__src);
  *a2 += result + 1;
  *a3 -= result + 1;
  return result;
}

const char *_xpc_spawnattr_unpack_string(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (a2 <= a3) {
    return 0LL;
  }
  uint64_t v3 = (const char *)(a1 + a3 + 240);
  if (strnlen(v3, a2 - a3) + 1 <= a2 - a3) {
    return v3;
  }
  else {
    return 0LL;
  }
}

void *_xpc_spawnattr_pack_bytes(uint64_t a1, _DWORD *a2, void *a3, void *__src, size_t __n)
{
  unsigned int v5 = __n;
  size_t result = memcpy((void *)(a1 + *a2 + 240), __src, __n);
  *a2 += v5;
  *a3 -= v5;
  return result;
}

uint64_t _xpc_spawnattr_unpack_bytes(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a2 - a3 >= a4) {
    uint64_t v4 = a1 + a3 + 240;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= a3) {
    return 0LL;
  }
  else {
    return v4;
  }
}

const char *_xpc_spawnattr_unpack_strings( uint64_t a1, unint64_t a2, unsigned int a3, const char **a4, uint64_t a5)
{
  if (a3 >= a2) {
    return 0LL;
  }
  uint64_t v5 = a5;
  if (!a5) {
    return *a4;
  }
  unsigned int v7 = a3;
  uint64_t v9 = a1 + 240;
  for (size_t i = a4; ; ++i)
  {
    __int128 v11 = (const char *)(v9 + v7);
    size_t v12 = strnlen(v11, a2 - v7);
    if (v12 + 1 > a2 - v7) {
      break;
    }
    v7 += v12 + 1;
    *size_t i = v11;
    if (!--v5) {
      return *a4;
    }
  }

  return 0LL;
}

uint64_t _xpc_spawnattr_binprefs_size(uint64_t a1)
{
  return 8LL * xpc_binprefs_count(a1);
}

uint64_t _xpc_spawnattr_binprefs_pack(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  unsigned int v8 = xpc_binprefs_count(a2);
  *(_DWORD *)(a1 + 32) = v8;
  uint64_t v9 = 0LL;
  if (v8)
  {
    *(_DWORD *)(a1 + 36) = *a3;
    uint64_t v10 = 8LL * (v8 - 1);
    uint64_t v11 = v8;
    size_t v12 = (_DWORD *)(*a3 + a1 + 244);
    do
    {
      *(v12 - 1) = xpc_binprefs_cpu_type(a2, v9);
      *size_t v12 = xpc_binprefs_cpu_subtype(a2, v9);
      v12 += 2;
      ++v9;
    }

    while (v11 != v9);
    uint64_t v9 = v10 + 8;
  }

  else
  {
    *(_DWORD *)(a1 + 36) = 0;
  }

  uint64_t result = xpc_binprefs_count(a2);
  *a3 += v9;
  *a4 -= v9;
  return result;
}

uint64_t _xpc_spawnattr_binprefs_unpack(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  xpc_binprefs_alloc();
  uint64_t v4 = v5;
  if (*(_DWORD *)(a1 + 32))
  {
    unint64_t v6 = 0LL;
    unsigned int v7 = (int *)(*(unsigned int *)(a1 + 36) + a1 + 244);
    do
    {
      xpc_binprefs_add(v4, *(v7 - 1), *v7);
      ++v6;
      v7 += 2;
    }

    while (v6 < *(unsigned int *)(a1 + 32));
  }

  return v4;
}

uint64_t sub_100012654()
{
  return 1LL;
}

void *sub_100012670(const void *a1, size_t __size)
{
  uint64_t v4 = sub_100010B00(__size);
  return memcpy(v4, a1, __size);
}

char *sub_1000126A0(const char *a1)
{
  for (size_t i = a1; ; a1 = i)
  {
    uint64_t result = strdup(a1);
    if (result) {
      break;
    }
    if (*__error() != 12)
    {
      int v3 = *__error();
      if (v3) {
        sub_100046EE0(v3);
      }
    }

    sub_100012654();
  }

  return result;
}

char *sub_1000126F4(const char *a1, size_t a2)
{
  size_t v2 = a2;
  int v3 = a1;
  while (1)
  {
    uint64_t result = strndup(a1, a2);
    if (result) {
      break;
    }
    if (*__error() != 12)
    {
      int v5 = *__error();
      if (v5) {
        sub_100046EE0(v5);
      }
    }

    sub_100012654();
    a1 = v3;
    a2 = v2;
  }

  return result;
}

uint64_t sub_10001274C(const char *a1, const char *a2)
{
  uint64_t v3 = 0LL;
  while (1)
  {
    unint64_t v4 = v8[v3];
    unint64_t v5 = v7[v3];
    if (v4 > v5) {
      break;
    }
    if (v4 < v5) {
      return 0xFFFFFFFFLL;
    }
    if (++v3 == 3) {
      return 0LL;
    }
  }

  return 1LL;
}

void sub_100012808(const char *a1, uint64_t a2)
{
  uint64_t v3 = strdup(a1);
  uint64_t v4 = 0LL;
  __stringp = v3;
  do
  {
    unint64_t v5 = strsep(&__stringp, ".");
    if (!v5) {
      break;
    }
    unint64_t v6 = 0LL;
    *(void *)(a2 + v4) = strtoull(v5, &v6, 10);
    v4 += 8LL;
  }

  while (v4 != 24);
  free(v3);
}

char *sub_100012884(char *a1, ...)
{
  uint64_t v4 = 0LL;
  while (1)
  {
    vasprintf(&v4, a1, va);
    uint64_t result = v4;
    if (v4) {
      break;
    }
    if (*__error() != 12)
    {
      int v3 = *__error();
      if (v3) {
        sub_100046EE0(v3);
      }
    }

    sub_100012654();
  }

  return result;
}

void *sub_1000128F4(const void *a1)
{
  for (size_t i = a1; ; a1 = i)
  {
    uint64_t result = _Block_copy(a1);
    if (result) {
      break;
    }
    if (*__error() != 12)
    {
      int v3 = *__error();
      if (v3) {
        sub_100046EE0(v3);
      }
    }

    sub_100012654();
  }

  return result;
}

BOOL sub_100012944(const char *a1, char *__s)
{
  size_t v4 = strlen(__s);
  return strncmp(a1, __s, v4) == 0;
}

BOOL sub_100012984(const char *a1, const char *a2)
{
  size_t v4 = &a1[strlen(a1)];
  unint64_t v5 = &v4[-strlen(a2)];
  return v5 >= a1 && strcmp(v5, a2) == 0;
}

BOOL sub_1000129E0(const char *a1, const char *a2)
{
  return strstr(a1, a2) != 0LL;
}

BOOL sub_1000129FC(char *__s1, const char *a2)
{
  BOOL result = ((unint64_t)__s1 | (unint64_t)a2) == 0;
  if (__s1)
  {
    if (a2) {
      return strcmp(__s1, a2) == 0;
    }
  }

  return result;
}

BOOL sub_100012A34(char *a1, const char *a2)
{
  BOOL result = ((unint64_t)a1 | (unint64_t)a2) == 0;
  if (a1)
  {
    if (a2) {
      return strcasecmp(a1, a2) == 0;
    }
  }

  return result;
}

size_t sub_100012A6C(xpc_object_t xarray, const char *a2)
{
  size_t result = 0LL;
  if (xarray)
  {
    if (a2)
    {
      size_t result = xpc_array_get_count(xarray);
      if (result)
      {
        size_t v5 = result;
        size_t v6 = 0LL;
        while (1)
        {
          string = xpc_array_get_string(xarray, v6);
          if (string)
          {
            if (!strcmp(string, a2)) {
              break;
            }
          }

          if (v5 == ++v6) {
            return 0LL;
          }
        }

        return 1LL;
      }
    }
  }

  return result;
}

BOOL sub_100012AE8(void *a1)
{
  return xpc_array_apply(a1, &stru_100063F58);
}

BOOL sub_100012AF4(id a1, unint64_t a2, void *a3)
{
  return xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string;
}

uint64_t sub_100012B1C(_BYTE *a1, uint64_t a2)
{
  if (!a2) {
    return 5381LL;
  }
  uint64_t result = 5381LL;
  do
  {
    uint64_t v4 = *a1;
    if (!*a1) {
      break;
    }
    ++a1;
    uint64_t result = 33 * result + v4;
    --a2;
  }

  while (a2);
  return result;
}

uint64_t sub_100012B50(_BYTE *a1)
{
  char v1 = *a1;
  if (!*a1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  uint64_t v4 = a1 + 1;
  do
  {
    uint64_t result = 33 * result + v1;
    int v5 = *v4++;
    char v1 = v5;
  }

  while (v5);
  return result;
}

uint64_t sub_100012B80(int a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  for (uint64_t i = a2 + 8; *(_DWORD *)(i - 8) != a1; i += 16LL)
  {
    if (!--a3) {
      return 0LL;
    }
  }

  return *(void *)i;
}

xpc_type_t sub_100012BB0( FILE *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a3) {
    sub_10003D250((uint64_t)a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  }
  xpc_type_t result = xpc_get_type(a4);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    double value = COERCE_DOUBLE(xpc_string_get_string_ptr(a4));
    uint64_t v35 = "%s";
LABEL_22:
    uint64_t v37 = a1;
    uint64_t v38 = 0LL;
    return (xpc_type_t)sub_10003D32C(v37, v38, v35, v12, v13, v14, v15, v16, *(void *)&value);
  }

  if (result == (xpc_type_t)&_xpc_type_int64)
  {
    double value = COERCE_DOUBLE(xpc_int64_get_value(a4));
    uint64_t v35 = "%lld";
    goto LABEL_22;
  }

  if (result == (xpc_type_t)&_xpc_type_uint64)
  {
    double value = COERCE_DOUBLE(xpc_uint64_get_value(a4));
    uint64_t v35 = "%llu";
    goto LABEL_22;
  }

  if (result == (xpc_type_t)&_xpc_type_double)
  {
    double value = xpc_double_get_value(a4);
    uint64_t v35 = "%f";
    goto LABEL_22;
  }

  if (result == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (a4 == &_xpc_BOOL_true) {
      uint64_t v36 = "true";
    }
    else {
      uint64_t v36 = "false";
    }
    double value = *(double *)&v36;
    uint64_t v35 = "%s";
    goto LABEL_22;
  }

  if (result == (xpc_type_t)&_xpc_type_date)
  {
    time_t v43 = (uint64_t)(xpc_date_get_value_absolute(a4) + 978307200.0);
    memset(&v42, 0, sizeof(v42));
    gmtime_r(&v43, &v42);
    *(void *)int v44 = 0LL;
    uint64_t v45 = 0LL;
    memset(v46, 0, sizeof(v46));
    strftime(v44, 0x1EuLL, "%a %b %d %T %Y %Z", &v42);
    double value = COERCE_DOUBLE(v44);
    uint64_t v35 = "%s (approx)";
    goto LABEL_22;
  }

  if (result == (xpc_type_t)&_xpc_type_array)
  {
    sub_10003D32C(a1, 0LL, "[", v12, v13, v14, v15, v16);
    if (xpc_array_get_count(a4))
    {
      size_t v39 = 0LL;
      do
      {
        sub_10003D2C0(a1, a2 + 1, "%lu = ", v29, v30, v31, v32, v33, v39);
        xpc_object_t v40 = xpc_array_get_value(a4, v39);
        sub_100012BB0(a1, a2 + 1, 0LL, v40);
        ++v39;
      }

      while (v39 < xpc_array_get_count(a4));
    }

    uint64_t v34 = "]";
    return (xpc_type_t)sub_10003D32C(a1, a2, v34, v29, v30, v31, v32, v33);
  }

  if (result == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10003D32C(a1, 0LL, "{", v12, v13, v14, v15, v16);
    *(void *)&v42.tm_sec = 0LL;
    *(void *)&v42.tm_hour = a1;
    *(void *)&v42.tm_mon = a2 + 1;
    xpc_dictionary_apply_f(a4);
    uint64_t v35 = "}";
    uint64_t v37 = a1;
    uint64_t v38 = a2;
    return (xpc_type_t)sub_10003D32C(v37, v38, v35, v12, v13, v14, v15, v16, *(void *)&value);
  }

  if (result == (xpc_type_t)&_xpc_type_bundle)
  {
    sub_10003D32C(a1, 0LL, "@bundle {", v12, v13, v14, v15, v16);
    info_xpc_object_t dictionary = xpc_bundle_get_info_dictionary(a4);
    sub_10003D2C0(a1, a2 + 1, "info plist = ", v18, v19, v20, v21, v22);
    sub_100012BB0(a1, a2 + 1, 0LL, info_dictionary);
    uint64_t v23 = (void *)xpc_bundle_copy_services(a4);
    sub_10003D2C0(a1, a2 + 1, "service bundles => ", v24, v25, v26, v27, v28);
    sub_100012BB0(a1, a2 + 1, 0LL, v23);
    xpc_release(v23);
    uint64_t v34 = "}";
    return (xpc_type_t)sub_10003D32C(a1, a2, v34, v29, v30, v31, v32, v33);
  }

  return result;
}

uint64_t sub_100012F74( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(FILE **)(a3 + 8);
  uint64_t v10 = *(void *)(a3 + 16);
  sub_10003D2C0(v9, v10, "%s => ", a4, a5, a6, a7, a8, a1);
  return sub_100012BB0(v9, v10, 0LL, a2);
}

uint64_t sub_100012FCC(uint64_t a1, mach_port_context_t a2)
{
  v4.reserved[1] = 0LL;
  memset(v5, 0, sizeof(v5));
  char v6 = 7;
  __strlcpy_chk(v5, a1, 255LL, 255LL);
  *(void *)&v4.flags = 0x8000000433LL;
  v4.reserved[0] = (uint64_t)v5;
  return sub_10000AB40(&v4, a2);
}

void os_crash_function(const char *a1)
{
}

void start()
{
  kern_return_t v25;
  uint64_t v26;
  pid_t v27;
  int v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  dispatch_object_s *v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  mach_port_t init_port_set[4];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  unint64_t v69;
  char *v70;
  char out[48];
  if (!getenv("LAUNCH_DID_REEXEC") && !getenv("XPC_USERSPACE_REBOOTED")) {
    sub_100039D0C("kern.initproc_spawned", 1);
  }
  _os_crash_callback = os_crash_function;
  int v0 = isatty(1);
  if (v0 && !byte_10006A999)
  {
    int v1 = v0;
    size_t v2 = __stdoutp;
    int v3 = getprogname();
    fprintf(v2, "%s cannot be run directly.\n", v3);
    mach_port_options_t v4 = getprogname();
    sub_100039448("%s cannot be run directly (stdout: %d)", v4, v1);
  }

  pid_t v5 = getpid();
  if (v5 != 1 && !byte_10006A999)
  {
    pid_t v6 = v5;
    unsigned int v7 = __stdoutp;
    unsigned int v8 = getprogname();
    fprintf(v7, "%s cannot be run directly.\n", v8);
    uint64_t v9 = getprogname();
    sub_100039448("%s cannot be run directly (pid = %d)", v9, v6);
  }

  mach_port_t v10 = mach_host_self();
  panic_init(v10);
  sub_10001185C();
  if (!byte_10006A999)
  {
    sub_100013720(0, 0);
    sub_100013720(1, 1);
    sub_100013720(2, 2);
  }

  sub_10000E624(570425408LL);
  sub_10000E110();
  uint64_t v11 = sub_100040854();
  nullsub_23(v11, v12);
  sub_1000016F4();
  memset(out, 0, 37);
  memset(init_port_set, 0, sizeof(init_port_set));
  uint64_t v13 = _NSGetMachExecuteHeader();
  _os_assumes_log(0LL);
  while (1)
  {
    sub_10003AB08(5, "hello, launchd UUID: %s", out);
    if (byte_10006A9B3) {
      dword_100069A5C = -1;
    }
    if (byte_10006A97F)
    {
      sub_10003AB08(65543, "Memory limit override file is present, disabling memory limits.");
      dword_100069A5C = -1;
      *(void *)init_port_set = 0LL;
    }

    else
    {
      *(void *)init_port_set = 0LL;
    }

    uint64_t v14 = getpid();
    if (memorystatus_control(6LL, v14, dword_100069A5C, 0LL, 0LL) == -1)
    {
      int v15 = dword_100069A5C;
      int v16 = *__error();
      int v17 = __error();
      uint64_t v18 = strerror(*v17);
      sub_10003AB08(65539, "Could not opt into %d MB Jetsam high watermark: %d: %s", v15, v16, v18);
    }

    sub_10003AB08(65541, "%s", off_100069A70[0]);
    uint64_t v70 = 0LL;
    if (sub_100039AB8("kern.bootargs", &v70)) {
      sub_10003AB08(65541, "boot-args = %s", v70);
    }
    free(v70);
    uint64_t v19 = getpid();
    if (proc_disable_wakemon(v19) == -1)
    {
      uint64_t v38 = __error();
      size_t v39 = _os_assert_log(*v38);
      _os_crash(v39, v40, v41, v42);
      __break(1u);
    }

    else
    {
      if (byte_10006A999)
      {
        byte_10006A9E2 = 1;
        sub_10003AB08(65541, "Lean Testing Environment starting.");
      }

      int v20 = byte_10006A99D;
      if (byte_10006A99B && !byte_10006A99D)
      {
        byte_10006A9E2 = 1;
        sub_10003AB08(65541, "Restore environment starting.");
        int v20 = byte_10006A99D;
      }

      if (v20)
      {
        byte_10006A9E2 = 1;
        sub_10003AB08(65541, "BaseSystem environment starting.");
      }

      uint64_t v69 = 0LL;
      if (sub_1000017BC(&v69)) {
        sub_10003AB08(65541, "Running with Probabilistic Guard Malloc envvar (Sample Rate = %zu)", v69);
      }
      if (setsid() == -1 && !byte_10006A999 && (!byte_10006A9B8 || *__error() != 1))
      {
        uint64_t v21 = *__error();
        if ((_DWORD)v21) {
          goto LABEL_57;
        }
      }

      if (chdir("/") != -1)
      {
        if (setlogin("root") != -1)
        {
          uint64_t v22 = 0LL;
          while (1)
          {
            int v23 = dword_100049490[v22];
            dword_100069C90 |= 1 << (v23 - 1);
            if (signal(v23, (void (__cdecl *)(int))1) == (void (__cdecl *)(int))-1LL)
            {
              uint64_t v24 = __error();
              _os_assumes_log(*v24);
            }

            if (++v22 == 21)
            {
              uint64_t v25 = task_set_special_port(mach_task_self_, 4, 0);
              if (!v25)
              {
                bootstrap_uint64_t port = 0;
                uint64_t v26 = sub_100012FCC((uint64_t)off_100069630, 0x70507uLL);
                init_port_set[0] = v26;
                if (!mach_ports_register(mach_task_self_, init_port_set, 1u))
                {
                  dword_10006A940 = v26;
                  qword_10006A948 = xpc_mach_send_create_with_disposition(v26, 17LL);
                  qword_10006A8C0 = mach_absolute_time();
                  uuid_generate(byte_10006A8D0);
                  LODWORD(qword_10006A8E0) = getuid();
                  HIDWORD(qword_10006A8E0) = geteuid();
                  dword_10006A8E8 = getegid();
                  dword_10006A8EC = geteuid();
                  LODWORD(qword_10006A8F0) = getegid();
                  HIDWORD(qword_10006A8F0) = getpid();
                  dword_10006A8F8 = sub_10001C0CC();
                  unk_10006A8FC = 0;
                  uint64_t v67 = 0u;
                  uint64_t v68 = 0u;
                  uint64_t v65 = 0u;
                  uint64_t v66 = 0u;
                  uint64_t v63 = 0u;
                  uint64_t v64 = 0u;
                  int v61 = 0u;
                  uint64_t v62 = 0u;
                  unsigned int v59 = 0u;
                  uint64_t v60 = 0u;
                  *(_OWORD *)init_port_set = 0u;
                  int v58 = 0u;
                  uint64_t v27 = getpid();
                  uint64_t v28 = sub_100039954(v27, init_port_set);
                  if (v28)
                  {
                    if (v28 != 45) {
                      sub_100039448("could not get unique pid");
                    }
                  }

                  qword_10006A8C8 = *((void *)&v66 + 1);
                  sub_10003DF18();
                  sub_10000D4F8();
                  sub_100034D0C();
                  uint64_t v29 = sub_10001C380();
                  sub_1000298AC((uint64_t)v29, v30, v31, v32);
                  sub_100036760();
                  sub_1000377F0();
                  sub_100034444();
                  sub_100034238();
                  nullsub_23(v33, v34);
                  sub_100010D7C();
                  sub_1000010B8();
                  sub_1000198A8();
                  uint64_t v35 = sub_10000BFC8();
                  nullsub_23(v35, v36);
                  sub_10000D0D0();
                  sub_10000F73C();
                  sub_100019F14();
                  sub_10003C268();
                  uint64_t v37 = (dispatch_object_s *)sub_100011938();
                  dispatch_activate(v37);
                  dispatch_main();
                }

                sub_100039448("could not set up inheritance port");
              }

              sub_10003AB08(3, "Could not neuter bootstrap port: 0x%x", v25);
              exit(1);
            }
          }
        }

        goto LABEL_56;
      }
    }

    time_t v43 = __error();
    int v44 = _os_assert_log(*v43);
    _os_crash(v44, v45, v46, v47);
    __break(1u);
LABEL_56:
    uint64_t v48 = __error();
    uint64_t v49 = _os_assert_log(*v48);
    uint64_t v21 = _os_crash(v49, v50, v51, v52);
    __break(1u);
LABEL_57:
    uint64_t v53 = _os_assert_log(v21);
    _os_crash(v53, v54, v55, v56);
    __break(1u);
LABEL_58:
    uuid_unparse((const unsigned __int8 *)init_port_set, out);
  }

int *sub_100013720(int a1, int a2)
{
  xpc_type_t result = (int *)open("/dev/null", a1 | 0x20000, 438LL);
  if ((_DWORD)result != -1)
  {
    mach_port_options_t v4 = (int *)dup2((int)result, a2);
    if ((_DWORD)v4 == -1)
    {
      int v5 = *__error();
      if (v5) {
        sub_100046EF4(v5);
      }
    }

    return sub_100036D70(v4);
  }

  return result;
}

size_t sub_10001379C(const char *a1)
{
  if ((sub_1000137F8(a1, "Frameworks") & 1) != 0 || (sub_1000137F8(a1, "PrivateFrameworks") & 1) != 0) {
    return 1LL;
  }
  else {
    return sub_1000137F8(a1, "AppRemovalServices");
  }
}

size_t sub_1000137F8(const char *a1, const char *a2)
{
  if (sub_100012944(a1, __str)) {
    return 1LL;
  }
  size_t result = (size_t)sub_1000411E4("SystemRoots");
  if (result)
  {
    int v5 = (void *)result;
    if (xpc_get_type((xpc_object_t)result) == (xpc_type_t)&_xpc_type_array)
    {
      size_t result = xpc_array_get_count(v5);
      if (result)
      {
        size_t v6 = 0LL;
        while (1)
        {
          string = xpc_array_get_string(v5, v6);
          if (string)
          {
            unsigned int v8 = string;
            bzero(__str, 0x400uLL);
            snprintf(__str, 0x400uLL, "%s/%s", v8, a2);
            if (sub_100012944(a1, __str)) {
              break;
            }
          }

          if (++v6 >= xpc_array_get_count(v5)) {
            return 0LL;
          }
        }

        return 1LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

char *sub_100013948(char a1, const char *a2, _OWORD *a3, uint64_t a4, dispatch_object_s *a5)
{
  mach_port_t v10 = (char *)sub_100016D4C(0LL);
  v10[100] = a1;
  *((void *)v10 + 2) = sub_1000126A0(a2);
  __int128 v11 = a3[1];
  *(_OWORD *)(v10 + 24) = *a3;
  *(_OWORD *)(v10 + 40) = v11;
  *((void *)v10 + 7) = a4;
  *((void *)v10 + 8) = a5;
  dispatch_retain(a5);
  return v10;
}

void sub_1000139BC(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 101) & 1) != 0) {
    sub_100046EB4();
  }
  free(*(void **)(a1 + 16));
  dispatch_release(*(dispatch_object_t *)(a1 + 64));
  size_t v2 = *(const void **)(a1 + 72);
  if (v2) {
    _Block_release(v2);
  }
  int v3 = *(const void **)(a1 + 80);
  if (v3) {
    _Block_release(v3);
  }
  mach_port_options_t v4 = *(void **)(a1 + 88);
  if (v4)
  {
    sub_10001685C(v4);
    *(void *)(a1 + 88) = 0LL;
  }

void *sub_100013A28(uint64_t a1, void *aBlock)
{
  if ((*(_BYTE *)(a1 + 101) & 1) != 0) {
    sub_100046EB4();
  }
  size_t result = _Block_copy(aBlock);
  *(void *)(a1 + 72) = result;
  return result;
}

void *sub_100013A5C(uint64_t a1, void *aBlock)
{
  if ((*(_BYTE *)(a1 + 101) & 1) != 0) {
    sub_100046EB4();
  }
  size_t result = _Block_copy(aBlock);
  *(void *)(a1 + 80) = result;
  return result;
}

void sub_100013A90(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 101) & 1) != 0) {
    sub_100046EB4();
  }
  *(_BYTE *)(a1 + 101) |= 1u;
  sub_1000167B0((void *)a1);
  if (!*(void *)(a1 + 72)) {
    sub_100046EB4();
  }
  if (!*(void *)(a1 + 80)) {
    sub_100046EB4();
  }
  size_t v2 = *(const char **)(a1 + 16);
  if (*v2 != 47 || sub_100012944(*(const char **)(a1 + 16), "/usr/lib") || (BOOL v3 = sub_100012944(v2, "/usr/local/lib")))
  {
    sub_100013C9C(a1);
  }

  else
  {
    int v7 = *(unsigned __int8 *)(a1 + 100);
    switch(*(_BYTE *)(a1 + 100))
    {
      case 1:
        sub_100013D08(a1);
        return;
      case 2:
        sub_100013DC4(a1);
        return;
      case 3:
        sub_100013E78(a1);
        return;
      case 4:
      case 5:
        if (!qword_100069C98) {
          goto LABEL_20;
        }
        if (xpc_dictionary_get_BOOL((xpc_object_t)qword_100069C98, *(const char **)(a1 + 16)))
        {
          sub_1000148D0(a1);
        }

        else
        {
          int v7 = *(unsigned __int8 *)(a1 + 100);
LABEL_20:
          if (v7 == 5) {
            int v14 = 1;
          }
          else {
            int v14 = 2;
          }
          uint64_t v9 = sub_10000D6C0(v14, *(void *)(a1 + 16), 0);
          __int128 v15 = *(_OWORD *)(a1 + 40);
          *((_OWORD *)v9 + 1) = *(_OWORD *)(a1 + 24);
          *((_OWORD *)v9 + 2) = v15;
          __int128 v11 = *(dispatch_object_s **)(a1 + 64);
          *((void *)v9 + 6) = *(void *)(a1 + 56);
          int v16 = _NSConcreteStackBlock;
          uint64_t v17 = 0x40000000LL;
          uint64_t v12 = sub_100014BC4;
          uint64_t v13 = &unk_1000640A0;
LABEL_24:
          uint64_t v18 = v12;
          uint64_t v19 = v13;
          uint64_t v20 = a1;
          uint64_t v21 = v9;
          sub_10000D6F0((uint64_t)v9, v11, &v16);
        }

        break;
      case 6:
      case 7:
        if (v7 == 7) {
          int v8 = 1;
        }
        else {
          int v8 = 2;
        }
        uint64_t v9 = sub_10000D6C0(v8, *(void *)(a1 + 16), 0);
        __int128 v10 = *(_OWORD *)(a1 + 40);
        *((_OWORD *)v9 + 1) = *(_OWORD *)(a1 + 24);
        *((_OWORD *)v9 + 2) = v10;
        __int128 v11 = *(dispatch_object_s **)(a1 + 64);
        *((void *)v9 + 6) = *(void *)(a1 + 56);
        int v16 = _NSConcreteStackBlock;
        uint64_t v17 = 0x40000000LL;
        uint64_t v12 = sub_100014DA4;
        uint64_t v13 = &unk_1000640C0;
        goto LABEL_24;
      default:
        sub_1000470E0(v3, v4, v5, v6);
    }
  }

void sub_100013C9C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 101) & 1) == 0) {
    sub_100046EB4();
  }
  *(_BYTE *)(a1 + 101) &= ~1u;
  sub_10001685C((void *)a1);
}

void sub_100013D08(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  BOOL v3 = *(const char **)(a1 + 16);
  if (sub_100012984(v3, ".plist"))
  {
    char v4 = 2;
  }

  else if (sub_100012984(v3, ".xpc") || sub_100012984(v3, ".pluginkit"))
  {
    v2 |= 0x1000uLL;
    char v4 = 7;
  }

  else
  {
    char v4 = 3;
  }

  uint64_t v5 = sub_100013948(v4, v3, (_OWORD *)(a1 + 24), v2, *(dispatch_object_s **)(a1 + 64));
  sub_10001480C(a1, v5);
  sub_10001685C(v5);
  sub_1000148D0(a1);
}

void sub_100013DC4(uint64_t a1)
{
  uint64_t v2 = *(const char **)(a1 + 16);
  if (sub_100012984(v2, ".plist"))
  {
    BOOL v3 = sub_10000D6C0(0, (uint64_t)v2, 0);
    __int128 v4 = *(_OWORD *)(a1 + 40);
    *((_OWORD *)v3 + 1) = *(_OWORD *)(a1 + 24);
    *((_OWORD *)v3 + 2) = v4;
    uint64_t v5 = *(dispatch_object_s **)(a1 + 64);
    *((void *)v3 + 6) = *(void *)(a1 + 56);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    v6[2] = sub_100014A38;
    v6[3] = &unk_100064060;
    v6[4] = a1;
    v6[5] = v3;
    sub_10000D6F0((uint64_t)v3, v5, v6);
  }

  else
  {
    sub_100013C9C(a1);
  }

void sub_100013E78(uint64_t a1)
{
  uint64_t v2 = sub_10000D6C0(3, *(void *)(a1 + 16), 0);
  __int128 v3 = *(_OWORD *)(a1 + 40);
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 24);
  *((_OWORD *)v2 + 2) = v3;
  __int128 v4 = *(dispatch_object_s **)(a1 + 64);
  *((void *)v2 + 6) = *(void *)(a1 + 56);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_100014A78;
  v5[3] = &unk_100064080;
  v5[4] = a1;
  void v5[5] = v2;
  sub_10000D6F0((uint64_t)v2, v4, v5);
}

void sub_100013EF8(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 140) & 1) != 0) {
    sub_100046EB4();
  }
  sub_10001685C(*(void **)(a1 + 48));
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2) {
    xpc_release(v2);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 16));
  _Block_release(*(const void **)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 80));
  __int128 v3 = *(dispatch_object_s **)(a1 + 56);
  if (v3) {
    dispatch_release(v3);
  }
  sub_10001685C(*(void **)(a1 + 64));
  sub_10001685C(*(void **)(a1 + 32));
}

void sub_100013F88(void *a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a6;
  if (!a1[28]) {
    a1[28] = mach_absolute_time();
  }
  if (a2 == 1) {
    sub_100026264((uint64_t)a1, 8LL, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v48);
  }
  int v14 = (dispatch_object_s *)sub_100011938();
  __int128 v15 = (char *)sub_100016D20(0LL);
  *((void *)v15 + 6) = sub_1000167B0(a1);
  v15[96] = a2;
  *((void *)v15 + 11) = v8;
  if (a3) {
    *((void *)v15 + 9) = xpc_retain(a3);
  }
  *((void *)v15 + 2) = v14;
  dispatch_retain(v14);
  *((void *)v15 + 10) = xpc_dictionary_create(0LL, 0LL, 0LL);
  *((void *)v15 + 4) = sub_10000E454();
  if (a2 == 2 && a3)
  {
    int v16 = dispatch_group_create();
    *((void *)v15 + 7) = v16;
    dispatch_group_enter(v16);
  }

  *((void *)v15 + 8) = sub_10003CBF8();
  if ((uint64_t *)a5 == &qword_10006A8E0
    || (*(void *)a5 == qword_10006A8E0 ? (BOOL v17 = *(void *)(a5 + 8) == *(void *)&dword_10006A8E8) : (BOOL v17 = 0),
        v17 ? (BOOL v18 = *(void *)(a5 + 16) == qword_10006A8F0) : (BOOL v18 = 0),
        v18 ? (BOOL v19 = *(void *)(a5 + 24) == *(void *)&dword_10006A8F8) : (BOOL v19 = 0),
        v19))
  {
    char v20 = 2;
  }

  else if (sub_100015944((_OWORD *)a5, 0LL, 2))
  {
    char v20 = 2;
  }

  else
  {
    char v20 = 1;
  }

  v15[104] = v20;
  __int128 v21 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)(v15 + 108) = *(_OWORD *)a5;
  *(_OWORD *)(v15 + 124) = v21;
  if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(a4))
    {
      size_t v26 = 0LL;
      do
      {
        string = xpc_array_get_string(a4, v26);
        if (string)
        {
          uint64_t v28 = string;
          if ((v8 & 0x1000) != 0) {
            char v29 = 6;
          }
          else {
            char v29 = 4;
          }
          if ((v8 & 0x1000) != 0) {
            char v30 = 7;
          }
          else {
            char v30 = 5;
          }
          else {
            char v31 = v30;
          }
          uint64_t v8 = v8 & 0xFFFFFF00;
          uint64_t v32 = (dispatch_object_s *)sub_100011938();
          uint64_t v33 = sub_100013948(v31, v28, v15 + 108, v8, v32);
          sub_100014DE4((uint64_t)v15, v33);
          sub_10001685C(v33);
        }

        ++v26;
      }

      while (v26 < xpc_array_get_count(a4));
    }
  }

  else if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
  {
    if ((v8 & 0x1000) != 0) {
      char v34 = 6;
    }
    else {
      char v34 = 4;
    }
    if ((v8 & 0x1000) != 0) {
      char v35 = 7;
    }
    else {
      char v35 = 5;
    }
    else {
      char v36 = 1;
    }
    else {
      char v37 = v36;
    }
    int64_t string_ptr = xpc_string_get_string_ptr(a4);
    size_t v39 = (dispatch_object_s *)sub_100011938();
    xpc_object_t v40 = sub_100013948(v37, string_ptr, v15 + 108, v8 & 0xFFFFFF00, v39);
    sub_100014DE4((uint64_t)v15, v40);
    sub_10001685C(v40);
  }

  else
  {
    xpc_type_t type = xpc_get_type(a4);
    if (type != (xpc_type_t)&_xpc_type_dictionary) {
      sub_1000470F8((uint64_t)type, v23, v24, v25);
    }
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_100014E9C;
    applier[3] = &unk_1000640E0;
    applier[4] = v8;
    void applier[5] = v15;
    xpc_dictionary_apply(a4, applier);
  }

  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000LL;
  aBlock[2] = sub_10001437C;
  aBlock[3] = &unk_100063F78;
  aBlock[4] = v15;
  if ((v15[140] & 1) != 0) {
    sub_100046EB4();
  }
  *((void *)v15 + 3) = _Block_copy(aBlock);
  char v41 = (dispatch_queue_s *)sub_100011938();
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 0x40000000LL;
  v49[2] = sub_10001456C;
  v49[3] = &unk_100063F98;
  v49[4] = v15;
  char v42 = sub_1000342FC((uint64_t)a3, v41, v49);
  if (a3)
  {
    if ((v42 & 1) == 0) {
      sub_10002587C((uint64_t)a1, 5, "couldn't handoff domain IO, asynced away", v43, v44, v45, v46, v47, v48);
    }
  }

void sub_10001437C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  __int128 v3 = *(uint64_t **)(v2 + 48);
  if ((*(_BYTE *)(v2 + 89) & 4) != 0)
  {
    if (*(_BYTE *)(v2 + 96) != 1) {
      sub_100046EB4();
    }
    __int128 v4 = *(rb_tree_t ***)(v2 + 64);
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 0x40000000LL;
    v22[2] = sub_100015560;
    v22[3] = &unk_100064160;
    v22[4] = v3;
    v22[5] = v2;
    sub_10003CB60(v4, (uint64_t)v22);
  }

  uint64_t v5 = *(void **)(v2 + 72);
  if (v5)
  {
    if (*(_BYTE *)(v2 + 96) == 1) {
      uint64_t v6 = "bootstrap-error";
    }
    else {
      uint64_t v6 = "bootout-error";
    }
    xpc_dictionary_set_int64(*(xpc_object_t *)(v2 + 72), v6, *(int *)(v2 + 100));
    xpc_dictionary_set_value(v5, "errors", *(xpc_object_t *)(v2 + 80));
    if (*(void *)(v2 + 56))
    {
      xpc_retain(v5);
      sub_1000167B0(v3);
      dispatch_group_leave(*(dispatch_group_t *)(v2 + 56));
      int v7 = *(dispatch_group_s **)(v2 + 56);
      uint64_t v8 = *(dispatch_queue_s **)(v2 + 16);
      int v16 = _NSConcreteStackBlock;
      uint64_t v17 = 0x40000000LL;
      BOOL v18 = sub_1000155E0;
      BOOL v19 = &unk_100064180;
      char v20 = v5;
      __int128 v21 = v3;
      dispatch_group_notify(v7, v8, &v16);
    }

    else if ((xpc_pipe_routine_reply(v5) | 0x20) != 0x20)
    {
      _os_assumes_log_ctx(sub_100025848, v3);
    }
  }

  else
  {
    __int128 v15 = *(void **)(v2 + 80);
    int v16 = _NSConcreteStackBlock;
    uint64_t v17 = 0x40000000LL;
    BOOL v18 = sub_100015644;
    BOOL v19 = &unk_1000641A0;
    char v20 = (void *)v2;
    xpc_dictionary_apply(v15, &v16);
  }

  if ((*(_BYTE *)(v2 + 89) & 0x20) != 0)
  {
    v3[29] = sub_10000A9C0(v3[28]);
    sub_100026568((uint64_t)v3);
  }

  if (*(_BYTE *)(v2 + 96) == 1) {
    sub_1000262C4((uint64_t)v3, 8LL, v9, v10, v11, v12, v13, v14);
  }
  sub_10001685C(*(void **)(a1 + 32));
}

void sub_10001456C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 16));
  if ((*(_BYTE *)(v1 + 140) & 1) != 0) {
    sub_100046EB4();
  }
  *(_BYTE *)(v1 + 140) |= 1u;
  sub_1000167B0((void *)v1);
  if (sub_10000E618(*(void *)(v1 + 32)))
  {
    uint64_t v2 = sub_10000E618(*(void *)(v1 + 32));
    if ((*(_BYTE *)(v1 + 90) & 1) != 0) {
      uint64_t v3 = 1LL;
    }
    else {
      uint64_t v3 = v2;
    }
    if (v3)
    {
      for (unint64_t i = 0LL; i != v3; ++i)
      {
        uint64_t v5 = sub_10000E5F0(*(void *)(v1 + 32), i);
        sub_100013A90(v5);
      }
    }
  }

  else
  {
    sub_100015488(v1);
  }

void sub_100014618(void *a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100014620(void *a1, const char *a2, void *a3, _OWORD *a4, uint64_t a5)
{
  uint64_t v10 = (dispatch_object_s *)sub_100011938();
  uint64_t v11 = sub_100013948(6, a2, a4, 20480LL, v10);
  if (a3) {
    xpc_retain(a3);
  }
  sub_1000167B0(a1);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = sub_1000146FC;
  v12[3] = &unk_100063FC0;
  v12[4] = a5;
  void v12[5] = a3;
  v12[6] = a1;
  v12[7] = v11;
  sub_100013A28((uint64_t)v11, v12);
  sub_100013A5C((uint64_t)v11, &stru_100064000);
  sub_100013A90((uint64_t)v11);
}

void sub_1000146FC(uint64_t a1, uint64_t a2, int a3)
{
  int v9 = a3;
  if (!a3)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    if (v5)
    {
      uint64_t v6 = sub_10000D81C(a2);
      if (!v6) {
        sub_100046EB4();
      }
      info_xpc_object_t dictionary = xpc_bundle_get_info_dictionary(v6);
      if (info_dictionary)
      {
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000LL;
        applier[2] = sub_1000156E4;
        applier[3] = &unk_1000641C0;
        applier[4] = info_dictionary;
        xpc_dictionary_apply(v5, applier);
      }
    }

    sub_10002917C(*(void *)(a1 + 48), a2, *(void **)(a1 + 40), &v9);
    uint64_t v8 = *(void **)(a1 + 40);
    if (v8) {
      xpc_release(v8);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  sub_10001685C(*(void **)(a1 + 48));
  sub_10001685C(*(void **)(a1 + 56));
}

void sub_1000147F4(id a1, _launch_domain_io_s *a2, _launch_io_s *a3, int a4)
{
}

void *sub_10001480C(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 96)) {
    sub_100046EB4();
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000LL;
  aBlock[2] = sub_100014978;
  aBlock[3] = &unk_100064020;
  aBlock[4] = a1;
  void aBlock[5] = a2;
  sub_100013A28((uint64_t)a2, aBlock);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_100014A30;
  v6[3] = &unk_100064040;
  v6[4] = a1;
  sub_100013A5C((uint64_t)a2, v6);
  __int128 v4 = *(void **)(a1 + 88);
  if (!v4)
  {
    __int128 v4 = sub_10000E454();
    *(void *)(a1 + 88) = v4;
  }

  return sub_10000E4D8(v4, a2);
}

void sub_1000148D0(uint64_t a1)
{
  if (*(void *)(a1 + 88))
  {
    sub_1000167B0((void *)a1);
    int v2 = sub_10000E618(*(void *)(a1 + 88));
    *(_DWORD *)(a1 + 96) = v2;
    if (!v2) {
      sub_100046EB4();
    }
    if (sub_10000E618(*(void *)(a1 + 88)))
    {
      unint64_t v3 = 0LL;
      do
      {
        uint64_t v4 = sub_10000E5F0(*(void *)(a1 + 88), v3);
        sub_100013A90(v4);
        ++v3;
      }

      while (v3 < sub_10000E618(*(void *)(a1 + 88)));
    }

    sub_10001685C((void *)a1);
  }

  else
  {
    sub_100013C9C(a1);
  }

void sub_100014978(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 96);
  if (!v3) {
    sub_100046EB4();
  }
  int v4 = v3 - 1;
  *(_DWORD *)(v2 + 96) = v4;
  if (!v4) {
    sub_100013C9C(v2);
  }
}

uint64_t sub_1000149D8(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 101) & 1) == 0) {
    sub_100046EB4();
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  return (*(uint64_t (**)(void))(*(void *)(a1 + 80) + 16LL))();
}

uint64_t sub_100014A30(uint64_t a1)
{
  return sub_1000149D8(*(void *)(a1 + 32));
}

void sub_100014A38(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_100046EB4();
  }
  sub_100013C9C(*(void *)(a1 + 32));
  sub_10001685C(*(void **)(a1 + 40));
}

void sub_100014A78(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    sub_100013C9C(*(void *)(a1 + 32));
  }

  else
  {
    if (!a2) {
      sub_100046EB4();
    }
    if (!sub_10000E618(a2) && (*(_BYTE *)(*(void *)(a1 + 32) + 57LL) & 0x20) == 0) {
      sub_10003AB08(4, "Activated a directory (%s) and found no files", "<private>");
    }
    if (sub_10000E618(a2))
    {
      unint64_t v5 = 0LL;
      do
      {
        uint64_t v6 = sub_10000E5F0(a2, v5);
        uint64_t v7 = *(void *)(a1 + 32);
        __int128 v8 = *(_OWORD *)(v7 + 40);
        *(_OWORD *)(v6 + 16) = *(_OWORD *)(v7 + 24);
        *(_OWORD *)(v6 + 32) = v8;
        *(void *)(v6 + 48) = *(void *)(v7 + 56);
        int v9 = sub_10000D7D4(v6);
        uint64_t v10 = (const char *)sub_10000D814(v6);
        if (v9 == 3) {
          char v11 = 5;
        }
        else {
          char v11 = 2;
        }
        uint64_t v12 = sub_100013948( v11,  v10,  (_OWORD *)(*(void *)(a1 + 32) + 24LL),  *(void *)(*(void *)(a1 + 32) + 56LL),  *(dispatch_object_s **)(*(void *)(a1 + 32) + 64LL));
        sub_10001480C(*(void *)(a1 + 32), v12);
        sub_10001685C(v12);
        ++v5;
      }

      while (v5 < sub_10000E618(a2));
    }

    sub_1000148D0(*(void *)(a1 + 32));
  }

  sub_10001685C(*(void **)(a1 + 40));
}

void sub_100014BC4(uint64_t a1, uint64_t a2, int a3)
{
  if (a2) {
    sub_100046EB4();
  }
  if (a3)
  {
    sub_100013C9C(*(void *)(a1 + 32));
    int v4 = (uint64_t *)(a1 + 40);
  }

  else
  {
    int v4 = (uint64_t *)(a1 + 40);
    uint64_t v5 = sub_10000D81C(*(void *)(a1 + 40));
    uint64_t v6 = (void *)xpc_bundle_copy_services(v5);
    if (xpc_array_get_count(v6))
    {
      size_t v7 = 0LL;
      do
      {
        xpc_object_t value = xpc_array_get_value(v6, v7);
        if (sub_10000D7E4(*v4))
        {
          int v9 = sub_100015A1C(value);
          int v10 = sub_10000D7D4((uint64_t)v9);
          uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 56LL) | 0x1000LL;
          uint64_t v12 = (const char *)sub_10000D814((uint64_t)v9);
          if (v10 == 1) {
            char v13 = 7;
          }
          else {
            char v13 = 6;
          }
          uint64_t v14 = sub_100013948( v13,  v12,  (_OWORD *)(*(void *)(a1 + 32) + 24LL),  v11,  *(dispatch_object_s **)(*(void *)(a1 + 32) + 64LL));
          __int128 v15 = *(_OWORD *)(v14 + 40);
          *((_OWORD *)v9 + 1) = *(_OWORD *)(v14 + 24);
          *((_OWORD *)v9 + 2) = v15;
          *((void *)v9 + 6) = *((void *)v14 + 7);
          sub_1000149D8(*(void *)(a1 + 32));
          sub_10001685C(v14);
        }

        else
        {
          path = (const char *)xpc_bundle_get_path(value);
          int v9 = sub_100013948( 7,  path,  (_OWORD *)(*(void *)(a1 + 32) + 24LL),  *(void *)(*(void *)(a1 + 32) + 56LL) | 0x1000LL,  *(dispatch_object_s **)(*(void *)(a1 + 32) + 64LL));
          sub_10001480C(*(void *)(a1 + 32), v9);
        }

        sub_10001685C(v9);
        ++v7;
      }

      while (v7 < xpc_array_get_count(v6));
    }

    if ((sub_10000D7E4(*v4) & 1) == 0 && !xpc_array_get_count(v6))
    {
      uint64_t v17 = *(void *)(a1 + 32);
      xpc_object_t v18 = (xpc_object_t)qword_100069C98;
      if (!qword_100069C98)
      {
        xpc_object_t v18 = xpc_dictionary_create(0LL, 0LL, 0LL);
        qword_100069C98 = (uint64_t)v18;
      }

      xpc_dictionary_set_BOOL(v18, *(const char **)(v17 + 16), 1);
    }

    xpc_release(v6);
    sub_1000148D0(*(void *)(a1 + 32));
  }

  sub_10001685C((void *)*v4);
}

void sub_100014DA4(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_100046EB4();
  }
  sub_100013C9C(*(void *)(a1 + 32));
  sub_10001685C(*(void **)(a1 + 40));
}

void *sub_100014DE4(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 40)) {
    sub_100046EB4();
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000LL;
  aBlock[2] = sub_100014F80;
  aBlock[3] = &unk_100064120;
  aBlock[4] = a1;
  void aBlock[5] = a2;
  sub_100013A28((uint64_t)a2, aBlock);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_1000154F8;
  v5[3] = &unk_100064140;
  v5[4] = a1;
  sub_100013A5C((uint64_t)a2, v5);
  return sub_10000E4D8(*(void **)(a1 + 32), a2);
}

uint64_t sub_100014E9C(uint64_t a1, const char *a2, xpc_object_t object)
{
  else {
    uint64_t value = 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 32) | value;
  int v8 = (*(_BYTE *)(a1 + 32) | value);
  if ((v7 & 0x1000) != 0) {
    char v9 = 6;
  }
  else {
    char v9 = 4;
  }
  if ((v7 & 0x1000) != 0) {
    char v10 = 7;
  }
  else {
    char v10 = 5;
  }
  if (v8 != 1) {
    char v10 = 1;
  }
  if (v8 == 2) {
    char v11 = v9;
  }
  else {
    char v11 = v10;
  }
  uint64_t v12 = v7 & 0xFFFFFF00;
  char v13 = (_OWORD *)(*(void *)(a1 + 40) + 108LL);
  uint64_t v14 = (dispatch_object_s *)sub_100011938();
  __int128 v15 = sub_100013948(v11, a2, v13, v12, v14);
  sub_100014DE4(*(void *)(a1 + 40), v15);
  sub_10001685C(v15);
  return 1LL;
}

void sub_100014F80(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v4 + 32);
  unint64_t v6 = *(void *)(v4 + 40) + 1LL;
  *(void *)(v4 + 40) = v6;
  if (v6 > sub_10000E618(v5)) {
    sub_100046EB4();
  }
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v7 + 40);
  uint64_t v9 = sub_10000E618(*(void *)(v7 + 32));
  uint64_t v10 = *(void *)(a1 + 32);
  if (v8 == v9)
  {
    sub_100015488(v10);
  }

  else if ((*(_BYTE *)(v10 + 90) & 1) != 0)
  {
    char v11 = (dispatch_queue_s *)sub_100011938();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_1000154DC;
    block[3] = &unk_100064100;
    block[4] = *(void *)(a1 + 32);
    dispatch_async(v11, block);
  }

void sub_10001504C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  if (!(_DWORD)a4)
  {
    int v7 = *(unsigned __int8 *)(a1 + 96);
    size_t v9 = *(void *)(a1 + 48);
    if (sub_100025D50(v9))
    {
      uint64_t v4 = 124LL;
      goto LABEL_47;
    }

    int v10 = *(unsigned __int8 *)(a2 + 100);
    if ((v10 - 6) >= 2)
    {
      if (v10 != 2)
      {
LABEL_46:
        uint64_t v4 = 0LL;
        goto LABEL_47;
      }

      if (v7 == 1)
      {
        uint64_t v11 = sub_100028538(v9, (uint64_t)a3);
LABEL_13:
        uint64_t v4 = v11;
        goto LABEL_47;
      }

      unsigned int v12 = sub_100028CD4(v9, (uint64_t)a3, *(dispatch_group_s **)(a1 + 56));
      else {
        uint64_t v4 = v12;
      }
    }

    else
    {
      if (v7 == 2)
      {
        uint64_t v4 = 116LL;
        goto LABEL_47;
      }

      if ((*(_BYTE *)(a1 + 89) & 4) == 0)
      {
        uint64_t v11 = sub_100029144(v9, (uint64_t)a3);
        goto LABEL_13;
      }

      uint64_t v13 = sub_10000D81C((uint64_t)a3);
      uint64_t v14 = *(rb_tree_t ***)(a1 + 64);
      info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary(v13);
      if (!info_dictionary
        || (int v16 = info_dictionary, (string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier")) == 0LL))
      {
        uint64_t v4 = 107LL;
        goto LABEL_47;
      }

      xpc_object_t v18 = string;
      BOOL v19 = sub_10003CB2C(v14, string);
      if (!v19) {
        goto LABEL_45;
      }
      uint64_t v20 = (uint64_t)v19;
      uint64_t v21 = sub_10000D81C((uint64_t)v19);
      uint64_t property = (const char *)xpc_bundle_get_property(v13, 2LL);
      uint64_t v23 = (const char *)xpc_bundle_get_property(v21, 2LL);
      if (sub_10001379C(v23) && !sub_10001379C(property))
      {
        uint64_t v4 = 127LL;
        goto LABEL_47;
      }

      if ((sub_10001379C(v23) & 1) == 0 && (sub_10001379C(property) & 1) != 0)
      {
        LODWORD(v4) = 127;
LABEL_44:
        char v36 = (const char *)sub_10000D814(v20);
        sub_100015500(a1, v36, v4);
LABEL_45:
        a3[6] &= ~0x400uLL;
        sub_10003CA78((uint64_t)v14, v18, a3);
        goto LABEL_46;
      }

      if ((sub_10001379C(v23) & 1) != 0 || (sub_10001379C(property) & 1) != 0)
      {
        if (!strcmp(v23, property))
        {
          uint64_t v4 = 121LL;
        }

        else
        {
          sub_10002587C( *(void *)(a1 + 48),  4,  "Conflicts exist in System services. Randomly deciding: path1 = %s, path2 = %s",  v24,  v25,  v26,  v27,  v28,  (char)property);
          uint64_t v4 = 130LL;
        }
      }

      else
      {
        char v29 = xpc_dictionary_get_string(v16, "CFBundleVersion");
        if (v29) {
          char v30 = v29;
        }
        else {
          char v30 = "0";
        }
        char v31 = (void *)xpc_bundle_get_info_dictionary(v21);
        uint64_t v32 = xpc_dictionary_get_string(v31, "CFBundleVersion");
        if (v32) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = "0";
        }
        int v34 = sub_10001274C(v30, v33);
        else {
          int v35 = 3;
        }
        if (v34 == 1) {
          int v35 = 2;
        }
        uint64_t v4 = 129LL;
        if ((v35 | 2) == 2) {
          goto LABEL_44;
        }
      }
    }
  }

LABEL_47:
  int v37 = *(unsigned __int8 *)(a2 + 100);
  if (v37 == 2)
  {
    if ((*(_BYTE *)(a1 + 89) & 0x20) != 0) {
      goto LABEL_62;
    }
    if (*(_BYTE *)(a1 + 96) == 1) {
      uint64_t v38 = "Bootstrap";
    }
    else {
      uint64_t v38 = "Bootout";
    }
    if ((_DWORD)v4)
    {
      xpc_strerror(v4);
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      sub_100039990(a1 + 108, (char *)&v44);
      if ((_DWORD)v4 != 36)
      {
        sub_10002587C( *(void *)(a1 + 48),  5,  "%s by %s[%d] for %s failed (%d: %s)",  v39,  v40,  v41,  v42,  v43,  (char)v38);
LABEL_57:
        LOBYTE(v37) = *(_BYTE *)(a2 + 100);
        goto LABEL_58;
      }
    }

    else
    {
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      sub_100039990(a1 + 108, (char *)&v44);
    }

    sub_10002587C(*(void *)(a1 + 48), 5, "%s by %s[%d] for %s succeeded (%d: %s)", v39, v40, v41, v42, v43, (char)v38);
    goto LABEL_57;
  }

          if (!(_DWORD)v28) {
            return v16;
          }
          goto LABEL_61;
        }

        int v16 = 0LL;
        uint64_t v28 = 159LL;
        goto LABEL_74;
      }

      *(void *)&uint64_t v70 = a1;
      uint64_t v24 = sub_1000308F8((uint64_t *)&v70, *(_DWORD *)(a7 + 20), 0);
      if (!v24)
      {
        int v16 = 0LL;
        uint64_t v28 = 113LL;
        goto LABEL_46;
      }

      uint64_t v25 = sub_100020858(v24, a2);
      if (v25)
      {
        uint64_t v26 = sub_100035964(v25, a3);
        if (v26)
        {
          uint64_t v27 = sub_10000F704(v26);
          int v16 = sub_10002AEC4(v27, v27, a2);
          if (v16)
          {
LABEL_23:
            uint64_t v28 = 0LL;
            goto LABEL_46;
          }

void sub_100015488(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 140) & 1) == 0) {
    sub_100046EB4();
  }
  *(_BYTE *)(a1 + 140) &= ~1u;
  sub_10001685C((void *)a1);
}

void sub_1000154DC(uint64_t a1)
{
  uint64_t v1 = sub_10000E5F0(*(void *)(*(void *)(a1 + 32) + 32LL), *(void *)(*(void *)(a1 + 32) + 40LL));
  sub_100013A90(v1);
}

void sub_1000154F8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
}

void sub_100015500(uint64_t a1, const char *a2, int a3)
{
  if (!a3) {
    sub_100046EB4();
  }
  if (*(_BYTE *)(a1 + 104) != 2)
  {
    int v5 = 5;
    goto LABEL_6;
  }

  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 80), a2, a3);
  if (*(_DWORD *)(a1 + 100))
  {
    int v5 = 133;
LABEL_6:
    *(_DWORD *)(a1 + 100) = v5;
    return;
  }

  *(_DWORD *)(a1 + 100) = a3;
}

void sub_100015560(uint64_t a1, int a2, id a3)
{
  Class Class = j__object_getClass(a3);
  if (Class != (Class)sub_100016EC0()) {
    sub_100046EB4();
  }
  int v6 = sub_100029144(*(void *)(a1 + 32), (uint64_t)a3);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = *(void *)(a1 + 40);
    size_t v9 = (const char *)sub_10000D814((uint64_t)a3);
    sub_100015500(v8, v9, v7);
  }

void sub_1000155E0(uint64_t a1)
{
  int v2 = xpc_pipe_routine_reply(*(void *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  if ((v2 | 0x20) != 0x20) {
    _os_assumes_log_ctx(sub_100025848, *(void *)(a1 + 40));
  }
  sub_10001685C(*(void **)(a1 + 40));
}

uint64_t sub_100015644(uint64_t a1, char a2, xpc_object_t xint)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int64_t value = xpc_int64_get_value(xint);
  BOOL v6 = (value - 119) > 0x21 || ((1LL << (value - 119)) & 0x220008025LL) == 0;
  if (v6 || byte_10006A9B0)
  {
    uint64_t v7 = *(void *)(v4 + 48);
    xpc_strerror(value);
    sub_10002587C(v7, 3, "Failed to bootstrap path: path = %s, int error = %d: %s", v8, v9, v10, v11, v12, a2);
  }

  return 1LL;
}

uint64_t sub_1000156E4(uint64_t a1, const char *a2, void *a3)
{
  return 1LL;
}

void sub_100015700(const void *a1)
{
  if (dword_100069A44)
  {
    int v2 = dispatch_queue_attr_make_with_qos_class(0LL, QOS_CLASS_USER_INTERACTIVE, 0);
    int v3 = dispatch_queue_create("com.apple.xpc.launchd.timeout", v2);
    uint64_t v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v3);
    qword_100069CA0 = (uint64_t)v4;
    dispatch_time_t v5 = dispatch_time(0LL, 1000000000LL * dword_100069A44);
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    BOOL v6 = (dispatch_object_s *)qword_100069CA0;
    uint64_t v7 = _Block_copy(a1);
    dispatch_set_context(v6, v7);
    dispatch_source_set_event_handler_f((dispatch_source_t)qword_100069CA0, (dispatch_function_t)sub_1000157E0);
    dispatch_activate((dispatch_object_t)qword_100069CA0);
  }

void sub_1000157E0(uint64_t a1)
{
  uint64_t v2 = sub_10002A7C8();
  int v3 = (dispatch_queue_s *)sub_100011938();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100015910;
  v4[3] = &unk_1000641E8;
  _OWORD v4[4] = a1;
  v4[5] = v2;
  dispatch_async_and_wait(v3, v4);
}

void sub_100015848()
{
  if (qword_100069CA0)
  {
    dispatch_source_cancel((dispatch_source_t)qword_100069CA0);
    dispatch_release((dispatch_object_t)qword_100069CA0);
    qword_100069CA0 = 0LL;
  }

void sub_10001587C(uint64_t a1)
{
  if (qword_100069CA0)
  {
    uint64_t v2 = sub_10002A7C8();
    uint64_t v3 = mach_absolute_time();
    unint64_t v4 = sub_10000AA58(v3 - *(void *)(v2 + 240));
    unint64_t v5 = a1 + 1000000000LL * dword_100069A44;
    if (v5 > v4)
    {
      BOOL v6 = (dispatch_source_s *)qword_100069CA0;
      dispatch_time_t v7 = dispatch_time(0LL, v5 - v4);
      dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    }
  }

uint64_t sub_100015910(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

BOOL sub_100015944(_OWORD *a1, uint64_t a2, int a3)
{
  if (a3 == 2) {
    uint64_t v3 = SANDBOX_CHECK_NO_REPORT;
  }
  else {
    uint64_t v3 = 0LL;
  }
  __int128 v4 = a1[1];
  v6[0] = *a1;
  v6[1] = v4;
  return sandbox_check_by_audit_token(v6, a2, v3) == 0;
}

BOOL sub_100015988(_OWORD *a1, uint64_t a2, int a3)
{
  if (a3 == 2) {
    unsigned int v3 = 3;
  }
  else {
    unsigned int v3 = 2;
  }
  __int128 v4 = a1[1];
  if (a3 == 3) {
    uint64_t v5 = 12LL;
  }
  else {
    uint64_t v5 = v3;
  }
  v7[0] = *a1;
  v7[1] = v4;
  return sandbox_check_by_audit_token(v7, a2, v5) == 0;
}

BOOL sub_1000159D4(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  __int128 v3 = a1[1];
  v7[0] = *a1;
  v7[1] = v3;
  __int128 v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  return sandbox_check_process_signal_target(v7, a3, v6, 0LL) == 0;
}

_BYTE *sub_100015A1C(void *a1)
{
  int property = xpc_bundle_get_property(a1, 0LL);
  if (property == 1LL) {
    uint64_t v3 = 3LL;
  }
  else {
    uint64_t v3 = 2LL;
  }
  if (property == 1LL) {
    char v4 = 2;
  }
  else {
    char v4 = 1;
  }
  uint64_t v5 = xpc_bundle_get_property(a1, v3);
  BOOL v6 = sub_10000D654(v4, v5);
  *((void *)v6 + 10) = xpc_retain(a1);
  __int128 v7 = unk_100069480;
  *((_OWORD *)v6 + 8) = xmmword_100069470;
  *((_OWORD *)v6 + 9) = v7;
  __int128 v8 = unk_100069460;
  *((_OWORD *)v6 + 6) = xmmword_100069450;
  *((_OWORD *)v6 + 7) = v8;
  __int128 v9 = unk_1000694A0;
  *((_OWORD *)v6 + 10) = xmmword_100069490;
  *((_OWORD *)v6 + 11) = v9;
  __int128 v10 = unk_1000694C0;
  *((_OWORD *)v6 + 12) = xmmword_1000694B0;
  *((_OWORD *)v6 + 13) = v10;
  *((_OWORD *)v6 + 14) = xmmword_1000694D0;
  v6[264] |= 1u;
  return v6;
}

BOOL sub_100015ABC(const char *a1)
{
  uint64_t v2 = 0LL;
  do
  {
    BOOL result = sub_100012944(a1, off_100064208[v2]);
    if (result) {
      break;
    }
  }

  while (v2++ != 1);
  return result;
}

uint64_t sub_100015B0C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 == 1)
  {
    if (sub_100012984(*(const char **)(a1 + 64), ".appex"))
    {
      uint64_t v13 = *(char **)(a1 + 64);
LABEL_14:
      uint64_t v15 = (uint64_t)sub_10001634C(v13);
      goto LABEL_23;
    }

LABEL_15:
    int v2 = *(unsigned __int8 *)(a1 + 56);
LABEL_16:
    if (v2 == 2)
    {
      uint64_t v15 = sub_100016378(*(char **)(a1 + 64));
    }

    else
    {
      if (v2 == 1)
      {
        BOOL v19 = *(char **)(a1 + 64);
        uint64_t v17 = (uint64_t)sub_10001634C(v19);
        if (!v17)
        {
          uint64_t v20 = sub_100016378(v19);
          if (!v20) {
            return 148LL;
          }
          uint64_t v17 = v20;
          sub_10003AB08(5, "Found XPCService bundle by executable: %s", v19);
        }

        goto LABEL_28;
      }

      if (v2) {
        return 148LL;
      }
      if (!qword_10006A900) {
        return 148LL;
      }
      int v16 = sub_10003CB2C((rb_tree_t **)qword_10006A900, *(const void **)(a1 + 64));
      if (!v16) {
        return 148LL;
      }
      uint64_t v15 = sub_10003CD44((uint64_t)v16);
    }

  __int128 v12 = 0LL;
LABEL_16:
  uint64_t v13 = xpc_array_create(0LL, 0LL);
  for (unint64_t i = *(void *)(a1 + 152); i; unint64_t i = *(void *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0)
    {
      uint64_t v15 = sub_100012A6C(v12, (const char *)(i + 168));
      int v16 = sub_10003FA58(i, v15);
      xpc_array_append_value(v13, v16);
      xpc_release(v16);
    }
  }

  for (uint64_t j = *(void *)(a1 + 176); j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 0x40) == 0)
    {
      xpc_object_t v18 = sub_10003FA58(j, 0);
      xpc_array_append_value(v13, v18);
      xpc_release(v18);
    }
  }

  for (k = *(void *)(a1 + 184); k; k = *(void *)(k + 16))
  {
    if ((*(_BYTE *)(k + 88) & 0x40) == 0)
    {
      uint64_t v20 = sub_100012A6C(v12, (const char *)(k + 168));
      uint64_t v21 = sub_10003FA58(k, v20);
      xpc_array_append_value(v13, v21);
      xpc_release(v21);
    }
  }

  if (xpc_array_get_count(v13)) {
    xpc_dictionary_set_value(v4, launch_perfcheck_property_endpoints, v13);
  }
  xpc_release(v13);
  __int128 v22 = *(void *)(a1 + 256);
  if (!v22) {
    __int128 v22 = a1;
  }
  xpc_dictionary_set_string(v4, "label", (const char *)(v22 + 1360));
  if ((*(_BYTE *)(a1 + 1357) & 2) != 0) {
    xpc_dictionary_set_uuid(v4, "instance", (const unsigned __int8 *)(a1 + 408));
  }
  xpc_dictionary_set_int64(v4, "jp-priority", *(int *)(a1 + 896));
  xpc_dictionary_set_value(v4, "additional-properties", *(xpc_object_t *)(a1 + 640));
  __int128 v23 = (const char *)sub_10001A098(a1);
  xpc_dictionary_set_string(v4, "program", v23);
  xpc_dictionary_set_uint64(v4, "process-type", *(unsigned int *)(a1 + 872));
  xpc_dictionary_set_BOOL(v4, "keep-alive", (*(void *)(a1 + 1352) & 0xCLL) != 0);
  xpc_dictionary_set_BOOL(v4, "run-at-load", (*(void *)(a1 + 1352) & 0x10LL) != 0);
  xpc_dictionary_set_BOOL(v4, "enable-transactions", *(void *)(a1 + 1352) & 0x100LL);
  xpc_dictionary_set_uint64(v4, "service-type", *(unsigned __int8 *)(a1 + 356));
  return v4;
}

      BOOL result = 22LL;
      goto LABEL_37;
    }

    int64_t string_ptr = (char *)xpc_string_get_string_ptr(v19);
    BOOL result = sub_100032CB8(v13, v17, string_ptr, 0LL, &v37);
    if ((_DWORD)result == 36)
    {
      char v29 = *(void *)(v13 + 944);
      if (v29)
      {
        *(void *)(v13 + 944) = 0LL;
        char v30 = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uint64(v30, "response", 0LL);
        BOOL result = *(void *)(v29 + 272);
        if (result) {
          sub_100047110(result);
        }
        *(void *)(v29 + 272) = v30;
      }

      else
      {
        BOOL result = 36LL;
      }

      goto LABEL_37;
    }

    if (!(_DWORD)result)
    {
      reply = xpc_dictionary_create_reply(a3);
      __int128 v24 = reply;
      __int128 v22 = v37;
      goto LABEL_19;
    }
  }

xpc_object_t sub_100015E28()
{
  int v0 = (int *)open("/System/Library/xpc/launchd.plist", 0);
  if ((v0 & 0x80000000) != 0)
  {
    int v6 = *__error();
    __int128 v7 = __error();
    __int128 v8 = strerror(*v7);
    sub_10003AB08(65539, "Unable to open %s [%d:%s]", "/System/Library/xpc/launchd.plist", v6, v8);
    return 0LL;
  }

  else
  {
    uint64_t v1 = v0;
    memset(&v13, 0, sizeof(v13));
    if (fstat((int)v0, &v13))
    {
      int v2 = *__error();
      size_t v3 = __error();
      size_t v4 = strerror(*v3);
      sub_10003AB08(65539, "Unable to stat %s [%d:%s]", "/System/Library/xpc/launchd.plist", v2, v4);
      xpc_object_t v5 = 0LL;
    }

    else
    {
      size_t st_size = v13.st_size;
      __int128 v10 = (const void *)sub_10003A094((v13.st_size + vm_page_size - 1) & -(uint64_t)vm_page_size);
      __int128 v11 = dispatch_data_create(v10, st_size, 0LL, _dispatch_data_destructor_vm_deallocate);
      xpc_object_t v5 = xpc_data_create_with_dispatch_data(v11);
      dispatch_release(v11);
    }

    sub_100036D70(v1);
  }

  return v5;
}

void sub_100015F5C(xpc_object_t xdata)
{
  xpc_object_t v1 = xdata;
  if (!xdata)
  {
    sub_10003AB08(65539, "No MRM cache found");
LABEL_7:
    char v7 = 1;
    goto LABEL_8;
  }

  bytes_ptr = xpc_data_get_bytes_ptr(xdata);
  size_t length = xpc_data_get_length(v1);
  size_t v4 = (void *)xpc_create_from_plist(bytes_ptr, length);
  xpc_object_t v1 = v4;
  if (!v4)
  {
    sub_10003AB08(65541, "Unable to parse MRM cache");
    goto LABEL_7;
  }

  xpc_object_t value = xpc_dictionary_get_value(v4, "SystemLibraryTreeState");
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_value(v6, "_imagePathToInfo", value);
  xpc_dictionary_set_value(v1, "SystemLibraryTreeState", v6);
  xpc_release(v6);
  if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v9 = xpc_dictionary_get_value(v1, "LaunchDaemons");
    xpc_object_t v10 = v9;
    if (v9)
    {
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_object_t v10 = xpc_retain(v10);
      }
      else {
        xpc_object_t v10 = 0LL;
      }
    }

    xpc_object_t v11 = xpc_dictionary_get_value(v1, "SystemLibraryTreeState");
    xpc_object_t v12 = v11;
    if (v11)
    {
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary
        && (xpc_object_t v18 = xpc_dictionary_get_value(v12, "_imagePathToInfo")) != 0LL
        && (BOOL v19 = v18, xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary))
      {
        xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
        applier = _NSConcreteStackBlock;
        uint64_t v21 = 0x40000000LL;
        __int128 v22 = sub_10001652C;
        __int128 v23 = &unk_100064280;
        xpc_object_t v24 = v12;
        xpc_dictionary_apply(v19, &applier);
      }

      else
      {
        xpc_object_t v12 = 0LL;
      }
    }

    xpc_object_t v13 = xpc_dictionary_create(0LL, 0LL, 0LL);
    applier = _NSConcreteStackBlock;
    uint64_t v21 = 0x40000000LL;
    __int128 v22 = sub_100016708;
    __int128 v23 = &unk_1000642A0;
    xpc_object_t v24 = v13;
    xpc_object_t v14 = xpc_dictionary_get_value(v1, "AppExtensions");
    if (v14)
    {
      uint64_t v15 = v14;
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_dictionary_apply(v15, &applier);
      }
    }

    xpc_object_t v16 = xpc_dictionary_get_value(v1, "AppRemovalServices");
    if (v16)
    {
      uint64_t v17 = v16;
      if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_dictionary_apply(v17, &applier);
      }
    }

    sub_1000163D4(v10, v12, v13);
    if (v10) {
      xpc_release(v10);
    }
    if (v12) {
      xpc_release(v12);
    }
    if (v13) {
      xpc_release(v13);
    }
    goto LABEL_35;
  }

  char v7 = 0;
LABEL_8:
  if (byte_10006A99B) {
    BOOL v8 = byte_10006A99D == 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (!v8) {
    sub_100039448("No service cache");
  }
  sub_1000163D4(0LL, 0LL, 0LL);
  if ((v7 & 1) == 0)
  {
LABEL_35:
    xpc_release(v1);
    return;
  }

  if (!dword_10006A978) {
    sub_10003AB08(65540, "Unable to load cache");
  }
}

BOOL sub_1000162B8()
{
  if (byte_10006A99B) {
    BOOL v0 = byte_10006A99D == 0;
  }
  else {
    BOOL v0 = 0;
  }
  return !v0;
}

void sub_1000162E0(uint64_t a1, const char *a2)
{
  if (sub_100012944(a2, *(char **)(a1 + 32)))
  {
    size_t v4 = sub_10000D6C0(0, (uint64_t)a2, 0);
    sub_10000E4D8(*(void **)(a1 + 40), v4);
    sub_10001685C(v4);
  }

xpc_object_t sub_10001634C(char *key)
{
  xpc_object_t result = xpc_dictionary_get_value((xpc_object_t)qword_10006A910, key);
  if (result) {
    return xpc_retain(result);
  }
  return result;
}

uint64_t sub_100016378(char *key)
{
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_10006A908, key);
  if (!value) {
    return 0LL;
  }
  xpc_object_t v3 = value;
  uint64_t v4 = xpc_bundle_create_from_origin(1LL, key);
  xpc_bundle_populate(v4, 0LL, v3);
  return v4;
}

xpc_object_t sub_1000163D4(void *a1, void *a2, void *a3)
{
  if (qword_10006A900) {
    sub_10001685C((void *)qword_10006A900);
  }
  qword_10006A900 = (uint64_t)sub_10003CBF8();
  if (a1 && xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_dictionary_apply(a1, &stru_100064260);
  }
  if (qword_10006A908) {
    xpc_release((xpc_object_t)qword_10006A908);
  }
  if (a2 && xpc_get_type(a2) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_object_t v6 = xpc_retain(a2);
  }
  else {
    xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  }
  qword_10006A908 = (uint64_t)v6;
  if (qword_10006A910) {
    xpc_release((xpc_object_t)qword_10006A910);
  }
  if (a3 && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_object_t result = xpc_retain(a3);
  }
  else {
    xpc_object_t result = xpc_dictionary_create(0LL, 0LL, 0LL);
  }
  qword_10006A910 = (uint64_t)result;
  return result;
}

BOOL sub_1000164D8(id a1, const char *a2, void *a3)
{
  uint64_t v4 = sub_10003CCD8((uint64_t)a3);
  sub_10003CA78(qword_10006A900, a2, v4);
  sub_10001685C(v4);
  return 1;
}

uint64_t sub_10001652C(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (object
    && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary
    && (xpc_object_t v10 = xpc_dictionary_get_value(object, "_serviceBundles")) != 0LL
    && (xpc_object_t v11 = v10, xpc_get_type(v10) == (xpc_type_t)&_xpc_type_array)
    && xpc_array_get_count(v11))
  {
    xpc_object_t v8 = xpc_array_create(0LL, 0LL);
    if (xpc_array_get_count(v11))
    {
      size_t v12 = 0LL;
      do
      {
        xpc_object_t value = xpc_array_get_value(v11, v12);
        if (value)
        {
          xpc_object_t v14 = value;
          if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
          {
            uint64_t v15 = (void *)sub_100016688(v14);
            if (v15)
            {
              xpc_object_t v16 = v15;
              xpc_array_append_value(v8, v15);
              xpc_release(v16);
            }
          }
        }

        ++v12;
      }

      while (v12 < xpc_array_get_count(v11));
    }
  }

  else
  {
    xpc_object_t v6 = (xpc_object_t)qword_100069CA8;
    if (!qword_100069CA8)
    {
      xpc_object_t v6 = xpc_array_create(0LL, 0LL);
      qword_100069CA8 = (uint64_t)v6;
    }

    size_t count = xpc_array_get_count(v6);
    if (count) {
      sub_100047110(count);
    }
    xpc_object_t v8 = xpc_retain((xpc_object_t)qword_100069CA8);
  }

  if (v8)
  {
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, v8);
    xpc_release(v8);
  }

  return 1LL;
}

uint64_t sub_100016688(void *a1)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "_infoPlist");
  if (!value) {
    return 0LL;
  }
  xpc_object_t v3 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0LL;
  }
  string = xpc_dictionary_get_string(a1, "_executablePath");
  if (!string) {
    return 0LL;
  }
  uint64_t v4 = xpc_bundle_create_from_origin(1LL, string);
  xpc_bundle_populate(v4, v3, 0LL);
  return v4;
}

uint64_t sub_100016708(uint64_t a1, const char *a2, void *a3)
{
  xpc_object_t v5 = (void *)sub_100016688(a3);
  if (v5)
  {
    xpc_object_t v6 = v5;
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, v5);
    xpc_release(v6);
  }

  return 1LL;
}

void *sub_10001675C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v7 = sub_100010B00(0x18uLL);
  *char v7 = a1;
  v7[1] = a3;
  _OWORD v7[2] = a4;
  if (a1)
  {
    sub_100016C34((uint64_t)a1);
    id v8 = a1;
  }

  return v7;
}

void *sub_1000167B0(void *a1)
{
  id v2 = a1;
  return a1;
}

void *sub_1000167D8(void *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v6 = sub_100010B00(0x18uLL);
  *xpc_object_t v6 = a1;
  v6[1] = a2;
  _OWORD v6[2] = a3;
  if (a1) {
    xpc_retain(a1);
  }
  return v6;
}

void sub_100016828(uint64_t *a1)
{
  id v2 = (void *)*a1;
  if (*a1)
  {
    sub_100016C34(*a1);
  }

  free(a1);
}

void sub_10001685C(void *a1)
{
}

void sub_100016880(void **a1)
{
  id v2 = *a1;
  if (v2) {
    xpc_release(v2);
  }
  free(a1);
}

char *sub_1000168AC(char *__s, const char *a2, uint64_t a3, size_t *a4, char a5)
{
  if ((a5 & 1) == 0)
  {
    uint64_t v9 = 0LL;
    while (strcmp(__s, off_1000642C0[v9]))
    {
      if (++v9 == 2) {
        goto LABEL_5;
      }
    }

    return 0LL;
  }

LABEL_5:
  size_t v10 = strlen(__s);
  size_t v11 = v10 + 1;
  BOOL v12 = v10 == -1LL;
  xpc_object_t result = (char *)strlen(a2);
  xpc_object_t v14 = &result[v11];
  BOOL v15 = __CFADD__(result, v11);
  size_t v16 = (size_t)(v14 + 1);
  uint64_t v17 = v14 == (char *)-1LL;
  uint64_t v18 = v17 << 63 >> 63;
  BOOL v19 = v18 != v17;
  if (!v12 && !v15 && !v19 && (v18 & 0x8000000000000000LL) == 0)
  {
    xpc_object_t result = (char *)(v16 + 32);
    if (v16 < 0xFFFFFFFFFFFFFFE0LL)
    {
      uint64_t v20 = sub_100010B00((size_t)result);
      *((void *)v20 + 3) = a3;
      snprintf((char *)v20 + 32, v16, "%s=%s", __s, a2);
      *a4 = v16;
      return (char *)v20;
    }
  }

  __break(1u);
  return result;
}

size_t sub_1000169A0(uint64_t a1, size_t *a2)
{
  xpc_object_t v3 = (const char *)(a1 + 32);
  size_t v4 = strlen((const char *)(a1 + 32));
  size_t v5 = v4 + 1;
  BOOL v6 = __CFADD__(v4 + 1, 32LL);
  size_t result = v4 + 33;
  if (v6)
  {
    __break(1u);
  }

  else
  {
    id v8 = (char *)sub_100010B00(result);
    snprintf(v8 + 32, v5, "%s", v3);
    *a2 = v5;
    return (size_t)v8;
  }

  return result;
}

uint64_t sub_100016A10(uint64_t a1, uint64_t a2, FILE *a3)
{
  uint64_t v5 = a1 + 32;
  BOOL v6 = strrchr((const char *)(a1 + 32), 61);
  *BOOL v6 = 0;
  uint64_t result = sub_10003D32C(a3, a2, "%s => %s", v7, v8, v9, v10, v11, v5, v6 + 1);
  *BOOL v6 = 61;
  return result;
}

char *sub_100016A84(uint64_t a1, const char *a2)
{
  xpc_object_t v3 = (const char *)(a1 + 32);
  uint64_t result = strchr((const char *)(a1 + 32), 61);
  if (result)
  {
    uint64_t v5 = result;
    *uint64_t result = 0;
    uint64_t result = (char *)(strcmp(v3, a2) == 0);
    _BYTE *v5 = 61;
  }

  return result;
}

char *sub_100016AE0(uint64_t a1)
{
  xpc_object_t v1 = strchr((const char *)(a1 + 32), 61);
  if (v1) {
    return v1 + 1;
  }
  else {
    return 0LL;
  }
}

BOOL sub_100016B08(const char *a1)
{
  if (!strcmp(a1, "LD_LIBRARY_PATH")) {
    return 1LL;
  }
  BOOL result = sub_100012944(a1, "DYLD_");
  if (!result) {
    return result;
  }
  if (!sub_100012944(a1, "DYLD_PRINT_")) {
    return 1LL;
  }
  uint64_t v3 = 0LL;
  do
  {
    int v4 = strcmp(a1, off_1000642D8[v3]);
    BOOL result = v4 != 0;
    if (!v4) {
      break;
    }
  }

  while (v3++ != 10);
  return result;
}

_DWORD *sub_100016BA4(mach_port_name_t a1, int a2)
{
  int v4 = sub_100010B00(0x18uLL);
  int v5 = sub_10000AC54(a1);
  if (v5) {
    _os_assumes_log(v5);
  }
  _OWORD v4[4] = a1;
  v4[5] = a2;
  return v4;
}

void sub_100016BF8(mach_port_name_t *a1)
{
  int v2 = sub_10000AC70(a1[4]);
  if (v2) {
    _os_assumes_log(v2);
  }
  free(a1);
}

uint64_t sub_100016C34(uint64_t result)
{
  if (*(_BYTE *)(result + 8)) {
    sub_100046EC8();
  }
  return result;
}

uint64_t sub_100016C50(uint64_t a1)
{
  return a1;
}

uint64_t sub_100016C78(uint64_t result)
{
  if (*(_BYTE *)(result + 8)) {
    sub_100046EC8();
  }
  *(_BYTE *)(result + 8) = 1;
  return result;
}

id sub_100016C9C(uint64_t a1)
{
  size_t v1 = a1 + 32;
  int v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_array);
  return class_createInstance(v2, v1);
}

id sub_100016CC8(uint64_t a1)
{
  size_t v1 = a1 + 24;
  int v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_dictionary);
  return class_createInstance(v2, v1);
}

id sub_100016CF4(uint64_t a1)
{
  size_t v1 = a1 + 968;
  int v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_domain);
  return class_createInstance(v2, v1);
}

id sub_100016D20(uint64_t a1)
{
  size_t v1 = a1 + 136;
  int v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_domain_aggregate_io);
  return class_createInstance(v2, v1);
}

id sub_100016D4C(uint64_t a1)
{
  size_t v1 = a1 + 96;
  int v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_domain_io);
  return class_createInstance(v2, v1);
}

char *sub_100016D78(const char *a1)
{
  size_t v2 = strlen(a1) + 161;
  uint64_t v3 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_endpoint);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 168, a1);
  return Instance;
}

id sub_100016DC4(uint64_t a1)
{
  size_t v1 = a1 + 56;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_event_provider);
  return class_createInstance(v2, v1);
}

id sub_100016DF0(uint64_t a1)
{
  size_t v1 = a1 + 80;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_event_realm);
  return class_createInstance(v2, v1);
}

char *sub_100016E1C(const char *a1)
{
  size_t v2 = strlen(a1) + 33;
  uint64_t v3 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_event_stream);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 40, a1);
  return Instance;
}

id sub_100016E68(uint64_t a1)
{
  size_t v1 = a1 + 80;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_event_subscription);
  return class_createInstance(v2, v1);
}

id sub_100016E94(uint64_t a1)
{
  size_t v1 = a1 + 264;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_io);
  return class_createInstance(v2, v1);
}

uint64_t sub_100016EC0()
{
  return objc_opt_class(&OBJC_CLASS___OS_launch_io);
}

id sub_100016ECC(uint64_t a1)
{
  size_t v1 = a1 + 80;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_log);
  return class_createInstance(v2, v1);
}

char *sub_100016EF8(const char *a1)
{
  size_t v2 = strlen(a1) + 1353;
  uint64_t v3 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_service);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 1360, a1);
  return Instance;
}

id sub_100016F44(uint64_t a1)
{
  size_t v1 = a1 + 56;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_service_stub);
  return class_createInstance(v2, v1);
}

char *sub_100016F70(const char *a1)
{
  size_t v2 = strlen(a1) + 201;
  uint64_t v3 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_socket);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 208, a1);
  return Instance;
}

id sub_100016FBC(uint64_t a1)
{
  size_t v1 = a1 + 40;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_cache);
  return class_createInstance(v2, v1);
}

id sub_100016FE8(uint64_t a1)
{
  size_t v1 = a1 + 24;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_uint64_dictionary);
  return class_createInstance(v2, v1);
}

id sub_100017014(uint64_t a1)
{
  size_t v1 = a1 + 64;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_coalition);
  return class_createInstance(v2, v1);
}

id sub_100017040(uint64_t a1)
{
  size_t v1 = a1 + 16;
  size_t v2 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_plist);
  return class_createInstance(v2, v1);
}

char *sub_10001706C(const char *a1)
{
  size_t v2 = strlen(a1) + 33;
  uint64_t v3 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_service_stub_static);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 40, a1);
  return Instance;
}

char *sub_1000170B8(const char *a1)
{
  size_t v2 = strlen(a1) + 25;
  uint64_t v3 = (objc_class *)objc_opt_class(&OBJC_CLASS___OS_launch_service_static);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 32, a1);
  return Instance;
}

  ;
}

uint64_t sub_100017110()
{
  return sub_100016C78(v0);
}

id sub_100017118( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  return objc_msgSendSuper2(&a9, a2);
}

uint64_t sub_100017120(uid_t a1, uint64_t a2)
{
  int v4 = 0LL;
  uint64_t result = getpwuid_r(a1, (passwd *)a2, (char *)(a2 + 72), 0x1000uLL, &v4);
  if (!(_DWORD)result)
  {
    if (v4)
    {
      sub_1000172AC(*(const char **)a2, *(_DWORD *)(a2 + 20), a2);
      return 0LL;
    }

    else
    {
      return 114LL;
    }
  }

  return result;
}

uint64_t sub_100017180(const char *a1, const char *a2, uint64_t a3)
{
  if (a1)
  {
    v11[0] = 0LL;
    uint64_t result = getpwnam_r(a1, (passwd *)a3, (char *)(a3 + 72), 0x1000uLL, v11);
    if ((_DWORD)result) {
      return result;
    }
    if (!v11[0]) {
      return 114LL;
    }
    gid_t gr_gid = *(_DWORD *)(a3 + 20);
    if (!a2) {
      goto LABEL_10;
    }
  }

  else
  {
    gid_t gr_gid = -101;
    if (!a2) {
      goto LABEL_10;
    }
  }

  bzero(v11, 0x1000uLL);
  memset(&v10, 0, sizeof(v10));
  uint64_t v9 = 0LL;
  uint64_t result = getgrnam_r(a2, &v10, (char *)v11, 0x1000uLL, &v9);
  if ((_DWORD)result) {
    return result;
  }
  if (!v9) {
    return 115LL;
  }
  gid_t gr_gid = v10.gr_gid;
LABEL_10:
  if (gr_gid != -101)
  {
    if (a1) {
      uint64_t v8 = a1;
    }
    else {
      uint64_t v8 = "root";
    }
    sub_1000172AC(v8, gr_gid, a3);
  }

  return 0LL;
}

uint64_t sub_1000172AC(const char *a1, int a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 4232) = 16;
  uint64_t result = getgrouplist(a1, a2, (int *)(a3 + 4168), (int *)(a3 + 4232));
  if ((_DWORD)result == -1) {
    return sub_100047024();
  }
  return result;
}

uint64_t sub_1000172E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 24);
  unint64_t v4 = *(void *)(a3 + 24);
  BOOL v5 = v3 >= v4;
  BOOL v6 = v3 > v4;
  if (v5) {
    return v6;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100017300(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 24);
  BOOL v4 = v3 >= *a3;
  BOOL v5 = v3 > *a3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_100017318(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v8 = a2;
  if (*(_DWORD *)(a1 + 24) == 4982)
  {
    node = (void **)rb_tree_find_node(*(rb_tree_t **)(a1 + 16), &v8);
    if (node)
    {
      BOOL v6 = node;
      rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), node);
      os_release(v6[4]);
      free(v6);
    }

    if (a3)
    {
      uint64_t v7 = malloc(0x28uLL);
      void v7[3] = v8;
      v7[4] = os_retain(a3);
      if (rb_tree_insert_node(*(rb_tree_t **)(a1 + 16), v7) != v7) {
        sub_100046EC8();
      }
    }
  }

  else
  {
    __break(1u);
  }

rb_tree_t **sub_1000173CC(rb_tree_t **result, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((_DWORD *)result + 6) == 4982)
  {
    uint64_t result = (rb_tree_t **)rb_tree_find_node(result[2], &v2);
    if (result) {
      return (rb_tree_t **)result[4];
    }
  }

  else
  {
    __break(1u);
  }

  return result;
}

rb_tree_t **sub_100017410(rb_tree_t **result, uint64_t a2)
{
  if (*((_DWORD *)result + 6) == 4982)
  {
    unint64_t v3 = result;
    uint64_t result = (rb_tree_t **)rb_tree_iterate(result[2], 0LL, 1u);
    if (result)
    {
      BOOL v4 = result;
      do
      {
        (*(void (**)(uint64_t, rb_tree_t *, rb_tree_t *))(a2 + 16))(a2, v4[3], v4[4]);
        uint64_t result = (rb_tree_t **)rb_tree_iterate(v3[2], v4, 1u);
        BOOL v4 = result;
      }

      while (result);
    }
  }

  else
  {
    __break(1u);
  }

  return result;
}

size_t sub_10001748C(size_t result)
{
  if (*(_DWORD *)(result + 24) == 4982) {
    return rb_tree_count(*(rb_tree_t **)(result + 16));
  }
  __break(1u);
  return result;
}

void *sub_1000174A8()
{
  uint64_t v0 = sub_100016FE8(0LL);
  size_t v1 = (rb_tree_t *)malloc(0x40uLL);
  v0[2] = v1;
  rb_tree_init(v1, (const rb_tree_ops_t *)off_100069570);
  *((_DWORD *)v0 + 6) = 4982;
  return v0;
}

void sub_1000174F0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) == 4982)
  {
    *(_DWORD *)(a1 + 24) = 0;
    uint64_t v2 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), 0LL, 1u);
    if (v2)
    {
      unint64_t v3 = v2;
      do
      {
        BOOL v4 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), v3, 1u);
        rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), v3);
        os_release(v3[4]);
        free(v3);
        unint64_t v3 = v4;
      }

      while (v4);
    }

    free(*(void **)(a1 + 16));
  }

  else
  {
    __break(1u);
  }

void sub_100017580(uint64_t a1)
{
  if (qword_100069CB0 == a1) {
    qword_100069CB0 = 0LL;
  }
  unint64_t v2 = *(void *)(a1 + 88);
  if (v2)
  {
    unint64_t v3 = 0LL;
    int v4 = dword_1000699D8;
    do
    {
      BOOL v5 = (int *)*(unsigned int *)(*(void *)(a1 + 64) + 4 * v3);
      if ((v5 & 0x80000000) == 0 && (_DWORD)v5 != v4)
      {
        sub_100036D70(v5);
        int v4 = dword_1000699D8;
        unint64_t v2 = *(void *)(a1 + 88);
      }

      ++v3;
    }

    while (v3 < v2);
  }

  if (*(void *)(a1 + 32) != -1LL || *(void *)(a1 + 40) != -1LL) {
    sub_100039448("socket deallocated while still in domain list");
  }
  if (*(void *)(a1 + 16) != -1LL || *(void *)(a1 + 24) != -1LL) {
    sub_100039448("socket deallocated while still in service list");
  }
  if ((*(_WORD *)(a1 + 204) & 0x84) == 4) {
    sub_100039448("socket deallocated while still active");
  }
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 144));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  xpc_release(*(xpc_object_t *)(a1 + 192));
}

uint64_t sub_1000176A0( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1LL;
}

void sub_1000176D4( uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  BOOL v12 = sub_100017734(a1);
  sub_10003AE8C(v12, a2, a3, &a9, v9);
  free(v12);
}

char *sub_100017734(uint64_t a1)
{
  uint64_t v8 = (const char **)sub_10000D8E8(0x40uLL);
  uint64_t v9 = *(void *)(a1 + 56);
  if (v9)
  {
    group v10 = sub_10001C2A0(v9, 1);
    sub_10000D960((uint64_t)v8, "%s - ", v11, v12, v13, v14, v15, v16, (char)v10);
    free(v10);
  }

  sub_10000D960((uint64_t)v8, "%s", v2, v3, v4, v5, v6, v7, a1 - 48);
  uint64_t v17 = sub_10000D930(v8);
  sub_10000D938((void **)v8);
  return v17;
}

char *sub_1000177CC( uint64_t a1, uint64_t a2, const char *a3, int a4, void *a5, dispatch_object_s *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16 = sub_100016F70(a3);
  *((void *)v16 + 7) = a1;
  *((_DWORD *)v16 + 24) = -1;
  *((_DWORD *)v16 + 26) = a4;
  dispatch_retain(a6);
  *((void *)v16 + 14) = a6;
  *((void *)v16 + 15) = a7;
  *((void *)v16 + 16) = a8;
  *((void *)v16 + 24) = xpc_retain(a5);
  *((_WORD *)v16 + 102) |= 2u;
  *(void *)&__int128 v17 = -1LL;
  *((void *)&v17 + 1) = -1LL;
  *((_OWORD *)v16 + 1) = v17;
  *((_OWORD *)v16 + 2) = v17;
  uint64_t v18 = sub_10001DD24(a1);
  int v19 = *(_DWORD *)(v18 + 20);
  if (v19)
  {
    uint64_t v20 = v18;
    if (v19 != getpid())
    {
      int v21 = *(_DWORD *)(v20 + 8);
      if (v21) {
        *((_DWORD *)v16 + 27) = v21;
      }
    }
  }

  string = xpc_dictionary_get_string(a5, "SockPathName");
  if (string && !strcmp(string, "/var/run/syslog")) {
    xpc_dictionary_set_BOOL(a5, "SystemLoggingSocket", 1);
  }
  *((_DWORD *)v16 + 25) = 1;
  __int128 v23 = sub_10001675C(v16, 1LL, a9, 0LL);
  xpc_dictionary_apply_f(a5);
  sub_100016828(v23);
  if (!*((_DWORD *)v16 + 50) && (_UNKNOWN *)sub_10002A994(a2) != &unk_1000695B8 && *((_DWORD *)v16 + 26) != a4)
  {
    sub_1000176D4( (uint64_t)v16,  3,  "Not allowed to set SockPathOwner to UID %d. Remove key.",  v25,  v26,  v27,  v28,  v29,  *((_DWORD *)v16 + 26));
    *((_DWORD *)v16 + 50) = 1;
  }

  return v16;
}

void sub_10001796C(const char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = (_BYTE *)a3[1];
  xpc_type_t type = xpc_get_type(object);
  if (!strcasecmp(a1, "SockType"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    if (!strcasecmp(string_ptr, "stream"))
    {
      int v12 = 1;
    }

    else if (!strcasecmp(string_ptr, "dgram"))
    {
      int v12 = 2;
    }

    else
    {
      if (strcasecmp(string_ptr, "seqpacket"))
      {
        sub_100011A84(v5, 3LL, "Unrecognized %s");
        goto LABEL_65;
      }

      int v12 = 5;
    }

    *(_DWORD *)(v6 + 100) = v12;
    return;
  }

  if (!strcasecmp(a1, "SockPassive"))
  {
    if (type == (xpc_type_t)&_xpc_type_BOOL)
    {
      if (xpc_BOOL_get_value(object)) {
        __int16 v9 = 2;
      }
      else {
        __int16 v9 = 0;
      }
      __int16 v10 = *(_WORD *)(v6 + 204) & 0xFFFD;
LABEL_27:
      __int16 v11 = v10 | v9;
LABEL_28:
      *(_WORD *)(v6 + 204) = v11;
      return;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(a1, "SecureSocketWithKey"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    if (!*(void *)(v6 + 144))
    {
      uint64_t v13 = xpc_string_get_string_ptr(object);
      *(void *)(v6 + 136) = sub_1000126A0(v13);
      return;
    }

    goto LABEL_34;
  }

  if (!strcasecmp(a1, "SockPathName"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    if (*(void *)(v6 + 136))
    {
LABEL_34:
      sub_100011A84(v5, 3LL, "Can't have both %s and %s");
      goto LABEL_65;
    }

    if (xpc_string_get_length(object) >= 0x68)
    {
      sub_100011A84(v5, 3LL, "%s value is too long.", a1);
      int v15 = 34;
LABEL_66:
      *(_DWORD *)(v6 + 200) = v15;
      return;
    }

    __int128 v17 = xpc_string_get_string_ptr(object);
    if (v17)
    {
      *(void *)(v6 + 144) = sub_1000126A0(v17);
      return;
    }

LABEL_65:
    int v15 = 22;
    goto LABEL_66;
  }

  if (!strcasecmp(a1, "SockPathOwner"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_DWORD *)(v6 + 104) = xpc_int64_get_value(object);
      return;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(a1, "SockPathGroup"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_DWORD *)(v6 + 108) = xpc_int64_get_value(object);
      return;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(a1, "SockPathMode"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_WORD *)(v6 + 152) = xpc_int64_get_value(object);
      __int16 v11 = *(_WORD *)(v6 + 204) | 8;
      goto LABEL_28;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(a1, "SockNodeName"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v14 = xpc_string_get_string_ptr(object);
      *(void *)(v6 + 160) = sub_1000126A0(v14);
      return;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(a1, "MulticastGroup"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v16 = xpc_string_get_string_ptr(object);
      *(void *)(v6 + 168) = sub_1000126A0(v16);
      return;
    }

    goto LABEL_64;
  }

  if (!strcasecmp(a1, "SockServiceName"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      __int128 v22 = xpc_string_get_string_ptr(object);
      int v19 = sub_1000126A0(v22);
    }

    else
    {
      int64_t value = xpc_int64_get_value(object);
      int v19 = sub_100012884("%lld", value);
    }

    *(void *)(v6 + 176) = v19;
    return;
  }

  if (!strcasecmp(a1, "SockFamily"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v20 = xpc_string_get_string_ptr(object);
      if (!strcasecmp(v20, "IPv4"))
      {
        int v21 = 2;
      }

      else if (!strcasecmp(v20, "IPv6"))
      {
        int v21 = 30;
      }

      else
      {
        if (!strcasecmp(v20, "IPv4v6"))
        {
          *(_DWORD *)(v6 + 184) = 30;
          __int16 v11 = *(_WORD *)(v6 + 204) | 0x20;
          goto LABEL_28;
        }

        if (strcasecmp(v20, "Unix")) {
          goto LABEL_79;
        }
        int v21 = 1;
      }

      *(_DWORD *)(v6 + 184) = v21;
      return;
    }

LABEL_64:
    xpc_type_get_name(type);
    sub_100011A84(v5, 3LL, "Invalid type for socket dictionary (key/type): %s/%s");
    goto LABEL_65;
  }

  if (!strcasecmp(a1, "SockProtocol"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    __int128 v23 = xpc_string_get_string_ptr(object);
    if (!strcasecmp(v23, "TCP"))
    {
      int v24 = 6;
    }

    else
    {
      if (strcasecmp(v23, "UDP"))
      {
LABEL_79:
        sub_100011A84(v5, 4LL, "Unrecognized %s");
        return;
      }

      int v24 = 17;
    }

    *(_DWORD *)(v6 + 188) = v24;
    return;
  }

  if (strcasecmp(a1, "Bonjour"))
  {
    if (!strcasecmp(a1, "SystemLoggingSocket"))
    {
      if (xpc_BOOL_get_value(object)) {
        __int16 v9 = 64;
      }
      else {
        __int16 v9 = 0;
      }
      __int16 v10 = *(_WORD *)(v6 + 204) & 0xFFBF;
    }

    else
    {
      if (strcasecmp(a1, "ReceivePacketInfo"))
      {
        sub_100011A84(v5, 4LL, "Unknown socket key %s");
        return;
      }

      if (xpc_BOOL_get_value(object)) {
        __int16 v9 = 512;
      }
      else {
        __int16 v9 = 0;
      }
      __int16 v10 = *(_WORD *)(v6 + 204) & 0xFDFF;
    }

    goto LABEL_27;
  }

  if (type != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(object))
  {
    __int16 v11 = *(_WORD *)(v6 + 204) | 0x10;
    goto LABEL_28;
  }

void sub_100017EFC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 204) & 0x40) != 0)
  {
    if (qword_100069CB0)
    {
      sub_1000176D4(a1, 3, "System logger socket is already claimed by: %s", a4, a5, a6, a7, a8, qword_100069CB0 - 48);
      *(_DWORD *)(a1 + 200) = 37;
      __int16 v10 = (dispatch_queue_t *)a1;
      int v11 = 1;
    }

    else
    {
      qword_100069CB0 = a1;
      *(void *)(a1 + 64) = sub_100010B00(4uLL);
      *(void *)(a1 + 72) = sub_100010B00(1uLL);
      *(void *)(a1 + 88) = 1LL;
      __int128 v17 = *(_DWORD **)(a1 + 64);
      *__int128 v17 = dword_1000699D8;
      *(_DWORD *)(a1 + 100) = 2;
      *(_WORD *)(a1 + 204) |= 4u;
      if (*v17 == -1) {
        sub_1000176D4( a1,  4,  "System logger socket was not opened during early boot. (Proceeding anyway)",  v12,  v13,  v14,  v15,  v16,  v18);
      }
      __int16 v10 = (dispatch_queue_t *)a1;
      int v11 = 0;
    }

    sub_10001800C(v10, v11);
  }

  else
  {
    sub_1000167B0((void *)a1);
    __int16 v9 = (dispatch_queue_s *)sub_100011944();
    dispatch_async_f(v9, (void *)a1, (dispatch_function_t)sub_10001806C);
  }

void sub_10001800C(dispatch_queue_t *a1, int a2)
{
  uint64_t v4 = sub_100010B00(0x10uLL);
  *(void *)uint64_t v4 = sub_1000167B0(a1);
  v4[2] = a2;
  dispatch_async_f(a1[14], v4, (dispatch_function_t)sub_1000196E4);
}

void sub_10001806C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 136);
  if (v9 || *(void *)(a1 + 144))
  {
    if (!byte_10006A918)
    {
      sub_10003B008("fixup-mobile-tmp", 196611, "launchd has not fixed mobile/tmp (socket)", a4, a5, a6, a7, a8, v155);
      uint64_t v9 = *(void *)(a1 + 136);
    }

    bzero(v165, 0x400uLL);
    if (v9)
    {
      __strlcpy_chk(v165, "/private/var/tmp/com.apple.launchd.XXXXXXXXXX", 1024LL, 1024LL);
      if (!mkdtemp(v165) && *__error()) {
        _os_assumes_log_ctx(sub_1000176A0, a1);
      }
      __int16 v10 = sub_100012884("%s/%s", v165, (const char *)(a1 + 208));
      *(void *)(a1 + 144) = v10;
    }

    else
    {
      __int16 v10 = *(char **)(a1 + 144);
    }

    memset(&v177, 0, 106);
    BYTE1(v177.st_dev) = 1;
    strncpy((char *)&v177.st_dev + 2, v10, 0x67uLL);
    *(void *)(a1 + 64) = sub_100010B00(4uLL);
    *(void *)(a1 + 72) = sub_100010B00(1uLL);
    *(void *)(a1 + 88) = 1LL;
    int v11 = socket(1, *(_DWORD *)(a1 + 100), 0);
    **(_DWORD **)(a1 + 64) = v11;
    if (v11 == -1) {
      goto LABEL_130;
    }
    if ((*(_WORD *)(a1 + 204) & 2) == 0)
    {
      int v12 = connect(v11, (const sockaddr *)&v177, 0x6Au);
      goto LABEL_14;
    }

    uint64_t v14 = *(const char **)(a1 + 144);
    if (!v14) {
      sub_100046EB4();
    }
    memset(&v178, 0, sizeof(v178));
    if (stat(v14, &v178))
    {
      if (*__error() != 2)
      {
        uint64_t v13 = (char *)*__error();
        uint64_t v20 = *(void *)(a1 + 144);
        xpc_strerror(v13);
        sub_1000176D4(a1, 3, "Failed to stat() old socket path: path=%s, error=%s (%d)", v21, v22, v23, v24, v25, v20);
        if ((_DWORD)v13) {
          goto LABEL_140;
        }
LABEL_25:
        if (bind(**(_DWORD **)(a1 + 64), (const sockaddr *)&v177, 0x6Au))
        {
          uint64_t v33 = __error();
          char v34 = xpc_strerror(*v33);
          __error();
          sub_1000176D4(a1, 3, "Failed to bind() a socket: error=%s (%d)", v35, v36, v37, v38, v39, v34);
          LODWORD(v13) = *__error();
          if ((_DWORD)v13) {
            goto LABEL_140;
          }
        }

        bzero(&v178, 0x400uLL);
        if (dirname_r(*(const char **)(a1 + 144), (char *)&v178))
        {
          uint64_t v40 = (int *)open((const char *)&v178, 0x100000);
          if ((v40 & 0x80000000) == 0)
          {
            uint64_t v41 = v40;
            bzero(&v178, 0x400uLL);
            if (basename_r(*(const char **)(a1 + 144), (char *)&v178))
            {
              uid_t v42 = *(_DWORD *)(a1 + 104);
              if (*(_DWORD *)(a1 + 108)) {
                gid_t v43 = *(_DWORD *)(a1 + 108);
              }
              else {
                gid_t v43 = v42 == 0;
              }
              if (fchownat((int)v41, (const char *)&v178, v42, v43, 32))
              {
                uint64_t v13 = "Failed to fchown() a socket: error=%s (%d)";
              }

              else
              {
                if (!*(void *)(a1 + 136) || (uid_t v140 = *(_DWORD *)(a1 + 104)) == 0 || !chown(v165, v140, 0))
                {
LABEL_147:
                  if ((*(_WORD *)(a1 + 204) & 8) != 0) {
                    mode_t v141 = *(_WORD *)(a1 + 152);
                  }
                  else {
                    mode_t v141 = 438;
                  }
                  if (fchmodat((int)v41, (const char *)&v178, v141, 32))
                  {
                    uint64_t v142 = __error();
                    char v143 = xpc_strerror(*v142);
                    __error();
                    sub_1000176D4( a1,  3,  "Failed to fchmodat() a socket: error=%s (%d)",  v144,  v145,  v146,  v147,  v148,  v143);
                    LODWORD(v13) = *__error();
                    sub_100036D70(v41);
                    if ((_DWORD)v13) {
                      goto LABEL_140;
                    }
                  }

                  else
                  {
                    sub_100036D70(v41);
                  }

                  if ((*(_DWORD *)(a1 + 100) | 4) != 5) {
                    goto LABEL_15;
                  }
                  int v12 = listen(**(_DWORD **)(a1 + 64), -1);
LABEL_14:
                  if (v12 != -1)
                  {
LABEL_15:
                    LODWORD(v13) = 0;
LABEL_140:
                    *(_DWORD *)(a1 + 200) = (_DWORD)v13;
LABEL_141:
                    *(_WORD *)(a1 + 204) |= 4u;
                    sub_10001800C((dispatch_queue_t *)a1, (_DWORD)v13 != 0);
                    sub_10001685C((void *)a1);
                    return;
                  }

LABEL_130:
                  __error();
                  _os_assumes_log_ctx(sub_1000176A0, a1);
                  LODWORD(v13) = *__error();
                  goto LABEL_140;
                }

                uint64_t v13 = "Failed to chown() secure socket directory: error=%s (%d)";
              }

              __int128 v44 = __error();
              char v45 = xpc_strerror(*v44);
              __error();
              sub_1000176D4(a1, 3, v13, v46, v47, v48, v49, v50, v45);
              LODWORD(v13) = *__error();
              if ((_DWORD)v13)
              {
                sub_100036D70(v41);
                goto LABEL_140;
              }

              goto LABEL_147;
            }

            v133 = __error();
            char v134 = xpc_strerror(*v133);
            __error();
            sub_1000176D4( a1,  3,  "Failed to basename_r() a socket path: error=%s (%d)",  v135,  v136,  v137,  v138,  v139,  v134);
LABEL_139:
            LODWORD(v13) = 108;
            goto LABEL_140;
          }

          uint64_t v125 = "Failed to open() socket directory: error=%s (%d)";
        }

        else
        {
          uint64_t v125 = "Failed to dirname_r() a socket path: error=%s (%d)";
        }

        uint64_t v126 = __error();
        char v127 = xpc_strerror(*v126);
        __error();
        sub_1000176D4(a1, 3, v125, v128, v129, v130, v131, v132, v127);
        goto LABEL_139;
      }
    }

    else if (*(_DWORD *)(a1 + 104) != v178.st_uid)
    {
      sub_1000176D4( a1,  3,  "Cannot remove old socket path; UIDs mismatch: socket = %d, path = %d",
        v15,
        v16,
        v17,
        v18,
        v19,
        *(_DWORD *)(a1 + 104));
      LODWORD(v13) = 122;
      goto LABEL_140;
    }

    if (unlink(*(const char **)(a1 + 144)))
    {
      if (*__error() != 2)
      {
        uint64_t v26 = __error();
        char v27 = xpc_strerror(*v26);
        __error();
        sub_1000176D4(a1, 3, "Failed to remove old socket: error=%s (%d)", v28, v29, v30, v31, v32, v27);
        LODWORD(v13) = *__error();
        if ((_DWORD)v13) {
          goto LABEL_140;
        }
      }
    }

    goto LABEL_25;
  }

  memset(&v163, 0, sizeof(v163));
  int v51 = *(_DWORD *)(a1 + 100);
  int v52 = *(_DWORD *)(a1 + 188);
  v163.int ai_family = *(_DWORD *)(a1 + 184);
  v163.ai_sockxpc_type_t type = v51;
  v163.uint64_t ai_protocol = v52;
  if ((*(_BYTE *)(a1 + 204) & 2) != 0) {
    v163.ai_flags = 1;
  }
  v162 = 0LL;
  int v53 = getaddrinfo(*(const char **)(a1 + 160), *(const char **)(a1 + 176), &v163, &v162);
  if (v53)
  {
    int v149 = v53;
    _os_assumes_log_ctx(sub_1000176A0, a1);
    gai_strerror(v149);
    sub_1000176D4(a1, 3, "getaddrinfo(3): %d: %s", v150, v151, v152, v153, v154, v149);
    LODWORD(v13) = sub_100019778(v149);
    *(_DWORD *)(a1 + 200) = (_DWORD)v13;
    if ((_DWORD)v13) {
      goto LABEL_141;
    }
LABEL_133:
    if ((*(_WORD *)(a1 + 204) & 0x10) != 0)
    {
      sub_1000167B0((void *)a1);
      unsigned int v124 = (dispatch_queue_s *)sub_100011938();
      dispatch_async_f(v124, (void *)a1, (dispatch_function_t)sub_10001972C);
      LODWORD(v13) = *(_DWORD *)(a1 + 200);
    }

    else
    {
      LODWORD(v13) = 0;
    }

    goto LABEL_141;
  }

  uint64_t v54 = v162;
  unint64_t v55 = *(void *)(a1 + 88);
  if (v162)
  {
    do
    {
      ++v55;
      uint64_t v54 = v54->ai_next;
    }

    while (v54);
    *(void *)(a1 + 88) = v55;
  }

  if (!(v55 >> 62))
  {
    *(void *)(a1 + 64) = sub_100010B00(4 * v55);
    *(void *)(a1 + 72) = sub_100010B00(*(void *)(a1 + 88));
    uint64_t v56 = v162;
    if (!v162)
    {
      size_t v123 = 0LL;
      goto LABEL_132;
    }

    uint64_t v57 = 0LL;
    while (1)
    {
      int v58 = socket(v56->ai_family, v56->ai_socktype, v56->ai_protocol);
      uint64_t v59 = *(void *)(a1 + 64);
      *(_DWORD *)(v59 + 4 * v57) = v58;
      if (v58 == -1)
      {
        __error();
        _os_assumes_log_ctx(sub_1000176A0, a1);
        uint64_t ai_protocol = v56->ai_protocol;
        uint64_t v159 = v57;
        ai_sockxpc_type_t type = (const char *)v56->ai_socktype;
        sub_1000176D4( a1,  3,  "Could not create socket for resolved listener (family = %d, xpc_type_t type = %d, protocol = %d, idx = %lu: ",  v65,  v66,  v67,  v68,  v69,  v56->ai_family);
        goto LABEL_118;
      }

      int v161 = 1;
      __int16 v60 = *(_WORD *)(a1 + 204);
      if ((v60 & 2) == 0)
      {
        int v61 = connect(*(_DWORD *)(v59 + 4 * v57), v56->ai_addr, v56->ai_addrlen);
        if (!v61) {
          goto LABEL_102;
        }
        if (v61 == -1) {
          goto LABEL_101;
        }
        goto LABEL_118;
      }

      int ai_family = v56->ai_family;
      if (ai_family == 2)
      {
        if ((v60 & 0x20) != 0)
        {
          sub_100036D70((int *)*(unsigned int *)(v59 + 4 * v57));
          *(_DWORD *)(*(void *)(a1 + 64) + 4 * v57) = -1;
          goto LABEL_118;
        }

        if ((*(_WORD *)(a1 + 204) & 0x200) != 0)
        {
          int v64 = setsockopt(*(_DWORD *)(v59 + 4 * v57), 0, 20, &v161, 4u);
          if (v64)
          {
            if (v64 == -1) {
              goto LABEL_101;
            }
            goto LABEL_118;
          }

          int v71 = setsockopt(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v57), 0, 7, &v161, 4u);
          if (v71)
          {
            if (v71 == -1) {
              goto LABEL_101;
            }
            goto LABEL_118;
          }
        }
      }

      else if (ai_family == 30)
      {
        if ((v60 & 0x20) == 0)
        {
          int v63 = setsockopt(*(_DWORD *)(v59 + 4 * v57), 41, 27, &v161, 4u);
          if (v63)
          {
            if (v63 == -1) {
              goto LABEL_101;
            }
            goto LABEL_118;
          }

          uint64_t v59 = *(void *)(a1 + 64);
          *(_DWORD *)(a1 + 96) = *(_DWORD *)(v59 + 4 * v57);
          __int16 v60 = *(_WORD *)(a1 + 204);
        }

        if ((v60 & 0x200) != 0)
        {
          int v70 = setsockopt(*(_DWORD *)(v59 + 4 * v57), 41, 61, &v161, 4u);
          if (v70)
          {
            if (v70 == -1) {
              goto LABEL_101;
            }
            goto LABEL_118;
          }
        }
      }

      int v72 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v57);
      if (*(void *)(a1 + 168))
      {
        int v73 = setsockopt(v72, 0xFFFF, 512, &v161, 4u);
        if (v73)
        {
          if (v73 == -1) {
            goto LABEL_101;
          }
          goto LABEL_118;
        }
      }

      else
      {
        int v74 = setsockopt(v72, 0xFFFF, 4, &v161, 4u);
        if (v74)
        {
          if (v74 == -1) {
            goto LABEL_101;
          }
          goto LABEL_118;
        }
      }

      int v75 = bind(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v57), v56->ai_addr, v56->ai_addrlen);
      if (v75)
      {
        if (v75 == -1) {
          goto LABEL_101;
        }
        goto LABEL_118;
      }

      int v76 = getsockname(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v57), v56->ai_addr, &v56->ai_addrlen);
      if (v76)
      {
        if (v76 == -1) {
          goto LABEL_101;
        }
        goto LABEL_118;
      }

      uint64_t v77 = *(const char **)(a1 + 168);
      if (v77)
      {
        int v78 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v57);
        int v79 = v56->ai_protocol;
        uint64_t v80 = *(void *)&v56->ai_family;
        memset(&v178.st_uid, 0, 32);
        int v160 = v80;
        *(void *)&v178.st_mode = v80;
        v178.st_dev = 1;
        HIDWORD(v178.st_ino) = v79;
        *(void *)&v177.st_dev = 0LL;
        int v81 = getaddrinfo(v77, 0LL, (const addrinfo *)&v178, (addrinfo **)&v177);
        if (!v81)
        {
          uint64_t v93 = *(void *)&v177.st_dev;
          if (!*(void *)&v177.st_dev)
          {
LABEL_97:
            freeaddrinfo(*(addrinfo **)&v177.st_dev);
            goto LABEL_98;
          }

          while (2)
          {
            if (v160 == 30)
            {
              LODWORD(v166) = 0;
              memset(v165, 0, sizeof(v165));
              *(_OWORD *)v165 = *(_OWORD *)(*(void *)(v93 + 32) + 8LL);
              int v94 = v78;
              int v95 = 41;
              socklen_t v96 = 20;
LABEL_93:
              if (setsockopt(v94, v95, 12, v165, v96) != -1) {
                goto LABEL_97;
              }
              __error();
              _os_assumes_log_ctx(sub_1000176A0, a1);
            }

            else
            {
              if (v160 == 2)
              {
                *(void *)v165 = 0LL;
                *(_DWORD *)v165 = *(_DWORD *)(*(void *)(v93 + 32) + 4LL);
                int v94 = v78;
                int v95 = 0;
                socklen_t v96 = 8;
                goto LABEL_93;
              }

              sub_1000176D4( a1,  3,  "Unknown family encountered during multicast group bind: %d",  v82,  v83,  v84,  v85,  v86,  v160);
            }

            uint64_t v93 = *(void *)(v93 + 40);
            if (!v93) {
              goto LABEL_97;
            }
            continue;
          }
        }

        int v87 = v81;
        ai_sockxpc_type_t type = gai_strerror(v81);
        sub_1000176D4(a1, 3, "getaddrinfo(3): %d: %s", v88, v89, v90, v91, v92, v87);
        sub_100019778(v87);
      }

LABEL_98:
      if ((v56->ai_socktype | 4) != 5 || (int v97 = listen(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v57), -1)) == 0)
      {
LABEL_102:
        int v98 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v57);
        uint64_t v99 = (const char *)sub_10001E38C(*(void *)(a1 + 56));
        if (*v99 == 47)
        {
          uint64_t v100 = 0LL;
        }

        else
        {
          uint64_t v102 = getenv("PATH");
          if (!v102)
          {
            sub_1000176D4( a1,  3,  "No PATH environment variable set. The application firewall will not work with this service.",  v103,  v104,  v105,  v106,  v107,  v155);
LABEL_116:
            if (fcntl(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v57), 4, 4LL, ai_socktype, ai_protocol, v159) == -1) {
              sub_100047638();
            }
            goto LABEL_118;
          }

          uint64_t v100 = sub_1000126A0(v102);
          __stringp = v100;
          __int128 v175 = 0u;
          __int128 v176 = 0u;
          __int128 v173 = 0u;
          __int128 v174 = 0u;
          __int128 v171 = 0u;
          __int128 v172 = 0u;
          __int128 v169 = 0u;
          __int128 v170 = 0u;
          __int128 v167 = 0u;
          __int128 v168 = 0u;
          *(_OWORD *)v165 = 0u;
          __int128 v166 = 0u;
          int v108 = strsep(&__stringp, ":");
          if (v108)
          {
            uint64_t v114 = 0LL;
            while (v114 != 24)
            {
              uint64_t v115 = v114 + 1;
              *(void *)&v165[8 * v114] = v108;
              int v108 = strsep(&__stringp, ":");
              uint64_t v114 = v115;
              if (!v108) {
                goto LABEL_122;
              }
            }

            sub_1000176D4( a1,  4,  "PATH contains lots of paths. Some will be skipped.",  v109,  v110,  v111,  v112,  v113,  v155);
            uint64_t v115 = 24LL;
LABEL_122:
            uint64_t v116 = 0LL;
            uint64_t v117 = 8 * v115;
            while (1)
            {
              bzero(&v178, 0x400uLL);
              snprintf((char *)&v178, 0x400uLL, "%s/%s", *(const char **)&v165[v116], v99);
              memset(&v177, 0, sizeof(v177));
              v116 += 8LL;
              if (v117 == v116) {
                goto LABEL_127;
              }
            }

            free(v100);
            uint64_t v99 = sub_1000126A0((const char *)&v178);
            uint64_t v100 = (char *)v99;
LABEL_127:
            if (!v99)
            {
              sub_1000176D4( a1,  3,  "Socket's service points to a non-existent executable. The application firewall will not work with this service.",  v118,  v119,  v120,  v121,  v122,  v156);
LABEL_115:
              free(v100);
              goto LABEL_116;
            }
          }
        }

        int v101 = strlen(v99);
        if (setsockopt(v98, 0xFFFF, 4229, v99, v101 + 1) == -1 && *__error() != 42 && *__error()) {
          _os_assumes_log_ctx(sub_1000176A0, a1);
        }
        goto LABEL_115;
      }

      if (v97 == -1) {
LABEL_101:
      }
        sub_100047610();
LABEL_118:
      ++v57;
      uint64_t v56 = v56->ai_next;
      if (!v56)
      {
        size_t v123 = v162;
LABEL_132:
        freeaddrinfo(v123);
        *(_DWORD *)(a1 + 200) = 0;
        goto LABEL_133;
      }
    }
  }

  __break(1u);
}

uint64_t sub_100018D10(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2) {
    return 0LL;
  }
  uint64_t result = *(void *)(a1 + 144);
  *a2 = v2;
  return result;
}

void sub_100018D2C(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 204);
  if ((v1 & 0x100) != 0) {
    sub_100039448("attempt to watch socket that is already watched");
  }
  if ((v1 & 0x80) != 0) {
    sub_100039448("attempt to watch canceled socket");
  }
  if (*(void *)(a1 + 80)) {
    sub_100046EB4();
  }
  unint64_t v3 = *(void *)(a1 + 88);
  if (v3 >> 61)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a1 + 80) = sub_100010B00(8 * v3);
    unint64_t v4 = *(void *)(a1 + 88);
    if (v4)
    {
      uint64_t v5 = 0LL;
      while (1)
      {
        int v6 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v5);
        if (v6 != -1) {
          break;
        }
LABEL_15:
        if (++v5 >= v4) {
          goto LABEL_16;
        }
      }

      int v7 = dup(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v5));
      if (v7 == -1)
      {
        sub_100047638();
      }

      else
      {
        uintptr_t v13 = v7;
        if ((v7 & 0x80000000) == 0)
        {
          uint64_t v14 = (dispatch_queue_s *)sub_100011938();
          dispatch_source_t v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v13, 0LL, v14);
          dispatch_set_context(v15, (void *)a1);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 0x40000000LL;
          handler[2] = sub_1000197F4;
          handler[3] = &unk_100064330;
          handler[4] = v15;
          int v18 = v6;
          dispatch_source_set_event_handler(v15, handler);
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 0x40000000LL;
          v16[2] = sub_10001985C;
          v16[3] = &unk_100064350;
          v16[4] = v15;
          dispatch_source_set_mandatory_cancel_handler(v15, v16);
          dispatch_activate(v15);
          if (v15) {
            goto LABEL_14;
          }
        }
      }

      sub_1000176D4(a1, 4, "Unable to monitor socket #%zu", v8, v9, v10, v11, v12, v5);
      dispatch_source_t v15 = 0LL;
LABEL_14:
      *(void *)(*(void *)(a1 + 80) + 8 * v5) = v15;
      unint64_t v4 = *(void *)(a1 + 88);
      goto LABEL_15;
    }

LABEL_16:
    *(_WORD *)(a1 + 204) |= 0x100u;
  }

  byte_10006A6C8 = 0;
}

void sub_100018EE4(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 204);
  if ((v1 & 0x100) == 0) {
    sub_100039448("attempt to ignore socket that is already ignored");
  }
  if ((v1 & 0x80) != 0) {
    sub_100039448("attempt to ignore canceled socket");
  }
  unint64_t v3 = *(void **)(a1 + 80);
  if (!v3) {
    sub_100046EB4();
  }
  unint64_t v4 = *(void *)(a1 + 88);
  if (v4)
  {
    for (unint64_t i = 0LL; i < v4; ++i)
    {
      int v6 = *(dispatch_source_s **)(*(void *)(a1 + 80) + 8 * i);
      if (*(_DWORD *)(*(void *)(a1 + 64) + 4 * i) == -1)
      {
        if (v6) {
          sub_100046EB4();
        }
      }

      else if (v6)
      {
        dispatch_source_cancel(v6);
        unint64_t v4 = *(void *)(a1 + 88);
        *(void *)(*(void *)(a1 + 80) + 8 * i) = 0LL;
      }
    }

    unint64_t v3 = *(void **)(a1 + 80);
  }

  free(v3);
  *(void *)(a1 + 80) = 0LL;
  *(_WORD *)(a1 + 204) &= ~0x100u;
}

uint64_t sub_100018F94(uint64_t a1, void *a2, void *a3, void *a4)
{
  if ((*(_WORD *)(a1 + 204) & 1) != 0) {
    return 37LL;
  }
  *a2 = *(void *)(a1 + 64);
  *a4 = *(void *)(a1 + 88);
  if (a3) {
    *a3 = *(void *)(a1 + 72);
  }
  if (*(void *)(a1 + 88))
  {
    unint64_t v5 = 0LL;
    do
    {
      int v6 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v5);
      if (v6 != -1 && fcntl(v6, 4, 0LL) == -1) {
        sub_100047638();
      }
      ++v5;
    }

    while (v5 < *(void *)(a1 + 88));
  }

  uint64_t result = 0LL;
  *(_WORD *)(a1 + 204) |= 1u;
  return result;
}

uint64_t sub_100019040(uint64_t result, void *a2, void *a3)
{
  *a2 = *(void *)(result + 64);
  *a3 = *(void *)(result + 88);
  return result;
}

uint64_t sub_100019054(uint64_t a1)
{
  return *(unsigned int *)(a1 + 200);
}

uint64_t sub_10001905C(uint64_t result)
{
  *(_WORD *)(result + 204) &= ~1u;
  unint64_t v1 = *(void *)(result + 88);
  if (v1)
  {
    uint64_t v2 = (void *)result;
    for (unint64_t i = 0LL; i < v1; ++i)
    {
      uint64_t result = *(unsigned int *)(v2[8] + 4 * i);
      if ((_DWORD)result != -1)
      {
        uint64_t result = fcntl(result, 4, 4LL);
        if ((_DWORD)result == -1) {
          uint64_t result = sub_100047638();
        }
        *(_BYTE *)(v2[9] + i) = 0;
        unint64_t v1 = v2[11];
      }
    }
  }

  return result;
}

void sub_1000190EC(uint64_t a1)
{
  __int16 v2 = *(_WORD *)(a1 + 204);
  if ((v2 & 0x100) != 0)
  {
    sub_100018EE4(a1);
    __int16 v2 = *(_WORD *)(a1 + 204);
  }

  *(_WORD *)(a1 + 204) = v2 | 0x80;
}

uint64_t sub_100019124(void *a1, unsigned int **a2, void *a3)
{
  unint64_t v3 = a1[11];
  if (v3 >> 62) {
    __break(1u);
  }
  int v7 = (unsigned int *)sub_100010B00(4 * v3);
  unint64_t v8 = a1[11];
  if (v8)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = a1[8];
      if (*(_DWORD *)(v11 + 4 * v9) != -1)
      {
        __int128 v31 = 0u;
        __int128 v32 = 0u;
        __int128 v29 = 0u;
        __int128 v30 = 0u;
        __int128 v27 = 0u;
        __int128 v28 = 0u;
        sockaddr v25 = (sockaddr)0;
        __int128 v26 = 0u;
        socklen_t v24 = 128;
        int v12 = accept(*(_DWORD *)(v11 + 4 * v9), &v25, &v24);
        if (v12 == -1)
        {
          uint64_t v14 = __error();
          uint64_t v15 = *v14;
          if (*(_BYTE *)(a1[9] + v9))
          {
            xpc_strerror(*v14);
            sub_1000176D4( (uint64_t)a1,  3,  "Got a socket event but accept() failed with errno %d - %s",  v16,  v17,  v18,  v19,  v20,  v15);
          }

          if ((_DWORD)v15 != 35)
          {
            if (v10)
            {
              uint64_t v22 = v7;
              do
              {
                unsigned int v23 = *v22++;
                sub_100036D70((int *)v23);
                --v10;
              }

              while (v10);
            }

            free(v7);
            return v15;
          }
        }

        else
        {
          int v13 = v12;
          if (fcntl(v12, 4, 0LL) == -1) {
            sub_100047638();
          }
          v7[v10++] = v13;
        }

        *(_BYTE *)(a1[9] + v9) = 0;
        unint64_t v8 = a1[11];
      }

      if (++v9 >= v8) {
        goto LABEL_16;
      }
    }
  }

  uint64_t v10 = 0LL;
LABEL_16:
  uint64_t v15 = 0LL;
  *a2 = v7;
  *a3 = v10;
  return v15;
}

uint64_t sub_1000192CC( uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D32C(a2, a3, "%s = {", a4, a5, a6, a7, a8, a1 + 208);
  __int16 v16 = *(_WORD *)(a1 + 204);
  if ((v16 & 4) != 0)
  {
    if ((v16 & 0x40) != 0)
    {
      uint64_t v18 = "(system logger socket)";
LABEL_63:
      uint64_t v19 = a2;
      uint64_t v17 = a3 + 1;
      goto LABEL_64;
    }

    unsigned int v20 = *(_DWORD *)(a1 + 100) - 1;
    uint64_t v21 = "(unknown)";
    if (v20 <= 4) {
      uint64_t v21 = off_100064370[v20];
    }
    sub_10003D32C(a2, a3 + 1, "xpc_type_t type = %s", v11, v12, v13, v14, v15, v21);
    if (*(void *)(a1 + 144) || *(void *)(a1 + 136))
    {
      sub_10003D32C(a2, a3 + 1, "path = %s", v24, v25, v26, v27, v28, *(void *)(a1 + 144));
      if ((*(_WORD *)(a1 + 204) & 8) != 0)
      {
        LOWORD(v85) = *(_WORD *)(a1 + 152);
        sub_10003D32C(a2, a3 + 1, "mode = %o", v24, v25, v26, v27, v28);
      }

      if (*(void *)(a1 + 136))
      {
        uint64_t v85 = *(void *)(a1 + 136);
        sub_10003D32C(a2, a3 + 1, "secure key = %s", v24, v25, v26, v27, v28);
      }

      if (*(_DWORD *)(a1 + 104))
      {
        LODWORD(v85) = *(_DWORD *)(a1 + 104);
        sub_10003D32C(a2, a3 + 1, "owner uid = %u", v24, v25, v26, v27, v28);
        if (*(_DWORD *)(a1 + 104)) {
          sub_10003D32C(a2, a3 + 1, "group id = %u", v24, v25, v26, v27, v28, *(unsigned int *)(a1 + 108));
        }
      }

LABEL_39:
      if (*(_DWORD *)(a1 + 200))
      {
        LODWORD(v85) = *(_DWORD *)(a1 + 200);
        sub_10003D32C(a2, a3 + 1, "int error = %d", v24, v25, v26, v27, v28);
      }

      sub_10003D3A8(a2, v22, v23, v24, v25, v26, v27, v28, v85);
      sub_10003D32C(a2, a3 + 1, "sockets = {", v34, v35, v36, v37, v38);
      if (*(void *)(a1 + 88))
      {
        unint64_t v44 = 0LL;
        do
        {
          if (*(_BYTE *)(*(void *)(a1 + 72) + v44)) {
            char v45 = "";
          }
          else {
            char v45 = "no ";
          }
          sub_10003D32C( a2,  a3 + 2,  "%d (%sbytes to read)",  v39,  v40,  v41,  v42,  v43,  *(unsigned int *)(*(void *)(a1 + 64) + 4 * v44++),  v45);
        }

        while (v44 < *(void *)(a1 + 88));
      }

      sub_10003D32C(a2, a3 + 1, "}", v39, v40, v41, v42, v43);
      sub_10003D3A8(a2, v46, v47, v48, v49, v50, v51, v52, v86);
      if ((*(_WORD *)(a1 + 204) & 1) != 0) {
        int v58 = "1";
      }
      else {
        int v58 = "0";
      }
      sub_10003D32C(a2, a3 + 1, "active = %s", v53, v54, v55, v56, v57, v58);
      if ((*(_WORD *)(a1 + 204) & 2) != 0) {
        int v64 = "1";
      }
      else {
        int v64 = "0";
      }
      sub_10003D32C(a2, a3 + 1, "passive = %s", v59, v60, v61, v62, v63, v64);
      if ((*(_WORD *)(a1 + 204) & 0x10) != 0) {
        int v70 = "1";
      }
      else {
        int v70 = "0";
      }
      sub_10003D32C(a2, a3 + 1, "bonjour = %s", v65, v66, v67, v68, v69, v70);
      if ((*(_WORD *)(a1 + 204) & 0x20) != 0) {
        int v76 = "1";
      }
      else {
        int v76 = "0";
      }
      sub_10003D32C(a2, a3 + 1, "ipv4int v6 = %s", v71, v72, v73, v74, v75, v76);
      if ((*(_WORD *)(a1 + 204) & 0x200) != 0) {
        uint64_t v77 = "1";
      }
      else {
        uint64_t v77 = "0";
      }
      uint64_t v84 = v77;
      uint64_t v18 = "receive_packet_info = %s";
      goto LABEL_63;
    }

    if (*(void *)(a1 + 160))
    {
      uint64_t v85 = *(void *)(a1 + 160);
      sub_10003D32C(a2, a3 + 1, "node mach_port_name_t name = %s", v24, v25, v26, v27, v28);
    }

    if (*(void *)(a1 + 168))
    {
      uint64_t v85 = *(void *)(a1 + 168);
      sub_10003D32C(a2, a3 + 1, "multicast group = %s", v24, v25, v26, v27, v28);
    }

    if (*(void *)(a1 + 176))
    {
      uint64_t v85 = *(void *)(a1 + 176);
      sub_10003D32C(a2, a3 + 1, "service mach_port_name_t name = %s", v24, v25, v26, v27, v28);
    }

    int v29 = *(_DWORD *)(a1 + 184);
    if (v29 > 1)
    {
      if (v29 == 2)
      {
        __int128 v30 = "ipv4";
        goto LABEL_31;
      }

      if (v29 == 30)
      {
        __int128 v30 = "ipv6";
        goto LABEL_31;
      }
    }

    else
    {
      if (!v29) {
        goto LABEL_32;
      }
      if (v29 == 1)
      {
        __int128 v30 = "unix";
LABEL_31:
        sub_10003D32C(a2, a3 + 1, "family = %s", v24, v25, v26, v27, v28, v30);
LABEL_32:
        int v31 = *(_DWORD *)(a1 + 188);
        if (v31)
        {
          __int128 v32 = "udp";
          if (v31 != 17) {
            __int128 v32 = "(unknown)";
          }
          if (v31 == 6) {
            uint64_t v33 = "tcp";
          }
          else {
            uint64_t v33 = v32;
          }
          sub_10003D32C(a2, a3 + 1, "protocol = %s", v24, v25, v26, v27, v28, v33);
        }

        goto LABEL_39;
      }
    }

    __int128 v30 = "(unknown)";
    goto LABEL_31;
  }

  uint64_t v17 = a3 + 1;
  uint64_t v18 = "(animating)";
  uint64_t v19 = a2;
LABEL_64:
  sub_10003D32C(v19, v17, v18, v11, v12, v13, v14, v15, v84);
  return sub_10003D32C(a2, a3, "}", v78, v79, v80, v81, v82);
}

  unint64_t v3 = 0LL;
LABEL_40:
  if ((*(_BYTE *)(a1 + 1356) & 4) != 0)
  {
    unsigned int v20 = sub_100020AC4(a1);
    uint64_t v21 = a1 + 1016;
    if (v20) {
      uint64_t v21 = v20;
    }
    *(_BYTE *)(v21 + 1) = 1;
  }

  return v3;
}

  uint64_t v36 = (void *)*((void *)v17 + 13);
  if (v36 == (void *)&unk_1000695B8 || v36 == qword_100069750)
  {
    sub_10002C1C8((uint64_t)v17, 0LL, dword_10006A940, 4LL, v27, v28, v29, v30);
    *((void *)v17 + 16) = xpc_retain((xpc_object_t)qword_10006A948);
  }

  sub_10002587C((uint64_t)v17, 5, "created", v26, v27, v28, v29, v30, v38);
  return v17;
}

                uint64_t v24 = 1LL;
                if (!sub_100015988((_OWORD *)a2, (uint64_t)"mach-register", 1))
                {
LABEL_54:
                  sub_10002C2D4(a1, v15);
                  sub_100030FC8(a1, (char)a3, a4, a2, v24);
                  goto LABEL_55;
                }

                if (*(_WORD *)(v15 + 300) == 32766)
                {
                  uint64_t v24 = 12LL;
                  goto LABEL_54;
                }

                if (a5)
                {
                  xpc_retain(a5);
                }

                else
                {
                  uint64_t v85 = sub_10000AB70(0x12u, 2u, 0LL);
                  a5 = (void *)xpc_mach_send_create_with_disposition(v85, 17LL);
                }

                char v86 = sub_10003F35C(v15, a3, a5, (uint64_t)sub_10002762C, v15);
                if (a6) {
                  *a6 = a5;
                }
                else {
                  xpc_release(a5);
                }
                v86[88] |= 4u;
                sub_100027850(a1, (void *)v15, (uint64_t)v86, 1);
                sub_10002BE4C(a1, (uint64_t)v86);
LABEL_34:
                sub_10002C2D4(a1, v15);
                sub_10002C2D4(a1, v15);
                uint64_t v24 = 0LL;
LABEL_55:
                sub_10002B3F0(a1, v15, v55, v56, v57, v58, v59, v60);
                return v24;
              }

              sub_10002587C( a1,  3,  "Service %s tried to register for endpoint %s already registered by owner: %s",  v78,  v79,  v80,  v81,  v82,  v15 + 80);
            }
          }

          uint64_t v24 = 1LL;
          goto LABEL_54;
        }

        *(_DWORD *)(v15 + 368) |= 0x2000u;
        *(_BYTE *)(v16 + 88) |= 4u;
        if (!a6) {
          goto LABEL_34;
        }
        uint64_t v52 = v16;
      }

      uint64_t v84 = (void *)sub_10003FB6C(v52, 4, v46, v47, v48, v49, v50, v51);
      *a6 = xpc_retain(v84);
      goto LABEL_34;
    }

    if (sub_100015988((_OWORD *)a2, (uint64_t)"mach-register", 2))
    {
      for (unint64_t i = *(void *)(v15 + 168); i; unint64_t i = *(void *)(i + 16))
      {
        if ((*(_BYTE *)(i + 88) & 0x40) == 0 && sub_1000129FC((char *)(i + 168), a3))
        {
          uint64_t v37 = sub_10003F1E0(i, 2, v31, v32, v33, v34, v35, v36);
          if (!sub_10002C17C(v37))
          {
            uint64_t v24 = 37LL;
            goto LABEL_54;
          }

          *(_BYTE *)(i + 88) |= 0x40u;
        }
      }

      if (a5)
      {
        xpc_retain(a5);
      }

      else
      {
        uint64_t v53 = sub_10000AB70(0x12u, 6u, 0LL);
        a5 = (void *)xpc_mach_send_create_with_disposition(v53, 17LL);
      }

      uint64_t v54 = sub_10003F35C(v15, a3, a5, (uint64_t)sub_10002762C, v15);
      if (a6) {
        *a6 = a5;
      }
      else {
        xpc_release(a5);
      }
      v54[88] |= 5u;
      sub_100027850(a1, (void *)v15, (uint64_t)v54, 2);
      goto LABEL_34;
    }

    uint64_t v24 = 1LL;
    sub_100028BC8(a1, a2, 1LL, "pid-local registration");
    uint64_t v25 = a1;
    uint64_t v26 = (char)a3;
    uint64_t v27 = a4;
    uint64_t v28 = a2;
    int v29 = 1LL;
  }

  else
  {
    uint64_t v24 = 113LL;
    uint64_t v25 = a1;
    uint64_t v26 = (char)a3;
    uint64_t v27 = a4;
    uint64_t v28 = a2;
    int v29 = 113LL;
  }

  sub_100030FC8(v25, v26, v27, v28, v29);
  return v24;
}

void sub_1000196E4(unsigned int *a1)
{
  __int16 v2 = *(void **)a1;
  (*(void (**)(void, void, void))(*(void *)a1 + 120LL))( *(void *)a1,  a1[2],  *(void *)(*(void *)a1 + 128LL));
  sub_10001685C(v2);
  free(a1);
}

void sub_10001972C(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 204) & 0x80) == 0) {
    sub_100035CE8( *(void **)(a1 + 56),  "com.apple.bonjour.registration",  (const char *)(a1 + 208),  *(void **)(a1 + 192));
  }
  sub_10001685C((void *)a1);
}

uint64_t sub_100019778(int a1)
{
  switch(a1)
  {
    case 1:
    case 5:
    case 9:
    case 10:
      uint64_t result = 45LL;
      break;
    case 2:
      uint64_t result = 35LL;
      break;
    case 3:
    case 12:
    case 13:
      uint64_t result = 22LL;
      break;
    case 4:
      uint64_t result = 153LL;
      break;
    case 6:
      uint64_t result = 12LL;
      break;
    case 7:
    case 8:
      uint64_t result = 3LL;
      break;
    case 11:
      uint64_t result = *__error();
      break;
    case 14:
      uint64_t result = 34LL;
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }

  return result;
}

uint64_t sub_1000197F4(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  uint64_t v3 = context[11];
  if (v3)
  {
    uint64_t v4 = 0LL;
    while (*(_DWORD *)(context[8] + 4 * v4) != *(_DWORD *)(a1 + 40))
    {
      if (v3 == ++v4) {
        return ((uint64_t (*)(void *, uint64_t, void))context[15])(context, 2LL, context[16]);
      }
    }

    *(_BYTE *)(context[9] + v4) = 1;
  }

  return ((uint64_t (*)(void *, uint64_t, void))context[15])(context, 2LL, context[16]);
}

void sub_10001985C(uint64_t a1)
{
  handle = (int *)dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  sub_100036D70(handle);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_100019888(uint64_t a1)
{
  return _os_assumes_log_ctx(a1, v1);
}

int *sub_100019890()
{
  return __error();
}

  ;
}

uint64_t sub_1000198A0(int *a1)
{
  return _os_assumes_log(*a1);
}

void sub_1000198A8()
{
  qword_100069CB8 = 0LL;
  byte_100069CC0 = 0;
  qword_100069CC8 = 0LL;
  qword_100069CD0 = 0LL;
  qword_100069CD8 = 0LL;
}

BOOL sub_1000198D4(uint64_t a1)
{
  if (a1)
  {
    __int16 v2 = (rb_tree_t **)sub_100019948();
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000LL;
    v5[2] = sub_100019978;
    v5[3] = &unk_1000643A0;
    v5[4] = a1;
    sub_100017410(v2, (uint64_t)v5);
  }

  uint64_t v3 = sub_100019948();
  return sub_10001748C((size_t)v3) != 0;
}

void *sub_100019948()
{
  uint64_t result = (void *)qword_100069CD0;
  if (!qword_100069CD0)
  {
    uint64_t result = sub_1000174A8();
    qword_100069CD0 = (uint64_t)result;
  }

  return result;
}

uint64_t sub_100019978(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_100019988(void *a1, void *a2)
{
  uunint64_t int64 = xpc_dictionary_get_uint64(a1, "cid");
  uint64_t v5 = uint64;
  int v6 = (rb_tree_t **)sub_100019948();
  int v7 = sub_1000173CC(v6, v5);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      xpc_object_t v10 = reply;
      sub_100019A08(reply, v8);
      uint64_t result = 0LL;
      *a2 = v10;
      return result;
    }

    return 22LL;
  }

  return 3LL;
}

void sub_100019A08(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_10000E618(a2);
  xpc_dictionary_set_uint64(a1, "cid", v4);
  uint64_t v5 = (const char *)sub_10000F6FC(a2);
  int v6 = (const char *)sub_10000F704(a2);
  if (v5) {
    xpc_dictionary_set_string(a1, "name", v5);
  }
  if (v6) {
    xpc_dictionary_set_string(a1, "bundle_identifier", v6);
  }
  int v7 = (const void *)sub_10000F70C(a2);
  if (v7) {
    xpc_dictionary_set_data(a1, "resource-usage-blob", v7, 0x160uLL);
  }
}

uint64_t sub_100019AC4(void *a1, void *a2)
{
  byte_100069CC0 = 1;
  uint64_t v4 = (void *)qword_100069CD8;
  if (!qword_100069CD8)
  {
    uint64_t v4 = sub_10000E454();
    qword_100069CD8 = (uint64_t)v4;
  }

  if (sub_10000E618((uint64_t)v4))
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      int v6 = reply;
      int v7 = (void *)qword_100069CD8;
      if (!qword_100069CD8)
      {
        int v7 = sub_10000E454();
        qword_100069CD8 = (uint64_t)v7;
      }

      uint64_t v8 = sub_10000E5F0((uint64_t)v7, 0LL);
      sub_10000F71C(v8, 2);
      sub_100019A08(v6, v8);
      uint64_t v9 = (void *)qword_100069CD8;
      if (!qword_100069CD8)
      {
        uint64_t v9 = sub_10000E454();
        qword_100069CD8 = (uint64_t)v9;
      }

      sub_10000E580((uint64_t)v9, 0LL);
      uint64_t result = 0LL;
      *a2 = v6;
    }

    else
    {
      return 22LL;
    }
  }

  else if (qword_100069CB8)
  {
    return 37LL;
  }

  else
  {
    xpc_object_t v11 = xpc_dictionary_create_reply(a1);
    uint64_t result = 0LL;
    qword_100069CB8 = (uint64_t)v11;
  }

  return result;
}

uint64_t sub_100019BA8(uint64_t a1)
{
  __int16 v2 = (rb_tree_t **)sub_100019948();
  uint64_t v3 = sub_1000173CC(v2, a1);
  if (!v3) {
    return 5LL;
  }
  uint64_t v4 = v3;
  sub_10000F71C((uint64_t)v3, 1);
  if (!sub_10000F714((uint64_t)v4))
  {
    memset(v11, 0, sizeof(v11));
    sub_10000F6A8(v4, v11);
    int v6 = (void *)qword_100069CB8;
    if (qword_100069CB8)
    {
      qword_100069CB8 = 0LL;
      sub_100019A08(v6, (uint64_t)v4);
      int v7 = xpc_pipe_routine_reply(v6);
      xpc_release(v6);
      if (!v7) {
        goto LABEL_11;
      }
      if (v7 != 32)
      {
        _os_assumes_log(v7);
        goto LABEL_11;
      }
    }

    sub_100019EBC(v4);
    goto LABEL_11;
  }

  sub_10000F6A8(v4, 0LL);
LABEL_11:
  if (byte_10006A9BA)
  {
    uint64_t v8 = (const char *)sub_10000F6FC((uint64_t)v4);
    sub_10003AB08(65541, "coalition_reap(%llu) [%s]", a1, v8);
  }

  sub_10000D42C(a1);
  uint64_t v9 = sub_100019948();
  uint64_t v10 = sub_10000E618((uint64_t)v4);
  sub_100017318((uint64_t)v9, v10, 0LL);
  return 0LL;
}

_BYTE *sub_100019D24(uint64_t a1)
{
  uint64_t v2 = sub_10000D30C((unsigned int *)a1);
  uint64_t v3 = sub_10000F544(v2, *(const char **)(a1 + 8), *(const char **)(a1 + 16), *(_DWORD *)a1, (uint64_t)sub_10000D404);
  uint64_t v4 = sub_100019948();
  uint64_t v5 = sub_10000E618((uint64_t)v3);
  sub_100017318((uint64_t)v4, v5, v3);
  return v3;
}

uint64_t sub_100019D80(const void *a1, _DWORD *a2)
{
  if (*a2) {
    sub_100046EC8();
  }
  if (!a1) {
    sub_100046EC8();
  }
  uint64_t v4 = (void *)qword_100069CC8;
  if (!qword_100069CC8)
  {
    uint64_t v4 = sub_10003CF98(32LL, (uint64_t)sub_100019E4C);
    qword_100069CC8 = (uint64_t)v4;
  }

  uint64_t v5 = sub_10003CF38((uint64_t)v4, a1);
  if (v5)
  {
    uint64_t v6 = (uint64_t)v5;
    uint64_t v7 = sub_10000E618((uint64_t)v5);
    sub_10003AB08(5, "Coalition Cache Hit: %s [%llu]", (const char *)a1, v7);
    return sub_10000F620(v6);
  }

  else
  {
    uint64_t v9 = sub_100019D24((uint64_t)a2);
    uint64_t v10 = qword_100069CC8;
    xpc_object_t v11 = (void *)sub_10000F620((uint64_t)v9);
    sub_10003CD6C(v10, a1, v11);
    return (uint64_t)v9;
  }

uint64_t sub_100019E4C(const char *a1, uint64_t a2)
{
  uint64_t v4 = sub_10000E618(a2);
  sub_10003AB08(5, "Coalition Cache Evicted: %s [%llu]", a1, v4);
  return sub_10000F650(a2);
}

void sub_100019E94()
{
  qword_100069CC8 = 0LL;
}

void *sub_100019EBC(void *a1)
{
  uint64_t result = (void *)sub_10000F71C((uint64_t)a1, 2);
  if (byte_100069CC0 == 1)
  {
    uint64_t v3 = (void *)qword_100069CD8;
    if (!qword_100069CD8)
    {
      uint64_t v3 = sub_10000E454();
      qword_100069CD8 = (uint64_t)v3;
    }

    return sub_10000E4D8(v3, a1);
  }

  return result;
}

uint64_t sub_100019F14()
{
  return os_map_str_init(&unk_100069CE0, 0LL, 1LL);
}

void sub_100019F28(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
    sub_10001685C(v2);
  }
}

char *sub_100019F7C(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v4 = sub_1000170B8(a3);
  *((void *)v4 + 2) = sub_1000126A0(a2);
  return v4;
}

void *sub_100019FB4(uint64_t a1, char *a2, const char *a3, void *a4)
{
  uint64_t v7 = os_map_str_find(&unk_100069CE0, a3);
  if (!v7) {
    goto LABEL_6;
  }
  uint64_t v8 = (const char **)v7;
  if (!sub_1000129FC(a2, *(const char **)(v7 + 16)))
  {
    sub_10003AB08(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", a3, a2, v8[2]);
LABEL_6:
    uint64_t v9 = sub_1000170B8(a3);
    v9[2] = sub_1000126A0(a2);
    v9[3] = sub_1000167B0(a4);
    os_map_str_insert(&unk_100069CE0, v9 + 4, v9);
    return v9;
  }

  uint64_t v9 = sub_1000167B0(v8);
  if (!v9) {
    goto LABEL_6;
  }
  return v9;
}

uint64_t sub_10001A098(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 16LL);
}

uint64_t sub_10001A0A4(uint64_t a1)
{
  return *(void *)(a1 + 16) + 32LL;
}

uint64_t sub_10001A0B0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 24LL);
}

void *sub_10001A0BC()
{
  return sub_100010B00(0x50uLL);
}

uint64_t sub_10001A0C4(uint64_t result, int a2)
{
  if (*(void *)result)
  {
    int v2 = *(_DWORD *)(result + 72);
    unsigned int v3 = *(_DWORD *)(result + 76);
    *(_DWORD *)(result + 4LL * (((_BYTE)v3 + (_BYTE)v2) & 0xF) + 8) = a2 - *(void *)result;
    if (v3 > 0xF) {
      *(_DWORD *)(result + 72) = ((_BYTE)v2 + 1) & 0xF;
    }
    else {
      *(_DWORD *)(result + 76) = v3 + 1;
    }
  }

  *(void *)uint64_t result = 0LL;
  return result;
}

void *sub_10001A10C(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t sub_10001A114(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t sub_10001A11C(uint64_t a1, char a2)
{
  return *(unsigned int *)(a1 + 4LL * ((*(_DWORD *)(a1 + 72) + a2) & 0xF) + 8);
}

uint64_t sub_10001A134(uint64_t a1)
{
  uint64_t result = sub_10001A1AC(a1);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = os_map_str_find(result, *(void *)(a1 + 576));
    if (!result)
    {
      uint64_t v4 = *(const char **)(a1 + 576);
      uint64_t v5 = sub_100010B00(0x58uLL);
      v5[1] = 1;
      uint64_t v6 = sub_1000126A0(v4);
      return os_map_str_insert(v3, v6, v5);
    }
  }

  return result;
}

uint64_t sub_10001A1AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 248);
  if (v2 && (_UNKNOWN *)sub_10002A994(v2) == &unk_100069750 && (*(_BYTE *)(a1 + 1358) & 8) != 0) {
    return sub_10002A9A4(*(void *)(*(void *)(a1 + 248) + 200LL));
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10001A204(uint64_t a1)
{
  uint64_t v2 = sub_100020AC4(a1);
  uint64_t v3 = (unsigned __int8 *)(a1 + 1016);
  if (v2) {
    uint64_t v3 = (unsigned __int8 *)v2;
  }
  return *v3;
}

uint64_t sub_10001A234(uint64_t a1, uint64_t a2)
{
  if (byte_10006A9B1 || (*(_BYTE *)(a1 + 1354) & 0x80) != 0) {
    return 0LL;
  }
  return 0LL;
}

uint64_t sub_10001A288(uint64_t a1, uint64_t a2)
{
  if (byte_10006A9B1 || (*(_BYTE *)(a1 + 1354) & 0x80) != 0) {
    return 0LL;
  }
  if (sub_10003DC94(a1 + 1176))
  {
    int v4 = 1;
  }

  else if (sub_10003DA48(a1 + 1176))
  {
    int v4 = sub_10003DA74((_DWORD *)(a1 + 1176)) == 0;
  }

  else if (*(_DWORD *)(a1 + 1000))
  {
    int v4 = 0;
  }

  else
  {
    int v4 = *(_BYTE *)(a2 + 32) != 0;
  }

  else {
    return 0LL;
  }
}

uint64_t sub_10001A334(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 144);
  if (v3)
  {
    int v4 = 0;
    do
    {
      v4 |= sub_100035994(v3);
      uint64_t v3 = *(void *)(v3 + 16);
    }

    while (v3);
  }

  else
  {
    LOBYTE(v4) = 0;
  }

  if (*(_BYTE *)(a2 + 32) == (v4 & 1)) {
    return 14LL;
  }
  else {
    return 0LL;
  }
}

void sub_10001A394(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 512);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      if ((_DWORD)a2 == 9 || *((_DWORD *)v6 + 8) == (_DWORD)a2)
      {
        void v6[5] = sub_1000167B0((void *)a1);
        uint64_t v8 = (dispatch_queue_s *)sub_100011938();
        dispatch_async_f(v8, v6, (dispatch_function_t)sub_100020AF8);
        uint64_t v9 = (void *)*v6;
        if (*v6) {
          v9[1] = v6[1];
        }
        *(void *)v6[1] = v9;
        *uint64_t v6 = -1LL;
        v6[1] = -1LL;
      }

      uint64_t v6 = v7;
    }

    while (v7);
  }

  sub_1000167B0((void *)a1);
  else {
    uint64_t v15 = off_100064760[(int)a2 - 1];
  }
  sub_10001A4D8(a1, 5, "internal event: %s, code = %ld", v10, v11, v12, v13, v14, (char)v15);
  sub_100038488(a1, a2, a3, v16, v17, v18, v19, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 520))(a1, a2, a3, *(void *)(a1 + 568));
  sub_10001685C((void *)a1);
}

void sub_10001A4D8( uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12 = sub_10001C2A0(a1, 2);
  sub_10003AE8C(v12, a2, a3, &a9, v9);
  free(v12);
}

uint64_t sub_10001A53C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = a2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 528))(a1, a2, *(void *)(a1 + 568));
  if ((_DWORD)result == 124) {
    return 0LL;
  }
  if (!(_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 1354) & 4) != 0)
    {
      sub_10001A4D8(a1, 5, "cannot spawn: service is in penalty box", v5, v6, v7, v8, v9, v62);
      return 139LL;
    }

    uint64_t v10 = *(void *)(a1 + 248);
    if ((_UNKNOWN *)sub_10002A994(v10) == &unk_100069750)
    {
      uint64_t v24 = qword_100069CF8;
      if (qword_100069CF8)
      {
        do
        {
          uint64_t v25 = *(void *)v24;
          uint64_t v26 = *(void *)(a1 + 256);
          uint64_t v27 = *(char **)(v24 + 16);
          if (v26)
          {
          }

          else if (sub_1000129FC(v27, (const char *)(a1 + 1360)))
          {
LABEL_25:
            sub_10001A4D8(a1, 5, "matched global attach request before spawn", v11, v12, v13, v14, v15, v62);
            uint64_t v32 = sub_10002A99C(v10);
            xpc_dictionary_set_uint64(*(xpc_object_t *)(v24 + 24), "handle", v32);
            if ((*(_BYTE *)(a1 + 1357) & 2) != 0) {
              xpc_dictionary_set_uuid(*(xpc_object_t *)(v24 + 24), "_instance", (const unsigned __int8 *)(a1 + 408));
            }
            sub_10003E5F8(dword_10006A940, *(void **)(v24 + 24));
            xpc_release(*(xpc_object_t *)(v24 + 24));
            uint64_t v33 = *(void *)v24;
            if (*(void *)v24) {
              *(void *)(v33 + 8) = *(void *)(v24 + 8);
            }
            **(void **)(v24 + 8) = v33;
            free((void *)v24);
            *(_DWORD *)(a1 + 796) = v2;
            *(_BYTE *)(a1 + 1298) |= 8u;
            char v34 = sub_10002089C(v2);
            sub_10001A4D8( a1,  5,  "service spawn reason '%s' pended until controller attaches",  v35,  v36,  v37,  v38,  v39,  v34);
            sub_100020C0C(a1, 1);
            char v62 = sub_10002089C(v2);
            uint64_t v23 = "pended spawn reason '%s': redriving controller attach request";
LABEL_30:
            sub_10001A4D8(a1, 5, v23, v11, v12, v13, v14, v15, v62);
            return 36LL;
          }

          uint64_t v24 = v25;
        }

        while (v25);
      }
    }

    int v16 = *(_DWORD *)(a1 + 1104);
    if (v16 && v16 != v2)
    {
      char v17 = sub_10002089C(v2);
      sub_10001A4D8(a1, 5, "ignoring spawn reason '%s' due to filter", v18, v19, v20, v21, v22, v17);
      return 102LL;
    }

    if (*(void *)(a1 + 800))
    {
      uint64_t v23 = "cannot spawn: service is throttled";
      goto LABEL_30;
    }

    uint64_t v28 = sub_100020AC4(a1);
    uint64_t v29 = a1 + 1016;
    if (v28) {
      uint64_t v30 = v28;
    }
    else {
      uint64_t v30 = a1 + 1016;
    }
    if (*(_BYTE *)(v30 + 1) || (v2 & 0xFFFFFFF7) == 3 || (*(void *)(a1 + 1352) & 0x4000) != 0) {
      goto LABEL_23;
    }
    uint64_t v40 = sub_100020AC4(a1);
    uint64_t v41 = sub_100020AC4(a1);
    if (v41) {
      uint64_t v42 = v41;
    }
    else {
      uint64_t v42 = a1 + 1016;
    }
    if (v40)
    {
      if (v42 == v29) {
        uint64_t v43 = (_DWORD *)(a1 + 1176);
      }
      else {
        uint64_t v43 = (_DWORD *)(v42 + 32);
      }
      if (!*v43) {
        goto LABEL_23;
      }
      uint64_t v44 = sub_100020AC4(a1);
      if (v44) {
        uint64_t v45 = v44;
      }
      else {
        uint64_t v45 = a1 + 1016;
      }
      if (v45 == v29) {
        uint64_t v46 = (_DWORD *)(a1 + 1176);
      }
      else {
        uint64_t v46 = (_DWORD *)(v45 + 32);
      }
      if (*v46 != 3)
      {
        if (!*v46)
        {
          sub_10001A9FC(a1);
LABEL_23:
          unsigned int v31 = *(unsigned __int8 *)(a1 + 424);
          if (v31 >= 2)
          {
            if (v31 != 2)
            {
              uint64_t v47 = sub_100020C90(a1);
              sub_100039448("Spawning a service in state %s", v47);
            }

            return 36LL;
          }

          sub_100020C0C(a1, 1);
          sub_100020D38(a1, v2);
          return sub_100020E18(a1);
        }

        unint64_t v49 = 0LL;
LABEL_58:
        unint64_t v55 = sub_10001A9FC(a1);
        uint64_t v56 = v55 - v49;
        if (v55 > v49)
        {
          sub_10001A4D8( a1,  5,  "Service only ran for %llu seconds. Pushing respawn out by %llu seconds.",  v50,  v51,  v52,  v53,  v54,  v49);
          if (v55 != v49)
          {
            sub_1000217AC(a1, v56, v2);
            return 36LL;
          }
        }

        goto LABEL_23;
      }

      uint64_t v48 = sub_10003DAB8((uint64_t)v46);
    }

    else
    {
      uint64_t v48 = *(void *)(v42 + 8);
    }

    unint64_t v49 = sub_10000A9C0(v48) / 0x3B9ACA00uLL;
    goto LABEL_58;
  }

  return result;
}

uint64_t sub_10001A8EC()
{
  return 1LL;
}

uint64_t sub_10001A8F4(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 676);
  if (!(_DWORD)result)
  {
    uint64_t v3 = *(void *)(a1 + 256);
    if (v3) {
      return *(unsigned int *)(v3 + 676);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

size_t sub_10001A91C(uint64_t a1)
{
  uint64_t v2 = sub_100020AC4(a1);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = a1 + 1016;
  }
  if (!*(void *)(v3 + 16)) {
    return 0LL;
  }
  uint64_t v4 = sub_100020AC4(a1);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = a1 + 1016;
  }
  return xpc_array_get_count(*(xpc_object_t *)(v5 + 16));
}

uint64_t sub_10001A978(uint64_t a1)
{
  uint64_t result = sub_100020AC4(a1);
  if (result) {
    uint64_t v3 = result;
  }
  else {
    uint64_t v3 = a1 + 1016;
  }
  if (*(void *)(v3 + 16))
  {
    uint64_t v4 = sub_100020AC4(a1);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = a1 + 1016;
    }
    uint64_t v6 = *(void **)(v5 + 16);
    xpc_object_t v7 = sub_100020B50(v6, qword_100069A48);
    xpc_release(v6);
    uint64_t result = sub_100020AC4(a1);
    if (result) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = a1 + 1016;
    }
    *(void *)(v8 + 16) = v7;
  }

  return result;
}

uint64_t sub_10001A9FC(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 1358) & 4) == 0) {
    return *(unsigned int *)(a1 + 812);
  }
  uint64_t v2 = sub_100020AC4(a1);
  uint64_t v3 = a1 + 1016;
  if (v2) {
    uint64_t v3 = v2;
  }
  if (!*(void *)(v3 + 16)) {
    return *(unsigned int *)(a1 + 812);
  }
  unsigned int v4 = *(unsigned __int16 *)(a1 + 1004);
  unsigned int v5 = sub_10001A91C(a1);
  unsigned int v6 = v5 - v4;
  if (v5 <= v4) {
    return *(unsigned int *)(a1 + 812);
  }
  if (v6 > 0xB) {
    return 1200LL;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 812);
  if (!(_DWORD)v8) {
    sub_100046EB4();
  }
  unint64_t v9 = v8 << v6;
  if (v9 >= 0x4B0) {
    return 1200LL;
  }
  else {
    return v9;
  }
}

void sub_10001AA88( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(_BYTE *)(a2 + 176) = 0;
  *(void *)(a2 + 180) = 0LL;
  if (*(_BYTE *)(a1 + 1006) || (*(_BYTE *)(a1 + 1359) & 4) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 1352);
    if (byte_10006A99E) {
      BOOL v12 = 0;
    }
    else {
      BOOL v12 = (v11 & 0x10000000000LL) == 0;
    }
    if (v12)
    {
      sub_10001A4D8(a1, 4, "Disallowing panic-on-crash behavior for non-system service", a4, a5, a6, a7, a8, a9);
    }

    else if ((v11 & 0x400000000000000LL) != 0)
    {
      uint64_t v14 = sub_100020AC4(a1);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = a1 + 1016;
      }
      int v16 = *(void **)(v15 + 24);
      if (v16)
      {
        xpc_object_t v17 = sub_100020B50(*(void **)(v15 + 24), *(void *)(a1 + 1008));
        xpc_release(v16);
        *(void *)(v15 + 24) = v17;
        if (xpc_array_get_count(v17) >= 2)
        {
          uint64_t v18 = sub_10001ABA4(*(void *)(a1 + 1008));
          sub_10001A4D8(a1, 4, "Enabling panic-on-crash due to consecutive crashes", v19, v20, v21, v22, v23, v24);
          *(void *)(a2 + 180) = v18;
          *(_BYTE *)(a2 + 176) = 1;
        }
      }
    }

    else
    {
      *(_BYTE *)(a2 + 176) = *(_BYTE *)(a1 + 1006);
      unint64_t v13 = *(void *)(a1 + 1008);
      if (v13) {
        *(void *)(a2 + 180) = sub_10001ABA4(v13);
      }
    }
  }

uint64_t sub_10001ABA4(unint64_t a1)
{
  uint64_t v2 = mach_continuous_time();
  sub_10000AA5C(a1);
  if (__CFADD__(v2, v3)) {
    sub_100039448("Overflow calculating deadline: %lld + %lld", v2, v3);
  }
  return v2 + v3;
}

uint64_t sub_10001ABF4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 1352);
  if ((v2 & 0x220000) != 0 || (v2 & 0x400000) != 0 && !*(_DWORD *)(a1 + 1000))
  {
    uint64_t v3 = 7LL;
    goto LABEL_3;
  }

  if ((v2 & 4) != 0)
  {
    if (*(_DWORD *)(a1 + 1000)) {
      uint64_t v3 = 5LL;
    }
    else {
      uint64_t v3 = 4LL;
    }
LABEL_3:
    if (byte_10006A919)
    {
      unsigned int v4 = &dword_1000695B0;
      uint64_t v5 = 2LL;
      goto LABEL_37;
    }

    if (byte_10006A9B1)
    {
      unsigned int v4 = &dword_100069590;
      uint64_t v5 = 8LL;
LABEL_37:
      while (1)
      {
        int v19 = *v4++;
        if (v19 == (_DWORD)v3) {
          break;
        }
        if (!--v5) {
          goto LABEL_39;
        }
      }
    }

    goto LABEL_40;
  }

  if ((v2 & 0x10) != 0 && !*(_DWORD *)(a1 + 1000))
  {
    if ((~v2 & 0x40000001000LL) != 0) {
      uint64_t v3 = 4LL;
    }
    else {
      uint64_t v3 = 9LL;
    }
    goto LABEL_3;
  }

  uint64_t v6 = sub_100020AC4(a1);
  uint64_t v7 = a1 + 1016;
  if (v6) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = a1 + 1016;
  }
  if (v8 == v7) {
    uint64_t v9 = a1 + 1176;
  }
  else {
    uint64_t v9 = v8 + 32;
  }
  if ((*(_BYTE *)(v9 + 48) & 2) != 0)
  {
    uint64_t v10 = sub_100020AC4(a1);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = a1 + 1016;
    }
    if (v11 == v7) {
      uint64_t v12 = a1 + 1176;
    }
    else {
      uint64_t v12 = v11 + 32;
    }
    BOOL v13 = sub_10003DC94(v12);
    uint64_t v14 = sub_100020AC4(a1);
    if (v14) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = a1 + 1016;
    }
    if (v13)
    {
      *(_BYTE *)(v15 + 1) = 1;
      goto LABEL_28;
    }

    if (v15 == v7) {
      uint64_t v23 = (_DWORD *)(a1 + 1176);
    }
    else {
      uint64_t v23 = (_DWORD *)(v15 + 32);
    }
    BOOL v24 = sub_10003DC4C(v23);
    uint64_t v25 = sub_100020AC4(a1);
    if (v25) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = a1 + 1016;
    }
    if (v26 == v7) {
      uint64_t v27 = a1 + 1176;
    }
    else {
      uint64_t v27 = v26 + 32;
    }
    if (v24)
    {
      if (!sub_10003DC64(v27))
      {
        if (*(int *)(a1 + 896) >= 31)
        {
          uint64_t v28 = sub_100020AC4(a1);
          if (v28) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = a1 + 1016;
          }
          *(_BYTE *)(v29 + 1) = 1;
        }

        if ((*(_BYTE *)(a1 + 1356) & 4) == 0) {
          goto LABEL_86;
        }
      }
    }

    else if (sub_10003DBAC(v27))
    {
      uint64_t v30 = sub_100020AC4(a1);
      uint64_t v31 = v30 ? v30 : a1 + 1016;
      uint64_t v32 = v31 == v7 ? a1 + 1176 : v31 + 32;
      if ((*(_BYTE *)(v32 + 48) & 1) != 0)
      {
        uint64_t v33 = sub_100020AC4(a1);
        if (v33) {
          uint64_t v39 = v33;
        }
        else {
          uint64_t v39 = a1 + 1016;
        }
        if (*(_DWORD *)(v39 + 4) <= 2u)
        {
          uint64_t v40 = sub_100020AC4(a1);
          if (v40) {
            uint64_t v41 = v40;
          }
          else {
            uint64_t v41 = a1 + 1016;
          }
          *(_BYTE *)(v41 + 1) = 1;
LABEL_86:
          uint64_t v3 = 3LL;
          goto LABEL_3;
        }

        sub_10001A4D8( a1,  5,  "service exceeded successive crash limit. launch will be throttled",  v34,  v35,  v36,  v37,  v38,  v42);
      }
    }
  }

LABEL_28:
  uint64_t v16 = *(void *)(a1 + 136);
  if (v16)
  {
    while ((sub_100035EB4(v16) & 1) == 0)
    {
      uint64_t v16 = *(void *)(v16 + 16);
      if (!v16) {
        goto LABEL_31;
      }
    }

    uint64_t v3 = 8LL;
    goto LABEL_3;
  }

LABEL_31:
  uint64_t v17 = a1 + 648;
  while (1)
  {
    uint64_t v17 = *(void *)v17;
    if (!v17) {
      break;
    }
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 16))(a1, v17);
    if ((_DWORD)v18)
    {
      uint64_t v3 = v18;
      goto LABEL_3;
    }
  }

    ;
  }

  sub_100010BC4(a1, 6);
  for (uint64_t j = 0LL; j != 23; ++j)
  {
    uint64_t v78 = *(void *)(a1 + 8 * j + 304);
    while (v78)
    {
      uint64_t v79 = v78;
      uint64_t v78 = *(void *)(v78 + 120);
    }
  }

  os_map_str_clear(a1 + 488, &stru_1000648C0);
  sub_100010BC4(a1, 7);
  for (k = 0LL; k != 31; ++k)
  {
    uint64_t v81 = *(void **)(a1 + 8 * k + 672);
    if (v81)
    {
      do
      {
        uint64_t v82 = (void *)v81[4];
        if (v81[9]) {
          sub_10002BD2C(v81);
        }
        uint64_t v81 = v82;
      }

      while (v82);
    }
  }

  sub_100010BC4(a1, 8);
  for (m = *(void *)(a1 + 288); m; m = *(void *)(m + 16))
    sub_100025C50(m);
  sub_100010BC4(a1, 9);
  *(_WORD *)(a1 + 968) |= 1u;
  if (*(void *)(a1 + 144))
  {
    sub_100016C74(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 144), *(void **)(a1 + 144));
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 144));
    *(void *)(a1 + 144) = 0LL;
    *(_DWORD *)(a1 + 152) = 0;
  }

  if (*(void *)(a1 + 136))
  {
    if ((*(_WORD *)(a1 + 968) & 0x200) != 0)
    {
      sub_10002587C(a1, 5, "uncorking exec source for disposal", v84, v85, v86, v87, v88, v90);
      dispatch_activate(*(dispatch_object_t *)(a1 + 136));
      *(_WORD *)(a1 + 968) &= ~0x200u;
    }

    sub_100016C74(a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 136));
    *(void *)(a1 + 136) = 0LL;
  }

  sub_100010BC4(a1, 10);
  sub_100025A14(a1, 1);
  if (*(_UNKNOWN **)(a1 + 104) == &unk_1000695B8 && qword_10006A410) {
    dispatch_release((dispatch_object_t)qword_10006A410);
  }
  sub_100010BC4(a1, 11);
  sub_100025B64(a1);
}

  *a4 = v85;
  return v12;
}

uint64_t sub_10001AE98( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  if (a2) {
    sub_10001A4D8( (uint64_t)a1,  4,  "Overriding specified stdin path for inetd-compatible service.",  a4,  a5,  a6,  a7,  a8,  v19);
  }
  uint64_t v12 = (int *)dup(v8);
  if ((_DWORD)v12 != -1)
  {
    BOOL v13 = v12;
    if (a3)
    {
      uint64_t v14 = 0xFFFFFFFFLL;
    }

    else
    {
      uint64_t v14 = dup(v8);
      if ((_DWORD)v14 == -1)
      {
        uint64_t v15 = *__error();
        uint64_t v17 = v13;
        goto LABEL_15;
      }
    }

    if (a4)
    {
      int v16 = -1;
LABEL_11:
      uint64_t v15 = 0LL;
      a1[166] = (_DWORD)v13;
      a1[167] = v14;
      a1[168] = v16;
      return v15;
    }

    int v16 = dup(v8);
    if (v16 != -1) {
      goto LABEL_11;
    }
    uint64_t v15 = *__error();
    sub_100036D70(v13);
    if ((_DWORD)v14 == -1) {
      return v15;
    }
    uint64_t v17 = (int *)v14;
LABEL_15:
    sub_100036D70(v17);
    return v15;
  }

  return *__error();
}

void *sub_10001AF8C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (void *)a1;
  if (*(_DWORD *)(a1 + 1128))
  {
    sub_10001A4D8(a1, 5, "Abandoning PID %d and its process group", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 1128));
    sub_1000167B0(v8);
    *(void *)((char *)v8 + 1164) |= 0x2000000000uLL;
    sub_10001B024((uint64_t)v8, 1);
    uint64_t v9 = v8[169];
    sub_10001685C(v8);
    if ((v9 & 0x10000000) != 0) {
      return 0LL;
    }
  }

  return v8;
}

void sub_10001B024(uint64_t a1, char a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 1128);
  __int128 v156 = 0uLL;
  *(void *)&__int128 v157 = 0LL;
  uint64_t v5 = sub_10003A628(v4, (uint64_t)&v156);
  if ((_DWORD)v5) {
    __int16 v6 = -1;
  }
  else {
    __int16 v6 = WORD2(v156);
  }
  if ((_DWORD)v5)
  {
    int v7 = *(_DWORD *)(a1 + 1128);
    xpc_strerror(v5);
    sub_10001A4D8(a1, 4, "failed to query memory status priority for PID %d: %s (%d)", v8, v9, v10, v11, v12, v7);
  }

  if ((a2 & 1) == 0 && (*(void *)(a1 + 1352) & 0x10000) == 0)
  {
    int v13 = killpg(*(_DWORD *)(a1 + 1128), 15);
    if (v13)
    {
      int v14 = v13;
      if (*__error() != 3)
      {
        uint64_t v15 = __error();
        if (v14 == -1 && *v15 != 1) {
          sub_100047650(a1);
        }
      }
    }
  }

  if ((*(_BYTE *)(a1 + 1168) & 0x20) != 0)
  {
    sub_10003DAC0(a1 + 1176);
    LODWORD(v19) = 0;
    LODWORD(v18) = 0;
    uint64_t v17 = 0LL;
  }

  else
  {
    __int128 v183 = 0u;
    __int128 v184 = 0u;
    __int128 v181 = 0u;
    __int128 v182 = 0u;
    __int128 v179 = 0u;
    __int128 v180 = 0u;
    __int128 v177 = 0u;
    __int128 v178 = 0u;
    __int128 v175 = 0u;
    __int128 v176 = 0u;
    __int128 v173 = 0u;
    __int128 v174 = 0u;
    __int128 v171 = 0u;
    __int128 v172 = 0u;
    __int128 v169 = 0u;
    __int128 v170 = 0u;
    __int128 v167 = 0u;
    __int128 v168 = 0u;
    __int128 v165 = 0u;
    __int128 v166 = 0u;
    __int128 v163 = 0u;
    __int128 v164 = 0u;
    __int128 v161 = 0u;
    __int128 v162 = 0u;
    __int128 v159 = 0u;
    __int128 v160 = 0u;
    __int128 v157 = 0u;
    __int128 v158 = 0u;
    __int128 v156 = 0u;
    int v16 = (__int128 *)(a1 + 1176);
    uint64_t v17 = sub_10003D3B4(a1 + 1176, *(_DWORD *)(a1 + 1128), (uint64_t)&v156);
    uint64_t v18 = *((void *)&v173 + 1) >> 10;
    unint64_t v19 = (unint64_t)v171 >> 10;
    if ((sub_100021F64(a1) & 1) == 0)
    {
      uint64_t v25 = sub_100020AC4(a1);
      uint64_t v26 = v25 ? v25 : a1 + 1016;
      if (v26 != a1 + 1016 && (__int128 *)(v26 + 32) != v16 && *(void *)(a1 + 1208) > *(void *)(v26 + 64))
      {
        __int128 v27 = *v16;
        __int128 v28 = *(_OWORD *)(a1 + 1192);
        __int128 v29 = *(_OWORD *)(a1 + 1208);
        *(void *)(v26 + 80) = *(void *)(a1 + 1224);
        *(_OWORD *)(v26 + 48) = v28;
        *(_OWORD *)(v26 + 64) = v29;
        *(_OWORD *)(v26 + 32) = v27;
      }
    }
  }

  int v30 = *(_DWORD *)(a1 + 1176);
  if (v30 == 2)
  {
    sub_10001A4D8(a1, 3, "wait4() failed", v20, v21, v22, v23, v24, v148);
  }

  else if (!v30)
  {
    sub_100046EB4();
  }

  uint64_t v31 = (uint64_t *)(a1 + 1164);
  if ((*(_BYTE *)(a1 + 1168) & 2) == 0)
  {
    if (*(_DWORD *)(a1 + 1176) == 1)
    {
      uint64_t v32 = "abandoned xpcproxy before exec";
      uint64_t v33 = a1;
      int v34 = 4;
    }

    else
    {
      if (sub_10003DA48(a1 + 1176))
      {
        int v35 = sub_10003DA74((_DWORD *)(a1 + 1176));
        char v36 = v35;
        if (v35 != 78) {
          sub_10001A4D8(a1, 4, "xpcproxy could not exec: %d: %s", v20, v21, v22, v23, v24, v35);
        }
        char v148 = v36;
        uint64_t v32 = "xpcproxy exited due to exit(%d)";
      }

      else
      {
        char v148 = (char)v17;
        uint64_t v32 = "xpcproxy exited due to %s";
      }

      uint64_t v33 = a1;
      int v34 = 5;
    }

    sub_10001A4D8(v33, v34, v32, v20, v21, v22, v23, v24, v148);
  }

  if (sub_10003DADC(a1 + 1176)) {
    sub_10001A4D8( a1,  4,  "removing service since it exited with consistent failure - %s",  v37,  v38,  v39,  v40,  v41,  (char)v17);
  }
  sub_10000E638(570425428LL, *(int *)(a1 + 1128));
  char v42 = (void **)sub_10000D8E8(0x80uLL);
  if (sub_10003DA48(a1 + 1176))
  {
    char v149 = sub_10003DA74((_DWORD *)(a1 + 1176));
    sub_10000D960((uint64_t)v42, "exited due to exit(%d)", v43, v44, v45, v46, v47, v48, v149);
  }

  else if (sub_10003DB1C((_DWORD *)(a1 + 1176)))
  {
    sub_10000D960((uint64_t)v42, "exited due to %s", v49, v50, v51, v52, v53, v54, (char)v17);
  }

  else
  {
    int v55 = *(_DWORD *)(a1 + 1180);
    if (v55) {
      sub_10000D960( (uint64_t)v42,  "exited with exit reason (namespace: %d code: 0x%llx) - %s",  v49,  v50,  v51,  v52,  v53,  v54,  v55);
    }
  }

  uint64_t v56 = sub_10002B0DC(*(void *)(a1 + 248));
  if (v56) {
    sub_10000D960((uint64_t)v42, " during %s", v57, v58, v59, v60, v61, v62, (char)v56);
  }
  unint64_t v63 = sub_10003DAAC(a1 + 1176);
  sub_10000D960((uint64_t)v42, ", ran for %qums", v64, v65, v66, v67, v68, v69, v63 / 0xF4240);
  sub_10001A4D8(a1, 5, "%s", v70, v71, v72, v73, v74, (char)*v42);
  sub_10000D938(v42);
  free(v17);
  if (*(void *)(a1 + 824))
  {
    sub_100016C74(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 824));
    dispatch_release(*(dispatch_object_t *)(a1 + 824));
    *(void *)(a1 + 824) = 0LL;
  }

  if (*(void *)(a1 + 832))
  {
    sub_100016C74(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 832));
    dispatch_release(*(dispatch_object_t *)(a1 + 832));
    *(void *)(a1 + 832) = 0LL;
  }

  if ((*(_BYTE *)(a1 + 1356) & 4) != 0)
  {
    if (sub_10003DC4C((_DWORD *)(a1 + 1176))) {
      sub_10001DA98(a1, v80, v86, v81, v82, v83, v84, v85);
    }
    int v87 = *(void **)(a1 + 136);
    if (v87)
    {
      do
      {
        uint64_t v88 = (void *)v87[2];
        sub_100035ECC(v87);
        sub_10001685C(v87);
        int v87 = v88;
      }

      while (v88);
    }
  }

  uint64_t v89 = *v31;
  if ((*v31 & 0x200000000LL) == 0)
  {
    if (byte_10006A9B2)
    {
      nullsub_23("xpcproxy exited before exec", v80);
      LOBYTE(v89) = *(_BYTE *)v31;
    }

    if ((_BYTE)v89)
    {
      uint64_t v90 = 89LL;
    }

    else if (sub_10003DCC0(a1 + 1176))
    {
      uint64_t v90 = 80LL;
    }

    else if (sub_10003DCEC((_DWORD *)(a1 + 1176)))
    {
      uint64_t v90 = 162LL;
    }

    else
    {
      uint64_t v90 = 153LL;
    }

    sub_100021F98(a1, v90, 0LL, v81, v82, v83, v84, v85, v150);
  }

  if ((*(_BYTE *)(a1 + 1354) & 0x10) != 0)
  {
    sub_10001A4D8(a1, 5, "service only configured to run once, removing", v81, v82, v83, v84, v85, v150);
    *(_DWORD *)(a1 + 368) |= 0x10u;
  }

  else
  {
    sub_10003DADC(a1 + 1176);
  }

  if (sub_10003DBAC(a1 + 1176))
  {
    uint64_t v91 = sub_100020AC4(a1);
    if (v91) {
      uint64_t v92 = v91;
    }
    else {
      uint64_t v92 = a1 + 1016;
    }
    ++*(_DWORD *)(v92 + 4);
    uint64_t v93 = sub_100020AC4(a1);
    if (v93) {
      uint64_t v94 = v93;
    }
    else {
      uint64_t v94 = a1 + 1016;
    }
    int v95 = *(_DWORD *)(v94 + 4);
    sub_100020AC4(a1);
    sub_10001A4D8(a1, 5, "service has crashed %u times in a row (last was%s dirty)", v96, v97, v98, v99, v100, v95);
    sub_10001A4D8(a1, 5, "service has crashed into the shared cache area", v101, v102, v103, v104, v105, v151);
    uint64_t v106 = (_BYTE *)sub_100020AC4(a1);
    uint64_t v112 = *(void *)(a1 + 256);
    if (v106)
    {
      if (!v112)
      {
LABEL_92:
        uint64_t v120 = sub_100020AC4(a1);
        if ((*(_BYTE *)(a1 + 1358) & 0x10) == 0)
        {
          if (v120) {
            uint64_t v121 = (_BYTE *)v120;
          }
          else {
            uint64_t v121 = (_BYTE *)(a1 + 1016);
          }
          *uint64_t v121 = 1;
        }

        goto LABEL_97;
      }
    }

    else
    {
      if (!v112) {
        goto LABEL_92;
      }
      uint64_t v106 = (_BYTE *)(v112 + 1016);
    }

    if ((*(_BYTE *)(v112 + 1358) & 0x10) == 0)
    {
      *uint64_t v106 = 1;
      sub_10001A4D8( a1,  5,  "recorded reslide request for this instance in the original service",  v107,  v108,  v109,  v110,  v111,  v152);
    }

    goto LABEL_92;
  }

  if (sub_100021F64(a1))
  {
    sub_10001A4D8(a1, 5, "skipping successive crash reset", v113, v114, v115, v116, v117, v150);
  }

  else
  {
    uint64_t v118 = sub_100020AC4(a1);
    uint64_t v119 = a1 + 1016;
    if (v118) {
      uint64_t v119 = v118;
    }
    *(_DWORD *)(v119 + 4) = 0;
  }

LABEL_97:
  for (uint64_t i = 664LL; i != 676; i += 4LL)
  {
    size_t v123 = (int *)*(unsigned int *)(a1 + i);
    if ((_DWORD)v123 != -1)
    {
      sub_100036D70(v123);
      *(_DWORD *)(a1 + i) = -1;
    }
  }

  sub_100020C0C(a1, 8);
  if (*(_BYTE *)(a1 + 424) != 8) {
    sub_100046EB4();
  }
  if (sub_10003DC4C((_DWORD *)(a1 + 1176)) && !sub_10003DC64(a1 + 1176))
  {
    if (!*(void *)(a1 + 952)) {
      *(void *)(a1 + 952) = sub_10001A0BC();
    }
    __uint64_t v124 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    sub_10001A10C(*(void **)(a1 + 952), v124 / 0xF4240);
  }

  if (*(_BYTE *)(a1 + 424) != 8) {
    sub_100046EB4();
  }
  unsigned int v153 = v19;
  unsigned int v154 = v18;
  uint64_t v125 = *(unsigned int *)(a1 + 1128);
  uint64_t v126 = *v31;
  if (*(void *)(a1 + 256)) {
    uint64_t v127 = *(void *)(a1 + 256);
  }
  else {
    uint64_t v127 = a1;
  }
  uint64_t v128 = *(void *)(a1 + 952);
  char v155 = (unint64_t *)(a1 + 1164);
  if (v128 && (int v129 = sub_10001A114(v128)) != 0)
  {
    __int16 v130 = v6;
    int v131 = sub_10001A11C(*(void *)(a1 + 952), v129 - 1);
  }

  else
  {
    __int16 v130 = v6;
    int v131 = -1;
  }

  uint64_t v132 = (const char *)(v127 + 1360);
  if (sub_10003DA48(a1 + 1176))
  {
    uint64_t v133 = 0LL;
    uint64_t v134 = (int)sub_10003DA74((_DWORD *)(a1 + 1176));
  }

  else
  {
    uint64_t v133 = *(unsigned int *)(a1 + 1180);
    uint64_t v134 = *(void *)(a1 + 1184);
  }

  __uint64_t v135 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  uint64_t v136 = sub_100001384(v125);
  if (!v136) {
    sub_10003AB08(4, "No spawn timestamp found; service=%s, pid=%d", v132, v125);
  }
  *(void *)&__int128 v156 = _NSConcreteStackBlock;
  *(void *)&__int128 v157 = sub_100022094;
  *((void *)&v157 + 1) = &unk_100064540;
  *((void *)&v156 + 1) = 0x40000000LL;
  *((void *)&v160 + 1) = __PAIR64__(v131, v125);
  *(void *)&__int128 v158 = v132;
  *((void *)&v158 + 1) = v136;
  *(void *)&__int128 v159 = v135 / 0xF4240;
  *((void *)&v159 + 1) = v133;
  *(void *)&__int128 v160 = v134;
  *(void *)&__int128 v161 = __PAIR64__(v154, v153);
  DWORD2(v161) = v126 >> 8;
  WORD6(v161) = v130;
  sub_100001548((uint64_t)&v156);
  sub_1000167B0((void *)a1);
  sub_10001A394(a1, 5LL, 0LL);
  free(*(void **)(a1 + 1112));
  *(void *)(a1 + 1112) = 0LL;
  sub_100020C0C(a1, 0);
  *(_DWORD *)(a1 + 1128) = 0;
  *(_DWORD *)(a1 + 1136) = 16;
  uint64_t v137 = *(dispatch_source_s **)(a1 + 1144);
  if (v137)
  {
    dispatch_source_cancel(v137);
    dispatch_release(*(dispatch_object_t *)(a1 + 1144));
    *(void *)(a1 + 1144) = 0LL;
  }

  if (*(void *)(a1 + 1152))
  {
    sub_100016C74(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 1152));
    dispatch_release(*(dispatch_object_t *)(a1 + 1152));
    *(void *)(a1 + 1152) = 0LL;
  }

  unint64_t v138 = *v155;
  uint64_t v139 = *(void *)(a1 + 24);
  *(_DWORD *)(a1 + 1160) = 0;
  *char v155 = v138 & 0xFFFFFE0000000000LL;
  if (v139) {
    *(void *)(v139 + 32) = *(void *)(a1 + 32);
  }
  **(void **)(a1 + 32) = v139;
  *(void *)(a1 + 24) = -1LL;
  *(void *)(a1 + 32) = -1LL;
  if ((*(_BYTE *)(a1 + 368) & 0x10) == 0 && (*(_BYTE *)(a1 + 1354) & 4) == 0)
  {
    uint64_t v140 = sub_10001ABF4(a1);
    if ((_DWORD)v140)
    {
      uint64_t v141 = sub_10001A53C(a1, v140);
      if ((_DWORD)v141)
      {
        char v142 = v141;
        if ((_DWORD)v141 != 36 && (_DWORD)v141 != 124)
        {
          xpc_strerror(v141);
          sub_10001A4D8(a1, 4, "Failed to respawn: %d: %s", v143, v144, v145, v146, v147, v142);
        }
      }
    }
  }

  if ((*(_BYTE *)(a1 + 368) & 0x10) == 0 && (*(_BYTE *)(a1 + 1354) & 4) != 0) {
    sub_100020C0C(a1, 1);
  }
  sub_10001685C((void *)a1);
}

void sub_10001B9F8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int data = dispatch_source_get_data(*(dispatch_source_t *)(*a1 + 1144));
  int v3 = data;
  if ((data & 0x40000000) != 0)
  {
    ++*(_WORD *)(v1 + 1160);
    if ((data & 0x20000000) == 0)
    {
LABEL_3:
      if ((data & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      sub_10001B024(v1, 0);
      return;
    }
  }

  else if ((data & 0x20000000) == 0)
  {
    goto LABEL_3;
  }

  sub_10001BA5C(v1);
  if (v3 < 0) {
    goto LABEL_7;
  }
}

void sub_10001BA5C(uint64_t a1)
{
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v21 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(buffer, 0, sizeof(buffer));
  if (sub_100039954(*(_DWORD *)(a1 + 1128), buffer))
  {
    _os_assumes_log_ctx(sub_10001C1B0, a1);
    if ((*(_BYTE *)(a1 + 1168) & 2) != 0) {
      goto LABEL_15;
    }
LABEL_3:
    sub_100020C0C(a1, 4);
    *(void *)(a1 + 1164) |= 0x200000000uLL;
    if ((*(_BYTE *)(a1 + 1356) & 4) == 0) {
      goto LABEL_14;
    }
    if (byte_10006A9F0)
    {
      unsigned int v7 = *(_DWORD *)(a1 + 844);
      if (v7)
      {
        dispatch_time_t v8 = dispatch_time(0LL, 1000000000LL * v7);
LABEL_13:
        uint64_t v9 = (dispatch_queue_s *)sub_100011938();
        *(void *)(a1 + 832) = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  v9);
        sub_100016C50(a1);
        dispatch_set_context(*(dispatch_object_t *)(a1 + 832), (void *)a1);
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 832), v8, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 832), (dispatch_function_t)sub_1000220E0);
        dispatch_activate(*(dispatch_object_t *)(a1 + 832));
LABEL_14:
        sub_10001A394(a1, 4LL, 0LL);
        sub_100021B6C(a1);
        char v10 = sub_10001E3C0(a1);
        uint64_t v11 = sub_10002089C(*(_DWORD *)(a1 + 1136));
        uint64_t v12 = sub_100012884("%s", v11);
        sub_10001A4D8(a1, 5, "Successfully spawned %s[%d] because %s", v13, v14, v15, v16, v17, v10);
        free(v12);
        goto LABEL_15;
      }

      sub_10001A4D8(a1, 4, "Skipping extension launch watchdog", v2, v3, v4, v5, v6, v18);
    }

    dispatch_time_t v8 = -1LL;
    goto LABEL_13;
  }

  *(void *)(a1 + 1120) = *((void *)&v21 + 1);
  if ((*(_BYTE *)(a1 + 1168) & 2) == 0) {
    goto LABEL_3;
  }
  free(*(void **)(a1 + 1112));
  *(void *)(a1 + 1112) = sub_1000126A0((const char *)v20);
LABEL_15:
  ++*(_WORD *)(a1 + 1162);
}

uint64_t sub_10001BC88( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v16 = dyld_image_header_containing_address(v9);
  int v17 = v16;
  if (!v16)
  {
    uuid_clear(uu);
    if (!a5) {
      goto LABEL_3;
    }
LABEL_5:
    sub_100039448("Cannot setup an event for proxyless spawns!");
  }

  _dyld_get_image_uuid(v16, uu);
  if (a5) {
    goto LABEL_5;
  }
LABEL_3:
  v19[0] = 0LL;
  v19[1] = &a9;
  vasprintf(v19, a6, &a9);
  sub_10001BD94(*(void *)(a1 + 1256), v9 - v17, a4, uu, (int)a2, a3, (char)v19[0]);
  free(v19[0]);
  return a2;
}

void sub_10001BD94(uint64_t a1, int a2, int a3, unsigned __int8 *uu, uint64_t a5, uint64_t a6, char a7)
{
  if (a5 <= 85)
  {
    if (a5 > 79)
    {
      if (a5 == 80)
      {
        int v17 = "FairPlay decryption failed on binary.";
      }

      else
      {
        if (a5 != 85) {
          goto LABEL_46;
        }
        int v17 = "Program specified by service is malformed.";
      }
    }

    else
    {
      if (a5 != 8)
      {
        if (a5 == 32)
        {
          int v16 = *(_DWORD *)(a1 + 676);
          if ((v16 || (v27 = *(void *)(a1 + 256)) != 0 && (int v16 = *(_DWORD *)(v27 + 676)) != 0) && v16 != -1)
          {
            int v17 = "Service could not notify controller.";
LABEL_44:
            uint64_t v28 = a1;
            int v29 = 4;
            goto LABEL_45;
          }
        }

        goto LABEL_46;
      }

      int v17 = "Program specified by service is not a Mach-O executable file.";
    }

LABEL_42:
    uint64_t v28 = a1;
    int v29 = 3;
LABEL_45:
    sub_10001A4D8(v28, v29, v17, v11, v12, v13, v14, v15, (char)v41);
    goto LABEL_46;
  }

  if ((unint64_t)(a5 - 114) < 2)
  {
    int v18 = *(_DWORD *)(*(void *)(a1 + 248) + 56LL);
    xpc_strerror(a6);
    LOBYTE(v41) = a6;
    if (v18) {
      int v17 = "Could not find uid associated with service: %d: %s %u";
    }
    else {
      int v17 = "Could not find user/group associated with service: %d: %s %s/%s";
    }
    goto LABEL_44;
  }

  if (a5 == 86)
  {
    uint64_t v19 = *(void *)(a1 + 880);
    if (v19)
    {
      memset(v42, 0, sizeof(v42));
      if (xpc_binprefs_count(v19))
      {
        unsigned int v20 = 0;
        __int128 v21 = (char *)v42;
        size_t v22 = 128LL;
        do
        {
          int v23 = xpc_binprefs_cpu_type(v19, v20);
          if (v22 < 2)
          {
            size_t v26 = 0LL;
          }

          else
          {
            uint64_t v24 = "(invalid)";
            if ((v23 & 0xFEFFFFFF) - 1 <= 0x11)
            {
              uint64_t v25 = &off_100064560[v23 & 0xFEFFFFFF];
              if ((v23 & 0x1000000) == 0) {
                uint64_t v25 = &off_1000645F8[v23];
              }
              uint64_t v24 = *v25;
            }

            size_t v26 = snprintf(v21, v22, "%u:%s ", v23, v24);
            if (v22 <= v26) {
              size_t v26 = v22 - 1;
            }
          }

          v21 += v26;
          v22 -= v26;
          ++v20;
        }

        while (v20 < xpc_binprefs_count(v19));
      }

      uint64_t v41 = v42;
      int v17 = "Program specified by service does not contain one of the requested architectures: %s";
    }

    else
    {
      int v17 = "Program specified by service does not contain any valid architectures for this system.";
    }

    goto LABEL_42;
  }

  if (a5 == 111)
  {
    if ((int)a6 >= 1)
    {
      if ((_DWORD)a6 == 75)
      {
        int v17 = "LaunchServices returned a bundle URL that does not match with the LoginItem's known association.";
      }

      else
      {
        xpc_strerror(a6);
        sub_10001A098(a1);
        LOBYTE(v41) = a6;
        int v17 = "Could not find and/or execute program specified by service: %d: %s: %s";
      }

      goto LABEL_44;
    }

    if ((a6 & 0x80000000) != 0)
    {
      LOBYTE(v41) = a6;
      sub_10001A098(a1);
      int v17 = "Could not resolve CFBundleIdentifier specified by service: %d: %s";
      goto LABEL_44;
    }
  }

      dispatch_time_t v8 = 135LL;
LABEL_43:
      if (xpc_dictionary_get_uint64(a3, "ingsk"))
      {
        if (*((_DWORD *)v9 + 74)) {
          return 135LL;
        }
        else {
          return v8;
        }
      }

      return v8;
    default:
      goto LABEL_43;
  }

LABEL_46:
  xpc_strerror(a5);
  sub_10001A4D8(a1, 3, "Service could not initialize: %s, error 0x%llx - %s", v30, v31, v32, v33, v34, a7);
  char v35 = sub_10000E248();
  sub_10001A4D8(a1, 3, "initialization failure: %s: %s + %llu [%llu][%s]: 0x%llx", v36, v37, v38, v39, v40, v35);
}

          if ((_DWORD)v28) {
            goto LABEL_47;
          }
          char v35 = a4 & 0x100;
          uint64_t v36 = v16;
LABEL_50:
          if (*(void *)(v36 + 72)) {
            int v16 = *(void *)(v36 + 72);
          }
          else {
            int v16 = v36;
          }
          if (v35)
          {
            char v42 = sub_10001CB68(*(_DWORD *)(a7 + 20));
            if (!v42)
            {
              sub_10002587C( v68,  5,  "Unable to find managed service for pid %d. Trying unmanaged services",  v37,  v38,  v39,  v40,  v41,  *(_DWORD *)(a7 + 20));
              char v42 = sub_100030804(&v68, *(_DWORD *)(a7 + 20));
            }

            uint64_t v43 = sub_10003FDE0(v16);
            if (!v42 || v42 != v43) {
              goto LABEL_60;
            }
          }

          if ((a4 & 8) != 0 && *(_UNKNOWN **)(a1 + 104) != &unk_1000695B8)
          {
LABEL_60:
            sub_100030624(a1, (uint64_t)a2, a5, a3, a4, a7, 1LL);
            int v16 = 0LL;
            uint64_t v28 = 1LL;
LABEL_61:
            sub_100030624(a1, (uint64_t)a2, a5, a3, a4, a7, v28);
            return v16;
          }

          if ((a4 & 0x200) != 0 || ((a4 >> 7) & 1) == *(unsigned __int8 *)(v16 + 88) >> 7)
          {
            uint64_t v45 = sub_10003FB6C(v16, 1, v17, v18, v19, v20, v21, v22);
            if (v45)
            {
              if (!v16) {
                sub_100046E84(v45, v46, v47, v48);
              }
              uint64_t v28 = 0LL;
            }

            else
            {
              int v16 = 0LL;
              uint64_t v28 = 145LL;
            }
          }

          else
          {
            uint64_t v72 = 0u;
            uint64_t v73 = 0u;
            uint64_t v70 = 0u;
            uint64_t v71 = 0u;
            sub_100039990(a7, (char *)&v70);
            sub_10002587C( a1,  4,  "failed lookup due to non-launching property mismatch: mach_port_name_t name = %s, requestor = %s.%d",  v49,  v50,  v51,  v52,  v53,  (char)a2);
            sub_100039990(a7, (char *)&v70);
            sub_10002587C( a1,  5,  "failed lookup due to non-launching property mismatch: mach_port_name_t name = %s, requestor = %s.%d",  v54,  v55,  v56,  v57,  v58,  (char)a2);
            int v16 = 0LL;
            uint64_t v28 = 3LL;
          }

uint64_t sub_10001C0CC()
{
  return 0LL;
}

void sub_10001C0D4(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v4 = sub_10000E860(1LL, 0LL, object);
    uint64_t v5 = (void *)sub_10000E90C(v4);
    size_t length = xpc_data_get_length(v5);
    unsigned int v7 = sub_100010B00(length);
    if (xpc_data_get_bytes(v5, v7, 0LL, length) != length) {
      _os_assumes_log_ctx(sub_10001C1B0, a1);
    }
    *(void *)(a1 + 616) = v7;
    *(_DWORD *)(a1 + 624) = length;
    *(void *)(a1 + 592) += length;
    xpc_release(v4);
    xpc_release(v5);
  }

uint64_t sub_10001C1B0( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1LL;
}

void *sub_10001C1E4(void *result, xpc_object_t object)
{
  if (object)
  {
    uint64_t v3 = result;
    uint64_t result = xpc_get_type(object);
    if (result == (void *)&_xpc_type_data)
    {
      xpc_object_t v4 = (void *)v3[75];
      if (v4)
      {
        free(v4);
        v3[74] -= *((unsigned int *)v3 + 152);
      }

      size_t length = xpc_data_get_length(object);
      uint64_t v6 = sub_100010B00(length);
      uint64_t result = (void *)xpc_data_get_bytes(object, v6, 0LL, length);
      if (result != (void *)length) {
        uint64_t result = (void *)_os_assumes_log_ctx(sub_10001C1B0, v3);
      }
      v3[75] = v6;
      *((_DWORD *)v3 + 152) = length;
      v3[74] += length;
    }
  }

  return result;
}

char *sub_10001C2A0(uint64_t a1, int a2)
{
  char v10 = (const char **)sub_10000D8E8(0x40uLL);
  uint64_t v11 = *(void *)(a1 + 248);
  if (v11)
  {
    uint64_t v12 = sub_1000258E0(v11, 1);
    sub_10000D960((uint64_t)v10, "%s/", v13, v14, v15, v16, v17, v18, (char)v12);
    free(v12);
  }

  sub_10000D960((uint64_t)v10, "%s", v4, v5, v6, v7, v8, v9, a1 + 80);
  if (a2 == 2)
  {
    int v25 = *(_DWORD *)(a1 + 296);
    if (v25 > 0 || (int v25 = *(_DWORD *)(a1 + 1128), v25 >= 1)) {
      sub_10000D960((uint64_t)v10, " [%d]", v19, v20, v21, v22, v23, v24, v25);
    }
  }

  size_t v26 = sub_10000D930(v10);
  sub_10000D938((void **)v10);
  return v26;
}

_DWORD *sub_10001C380()
{
  return sub_10003DF50(6, (uint64_t)sub_10001C674);
}

uint64_t sub_10001C3AC(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  unsigned int v18 = -1;
  uint64_t v7 = sub_1000221F0(a3, (int *)&v18);
  if (v18 == 36)
  {
    sub_10003E78C(a3, "domain deferral", v8, v9, v10, v11, v12, v13, v17);
    return 0LL;
  }

  uint64_t v14 = v7;
  if (v7)
  {
    if (*(_BYTE *)(v7 + 424) == 2)
    {
      sub_10001A4D8(v7, 5, "Deferring IPC (%d) while service is spawning", v9, v10, v11, v12, v13, a2);
      sub_1000223E0(v14, a3, 1);
      return 0LL;
    }

    uint64_t v16 = sub_10003DF34();
    uint64_t result = 45LL;
    switch(a2)
    {
      case 700:
        uint64_t result = sub_100022444(v14, (uint64_t)v16, a3, a4);
        break;
      case 701:
        uint64_t result = sub_1000226FC(v14, (uint64_t)v16, a3, a4);
        break;
      case 702:
        uint64_t result = sub_1000228C4(v14, (uint64_t)v16, a3, a4);
        break;
      case 703:
        uint64_t result = sub_100022ACC(v14, (uint64_t)v16, a3, a4);
        break;
      case 704:
        return sub_100022D14(v14, (uint64_t)v16, a3, a4);
      case 705:
        uint64_t result = sub_1000231DC(v14, (uint64_t)v16, a3, a4);
        break;
      case 706:
        uint64_t result = sub_1000234B4(v14, (uint64_t)v16, (uint64_t)a3);
        break;
      case 707:
        uint64_t result = sub_100023520(v14, (uint64_t)v16, a3, a4);
        break;
      case 708:
        uint64_t result = sub_1000235F4(v14, (uint64_t)v16, a3, a4);
        break;
      case 710:
        uint64_t result = sub_1000236B4(v14, (uint64_t)v16, a3, a4);
        break;
      case 711:
        uint64_t result = sub_100023788(v14, (uint64_t)v16, a3, a4);
        break;
      case 712:
        uint64_t result = sub_100023880(v14, (uint64_t)v16, a3, a4);
        break;
      case 713:
        uint64_t result = sub_100023940(v14, (uint64_t)v16, a3, a4);
        break;
      case 715:
        uint64_t result = sub_100023B68(v14, (uint64_t)v16, a3, a4);
        break;
      case 716:
        uint64_t result = sub_100023D4C(v14, (uint64_t)v16, a3, a4);
        break;
      case 717:
      case 724:
        return result;
      case 718:
        uint64_t result = sub_100023E24(v14, (uint64_t)v16, a3, a4);
        break;
      case 719:
        uint64_t result = sub_100023A18(v14, (uint64_t)v16, a3, a4);
        break;
      case 720:
        uint64_t result = sub_100023EEC(v14, a3, a4);
        break;
      case 721:
        uint64_t result = sub_100023F5C(v14, v16, a3, a4);
        break;
      case 722:
        uint64_t result = sub_100024044(v14, (uint64_t)v16, a3, a4);
        break;
      case 723:
        uint64_t result = sub_100024154(v14, (uint64_t)v16, a3, a4);
        break;
      case 725:
        uint64_t result = sub_100024204(v14, (uint64_t)v16, a3, a4);
        break;
      default:
        uint64_t result = 33LL;
        break;
    }
  }

  else
  {
    sub_10003E78C(a3, "no service, code = %d", v8, v9, v10, v11, v12, v13, v18);
    uint64_t result = v18;
    if (a2 == 704 && (v18 & 0xFFFFFFFE) == 0x70)
    {
      uint64_t v16 = sub_10003DF34();
      return sub_100022D14(v14, (uint64_t)v16, a3, a4);
    }
  }

  return result;
}

uint64_t sub_10001C674(uint64_t a1, int a2, void *a3, void *a4)
{
  dword_100069E30 = *((_DWORD *)sub_10003DF34() + 5);
  qword_100069E00 = sub_10002A7C8();
  unsigned int v25 = -1;
  uint64_t v7 = sub_1000221F0(a3, (int *)&v25);
  uint64_t v8 = v25;
  if (v25 == 36) {
    return 0LL;
  }
  uint64_t v9 = (void *)v7;
  if (a2 == 301 && v25 == 135)
  {
    uint64_t v9 = &unk_100069D08;
  }

  else
  {
    if (!v7) {
      return v8;
    }
    uint64_t v8 = 45LL;
    if (a2 != 301) {
      return 33LL;
    }
  }

  uint64_t v10 = v9[31];
  uint64_t v8 = 45LL;
  xpc_object_t v11 = 0LL;
  switch(xpc_dictionary_get_uint64(a3, "outgsk"))
  {
    case 0uLL:
      goto LABEL_54;
    case 1uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      int v12 = *((_DWORD *)v9 + 294);
      if (v12 == 2)
      {
        int64_t v13 = 11LL;
      }

      else if (v12)
      {
        int64_t v13 = *((int *)v9 + 301);
      }

      else
      {
LABEL_18:
        int64_t v13 = 0LL;
      }

      goto LABEL_52;
    case 3uLL:
      int64_t v13 = getuid();
      goto LABEL_52;
    case 4uLL:
      int64_t v13 = getpid();
      goto LABEL_52;
    case 6uLL:
      if ((_UNKNOWN *)sub_10002A994(v10) != &unk_1000695B8)
      {
        uint64_t v8 = 125LL;
        goto LABEL_43;
      }

      xpc_object_t v16 = xpc_string_create("System");
      goto LABEL_53;
    case 7uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      int64_t v13 = (v9[169] >> 2) & 1LL;
      goto LABEL_52;
    case 8uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      int64_t v13 = *((unsigned int *)v9 + 214);
      goto LABEL_52;
    case 9uLL:
      goto LABEL_18;
    case 0xAuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      int64_t v13 = *((unsigned int *)v9 + 202);
      goto LABEL_52;
    case 0xBuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      xpc_object_t v11 = xpc_dictionary_create(0LL, 0LL, 0LL);
      for (uint64_t i = (const char *)v9[123]; i; uint64_t i = *(const char **)i)
      {
        uint64_t v15 = strrchr(i + 32, 61);
        *uint64_t v15 = 0;
        xpc_dictionary_set_string(v11, i + 32, v15 + 1);
        *uint64_t v15 = 61;
      }

      goto LABEL_54;
    case 0xCuLL:
    case 0x18uLL:
    case 0x1AuLL:
      uint64_t v8 = 126LL;
      goto LABEL_43;
    case 0xDuLL:
      int64_t v13 = 32LL;
      goto LABEL_52;
    case 0xEuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      if ((*((_BYTE *)v9 + 1356) & 1) == 0)
      {
        uint64_t v8 = 3LL;
        goto LABEL_43;
      }

      int64_t v13 = *((unsigned __int16 *)v9 + 396);
      goto LABEL_52;
    case 0xFuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      int64_t v13 = (v9[169] >> 16) & 1LL;
      goto LABEL_52;
    case 0x10uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_42;
      }
      int64_t v13 = (v9[169] >> 8) & 1LL;
      goto LABEL_52;
    case 0x12uLL:
      if (!*((_DWORD *)v9 + 74))
      {
        int64_t v13 = (v9[169] >> 11) & 1LL;
LABEL_52:
        xpc_object_t v16 = xpc_int64_create(v13);
LABEL_53:
        xpc_object_t v11 = v16;
LABEL_54:
        uunint64_t int64 = xpc_dictionary_get_uint64(a3, "ingsk");
        if (uint64)
        {
          if (*((_DWORD *)v9 + 74))
          {
            uint64_t v8 = 135LL;
LABEL_57:
            if (v11) {
              xpc_release(v11);
            }
            return v8;
          }

          uint64_t v18 = uint64;
          xpc_object_t value = xpc_dictionary_get_value(a3, "in");
          if (value)
          {
            uint64_t v8 = 45LL;
            uint64_t v20 = value;
            switch(v18)
            {
              case 2uLL:
              case 0xDuLL:
                break;
              case 7uLL:
                unint64_t v21 = v9[169] & 0xFFFFFFFFFFFFFFFBLL | (4LL * (xpc_int64_get_value(v20) != 0));
                goto LABEL_74;
              case 8uLL:
                if (*((_DWORD *)v9 + 282))
                {
                  if (v9[106]) {
                    sub_100046EB4();
                  }
                  *((_DWORD *)v9 + 214) = xpc_int64_get_value(v20);
                }

                break;
              case 0xAuLL:
                *((_DWORD *)v9 + 202) = xpc_int64_get_value(v20);
                break;
              case 0xEuLL:
                v9[169] |= (unint64_t)&_mh_execute_header;
                *((_WORD *)v9 + 396) = xpc_int64_get_value(v20);
                break;
              case 0xFuLL:
                if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
                {
LABEL_75:
                  uint64_t v8 = 22LL;
                  goto LABEL_57;
                }

                unint64_t v21 = v9[169] & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(xpc_int64_get_value(v20) != 0) << 16);
LABEL_74:
                v9[169] = v21;
                break;
              case 0x10uLL:
                break;
              case 0x11uLL:
              case 0x12uLL:
              case 0x16uLL:
              case 0x17uLL:
                uint64_t v8 = 126LL;
                goto LABEL_57;
              default:
                goto LABEL_57;
            }
          }
        }

        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_object_t v23 = reply;
        if (v11)
        {
          xpc_dictionary_set_value(reply, "out", v11);
          xpc_release(v11);
        }

        uint64_t v8 = 0LL;
        *a4 = v23;
        return v8;
      }

uint64_t sub_10001CB2C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return (*(unsigned __int8 *)(a1 + 1357) >> 1) & 1;
}

uint64_t sub_10001CB68(int a1)
{
  uint64_t result = sub_10001CBA8(a1);
  if (!result)
  {
    uint64_t result = sub_10001CC20(a1);
    if (result) {
      return sub_10001CBA8(a1);
    }
  }

  return result;
}

uint64_t sub_10001CBA8(int a1)
{
  int v2 = a1;
  for (uint64_t result = qword_10006A258[sub_100012B1C(&v2, 4LL) % 0x35uLL]; result; uint64_t result = *(void *)(result + 24))
  {
    if (*(_DWORD *)(result + 1128) == v2) {
      break;
    }
  }

  return result;
}

uint64_t sub_10001CC20(int a1)
{
  if (!a1) {
    return 0LL;
  }
  __dmb(9u);
  uint64_t v7 = qword_100069D00;
  if (!qword_100069D00) {
    return 0LL;
  }
  while (*(_DWORD *)(v7 + 1132) != a1)
  {
    uint64_t v7 = *(void *)(v7 + 24);
    if (!v7) {
      return 0LL;
    }
  }

  if (*(_BYTE *)(v7 + 424) != 2) {
    sub_100046EB4();
  }
  sub_10001A4D8(v7, 5, "speculatively converting service to spawned, pid=%d", v2, v3, v4, v5, v6, a1);
  return sub_10001CCBC(v7, a1, 0LL, 1LL, v9, v10, v11, v12);
}

uint64_t sub_10001CCBC( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v11 = a1;
  if ((*(_BYTE *)(a1 + 1168) & 0x80) != 0) {
    uint64_t v12 = "xpcproxy";
  }
  else {
    uint64_t v12 = "service";
  }
  if (*(_BYTE *)(a1 + 424) != 2)
  {
    sub_10001A4D8(a1, 5, "spawn completed after a speculative conversion", a4, a5, a6, a7, a8, v96);
    if ((_DWORD)a3) {
      sub_100039448("speculatively converted service to spawned, but spawn failed with error %d", a3);
    }
    if (*(_DWORD *)(v11 + 1132) != a2) {
      sub_100046EB4();
    }
    int v23 = *(_DWORD *)(v11 + 1128);
    if (v23 && v23 != a2) {
      sub_100039448( "speculatively converted service to spawned with PID %d, but the PID is %d",  *(_DWORD *)(v11 + 1128),  a2);
    }
    if (v8) {
      sub_100046EB4();
    }
    sub_10001A394(v11, 8LL, 0LL);
    return v11;
  }

  uint64_t v13 = *(int *)(a1 + 1136);
  sub_100011968();
  uint64_t v20 = (void *)(v11 + 24);
  uint64_t v19 = *(void *)(v11 + 24);
  if (v19) {
    *(void *)(v19 + 32) = *(void *)(v11 + 32);
  }
  **(void **)(v11 + 32) = v19;
  *uint64_t v20 = -1LL;
  *(void *)(v11 + 32) = -1LL;
  if ((_DWORD)a3)
  {
    if ((*(_BYTE *)(v11 + 1168) & 0x80) != 0)
    {
      char v21 = (char)off_100069A28[0];
      uint64_t v22 = "trampoline";
    }

    else
    {
      char v21 = sub_10001A098(v11);
      uint64_t v22 = "service";
    }

    int v46 = *(_DWORD *)(v11 + 1136);
    if (a3 <= 0xD && ((1 << a3) & 0x2104) != 0)
    {
      uint64_t v47 = *(void *)(v11 + 1352);
      if ((v47 & 0x1000000000000LL) == 0)
      {
        *(void *)(v11 + 1352) = v47 | 0x1000000000000LL;
        strerror(a3);
        sub_10001A4D8( v11,  5,  "Remove ability to use bypass the proxy: spawn failed: %d: %s",  v48,  v49,  v50,  v51,  v52,  a3);
      }
    }

    strerror(a3);
    sub_10001A4D8(v11, 5, "%s spawn failed: %d: %s", v53, v54, v55, v56, v57, (char)v22);
    sub_1000167B0((void *)v11);
    sub_10001A394(v11, 1LL, (int)a3);
    strerror(a3);
    sub_10001A4D8(v11, 3, "Could not spawn process %s: %d: %s", v58, v59, v60, v61, v62, v21);
    if ((*(_BYTE *)(v11 + 1355) & 0x10) == 0)
    {
      sub_10001685C((void *)v11);
      sub_100020C0C(v11, 0);
      if ((*(_BYTE *)(v11 + 1168) & 0x80) != 0)
      {
        if ((*(_DWORD *)(v11 + 368) & 0x10) != 0) {
          sub_100047684(*(_DWORD *)(v11 + 368) & 0x10);
        }
        unsigned int v73 = sub_10001A9FC(v11);
        sub_1000217AC(v11, v73, v46);
      }

      sub_100021F98(v11, a3, 0LL, v68, v69, v70, v71, v72, v98);
      goto LABEL_51;
    }

    sub_10001A4D8(v11, 3, "Removed service on spawn failure", v63, v64, v65, v66, v67, v98);
    sub_100020C0C(v11, 0);
    sub_10001685C((void *)v11);
    return 0LL;
  }

  *(_DWORD *)(v11 + 1128) = a2;
  sub_10001A4D8(v11, 5, "%s spawned with pid %d", v14, v15, v16, v17, v18, (char)v12);
  sub_10000E638(570425348LL, *(int *)(v11 + 1128));
  j__kdebug_trace(570425416LL, *(int *)(v11 + 1128), v13, 0LL, 0LL);
  uint64_t v24 = &qword_10006A258[sub_100012B1C((_BYTE *)(v11 + 1128), 4LL) % 0x35uLL];
  uint64_t v25 = *v24;
  *(void *)(v11 + 24) = *v24;
  if (v25) {
    *(void *)(v25 + 32) = v20;
  }
  *uint64_t v24 = v11;
  *(void *)(v11 + 32) = v24;
  uintptr_t v26 = *(int *)(v11 + 1128);
  uint64_t v27 = (dispatch_queue_s *)sub_100011938();
  dispatch_source_t v28 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v26, 0xE0000000uLL, v27);
  *(void *)(v11 + 1144) = v28;
  int v29 = sub_10001675C((void *)v11, 26LL, (uint64_t)v28, 0LL);
  dispatch_set_context(*(dispatch_object_t *)(v11 + 1144), v29);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v11 + 1144), (dispatch_function_t)sub_10001B9F8);
  dispatch_source_set_registration_handler_f(*(dispatch_source_t *)(v11 + 1144), (dispatch_function_t)sub_1000245CC);
  dispatch_source_set_mandatory_cancel_handler_f(*(void *)(v11 + 1144), sub_100024608);
  dispatch_activate(*(dispatch_object_t *)(v11 + 1144));
  if ((*(_BYTE *)(v11 + 1353) & 0x80) != 0)
  {
    uint64_t v35 = *(void *)(v11 + 192);
    if (!v35)
    {
      uint64_t v74 = "inetd-compatible service with no sockets.";
LABEL_42:
      sub_10001A4D8(v11, 3, v74, v30, v31, v32, v33, v34, v97);
      goto LABEL_43;
    }

    uint64_t v100 = 0LL;
    uint64_t v101 = 0LL;
    uint64_t v99 = 0LL;
    uint64_t v36 = sub_100018F94(v35, &v101, &v100, &v99);
    if ((_DWORD)v36)
    {
      char v40 = v36;
      xpc_strerror(v36);
      sub_10001A4D8(v11, 3, "Could not activate inetd socket: %d: %s", v41, v42, v43, v44, v45, v40);
      goto LABEL_43;
    }

    uint64_t v75 = v101;
    uint64_t v76 = *v101;
    uint64_t v77 = v99;
    if (v99)
    {
      uint64_t v78 = v100;
      while (!*v78++)
      {
        ++v75;
        if (!--v77) {
          goto LABEL_40;
        }
      }

      uint64_t v76 = *v75;
    }

LABEL_40:
    int v80 = sub_10001AE98( (_DWORD *)v11,  *(void *)(v11 + 448),  *(void *)(v11 + 456),  *(void *)(v11 + 464),  v76,  v37,  v38,  v39);
    if (v80)
    {
      char v97 = v80;
      strerror(v80);
      uint64_t v74 = "Could not setup inetd descriptors: %d: %s";
      goto LABEL_42;
    }
  }

LABEL_43:
  sub_10001A394(v11, 1LL, 0LL);
  if (*(_BYTE *)(v11 + 424) != 2) {
    sub_100046EB4();
  }
  sub_100020C0C(v11, 3);
  if (*(_BYTE *)(v11 + 424) != 3) {
    sub_100046EB4();
  }
  uint64_t v81 = *(unsigned int *)(v11 + 1128);
  __uint64_t v82 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  sub_100001284(v81, v82 / 0xF4240);
  if ((*(_BYTE *)(v11 + 1168) & 0x80) == 0) {
    sub_10001BA5C(v11);
  }
  if (v8) {
    sub_10001A394(v11, 7LL, 0LL);
  }
  if ((*(_BYTE *)(v11 + 1169) & 1) != 0)
  {
    sub_10001A4D8(v11, 5, "redriving pending stop", v83, v84, v85, v86, v87, v97);
    uint64_t v88 = sub_10000AD0C();
    sub_10001D4CC(v11, v88, v89, v90, v91, v92, v93, v94);
LABEL_51:
    *(void *)(v11 + 1164) &= ~0x10000000000uLL;
  }

  return v11;
}

    if (a4)
    {
      uint64_t v24 = ccder_sizeof(0xA000000000000010LL, *(void *)(a3 + 16));
      uint64_t v25 = ccder_sizeof(2LL, 1LL);
      if ((ccder_blob_encode_tl(&v32, 0x6000000000000010LL, v25 + v24) & 1) != 0)
      {
        int v29 = 0LL;
        uint64_t v30 = 0LL;
        uint64_t v31 = 0LL;
        uint64_t v6 = (void *)sub_100045664(v27, a2, (uint64_t *)&v29, a5, a6);
        if (v6 != &unk_100065C48) {
          cc_clear(v26, a5);
        }
        return (uint64_t)v6;
      }

      return (uint64_t)&unk_100065C88;
    }
  }

uint64_t sub_10001D218(uint64_t result)
{
  uint64_t v1 = result;
  if (*(_DWORD *)(result + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(result + 296),  (const char *)(result + 1360));
  }
  if (!*(_DWORD *)(result + 1128) && (*(_BYTE *)(result + 368) & 0x10) == 0)
  {
    uint64_t result = sub_10001ABF4(result);
    if ((_DWORD)result) {
      return sub_10001A53C(v1, result);
    }
  }

  return result;
}

uint64_t sub_10001D28C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 424) == 1) {
    sub_10001D2E8(a1, 1);
  }
  uint64_t v4 = sub_100020AC4(a1);
  uint64_t v11 = a1 + 1016;
  if (v4) {
    uint64_t v11 = v4;
  }
  *(_BYTE *)(v11 + 1) = 1;
  return sub_10001D3D8(a1, a2, v5, v6, v7, v8, v9, v10);
}

void sub_10001D2E8(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 424) != 1) {
    sub_100046EB4();
  }
  sub_100020C0C(a1, 0);
  if ((*(_BYTE *)(a1 + 1354) & 4) != 0)
  {
    uint64_t v18 = *(void **)(a1 + 136);
    if (v18)
    {
      do
      {
        uint64_t v19 = (void *)v18[2];
        if (sub_100035EC0((uint64_t)v18))
        {
          sub_100035ECC(v18);
          sub_10001685C(v18);
        }

        uint64_t v18 = v19;
      }

      while (v19);
    }

    if (a2) {
      *(void *)(a1 + 1352) &= ~0x40000uLL;
    }
    uint64_t v17 = "canceling penalty-box spawn";
    goto LABEL_14;
  }

  uint64_t v9 = *(dispatch_source_s **)(a1 + 800);
  if (v9)
  {
    dispatch_source_cancel(v9);
    *(void *)(a1 + 800) = 0LL;
    *(_DWORD *)(a1 + 796) = 0;
    uint64_t v16 = *(dispatch_semaphore_t **)(a1 + 816);
    if (v16)
    {
      sub_100001CA8(v16);
      *(void *)(a1 + 816) = 0LL;
    }

    sub_100021A84(a1, 0, v10, v11, v12, v13, v14, v15);
    uint64_t v17 = "canceling throttled spawn";
LABEL_14:
    sub_10001A4D8(a1, 5, v17, v4, v5, v6, v7, v8, v20);
  }

  sub_10001A394(a1, 1LL, 89LL);
}

uint64_t sub_10001D3D8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  if ((_DWORD)a2 == 11)
  {
    uint64_t v10 = *(void *)(a1 + 1352);
    if ((v10 & 0x40000) == 0) {
      sub_100039448("retry launch on service that was not deferred");
    }
    *(void *)(a1 + 1352) = v10 & 0xFFFFFFFFFFFBFFFFLL;
    sub_10001A4D8(a1, 5, "retry launch", a4, a5, a6, a7, a8, v12);
  }

  else if (*(unsigned __int8 *)(a1 + 424) - 1 <= 1)
  {
    sub_10001A4D8(a1, 5, "launch already in progress", a4, a5, a6, a7, a8, v12);
    return 36LL;
  }

  if ((*(_BYTE *)(a1 + 1354) & 4) != 0)
  {
    sub_10001A4D8(a1, 5, "attempt to launch while in penalty box", a4, a5, a6, a7, a8, v12);
    return 139LL;
  }

  else if (*(_DWORD *)(a1 + 1128))
  {
    return 37LL;
  }

  else
  {
    return sub_10001A53C(a1, a2);
  }

uint64_t sub_10001D4CC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  if ((*(_BYTE *)(a1 + 368) & 0x10) != 0)
  {
    uint64_t v10 = *(void **)(a1 + 144);
    if (v10)
    {
      do
      {
        uint64_t v11 = (void *)v10[2];
        sub_1000359A0((uint64_t)v10);
        sub_10001685C(v10);
        uint64_t v10 = v11;
      }

      while (v11);
    }
  }

  int v12 = *(unsigned __int8 *)(a1 + 424);
  if (v12 == 1)
  {
    sub_10001D2E8(a1, 0);
    return 89LL;
  }

  if (!*(_DWORD *)(a1 + 1128))
  {
    if (v12 == 2)
    {
      sub_10001A4D8(a1, 5, "service spawning, defer stopping", a4, a5, a6, a7, a8, v34);
      if (*(_DWORD *)(a1 + 1128)) {
        sub_100046EB4();
      }
      uint64_t v26 = *(void *)(a1 + 1164);
      *(void *)(a1 + 1164) = v26 | 0x10000000000LL;
      if ((v26 & 0x10000000000LL) != 0) {
        return 37LL;
      }
      else {
        return 36LL;
      }
    }

    else
    {
      sub_10001A4D8(a1, 5, "service not running, not stopping", a4, a5, a6, a7, a8, v34);
      return 37LL;
    }
  }

  if (v12 == 7)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, void))(a1 + 536))(a1, *(void *)(a1 + 568));
    uint64_t v13 = v15;
    if ((_DWORD)v15)
    {
      sub_10001A4D8(a1, 5, "cannot abandon languishing service: %d", v16, v17, v18, v19, v20, v15);
      xpc_strerror(v13);
      sub_10001A4D8(a1, 4, "Cannot abandon languishing service: %d: %s", v21, v22, v23, v24, v25, v13);
    }

    else
    {
      sub_10001A4D8(a1, 5, "abandoning languishing service", v16, v17, v18, v19, v20, v34);
      sub_10001AF8C(a1, v27, v28, v29, v30, v31, v32, v33);
    }

    return v13;
  }

  return sub_10001D678(a1, 0, a2, a4, a5, a6, a7, a8);
}

uint64_t sub_10001D678( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int8 *)(a1 + 424) - 3 >= 2)
  {
    sub_10001A4D8(a1, 5, "service already stopped", a4, a5, a6, a7, a8, v63);
    return 37LL;
  }

  memset(v64, 0, sizeof(v64));
  int v9 = *(_DWORD *)(a1 + 1128);
  if (!v9) {
    sub_100046EB4();
  }
  mach_error_t v12 = sub_10003A5AC(v9, (integer_t *)v64);
  if (v12)
  {
    int v13 = *(_DWORD *)(a1 + 1128);
    mach_error_string(v12);
    sub_10001A4D8(a1, 5, "could not get audit token for service (PID %d): %d: %s", v14, v15, v16, v17, v18, v13);
    unint64_t v19 = dword_100069A3C;
    int v20 = 3;
LABEL_26:
    strerror(v20);
    sub_10001A4D8(a1, 5, "could not terminate service: %d: %s", v31, v32, v33, v34, v35, v20);
    strerror(v20);
    sub_10001A4D8(a1, 3, "could not terminate service: %d: %s", v36, v37, v38, v39, v40, v20);
    if (v19 <= 1) {
      unint64_t v19 = 1LL;
    }
    unint64_t v41 = *(void *)(a1 + 1164) & 0xFFFFFFFFFFFFFF00LL | 9;
    *(void *)(a1 + 1164) = v41;
    goto LABEL_29;
  }

  if (sub_10000AD0C() != a3 && sub_10002986C(*(void *)(a1 + 248), a3) && !sub_1000159D4((_OWORD *)a3, v64, 9LL))
  {
    sub_10001A4D8( a1,  5,  "caller (PID %d) is not allowed to signal target process: %s",  v22,  v23,  v24,  v25,  v26,  *(_DWORD *)(a3 + 20));
    return 1LL;
  }

  uint64_t v27 = (_BYTE *)(a1 + 1164);
  if ((*(_BYTE *)(a1 + 1168) & 2) == 0 || byte_10006A97D)
  {
    int v29 = sub_10003A454(v64);
    if (v29 && v29 != 3) {
      _os_assumes_log(v29);
    }
    if ((*(_BYTE *)(a1 + 1168) & 2) != 0)
    {
      if (!byte_10006A97D) {
        sub_100046EB4();
      }
      uint64_t v30 = "sudden shutdown";
    }

    else
    {
      uint64_t v30 = "aborting trampoline";
    }

    goto LABEL_23;
  }

  if (a2 == 1)
  {
    uint64_t v30 = "force-kill";
LABEL_23:
    int v28 = sub_10002460C(a1, v64, (char)v30);
    goto LABEL_24;
  }

  if (a2 == 2)
  {
    int v28 = sub_10003A3A0(*(unsigned int *)(a1 + 1128), 3u, (uint64_t)"extension check-in timeout", 2LL);
LABEL_24:
    int v20 = v28;
    _BYTE *v27 = 9;
    goto LABEL_25;
  }

  if (a2) {
    sub_100046EB4();
  }
  int v20 = sub_10003A454(v64);
  _BYTE *v27 = 0;
  if (!v20)
  {
    sub_10000E648(570425424LL, *(int *)(a1 + 1128), 0LL);
    char v57 = strsignal(*v27);
    sub_10001A4D8(a1, 5, "signaled service: %s", v58, v59, v60, v61, v62, v57);
  }

uint64_t sub_10001DA70(uint64_t a1)
{
  uint64_t v2 = sub_10000AD0C();
  return sub_10001D4CC(a1, v2, v3, v4, v5, v6, v7, v8);
}

void sub_10001DA98( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  if ((*(_BYTE *)(a1 + 1356) & 0x10) != 0) {
    sub_10001DAE0(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_10001DAE0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0)
    {
      sub_10001A4D8(a1, 5, "draining messages from %s", a4, a5, a6, a7, a8, i - 88);
      sub_100040574(i, v10, v11, v12, v13, v14, v15, v16);
    }
  }

  for (uint64_t j = *(void *)(a1 + 184); j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 0x40) == 0)
    {
      sub_10001A4D8(a1, 5, "draining messages from %s", a4, a5, a6, a7, a8, j - 88);
      sub_100040574(j, v18, v19, v20, v21, v22, v23, v24);
    }
  }

void sub_10001DB8C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 856))
  {
    if (*(void *)(a1 + 848)) {
      sub_100046EB4();
    }
    uint64_t v2 = (dispatch_queue_s *)sub_100011938();
    dispatch_source_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v2);
    *(void *)(a1 + 848) = v3;
    dispatch_set_context(v3, (void *)a1);
    uint64_t v4 = *(dispatch_source_s **)(a1 + 848);
    dispatch_time_t v5 = dispatch_time(0LL, 1000000000LL * *(unsigned int *)(a1 + 856));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 848), (dispatch_function_t)sub_10001DC34);
    dispatch_activate(*(dispatch_object_t *)(a1 + 848));
  }

void sub_10001DC34(uint64_t a1)
{
  uint64_t v2 = sub_10001A53C(a1, 12LL);
  sub_10001A4D8(a1, 5, "interval event: domain response: %d", v3, v4, v5, v6, v7, v2);
  if ((_DWORD)v2 && (_DWORD)v2 != 36 && (_DWORD)v2 != 124)
  {
    xpc_strerror(v2);
    sub_10001A4D8(a1, 3, "Interval spawn of service failed: %d: %s", v8, v9, v10, v11, v12, v2);
  }

void sub_10001DCB0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 856))
  {
    uint64_t v2 = *(dispatch_source_s **)(a1 + 848);
    if (!v2) {
      sub_100046EB4();
    }
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 848));
    *(void *)(a1 + 848) = 0LL;
  }

void sub_10001DCF0(uint64_t a1)
{
  uint64_t v2 = *(dispatch_source_s **)(a1 + 848);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 848));
    *(void *)(a1 + 848) = 0LL;
  }

uint64_t sub_10001DD24(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return a1 + 376;
}

uint64_t sub_10001DD5C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return *(unsigned int *)(a1 + 1128);
}

xpc_object_t sub_10001DD94(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_string(v2, "Label", (const char *)(a1 + 1360));
  xpc_dictionary_set_BOOL(v2, "OnDemand", (*(void *)(a1 + 1352) & 4LL) == 0);
  uint64_t v3 = (void *)sub_10002A994(*(void *)(a1 + 248));
  if (v3 == &unk_1000695B8)
  {
    uint64_t v4 = "System";
  }

  else if (v3 == &unk_100069640)
  {
    uint64_t v4 = "Background";
  }

  else
  {
    if (v3 != &unk_1000696C8) {
      goto LABEL_9;
    }
    uint64_t v4 = "Aqua";
  }

  xpc_dictionary_set_string(v2, "LimitLoadToSessionType", v4);
LABEL_9:
  if (sub_10003DCC0(a1 + 1176))
  {
    int64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  }

  else if (sub_10003DAF8((_DWORD *)(a1 + 1176)))
  {
    int64_t v5 = *(int *)(a1 + 1204);
  }

  else
  {
    int64_t v5 = 0LL;
  }

  xpc_dictionary_set_int64(v2, "LastExitStatus", v5);
  int64_t v6 = *(int *)(a1 + 1128);
  if ((_DWORD)v6) {
    xpc_dictionary_set_int64(v2, "PID", v6);
  }
  uint64_t v7 = *(const char **)(a1 + 448);
  if (v7) {
    xpc_dictionary_set_string(v2, "StandardInPath", v7);
  }
  uint64_t v8 = *(const char **)(a1 + 456);
  if (v8) {
    xpc_dictionary_set_string(v2, "StandardOutPath", v8);
  }
  uint64_t v9 = *(const char **)(a1 + 464);
  if (v9) {
    xpc_dictionary_set_string(v2, "StandardErrorPath", v9);
  }
  uint64_t v10 = *(void *)(a1 + 1352);
  if ((v10 & 0x100) != 0)
  {
    xpc_dictionary_set_BOOL(v2, "EnableTransactions", 1);
    uint64_t v10 = *(void *)(a1 + 1352);
  }

  if ((v10 & 0x4000) != 0)
  {
    xpc_dictionary_set_BOOL(v2, "inetdCompatibility", 1);
    xpc_dictionary_set_BOOL(v2, "Wait", (*(void *)(a1 + 1352) & 0x8000LL) != 0);
  }

  uint64_t v11 = *(void **)(a1 + 640);
  if (v11) {
    xpc_dictionary_set_value(v2, "_AdditionalProperties", v11);
  }
  uint64_t v12 = (const char *)sub_10001A098(a1);
  xpc_dictionary_set_string(v2, "Program", v12);
  if (*(_DWORD *)(a1 + 428))
  {
    xpc_object_t v13 = xpc_array_create(0LL, 0LL);
    if (*(_DWORD *)(a1 + 428))
    {
      unint64_t v14 = 0LL;
      do
        xpc_array_set_string(v13, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(*(void *)(a1 + 432) + 8 * v14++));
      while (v14 < *(unsigned int *)(a1 + 428));
    }

    xpc_dictionary_set_value(v2, "ProgramArguments", v13);
    xpc_release(v13);
  }

  return v2;
}

xpc_object_t sub_10001E010(uint64_t a1, char a2)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_BOOL(v4, "extension", (*(void *)(a1 + 1352) & 0x400000000LL) != 0);
  xpc_dictionary_set_BOOL(v4, launch_extension_property_xpc_bundle, (*(void *)(a1 + 1352) & 2LL) != 0);
  int64_t v5 = *(const char **)(a1 + 576);
  if (v5) {
    xpc_dictionary_set_string(v4, "bundle-id", v5);
  }
  xpc_dictionary_set_int64(v4, launch_extension_property_pid, *(int *)(a1 + 1128));
  if (*(_BYTE *)sub_10001A0A4(a1) == 47)
  {
    int64_t v6 = (const char *)sub_10001A0A4(a1);
    xpc_dictionary_set_string(v4, "path", v6);
  }

  uint64_t v7 = *(void *)(a1 + 248);
  if ((void *)sub_10002A994(v7) == qword_100069750)
  {
    int v8 = sub_10002A99C(v7);
    uint64_t v9 = sub_10001CB68(v8);
    if (v9)
    {
      uint64_t v10 = *(const char **)(v9 + 576);
      if (v10) {
        xpc_dictionary_set_string(v4, launch_extension_property_host_bundle_id, v10);
      }
    }

    xpc_dictionary_set_int64(v4, launch_extension_property_host_pid, v8);
    if ((a2 & 1) == 0) {
      goto LABEL_15;
    }
  }

  else if ((a2 & 1) == 0)
  {
    goto LABEL_15;
  }

  uint64_t v11 = *(void *)(a1 + 344);
  if (v11)
  {
    uint64_t v12 = *(void **)(v11 + 56);
    goto LABEL_16;
  }

uint64_t sub_10001E38C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return sub_10001A098(a1);
}

const char *sub_10001E3C0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  uint64_t result = *(const char **)(a1 + 1112);
  if (!result || *(unsigned __int16 *)(a1 + 1162) <= 1u)
  {
    uint64_t v3 = (const char *)sub_10001A098(a1);
    uint64_t v4 = *(void *)(a1 + 1352);
    int64_t v5 = strrchr(v3, 47);
    int64_t v6 = v5;
    if ((v4 & 2) != 0)
    {
      if (v5)
      {
        uint64_t v7 = strrchr(v5, 46);
        if (v7) {
          uint64_t v3 = v7;
        }
        else {
          uint64_t v3 = v6;
        }
      }
    }

    else if (v5)
    {
      uint64_t v3 = v5;
    }

    return v3 + 1;
  }

  return result;
}

uint64_t sub_10001E464(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return *(void *)(a1 + 584);
}

uint64_t sub_10001E49C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return *(void *)(a1 + 576);
}

uint64_t sub_10001E4D4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return a1 + 408;
}

uint64_t sub_10001E50C(uint64_t a1)
{
  return a1 + 1176;
}

uint64_t sub_10001E514(uint64_t a1, BOOL *a2)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  *a2 = (*(_DWORD *)(a1 + 1352) & 0x8000) != 0;
  return (*(unsigned __int8 *)(a1 + 1353) >> 6) & 1;
}

uint64_t sub_10001E55C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return (*(unsigned __int8 *)(a1 + 1168) >> 1) & 1;
}

uint64_t sub_10001E598(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return *(_BYTE *)(a1 + 1357) & 1;
}

uint64_t sub_10001E5D4(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 1357) >> 3) & 1;
}

FILE *sub_10001E5E0( FILE *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100069CF8)
  {
    uint64_t v9 = result;
    uint64_t v10 = a2 + 1;
    sub_10003D32C(result, a2 + 1, "pending global attachments = {", a4, a5, a6, a7, a8);
    xpc_object_t v16 = (void *)qword_100069CF8;
    if (qword_100069CF8)
    {
      uint64_t v17 = a2 + 2;
      do
      {
        sub_10003D32C(v9, v17, "%s", v11, v12, v13, v14, v15, v16[2]);
        xpc_object_t v16 = (void *)*v16;
      }

      while (v16);
    }

    return (FILE *)sub_10003D32C(v9, v10, "}", v11, v12, v13, v14, v15);
  }

  return result;
}

uint64_t sub_10001E694(uint64_t a1, FILE *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  return sub_10001E6C8(a1, a2, a3);
}

uint64_t sub_10001E6C8(uint64_t a1, FILE *a2, uint64_t a3)
{
  int64_t v6 = sub_10001C2A0(a1, 1);
  sub_10003D32C(a2, a3, "%s = {", v7, v8, v9, v10, v11, v6);
  free(v6);
  uint64_t v17 = a3 + 1;
  if ((*(_BYTE *)(a1 + 1357) & 2) != 0) {
    sub_10003D32C(a2, a3 + 1, "original = %s", v12, v13, v14, v15, v16, *(void *)(a1 + 256) + 1360LL);
  }
  sub_10003D32C(a2, a3 + 1, "active size_t count = %d", v12, v13, v14, v15, v16, *(__int16 *)(a1 + 300));
  if (*(_DWORD *)(a1 + 264)) {
    sub_10003D32C(a2, a3 + 1, "copy size_t count = %d", v18, v19, v20, v21, v22, *(unsigned int *)(a1 + 264));
  }
  if (sub_10001A0A4(a1))
  {
    uint64_t v28 = sub_10001A0A4(a1);
    sub_10003D32C(a2, a3 + 1, "path = %s", v29, v30, v31, v32, v33, v28);
  }

  unsigned int v34 = *(unsigned __int8 *)(a1 + 356) - 1;
  if (v34 > 6) {
    uint64_t v35 = "Unknown";
  }
  else {
    uint64_t v35 = off_1000647A8[(char)v34];
  }
  sub_10003D32C(a2, a3 + 1, "xpc_type_t type = %s", v23, v24, v25, v26, v27, v35);
  uint64_t v41 = *(void *)(a1 + 344);
  if (v41)
  {
    uint64_t v42 = *(void **)(v41 + 48);
    if (v42)
    {
      xpc_type_t type = xpc_get_type(v42);
      if (type == (xpc_type_t)&_xpc_type_array)
      {
        sub_10003D32C(a2, a3 + 1, "managed_by = {", v36, v37, v38, v39, v40);
        uint64_t v49 = *(void **)(*(void *)(a1 + 344) + 48LL);
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000LL;
        applier[2] = sub_100024A6C;
        applier[3] = &unk_1000646B0;
        applier[4] = a2;
        void applier[5] = a3;
        xpc_array_apply(v49, applier);
        sub_10003D32C(a2, a3 + 1, "}", v50, v51, v52, v53, v54, v857);
      }

      else if (type == (xpc_type_t)&_xpc_type_string)
      {
        int64_t string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(*(void *)(a1 + 344) + 48LL));
        sub_10003D32C(a2, a3 + 1, "managed_by = %s", v44, v45, v46, v47, v48, string_ptr);
      }
    }

    uint64_t v55 = *(void *)(a1 + 344);
    if (v55 && *(void *)(v55 + 56))
    {
      sub_10003D32C(a2, a3 + 1, "managedby_services = {", v36, v37, v38, v39, v40);
      dispatch_time_t v56 = *(void **)(*(void *)(a1 + 344) + 56LL);
      v883[0] = _NSConcreteStackBlock;
      v883[1] = 0x40000000LL;
      v883[2] = sub_100024AB8;
      v883[3] = &unk_1000646D0;
      v883[4] = a2;
      v883[5] = a3;
      xpc_array_apply(v56, v883);
      sub_10003D32C(a2, a3 + 1, "}", v57, v58, v59, v60, v61);
    }
  }

  LOBYTE(v859) = sub_100020C90(a1);
  sub_10003D32C(a2, a3 + 1, "state = %s", v62, v63, v64, v65, v66);
  if (*(void *)(a1 + 576))
  {
    uint64_t v859 = *(void *)(a1 + 576);
    sub_10003D32C(a2, a3 + 1, "bundle id = %s", v69, v70, v71, v72, v73);
  }

  if ((*(_BYTE *)(a1 + 1356) & 4) != 0)
  {
    uint64_t v859 = *(void *)(a1 + 584);
    sub_10003D32C(a2, a3 + 1, "extension point = %s", v69, v70, v71, v72, v73);
  }

  int v74 = *(_DWORD *)(a1 + 680);
  if (v74)
  {
    *(_OWORD *)object_addr = 0u;
    __int128 v882 = 0u;
    DWORD1(v882) = v74;
    __int128 v887 = 0u;
    __int128 v888 = 0u;
    *(_OWORD *)object_xpc_type_t type = 0u;
    __int128 v886 = 0u;
    LOBYTE(v859) = sub_100039990((uint64_t)object_addr, (char *)object_type);
    uint64_t v874 = *(unsigned int *)(a1 + 680);
    sub_10003D32C(a2, a3 + 1, "controller = %s.%d", v75, v76, v77, v78, v79);
  }

  sub_10003D3A8(a2, v67, v68, v69, v70, v71, v72, v73, v859);
  LOBYTE(v860) = sub_10001A098(a1);
  sub_10003D32C(a2, a3 + 1, "prograuint64_t m = %s", v80, v81, v82, v83, v84);
  if (*(void *)(a1 + 1232))
  {
    uint64_t v860 = *(void *)(a1 + 1232);
    sub_10003D32C(a2, a3 + 2, "+ %s", v85, v86, v87, v88, v89);
  }

  if (*(_DWORD *)(a1 + 428) || *(void *)(a1 + 1240))
  {
    sub_10003D32C(a2, a3 + 1, "arguments = {", v85, v86, v87, v88, v89);
    if (*(_DWORD *)(a1 + 428))
    {
      unint64_t v95 = 0LL;
      do
        sub_10003D32C(a2, a3 + 2, "%s", v90, v91, v92, v93, v94, *(void *)(*(void *)(a1 + 432) + 8 * v95++));
      while (v95 < *(unsigned int *)(a1 + 428));
    }

    sub_10003D32C(a2, a3 + 1, "}", v90, v91, v92, v93, v94);
    if (*(void *)(a1 + 1240))
    {
      sub_10003D3A8(a2, v96, v97, v98, v99, v100, v101, v102, v860);
      sub_10003D32C(a2, a3 + 1, "controller-supplied arguments = {", v103, v104, v105, v106, v107);
      if (xpc_array_get_count(*(xpc_object_t *)(a1 + 1240)))
      {
        size_t v113 = 0LL;
        do
        {
          string = xpc_array_get_string(*(xpc_object_t *)(a1 + 1240), v113);
          if (string)
          {
            LOBYTE(v860) = (_BYTE)string;
            sub_10003D32C(a2, a3 + 2, "%s", v115, v116, v117, v118, v119);
          }

          ++v113;
        }

        while (v113 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1240)));
      }

      sub_10003D32C(a2, a3 + 1, "}", v108, v109, v110, v111, v112);
    }

    sub_10003D3A8(a2, v96, v97, v98, v99, v100, v101, v102, v860);
  }

  uint64_t v120 = *(const char **)(a1 + 440);
  if (!v120)
  {
    if (!*(void *)(a1 + 1248)) {
      goto LABEL_46;
    }
    uint64_t v120 = "(unspecified)";
  }

  sub_10003D32C(a2, a3 + 1, "working directory = %s", v85, v86, v87, v88, v89, v120);
  if (*(void *)(a1 + 1248))
  {
    uint64_t v861 = *(void *)(a1 + 1248);
    sub_10003D32C(a2, a3 + 2, "+ %s", v123, v124, v125, v126, v127);
  }

  sub_10003D3A8(a2, v121, v122, v123, v124, v125, v126, v127, v861);
LABEL_46:
  if (*(void *)(a1 + 448))
  {
    uint64_t v860 = *(void *)(a1 + 448);
    sub_10003D32C(a2, a3 + 1, "stdin path = %s", v85, v86, v87, v88, v89);
  }

  if (*(void *)(a1 + 456))
  {
    uint64_t v860 = *(void *)(a1 + 456);
    sub_10003D32C(a2, a3 + 1, "stdout path = %s", v85, v86, v87, v88, v89);
  }

  if (*(void *)(a1 + 464))
  {
    uint64_t v860 = *(void *)(a1 + 464);
    sub_10003D32C(a2, a3 + 1, "stderr path = %s", v85, v86, v87, v88, v89);
  }

  if (*(void *)(a1 + 472))
  {
    uint64_t v860 = *(void *)(a1 + 472);
    sub_10003D32C(a2, a3 + 1, "container id = %s", v85, v86, v87, v88, v89);
  }

  if (*(void *)(a1 + 480))
  {
    uint64_t v860 = *(void *)(a1 + 480);
    sub_10003D32C(a2, a3 + 1, "sandbox profile = %s", v85, v86, v87, v88, v89);
  }

  if (*(void *)(a1 + 488))
  {
    uint64_t v860 = *(void *)(a1 + 488);
    sub_10003D32C(a2, a3 + 1, "subsystem root = %s", v85, v86, v87, v88, v89);
  }

  if (*(void *)(a1 + 1256))
  {
    sub_10003D32C(a2, a3 + 1, "controller-supplied environment = {", v85, v86, v87, v88, v89);
    *(void *)object_xpc_type_t type = a2;
    *(void *)&object_type[2] = 0LL;
    *(void *)&__int128 v886 = a3 + 2;
    xpc_dictionary_apply_f(*(void *)(a1 + 1256));
    sub_10003D32C(a2, a3 + 1, "}", v128, v129, v130, v131, v132);
    sub_10003D3A8(a2, v133, v134, v135, v136, v137, v138, v139, v860);
  }

  if (qword_10006A9F8)
  {
    sub_10003D32C(a2, a3 + 1, "global environment = {", v85, v86, v87, v88, v89);
    uint64_t v145 = (void *)qword_10006A9F8;
    if (qword_10006A9F8)
    {
      do
      {
        sub_100016A10((uint64_t)v145, a3 + 2, a2);
        uint64_t v145 = (void *)*v145;
      }

      while (v145);
    }

    sub_10003D32C(a2, a3 + 1, "}", v140, v141, v142, v143, v144);
    sub_10003D3A8(a2, v146, v147, v148, v149, v150, v151, v152, v860);
  }

  if (*(void *)(*(void *)(a1 + 248) + 88LL))
  {
    sub_10003D32C(a2, a3 + 1, "inherited environment = {", v85, v86, v87, v88, v89);
    for (uint64_t i = *(void **)(*(void *)(a1 + 248) + 88LL); i; uint64_t i = (void *)*i)
      sub_100016A10((uint64_t)i, a3 + 2, a2);
    sub_10003D32C(a2, a3 + 1, "}", v153, v154, v155, v156, v157);
    sub_10003D3A8(a2, v159, v160, v161, v162, v163, v164, v165, v860);
  }

  if (qword_10006AA00)
  {
    sub_10003D32C(a2, a3 + 1, "default environment = {", v85, v86, v87, v88, v89);
    __int128 v171 = (void *)qword_10006AA00;
    if (qword_10006AA00)
    {
      do
      {
        sub_100016A10((uint64_t)v171, a3 + 2, a2);
        __int128 v171 = (void *)*v171;
      }

      while (v171);
    }

    sub_10003D32C(a2, a3 + 1, "}", v166, v167, v168, v169, v170);
    sub_10003D3A8(a2, v172, v173, v174, v175, v176, v177, v178, v860);
  }

  if (*(_WORD *)(a1 + 992))
  {
    sub_10003D32C(a2, a3 + 1, "environment = {", v85, v86, v87, v88, v89);
    for (uint64_t j = *(void **)(a1 + 984); j; uint64_t j = (void *)*j)
      sub_100016A10((uint64_t)j, a3 + 2, a2);
    sub_10003D32C(a2, a3 + 1, "}", v179, v180, v181, v182, v183);
    sub_10003D3A8(a2, v185, v186, v187, v188, v189, v190, v191, v860);
  }

  v192 = sub_1000258E0(*(void *)(a1 + 248), 2);
  sub_10003D32C(a2, a3 + 1, "domaiuint64_t n = %s", v193, v194, v195, v196, v197, v192);
  free(v192);
  if (*(void *)(a1 + 776))
  {
    uint64_t v862 = *(void *)(a1 + 776);
    sub_10003D32C(a2, a3 + 1, "usermach_port_name_t name = %s", v198, v199, v200, v201, v202);
    uint64_t v205 = *(void *)(a1 + 784);
    if (!v205) {
      goto LABEL_81;
    }
  }

  else
  {
    uint64_t v205 = *(void *)(a1 + 784);
    if (!v205) {
      goto LABEL_82;
    }
  }

  sub_10003D32C(a2, a3 + 1, "group = %s", v198, v199, v200, v201, v202, v205);
LABEL_81:
  sub_10003D3A8(a2, v203, v204, v198, v199, v200, v201, v202, v862);
LABEL_82:
  if ((*(_BYTE *)(a1 + 1356) & 1) != 0) {
    sub_10003D32C(a2, a3 + 1, "umasuint64_t k = %o", v198, v199, v200, v201, v202, *(unsigned __int16 *)(a1 + 792));
  }
  uint64_t v206 = sub_10001A9FC(a1);
  sub_10003D32C(a2, a3 + 1, "minimum runtime = %u", v207, v208, v209, v210, v211, v206);
  if ((*(_BYTE *)(a1 + 1358) & 4) != 0) {
    sub_10003D32C(a2, a3 + 1, "base minimum runtime = %u", v212, v213, v214, v215, v216, *(unsigned int *)(a1 + 812));
  }
  sub_10003D32C(a2, a3 + 1, "exit timeout = %u", v212, v213, v214, v215, v216, *(unsigned int *)(a1 + 808));
  if ((*(_BYTE *)(a1 + 1356) & 4) != 0)
  {
    sub_10003D32C(a2, a3 + 1, "voluntary exit timeout = %u", v217, v218, v219, v220, v221, *(unsigned int *)(a1 + 840));
    if (byte_10006A9F0) {
      sub_10003D32C( a2,  a3 + 1,  "launch watchdog timeout = %u",  v222,  v223,  v224,  v225,  v226,  *(unsigned int *)(a1 + 844));
    }
    else {
      sub_10003D32C(a2, a3 + 1, "launch watchdog timeout = (globally disabled)", v222, v223, v224, v225, v226, v863);
    }
  }

  if (*(void *)(a1 + 864)) {
    sub_10003D32C(a2, a3 + 1, "exception handler endpoint = %s", v217, v218, v219, v220, v221, *(void *)(a1 + 864));
  }
  sub_10003D32C(a2, a3 + 1, "runs = %u", v217, v218, v219, v220, v221, *(unsigned int *)(a1 + 1000));
  uint64_t v227 = sub_100020AC4(a1);
  uint64_t v233 = a1 + 1016;
  if (v227) {
    uint64_t v233 = v227;
  }
  v234 = (char *)*(unsigned int *)(v233 + 4);
  if ((_DWORD)v234)
  {
    v864 = v234;
    sub_10003D32C(a2, a3 + 1, "successive crashes = %u", v228, v229, v230, v231, v232);
  }

  if (*(_DWORD *)(a1 + 1128))
  {
    sub_10003D32C(a2, a3 + 1, "pid = %d", v228, v229, v230, v231, v232, *(unsigned int *)(a1 + 1128));
    v235 = sub_10002089C(*(_DWORD *)(a1 + 1136));
    sub_10003D32C(a2, a3 + 1, "immediate reasouint64_t n = %s", v236, v237, v238, v239, v240, v235);
    sub_10003D32C(a2, a3 + 1, "forks = %hu", v241, v242, v243, v244, v245, *(unsigned __int16 *)(a1 + 1160));
    sub_10003D32C(a2, a3 + 1, "execs = %hu", v246, v247, v248, v249, v250, *(unsigned __int16 *)(a1 + 1162));
    v256 = (void *)(a1 + 1164);
    v257 = (*(void *)(a1 + 1164) & (unint64_t)&_mh_execute_header) != 0 ? "1" : "0";
    sub_10003D32C(a2, a3 + 1, "initialized = %s", v251, v252, v253, v254, v255, v257);
    v263 = (*v256 & 0x200000000LL) != 0 ? "1" : "0";
    sub_10003D32C(a2, a3 + 1, "trampolined = %s", v258, v259, v260, v261, v262, v263);
    v269 = (*v256 & 0x400000000LL) != 0 ? "1" : "0";
    sub_10003D32C(a2, a3 + 1, "started suspended = %s", v264, v265, v266, v267, v268, v269);
    v275 = (*v256 & 0x800000000LL) != 0 ? "1" : "0";
    sub_10003D32C(a2, a3 + 1, "proxy started suspended = %s", v270, v271, v272, v273, v274, v275);
    v281 = (*v256 & 0x8000000000LL) != 0 ? "1" : "0";
    sub_10003D32C(a2, a3 + 1, "uses proxy = %s", v276, v277, v278, v279, v280, v281);
    if ((*(_BYTE *)(a1 + 1356) & 4) != 0)
    {
      if ((*v256 & 0x4000000000LL) != 0) {
        v282 = "1";
      }
      else {
        v282 = "0";
      }
      sub_10003D32C(a2, a3 + 1, "extension alive = %s", v228, v229, v230, v231, v232, v282);
    }
  }

  unsigned int v283 = *(_DWORD *)(a1 + 288);
  if (v283)
  {
    v864 = sub_10002089C(v283);
    sub_10003D32C(a2, a3 + 1, "pended spawuint64_t n = %s", v284, v285, v286, v287, v288);
  }

  unsigned int v289 = *(_DWORD *)(a1 + 292);
  if (v289)
  {
    v864 = sub_10002089C(v289);
    sub_10003D32C(a2, a3 + 1, "pended nondemand spawuint64_t n = %s", v290, v291, v292, v293, v294);
  }

  unsigned int v295 = *(_DWORD *)(a1 + 1104);
  if (v295)
  {
    v864 = sub_10002089C(v295);
    sub_10003D32C(a2, a3 + 1, "spawn reason filter = %s", v296, v297, v298, v299, v300);
  }

  int v301 = *(_DWORD *)(a1 + 1176);
  switch(v301)
  {
    case 2:
      v302 = "last exit code = (failed reap)";
      goto LABEL_131;
    case 1:
      v302 = "last exit code = (abandoned)";
      goto LABEL_131;
    case 0:
      v302 = "last exit code = (never exited)";
LABEL_131:
      sub_10003D32C(a2, a3 + 1, v302, v228, v229, v230, v231, v232, v864, v874);
      goto LABEL_132;
  }

  if (sub_10003DB1C((_DWORD *)(a1 + 1176)))
  {
    int v303 = sub_10003DB64((_DWORD *)(a1 + 1176));
    v864 = strsignal(v303);
    v302 = "last terminating signal = %s";
    goto LABEL_131;
  }

  if (sub_10003DA48(a1 + 1176))
  {
    uint64_t v435 = sub_10003DA74((_DWORD *)(a1 + 1176));
    else {
      sub_10003D32C( a2,  a3 + 1,  "last exit code = %d: %s",  v436,  v437,  v438,  v439,  v440,  v435,  off_1000644C8[(v435 - 64)]);
    }
  }

  else
  {
    if (sub_10003DD04(a1 + 1176))
    {
      v302 = "last exit code = (extension watchdogged)";
      goto LABEL_131;
    }

    v850 = sub_10003D968(a1 + 1176);
    v856 = "(unknown)";
    if (v850) {
      v856 = v850;
    }
    sub_10003D32C(a2, a3 + 1, "last exit reasouint64_t n = %s", v851, v852, v853, v854, v855, v856, v874);
  }

LABEL_132:
  if (sub_10003DC4C((_DWORD *)(a1 + 1176)))
  {
    v311 = sub_10003D968(a1 + 1176);
    v317 = "(unknown)";
    if (v311) {
      v317 = v311;
    }
    sub_10003D32C(a2, a3 + 1, "last jetsam exit details = %s", v312, v313, v314, v315, v316, v317);
  }

  if (*(void *)(a1 + 648))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "semaphores = {", v318, v319, v320, v321, v322);
    for (uint64_t k = *(uint64_t ***)(a1 + 648); k; uint64_t k = (uint64_t **)*k)
    {
      __int128 v899 = 0u;
      __int128 v900 = 0u;
      __int128 v897 = 0u;
      __int128 v898 = 0u;
      __int128 v895 = 0u;
      __int128 v896 = 0u;
      __int128 v893 = 0u;
      __int128 v894 = 0u;
      __int128 v891 = 0u;
      __int128 v892 = 0u;
      __int128 v889 = 0u;
      __int128 v890 = 0u;
      __int128 v887 = 0u;
      __int128 v888 = 0u;
      *(_OWORD *)object_xpc_type_t type = 0u;
      __int128 v886 = 0u;
      sub_10003D32C( a2,  a3 + 2,  "%s%s => %u",  v323,  v324,  v325,  v326,  v327,  k[3],  object_type,  *((unsigned __int8 *)k + 32));
    }

    sub_10003D32C(a2, a3 + 1, "}", v323, v324, v325, v326, v327);
  }

  if (*(void *)(a1 + 136))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "event triggers = {", v329, v330, v331, v332, v333);
    for (uint64_t m = *(void *)(a1 + 136); m; uint64_t m = *(void *)(m + 16))
      sub_100035BBC(m, a2, a3 + 2, v334, v335, v336, v337, v338);
    sub_10003D32C(a2, a3 + 1, "}", v334, v335, v336, v337, v338);
  }

  if (*(void *)(a1 + 152))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "endpoints = {", v340, v341, v342, v343, v344);
    for (uint64_t n = *(void *)(a1 + 152); n; uint64_t n = *(void *)(n + 16))
    {
      if ((*(_BYTE *)(n + 88) & 0x40) == 0) {
        sub_10003FE38(n, a2, a3 + 2, v345, v346, v347, v348, v349);
      }
    }

    sub_10003D32C(a2, a3 + 1, "}", v345, v346, v347, v348, v349);
  }

  if (*(void *)(a1 + 160))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "dynamic endpoints = {", v351, v352, v353, v354, v355);
    for (iuint64_t i = *(void *)(a1 + 160); ii; iuint64_t i = *(void *)(ii + 16))
    {
      if ((*(_BYTE *)(ii + 88) & 0x40) == 0) {
        sub_10003FE38(ii, a2, a3 + 2, v356, v357, v358, v359, v360);
      }
    }

    sub_10003D32C(a2, a3 + 1, "}", v356, v357, v358, v359, v360);
  }

  if (*(void *)(a1 + 168))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "pid-local endpoints = {", v362, v363, v364, v365, v366);
    for (juint64_t j = *(void *)(a1 + 168); jj; juint64_t j = *(void *)(jj + 16))
    {
      if ((*(_BYTE *)(jj + 88) & 0x40) == 0) {
        sub_10003FE38(jj, a2, a3 + 2, v367, v368, v369, v370, v371);
      }
    }

    sub_10003D32C(a2, a3 + 1, "}", v367, v368, v369, v370, v371);
  }

  if (*(void *)(a1 + 184))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "instance-specific endpoints = {", v373, v374, v375, v376, v377);
    for (kuint64_t k = *(void *)(a1 + 184); kk; kuint64_t k = *(void *)(kk + 16))
    {
      if ((*(_BYTE *)(kk + 88) & 0x40) == 0) {
        sub_10003FE38(kk, a2, a3 + 2, v378, v379, v380, v381, v382);
      }
    }

    sub_10003D32C(a2, a3 + 1, "}", v378, v379, v380, v381, v382);
  }

  if (*(void *)(a1 + 176))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "event channels = {", v384, v385, v386, v387, v388);
    for (muint64_t m = *(void *)(a1 + 176); mm; muint64_t m = *(void *)(mm + 16))
    {
      if ((*(_BYTE *)(mm + 88) & 0x40) == 0) {
        sub_10003FE38(mm, a2, a3 + 2, v389, v390, v391, v392, v393);
      }
    }

    sub_10003D32C(a2, a3 + 1, "}", v389, v390, v391, v392, v393);
  }

  if (*(void *)(a1 + 192))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "sockets = {", v395, v396, v397, v398, v399);
    for (nuint64_t n = *(void *)(a1 + 192); nn; nuint64_t n = *(void *)(nn + 16))
      sub_1000192CC(nn, a2, a3 + 2, v400, v401, v402, v403, v404);
    sub_10003D32C(a2, a3 + 1, "}", v400, v401, v402, v403, v404);
  }

  if (*(void *)(a1 + 200))
  {
    sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
    sub_10003D32C(a2, a3 + 1, "instances = {", v406, v407, v408, v409, v410);
    for (uint64_t i1 = *(void *)(a1 + 200); i1; uint64_t i1 = *(void *)(i1 + 40))
      sub_10003D32C(a2, a3 + 2, "%s,", v411, v412, v413, v414, v415, i1 + 1360);
    sub_10003D32C(a2, a3 + 1, "}", v411, v412, v413, v414, v415);
  }

  sub_10003D3A8(a2, v304, v305, v306, v307, v308, v309, v310, v865);
  mach_port_name_t v422 = *(_DWORD *)(a1 + 1316);
  if (v422 + 1 >= 2)
  {
    object_type[0] = 0;
    object_addr[0] = 0;
    if (mach_port_kernel_object(mach_task_self_, v422, object_type, object_addr)) {
      sub_10003D32C( a2,  a3 + 1,  "dext checkin uint64_t port = %#x [unable to get port information]",  v423,  v424,  v425,  v426,  v427,  *(unsigned int *)(a1 + 1316),  v875,  v878);
    }
    else {
      sub_10003D32C( a2,  a3 + 1,  "dext checkin uint64_t port = %#x [type %u, object %#x]",  v423,  v424,  v425,  v426,  v427,  *(unsigned int *)(a1 + 1316),  object_type[0],  object_addr[0]);
    }
    sub_10003D3A8(a2, v428, v429, v430, v431, v432, v433, v434, v867);
  }

  unint64_t v441 = *(unsigned int *)(a1 + 872);
  if (v441 >= 0x100)
  {
    unint64_t v442 = v441 >> 8;
    else {
      v443 = (const char *)qword_1000646F0[v442];
    }
    sub_10003D32C(a2, a3 + 1, "spawn xpc_type_t type = %s (%lu)", v417, v418, v419, v420, v421, v443, v442);
  }

  uint64_t v444 = *(unsigned int *)(a1 + 876);
  if ((_DWORD)v444)
  {
    else {
      v445 = (const char *)qword_100064728[v444];
    }
    sub_10003D32C(a2, a3 + 1, "spawn role = %s (%lu)", v417, v418, v419, v420, v421, v445, v444);
  }

  uint64_t v880 = a3 + 1;
  if (*(void *)(a1 + 880) || *(void *)(a1 + 1264))
  {
    sub_10003D32C(a2, a3 + 1, "binary order preference = {", v417, v418, v419, v420, v421);
    uint64_t v451 = *(void *)(a1 + 880);
    if (v451 && xpc_binprefs_count(*(void *)(a1 + 880)))
    {
      unsigned int v452 = 0;
      do
      {
        int v453 = xpc_binprefs_cpu_type(v451, v452);
        v459 = "(invalid)";
        if ((v453 & 0xFEFFFFFF) - 1 <= 0x11)
        {
          v460 = &off_100064560[v453 & 0xFEFFFFFF];
          if ((v453 & 0x1000000) == 0) {
            v460 = &off_1000645F8[v453];
          }
          v459 = *v460;
        }

        sub_10003D32C(a2, a3 + 2, "%s", v454, v455, v456, v457, v458, v459);
        ++v452;
      }

      while (v452 < xpc_binprefs_count(v451));
    }

    uint64_t v461 = *(void *)(a1 + 1264);
    if (v461 && xpc_binprefs_count(*(void *)(a1 + 1264)))
    {
      unsigned int v462 = 0;
      do
      {
        int v463 = xpc_binprefs_cpu_type(v461, v462);
        v469 = "(invalid)";
        if ((v463 & 0xFEFFFFFF) - 1 <= 0x11)
        {
          v470 = &off_100064560[v463 & 0xFEFFFFFF];
          if ((v463 & 0x1000000) == 0) {
            v470 = &off_1000645F8[v463];
          }
          v469 = *v470;
        }

        sub_10003D32C(a2, a3 + 2, "+ %s", v464, v465, v466, v467, v468, v469);
        ++v462;
      }

      while (v462 < xpc_binprefs_count(v461));
    }

    uint64_t v17 = a3 + 1;
    sub_10003D32C(a2, v880, "}", v446, v447, v448, v449, v450);
    sub_10003D3A8(a2, v471, v472, v473, v474, v475, v476, v477, v866);
  }

  sub_10003D32C(a2, v17, "jetsam priority = %d", v417, v418, v419, v420, v421, *(unsigned int *)(a1 + 896));
  if ((*(_DWORD *)(a1 + 1288) & 0x80000000) == 0) {
    sub_10003D32C(a2, v17, "+ %d", v478, v479, v480, v481, v482, *(unsigned int *)(a1 + 1288));
  }
  int v483 = *(_DWORD *)(a1 + 900);
  if (v483 >= 1)
  {
    if ((*(_DWORD *)(a1 + 892) & 4) != 0) {
      v484 = "hard";
    }
    else {
      v484 = "soft";
    }
    v868 = v484;
    uint64_t v875 = *(unsigned int *)(a1 + 900);
LABEL_226:
    v485 = "jetsam memory limit (active, %s) = %d MB";
    goto LABEL_229;
  }

  if (!v483)
  {
    if ((*(_DWORD *)(a1 + 892) & 4) != 0) {
      v848 = "hard";
    }
    else {
      v848 = "soft";
    }
    v868 = v848;
    uint64_t v875 = 0xFFFFFFFFLL;
    goto LABEL_226;
  }

  v485 = "jetsam memory limit (active) = (unlimited)";
LABEL_229:
  sub_10003D32C(a2, v17, v485, v478, v479, v480, v481, v482, v868, v875);
  int v491 = *(_DWORD *)(a1 + 1292);
  if (v491 >= 1)
  {
    v869 = (const char *)*(unsigned int *)(a1 + 1292);
    v492 = "+ %d MB";
LABEL_231:
    sub_10003D32C(a2, v17, v492, v486, v487, v488, v489, v490, v869);
    goto LABEL_233;
  }

  if (v491 < 0)
  {
    v492 = "+ (unlimited)";
    goto LABEL_231;
  }

LABEL_233:
  int v493 = *(_DWORD *)(a1 + 904);
  if (v493 >= 1)
  {
    if ((*(_DWORD *)(a1 + 892) & 8) != 0) {
      v494 = "hard";
    }
    else {
      v494 = "soft";
    }
    v869 = v494;
    uint64_t v876 = *(unsigned int *)(a1 + 904);
LABEL_238:
    v495 = "jetsam memory limit (inactive, %s) = %d MB";
    goto LABEL_241;
  }

  if (!v493)
  {
    if ((*(_DWORD *)(a1 + 892) & 8) != 0) {
      v849 = "hard";
    }
    else {
      v849 = "soft";
    }
    v869 = v849;
    uint64_t v876 = 0xFFFFFFFFLL;
    goto LABEL_238;
  }

  v495 = "jetsam memory limit (inactive) = (unlimited)";
LABEL_241:
  sub_10003D32C(a2, v17, v495, v486, v487, v488, v489, v490, v869, v876);
  int v501 = *(_DWORD *)(a1 + 1292);
  if (v501 >= 1)
  {
    uint64_t v870 = *(unsigned int *)(a1 + 1292);
    v502 = "+ %d MB";
LABEL_243:
    sub_10003D32C(a2, v17, v502, v496, v497, v498, v499, v500, v870);
    goto LABEL_245;
  }

  if (v501 < 0)
  {
    v502 = "+ (unlimited)";
    goto LABEL_243;
  }

LABEL_245:
  v871 = sub_10002058C(a1);
  sub_10003D32C(a2, v17, "jetsamproperties category = %s", v503, v504, v505, v506, v507);
  if ((*(_BYTE *)(a1 + 1357) & 4) != 0) {
    sub_10003D32C(a2, v17, "submitted job. ignore execute allowed", v508, v509, v510, v511, v512);
  }
  if (*(_DWORD *)(a1 + 908))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 908);
    sub_10003D32C(a2, v17, "jetsam thread limit = %d", v508, v509, v510, v511, v512);
  }

  if (*(void *)(a1 + 912))
  {
    v871 = *(const char **)(a1 + 912);
    sub_10003D32C(a2, v17, "jetsam address limit = %llu", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 920))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 920);
    sub_10003D32C(a2, v17, "jetsam soft port limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 924))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 924);
    sub_10003D32C(a2, v17, "jetsam hard port limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 928))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 928);
    sub_10003D32C(a2, v17, "jetsam soft file descriptor limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 932))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 932);
    sub_10003D32C(a2, v17, "jetsam hard file descriptor limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 936))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 936);
    sub_10003D32C(a2, v17, "jetsam soft kqworkloop limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 940))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 940);
    sub_10003D32C(a2, v17, "jetsam hard kqworkloop limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_DWORD *)(a1 + 944))
  {
    v871 = (const char *)*(unsigned int *)(a1 + 944);
    sub_10003D32C(a2, v17, "jetsam wired memory limit = %u", v508, v509, v510, v511, v512);
  }

  if (*(_BYTE *)(a1 + 994) || *(_DWORD *)(a1 + 996))
  {
    v871 = (const char *)*(unsigned __int8 *)(a1 + 994);
    uint64_t v877 = *(unsigned int *)(a1 + 996);
    v513 = "cpumouint64_t n = %d%% over %u seconds";
  }

  else
  {
    v513 = "cpumouint64_t n = default";
  }

  sub_10003D32C(a2, v17, v513, v508, v509, v510, v511, v512, v871, v877);
  if (*(void *)(a1 + 656))
  {
    uint64_t v879 = a3;
    sub_10003D32C(a2, v17, "resource limits = {", v514, v515, v516, v517, v518);
    v524 = *(uint64_t **)(a1 + 656);
    if (v524)
    {
      uint64_t v525 = v879 + 2;
      do
      {
        if (*((_BYTE *)v524 + 35))
        {
          __int128 v887 = 0u;
          __int128 v888 = 0u;
          *(_OWORD *)object_xpc_type_t type = 0u;
          __int128 v886 = 0u;
          if (v524[2] == 0x7FFFFFFFFFFFFFFFLL) {
            strcpy((char *)object_type, "(infinity)");
          }
          else {
            snprintf((char *)object_type, 0x40uLL, "%llu", v524[2]);
          }
          char v872 = sub_10003A05C(*((unsigned __int16 *)v524 + 16));
          sub_10003D32C(a2, v525, "%s (soft) => %s", v526, v527, v528, v529, v530);
        }

        if (*((_BYTE *)v524 + 34))
        {
          __int128 v887 = 0u;
          __int128 v888 = 0u;
          *(_OWORD *)object_xpc_type_t type = 0u;
          __int128 v886 = 0u;
          if (v524[3] == 0x7FFFFFFFFFFFFFFFLL) {
            strcpy((char *)object_type, "(infinity)");
          }
          else {
            snprintf((char *)object_type, 0x40uLL, "%llu", v524[3]);
          }
          char v872 = sub_10003A05C(*((unsigned __int16 *)v524 + 16));
          sub_10003D32C(a2, v525, "%s (hard) => %s", v531, v532, v533, v534, v535);
        }

        v524 = (uint64_t *)*v524;
      }

      while (v524);
    }

    uint64_t v17 = v880;
    sub_10003D32C(a2, v880, "}", v519, v520, v521, v522, v523);
    sub_10003D3A8(a2, v536, v537, v538, v539, v540, v541, v542, v872);
    a3 = v879;
  }

  if (*(_DWORD *)(a1 + 856)) {
    sub_10003D32C(a2, v17, "run interval = %u seconds", v514, v515, v516, v517, v518, *(unsigned int *)(a1 + 856));
  }
  if ((*(_BYTE *)(a1 + 1358) & 4) != 0) {
    sub_10003D32C( a2,  v17,  "exponential throttling grace limit = %u",  v514,  v515,  v516,  v517,  v518,  *(unsigned __int16 *)(a1 + 1004));
  }
  v543 = sub_100038860(a1);
  if (v543) {
    sub_10003D32C(a2, v17, "job state = %s", v544, v545, v546, v547, v548, v543);
  }
  uint64_t v549 = *(void *)(a1 + 1352);
  if ((v549 & 0x200000000000LL) != 0)
  {
    sub_10003D32C(a2, v17, "persona set at = %u", v544, v545, v546, v547, v548, *(unsigned int *)(a1 + 1304));
    uint64_t v549 = *(void *)(a1 + 1352);
  }

  if ((v549 & 0x1000000000000LL) == 0)
  {
    if (*(_DWORD *)(a1 + 696) != -101) {
      sub_10003D32C(a2, v17, "resolved uid = %d", v544, v545, v546, v547, v548, *(unsigned int *)(a1 + 696));
    }
    if (*(_DWORD *)(a1 + 700) != -101)
    {
      sub_10003D32C(a2, v17, "resolved gid = %d", v544, v545, v546, v547, v548, *(unsigned int *)(a1 + 700));
      if (*(_DWORD *)(a1 + 768))
      {
        sub_10003D32C(a2, v17, "resolved groups = {", v544, v545, v546, v547, v548);
        if (*(int *)(a1 + 768) >= 1)
        {
          uint64_t v555 = 0LL;
          do
            sub_10003D32C(a2, a3 + 2, "%d", v550, v551, v552, v553, v554, *(unsigned int *)(a1 + 704 + 4 * v555++));
          while (v555 < *(int *)(a1 + 768));
        }

        sub_10003D32C(a2, v17, "}", v550, v551, v552, v553, v554);
      }
    }
  }

  if (*(_BYTE *)(a1 + 1006)) {
    sub_10003D32C(a2, v17, "crash behavior = %x", v544, v545, v546, v547, v548, *(unsigned __int8 *)(a1 + 1006));
  }
  if ((*(_BYTE *)(a1 + 1359) & 4) != 0)
  {
    uint64_t v556 = sub_100020AC4(a1);
    uint64_t v562 = a1 + 1016;
    if (v556) {
      uint64_t v562 = v556;
    }
    size_t count = *(void **)(v562 + 24);
    if (count) {
      size_t count = (void *)xpc_array_get_count(count);
    }
    sub_10003D32C(a2, v17, "panic on consecutive crashes (%zd)", v557, v558, v559, v560, v561, count);
  }

  sub_10003D32C(a2, v17, "probabilistic guard malloc policy = {", v544, v545, v546, v547, v548);
  sub_10003D32C(a2, a3 + 2, "activation rate = 1/%u", v564, v565, v566, v567, v568, *(unsigned int *)(a1 + 1328));
  LODWORD(v873) = *(_DWORD *)(a1 + 1324);
  sub_10003D32C(a2, a3 + 2, "sample rate = 1/%u", v569, v570, v571, v572, v573);
  sub_10003D32C(a2, v17, "}", v574, v575, v576, v577, v578);
  int v584 = *(unsigned __int8 *)(a1 + 1320);
  if (*(_BYTE *)(a1 + 1320))
  {
    v585 = "0";
    if (v584 == 1) {
      v585 = "1";
    }
    if (v584 == 2) {
      v586 = "managed";
    }
    else {
      v586 = v585;
    }
    sub_10003D32C(a2, v17, "multiple instances = %s", v579, v580, v581, v582, v583, v586);
  }

  if (*(void *)(a1 + 1336))
  {
    uint64_t v873 = *(void *)(a1 + 1336);
    sub_10003D32C(a2, v17, "cryptex = %s", v579, v580, v581, v582, v583);
  }

  if (*(void *)(a1 + 1344))
  {
    uint64_t v873 = *(void *)(a1 + 1344);
    sub_10003D32C(a2, v17, "conclave = %s", v579, v580, v581, v582, v583);
  }

  v587 = (void **)sub_10000D8E8(0x80uLL);
  sub_100024B74((uint64_t)v587, (char)"partial import", *(_DWORD *)(a1 + 1352) & 1, v588, v589, v590, v591, v592);
  sub_100024B74((uint64_t)v587, (char)"xpc bundle", (*(void *)(a1 + 1352) >> 1) & 1LL, v593, v594, v595, v596, v597);
  sub_100024B74((uint64_t)v587, (char)"keepalive", (*(void *)(a1 + 1352) >> 2) & 1LL, v598, v599, v600, v601, v602);
  sub_100024B74((uint64_t)v587, (char)"runatload", (*(void *)(a1 + 1352) >> 4) & 1LL, v603, v604, v605, v606, v607);
  sub_100024B74( (uint64_t)v587,  (char)"low priority i/o",  (*(void *)(a1 + 1352) >> 5) & 1LL,  v608,  v609,  v610,  v611,  v612);
  sub_100024B74( (uint64_t)v587,  (char)"low priority background i/o",  (*(void *)(a1 + 1352) >> 6) & 1LL,  v613,  v614,  v615,  v616,  v617);
  sub_100024B74((uint64_t)v587, (char)"dataless file mode", *(_BYTE *)(a1 + 1308) != 0, v618, v619, v620, v621, v622);
  sub_100024B74( (uint64_t)v587,  (char)"exception handler",  (*(void *)(a1 + 1352) >> 7) & 1LL,  v623,  v624,  v625,  v626,  v627);
  sub_100024B74( (uint64_t)v587,  (char)"supports transactions",  (*(void *)(a1 + 1352) >> 8) & 1LL,  v628,  v629,  v630,  v631,  v632);
  sub_100024B74( (uint64_t)v587,  (char)"supports pressured exit",  (*(void *)(a1 + 1352) >> 9) & 1LL,  v633,  v634,  v635,  v636,  v637);
  sub_100024B74( (uint64_t)v587,  (char)"supports idle hysteresis",  (*(void *)(a1 + 1352) >> 46) & 1LL,  v638,  v639,  v640,  v641,  v642);
  sub_100024B74( (uint64_t)v587,  (char)"enter kdp before kill",  (*(void *)(a1 + 1352) >> 10) & 1LL,  v643,  v644,  v645,  v646,  v647);
  sub_100024B74( (uint64_t)v587,  (char)"wait for debugger",  (*(void *)(a1 + 1352) >> 11) & 1LL,  v648,  v649,  v650,  v651,  v652);
  sub_100024B74((uint64_t)v587, (char)"app", (*(void *)(a1 + 1352) >> 12) & 1LL, v653, v654, v655, v656, v657);
  sub_100024B74((uint64_t)v587, (char)"system app", (*(void *)(a1 + 1352) >> 13) & 1LL, v658, v659, v660, v661, v662);
  sub_100024B74( (uint64_t)v587,  (char)"inetd-compatible",  (*(void *)(a1 + 1352) >> 14) & 1LL,  v663,  v664,  v665,  v666,  v667);
  sub_100024B74( (uint64_t)v587,  (char)"inetd listener",  (*(void *)(a1 + 1352) >> 15) & 1LL,  v668,  v669,  v670,  v671,  v672);
  sub_100024B74( (uint64_t)v587,  (char)"abandon process group",  (*(void *)(a1 + 1352) >> 16) & 1LL,  v673,  v674,  v675,  v676,  v677);
  sub_100024B74( (uint64_t)v587,  (char)"event monitor",  (*(void *)(a1 + 1352) >> 17) & 1LL,  v678,  v679,  v680,  v681,  v682);
  sub_100024B74((uint64_t)v587, (char)"penalty box", (*(void *)(a1 + 1352) >> 18) & 1LL, v683, v684, v685, v686, v687);
  sub_100024B74((uint64_t)v587, (char)"role account", (*(void *)(a1 + 1352) >> 19) & 1LL, v688, v689, v690, v691, v692);
  sub_100024B74( (uint64_t)v587,  (char)"launch only once",  (*(void *)(a1 + 1352) >> 20) & 1LL,  v693,  v694,  v695,  v696,  v697);
  sub_100024B74( (uint64_t)v587,  (char)"system support",  (*(void *)(a1 + 1352) >> 21) & 1LL,  v698,  v699,  v700,  v701,  v702);
  sub_100024B74( (uint64_t)v587,  (char)"initial system support",  (*(void *)(a1 + 1352) >> 22) & 1LL,  v703,  v704,  v705,  v706,  v707);
  sub_100024B74( (uint64_t)v587,  (char)"inferred program",  (*(void *)(a1 + 1352) >> 24) & 1LL,  v708,  v709,  v710,  v711,  v712);
  sub_100024B74( (uint64_t)v587,  (char)"ios home screen app",  (*(void *)(a1 + 1352) >> 29) & 1LL,  v713,  v714,  v715,  v716,  v717);
  sub_100024B74( (uint64_t)v587,  (char)"abandon coalition",  (*(void *)(a1 + 1352) >> 30) & 1LL,  v718,  v719,  v720,  v721,  v722);
  sub_100024B74( (uint64_t)v587,  (char)"disable pointer auth",  (*(void *)(a1 + 1352) >> 54) & 1LL,  v723,  v724,  v725,  v726,  v727);
  sub_100024B74( (uint64_t)v587,  (char)"high bits aslr",  (*(void *)(a1 + 1352) >> 33) & 1LL,  v728,  v729,  v730,  v731,  v732);
  uint64_t v733 = sub_100020AC4(a1);
  v739 = (unsigned __int8 *)(a1 + 1016);
  if (v733) {
    v739 = (unsigned __int8 *)v733;
  }
  sub_100024B74((uint64_t)v587, (char)"reslide shared cache", *v739, v734, v735, v736, v737, v738);
  sub_100024B74( (uint64_t)v587,  (char)"disable resliding",  (*(void *)(a1 + 1352) >> 52) & 1LL,  v740,  v741,  v742,  v743,  v744);
  sub_100024B74((uint64_t)v587, (char)"extension", (*(void *)(a1 + 1352) >> 34) & 1LL, v745, v746, v747, v748, v749);
  sub_100024B74( (uint64_t)v587,  (char)"nano allocator",  (*(void *)(a1 + 1352) >> 25) & 1LL,  v750,  v751,  v752,  v753,  v754);
  sub_100024B74( (uint64_t)v587,  (char)"enable sec_transition shim",  (*(void *)(a1 + 1352) >> 26) & 1LL,  v755,  v756,  v757,  v758,  v759);
  sub_100024B74((uint64_t)v587, (char)"no initgroups", *(_DWORD *)(a1 + 1352) >> 31, v760, v761, v762, v763, v764);
  sub_100024B74( (uint64_t)v587,  (char)"needs implicit endpoint",  (*(void *)(a1 + 1352) >> 38) & 1LL,  v765,  v766,  v767,  v768,  v769);
  sub_100024B74( (uint64_t)v587,  (char)"platform binary",  (*(void *)(a1 + 1352) >> 40) & 1LL,  v770,  v771,  v772,  v773,  v774);
  sub_100024B74((uint64_t)v587, (char)"is copy", (*(void *)(a1 + 1352) >> 41) & 1LL, v775, v776, v777, v778, v779);
  sub_100024B74( (uint64_t)v587,  (char)"disallow all lookups",  (*(void *)(a1 + 1352) >> 43) & 1LL,  v780,  v781,  v782,  v783,  v784);
  sub_100024B74((uint64_t)v587, (char)"one-shot", (*(_DWORD *)(a1 + 368) >> 5) & 1, v785, v786, v787, v788, v789);
  sub_100024B74( (uint64_t)v587,  (char)"use maximum address space limit (for sanitizers)",  (*(void *)(a1 + 1352) >> 47) & 1LL,  v790,  v791,  v792,  v793,  v794);
  sub_100024B74( (uint64_t)v587,  (char)"null bootstrap port",  (*(void *)(a1 + 1352) >> 49) & 1LL,  v795,  v796,  v797,  v798,  v799);
  sub_100024B74( (uint64_t)v587,  (char)"exponential throttling",  (*(void *)(a1 + 1352) >> 50) & 1LL,  v800,  v801,  v802,  v803,  v804);
  sub_100024B74( (uint64_t)v587,  (char)"abandon during shutdown",  (*(void *)(a1 + 1352) >> 55) & 1LL,  v805,  v806,  v807,  v808,  v809);
  sub_100024B74((uint64_t)v587, (char)"needs proxy", HIWORD(*(void *)(a1 + 1352)) & 1LL, v810, v811, v812, v813, v814);
  sub_100024B74((uint64_t)v587, (char)"has spawn constraint", *(_DWORD *)(a1 + 624) != 0, v815, v816, v817, v818, v819);
  sub_100024B74((uint64_t)v587, (char)"tle system", *(unsigned __int8 *)(a1 + 960) == 1, v820, v821, v822, v823, v824);
  sub_100024B74((uint64_t)v587, (char)"has provenance", *(_DWORD *)(a1 + 608) != 0, v825, v826, v827, v828, v829);
  sub_10003D3A8(a2, v830, v831, v832, v833, v834, v835, v836, v873);
  sub_10003D32C(a2, v17, "properties = %s", v837, v838, v839, v840, v841, *v587);
  sub_10000D938(v587);
  return sub_10003D32C(a2, a3, "}", v842, v843, v844, v845, v846);
}

const char *sub_10002058C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1352);
  if ((v1 & 0x400000000LL) != 0) {
    return "extension";
  }
  if ((v1 & 2) != 0)
  {
    if (sub_1000259FC(*(void *)(a1 + 248))) {
      return "system xpcservice";
    }
    else {
      return "xpcservice";
    }
  }

  else if ((v1 & 0x2000) != 0)
  {
    return "system app";
  }

  else if ((v1 & 0x1000) != 0)
  {
    return "app";
  }

  else if (*(_DWORD *)(a1 + 872) == 1792)
  {
    return "DriverKit";
  }

  else
  {
    return "daemon";
  }

uint64_t sub_100020614(uint64_t a1, FILE *a2, uint64_t a3)
{
  uint64_t v4 = a3 + 1;
  uint64_t v5 = a1 + 1360;
  int64_t v6 = sub_10002058C(a1);
  return sub_10003D32C(a2, v4, "%s : %s", v7, v8, v9, v10, v11, v5, v6);
}

uint64_t sub_100020664( uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
  }
  *(void *)__str = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  if (*(_DWORD *)(a1 + 1128)) {
    snprintf(__str, 0x18uLL, "%d", *(_DWORD *)(a1 + 1128));
  }
  else {
    strcpy(__str, "0");
  }
  *(void *)uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  int v11 = *(_DWORD *)(a1 + 1176);
  if (v11 == 2)
  {
    v15[4] = 0;
    int v13 = 695363112;
    goto LABEL_12;
  }

  if (v11 == 1)
  {
    v15[4] = 0;
    int v13 = 694313256;
    goto LABEL_12;
  }

  if (v11)
  {
    if (sub_10003DA48(a1 + 1176))
    {
      sub_10003DA74((_DWORD *)(a1 + 1176));
      snprintf(v15, 0x18uLL, "%d");
      return sub_10003D32C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1360);
    }

    if (sub_10003DB1C((_DWORD *)(a1 + 1176)))
    {
      sub_10003DB64((_DWORD *)(a1 + 1176));
      snprintf(v15, 0x18uLL, "-%d");
      return sub_10003D32C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1360);
    }

    if (sub_10003DC4C((_DWORD *)(a1 + 1176)))
    {
      v15[4] = 0;
      if (sub_10003DC94(a1 + 1176)) {
        int v13 = 694513704;
      }
      else {
        int v13 = 695495208;
      }
    }

    else if (sub_10003DCEC((_DWORD *)(a1 + 1176)))
    {
      v15[4] = 0;
      int v13 = 695427880;
    }

    else
    {
      if (!sub_10003DCC0(a1 + 1176))
      {
        __int16 v12 = 63;
        goto LABEL_9;
      }

      v15[4] = 0;
      int v13 = 695232040;
    }

LABEL_12:
    *(_DWORD *)uint64_t v15 = v13;
    return sub_10003D32C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1360);
  }

  __int16 v12 = 45;
LABEL_9:
  *(_WORD *)uint64_t v15 = v12;
  return sub_10003D32C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1360);
}

  sub_10000E624(570425400LL);
  uint64_t v9 = 22LL;
  if (xpc_dictionary_expects_reply(xdict) && (v10 & 2) == 0)
  {
    bzero(v48, 0x400uLL);
    sub_10002CAE0(*(_DWORD *)(a2 + 20), v48);
    if ((v10 & 0x8000000000000000LL) != 0)
    {
      uint64_t v19 = 0;
      uint64_t v20 = "System reboot";
      uint64_t v21 = "system reboot";
      goto LABEL_22;
    }

    if ((v10 & 0x2000000000000000LL) != 0)
    {
      if (sub_10000D114(a2, 18LL))
      {
        if (sub_100001FC8(7))
        {
          sub_10002587C((uint64_t)a1, 65540, "cannot userspace reboot while in REM", v14, v15, v16, v17, v18, v45);
        }

        else if (v11 != 4)
        {
          if ((v10 & 0x200000000000000LL) != 0) {
            goto LABEL_30;
          }
          uint64_t v19 = 1;
          uint64_t v20 = "Userspace reboot";
          uint64_t v21 = "userspace reboot";
LABEL_22:
          if ((v10 & 0x200000000000000LL) != 0)
          {
            if ((v10 & 0x4000000000000000LL) == 0 || !byte_10006A919) {
              goto LABEL_30;
            }
          }

          else
          {
            sub_10002587C((uint64_t)a1, 196613, "%s initiated by: %s", v14, v15, v16, v17, v18, (char)v20);
            sub_10002587C((uint64_t)a1, 5, "%s: flags = 0x%llx, caller = %s", v23, v24, v25, v26, v27, (char)v21);
            if (byte_10006A97D)
            {
              sub_10002587C( (uint64_t)a1,  65540,  "system is in sudden shutdown mode. All processes will be SIGKILLed immediately.",  v28,  v29,  v30,  v31,  v32,  v46);
              sub_10002587C( (uint64_t)a1,  5,  "system is in sudden shutdown mode. All processes will be SIGKILLed immediately.",  v33,  v34,  v35,  v36,  v37,  v47);
            }

            if ((v10 & 0x4000000000000000LL) == 0)
            {
              uint64_t v9 = sub_100010F9C(v19, 0LL, v10);
              if ((_DWORD)v9) {
                return v9;
              }
              sub_100031678((mach_port_context_t)a1);
LABEL_30:
              uint64_t v9 = 0LL;
              *a4 = xpc_dictionary_create_reply(xdict);
              return v9;
            }

            if (!byte_10006A919)
            {
              xpc_object_t reply = xpc_dictionary_create_reply(xdict);
              dword_10006A548 = *(_DWORD *)(a2 + 20);
              sub_100031578(a1, (uint64_t)reply, v39, v40, v41, v42, v43, v44);
              return 0LL;
            }
          }

          return 37LL;
        }

        return 45LL;
      }
    }

    else
    {
      if ((v10 & 0x4000000000000000LL) == 0)
      {
        uint64_t v19 = 0;
        uint64_t v20 = "System shutdown";
        uint64_t v21 = "system shutdown";
        goto LABEL_22;
      }

      if (sub_10000D114(a2, 12LL))
      {
        uint64_t v19 = 0;
        uint64_t v20 = "Obliteration";
        uint64_t v21 = "obliteration";
        goto LABEL_22;
      }
    }

    return 144LL;
  }

  return v9;
}

  uint64_t v10 = sub_10003B408(a1);
  if (v10)
  {
    int v11 = v10;
    if (*(_BYTE *)(a1 + 20)) {
      sub_10000D024("%s|%s", off_100069A30, v10);
    }
    if (*(_BYTE *)(a1 + 23))
    {
      __int16 v12 = *(unsigned int *)(a1 + 16);
      if (v12 < 8)
      {
        if (*(void *)(a1 + 24)) {
          int v13 = *(const char **)(a1 + 24);
        }
        else {
          int v13 = "launchd";
        }
        if (record_system_event_as_kernel(byte_1000495EA[v12], 1LL, v13, *(void *)(a1 + 48)))
        {
          __error();
          sub_10003AB08(3, "Unable to record system event. Result: %d errno: %d Message: %s");
        }
      }

      else
      {
        sub_10003AB08(3, "Log level out of bounds for system state conversion: %d");
      }
    }

    if (*(_BYTE *)(a1 + 22))
    {
      uint64_t v14 = (FILE *)qword_10006A590;
      if (qword_10006A590 || (uint64_t v14 = sub_10003458C(off_100069A18[0]), (qword_10006A590 = (uint64_t)v14) != 0))
      {
        uint64_t v15 = strlen(v11);
        fwrite(v11, 1uLL, v15, v14);
        if (qword_100069A60 >= 1)
        {
          qword_10006A640 += v15;
          if (qword_10006A640 >= qword_100069A60)
          {
            sub_100036EEC((FILE *)qword_10006A590);
            qword_10006A590 = 0LL;
            qword_10006A640 = 0LL;
          }
        }
      }
    }

    free(v11);
  }

  else
  {
    sub_10000CEB8("_launch_log_format failed");
  }

  __break(0x5519u);
LABEL_13:
  uint64_t v5 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))( v1,  "[%s]: %s\n",  "der_vm_BOOL_from_context",  "Attempting to select a BOOLean value from a non-BOOLean DER object");
  return sub_100045574(v5);
}

    uint64_t v9 = *(void (**)(unint64_t, const char *, ...))(v3 + 24);
    if (!v9) {
      return 1LL;
    }
    if (!v3 || v3 < v3 + 64)
    {
      v9(v3, "[%s]: %s\n", "der_vm_execute_match_integer", "BOOL decode failure");
      return 1LL;
    }

uint64_t sub_100020858(uint64_t a1, const char *a2)
{
  for (uint64_t i = *(void *)(a1 + 144); i; uint64_t i = *(void *)(i + 16))
  {
    uint64_t v4 = (const char *)sub_100035988(i);
    if (!strcmp(v4, a2)) {
      break;
    }
  }

  return i;
}

char *sub_10002089C(unsigned int a1)
{
  if (a1 >= 0x11) {
    sub_100046EB4();
  }
  return off_1000643C0[a1];
}

uint64_t sub_1000208C4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1104) = a2;
  return result;
}

BOOL sub_1000208CC(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 1104);
  if (v2) {
    BOOL v3 = v2 == a2;
  }
  else {
    BOOL v3 = 1;
  }
  return !v3;
}

BOOL sub_1000208E0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1104) != 0;
}

uint64_t sub_1000208F0(uint64_t a1, unsigned __int8 *uu1)
{
  for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 40))
  {
  }

  return i;
}

uint64_t sub_100020930(mach_port_context_t a1)
{
  if ((*(void *)(a1 + 1352) & 0x10000000) != 0) {
    sub_1000476A0(*(void *)(a1 + 1352) & 0x10000000LL);
  }
  uint64_t result = *(unsigned int *)(a1 + 1312);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10000AB70(1u, 0, a1);
    *(_DWORD *)(a1 + 1312) = result;
  }

  return result;
}

uint64_t sub_100020978(mach_port_context_t guard)
{
  if ((*(_BYTE *)(guard + 1355) & 0x10) == 0) {
    sub_100046EB4();
  }
  uint64_t result = *(unsigned int *)(guard + 1312);
  if ((_DWORD)result)
  {
    uint64_t result = sub_10000AC84(result, 0, guard);
    if ((_DWORD)result) {
      sub_100046EE0(result);
    }
    *(_DWORD *)(guard + 1312) = 0;
  }

  return result;
}

uint64_t sub_1000209C0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1358) >> 7;
}

uint64_t sub_1000209CC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (byte_100069A6C) {
    return sub_1000209FC(a1, a2, a3, a4, a5, a6, a7, a8) ^ 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000209FC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a1 + 1358) & 1) == 0)
  {
    int v8 = *(_DWORD *)(a1 + 676);
    if ((v8 || (v10 = *(void *)(a1 + 256)) != 0 && (int v8 = *(_DWORD *)(v10 + 676)) != 0) && v8 != -1)
    {
      uint64_t v9 = "it has a control port set";
    }

    else if ((*(_BYTE *)(a1 + 1298) & 0xA) != 0 || *(void *)(a1 + 1232))
    {
      uint64_t v9 = "it is being debugged";
    }

    else
    {
      if (!*(void *)(a1 + 1248)) {
        return 0LL;
      }
      uint64_t v9 = "its working directory has been overridden";
    }

    sub_10001A4D8(a1, 5, "service will use proxy because %s", a4, a5, a6, a7, a8, (char)v9);
  }

  return 1LL;
}

uint64_t sub_100020A9C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 1357) & 0x20) != 0) {
    return *(unsigned int *)(a1 + 1304);
  }
  else {
    return sub_10002B1AC(*(void *)(a1 + 248), (const void *)(a1 + 1360));
  }
}

uint64_t sub_100020ABC(uint64_t a1)
{
  return *(void *)(a1 + 1336);
}

uint64_t sub_100020AC4(uint64_t a1)
{
  uint64_t result = sub_10001A1AC(a1);
  if (result) {
    return os_map_str_find(result, *(void *)(a1 + 576));
  }
  return result;
}

void sub_100020AF8(uint64_t a1)
{
  int v2 = *(void **)(a1 + 40);
  BOOL v3 = *(void **)(a1 + 24);
  sub_10003E820(*(unsigned int *)(a1 + 16), v3);
  xpc_release(v3);
  sub_10001685C(v2);
  free((void *)a1);
}

xpc_object_t sub_100020B50(void *a1, __uint64_t a2)
{
  __uint64_t v4 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
  xpc_object_t v5 = 0LL;
  if (xpc_array_get_count(a1))
  {
    size_t v6 = 0LL;
    do
    {
      uunint64_t int64 = xpc_array_get_uint64(a1, v6);
      uint64_t v8 = uint64;
      if (v4 < uint64)
      {
        _os_assumes_log(uint64 - v4);
      }

      else if (v4 - uint64 < a2)
      {
        if (!v5) {
          xpc_object_t v5 = xpc_array_create(0LL, 0LL);
        }
        xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, v8);
      }

      ++v6;
    }

    while (v6 < xpc_array_get_count(a1));
  }

  return v5;
}

void sub_100020C0C(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 424);
  if (v2 != a2)
  {
    if (v2 == 2 && a2 != 0 && a2 != 3) {
      sub_1000476BC(a2);
    }
    *(_BYTE *)(a1 + 424) = a2;
    if (a2 == 1) {
      sub_10001A394(a1, 0LL, 0LL);
    }
    char v6 = sub_100020C90(a1);
    sub_10001A4D8(a1, 5, "service state: %s", v7, v8, v9, v10, v11, v6);
  }

const char *sub_100020C90(uint64_t a1)
{
  switch(*(_BYTE *)(a1 + 424))
  {
    case 1:
      uint64_t result = "spawn scheduled";
      break;
    case 2:
      uint64_t result = "spawning";
      break;
    case 3:
      if ((*(_BYTE *)(a1 + 1168) & 0x80) != 0) {
        uint64_t result = "xpcproxy";
      }
      else {
        uint64_t result = "spawned";
      }
      break;
    case 4:
      uint64_t result = "running";
      break;
    case 5:
      uint64_t result = "SIGTERMed";
      break;
    case 6:
      uint64_t result = "SIGKILLed";
      break;
    case 7:
      uint64_t result = "languishing";
      break;
    case 8:
      uint64_t result = "exited";
      break;
    default:
      uint64_t result = "not running";
      break;
  }

  return result;
}

uint64_t sub_100020D38(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 424) != 1) {
    sub_100046EB4();
  }
  sub_100020C0C(a1, 2);
  if (*(_BYTE *)(a1 + 424) != 2) {
    sub_100046EB4();
  }
  if (*(void *)(a1 + 952))
  {
    __uint64_t v4 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    sub_10001A0C4(*(void *)(a1 + 952), v4 / 0xF4240);
  }

  uint64_t v5 = sub_100020AC4(a1);
  uint64_t v13 = a1 + 1016;
  if (v5) {
    uint64_t v13 = v5;
  }
  *(_BYTE *)(v13 + 1) = 0;
  *(void *)(a1 + 1352) &= ~0x800000uLL;
  *(_DWORD *)(a1 + 1136) = a2;
  *(void *)(a1 + 1164) = *(void *)(a1 + 1164) & 0xFFFFFFF7FFFFFFFFLL | ((unint64_t)((*(unsigned __int8 *)(a1 + 1298) >> 1) & 1) << 35);
  uint64_t result = sub_1000209FC(a1, v6, v7, v8, v9, v10, v11, v12);
  uint64_t v15 = 0x8000000000LL;
  if (!(_DWORD)result) {
    uint64_t v15 = 0LL;
  }
  *(void *)(a1 + 1164) = *(void *)(a1 + 1164) & 0xFFFFFD7FFFFFFFFFLL | v15;
  return result;
}

uint64_t sub_100020E18(uint64_t a1)
{
  *(void *)&v103[116] = a1;
  uint64_t v8 = *(void *)(a1 + 152);
  if (v8)
  {
    unint64_t v9 = 0LL;
    do
    {
      if ((*(_BYTE *)(v8 + 88) & 0x40) == 0)
      {
        v106[v9++] = sub_10003F1E0(v8, 1, v2, v3, v4, v5, v6, v7);
        if (v9 == 128)
        {
          sub_10001A4D8(a1, 4, "Skipping remaining service endpoints for importance boosting.", v3, v4, v5, v6, v7, v96);
          goto LABEL_20;
        }
      }

      uint64_t v8 = *(void *)(v8 + 16);
    }

    while (v8);
    if (v9 <= 0x7F) {
      goto LABEL_9;
    }
    goto LABEL_20;
  }

  unint64_t v9 = 0LL;
LABEL_9:
  uint64_t v10 = *(void *)(a1 + 176);
  if (v10)
  {
    while (1)
    {
      if ((*(_BYTE *)(v10 + 88) & 0x40) == 0)
      {
        v106[v9++] = sub_10003F1E0(v10, 1, v2, v3, v4, v5, v6, v7);
        if (v9 == 128) {
          break;
        }
      }

      uint64_t v10 = *(void *)(v10 + 16);
      if (!v10)
      {
        if (v9 > 0x7F) {
          goto LABEL_21;
        }
        goto LABEL_14;
      }
    }

LABEL_14:
  uint64_t v11 = *(void *)(a1 + 184);
  if (!v11) {
    goto LABEL_22;
  }
  while (1)
  {
    if ((*(_BYTE *)(v11 + 88) & 0x40) == 0)
    {
      v106[v9++] = sub_10003F1E0(v11, 1, v2, v3, v4, v5, v6, v7);
      if (v9 == 128) {
        break;
      }
    }

    uint64_t v11 = *(void *)(v11 + 16);
    if (!v11) {
      goto LABEL_22;
    }
  }

    qword_10006A5B0 = (uint64_t)sub_1000167B0((void *)v2);
    qword_10006A5B8 = 0LL;
    uint64_t v14 = 0;
    sub_10003B12C(v2, &v14);
    if (v14) {
      ++v4;
    }
    goto LABEL_16;
  }

  uint64_t v4 = 0LL;
  uint64_t v3 = 0LL;
LABEL_21:
  if (v3 == v0)
  {
    if (v1)
    {
LABEL_23:
      unint64_t v9 = sub_100012884("%lld file logs dropped [in-flight %lld]: %lld os_log_simple logs dropped", v1, v0, v4);
      uint64_t v10 = 4;
      goto LABEL_27;
    }
  }

  else
  {
    _os_assumes_log(0LL);
    if (v1) {
      goto LABEL_23;
    }
  }

  if (v0 < dword_100069A68) {
    goto LABEL_29;
  }
  unint64_t v9 = sub_100012884("Flushed %lld logs [limit: %d]", v0, dword_100069A68);
  uint64_t v10 = 5;
LABEL_27:
  uint64_t v11 = sub_10003B038(v10, 0LL, (__darwin_time_t)v9, 0LL);
  uint64_t v12 = v11;
  if (v11)
  {
    sub_10003B12C((uint64_t)v11, 0LL);
    sub_10001685C(v12);
  }

LABEL_21:
  sub_10001A4D8(a1, 4, "Skipping remaining instance endpoints for importance boosting.", v3, v4, v5, v6, v7, v96);
LABEL_22:
  unint64_t v107 = v9;
  if (*(void *)(a1 + 864))
  {
    uint64_t v12 = sub_1000297F8(*(void *)(a1 + 248));
    if (v12)
    {
      mach_port_name_t v108 = sub_10003F1E0(v12, 1, v13, v14, v15, v16, v17, v18);
      int v19 = sub_10000AC54(v108);
      if (v19) {
        sub_100046EE0(v19);
      }
    }

    else
    {
      sub_10001A4D8( a1,  3,  "Could not find exception endpoint for service: %s",  v14,  v15,  v16,  v17,  v18,  *(void *)(a1 + 864));
    }
  }

  unint64_t v20 = v107;
  mach_port_t v21 = v108;
  uint64_t v22 = (unint64_t *)(a1 + 1164);
  if ((*(void *)(a1 + 1164) & 0x800000000LL) != 0) {
    __int16 v23 = 16524;
  }
  else {
    __int16 v23 = 16396;
  }
  if (posix_spawnattr_setflags(&v100, v23)) {
    _os_assumes_log_ctx(sub_10001C1B0, a1);
  }
  v117[0] = 0;
  if (posix_spawnattr_setsigmask(&v100, v117)) {
    _os_assumes_log_ctx(sub_10001C1B0, a1);
  }
  v114[0] = -1;
  if (posix_spawnattr_setsigdefault(&v100, v114)) {
    _os_assumes_log_ctx(sub_10001C1B0, a1);
  }
  unsigned int v24 = *(_DWORD *)(a1 + 872);
  if (v24 == 1792) {
    uint64_t v25 = 1024LL;
  }
  else {
    uint64_t v25 = v24;
  }
  uint64_t v26 = *(unsigned int *)(a1 + 876);
  if ((_DWORD)v26)
  {
    int v27 = posix_spawnattr_set_darwin_role_np(&v100, v26);
    if (v27) {
      sub_100046EE0(v27);
    }
  }

  if (*(void *)(a1 + 1344))
  {
    int v28 = posix_spawnattr_set_conclave_id_np(&v100);
    if (v28) {
      sub_100046EE0(v28);
    }
  }

  uint64_t v29 = *(void *)(a1 + 952);
  if (v29)
  {
    unsigned int v30 = sub_10001A114(v29);
    if (v30)
    {
      uint64_t v31 = 0LL;
      __int128 v111 = 0u;
      __int128 v112 = 0u;
      uint64_t v32 = v30;
      *(_OWORD *)__str = 0u;
      __int128 v110 = 0u;
      do
      {
        __str[v31] = sub_10001A11C(*(void *)(a1 + 952), v31);
        ++v31;
      }

      while (v32 != v31);
    }
  }

  *(void *)__str = sub_10002AB90(*(void *)(a1 + 248), a1, (*(void *)(a1 + 1352) >> 30) & 1);
  *(void *)&__str[2] = v33;
  sub_10000D454(a1, (uint64_t)&v100, 0LL, (uint64_t)__str);
  *(void *)__str = sub_10002ACE8(*(void *)(a1 + 248), a1);
  *(void *)&__str[2] = v34;
  sub_10000D454(a1, (uint64_t)&v100, 1LL, (uint64_t)__str);
  if ((*(_BYTE *)(a1 + 1357) & 0x20) != 0) {
    uint64_t v35 = *(unsigned int *)(a1 + 1304);
  }
  else {
    uint64_t v35 = sub_10002B1AC(*(void *)(a1 + 248), (const void *)(a1 + 1360));
  }
  if ((_DWORD)v35 != -1)
  {
  }

  if (v21 - 1 <= 0xFFFFFFFD)
  {
    int v36 = sub_10000ADFC(&v100, v21);
    if (v36) {
      sub_100046EE0(v36);
    }
  }

  ++*(_DWORD *)(a1 + 1000);
  uint64_t v37 = mach_absolute_time();
  uint64_t v38 = sub_100020AC4(a1);
  uint64_t v39 = a1 + 1016;
  if (v38) {
    uint64_t v40 = v38;
  }
  else {
    uint64_t v40 = a1 + 1016;
  }
  *(void *)(v40 + 8) = v37;
  uint64_t v41 = sub_100020AC4(a1);
  if (v41) {
    uint64_t v42 = v41;
  }
  else {
    uint64_t v42 = a1 + 1016;
  }
  if (v42 == v39) {
    uint64_t v43 = a1 + 1176;
  }
  else {
    uint64_t v43 = v42 + 32;
  }
  int v44 = sub_10003DBAC(v43);
  uint64_t v45 = sub_100020AC4(a1);
  if (v44)
  {
    if (v45) {
      uint64_t v51 = v45;
    }
    else {
      uint64_t v51 = a1 + 1016;
    }
    if (v51 == v39) {
      uint64_t v52 = (_DWORD *)(a1 + 1176);
    }
    else {
      uint64_t v52 = (_DWORD *)(v51 + 32);
    }
    if (!sub_10003DC4C(v52) && (*(_BYTE *)(a1 + 1358) & 4) != 0)
    {
      uint64_t v53 = sub_100020AC4(a1);
      if (v53) {
        uint64_t v54 = v53;
      }
      else {
        uint64_t v54 = a1 + 1016;
      }
      sub_100021E50((xpc_object_t *)(v54 + 16));
    }

    uint64_t v55 = sub_100020AC4(a1);
    if (v55) {
      uint64_t v56 = v55;
    }
    else {
      uint64_t v56 = a1 + 1016;
    }
    if (v56 == v39) {
      uint64_t v57 = (_DWORD *)(a1 + 1176);
    }
    else {
      uint64_t v57 = (_DWORD *)(v56 + 32);
    }
    if (!sub_10003DC4C(v57)
      || ((uint64_t v58 = sub_100020AC4(a1)) != 0 ? (v59 = v58) : (v59 = a1 + 1016),
          v59 != v39 ? (uint64_t v60 = v59 + 32) : (uint64_t v60 = a1 + 1176),
          sub_10003DC64(v60)))
    {
      if ((*(_BYTE *)(a1 + 1359) & 4) != 0)
      {
        uint64_t v61 = sub_100020AC4(a1);
        if (v61) {
          uint64_t v62 = v61;
        }
        else {
          uint64_t v62 = a1 + 1016;
        }
        sub_100021E50((xpc_object_t *)(v62 + 24));
      }
    }
  }

  else if ((*(_BYTE *)(a1 + 1359) & 4) != 0)
  {
    uint64_t v63 = v45 ? v45 : a1 + 1016;
    if (*(void *)(v63 + 24))
    {
      sub_10001A4D8(a1, 5, "Reseting consecutive crash history", v46, v47, v48, v49, v50, v96);
      xpc_release(*(xpc_object_t *)(v63 + 24));
      *(void *)(v63 + 24) = 0LL;
    }
  }

  char v64 = sub_10002089C(*(_DWORD *)(a1 + 1136));
  sub_10001A4D8(a1, 5, "launching: %s", v65, v66, v67, v68, v69, v64);
  sub_100011968();
  uint64_t v70 = qword_100069D00;
  *(void *)(a1 + 24) = qword_100069D00;
  if (v70) {
    *(void *)(v70 + 32) = a1 + 24;
  }
  qword_100069D00 = a1;
  *(void *)(a1 + 32) = &qword_100069D00;
  if ((*(_BYTE *)(a1 + 1168) & 0x80) == 0)
  {
    v105[1] = sub_100002290(a1, v104, v105) - 240;
    v104[1] = *(void *)(a1 + 1280);
    *(void *)(a1 + 1280) = 0LL;
    v101[140] = *(posix_spawn_file_actions_t *)(a1 + 696);
    int v102 = *(_DWORD *)(a1 + 768);
    __memcpy_chk(v103, a1 + 704, 4LL * v102, 692LL);
    for (uint64_t i = 0LL; i != 3; ++i)
    {
      int v72 = *(_DWORD *)(a1 + 4 * i + 664);
      if (v72 != -1)
      {
        if ((_DWORD)i == v72)
        {
          int v73 = posix_spawn_file_actions_addinherit_np(v101, v72);
          if (v73) {
            sub_100046EE0(v73);
          }
        }

        else
        {
          int v74 = posix_spawn_file_actions_adddup2(v101, v72, i);
          if (v74) {
            sub_100046EE0(v74);
          }
        }
      }
    }

    *uint64_t v22 = *v22 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(v105[0] + 108LL) << 34);
    sub_100021B6C(a1);
    *v22 |= (unint64_t)&_mh_execute_header;
    *(_DWORD *)(a1 + 1132) = 0;
    uint64_t v75 = sub_100012670(&v100, 0x728uLL);
    uint64_t v76 = sub_1000386B0(a1);
    uint64_t v77 = (dispatch_queue_s *)sub_100011974();
    v98[0] = _NSConcreteStackBlock;
    v98[1] = 0x40000000LL;
    v98[2] = sub_100021C24;
    v98[3] = &unk_100064488;
    v98[4] = v75;
    char v78 = sub_1000342FC(v76, v77, v98);
    uint64_t v84 = 0LL;
    if (v76 && (v78 & 1) == 0)
    {
      sub_10001A4D8(a1, 5, "couldn't handoff a spawn, asynced away", v79, v80, v81, v82, v83, v97);
      return 0LL;
    }

    return v84;
  }

  pid_t v99 = 0;
  uint64_t v85 = off_100069A28[0];
  *(void *)uint64_t v117 = "xpcproxy";
  uint64_t v118 = a1 + 1360;
  uint64_t v119 = 0LL;
  uint64_t v120 = 0LL;
  *(void *)uint64_t v114 = 0LL;
  uint64_t v115 = 0LL;
  uint64_t v116 = 0LL;
  if ((_UNKNOWN *)sub_10002A994(*(void *)(a1 + 248)) == &unk_100069750)
  {
    uint64_t v86 = sub_10002A99C(*(void *)(a1 + 248));
    snprintf((char *)v114, 0x18uLL, "%lu", v86);
    uint64_t v119 = v114;
  }

  if (posix_spawn_file_actions_addopen(v101, 0, "/dev/console", 0, 0) == -1) {
    sub_1000470C8();
  }
  if (posix_spawn_file_actions_addopen(v101, 1, "/dev/console", 1, 0) == -1) {
    sub_1000470C8();
  }
  if (posix_spawn_file_actions_addopen(v101, 2, "/dev/console", 2, 0) == -1) {
    sub_1000470C8();
  }
  unint64_t v113 = 0LL;
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v110 = 0u;
  sub_100041778((*(void *)(a1 + 1352) >> 24) & 0x400LL, (char *)__str);
  unsigned int v87 = *(_DWORD *)(a1 + 676);
  if (!v87)
  {
    uint64_t v88 = *(void *)(a1 + 256);
    if (!v88) {
      goto LABEL_138;
    }
    unsigned int v87 = *(_DWORD *)(v88 + 676);
  }

  if (v87 - 1 < 0xFFFFFFFE)
  {
    unint64_t v113 = __PAIR64__(v87, dword_10006A940);
    int v89 = posix_spawnattr_set_registered_ports_np(&v100, &v113, 2LL);
    if (v89) {
      sub_100046EE0(v89);
    }
    goto LABEL_139;
  }

      if (value)
      {
        uint64_t v16 = (void *)v15[7];
        if (v16)
        {
          if (xpc_equal(value, v16)) {
            goto LABEL_30;
          }
        }
      }

      sub_10003AB08(5, "Remove subscription with token %llu", v15[9]);
      uint64_t v17 = v15[2];
      if (v17) {
        *(void *)(v17 + 24) = v15[3];
      }
      *(void *)v15[3] = v17;
      v15[2] = -1LL;
      v15[3] = -1LL;
      sub_100035B04(v15, 1, a4);
      sub_10001685C(v15);
LABEL_27:
      if (value) {
        uint64_t v15 = sub_100035CF0(v9, string, v12, value, a4);
      }
      else {
        uint64_t v15 = 0LL;
      }
LABEL_30:
      uint64_t result = 0LL;
      *a5 = v15;
      return result;
    }

    __break(0x5519u);
LABEL_22:
    uint64_t v7 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))( v1,  "[%s]: %s\n",  "der_vm_integer_from_context",  "Attempting to select an integer value from a non-integer DER object");
    return sub_1000453DC(v7);
  }

  return 0LL;
}

LABEL_138:
  unint64_t v113 = 0LL;
LABEL_139:
  uint64_t v84 = posix_spawnp(&v99, v85, v101, &v100, (char *const *)v117, (char *const *)qword_10006A968);
  if (!(_DWORD)v84 && v99 <= 0)
  {
    sub_10001A4D8(a1, 3, "posix_spawnp() returned 0 but pid=%d", v90, v91, v92, v93, v94, v99);
    uint64_t v84 = 153LL;
  }

  sub_100021E9C((uint64_t)&v100, v84);
  sub_10001CCBC(a1, v99, v84, 0LL);
  return v84;
}

void sub_1000217AC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = (dispatch_queue_s *)sub_100011938();
  uint64_t v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v6);
  dispatch_time_t v8 = dispatch_time(0LL, 1000000000 * a2);
  dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  sub_1000167B0((void *)a1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_10002197C;
  handler[3] = &unk_100064448;
  handler[4] = a1;
  dispatch_source_set_event_handler(v7, handler);
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 0x40000000LL;
  v37[2] = sub_100021A50;
  v37[3] = &unk_100064468;
  v37[4] = a1;
  v37[5] = v7;
  dispatch_source_set_mandatory_cancel_handler(v7, v37);
  dispatch_activate(v7);
  *(void *)(a1 + 800) = v7;
  *(_DWORD *)(a1 + 796) = a3;
  *(void *)(a1 + 1164) = *(void *)(a1 + 1164) & 0xFFFFFFFF000000FFLL | ((_DWORD)a2 << 8);
  unint64_t v9 = sub_10001C2A0(a1, 1);
  uint64_t v10 = (char **)sub_10000D8E8(0x40uLL);
  sub_10000D960((uint64_t)v10, "%s throttled", v11, v12, v13, v14, v15, v16, (char)v9);
  uint64_t v17 = sub_10003D968(a1 + 1176);
  if (v17) {
    sub_10000D960((uint64_t)v10, " after %s", v18, v19, v20, v21, v22, v23, (char)v17);
  }
  size_t v24 = sub_100001A44(1, *v10);
  if (!v25) {
    *(void *)(a1 + 816) = v24;
  }
  sub_10000D938((void **)v10);
  free(v9);
  sub_100021A84(a1, 1, v26, v27, v28, v29, v30, v31);
  sub_100020C0C(a1, 1);
  sub_10001A4D8(a1, 5, "service throttled by %llu seconds", v32, v33, v34, v35, v36, a2);
}

void sub_10002197C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 800));
  *(void *)(v1 + 800) = 0LL;
  dispatch_time_t v8 = *(dispatch_semaphore_t **)(v1 + 816);
  if (v8)
  {
    sub_100001CA8(v8);
    *(void *)(v1 + 816) = 0LL;
  }

  sub_100021A84(v1, 0, v2, v3, v4, v5, v6, v7);
  uint64_t v9 = sub_100020AC4(v1);
  uint64_t v10 = v1 + 1016;
  if (v9) {
    uint64_t v10 = v9;
  }
  *(_BYTE *)(v10 + 1) = 1;
  uint64_t v11 = *(unsigned int *)(v1 + 796);
  *(_DWORD *)(v1 + 796) = 0;
  uint64_t v12 = sub_10001A53C(v1, v11);
  sub_10001A4D8(v1, 5, "deferred event: domain spawn response: %d", v13, v14, v15, v16, v17, v12);
  if ((_DWORD)v12 && (_DWORD)v12 != 36)
  {
    if ((_DWORD)v12 == 139) {
      sub_100039448("deferral event on service in penalty box");
    }
    xpc_strerror(v12);
    sub_10001A4D8(v1, 3, "Deferred spawn of service failed: %d: %s", v18, v19, v20, v21, v22, v12);
  }

void sub_100021A50(uint64_t a1)
{
}

void sub_100021A84( uint64_t a1, integer_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (((*(_BYTE *)(a1 + 1359) & 0x20) == 0) == a2)
  {
    for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
      sub_1000402E8(i, a2, a3, a4, a5, a6, a7, a8);
    for (uint64_t j = *(void *)(a1 + 176); j; uint64_t j = *(void *)(j + 16))
      sub_1000402E8(j, a2, a3, a4, a5, a6, a7, a8);
    for (uint64_t k = *(void *)(a1 + 184); k; uint64_t k = *(void *)(k + 16))
      sub_1000402E8(k, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v14 = 0x2000000000000000LL;
    if (!a2) {
      uint64_t v14 = 0LL;
    }
    *(void *)(a1 + 1352) = *(void *)(a1 + 1352) & 0xDFFFFFFFFFFFFFFFLL | v14;
  }

  else
  {
    uint64_t v10 = "unmarked";
    if (a2) {
      uint64_t v10 = "marked";
    }
    sub_10001A4D8(a1, 7, "Service already %s as throttled", a4, a5, a6, a7, a8, (char)v10);
  }

double sub_100021B6C(uint64_t a1)
{
  *(void *)(a1 + 1232) = 0LL;
  uint64_t v2 = *(void **)(a1 + 1240);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 1240) = 0LL;
  }

  free(*(void **)(a1 + 1248));
  *(void *)(a1 + 1248) = 0LL;
  uint64_t v3 = *(void **)(a1 + 1256);
  if (v3)
  {
    xpc_release(v3);
    *(void *)(a1 + 1256) = 0LL;
  }

  free(*(void **)(a1 + 1264));
  *(void *)(a1 + 1264) = 0LL;
  uint64_t v4 = *(void **)(a1 + 1280);
  if (v4)
  {
    xpc_release(v4);
    *(void *)(a1 + 1280) = 0LL;
  }

  mach_port_name_t v5 = *(_DWORD *)(a1 + 1272);
  if (v5)
  {
    *(_DWORD *)(a1 + 1272) = 0;
  }

  *(_WORD *)(a1 + 1296) = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(a1 + 1288) = 0xFFFFFFFFLL;
  *(_BYTE *)(a1 + 1298) &= 0xC8u;
  return result;
}

void sub_100021C24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (dispatch_queue_s *)sub_100011974();
  dispatch_assert_queue_V2(v2);
  *(void *)(v1 + 1208) = _xpc_spawnattr_unpack_string( *(void *)(v1 + 1280),  *(void *)(v1 + 1288),  *(_DWORD *)(*(void *)(v1 + 1280) + 4LL));
  if (*(_DWORD *)(v1 + 1128) == -101) {
    uid_t v3 = 0;
  }
  else {
    uid_t v3 = *(_DWORD *)(v1 + 1128);
  }
  bzero(block, 0x1090uLL);
  uint64_t v4 = sub_100017120(v3, (uint64_t)block);
  if ((_DWORD)v4)
  {
    LODWORD(v9) = v4;
    sub_10001BC88(v1, v4, 0LL, 3019, 0LL, "launch_kern_credentials_resolve_by_uid(%d) failed", v7, v8, v3);
  }

  else
  {
    LODWORD(v9) = sub_10000FAD4(v1, *(void *)(v1 + 1280), *(void *)(v1 + 1288), (uint64_t)block, v5, v6, v7, v8);
    if (!(_DWORD)v9)
    {
      LODWORD(v9) = sub_1000105EC( (posix_spawnattr_t *)v1,  *(void *)(v1 + 1280),  *(void *)(v1 + 1288),  *(xpc_object_t *)(v1 + 1264),  v10,  v11,  v12,  v13);
      if (!(_DWORD)v9)
      {
        uint64_t v17 = *(void **)(v1 + 1272);
        if (!v17 || (LODWORD(v9) = sub_10001078C(v1, v17), !(_DWORD)v9))
        {
          LODWORD(v9) = sub_1000108E0(v1, *(void *)(v1 + 1280), *(void *)(v1 + 1288), 0LL, 0LL);
          if (!(_DWORD)v9)
          {
            if (((*(void *)(v1 + 1256) + 1132LL) & 3) != 0) {
              sub_100046EB4();
            }
            if ((*(_DWORD *)(*(void *)(v1 + 1280) + 236LL) & 0x800) != 0) {
              uint64_t v18 = &_posix_spawnp;
            }
            else {
              uint64_t v18 = &_posix_spawn;
            }
            uint64_t v9 = ((uint64_t (*)(void))v18)();
            if ((_DWORD)v9) {
              sub_10001BC88(v1, v9, 0LL, 3055, 0LL, "posix_spawn(%s) failed", v19, v20, *(void *)(v1 + 1208));
            }
          }
        }
      }
    }
  }

  uint64_t v14 = *(void *)(v1 + 1256);
  int v15 = *(_DWORD *)(v14 + 1132);
  sub_100021E9C(v1, v9);
  free((void *)v1);
  uint64_t v16 = (dispatch_queue_s *)sub_100011938();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100021F50;
  block[3] = &unk_1000644A8;
  block[4] = v14;
  int v22 = v15;
  int v23 = v9;
  dispatch_async(v16, block);
}

void sub_100021E50(xpc_object_t *a1)
{
  xpc_object_t v1 = *a1;
  if (!*a1)
  {
    xpc_object_t v1 = xpc_array_create(0LL, 0LL);
    *a1 = v1;
  }

  __uint64_t v3 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
  xpc_array_set_uint64(v1, 0xFFFFFFFFFFFFFFFFLL, v3);
}

void sub_100021E9C(uint64_t a1, int a2)
{
  if (a2 && *(void *)(a1 + 1808))
  {
    unint64_t v3 = 0LL;
    do
    {
      ++v3;
    }

    while (v3 < *(void *)(a1 + 1808));
  }

  mach_port_name_t v4 = *(_DWORD *)(a1 + 1816);
  if (v4 + 1 >= 2)
  {
    int v5 = sub_10000AC70(v4);
    if (v5) {
      sub_100046EE0(v5);
    }
  }

  free(*(void **)(a1 + 1280));
  uint64_t v6 = *(void **)(a1 + 1264);
  if (v6) {
    xpc_release(v6);
  }
  uint64_t v7 = *(void **)(a1 + 1272);
  if (v7) {
    xpc_release(v7);
  }
  sub_10000FA00(a1);
}

uint64_t sub_100021F50(uint64_t a1)
{
  return sub_10001CCBC(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), 0LL);
}

uint64_t sub_100021F64(uint64_t a1)
{
  uint64_t result = sub_100020AC4(a1);
  if (result) {
    return sub_100025D50(*(void *)(a1 + 248));
  }
  return result;
}

double sub_100021F98( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10 = *(void *)(a1 + 1164);
  if ((v10 & 0x20000000000LL) != 0)
  {
    sub_10001A4D8(a1, 5, "already handled failed init, ignoring", a4, a5, a6, a7, a8, a9);
  }

  else
  {
    int v11 = a3;
    int v12 = a2;
    *(void *)(a1 + 1164) = v10 | 0x20000000000LL;
    if ((*(_BYTE *)(a1 + 1356) & 0x10) != 0) {
      sub_10001DAE0(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    if (v12 != 111 || v11 == 75)
    {
      if (!v12) {
        sub_100046EB4();
      }
    }

    else
    {
      uint64_t v13 = *(void *)(a1 + 1352);
      if ((v13 & 0x40000000000LL) == 0)
      {
        if (*(_DWORD *)(a1 + 296)) {
          sub_100039448( "unmanaged service given to service interface. pid: %d service: %s",  *(_DWORD *)(a1 + 296),  (const char *)(a1 + 1360));
        }
        if ((v13 & 0x10000000000LL) != 0)
        {
          sub_10001A098(a1);
          sub_10001A4D8( a1,  65539,  "Missing executable detected. Job: '%s' Executable: '%s'",  v14,  v15,  v16,  v17,  v18,  a1 + 80);
        }
      }
    }

    sub_10001A394(a1, 4LL, v12);
    return sub_100021B6C(a1);
  }

  return result;
}

size_t sub_100022094(uint64_t a1, uint64_t a2, size_t a3)
{
  return sub_100001394( a3,  *(_DWORD *)(a1 + 72),  *(const char **)(a1 + 32),  *(_DWORD *)(a1 + 76),  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  *(void *)(a1 + 80),  HIDWORD(*(void *)(a1 + 80)),  *(_DWORD *)(a1 + 88),  *(_WORD *)(a1 + 92));
}

void sub_1000220E0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if ((sub_10003A668(*(_DWORD *)(a1 + 1128)) & 1) != 0 || (*(_BYTE *)(a1 + 1168) & 0xC) != 0)
  {
    sub_10001A4D8(a1, 5, "service is being debugged, not timing out launch", v10, v11, v12, v13, v14, a9);
  }

  else
  {
    if (*(void *)(a1 + 832))
    {
      sub_100016C74(a1);
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 832));
      dispatch_release(*(dispatch_object_t *)(a1 + 832));
      *(void *)(a1 + 832) = 0LL;
    }

    sub_10001A4D8(a1, 4, "Extension is hanging on launch. Killing.", v10, v11, v12, v13, v14, v33);
    sub_10001A4D8(a1, 5, "killing extension hanging on launch", v15, v16, v17, v18, v19, v34);
    uint64_t v20 = sub_10000AD0C();
    unsigned int v26 = sub_10001D678(a1, 2, v20, v21, v22, v23, v24, v25);
    char v27 = v26;
    if (v26 > 0x25 || ((1LL << v26) & 0x2000000009LL) == 0)
    {
      strerror(v26);
      sub_10001A4D8(a1, 4, "Failed to kill hanging extension: %d: %s", v28, v29, v30, v31, v32, v27);
    }
  }

uint64_t sub_1000221F0(void *a1, int *a2)
{
  if (xpc_dictionary_get_BOOL(a1, "self"))
  {
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    xpc_dictionary_get_audit_token(a1, &v25);
    uint64_t v4 = sub_10001CB68(SDWORD1(v26));
    if (v4)
    {
      uint64_t v5 = v4;
      if (sub_10002A938(*(void *)(v4 + 248), a1)) {
        return v5;
      }
      int v6 = 36;
    }

    else
    {
      int v6 = 135;
    }

    uint64_t v5 = 0LL;
LABEL_10:
    *a2 = v6;
    return v5;
  }

  xpc_object_t value = xpc_dictionary_get_value(a1, "service-port");
  if (!value) {
    goto LABEL_13;
  }
  xpc_object_t v8 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_mach_send)
  {
LABEL_7:
    uint64_t v5 = 0LL;
    int v6 = 22;
    goto LABEL_10;
  }

  uint64_t right = xpc_mach_send_get_right(v8);
  if ((right + 1) < 2)
  {
LABEL_13:
    int int64 = xpc_dictionary_get_int64(a1, "pid");
    if (int64)
    {
      uint64_t v5 = sub_10001CB68(int64);
      if (v5) {
        return v5;
      }
    }

    else
    {
      uint64_t v18 = sub_10002A864(a1, 1, a2);
      if (!v18) {
        return 0LL;
      }
      uint64_t v19 = (_DWORD *)v18;
      if (!sub_10002A938(v18, a1))
      {
        uint64_t v5 = 0LL;
        int v6 = 36;
        goto LABEL_10;
      }

      string = (char *)xpc_dictionary_get_string(a1, "name");
      if (!string) {
        goto LABEL_7;
      }
      uint64_t v21 = string;
      uint64_t v5 = (uint64_t)sub_100028EF4(v19, string);
      if (v5 || (uint64_t v5 = (uint64_t)sub_10002ADC0((uint64_t)v19, v21)) != 0)
      {
        uuid = xpc_dictionary_get_uuid(a1, "_instance");
        if (!uuid) {
          return v5;
        }
        uint64_t v5 = *(void *)(v5 + 200);
        if (v5)
        {
          uint64_t v23 = uuid;
          while (uuid_compare(v23, (const unsigned __int8 *)(v5 + 408)))
          {
            uint64_t v5 = *(void *)(v5 + 40);
            if (!v5) {
              goto LABEL_26;
            }
          }

          return v5;
        }
      }

LABEL_26:
      uint64_t v5 = 0LL;
    }

    int v6 = 113;
    goto LABEL_10;
  }

  uint64_t v24 = sub_10002A680(right, 0LL, v11, v12, v13, v14, v15, v16);
  if (!v24)
  {
    uint64_t v5 = 0LL;
    int v6 = 135;
    goto LABEL_10;
  }

  return sub_10003FDE0((uint64_t)v24);
}

xpc_object_t sub_1000223E0(uint64_t a1, void *a2, int a3)
{
  int v6 = sub_10002B170(*(void *)(a1 + 248));
  xpc_object_t result = xpc_retain(a2);
  *((void *)v6 + 3) = result;
  v6[8] = a3;
  xpc_object_t v8 = (void *)(a1 + 512);
  uint64_t v9 = *(void *)(a1 + 512);
  *(void *)int v6 = v9;
  if (v9) {
    *(void *)(v9 + 8) = v6;
  }
  *xpc_object_t v8 = v6;
  *((void *)v6 + 1) = v8;
  return result;
}

uint64_t sub_100022444(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  xpc_object_t value = 0LL;
  sub_10000E638(570425352LL, *(int *)(a1 + 1128));
  if (*(_DWORD *)(a1 + 1128) != *(_DWORD *)(a2 + 20)) {
    return 1LL;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 676);
  if (!(_DWORD)v13)
  {
    uint64_t v14 = *(void *)(a1 + 256);
    if (!v14)
    {
      uint64_t v13 = 0LL;
      BOOL v15 = 1;
      goto LABEL_10;
    }

    uint64_t v13 = *(unsigned int *)(v14 + 676);
  }

  BOOL v15 = (_DWORD)v13 == 0;
  if ((v13 - 1) <= 0xFFFFFFFD && (*(_BYTE *)(a1 + 1298) & 4) == 0)
  {
    sub_10001A4D8( a1,  5,  "blocking xpcproxy until controller configures the service",  v8,  v9,  v10,  v11,  v12,  (char)buffer);
    uint64_t v16 = a1;
    uint64_t v17 = a3;
    int v18 = 3;
LABEL_13:
    sub_1000223E0(v16, v17, v18);
    return 0LL;
  }

uint64_t sub_1000226FC(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  if (*(_DWORD *)(a1 + 1128) != *(_DWORD *)(a2 + 20)) {
    return 1LL;
  }
  if ((*(_BYTE *)(a1 + 1168) & 2) != 0) {
    return 131LL;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, "pc");
  if (!uint64)
  {
    size_t v31 = "Failure info has no PC.";
LABEL_17:
    sub_10001A4D8(a1, 3, v31, v8, v9, v10, v11, v12, v32);
    return 22LL;
  }

  int v13 = uint64;
  uint64_t v14 = xpc_dictionary_get_uint64(xdict, "line");
  if (!v14)
  {
    size_t v31 = "Failure info has no line number.";
    goto LABEL_17;
  }

  int v15 = v14;
  uuid = xpc_dictionary_get_uuid(xdict, "uuid");
  if (!uuid)
  {
    size_t v31 = "Failure info has no image UUID.";
    goto LABEL_17;
  }

  uint64_t v17 = (unsigned __int8 *)uuid;
  BOOL v18 = xpc_dictionary_get_BOOL(xdict, "setup-event");
  char string = xpc_dictionary_get_string(xdict, "string");
  int64_t int64 = xpc_dictionary_get_int64(xdict, "code");
  uint64_t v21 = int64;
  int64_t v23 = xpc_dictionary_get_int64(xdict, "subcode");
  if (byte_10006A9B2) {
    nullsub_23("xpcproxy failed", v22);
  }
  sub_10001BD94(a1, v13, v15, v17, v21, v23, string);
  if (v18)
  {
    sub_10001A4D8( a1,  5,  "Service setup event to handle failure and will not launch until it fires.",  v24,  v25,  v26,  v27,  v28,  v32);
    *(void *)(a1 + 1352) |= 0x40000uLL;
  }

  sub_100021F98(a1, v21, v23, v24, v25, v26, v27, v28, v32);
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_1000228C4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if ((sub_10000D114(a2, 13LL) & 1) == 0)
  {
    memset(v36, 0, sizeof(v36));
    char v24 = sub_1000399D8(*(_DWORD *)(a2 + 20), (char *)v36);
    sub_10001A4D8(a1, 4, "denied kick request from %s - missing entitlement %s", v25, v26, v27, v28, v29, v24);
    return 144LL;
  }

  BOOL v8 = xpc_dictionary_get_BOOL(a3, "unthrottle");
  if (v8)
  {
    uint64_t v9 = sub_100020AC4(a1);
    uint64_t v10 = a1 + 1016;
    if (v9) {
      uint64_t v10 = v9;
    }
    *(_BYTE *)(v10 + 1) = 1;
  }

  BOOL v11 = xpc_dictionary_get_BOOL(a3, "suspended");
  BOOL v12 = xpc_dictionary_get_BOOL(a3, "kill");
  int v19 = *(_DWORD *)(a1 + 1128);
  if (v12)
  {
    if (v19)
    {
      uint64_t result = sub_10001D4CC(a1, a2, v13, v14, v15, v16, v17, v18);
      if ((_DWORD)result) {
        return result;
      }
      xpc_dictionary_set_BOOL(a3, "kill", 0);
      uint64_t v21 = a1;
      uint64_t v22 = a3;
      int v23 = 5;
      goto LABEL_25;
    }
  }

  else if (v19)
  {
    uint64_t v30 = a3;
LABEL_22:
    uint64_t result = (uint64_t)xpc_dictionary_create_reply(v30);
    if (!result) {
      return result;
    }
    char v33 = (void *)result;
    int64_t v34 = *(int *)(a1 + 1128);
    uint64_t v35 = "pid";
    goto LABEL_28;
  }

  if (v11) {
    *(_BYTE *)(a1 + 1298) |= 1u;
  }
  if (v8) {
    int v31 = sub_10001D28C(a1, 9LL);
  }
  else {
    int v31 = sub_10001D3D8(a1, 9LL, v13, v14, v15, v16, v17, v18);
  }
  int v32 = v31;
  if (v31 == 36)
  {
    uint64_t v21 = a1;
    uint64_t v22 = a3;
    int v23 = 1;
LABEL_25:
    sub_1000223E0(v21, v22, v23);
    return 0LL;
  }

  uint64_t v30 = a3;
  if (!v32) {
    goto LABEL_22;
  }
  uint64_t result = (uint64_t)xpc_dictionary_create_reply(a3);
  if (!result) {
    return result;
  }
  char v33 = (void *)result;
  int64_t v34 = v32;
  uint64_t v35 = "error";
LABEL_28:
  xpc_dictionary_set_int64(v33, v35, v34);
  uint64_t result = 0LL;
  *a4 = v33;
  return result;
}

uint64_t sub_100022ACC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if ((sub_10000D114(a2, 13LL) & 1) == 0)
  {
    memset(v40, 0, sizeof(v40));
    char v27 = sub_1000399D8(*(_DWORD *)(a2 + 20), (char *)v40);
    sub_10001A4D8(a1, 4, "denied attach request from %s - missing entitlement %s", v28, v29, v30, v31, v32, v27);
    return 144LL;
  }

  BOOL v8 = xpc_dictionary_get_BOOL(a3, "kill");
  BOOL v9 = xpc_dictionary_get_BOOL(a3, "run");
  BOOL v10 = xpc_dictionary_get_BOOL(a3, "proxy");
  int v11 = xpc_dictionary_get_BOOL(a3, "pended");
  char v18 = *(_BYTE *)(a1 + 1298);
  char v19 = v18 | 1;
  char v20 = v18 & 0xFC | 2;
  if ((v10 & ~v11) == 0) {
    char v20 = v19;
  }
  *(_BYTE *)(a1 + 1298) = v20;
  int v21 = *(_DWORD *)(a1 + 1128);
  if ((v11 & 1) == 0 && (v8 || v10))
  {
    if (v21)
    {
      uint64_t v22 = sub_10001D4CC(a1, a2, v12, v13, v14, v15, v16, v17);
      if ((_DWORD)v22 != 37)
      {
        uint64_t v23 = v22;
        if ((_DWORD)v22)
        {
          sub_100021B6C(a1);
          return v23;
        }
      }

      xpc_dictionary_set_BOOL(a3, "pended", 1);
      uint64_t v24 = a1;
      uint64_t v25 = a3;
      int v26 = 5;
      goto LABEL_23;
    }

    goto LABEL_16;
  }

  if (!v21)
  {
LABEL_16:
    if (!v9 || (int v35 = sub_10001A53C(a1, 9LL), v35 == 36))
    {
      xpc_dictionary_set_BOOL(a3, "pended", 1);
      uint64_t v24 = a1;
      uint64_t v25 = a3;
      int v26 = 1;
LABEL_23:
      sub_1000223E0(v24, v25, v26);
      return 0LL;
    }

    int v36 = v35;
    if (v35)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      if (reply)
      {
        xpc_object_t v38 = reply;
        xpc_dictionary_set_int64(reply, "error", v36);
        *a4 = v38;
      }

      sub_100021B6C(a1);
      return 0LL;
    }
  }

  xpc_object_t v33 = xpc_dictionary_create_reply(a3);
  if (!v33) {
    return 0LL;
  }
  xpc_object_t v34 = v33;
  xpc_dictionary_set_int64(v33, "pid", *(int *)(a1 + 1128));
  uint64_t v23 = 0LL;
  *a4 = v34;
  return v23;
}

uint64_t sub_100022D14(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unsigned int v75 = -1;
  if ((xpc_dictionary_expects_reply(a3) & 1) == 0)
  {
    sub_10003AB08(3, "no reply expected, failing");
    return 22LL;
  }

  char string = xpc_dictionary_get_string(a3, "name");
  if (!string)
  {
    sub_10003AB08(3, "no name, failing");
    return 22LL;
  }

  BOOL v9 = string;
  if ((sub_10000D114(a2, 13LL) & 1) == 0)
  {
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    char v20 = sub_100039990(a2, (char *)&v76);
    sub_10003AB08(3, "Non-entitled process tried to control service %s: %s.%d", v9, v20, *(_DWORD *)(a2 + 20));
    return 144LL;
  }

  uint64_t int64 = xpc_dictionary_get_uint64(a3, "type");
  uint64_t v11 = xpc_dictionary_get_uint64(a3, "handle");
  if (uint64 == 5 && !v11)
  {
    sub_10003AB08(5, "will attach to %s next time it is spawned", v9);
    uint64_t v12 = (const char **)&qword_100069CF8;
    while (1)
    {
      uint64_t v12 = (const char **)*v12;
      if (!v12) {
        break;
      }
      if (!strcmp(v12[2], v9))
      {
        sub_10003AB08(5, "canceling old global attach request to %s", v9);
        sub_1000242C0((uint64_t)v12);
        uint64_t v13 = *v12;
        if (*v12) {
          *((void *)v13 + 1) = v12[1];
        }
        *(void *)v12[1] = v13;
        *uint64_t v12 = (const char *)-1LL;
        v12[1] = (const char *)-1LL;
        xpc_release((xpc_object_t)v12[3]);
        free(v12);
        break;
      }
    }

    uint64_t v14 = sub_100010B00(0x20uLL);
    uint64_t v15 = v14;
    uint64_t v16 = qword_100069CF8;
    *uint64_t v14 = qword_100069CF8;
    if (v16) {
      *(void *)(v16 + 8) = v14;
    }
    qword_100069CF8 = (uint64_t)v14;
    v14[1] = &qword_100069CF8;
LABEL_15:
    v15[2] = v9;
    xpc_object_t v17 = xpc_retain(a3);
    uint64_t v18 = 0LL;
    v15[3] = v17;
    return v18;
  }

  if (!a1)
  {
    uint64_t v43 = sub_10002A864(a3, 1, (int *)&v75);
    if (!v43)
    {
      unsigned int v68 = v75;
      uint64_t v69 = (const char *)xpc_strerror(v75);
      sub_10003AB08(3, "couldn't find domain to attach to %s, error %d - %s", v9, v68, v69);
      return v75;
    }

    uint64_t v49 = v43;
    sub_10002587C(v43, 5, "will attach to %s next time it's created", v44, v45, v46, v47, v48, (char)v9);
    uint64_t v50 = (uint64_t *)(v49 + 48);
    uint64_t v51 = (const char **)(v49 + 48);
    while (1)
    {
      uint64_t v51 = (const char **)*v51;
      if (!v51) {
        break;
      }
      if (!strcmp(v51[2], v9))
      {
        sub_10002587C(v49, 5, "canceling old domain attach request to %s", v52, v53, v54, v55, v56, (char)v9);
        sub_1000242C0((uint64_t)v51);
        uint64_t v57 = *v51;
        if (*v51) {
          *((void *)v57 + 1) = v51[1];
        }
        *(void *)v51[1] = v57;
        *uint64_t v51 = (const char *)-1LL;
        v51[1] = (const char *)-1LL;
        xpc_release((xpc_object_t)v51[3]);
        free(v51);
        break;
      }
    }

    uint64_t v58 = sub_100010B00(0x20uLL);
    uint64_t v15 = v58;
    uint64_t v59 = *v50;
    void *v58 = *v50;
    if (v59) {
      *(void *)(v59 + 8) = v58;
    }
    *uint64_t v50 = (uint64_t)v58;
    v58[1] = v50;
    goto LABEL_15;
  }

  if (*(_DWORD *)(a1 + 676))
  {
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    v71[1] = 0LL;
    uint64_t v72 = 0LL;
    v71[0] = 0LL;
    HIDWORD(v72) = *(_DWORD *)(a1 + 680);
    int v73 = 0;
    int v74 = *(_DWORD *)(a1 + 684);
    char v21 = sub_100039990((uint64_t)v71, (char *)&v76);
    sub_100039990(a2, (char *)&v76);
    sub_10001A4D8(a1, 4, "Replacing controller %s[%d] with %s[%d]", v22, v23, v24, v25, v26, v21);
    sub_100024324(a1);
  }

  unsigned int mach_send = _xpc_dictionary_extract_mach_send(a3, "port");
  if (mach_send - 1 >= 0xFFFFFFFE)
  {
    sub_10001A4D8(a1, 4, "Got dead control port", v28, v29, v30, v31, v32, v70);
    uint64_t v18 = 57LL;
  }

  else
  {
    unsigned int v33 = mach_send;
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    *(_DWORD *)(a1 + 680) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 684) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 676) = v33;
    int v35 = (dispatch_queue_s *)sub_100011938();
    dispatch_source_t v36 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v33, 1uLL, v35);
    *(void *)(a1 + 688) = v36;
    dispatch_set_context(v36, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 688), (dispatch_function_t)sub_10002435C);
    dispatch_source_set_mandatory_cancel_handler_f(*(void *)(a1 + 688), sub_100024360);
    dispatch_activate(*(dispatch_object_t *)(a1 + 688));
    int64_t v42 = *(int *)(a1 + 1128);
    if ((_DWORD)v42)
    {
      xpc_dictionary_set_int64(reply, "pid", v42);
      xpc_dictionary_set_BOOL(reply, "configurable", 0);
    }

    uint64_t v18 = 0LL;
    *a4 = reply;
  }

  if ((*(_BYTE *)(a1 + 1298) & 8) != 0)
  {
    sub_10001A4D8(a1, 5, "controller attached, spawning", v37, v38, v39, v40, v41, v70);
    uint64_t v60 = *(unsigned int *)(a1 + 796);
    *(_DWORD *)(a1 + 796) = 0;
    uint64_t v61 = sub_10001A53C(a1, v60);
    if ((_DWORD)v61)
    {
      char v62 = v61;
      if ((_DWORD)v61 != 36)
      {
        if ((_DWORD)v61 == 139) {
          sub_100039448("deferral event on service waiting for controller");
        }
        xpc_strerror(v61);
        sub_10001A4D8(a1, 3, "service spawn failed after attach: %d: %s", v63, v64, v65, v66, v67, v62);
      }
    }

    *(_BYTE *)(a1 + 1298) &= ~8u;
  }

  return v18;
}

uint64_t sub_1000231DC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v8 = *(_DWORD *)(a1 + 680);
  uint64_t v9 = a1;
  if (!v8)
  {
    uint64_t v9 = *(void *)(a1 + 256);
    if (!v9) {
      uint64_t v9 = a1;
    }
    int v8 = *(_DWORD *)(v9 + 680);
    if (!v8) {
      return 142LL;
    }
  }

  if (v8 != *(_DWORD *)(a2 + 20) || *(_DWORD *)(v9 + 684) != *(_DWORD *)(a2 + 28)) {
    return 142LL;
  }
  if ((*(_BYTE *)(a1 + 1298) & 4) != 0) {
    return 37LL;
  }
  char string = xpc_dictionary_get_string(a3, "program");
  if (string) {
    *(void *)(a1 + 1232) = sub_1000126A0(string);
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "argv");
  if (value)
  {
    uint64_t v12 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array) {
      *(void *)(a1 + 1240) = xpc_retain(v12);
    }
  }

  uint64_t v13 = xpc_dictionary_get_string(a3, "cwd");
  if (v13) {
    *(void *)(a1 + 1248) = sub_1000126A0(v13);
  }
  xpc_object_t v14 = xpc_dictionary_get_value(a3, "environment");
  if (v14)
  {
    uint64_t v15 = v14;
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary) {
      *(void *)(a1 + 1256) = xpc_retain(v15);
    }
  }

  int int64 = xpc_dictionary_get_int64(a3, "binpref");
  if (int64)
  {
    xpc_binprefs_alloc();
    *(void *)(a1 + 1264) = v17;
    xpc_binprefs_add(v17, int64, -1);
  }

  xpc_object_t v18 = xpc_dictionary_get_value(a3, "fds");
  if (v18)
  {
    char v19 = v18;
    if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array) {
      *(void *)(a1 + 1280) = xpc_retain(v19);
    }
  }

  mach_port_name_t mach_send = _xpc_dictionary_extract_mach_send(a3, "endpoint");
  if (!mach_send) {
    goto LABEL_27;
  }
  if ((*(_DWORD *)(a1 + 1316) + 1) >= 2)
  {
    int v28 = sub_10000AC70(mach_send);
    if (v28) {
      sub_100046EE0(v28);
    }
    sub_10001A4D8( a1,  3,  "Cannot set configure key endpoint on service: service has dext checkin port %#x",  v29,  v30,  v31,  v32,  v33,  *(_DWORD *)(a1 + 1316));
    return 22LL;
  }

  *(_DWORD *)(a1 + 1272) = mach_send;
LABEL_27:
  __int16 v21 = xpc_dictionary_get_int64(a3, "jetsam-flags");
  if (v21) {
    *(_WORD *)(a1 + 1296) = v21;
  }
  int v22 = xpc_dictionary_get_int64(a3, "jetsam-priority");
  if (v22 >= 1) {
    *(_DWORD *)(a1 + 1288) = v22;
  }
  int v23 = xpc_dictionary_get_int64(a3, "jetsam-memlimit");
  if (v23) {
    *(_DWORD *)(a1 + 1292) = v23;
  }
  if (xpc_dictionary_get_BOOL(a3, "nano-allocator")) {
    *(_BYTE *)(a1 + 1298) |= 0x10u;
  }
  BOOL v24 = xpc_dictionary_get_BOOL(a3, "sec-transition");
  char v25 = *(_BYTE *)(a1 + 1298);
  if (v24)
  {
    v25 |= 0x20u;
    *(_BYTE *)(a1 + 1298) = v25;
  }

  if ((v25 & 1) == 0) {
    char v25 = *(_BYTE *)(a1 + 1298) & 0xFE | xpc_dictionary_get_BOOL(a3, "suspended");
  }
  *(_BYTE *)(a1 + 1298) = v25 | 4;
  sub_10001A394(a1, 3LL, 0LL);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_1000234B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 680);
  if (!v5 || v5 != *(_DWORD *)(a2 + 20) || *(_DWORD *)(a1 + 684) != *(_DWORD *)(a2 + 28)) {
    return 1LL;
  }
  sub_100024324(a1);
  return 0LL;
}

uint64_t sub_100023520(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_10002B03C(*(void *)(a1 + 248), 5LL, 0LL, a2);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100024398(a1, a2, v8);
  }

  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    if (reply)
    {
      uint64_t v11 = reply;
      uint64_t v12 = sub_10002089C(*(_DWORD *)(a1 + 1136));
      uint64_t v13 = sub_100012884("%s", v12);
      xpc_dictionary_set_string(v11, "reason", v13);
      free(v13);
      uint64_t v9 = 0LL;
      *a4 = v11;
    }

    else
    {
      return 22LL;
    }
  }

  return v9;
}

uint64_t sub_1000235F4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_10002B03C(*(void *)(a1 + 248), 5LL, 0LL, a2);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100024398(a1, a2, v8);
  }

  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    v11[2] = sub_1000244C8;
    v11[3] = &unk_100064690;
    v11[4] = a1;
    return sub_10003D10C(a3, a4, (uint64_t)v11);
  }

  return v9;
}

uint64_t sub_1000236B4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 248);
  if ((void *)sub_10002A994(v8) != qword_100069750) {
    return 125LL;
  }
  if (sub_10002A99C(v8) != *(_DWORD *)(a2 + 20)) {
    return 1LL;
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "bootstrap");
  uint64_t v11 = *(void **)(a1 + 632);
  if (v11)
  {
    xpc_release(v11);
    *(void *)(a1 + 632) = 0LL;
  }

  if (value) {
    *(void *)(a1 + 632) = xpc_retain(value);
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_100023788(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 248);
  if ((void *)sub_10002A994(v8) != qword_100069750) {
    return 125LL;
  }
  if (*(_DWORD *)(a1 + 1128) != *(_DWORD *)(a2 + 20)) {
    return 1LL;
  }
  uint64_t v10 = *(void *)(a1 + 256);
  if (!v10) {
    uint64_t v10 = a1;
  }
  uint64_t v11 = *(void **)(v10 + 632);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v13 = reply;
  if (v11) {
    xpc_dictionary_set_value(reply, "bootstrap", v11);
  }
  memset(v14, 0, sizeof(v14));
  sub_10002AB7C(v8, (uint64_t)v14);
  xpc_dictionary_set_data(v13, "creator", v14, 0x20uLL);
  uint64_t result = 0LL;
  *a4 = v13;
  return result;
}

uint64_t sub_100023880(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_DWORD *)(a1 + 296)) {
    return 113LL;
  }
  uint64_t v9 = *(void *)(a1 + 344);
  v11 = v9 && (uint64_t v10 = *(void **)(v9 + 48)) != 0LL && *(void *)(v9 + 56) && sub_10003752C(a2, v10);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_object_t v13 = sub_10001E010(a1, v11);
  xpc_dictionary_set_value(reply, "attrs", v13);
  xpc_release(v13);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_100023940(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!*(_DWORD *)(a1 + 1128)) {
    return 3LL;
  }
  BOOL v8 = xpc_dictionary_get_BOOL(a3, "deferred");
  if ((*(_BYTE *)(a1 + 1168) & 2) != 0)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    xpc_dictionary_set_int64(reply, "pid", *(int *)(a1 + 1128));
    uint64_t result = 0LL;
    *a4 = reply;
  }

  else
  {
    if (v8) {
      return 3LL;
    }
    xpc_dictionary_set_BOOL(a3, "deferred", 1);
    sub_1000223E0(a1, a3, 4);
    return 0LL;
  }

  return result;
}

uint64_t sub_100023A18(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_DWORD *)(a1 + 1000) && *(_DWORD *)(a1 + 1176))
  {
    if (sub_10003DA48(a1 + 1176))
    {
      uint64_t v8 = 1LL;
    }

    else if (sub_10003DAF8((_DWORD *)(a1 + 1176)))
    {
      if (*(_DWORD *)(a1 + 1180)) {
        uint64_t v8 = 128LL;
      }
      else {
        uint64_t v8 = 64LL;
      }
    }

    else
    {
      uint64_t v8 = 64LL;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  unsigned int v10 = *(_DWORD *)(a1 + 1180);
  uint64_t v11 = *(void *)(a1 + 1184);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_object_t v13 = reply;
  if (*(_DWORD *)(a1 + 1000) && *(_DWORD *)(a1 + 364) == 80)
  {
    xpc_dictionary_set_uint64(reply, "termination-state", 0x80uLL);
    unsigned int v10 = 9;
    uint64_t v11 = 10LL;
LABEL_14:
    xpc_dictionary_set_uint64(v13, "os-namespace", v10);
    xpc_dictionary_set_uint64(v13, "os-code", v11);
    goto LABEL_15;
  }

  xpc_dictionary_set_uint64(reply, "termination-state", v8);
  if (v8 == 128) {
    goto LABEL_14;
  }
LABEL_15:
  uint64_t result = 0LL;
  *a4 = v13;
  return result;
}

uint64_t sub_100023B68(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  BOOL v8 = xpc_dictionary_get_BOOL(xdict, "yesno");
  if (*(_DWORD *)(a1 + 1128) != *(_DWORD *)(a2 + 20)) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a1 + 824);
  if (v8)
  {
    if (v14)
    {
      sub_10001A4D8(a1, 5, "extension already attempting clean exit", v9, v10, v11, v12, v13, v20);
      return 36LL;
    }

    sub_10001A4D8(a1, 5, "extension attempting to exit cleanly", v9, v10, v11, v12, v13, v20);
    uint64_t v16 = (dispatch_queue_s *)sub_100011938();
    *(void *)(a1 + 824) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v16);
    sub_100016C50(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 824), (void *)a1);
    uint64_t v17 = *(dispatch_source_s **)(a1 + 824);
    dispatch_time_t v18 = dispatch_time(0LL, 1000000000LL * *(unsigned int *)(a1 + 840));
    dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 824), (dispatch_function_t)sub_1000244D4);
    dispatch_activate(*(dispatch_object_t *)(a1 + 824));
  }

  else
  {
    if (!v14)
    {
      sub_10001A4D8(a1, 5, "extension already interrupted clean exit attempt", v9, v10, v11, v12, v13, v20);
      return 37LL;
    }

    if (*(unsigned __int8 *)(a1 + 424) >= 5u)
    {
LABEL_12:
      sub_10001A4D8(a1, 5, "extension is being stopped", v9, v10, v11, v12, v13, v20);
      return 124LL;
    }

    sub_10001A4D8(a1, 5, "extension canceled clean exit attempt", v9, v10, v11, v12, v13, v20);
    sub_100016C74(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 824));
    dispatch_release(*(dispatch_object_t *)(a1 + 824));
    *(void *)(a1 + 824) = 0LL;
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_100023D4C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if ((*(_BYTE *)(a1 + 1356) & 4) == 0) {
    return 137LL;
  }
  if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a1 + 1128)) {
    return 1LL;
  }
  if (!*(void *)(a1 + 832)) {
    return 37LL;
  }
  sub_10001A4D8(a1, 5, "extension checked in as alive", v8, v9, v10, v11, v12, v14);
  sub_100016C74(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 832));
  dispatch_release(*(dispatch_object_t *)(a1 + 832));
  *(void *)(a1 + 832) = 0LL;
  *(void *)(a1 + 1164) |= 0x4000000000uLL;
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_100023E24(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_DWORD *)(a1 + 1128) != *(_DWORD *)(a2 + 20)) {
    return 1LL;
  }
  uint64_t v7 = sub_10001A0B0(a1);
  uint64_t v8 = *(void *)(a1 + 256);
  if (v8) {
    uint64_t v7 = sub_10001A0B0(v8);
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  if (v7)
  {
    uint64_t v10 = (void *)sub_10003CD44(v7);
    xpc_dictionary_set_value(reply, "xpcservice-dict", v10);
    xpc_release(v10);
    xpc_dictionary_set_string(reply, "identifier", *(const char **)(a1 + 576));
  }

  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_100023EEC(uint64_t a1, void *a2, void *a3)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  xpc_object_t v7 = reply;
  if ((*(_BYTE *)(a1 + 1357) & 2) != 0) {
    xpc_dictionary_set_uuid(reply, "instance", (const unsigned __int8 *)(a1 + 408));
  }
  uint64_t result = 0LL;
  *a3 = v7;
  return result;
}

uint64_t sub_100023F5C(uint64_t a1, _OWORD *a2, void *a3, xpc_object_t *a4)
{
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  if (!uuid) {
    return 22LL;
  }
  uint64_t v9 = (unsigned __int8 *)uuid;
  uint64_t v10 = *(void *)(a1 + 200);
  if (v10)
  {
    while (uuid_compare(v9, (const unsigned __int8 *)(v10 + 408)))
    {
      uint64_t v10 = *(void *)(v10 + 40);
      if (!v10) {
        goto LABEL_7;
      }
    }

    return 37LL;
  }

  else
  {
LABEL_7:
    unsigned int v13 = 0;
    sub_1000268C8(*(_DWORD **)(a1 + 248), a1, v9, 0, 0LL, a2, (int *)&v13);
    uint64_t v11 = v13;
    if (!v13) {
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }

  return v11;
}

uint64_t sub_100024044(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  if (!uuid) {
    return 22LL;
  }
  uint64_t v9 = uuid;
  mach_port_context_t v10 = *(void *)(a1 + 200);
  if (!v10) {
    return 113LL;
  }
  while (uuid_compare(v9, (const unsigned __int8 *)(v10 + 408)))
  {
    mach_port_context_t v10 = *(void *)(v10 + 40);
    if (!v10) {
      return 113LL;
    }
  }

  uint64_t result = sub_1000266F8(*(void *)(v10 + 248), v10);
  if (!(_DWORD)result)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    goto LABEL_15;
  }

  if ((_DWORD)result == 36)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    uint64_t v13 = sub_100020930(v10);
    char v14 = (void *)xpc_mach_send_create_with_disposition(v13, 20LL);
    xpc_dictionary_set_value(reply, "monitor", v14);
    xpc_release(v14);
LABEL_15:
    uint64_t result = 0LL;
    *a4 = reply;
  }

  return result;
}

uint64_t sub_100024154(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  xpc_object_t empty = xpc_array_create_empty();
  for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 40))
    xpc_array_set_uuid(empty, 0xFFFFFFFFFFFFFFFFLL, (const unsigned __int8 *)(i + 408));
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "uuids", empty);
  xpc_release(empty);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_100024204(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v9 = sub_10001C2A0(a1, 1);
  if (v9)
  {
    mach_port_context_t v10 = v9;
    xpc_dictionary_set_string(reply, "service-name", v9);
    free(v10);
  }

  else
  {
    xpc_dictionary_set_string(reply, "service-name", "Unknown service");
  }

  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

void sub_1000242C0(uint64_t a1)
{
  xpc_object_t reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 24));
  if (reply)
  {
    uint64_t v2 = reply;
    xpc_dictionary_set_int64(reply, "error", 89LL);
    int v3 = xpc_pipe_routine_reply(v2);
    if ((v3 & 0xFFFFFFDF) != 0) {
      _os_assumes_log(v3);
    }
    xpc_release(v2);
  }

void sub_100024324(uint64_t a1)
{
  *(void *)(a1 + 680) = 0LL;
  *(_DWORD *)(a1 + 676) = 0;
  if ((*(_BYTE *)(a1 + 1298) & 4) != 0) {
    sub_100021B6C(a1);
  }
  sub_100003174(a1);
}

void sub_100024360(dispatch_source_s *a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(a1);
  int v3 = sub_10000AC70(handle);
  if (v3) {
    _os_assumes_log(v3);
  }
  dispatch_release(a1);
}

void sub_100024398(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a3 != 124)
  {
    if ((_DWORD)a3 == 154) {
      int v5 = 65539;
    }
    else {
      int v5 = 3;
    }
    memset(v17, 0, sizeof(v17));
    char v6 = sub_100039990(a2, (char *)v17);
    xpc_strerror(a3);
    sub_10001A4D8( a1,  v5,  "Caller not allowed to perform action: %s.%d, actiouint64_t n = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u",  v7,  v8,  v9,  v10,  v11,  v6);
    xpc_strerror(a3);
    sub_10001A4D8( a1,  5,  "violation: %s.%d, actiouint64_t n = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u",  v12,  v13,  v14,  v15,  v16,  v6);
  }

uint64_t sub_1000244C8(uint64_t a1, FILE *a2)
{
  return sub_10001E6C8(*(void *)(a1 + 32), a2, 0LL);
}

void sub_1000244D4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(void *)(a1 + 824) = 0LL;
  if (sub_10003A668(*(_DWORD *)(a1 + 1128)))
  {
    sub_10001A4D8(a1, 5, "extension is being debugged; not timing out exit", v10, v11, v12, v13, v14, a9);
  }

  else
  {
    sub_10001A4D8( a1,  4,  "Extension remained dirty for too long after trying to exit. Killing.",  v10,  v11,  v12,  v13,  v14,  v33);
    sub_10001A4D8(a1, 5, "extension timed out trying to exit; killing", v15, v16, v17, v18, v19, v34);
    uint64_t v20 = sub_10000AD0C();
    unsigned int v26 = sub_10001D678(a1, 1, v20, v21, v22, v23, v24, v25);
    char v27 = v26;
    if (v26 > 0x25 || ((1LL << v26) & 0x2000000009LL) == 0)
    {
      strerror(v26);
      sub_10001A4D8(a1, 4, "Failed to kill extension. It may linger forever: %d: %s", v28, v29, v30, v31, v32, v27);
    }
  }

void sub_1000245CC(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(v1 + 1164);
  if ((v2 & 0x1000000000LL) != 0) {
    sub_100039448("proc source registration handler invoked twice");
  }
  *(void *)(v1 + 1164) = v2 | 0x1000000000LL;
  sub_10001A394(v1, 2LL, 0LL);
}

uint64_t sub_10002460C(uint64_t a1, _OWORD *a2, char a3)
{
  uint64_t v5 = sub_10003A54C(a2);
  uint64_t v6 = v5;
  if ((_DWORD)v5)
  {
    sub_1000476DC(v5, a1, a3);
  }

  else
  {
    sub_10000E648(570425424LL, *(int *)(a1 + 1128), 9LL);
    strsignal(9);
    sub_10001A4D8(a1, 5, "signaled service for %s: %s", v7, v8, v9, v10, v11, a3);
  }

  return v6;
}

void sub_10002469C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = sub_100039918(*(_DWORD *)(a1 + 1128), buffer);
  if (v14)
  {
    _os_assumes_log(v14);
  }

  else if (HIDWORD(buffer[0]) == 5)
  {
    sub_10001A4D8(a1, 5, "service is already a zombie", v15, v16, v17, v18, v19, v52);
    sub_10001B024(a1, 0);
    return;
  }

  sub_10001A4D8(a1, 5, "service is still not a zombie, abandoning", v15, v16, v17, v18, v19, v52);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void))(a1 + 536))(a1, *(void *)(a1 + 568));
  if ((_DWORD)v20)
  {
    char v26 = v20;
    xpc_strerror(v20);
    sub_10001A4D8(a1, 5, "cannot safely abandon: %d: %s", v27, v28, v29, v30, v31, v26);
    sub_10001A4D8( a1,  4,  "Cannot safely abandon service instance. Leaving it to languish. This may lead to deadlocks.",  v32,  v33,  v34,  v35,  v36,  v54);
    sub_100020C0C(a1, 7);
    sub_10001A394(a1, 6LL, 0LL);
  }

  else
  {
    sub_10001A4D8(a1, 5, "abandoning", v21, v22, v23, v24, v25, v53);
    sub_10001A4D8(a1, 4, "Abandoning service instance. This may lead to deadlocks.", v37, v38, v39, v40, v41, v55);
    uintptr_t v42 = *(int *)(a1 + 1128);
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    dispatch_source_t v44 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v42, 0x80000000uLL, global_queue);
    dispatch_set_context(v44, v44);
    dispatch_source_set_event_handler_f(v44, (dispatch_function_t)sub_1000249FC);
    dispatch_activate(v44);
    sub_10001AF8C(a1, v45, v46, v47, v48, v49, v50, v51);
  }

void sub_100024874( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!byte_10006A97C
    || *(_BYTE *)(a1 + 1006)
    || (_UNKNOWN *)sub_10002A994(*(void *)(a1 + 248)) == &unk_100069750
    && (uint64_t v18 = sub_10002A7C8(), !sub_100025D50(v18)))
  {
    sub_10001A4D8( a1,  4,  "Service did not exit %u seconds after SIGTERM. Sending SIGKILL.",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 808));
    memset(v26, 0, sizeof(v26));
    mach_error_t v9 = sub_10003A5AC(*(_DWORD *)(a1 + 1128), (integer_t *)v26);
    if (v9)
    {
      int v10 = *(_DWORD *)(a1 + 1128);
      mach_error_string(v9);
      sub_10001A4D8(a1, 5, "could not get audit token for service (PID %d): %d: %s", v11, v12, v13, v14, v15, v10);
    }

    else
    {
      sub_10002460C(a1, v26, (char)"SIGTERM timeout");
    }
  }

  else
  {
    sub_10001A4D8( a1,  4,  "Service did not exit %u seconds after SIGTERM. Terminating with a crash report.",  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 808));
    int v19 = sub_10003A3A0(*(unsigned int *)(a1 + 1128), 4u, (uint64_t)"SIGTERM timeout", 0LL);
    if (v19)
    {
      char v20 = v19;
      strerror(v19);
      sub_10001A4D8(a1, 5, "could not terminate service after SIGTERM timeout: %d: %s", v21, v22, v23, v24, v25, v20);
    }
  }

  *(_BYTE *)(a1 + 1164) = 9;
  sub_100020C0C(a1, 6);
  uint64_t v16 = *(dispatch_source_s **)(a1 + 1152);
  dispatch_time_t v17 = dispatch_time(0LL, 1000000000LL * dword_100069A3C);
  dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 1152), (dispatch_function_t)sub_10002469C);
}

void sub_1000249FC(dispatch_source_s *a1)
{
  pid_t handle = dispatch_source_get_handle(a1);
  int v6 = 0;
  if (waitpid(handle, &v6, 0) == -1)
  {
    int v3 = *__error();
    uint64_t v4 = __error();
    uint64_t v5 = strerror(*v4);
    sub_10003AB08(3, "Could not reap abandoned service instance: %d: %s", v3, v5);
  }

  dispatch_release(a1);
}

uint64_t sub_100024A6C(uint64_t a1, int a2, xpc_object_t xstring)
{
  int v3 = *(FILE **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40) + 2LL;
  int64_t string_ptr = xpc_string_get_string_ptr(xstring);
  sub_10003D32C(v3, v4, "%s", v6, v7, v8, v9, v10, string_ptr);
  return 1LL;
}

uint64_t sub_100024AB8(uint64_t a1, int a2, xpc_object_t xstring)
{
  int v3 = *(FILE **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40) + 2LL;
  int64_t string_ptr = xpc_string_get_string_ptr(xstring);
  sub_10003D32C(v3, v4, "%s", v6, v7, v8, v9, v10, string_ptr);
  return 1LL;
}

xpc_type_t sub_100024B04(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  uint64_t v5 = *(FILE **)a3;
  uint64_t v6 = *(void *)(a3 + 16);
  xpc_type_t result = xpc_get_type(object);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    return (xpc_type_t)sub_10003D32C(v5, v6, "%s => %s", v9, v10, v11, v12, v13, a1, string_ptr);
  }

  return result;
}

void sub_100024B74( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a3)
  {
    if (*(void *)(a1 + 16)) {
      sub_10000D960(a1, " | ", a3, a4, a5, a6, a7, a8, v10);
    }
    sub_10000D960(a1, "%s", a3, a4, a5, a6, a7, a8, a2);
  }

void *sub_100024BCC(char *__s1)
{
  uint64_t v2 = 0LL;
  while (strcmp(__s1, (&off_1000647E0)[v2]))
  {
    v2 += 2LL;
    if (v2 == 12) {
      sub_100039448("Unable to find boot task block for: %s", __s1);
    }
  }

  int v3 = (&off_1000647E0)[v2 + 1];
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000LL;
  aBlock[2] = sub_100024F1C;
  aBlock[3] = &unk_100064840;
  aBlock[4] = v3;
  return _Block_copy(aBlock);
}

void sub_100024C70()
{
  uint64_t v0 = sub_100001F54();
  uint64_t inited = os_variant_init_4launchd(v0);
  _os_trace_update_with_datavolume_4launchd(inited);
  sub_1000414BC();
}

void sub_100024C8C()
{
  int v0 = mkpath_np("/private/var/mobile/tmp", 0x1FFu);
  if (v0)
  {
    if (v0 == 17)
    {
      sub_10003B008( "fixup-mobile-tmp",  196613,  "%s already exists, skipping",  v1,  v2,  v3,  v4,  v5,  (char)"/private/var/mobile/tmp");
      goto LABEL_16;
    }

    strerror(v0);
    uint64_t v36 = "could not set create %s: %s";
LABEL_15:
    sub_10003B008("fixup-mobile-tmp", 196611, v36, v31, v32, v33, v34, v35, (char)"/private/var/mobile/tmp");
    goto LABEL_16;
  }

  if (chmod("/private/var/mobile/tmp", 0x3FFu) < 0)
  {
    uint64_t v11 = __error();
    strerror(*v11);
    sub_10003B008( "fixup-mobile-tmp",  196611,  "could not chmod 1777 on %s: %s",  v12,  v13,  v14,  v15,  v16,  (char)"/private/var/mobile/tmp");
  }

  if (chown("/private/var/mobile/tmp", 0x1F5u, 0x1F5u) < 0)
  {
    dispatch_time_t v17 = __error();
    strerror(*v17);
    sub_10003B008( "fixup-mobile-tmp",  196611,  "could not chown mobile/mobile %s: %s",  v18,  v19,  v20,  v21,  v22,  (char)"/private/var/mobile/tmp");
  }

  int v23 = open_dprotected_np("/private/var/mobile/tmp", 0, 0, 1);
  if (v23 == -1)
  {
    __error();
    uint64_t v37 = __error();
    strerror(*v37);
    uint64_t v36 = "could not open %s: %s";
    goto LABEL_15;
  }

  int v24 = v23;
  char v38 = 4;
  if (fcntl(v23, 64))
  {
    __error();
    uint64_t v25 = __error();
    strerror(*v25);
    sub_10003B008( "fixup-mobile-tmp",  196611,  "could not set protection class on %s: %s",  v26,  v27,  v28,  v29,  v30,  (char)"/private/var/mobile/tmp");
  }

  if ((v24 & 0x80000000) == 0) {
    close(v24);
  }
LABEL_16:
  sub_10003B008("fixup-mobile-tmp", 196613, "Finished boot task", v6, v7, v8, v9, v10, v38);
  byte_10006A918 = 1;
}

uint64_t sub_100024E54()
{
  unsigned int v0 = sub_100039294("/");
  uint64_t v2 = v0;
  if ((v0 & 1) != 0 || (result = sub_1000391C0("/private/preboot"), uint64_t v2 = result, (_DWORD)result))
  {
    sub_10003AB08(65541, "Found roots installed cookie");
    uint64_t result = sysctlbyname("kern.roots_installed", 0LL, 0LL, &v2, 8uLL);
    if ((_DWORD)result) {
      sub_100046EF4(result);
    }
  }

  return result;
}

void sub_100024ED4()
{
  int v0 = exclaves_boot(0LL, 0LL);
  if (v0)
  {
    if (v0 != 46) {
      sub_10003AB68(65541, "exclaves_boot failed: %d", v0);
    }
  }

uint64_t sub_100024F1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t sub_100024F24()
{
  return 0LL;
}

uint64_t sub_100024F30(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  switch(a2)
  {
    case 2:
      return *(_DWORD *)(a5 + 4) != 0;
    case 3:
      if ((sub_10002B35C(a5) & 1) != 0) {
        return 0LL;
      }
      if ((a3 & 8) != 0)
      {
        uint64_t v9 = 1LL;
      }

      if (a6 && (sub_10001379C(a6) & 1) != 0) {
        return 0LL;
      }
      if (*(_DWORD *)(a5 + 4)) {
        return 1LL;
      }
      int v13 = *(_DWORD *)(a5 + 20);
      if (v13 == getpid())
      {
        if (!a6) {
          return 0LL;
        }
      }

      else
      {
        BOOL v14 = sub_100015944((_OWORD *)a5, (uint64_t)"job-creation", 1);
        uint64_t v9 = !v14;
        if (!a6 || !v14) {
          return v9;
        }
      }

      BOOL v15 = *(_DWORD *)(a7 + 16) || (*(_WORD *)(a7 + 4) & 0x12) != 0;
      if ((a3 & 0x10) == 0LL && v15) {
        return 122LL;
      }
      else {
        return 0LL;
      }
    case 4:
    case 7:
      if ((sub_10002B35C(a5) & 1) != 0) {
        return 0LL;
      }
      if ((a3 & 8) == 0 || (uint64_t v9 = 1LL, sub_100015944((_OWORD *)a5, (uint64_t)"forbidden-launchd-operation", 1)))
      {
        if ((a3 & 4) != 0) {
          return 125LL;
        }
        else {
          return *(_DWORD *)(a5 + 4) != 0;
        }
      }

      return v9;
    case 5:
      if ((sub_10002B35C(a5) & 1) != 0) {
        return 0LL;
      }
      if ((a3 & 8) == 0) {
        return !sub_100015944((_OWORD *)a5, (uint64_t)"process-info-pidinfo", 1);
      }
      uint64_t v9 = 1LL;
      return v9;
    case 6:
      return 0LL;
    default:
      return 1LL;
  }

uint64_t sub_1000250E4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

void sub_1000250EC( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[4];
  if (v9) {
    *(void *)(v9 + 40) = a1[5];
  }
  *(void *)a1[5] = v9;
  a1[4] = -1LL;
  a1[5] = -1LL;
  sub_1000167B0(a1);
  uint64_t v10 = (dispatch_queue_s *)sub_100011938();
  dispatch_async_f(v10, a1, (dispatch_function_t)sub_10002B2AC);
}

uint64_t sub_100025160(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  switch(a2)
  {
    case 1:
    case 2:
      return 45LL;
    case 3:
      if ((a3 & 8) != 0)
      {
        uint64_t v11 = 1LL;
      }

      if ((a3 & 1) != 0 && a6 && !*(_DWORD *)(a7 + 16) && (*(_WORD *)(a7 + 4) & 0x12) == 0) {
        return 0LL;
      }
      uint64_t v14 = *(unsigned int *)(a5 + 4);
      if (v14 != a4) {
        return (_DWORD)v14 != 0;
      }
      if (!a6) {
        return !sub_100015944((_OWORD *)a5, (uint64_t)"job-creation", 1);
      }
      uint64_t v15 = *(unsigned int *)(a7 + 16);
      if (!(_DWORD)v15 && (*(_WORD *)(a7 + 4) & 0x12) == 0) {
        return 0LL;
      }
      if (v15 == a4 && (*(_WORD *)(a7 + 4) & 2) == 0) {
        return !sub_100015944((_OWORD *)a5, (uint64_t)"job-creation", 1);
      }
      return 122LL;
    case 4:
    case 7:
      if ((a3 & 8) == 0) {
        goto LABEL_23;
      }
      uint64_t v10 = "forbidden-launchd-operation";
      goto LABEL_22;
    case 5:
      if ((a3 & 8) == 0 || (uint64_t v11 = 1LL, sub_100015944((_OWORD *)a5, (uint64_t)"forbidden-launchd-operation", 1)))
      {
        uint64_t v10 = "process-info-pidinfo";
LABEL_22:
        uint64_t v11 = 1LL;
        if (sub_100015944((_OWORD *)a5, (uint64_t)v10, 1))
        {
LABEL_23:
          uint64_t v16 = *(unsigned int *)(a5 + 4);
          return v16 != a4 && (_DWORD)v16 != 0;
        }
      }

      return v11;
    case 6:
      if (*(_DWORD *)(a5 + 4) == a4) {
        return 0LL;
      }
      else {
        return 144LL;
      }
    default:
      return 1LL;
  }

uint64_t sub_1000252F8(uint64_t a1)
{
  return *(int *)(a1 + 24);
}

uint64_t sub_100025304()
{
  return 45LL;
}

uint64_t sub_10002530C(uint64_t a1)
{
  return *(int *)(a1 + 20);
}

void sub_100025314( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[23])
  {
    uint64_t v9 = sub_100010B00(0x30uLL);
    v9[4] = dword_10006A940;
    *((void *)v9 + 3) = a1[23];
    a1[23] = 0LL;
    uint64_t v10 = (dispatch_queue_s *)sub_100011938();
    dispatch_async_f(v10, v9, (dispatch_function_t)sub_10002B39C);
  }

  uint64_t v11 = a1[4];
  if (v11) {
    *(void *)(v11 + 40) = a1[5];
  }
  *(void *)a1[5] = v11;
  a1[4] = -1LL;
  a1[5] = -1LL;
  sub_1000167B0(a1);
  uint64_t v12 = (dispatch_queue_s *)sub_100011938();
  dispatch_async_f(v12, a1, (dispatch_function_t)sub_10002B2AC);
}

uint64_t sub_1000253CC( uint64_t a1, int a2, char a3, unint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t result = 125LL;
  switch(a2)
  {
    case 1:
      if (!(a4 >> 31))
      {
        uint64_t v10 = *(unsigned int *)(a5 + 20);
        if ((v10 & 0x80000000) == 0 && v10 == a4) {
          return 0LL;
        }
      }

      if ((sub_10000D114(a5, 13LL) & 1) != 0) {
        return 0LL;
      }
      uint64_t v11 = a5;
      uint64_t v12 = 2LL;
      return sub_10000D114(v11, v12) ^ 1;
    case 2:
      return result;
    case 3:
      if (!a1) {
        return 131LL;
      }
      if (!a6) {
        return 147LL;
      }
      unint64_t v14 = *(void *)(a1 + 112);
      if (v14 >> 31 || (uint64_t v15 = *(unsigned int *)(a5 + 20), (v15 & 0x80000000) != 0) || v14 != v15)
      {
        else {
          return 144LL;
        }
      }

      else
      {
        if ((a3 & 1) == 0
          && (!sub_10001379C(a6) || *(_DWORD *)(a7 + 16) || (*(_WORD *)(a7 + 4) & 0x12) != 0))
        {
          dispatch_time_t v17 = *(char **)(a1 + 208);
          if (!v17
            || !sub_100012944(a6, v17)
            || (size_t v18 = strlen(*(const char **)(a1 + 208)), a6[v18 - 1] != 47)
            && (size_t v19 = v18, strlen(a6) != v18)
            && a6[v19] != 47)
          {
          }
        }

        return 0LL;
      }

    case 4:
      if (!(a4 >> 31))
      {
        uint64_t v20 = *(unsigned int *)(a5 + 20);
        if ((v20 & 0x80000000) == 0 && v20 == a4) {
          return 0LL;
        }
      }

      uint64_t v11 = a5;
      uint64_t v12 = 0LL;
      return sub_10000D114(v11, v12) ^ 1;
    case 5:
      if (!(a4 >> 31) && (uint64_t v21 = *(unsigned int *)(a5 + 20), (v21 & 0x80000000) == 0) && v21 == a4
        || (int v22 = *(_DWORD *)(a5 + 4)) == 0
        || a1 && v22 == *(_DWORD *)(a1 + 56))
      {
      }

      return 1LL;
    case 6:
      uint64_t v23 = *(unsigned int *)(a5 + 20);
      return (a4 & 0xFFFFFFFF80000000LL) != 0 || (int)v23 < 0 || v23 != a4;
    default:
      return 1LL;
  }

void sub_1000255D4(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 968) & 0x800) != 0) {
    sub_100039448("system domain deallocated");
  }
  for (uint64_t i = 304LL; i != 488; i += 8LL)
  {
    if (*(void *)(a1 + i)) {
      sub_100039448("domain deallocated with services");
    }
  }

  if (os_map_str_count(a1 + 488)) {
    sub_100039448("domain deallocated with service stubs");
  }
  os_map_str_destroy(a1 + 488);
  uint64_t v3 = *(void *)(a1 + 928);
  if (v3)
  {
    os_map_str_clear(v3, &stru_100064880);
    os_map_str_destroy(*(void *)(a1 + 928));
    free(*(void **)(a1 + 928));
  }

  uint64_t v4 = *(mach_port_name_t **)(a1 + 80);
  if (v4)
  {
    do
    {
      uint64_t v5 = *(mach_port_name_t **)v4;
      sub_100025814(a1, v4);
      uint64_t v4 = v5;
    }

    while (v5);
  }

  if (*(void *)(a1 + 32) != -1LL || *(void *)(a1 + 40) != -1LL) {
    sub_100039448("domain disposal while still in the domains list", v4);
  }
  if (*(void *)(a1 + 16) != -1LL || *(void *)(a1 + 24) != -1LL) {
    sub_100039448("domain disposal while still in the children list", v4);
  }
  if (*(void *)(a1 + 176)) {
    _os_assumes_log_ctx(sub_100025848, a1);
  }
  uint64_t v6 = *(void **)(a1 + 88);
  if (v6)
  {
    uint64_t v7 = (void *)*v6;
    uint64_t v8 = (void *)v6[1];
    if (*v6)
    {
      do
      {
        uint64_t v9 = v7;
        v7[1] = v8;
        *(void *)v6[1] = v7;
        *uint64_t v6 = -1LL;
        v6[1] = -1LL;
        j__free(v6);
        uint64_t v7 = (void *)*v9;
        uint64_t v8 = (void *)v9[1];
        uint64_t v6 = v9;
      }

      while (*v9);
    }

    else
    {
      uint64_t v9 = *(void **)(a1 + 88);
    }

    *uint64_t v8 = 0LL;
    *uint64_t v9 = -1LL;
    v9[1] = -1LL;
    j__free(v9);
  }

  uint64_t v10 = *(void ***)(a1 + 48);
  if (v10)
  {
    do
    {
      uint64_t v11 = (void **)*v10;
      if ((*(_WORD *)(a1 + 968) & 0x80) != 0) {
        sub_10003E5F8(dword_10006A940, v10[3]);
      }
      xpc_release(v10[3]);
      uint64_t v12 = *v10;
      if (*v10) {
        v12[1] = v10[1];
      }
      *(void *)v10[1] = v12;
      free(v10);
      uint64_t v10 = v11;
    }

    while (v11);
  }

  free(*(void **)(a1 + 280));
  char v13 = *(void **)(a1 + 216);
  if (v13) {
    xpc_release(v13);
  }
  unint64_t v14 = *(void **)(a1 + 208);
  if (v14) {
    free(v14);
  }
  uint64_t v15 = *(void **)(a1 + 936);
  if (v15) {
    sub_10001685C(v15);
  }
  xpc_release(*(xpc_object_t *)(a1 + 128));
}

BOOL sub_1000257E4(id a1, const char *a2, void *a3)
{
  return 1;
}

void sub_100025814(uint64_t a1, mach_port_name_t *a2)
{
  uint64_t v2 = *(void *)a2;
  if (*(void *)a2) {
    *(void *)(v2 + 8) = *((void *)a2 + 1);
  }
  **((void **)a2 + 1) = v2;
  *(void *)a2 = -1LL;
  *((void *)a2 + 1) = -1LL;
  sub_100016BF8(a2);
}

uint64_t sub_100025848( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1LL;
}

void sub_10002587C( uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12 = sub_1000258E0(a1, 2);
  sub_10003AE8C(v12, a2, a3, &a9, v9);
  free(v12);
}

char *sub_1000258E0(uint64_t a1, int a2)
{
  uint64_t v4 = (const char **)sub_10000D8E8(0x80uLL);
  uint64_t v11 = v4;
  uint64_t v12 = *(void *)(a1 + 104);
  if ((_UNKNOWN *)v12 == &unk_1000695B8)
  {
    size_t v19 = "system";
  }

  else
  {
    if ((_UNKNOWN *)v12 != &unk_1000696C8)
    {
      sub_10000D960((uint64_t)v4, "%s/%lu", v5, v6, v7, v8, v9, v10, *(void *)(v12 + 112));
      goto LABEL_8;
    }

    int v23 = *(_DWORD *)(a1 + 56);
    size_t v19 = "gui/%u";
  }

  sub_10000D960((uint64_t)v4, v19, v5, v6, v7, v8, v9, v10, v23);
LABEL_8:
  if (a2 == 2)
  {
    uint64_t v20 = *(void **)(a1 + 104);
    if (v20 == &unk_100069750)
    {
      sub_10000D960((uint64_t)v11, " [%s]", v13, v14, v15, v16, v17, v18, *(void *)(a1 + 280));
    }

    else if (v20 == &unk_1000696C8)
    {
      sub_10000D960((uint64_t)v11, " [%lu]", v13, v14, v15, v16, v17, v18, *(void *)(a1 + 112));
    }
  }

  uint64_t v21 = sub_10000D930(v11);
  sub_10000D938((void **)v11);
  return v21;
}

BOOL sub_1000259FC(uint64_t a1)
{
  return *(void *)(a1 + 104) == (void)&unk_1000695B8;
}

void sub_100025A14(uint64_t a1, int a2)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 176);
  if (v2)
  {
    do
    {
      uint64_t v4 = *v2;
      if (*((_DWORD *)v2 + 8) == a2)
      {
        sub_10003E820(*((unsigned int *)v2 + 4), v2[3]);
        uint64_t v5 = *v2;
        if (*v2) {
          v5[1] = (uint64_t)v2[1];
        }
        *v2[1] = (uint64_t)v5;
        *uint64_t v2 = (uint64_t *)-1LL;
        v2[1] = (uint64_t *)-1LL;
      }

      uint64_t v2 = (uint64_t **)v4;
    }

    while (v4);
  }

void sub_100025A84(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 176);
  if (v2)
  {
    do
    {
      uint64_t v4 = (void *)*v2;
      if (*((_DWORD *)v2 + 8) == a2)
      {
        uint64_t v5 = (dispatch_queue_s *)sub_100011938();
        dispatch_async_f(v5, v2, (dispatch_function_t)sub_10002B39C);
        uint64_t v6 = (void *)*v2;
        if (*v2) {
          v6[1] = v2[1];
        }
        *(void *)v2[1] = v6;
        *uint64_t v2 = -1LL;
        v2[1] = -1LL;
      }

      uint64_t v2 = v4;
    }

    while (v4);
  }

void *sub_100025B08(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = v1 + 1;
  if (v1 < 0) {
    sub_100039448("underflow of active count during activate");
  }
  if (v1) {
    return (void *)sub_100016C50(a1);
  }
  if ((*(_WORD *)(a1 + 968) & 0x10) != 0) {
    sub_100039448("activation of deactivated domain");
  }
  return sub_1000167B0((void *)a1);
}

void sub_100025B64(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = v1 - 1;
  if (v1 <= 0) {
    sub_100039448("underflow of active count during deactivate");
  }
  if (v1 == 1)
  {
    __int16 v3 = *(_WORD *)(a1 + 968);
    if ((v3 & 1) == 0) {
      sub_100039448("inactive domain is not shutting down");
    }
    if ((v3 & 0x10) != 0) {
      sub_100039448("domain already deactivated");
    }
    for (uint64_t i = 304LL; i != 488; i += 8LL)
    {
      if (*(void *)(a1 + i)) {
        sub_100039448("domain cleaning up with services still in list");
      }
    }

    *(_WORD *)(a1 + 968) = v3 | 0x10;
    uint64_t v5 = *(void *)(a1 + 104);
    if ((*(_BYTE *)(v5 + 128) & 1) != 0)
    {
      uint64_t v6 = *(void *)(a1 + 128);
      if (v6) {
        LODWORD(sub_100010C04(15, v0, v1, v2, v3, v4, v5, v6) = xpc_mach_send_get_right(v6);
      }
      sub_10003E23C(v6);
      uint64_t v5 = *(void *)(a1 + 104);
    }

    (*(void (**)(uint64_t))(v5 + 96))(a1);
    sub_10001685C((void *)a1);
  }

  else
  {
    sub_100016C74(a1);
  }

void sub_100025C50( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __int16 v15 = *(_WORD *)(a1 + 968);
  if ((v15 & 3) != 0)
  {
    sub_10002587C(a1, 5, "already shutting down or slain", v10, v11, v12, v13, v14, a9);
  }

  else
  {
    if (*(void *)(a1 + 144))
    {
      sub_100016C74(a1);
      dispatch_set_context(*(dispatch_object_t *)(a1 + 144), *(void **)(a1 + 144));
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 144));
      *(void *)(a1 + 144) = 0LL;
      *(_DWORD *)(a1 + 152) = 0;
      __int16 v15 = *(_WORD *)(a1 + 968);
    }

    if (*(void *)(a1 + 136))
    {
      if ((v15 & 0x200) != 0)
      {
        sub_10002587C(a1, 5, "uncorking exec source for disposal", v10, v11, v12, v13, v14, v18);
        dispatch_activate(*(dispatch_object_t *)(a1 + 136));
        *(_WORD *)(a1 + 968) &= ~0x200u;
      }

      sub_100016C74(a1);
      dispatch_release(*(dispatch_object_t *)(a1 + 136));
      *(void *)(a1 + 136) = 0LL;
      __int16 v15 = *(_WORD *)(a1 + 968);
    }

    *(_WORD *)(a1 + 968) = v15 | 2;
    uint64_t v16 = (dispatch_queue_s *)sub_100011938();
    dispatch_async_f(v16, (void *)a1, (dispatch_function_t)sub_100025D60);
  }

BOOL sub_100025D50(uint64_t a1)
{
  return (*(_WORD *)(a1 + 968) & 3) != 0;
}

void sub_100025D60( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 968) & 1) != 0) {
    sub_100039448("multiple invocations of death handler for domain");
  }
  sub_10002587C(a1, 5, "shutting down", a4, a5, a6, a7, a8, v89);
  if (*(_UNKNOWN **)(a1 + 104) == &unk_1000695B8) {
    sub_100010DA0();
  }
  *(void *)(a1 + 240) = mach_absolute_time();
  *(_WORD *)(a1 + 968) |= 2u;
  sub_100010BC4(a1, 3);
  uint64_t v14 = 0LL;
  do
  {
    uint64_t v91 = v14;
    unint64_t v15 = a1 + 8 * v14;
    uint64_t v16 = *(void *)(v15 + 616);
    if (v16)
    {
      char v17 = (uint64_t *)(v15 + 616);
      do
      {
        sub_10002587C(a1, 5, "removing unmanaged service: %s", v9, v10, v11, v12, v13, v16 + 80);
        sub_10002C2D4(a1, v16);
        if (*(void *)(v16 + 152))
        {
          sub_10002587C(a1, 3, "Unmanaged service with non-dynamic endpoints: %s", v19, v20, v21, v22, v23, v16 + 80);
          uint64_t v24 = *(void *)(v16 + 152);
          if (v24)
          {
            do
            {
              uint64_t v25 = *(void *)(v24 + 16);
              sub_10002587C(a1, 3, "Removing unexpected non-dynamic endpoint: %s", v19, v20, v21, v22, v23, v24 - 88);
              sub_1000404D4(v24, v26, v27, v28, v29, v30, v31, v32);
              uint64_t v24 = v25;
            }

            while (v25);
          }
        }

        if (*(void *)(v16 + 176))
        {
          sub_10002587C(a1, 3, "Unmanaged service with event endpoints: %s", v19, v20, v21, v22, v23, v16 + 80);
          uint64_t v33 = *(void *)(v16 + 176);
          if (v33)
          {
            do
            {
              uint64_t v34 = *(void *)(v33 + 16);
              sub_10002587C(a1, 3, "Removing unexpected event endpoint: %s", v19, v20, v21, v22, v23, v33 - 88);
              sub_1000404D4(v33, v35, v36, v37, v38, v39, v40, v41);
              uint64_t v33 = v34;
            }

            while (v34);
          }
        }

        uint64_t v42 = *(void *)(v16 + 160);
        if (v42)
        {
          do
          {
            uint64_t v43 = *(void *)(v42 + 16);
            sub_10002587C(a1, 5, "removing unmanaged endpoint: %s", v19, v20, v21, v22, v23, v42 - 88);
            sub_1000404D4(v42, v44, v45, v46, v47, v48, v49, v50);
            uint64_t v42 = v43;
          }

          while (v43);
        }

        uint64_t v51 = *(void *)(v16 + 168);
        if (v51)
        {
          do
          {
            uint64_t v52 = *(void *)(v51 + 16);
            sub_10002587C(a1, 5, "removing unmanaged pid-local endpoint: %s", v19, v20, v21, v22, v23, v51 - 88);
            sub_1000404D4(v51, v53, v54, v55, v56, v57, v58, v59);
            uint64_t v51 = v52;
          }

          while (v52);
        }

        sub_10002B3F0(a1, v16, v18, v19, v20, v21, v22, v23);
        uint64_t v16 = *v17;
      }

      while (*v17);
    }

    uint64_t v14 = v91 + 1;
  }

  while (v91 != 6);
  sub_100010BC4(a1, 4);
  uint64_t v65 = *(void *)(a1 + 296);
  while (v65)
  {
    uint64_t v66 = v65;
    uint64_t v65 = *(void *)(v65 + 104);
    sub_10002587C(a1, 5, "removing semi-active service: %s", v60, v61, v62, v63, v64, v66 + 80);
    int v67 = sub_1000266FC(a1, v66);
    if (v67 && v67 != 36) {
      sub_100039448("failure to remove semi-active service");
    }
  }

  sub_100010BC4(a1, 5);
  for (uint64_t i = 0LL; i != 13; ++i)
  {
    uint64_t v74 = *(void *)(a1 + 8 * i + 512);
    while (v74)
    {
      while (1)
      {
        uint64_t v75 = v74;
        uint64_t v74 = *(void *)(v74 + 88);
        sub_10002587C(a1, 5, "removing active service: %s", v68, v69, v70, v71, v72, v75 + 80);
        int v76 = sub_1000266FC(a1, v75);
        if (v76)
        {
          if (v76 != 36) {
            break;
          }
        }

        if (!v74) {
          goto LABEL_31;
        }
      }

      _os_assumes_log_ctx(sub_10001C1B0, v75);
    }

void sub_100026264( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v10 = *(unsigned __int16 *)(a1 + 172);
  *(_WORD *)(a1 + 172) = v10 + 1;
  sub_100025B08(a1);
  if (!v10 && *(void **)(a1 + 104) != qword_100069750) {
    sub_10002587C(a1, 5, "entering bootstrap mode", v11, v12, v13, v14, v15, a9);
  }
}

void sub_1000262C4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(unsigned __int16 *)(a1 + 172);
  BOOL v10 = v9-- != 0;
  *(_WORD *)(a1 + 172) = v9;
  if (v9 == 0 || !v10)
  {
    if (*(void **)(a1 + 104) != qword_100069750) {
      sub_10002587C(a1, 5, "exiting bootstrap mode", a4, a5, a6, a7, a8, v19);
    }
    sub_100025A84(a1, 1);
    sub_100026360(a1);
    if ((*(_WORD *)(a1 + 968) & 0x40) != 0)
    {
      sub_1000263E4(a1, v11, v12, v13, v14, v15, v16, v17);
      *(_WORD *)(a1 + 968) &= ~0x40u;
      uint64_t v18 = (rb_tree_t **)sub_1000264FC(a1);
      sub_100035F64(v18);
    }
  }

  sub_100025B64(a1);
}

void sub_100026360(uint64_t a1)
{
  for (uint64_t i = 0LL; i != 23; ++i)
  {
    uint64_t v3 = *(void *)(a1 + 8 * i + 304);
    if (v3)
    {
      do
      {
        uint64_t v4 = *(void *)(v3 + 120);
        sub_1000167B0((void *)v3);
        if (*(_DWORD *)(v3 + 288)) {
          sub_10002B3D0(v3, v5, v6, v7, v8, v9, v10, v11);
        }
        sub_10001685C((void *)v3);
        uint64_t v3 = v4;
      }

      while (v4);
    }
  }

void sub_1000263E4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 160) = v8 - 1;
  if (!v8) {
    sub_100039448("underflow of on-demand count");
  }
  if (v8 <= 1)
  {
    if (*(_UNKNOWN **)(a1 + 104) != &unk_100069750) {
      sub_10002587C(a1, 5, "exiting ondemand mode", a4, a5, a6, a7, a8, v26);
    }
    for (uint64_t i = 0LL; i != 23; ++i)
    {
      uint64_t v11 = *(void *)(a1 + 8 * i + 304);
      if (v11)
      {
        do
        {
          uint64_t v12 = *(void *)(v11 + 120);
          if (*(_DWORD *)(v11 + 292))
          {
            sub_1000167B0((void *)v11);
            int v19 = sub_10001D3D8(v11, *(unsigned int *)(v11 + 292), v13, v14, v15, v16, v17, v18);
            if ((v19 & 0xFFFFFFFE) == 0x24) {
              int v25 = 0;
            }
            else {
              int v25 = v19;
            }
            if (v25)
            {
              if (v25 != 37) {
                sub_10001A4D8(v11, 3, "pended nondemand spawn failed: %d", v20, v21, v22, v23, v24, v25);
              }
            }

            *(_DWORD *)(v11 + 292) = 0;
            sub_10001685C((void *)v11);
          }

          uint64_t v11 = v12;
        }

        while (v12);
      }
    }
  }

void *sub_1000264FC(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 936);
  if (!result)
  {
    if (*(_UNKNOWN **)(a1 + 104) == &unk_1000695B8)
    {
      uint64_t result = sub_100035EFC(0LL);
    }

    else
    {
      uint64_t v3 = a1;
      do
      {
        uint64_t v4 = v3;
        uint64_t v3 = *(void *)(v3 + 200);
      }

      while (v3);
      uint64_t v5 = (void *)sub_1000264FC(v4);
      uint64_t result = sub_1000167B0(v5);
    }

    *(void *)(a1 + 936) = result;
  }

  return result;
}

uint64_t sub_100026568(uint64_t a1)
{
  if (*(_UNKNOWN **)(a1 + 104) == &unk_1000695B8) {
    byte_10006A930 = 0;
  }
  sub_10000E638(570425368LL, *(void *)(a1 + 112));
  return *(void *)(a1 + 112);
}

uint64_t sub_1000265C0(_DWORD *a1, uint64_t a2)
{
  if (*(_DWORD **)(a2 + 248) != a1)
  {
    uint64_t v13 = sub_10001C2A0(a2, 1);
    uint64_t v14 = sub_1000258E0((uint64_t)a1, 1);
    sub_100039448("%s is being added to a mismatched domain %s", v13, v14);
  }

  uint64_t v4 = (uint64_t *)&a1[2 * (sub_100012B50((_BYTE *)(a2 + 1360)) % 0x17uLL) + 76];
  uint64_t v5 = *v4;
  *(void *)(a2 + 120) = *v4;
  if (v5) {
    *(void *)(v5 + 128) = a2 + 120;
  }
  uint64_t *v4 = a2;
  *(void *)(a2 + 128) = v4;
  ++a1[41];
  *(void *)(a2 + 248) = sub_1000167B0(a1);
  if (!*(_DWORD *)(a2 + 296)) {
    *(_DWORD *)(a2 + 368) |= 6u;
  }
  ++*(_WORD *)(a2 + 300);
  sub_100025B08((uint64_t)a1);
  sub_10002B3F0((uint64_t)a1, a2, v6, v7, v8, v9, v10, v11);
  uint64_t result = sub_10001CB2C(a2);
  if ((result & 1) == 0)
  {
    sub_10001A134(a2);
    return sub_10001D218(a2);
  }

  return result;
}

uint64_t sub_1000266FC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 368);
  if ((v4 & 0x600) == 0x200)
  {
    uint64_t v5 = *(void *)(a2 + 40);
    if (v5 == -1)
    {
      uint64_t v8 = *(void *)(a2 + 48);
      if (v8 == -1) {
        sub_100039448("multiple attempts to remove service instance");
      }
    }

    else
    {
      if (!v5)
      {
        uint64_t v6 = *(void **)(a2 + 48);
        uint64_t v7 = *(void *)(a2 + 256);
        *(_DWORD *)(v7 + 240) = *(_DWORD *)(v7 + 224);
        *(void *)(v7 + 232) = *(void *)(v7 + 216);
        *(_DWORD *)(v7 + 224) = 5708;
        *(void *)(v7 + 208) = v6;
        *(void *)(v7 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
LABEL_9:
        *uint64_t v6 = v5;
        *(void *)(a2 + 40) = -1LL;
        *(void *)(a2 + 48) = -1LL;
        *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 64);
        *(void *)(a2 + 72) = *(void *)(a2 + 56);
        *(_DWORD *)(a2 + 64) = 5708;
        *(void *)(a2 + 56) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
        int v4 = *(_DWORD *)(a2 + 368) | 0x400;
        goto LABEL_10;
      }

      uint64_t v8 = *(void *)(a2 + 48);
    }

    *(void *)(v5 + 48) = v8;
    uint64_t v6 = *(void **)(a2 + 48);
    goto LABEL_9;
  }

char *sub_1000268C8(_DWORD *a1, uint64_t a2, unsigned __int8 *uu1, int a4, uint64_t *a5, _OWORD *a6, int *a7)
{
  if (*(_DWORD **)(a2 + 248) != a1) {
    sub_100046EB4();
  }
  if (a5) {
    uint64_t v14 = *a5;
  }
  else {
    uint64_t v14 = 0LL;
  }
  uint64_t v15 = sub_1000208F0(a2, uu1);
  if (v15)
  {
    uint64_t v21 = (char *)v15;
    if (!xpc_binprefs_equal(*(void *)(v15 + 880), v14))
    {
      uint64_t v27 = xpc_binprefs_copy_description(*((void *)v21 + 110));
      uint64_t v54 = xpc_binprefs_copy_description(v14);
      sub_10001A4D8((uint64_t)v21, 4, "Mismatched binprefs: %s != %s", v28, v29, v30, v31, v32, (char)v27);
      free(v27);
      free(v54);
    }

    if (((*((_DWORD *)v21 + 92) >> 5) & 1) != a4) {
      sub_10001A4D8( (uint64_t)v21,  4,  "One-shot property mismatch: requested=%d existing=%d",  v22,  v23,  v24,  v25,  v26,  a4);
    }
  }

  else
  {
    unint64_t v33 = *(unsigned int *)(a2 + 264);
    if (qword_10006A9A8 <= v33)
    {
      uint64_t v34 = **(void **)(*(void *)(a2 + 208) + 8LL);
      if (v34)
      {
        while (1)
        {
          if ((sub_10001CB2C(v34) & 1) == 0) {
            sub_100046EB4();
          }
          if ((*(_BYTE *)(v34 + 368) & 0x10) == 0) {
            break;
          }
          uint64_t v34 = **(void **)(*(void *)(v34 + 48) + 8LL);
          if (!v34)
          {
            LODWORD(v33) = *(_DWORD *)(a2 + 264);
            goto LABEL_16;
          }
        }

        sub_10002587C( (uint64_t)a1,  4,  "Too many instances (%d >= %lu : %d), slaying '%s' to make room",  v16,  v17,  v18,  v19,  v20,  *(_DWORD *)(a2 + 264));
        int v47 = sub_1000266FC((uint64_t)a1, v34);
        if (v47 && v47 != 36) {
          sub_100047744((uint64_t)a1, v47, v48, v49, v50, v51, v52, v53);
        }
      }

      else
      {
LABEL_16:
        sub_10002587C( (uint64_t)a1,  4,  "Too many instances (%d >= %lu : %d), but nothing to slay since all instances are already being removed.",  v16,  v17,  v18,  v19,  v20,  v33);
      }
    }

    sub_100026C3C((uint64_t)a1, a2);
    v55[0] = sub_100026D10;
    v55[1] = sub_1000270F8;
    v55[2] = sub_10002723C;
    v55[3] = sub_1000273D4;
    v55[4] = sub_10002742C;
    v55[5] = sub_100027520;
    v55[6] = a1;
    uint64_t v21 = sub_100003C3C(a2, uu1, 0xFFFFFFFFLL, (uint64_t)a5, a6, (uint64_t)v55, 0LL, a7);
    if (v21)
    {
      for (uint64_t i = *(void *)(a2 + 152); i; uint64_t i = *(void *)(i + 16))
      {
        if ((*(_BYTE *)(i + 88) & 0x40) == 0)
        {
          sub_10003F9F0(i, (unint64_t)sub_10002762C, (unint64_t)v21, (unint64_t)v21);
          sub_100027850((size_t)a1, v21, v36, 64);
        }
      }

      sub_1000265C0(a1, (uint64_t)v21);
      uint64_t v37 = (char **)(a2 + 200);
      uint64_t v38 = *(void *)(a2 + 200);
      ++*(_DWORD *)(a2 + 264);
      *((void *)v21 + 5) = v38;
      if (v38) {
        uint64_t v39 = (void *)(v38 + 48);
      }
      else {
        uint64_t v39 = (void *)(a2 + 208);
      }
      *uint64_t v39 = v21 + 40;
      int *v37 = v21;
      *(_DWORD *)(a2 + 240) = *(_DWORD *)(a2 + 224);
      *(void *)(a2 + 232) = *(void *)(a2 + 216);
      *(_DWORD *)(a2 + 224) = 6463;
      *(void *)(a2 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
      *((_DWORD *)v21 + 20) = *((_DWORD *)v21 + 16);
      *((void *)v21 + 9) = *((void *)v21 + 7);
      *((_DWORD *)v21 + 16) = 6463;
      *((void *)v21 + 6) = v37;
      *((void *)v21 + 7) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
      *((_DWORD *)v21 + 92) |= 0x200u;
      *((void *)v21 + 32) = a2;
      sub_1000167B0((void *)a2);
      if (a4) {
        *((_DWORD *)v21 + 92) |= 0x20u;
      }
    }

    else
    {
      int v40 = *a7;
      xpc_strerror(*a7);
      sub_10001A4D8(a2, 3, "Could not create copy of service: %d: %s", v41, v42, v43, v44, v45, v40);
    }
  }

  return v21;
}

uint64_t sub_100026C3C(uint64_t a1, uint64_t a2)
{
  if (*(_UNKNOWN **)(a1 + 104) == &unk_100069750)
  {
    uint64_t v2 = sub_100003598(a2);
    if (!v2) {
      return v2;
    }
    sub_10001A4D8(a2, 5, "initialized endpoint after lookup", v6, v7, v8, v9, v10, v16);
    if ((*(_BYTE *)(a2 + 368) & 1) != 0) {
      sub_100039448("lazy initialization of endpoint on semi-active service");
    }
    if (!sub_10002BE4C(a1, v2))
    {
      sub_100040070(v2);
      return v2;
    }

    sub_10001A4D8(a2, 3, "Failed to initialize implicit endpoint", v11, v12, v13, v14, v15, v17);
    sub_10002BBE0(a1, v2);
  }

  return 0LL;
}

void sub_100026D10( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch((int)a2)
  {
    case 0:
      if (*(_WORD *)(a1 + 300)) {
        sub_100039448("will-spawn received on active service");
      }
      if ((*(_BYTE *)(a1 + 368) & 1) != 0) {
        sub_100039448("multiple will-spawn events received");
      }
      sub_100026C3C(a4, a1);
      for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
        sub_1000403A0(i);
      for (uint64_t j = *(void *)(a1 + 176); j; uint64_t j = *(void *)(j + 16))
        sub_1000403A0(j);
      for (uint64_t k = *(void *)(a1 + 184); k; uint64_t k = *(void *)(k + 16))
        sub_1000403A0(k);
      for (uint64_t m = *(void *)(a1 + 192); m; uint64_t m = *(void *)(m + 16))
        sub_100018EE4(m);
      sub_10001DCB0(a1);
      *(_DWORD *)(a1 + 368) |= 1u;
      uint64_t v14 = (uint64_t *)(*(void *)(a1 + 248) + 296LL);
      uint64_t v15 = *v14;
      *(void *)(a1 + 104) = *v14;
      if (v15) {
        *(void *)(v15 + 112) = a1 + 104;
      }
      *uint64_t v14 = a1;
      *(void *)(a1 + 112) = v14;
      sub_100001824(a1);
      return;
    case 1:
      if ((*(_BYTE *)(a1 + 368) & 1) == 0) {
        sub_100039448("out-of-order spawn event received");
      }
      uint64_t v16 = *(void *)(a1 + 104);
      if (v16) {
        *(void *)(v16 + 112) = *(void *)(a1 + 112);
      }
      **(void **)(a1 + 112) = v16;
      *(void *)(a1 + 104) = -1LL;
      *(void *)(a1 + 112) = -1LL;
      *(_DWORD *)(a1 + 368) &= ~1u;
      *(_DWORD *)(a1 + 292) = 0;
      if (!(_DWORD)a3) {
        goto LABEL_21;
      }
      sub_100001940(a1, a2, a3, a4, a5, a6, a7, a8, v39);
      if ((*(_BYTE *)(a1 + 368) & 0x10) != 0) {
        sub_10002B73C(a4, a1, v17, v18, v19, v20, v21, v22);
      }
      else {
        sub_10002BA6C((void *)a1);
      }
      return;
    case 4:
      *(_DWORD *)(a1 + 360) = a3;
      *(_DWORD *)(a1 + 364) = a3;
      if (a3) {
        return;
      }
      uint64_t v23 = sub_10001DD5C(a1);
      uint64_t v24 = sub_10002A7D4(qword_100069750, (int)v23);
      if (v24)
      {
        uint64_t v30 = v24;
        if ((*(_WORD *)(v24 + 968) & 0x200) != 0)
        {
          sub_10002587C(v24, 5, "uncorking exec source after service init", v25, v26, v27, v28, v29, v39);
          dispatch_activate(*(dispatch_object_t *)(v30 + 136));
          *(_WORD *)(v30 + 968) &= ~0x200u;
        }
      }

      int v40 = 0;
      if (csops(v23, 0LL, &v40, 4LL))
      {
        if (*__error() != 3)
        {
          uint64_t v31 = __error();
          sub_10003AB68(65539, "csops returned %d", *v31);
          goto LABEL_52;
        }
      }

      else if ((v40 & 0x4000000) == 0)
      {
LABEL_52:
        uint64_t v36 = (const char *)sub_10001E38C(a1);
        sub_1000394A4("unexpected exec of non-platform binary: %s: %s [%d]", v36, (const char *)(a1 + 1360), v23);
      }

      return;
    case 5:
      if (byte_10006A919 && (*(_WORD *)(a4 + 968) & 3) == 0 && !*(_DWORD *)(a1 + 296))
      {
        int v32 = sub_10001DD5C(a1);
        if (!v32) {
          sub_100046EB4();
        }
        if (v32 == dword_10006A548)
        {
          uint64_t v37 = sub_10001E50C(a1);
          uint64_t v38 = sub_10003D968(v37);
          sub_10003AB68(0x10000, "Obliterator task exited: %s", v38);
          sub_10003AB68(0x10000, "The system may be in an inconsistent half-obliterated state.");
          sub_10003AB68(0x10000, "Rebooting now, so the finish-obliteration boot task can clean things up.");
          sub_10003A11C(1, 0);
        }
      }

      int v33 = *(_DWORD *)(a1 + 368);
      if ((v33 & 0x120) != 0) {
        *(_DWORD *)(a1 + 368) = v33 | 0x10;
      }
      sub_100001940(a1, a2, a3, a4, a5, a6, a7, a8, v39);
      for (uint64_t n = *(void *)(a1 + 192); n; uint64_t n = *(void *)(n + 16))
      {
        if ((*(_WORD *)(n + 204) & 1) != 0) {
          sub_10001905C(n);
        }
      }

      if ((*(_BYTE *)(a1 + 369) & 0x10) != 0)
      {
        sub_1000263E4(a4, v34, a3, a4, a5, a6, a7, a8);
        *(_DWORD *)(a1 + 368) &= ~0x1000u;
      }

      goto LABEL_43;
    case 6:
      sub_10002B6F8(a1);
      return;
    case 7:
LABEL_21:
      sub_10002C2D4(a4, a1);
      return;
    case 8:
LABEL_43:
      sub_10002B3F0(a4, a1, a3, a4, a5, a6, a7, a8);
      return;
    default:
      return;
  }

uint64_t sub_1000270F8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a3 + 968) & 3) != 0)
  {
    sub_10002587C(a3, 5, "denying spawn, domain shutting down: %s", a4, a5, a6, a7, a8, a1 + 80);
    return 124LL;
  }

  int v10 = a2;
  int v11 = *(_DWORD *)(a1 + 368);
  if ((v11 & 2) != 0)
  {
    sub_10002587C(a3, 5, "pending spawn, service not yet activated: %s", a4, a5, a6, a7, a8, a1 + 80);
    goto LABEL_7;
  }

  if (*(_WORD *)(a1 + 300))
  {
    sub_10002587C(a3, 5, "pending spawn, service not yet quiesced: %s", a4, a5, a6, a7, a8, a1 + 80);
    goto LABEL_7;
  }

  if (*(_DWORD *)(a3 + 160))
  {
    uint64_t v12 = 0LL;
    while (dword_100069590[v12] != (_DWORD)a2)
    {
      if (++v12 == 8)
      {
        if (*(_DWORD *)(a1 + 292) != (_DWORD)a2)
        {
          *(_DWORD *)(a1 + 292) = a2;
          sub_10002587C(a3, 5, "pending spawn, domain in on-demand-only mode: %s", a4, a5, a6, a7, a8, a1 + 80);
        }

        return 36LL;
      }
    }
  }

  if ((v11 & 4) == 0)
  {
    sub_10002587C(a3, 5, "pending spawn, service not yet imported: %s", a4, a5, a6, a7, a8, a1 + 80);
LABEL_7:
    *(_DWORD *)(a1 + 288) = v10;
    return 36LL;
  }

  if ((*(_WORD *)(a3 + 968) & 0x2000) != 0) {
    goto LABEL_7;
  }
  if (!*(_WORD *)(a3 + 172)) {
    return 0LL;
  }
  uint64_t result = sub_1000209CC(a1, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result) {
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_10002723C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a2 + 968) & 3) != 0)
  {
    sub_10002587C(a2, 5, "resetting service: %s", a4, a5, a6, a7, a8, (_BYTE)a1 + 80);
    sub_10002BD80(a2, (uint64_t)a1);
    return 0LL;
  }

  if (a1[20])
  {
    sub_10002587C(a2, 4, "Service cannot reset: active unmanaged endpoints", a4, a5, a6, a7, a8, v39);
    sub_10002587C(a2, 5, "cannot reset service active unmanaged endpoints: %s", v11, v12, v13, v14, v15, (_BYTE)a1 + 80);
  }

  else if (a1[21])
  {
    sub_10002587C(a2, 4, "Service cannot reset: active PID-local endpoints", a4, a5, a6, a7, a8, v39);
    sub_10002587C(a2, 5, "cannot reset service active pid-local endpoints: %s", v16, v17, v18, v19, v20, (_BYTE)a1 + 80);
  }

  else
  {
    uint64_t v21 = a1[19];
    if (v21)
    {
      while ((*(_BYTE *)(v21 + 88) & 4) == 0)
      {
        uint64_t v21 = *(void *)(v21 + 16);
        if (!v21) {
          goto LABEL_12;
        }
      }

      sub_10002587C(a2, 4, "Service cannot reset: active endpoints", a4, a5, a6, a7, a8, v39);
      sub_10002587C(a2, 5, "cannot reset service active endpoints: %s", v24, v25, v26, v27, v28, (_BYTE)a1 + 80);
    }

    else
    {
LABEL_12:
      uint64_t v22 = a1[22];
      if (v22)
      {
        while ((*(_BYTE *)(v22 + 88) & 4) == 0)
        {
          uint64_t v22 = *(void *)(v22 + 16);
          if (!v22) {
            goto LABEL_15;
          }
        }

        sub_10002587C(a2, 4, "Service cannot reset: active event channels", a4, a5, a6, a7, a8, v39);
        sub_10002587C(a2, 5, "cannot reset service active event channels: %s", v29, v30, v31, v32, v33, (_BYTE)a1 + 80);
      }

      else
      {
LABEL_15:
        uint64_t v23 = a1[23];
        if (!v23) {
          return 0LL;
        }
        uint64_t result = 0LL;
        while ((*(_BYTE *)(v23 + 88) & 4) == 0)
        {
          uint64_t v23 = *(void *)(v23 + 16);
          if (!v23) {
            return result;
          }
        }

        sub_10002587C(a2, 4, "Service cannot reset: active instance endpoints", a4, a5, a6, a7, a8, v39);
        sub_10002587C( a2,  5,  "cannot reset service: active instance endpoints: %s",  v34,  v35,  v36,  v37,  v38,  (_BYTE)a1 + 80);
      }
    }
  }

  return 16LL;
}

char *sub_1000273D4(void *a1, const char *a2, void *a3, uint64_t a4, _BYTE *a5, size_t a6)
{
  uint64_t v8 = sub_10003F590((uint64_t)a1, a2, a3, (uint64_t)sub_10002762C, a5, (uint64_t)a1);
  if (v8) {
    sub_100027850(a6, a1, (uint64_t)v8, 0);
  }
  return v8;
}

char *sub_10002742C(uint64_t a1, const char *a2, void *a3, _BYTE *a4, uint64_t a5)
{
  if ((*(_BYTE *)(a5 + 96) & 1) != 0) {
    int v10 = *(_DWORD *)(a5 + 56);
  }
  else {
    int v10 = 0;
  }
  uint64_t v11 = (dispatch_object_s *)sub_100011938();
  uint64_t v12 = sub_1000177CC(a1, a5, a2, v10, a3, v11, (uint64_t)sub_10002C424, a1, (uint64_t)a4);
  if (sub_100019054((uint64_t)v12))
  {
    uint64_t v13 = sub_100019054((uint64_t)v12);
    uint64_t v14 = (const char *)xpc_strerror(v13);
    sub_100011A84(a4, 4LL, "Ignored socket %s: %s", a2, v14);
    sub_10001685C(v12);
    return 0LL;
  }

  else
  {
    uint64_t v17 = *(void *)(a1 + 192);
    uint64_t v16 = (char **)(a1 + 192);
    uint64_t v15 = v17;
    *((void *)v12 + 2) = v17;
    if (v17) {
      *(void *)(v15 + 24) = v12 + 16;
    }
    *uint64_t v16 = v12;
    *((void *)v12 + 3) = v16;
  }

  return v12;
}

void sub_100027520( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void **)(a2 + 104) != qword_100069750 && sub_100003598(a1)) {
    sub_10001A4D8(a1, 5, "created the implicit endpoint upfront", a4, a5, a6, a7, a8, v24);
  }
  uint64_t v10 = *(void *)(a1 + 192);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 16);
      uint64_t v12 = *(void *)(v10 + 56);
      sub_100026264(a2, 9LL, a3, a4, a5, a6, a7, a8, v24);
      ++*(_WORD *)(v12 + 300);
      *(_DWORD *)(v12 + 368) |= 8u;
      sub_100017EFC(v10, v13, v14, v15, v16, v17, v18, v19);
      uint64_t v10 = v11;
    }

    while (v11);
  }

  uint64_t v20 = *(void **)(a1 + 152);
  while (v20)
  {
    uint64_t v21 = v20;
    uint64_t v22 = v20 + 2;
    uint64_t v20 = (void *)v20[2];
    if ((v22[9] & 0x40) == 0 && sub_10002BE4C(a2, (uint64_t)v21))
    {
      uint64_t v23 = *v22;
      if (*v22) {
        *(void *)(v23 + 24) = v21[3];
      }
      *(void *)v21[3] = v23;
      *uint64_t v22 = -1LL;
      v22[1] = -1LL;
      sub_10001685C(v21);
    }
  }

void sub_10002762C( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a3 + 248);
  if ((*(_BYTE *)(a1 + 88) & 8) != 0) {
    uint64_t v11 = 8LL;
  }
  else {
    uint64_t v11 = 1LL;
  }
  if (a2 == 1)
  {
    if ((*(_BYTE *)(a3 + 369) & 8) != 0) {
      sub_10002587C(v10, 7, "Deactivated abandoned endpoint: %s", a4, a5, a6, a7, a8, a1 - 88);
    }
    if (sub_10003FE08(a1)) {
      *(_BYTE *)(a1 + 88) &= ~4u;
    }
    else {
      sub_10002BBE0(v10, a1);
    }
    sub_10002B3F0(v10, a3, v31, v32, v33, v34, v35, v36);
  }

  else
  {
    if (a2) {
      return;
    }
    mach_port_name_t v12 = sub_10003F1E0(a1, 4, a3, a4, a5, a6, a7, a8);
    if (byte_10006A919)
    {
      mach_port_name_t v19 = v12;
      mach_port_seqno_t request_seqnop = 0;
      int v46 = 0;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      *(_OWORD *)trailer_infop = 0u;
      mach_msg_size_t msg_sizep = 0;
      mach_msg_type_number_t trailer_infopCnt = 52;
      mach_msg_id_t msg_idp = 0;
      if (mach_port_peek( mach_task_self_,  v12,  0x3000000u,  &request_seqnop,  &msg_sizep,  &msg_idp,  trailer_infop,  &trailer_infopCnt))
      {
LABEL_13:
        return;
      }

      while (1)
      {
        sub_10002587C(v10, 5, "peeking at message: seqno = %u, pid = %d", v20, v21, v22, v23, v24, request_seqnop);
        if (!DWORD2(v45) || DWORD2(v45) == dword_10006A548) {
          break;
        }
        ++request_seqnop;
        if (mach_port_peek( mach_task_self_,  v19,  0x3000000u,  &request_seqnop,  &msg_sizep,  &msg_idp,  trailer_infop,  &trailer_infopCnt))
        {
          goto LABEL_13;
        }
      }

      sub_10002587C(v10, 5, "port has message from obliterator or kernel", v25, v26, v27, v28, v29, v39);
    }

    int v37 = sub_10001D3D8(a3, v11, v13, v14, v15, v16, v17, v18);
    if ((v37 & 0xFFFFFFFE) == 0x24) {
      int v38 = 0;
    }
    else {
      int v38 = v37;
    }
    if (v38)
    {
      if (v38 == 37) {
        sub_100039448("endpoint event received for running service");
      }
      _os_assumes_log_ctx(sub_10001C1B0, a3);
    }
  }

size_t sub_100027850(size_t result, void *a2, uint64_t a3, char a4)
{
  if ((a4 & 4) != 0)
  {
    size_t v9 = result;
    size_t v10 = strlen((const char *)(a3 + 168));
    size_t v11 = v10 + 168;
    BOOL v12 = v10 >= 0xFFFFFFFFFFFFFF58LL;
    uint64_t result = v10 + 169;
    uint64_t v13 = v11 == -1LL;
    uint64_t v14 = v13 << 63 >> 63;
    BOOL v15 = v14 != v13;
    if (v12 || v15 || v14 < 0)
    {
      __break(1u);
    }

    else
    {
      uint64_t v16 = (char *)sub_100010B00(result);
      uint64_t v17 = strcpy(v16 + 168, (const char *)(a3 + 168));
      *((void *)v16 + 9) = a3;
      uint64_t v20 = *(void *)(a3 + 64);
      mach_port_name_t v19 = (char **)(a3 + 64);
      uint64_t v18 = v20;
      *((void *)v16 + 6) = v20;
      if (v20) {
        *(void *)(v18 + 56) = v16 + 48;
      }
      *mach_port_name_t v19 = v16;
      *((void *)v16 + 7) = v19;
      uint64_t result = sub_100012B50(v17);
      uint64_t v21 = (char **)(v9 + 8 * (result % 0x1F) + 672);
      uint64_t v22 = *v21;
      *((void *)v16 + 4) = *v21;
      if (v22) {
        *((void *)v22 + 5) = v16 + 32;
      }
      void *v21 = v16;
      *((void *)v16 + 5) = v21;
    }
  }

  else
  {
    uint64_t v5 = (void *)(a3 + 16);
    if (*(void *)(a3 + 16) != -1LL || *(void *)(a3 + 24) != -1LL) {
      sub_100039448("attempting to re-add an endpoint into service");
    }
    if ((a4 & 2) != 0)
    {
      uint64_t v23 = a2[21];
      uint64_t v6 = a2 + 21;
      uint64_t v7 = v23;
    }

    else if ((a4 & 0x10) != 0)
    {
      uint64_t v24 = a2[22];
      uint64_t v6 = a2 + 22;
      uint64_t v7 = v24;
    }

    else if ((a4 & 0x40) != 0)
    {
      uint64_t v25 = a2[23];
      uint64_t v6 = a2 + 23;
      uint64_t v7 = v25;
    }

    else if ((a4 & 1) != 0)
    {
      uint64_t v26 = a2[20];
      uint64_t v6 = a2 + 20;
      uint64_t v7 = v26;
    }

    else
    {
      uint64_t v8 = a2[19];
      uint64_t v6 = a2 + 19;
      uint64_t v7 = v8;
    }

    void *v5 = v7;
    if (v7) {
      *(void *)(v7 + 24) = v5;
    }
    *uint64_t v6 = a3;
    *(void *)(a3 + 24) = v6;
  }

  return result;
}

uint64_t sub_1000279B0(uint64_t a1, FILE *a2)
{
  uint64_t result = sub_100027A2C(a1, a2);
  for (uint64_t i = 0LL; i != 23; ++i)
  {
    for (uint64_t j = *(void *)(a1 + 8 * i + 304); j; uint64_t j = *(void *)(j + 120))
      uint64_t result = sub_10001E694(j, a2, 0LL);
  }

  for (uint64_t k = *(void *)(a1 + 288); k; uint64_t k = *(void *)(k + 16))
    uint64_t result = sub_1000279B0(k, a2);
  return result;
}

uint64_t sub_100027A2C(uint64_t a1, FILE *a2)
{
  uint64_t v3 = a1;
  int v4 = sub_1000258E0(a1, 1);
  sub_10003D32C(a2, 0LL, "%s = {", v5, v6, v7, v8, v9, v4);
  free(v4);
  sub_10003D32C(a2, 1LL, "xpc_type_t type = %s", v10, v11, v12, v13, v14, *(void *)(*(void *)(v3 + 104) + 112LL));
  sub_10003D32C(a2, 1LL, "pid_t handle = %lu", v15, v16, v17, v18, v19, *(void *)(v3 + 112));
  sub_10003D32C(a2, 1LL, "active size_t count = %d", v20, v21, v22, v23, v24, *(unsigned int *)(v3 + 156));
  if (*(_DWORD *)(v3 + 160)) {
    sub_10003D32C(a2, 1LL, "on-demand size_t count = %d", v25, v26, v27, v28, v29, *(unsigned int *)(v3 + 160));
  }
  if (*(_DWORD *)(v3 + 164)) {
    sub_10003D32C(a2, 1LL, "service size_t count = %u", v25, v26, v27, v28, v29, *(unsigned int *)(v3 + 164));
  }
  if (*(_DWORD *)(v3 + 168)) {
    sub_10003D32C(a2, 1LL, "active service size_t count = %u", v25, v26, v27, v28, v29, *(unsigned int *)(v3 + 168));
  }
  if (*(_UNKNOWN **)(v3 + 104) == &unk_1000695B8)
  {
    uint64_t v30 = sub_100001F54();
    if (v30) {
      sub_10003D32C(a2, 1LL, "boot mode = %s", v31, v32, v33, v34, v35, v30);
    }
    *(void *)&__int128 v350 = 0LL;
    if (sub_1000017BC((unint64_t *)&v350))
    {
      sub_10003D32C(a2, 1LL, "prob guard = true", v36, v37, v38, v39, v40);
      sub_10003D32C(a2, 1LL, "prob guard sample rate = %zu", v41, v42, v43, v44, v45, (void)v350);
    }

    sub_10003D32C( a2,  1LL,  "maximum allowed shutdown time = %d s",  v36,  v37,  v38,  v39,  v40,  dword_100069A44);
    sub_10003D32C(a2, 1LL, "service stats = {", v46, v47, v48, v49, v50);
    v349[0] = _NSConcreteStackBlock;
    v349[1] = 0x40000000LL;
    v349[2] = sub_10002C7EC;
    v349[3] = &unk_1000648E0;
    v349[4] = a2;
    v349[5] = 0LL;
    sub_100001548((uint64_t)v349);
    sub_10003D32C(a2, 1LL, "}", v51, v52, v53, v54, v55);
  }

  if (*(void *)(v3 + 208)) {
    sub_10003D32C(a2, 1LL, "originator = %s", v25, v26, v27, v28, v29, *(void *)(v3 + 208));
  }
  sub_10003D32C( a2,  1LL,  "creator = %s[%d]",  v25,  v26,  v27,  v28,  v29,  *(void *)(v3 + 280),  *(unsigned int *)(v3 + 268));
  uint64_t v339 = *(unsigned int *)(v3 + 252);
  sub_10003D32C(a2, 1LL, "creator euid = %d", v56, v57, v58, v59, v60);
  if (*(void **)(v3 + 104) == qword_100069750)
  {
    uint64_t v339 = *(void *)(v3 + 120);
    sub_10003D32C(a2, 1LL, "uniqueid = %llu", v61, v62, v63, v64, v65);
  }

  sub_10003D32C(a2, 1LL, "security context = {", v61, v62, v63, v64, v65);
  if ((*(_BYTE *)(v3 + 96) & 1) != 0)
  {
    uint64_t v339 = *(unsigned int *)(v3 + 56);
    uint64_t v71 = "uid = %u";
  }

  else
  {
    uint64_t v71 = "uid unset";
  }

  sub_10003D32C(a2, 2LL, v71, v66, v67, v68, v69, v70, v339);
  sub_10003D32C(a2, 1LL, "}", v72, v73, v74, v75, v76);
  sub_10003D3A8(a2, v77, v78, v79, v80, v81, v82, v83, v340);
  unint64_t v89 = *(void *)(v3 + 232);
  if (v89) {
    sub_10003D32C(a2, 1LL, "bringup time = %llu ms", v84, v85, v86, v87, v88, v89 / 0xF4240);
  }
  if (*(void *)(v3 + 216))
  {
    sub_10003D32C(a2, 1LL, "xpc service paths = {", v84, v85, v86, v87, v88);
    *(void *)&__int128 v350 = 0LL;
    *((void *)&v350 + 1) = a2;
    *(void *)&__int128 v351 = 2LL;
    xpc_dictionary_apply_f(*(void *)(v3 + 216));
    sub_10003D32C(a2, 1LL, "}", v90, v91, v92, v93, v94);
  }

  sub_10003D32C(a2, 1LL, "death uint64_t port = 0x%x", v84, v85, v86, v87, v88, *(unsigned int *)(v3 + 152));
  if (*(_WORD *)(v3 + 172))
  {
    LOWORD(v341) = *(_WORD *)(v3 + 172);
    sub_10003D32C(a2, 1LL, "in-progress bootstraps = %hu", v97, v98, v99, v100, v101);
  }

  if (*(void *)(v3 + 176))
  {
    sub_10003D32C(a2, 1LL, "pending requests = {", v97, v98, v99, v100, v101);
    for (uint64_t i = *(void **)(v3 + 176); i; uint64_t i = (void *)*i)
    {
      __int128 v352 = 0u;
      __int128 v353 = 0u;
      __int128 v350 = 0u;
      __int128 v351 = 0u;
      memset(v348, 0, sizeof(v348));
      xpc_dictionary_get_audit_token(i[3], v348);
      LOBYTE(v341) = sub_100039990((uint64_t)v348, (char *)&v350);
      sub_10003D32C(a2, 2LL, "caller = %s.%d, event = %d", v108, v109, v110, v111, v112);
    }

    sub_10003D32C(a2, 1LL, "}", v102, v103, v104, v105, v106);
  }

  if (*(void *)(v3 + 288))
  {
    sub_10003D32C(a2, 1LL, "subdomains = {", v97, v98, v99, v100, v101);
    for (uint64_t j = *(void *)(v3 + 288); j; uint64_t j = *(void *)(j + 16))
    {
      if (*(void **)(j + 104) != qword_100069750 || !*(void *)(j + 216))
      {
        uint64_t v341 = sub_1000258E0(j, 1);
        sub_10003D32C(a2, 2LL, "%s", v119, v120, v121, v122, v123);
        free(v341);
      }
    }

    sub_10003D32C(a2, 1LL, "}", v113, v114, v115, v116, v117);
  }

  uint64_t v346 = v3;
  if (*(void *)(v3 + 48))
  {
    sub_10003D32C(a2, 1LL, "pending attachments = {", v97, v98, v99, v100, v101);
    for (uint64_t k = *(void **)(v3 + 48); k; uint64_t k = (void *)*k)
      sub_10003D32C(a2, 2LL, "%s", v124, v125, v126, v127, v128, k[2]);
    sub_10003D32C(a2, 1LL, "}", v124, v125, v126, v127, v128);
    uint64_t v3 = v346;
  }

  if (*(_UNKNOWN **)(v3 + 104) == &unk_1000695B8) {
    sub_10001E5E0(a2, 0LL, v96, v97, v98, v99, v100, v101);
  }
  if (*(void *)(v3 + 88))
  {
    sub_10003D3A8(a2, v95, v96, v97, v98, v99, v100, v101, (char)v341);
    sub_10003D32C(a2, 1LL, "environment = {", v130, v131, v132, v133, v134);
    for (uint64_t m = *(void **)(v3 + 88); m; uint64_t m = (void *)*m)
      sub_100016A10((uint64_t)m, 2LL, a2);
    sub_10003D32C(a2, 1LL, "}", v135, v136, v137, v138, v139);
  }

  sub_10003D3A8(a2, v95, v96, v97, v98, v99, v100, v101, (char)v341);
  sub_10003D32C(a2, 1LL, "services = {", v141, v142, v143, v144, v145);
  for (uint64_t n = 0LL; n != 23; ++n)
  {
    for (iuint64_t i = *(void *)(v3 + 8 * n + 304); ii; iuint64_t i = *(void *)(ii + 120))
      sub_100020664(ii, a2, 2LL, v146, v147, v148, v149, v150);
  }

  sub_10003D32C(a2, 1LL, "}", v146, v147, v148, v149, v150);
  if (os_map_str_count(v3 + 488))
  {
    sub_10003D3A8(a2, v153, v154, v155, v156, v157, v158, v159, v342);
    sub_10003D32C(a2, 1LL, "service stubs = {", v160, v161, v162, v163, v164);
    v347[0] = _NSConcreteStackBlock;
    v347[1] = 0x40000000LL;
    v347[2] = sub_10002C870;
    v347[3] = &unk_100064900;
    v347[4] = a2;
    v347[5] = 0LL;
    os_map_str_foreach(v3 + 488, v347);
    sub_10003D32C(a2, 1LL, "}", v165, v166, v167, v168, v169);
  }

  sub_10003D3A8(a2, v153, v154, v155, v156, v157, v158, v159, v342);
  sub_10003D32C(a2, 1LL, "unmanaged processes = {", v170, v171, v172, v173, v174);
  for (juint64_t j = 0LL; jj != 7; ++jj)
  {
    for (kuint64_t k = *(void *)(v3 + 8 * jj + 616); kk; kuint64_t k = *(void *)(kk + 88))
    {
      sub_10003D32C(a2, 2LL, "%s = {", v175, v176, v177, v178, v179, kk + 1360);
      __int16 v343 = *(_WORD *)(kk + 300);
      sub_10003D32C(a2, 3LL, "active size_t count = %d", v182, v183, v184, v185, v186);
      sub_10003D32C(a2, 3LL, "dynamic endpoints = {", v187, v188, v189, v190, v191);
      for (muint64_t m = *(void *)(kk + 160); mm; muint64_t m = *(void *)(mm + 16))
        sub_10003FE38(mm, a2, 4LL, v192, v193, v194, v195, v196);
      sub_10003D32C(a2, 3LL, "}", v192, v193, v194, v195, v196);
      sub_10003D32C(a2, 3LL, "pid-local endpoints = {", v198, v199, v200, v201, v202);
      for (nuint64_t n = *(void *)(kk + 168); nn; nuint64_t n = *(void *)(nn + 16))
        sub_10003FE38(nn, a2, 4LL, v203, v204, v205, v206, v207);
      sub_10003D32C(a2, 3LL, "}", v203, v204, v205, v206, v207);
      sub_10003D32C(a2, 2LL, "}", v209, v210, v211, v212, v213);
    }
  }

  sub_10003D32C(a2, 1LL, "}", v175, v176, v177, v178, v179);
  sub_10003D3A8(a2, v214, v215, v216, v217, v218, v219, v220, v343);
  sub_10003D32C(a2, 1LL, "endpoints = {", v221, v222, v223, v224, v225);
  for (uint64_t i1 = 0LL; i1 != 31; ++i1)
  {
    for (uint64_t i2 = *(void *)(v3 + 8 * i1 + 672); i2; uint64_t i2 = *(void *)(i2 + 32))
    {
      uint64_t v234 = *(void *)(i2 + 72);
      if (v234) {
        uint64_t v235 = *(void *)(i2 + 72);
      }
      else {
        uint64_t v235 = i2;
      }
      char v236 = *(_BYTE *)(v235 + 88);
      if (v234)
      {
        uint64_t v237 = 65LL;
      }

      else if (sub_10003FE08(i2))
      {
        uint64_t v237 = 77LL;
      }

      else
      {
        uint64_t v237 = 85LL;
      }

      uint64_t v238 = sub_10003F1E0(v235, 2, v226, v227, v228, v229, v230, v231);
      if ((v236 & 4) != 0) {
        uint64_t v244 = 65LL;
      }
      else {
        uint64_t v244 = 68LL;
      }
      sub_10003D32C(a2, 2LL, "%#8x %4c%4c   %s", v239, v240, v241, v242, v243, v238, v237, v244, v235 + 168);
    }

    uint64_t v3 = v346;
  }

  sub_10003D32C(a2, 1LL, "}", v227, v228, v229, v230, v231);
  sub_10003D3A8(a2, v245, v246, v247, v248, v249, v250, v251, v344);
  sub_10003D32C(a2, 1LL, "task-special ports = {", v252, v253, v254, v255, v256);
  for (i3 = *(uint64_t ***)(v346 + 80); i3; i3 = (uint64_t **)*i3)
  {
    uint64_t v263 = *((unsigned int *)i3 + 5);
    uint64_t v264 = "exception";
    if ((_DWORD)v263 != 128) {
      uint64_t v264 = (const char *)mach_task_special_port_description(v263);
    }
    uint64_t v265 = *((unsigned int *)i3 + 4);
    uint64_t v266 = sub_10002C9A0(v346, v265);
    if (v266)
    {
      uint64_t v272 = (const char *)(v266 + 976);
    }

    else
    {
      uint64_t v273 = sub_10002A694(v346, v265, 0LL, v267, v268, v269, v270, v271);
      uint64_t v272 = (const char *)(v273 + 21);
      if (!v273) {
        uint64_t v272 = "(unknown)";
      }
    }

    sub_10003D32C( a2,  3LL,  "%#8x %-4u %12s  %s",  v267,  v268,  v269,  v270,  v271,  *((unsigned int *)i3 + 4),  *((unsigned int *)i3 + 5),  v264,  v272);
  }

  sub_10003D32C(a2, 1LL, "}", v257, v258, v259, v260, v261);
  uint64_t v274 = sub_10002A9A4(v346);
  if (os_map_str_count(v274))
  {
    sub_10003D32C(a2, 1LL, "attractive services = {", v275, v276, v277, v278, v279);
    *(void *)&__int128 v350 = _NSConcreteStackBlock;
    *((void *)&v350 + 1) = 0x40000000LL;
    *(void *)&__int128 v351 = sub_10002CA0C;
    *((void *)&v351 + 1) = &unk_100064920;
    __int128 v352 = (unint64_t)a2;
    os_map_str_foreach(v274, &v350);
    sub_10003D32C(a2, 1LL, "}", v280, v281, v282, v283, v284);
  }

  sub_10002C8AC(v346, a2, 1LL, v275, v276, v277, v278, v279);
  uint64_t v285 = (void **)sub_10000D8E8(0x80uLL);
  sub_100024B74((uint64_t)v285, (char)"shutting down", *(_WORD *)(v346 + 968) & 1, v286, v287, v288, v289, v290);
  sub_100024B74( (uint64_t)v285,  (char)"slain",  (*(unsigned __int16 *)(v346 + 968) >> 1) & 1,  v291,  v292,  v293,  v294,  v295);
  sub_100024B74( (uint64_t)v285,  (char)"uncorked",  (*(unsigned __int16 *)(v346 + 968) >> 2) & 1,  v296,  v297,  v298,  v299,  v300);
  sub_100024B74( (uint64_t)v285,  (char)"deactivated",  (*(unsigned __int16 *)(v346 + 968) >> 4) & 1,  v301,  v302,  v303,  v304,  v305);
  sub_100024B74( (uint64_t)v285,  (char)"inactive",  (*(unsigned __int16 *)(v346 + 968) >> 5) & 1,  v306,  v307,  v308,  v309,  v310);
  sub_100024B74( (uint64_t)v285,  (char)"in initial on-demand",  (*(unsigned __int16 *)(v346 + 968) >> 6) & 1,  v311,  v312,  v313,  v314,  v315);
  sub_100024B74( (uint64_t)v285,  (char)"exec hack",  (*(unsigned __int16 *)(v346 + 968) >> 7) & 1,  v316,  v317,  v318,  v319,  v320);
  sub_10003D3A8(a2, v321, v322, v323, v324, v325, v326, v327, v345);
  sub_10003D32C(a2, 1LL, "properties = %s", v328, v329, v330, v331, v332, *v285);
  sub_10000D938(v285);
  return sub_10003D32C(a2, 0LL, "}", v333, v334, v335, v336, v337);
}

uint64_t sub_100028538(uint64_t a1, uint64_t a2)
{
  int v4 = (char *)sub_10000D814(a2);
  uint64_t v5 = sub_10000D80C(a2);
  uint64_t v6 = (dispatch_data_s *)sub_10000D7DC(a2);
  uint64_t v41 = a1;
  xpc_object_t v42 = 0LL;
  uint64_t v35 = sub_100026D10;
  uint64_t v36 = sub_1000270F8;
  uint64_t v37 = sub_10002723C;
  uint64_t v38 = sub_1000273D4;
  uint64_t v39 = sub_10002742C;
  uint64_t v40 = sub_100027520;
  if (v6)
  {
    uint64_t v7 = sub_100028978(v6, &v42);
    unsigned int v43 = v7;
    xpc_object_t v8 = v42;
    if ((_DWORD)v7)
    {
      uint64_t v31 = (const char *)v7;
      uint64_t v32 = xpc_strerror(v7);
      uint64_t v30 = v4;
      uint64_t v9 = "Could not parse plist: path = %s, error = %d: %s";
LABEL_4:
      sub_100028A04(a1, v8, 3, v9, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42);
      goto LABEL_22;
    }
  }

  else
  {
    xpc_object_t v8 = sub_10000D7FC(a2);
    xpc_object_t v42 = v8;
  }

  uint64_t v10 = (*(void *)(a2 + 48) >> 13) & 1LL;
  else {
    uint64_t v11 = 0LL;
  }
  if (*(void **)(a1 + 104) != qword_100069750) {
    v10 |= 0x80uLL;
  }
  unsigned int v12 = sub_100028AF4(a1, 3LL, v10, a2 + 16, (uint64_t)v4, v5);
  if (!v12)
  {
    if (sub_100012944(v4, "/System/Library/LaunchDaemons/com.apple.jetsamproperties")
      || sub_100012944(v4, "/AppleInternal/Library/LaunchDaemons/com.apple.jetsamproperties"))
    {
      unsigned int v43 = 0;
      goto LABEL_22;
    }

    uint64_t v16 = (*(void *)(a2 + 48) >> 10) & 0x22LL;
    int v17 = sub_10000D7F0(a2);
    uint64_t v18 = 0x20000LL;
    if (!v17) {
      uint64_t v18 = 0LL;
    }
    unint64_t v19 = (v16 | v11 | v18) & 0xFFFFFFFFFFFFFDFFLL | ((((unint64_t)*(unsigned int *)(a2 + 48) >> 8) & 1) << 9);
    if (sub_100012944(v4, "/System/Library/LaunchAngels/")
      || sub_100012944(v4, "/AppleInternal/Library/LaunchAngels/")
      || (*(_BYTE *)(a2 + 50) & 4) != 0)
    {
      v19 |= 0x400uLL;
    }

    uint64_t v20 = *(void *)(a1 + 104);
    if ((_UNKNOWN *)v20 == &unk_1000695B8) {
      uint64_t v21 = v19 | 0x800;
    }
    else {
      uint64_t v21 = v19;
    }
    unint64_t v22 = v21 | ((unint64_t)(*(_BYTE *)(v20 + 128) & 2) << 11);
    BOOL v23 = sub_100012944(v4, "/Library/LaunchAgents/");
    uint64_t v24 = v22 | 0x12000;
    if (!v23) {
      uint64_t v24 = v22;
    }
    uint64_t v25 = v24 | (*(void *)(a2 + 48) >> 3) & 0x10000LL;
    if (sub_100012944(v4, "/System/Library/DeveloperModeLaunchDaemons/")) {
      unint64_t v26 = v25 | 0x4000;
    }
    else {
      unint64_t v26 = v25;
    }
    unsigned int v43 = 0;
    uint64_t v27 = sub_100003668((_DWORD *)a1, v8, v4, a2 + 16, (uint64_t)&v35, v26, (int *)&v43);
    if (v27)
    {
      sub_1000265C0((_DWORD *)a1, v27);
      goto LABEL_22;
    }

    if ((int)v43 > 118)
    {
      if (v43 == 119 || v43 == 134) {
        goto LABEL_22;
      }
    }

    else
    {
      if (v43 == 17)
      {
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        __int128 v44 = 0u;
        __int128 v45 = 0u;
        uint64_t v31 = sub_100039990(a2 + 16, (char *)&v44);
        uint64_t v32 = *(unsigned int *)(a2 + 36);
        uint64_t v30 = v4;
        uint64_t v9 = "Caller tried to import service with same label as an existing service: path = %s, caller = %s[%d]";
        goto LABEL_4;
      }

      if (v43 == 37) {
        goto LABEL_22;
      }
    }

    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    uint64_t v28 = sub_100039990(a2 + 16, (char *)&v44);
    uint64_t v29 = *(unsigned int *)(a2 + 36);
    if (v43 == 152)
    {
      xpc_strerror(152LL);
      sub_100028A04(a1, v8, 5, "Did not import service from caller: path = %s, caller = %s[%d], int error = %d: %s", v4);
      goto LABEL_22;
    }

    uint64_t v33 = v43;
    uint64_t v34 = xpc_strerror(v43);
    uint64_t v31 = v28;
    uint64_t v32 = v29;
    uint64_t v30 = v4;
    uint64_t v9 = "Could not import service from caller: path = %s, caller = %s[%d], error = %d: %s";
    goto LABEL_4;
  }

  unsigned int v13 = v12;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  uint64_t v14 = sub_100039990(a2 + 16, (char *)&v44);
  if (v13 == 122)
  {
    sub_100028A04( a1,  v8,  3,  "Caller specified a plist with bad ownership/permissions: path = %s, caller = %s[%d]",  v4,  v14,  *(_DWORD *)(a2 + 36));
  }

  else if (v13 == 1)
  {
    sub_100028BC8( a1,  a2 + 16,  1LL,  "service bootstrap (%s, io flags=%#llx, eval flags=%#llx)",  v4,  *(void *)(a2 + 48),  v10);
  }

  unsigned int v43 = v13;
LABEL_22:
  if (v8) {
    xpc_release(v8);
  }
  return v43;
}

uint64_t sub_100028978(dispatch_data_s *a1, void *a2)
{
  size_t v9 = 0LL;
  buffer_ptr = 0LL;
  dispatch_data_t v3 = dispatch_data_create_map(a1, (const void **)&buffer_ptr, &v9);
  if (!v3) {
    return 12LL;
  }
  int v4 = v3;
  uint64_t v5 = (void *)xpc_create_from_plist(buffer_ptr, v9);
  if (v5 && (uint64_t v6 = v5, xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary))
  {
    uint64_t v7 = 0LL;
    *a2 = v6;
  }

  else
  {
    uint64_t v7 = 109LL;
  }

  dispatch_release(v4);
  return v7;
}

void sub_100028A04(uint64_t a1, xpc_object_t xdict, int a3, char *a4, ...)
{
  if (xdict && (char string = xpc_dictionary_get_string(xdict, "Label")) != 0LL)
  {
    size_t v9 = string;
    uint64_t v10 = sub_1000258E0(a1, 1);
    uint64_t v11 = sub_100012884("%s/%s", v10, v9);
    free(v10);
  }

  else
  {
    uint64_t v11 = sub_1000258E0(a1, 1);
  }

  sub_10003AE8C(v11, a3, a4, va, v4);
  free(v11);
}

const char *sub_100028ACC(void *a1, const char *a2)
{
  uint64_t result = xpc_dictionary_get_string(a1, a2);
  if (result) {
    return (const char *)sub_100012944(result, "com.apple.");
  }
  return result;
}

uint64_t sub_100028AF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = a1;
  do
  {
    uint64_t v13 = v12;
    uint64_t v12 = *(void *)(v12 + 200);
  }

  while (v12);
  if ((a2 - 1) <= 1 && (*(_WORD *)(v13 + 968) & 1) != 0
    || (a2 - 3) <= 1 && (*(_WORD *)(a1 + 968) & 3) != 0)
  {
    return 124LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 104)
                                                                                                 + 104LL))( a1,  a2,  a3,  *(void *)(a1 + 112),  a4,  a5,  a6);
}

void sub_100028BC8(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, ...)
{
  if ((_DWORD)a3 != 124)
  {
    if ((_DWORD)a3 == 154) {
      int v7 = 65539;
    }
    else {
      int v7 = 3;
    }
    v14[0] = 0LL;
    va_copy((va_list)&v14[1], va);
    vasprintf(v14, a4, va);
    memset(v15, 0, sizeof(v15));
    char v8 = sub_100039990(a2, (char *)v15);
    xpc_strerror(a3);
    sub_10002587C( a1,  v7,  "Caller not allowed to perform action: %s.%d, actiouint64_t n = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u",  v9,  v10,  v11,  v12,  v13,  v8);
    free(v14[0]);
  }

uint64_t sub_100028CD4(uint64_t a1, uint64_t a2, dispatch_group_s *a3)
{
  uint64_t v6 = (const char *)sub_10000D814(a2);
  uint64_t v7 = sub_10000D80C(a2);
  uint64_t v8 = sub_10000D7DC(a2);
  xpc_object_t object = 0LL;
  if ((*(_WORD *)(a1 + 968) & 3) != 0) {
    return 124LL;
  }
  uint64_t v10 = (dispatch_data_s *)v8;
  uint64_t v11 = sub_100028AF4(a1, 4LL, 128LL, a2 + 16, (uint64_t)v6, v7);
  if ((_DWORD)v11)
  {
    uint64_t v9 = v11;
    sub_100028BC8(a1, a2 + 16, v11, "service bootout (%s)", v6);
    return v9;
  }

  if (v10)
  {
    uint64_t v12 = sub_100028978(v10, &object);
    if ((_DWORD)v12)
    {
      uint64_t v9 = v12;
      xpc_strerror(v12);
      sub_10002587C(a1, 3, "Could not parse plist: path = %s, int error = %d: %s:", v13, v14, v15, v16, v17, (char)v6);
      xpc_object_t v18 = object;
      goto LABEL_12;
    }

    xpc_object_t v18 = object;
  }

  else
  {
    xpc_object_t v18 = sub_10000D7FC(a2);
  }

  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary
    || (char string = (char *)xpc_dictionary_get_string(v18, "Label")) == 0LL)
  {
    uint64_t v9 = 109LL;
    goto LABEL_12;
  }

  uint64_t v21 = string;
  unint64_t v22 = sub_100028EF4((_DWORD *)a1, string);
  if (!v22)
  {
    uint64_t v9 = 113LL;
    goto LABEL_12;
  }

  uint64_t v23 = (uint64_t)v22;
  uint64_t v24 = sub_10001C0CC();
  if ((_DWORD)v24)
  {
    uint64_t v9 = v24;
    sub_100028BC8(a1, a2 + 16, v24, "service bootout (%s)", v21);
    goto LABEL_12;
  }

  sub_10002908C(v23, a2 + 16, (char)"booting out service");
  uint64_t v9 = sub_1000266FC(a1, v23);
  if ((_DWORD)v9 != 36)
  {
LABEL_25:
    if ((*(_BYTE *)(a2 + 49) & 8) != 0)
    {
      sub_10002A9E4(a1, v21, 1);
      sub_1000417C0();
    }

    goto LABEL_12;
  }

  if (!*(void *)(v23 + 280))
  {
    if (a3)
    {
      *(void *)(v23 + 280) = a3;
      dispatch_group_enter(a3);
    }

    goto LABEL_25;
  }

  uint64_t v9 = 37LL;
LABEL_12:
  if (v18) {
    xpc_release(v18);
  }
  return v9;
}

char *sub_100028EF4(_DWORD *a1, char *a2)
{
  for (uint64_t i = *(char **)&a1[2 * (sub_100012B50(a2) % 0x17uLL) + 76]; i; uint64_t i = (char *)*((void *)i + 15))
  {
    if (!strcmp(i + 1360, a2)) {
      break;
    }
  }

  uint64_t v5 = os_map_str_delete(a1 + 122, a2);
  if (v5)
  {
    uint64_t v6 = v5;
    v18[0] = sub_100026D10;
    v18[1] = sub_1000270F8;
    _OWORD v18[2] = sub_10002723C;
    _OWORD v18[3] = sub_1000273D4;
    v18[4] = sub_10002742C;
    v18[5] = sub_100027520;
    v18[6] = a1;
    uint64_t v7 = sub_10003DD9C(v5);
    uint64_t v8 = (void *)xpc_bundle_create(v7, 1LL);
    uint64_t v9 = sub_10003DDA8(v6);
    xpc_bundle_populate(v8, v9, 0LL);
    int v17 = 0;
    uint64_t i = sub_100004B74((uint64_t)a1, (uint64_t)v8, (_OWORD *)(v6 + 16), 0LL, (uint64_t)v18, *(void *)(v6 + 48), &v17);
    char v10 = sub_10003DD90(v6);
    if (i)
    {
      sub_10002587C((uint64_t)a1, 5, "Service stub initialized for %s", v11, v12, v13, v14, v15, v10);
      sub_1000265C0(a1, (uint64_t)i);
    }

    else
    {
      sub_10002587C((uint64_t)a1, 5, "Service stub initialization failed for %s [%d]", v11, v12, v13, v14, v15, v10);
    }

    xpc_release(v8);
    sub_10001685C((void *)v6);
  }

  return i;
}

void sub_10002908C(uint64_t a1, uint64_t a2, char a3)
{
  sub_10001A4D8(a1, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v6, v7, v8, v9, v10, a3);
}

void sub_100029130(uint64_t a1, char *a2, int a3)
{
}

uint64_t sub_100029144(size_t a1, uint64_t a2)
{
  unsigned int v3 = 0;
  sub_10002917C(a1, a2, 0LL, &v3);
  if ((v3 & 0xFFFFFFFD) == 0x79) {
    return 0LL;
  }
  else {
    return v3;
  }
}

char *sub_10002917C(size_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v8 = sub_10000D81C(a2);
  uint64_t v9 = sub_10000D80C(a2);
  int property = (const char *)xpc_bundle_get_property(v8, 2LL);
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary(v8);
  if ((*(_WORD *)(a1 + 968) & 3) != 0)
  {
    uint64_t v12 = 0LL;
    LODWORD(v85) = 124;
    goto LABEL_31;
  }

  uint64_t v13 = info_dictionary;
  uint64_t v14 = (*(void *)(a2 + 48) >> 13) & 1LL;
  if ((sub_100028ACC(info_dictionary, "CFBundleIdentifier") & 1) != 0
    || sub_10000D7E4(a2))
  {
    uint64_t v15 = 128LL;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  if (*(void **)(a1 + 104) == qword_100069750) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v14 | 0x80;
  }
  uint64_t v82 = v16;
  uint64_t v83 = a4;
  if ((*(_BYTE *)(a2 + 49) & 0x40) != 0 && sub_100012984(property, ".appex")) {
    v15 |= 0x40uLL;
  }
  uint64_t v85 = 0LL;
  uint64_t v17 = sub_10002CC20(a1, v8, &v85);
  if ((_DWORD)v17)
  {
    uint64_t v18 = v17;
    char v19 = xpc_bundle_get_property(v8, 2LL);
    xpc_strerror(v18);
    sub_10002587C( a1,  3,  "Could not get domain target from bundle: path = %s, int error = %d: %s",  v20,  v21,  v22,  v23,  v24,  v19);
LABEL_15:
    uint64_t v12 = 0LL;
    int v25 = 112;
LABEL_16:
    LODWORD(v85) = v25;
LABEL_30:
    a4 = v83;
    goto LABEL_31;
  }

  uint64_t v26 = v85;
  uint64_t v81 = a1;
  uint64_t v79 = a3;
  uint64_t v80 = (_OWORD *)(a2 + 16);
  if ((void *)v85 != qword_100069750)
  {
    uint64_t v27 = (*(uint64_t (**)(void))(v85 + 88))();
    uint64_t v81 = sub_10002A7D4((void *)v26, v27);
    if (!v81)
    {
      if ((*(_WORD *)(qword_10006A400 + 968) & 1) != 0)
      {
        uint64_t v61 = 124LL;
        uint64_t v63 = a2 + 16;
      }

      else
      {
        uint64_t v61 = (*(uint64_t (**)(void, uint64_t, void, uint64_t, _OWORD *, void, void))(v26 + 104))( 0LL,  1LL,  0LL,  v27,  v80,  0LL,  0LL);
        uint64_t v63 = a2 + 16;
        if (!(_DWORD)v61)
        {
          uint64_t v81 = (uint64_t)sub_10002997C(v26, v27, 0LL, v62, 0, qword_10006A400, (uint64_t)v80);
          if (*(_UNKNOWN **)(v81 + 104) == &unk_1000695B8 && qword_10006A970) {
            sub_100014618(v81, 1LL, 0LL, qword_10006A970, v80, 0x2000LL);
          }
          goto LABEL_19;
        }
      }

      memset(v86, 0, sizeof(v86));
      uint64_t v64 = v61;
      char v65 = sub_100039990(v63, (char *)v86);
      xpc_bundle_get_property(v8, 2LL);
      xpc_strerror(v64);
      sub_10002587C( a1,  3,  "Caller is denied target domain creation for bundle: caller = %s[%d], path = %s, int error = %d: %s",  v66,  v67,  v68,  v69,  v70,  v65);
      goto LABEL_15;
    }
  }

uint64_t sub_1000297FC(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = sub_10003DF34();
  if (*((_DWORD *)v3 + 5) || *((_DWORD *)v3 + 3) || *((_DWORD *)v3 + 7))
  {
    sub_10003AB08(65539, "Dropping coalition notification from unknown source (%llu)", a2);
    return 5LL;
  }

  else
  {
    sub_100019BA8(a2);
    sub_100011414();
    return 0LL;
  }

BOOL sub_10002986C(uint64_t a1, uint64_t a2)
{
  BOOL result = 1;
  if (*(_UNKNOWN **)(a1 + 104) == &unk_100069750)
  {
    unint64_t v3 = *(void *)(a1 + 112);
    if (!(v3 >> 31))
    {
      uint64_t v4 = *(unsigned int *)(a2 + 20);
      if ((v4 & 0x80000000) == 0 && v3 == v4) {
        return 0;
      }
    }
  }

  return result;
}

uint64_t sub_1000298AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  qword_10006A400 = (uint64_t)sub_10002997C((uint64_t)&unk_1000695B8, 0LL, 0LL, a4, 0, 0LL, (uint64_t)&qword_10006A8E0);
  *(_WORD *)(qword_10006A400 + 968) |= 0x800u;
  byte_10006A408 = os_variant_is_darwinos("com.apple.xpc.launchd");
  sub_10003DF50(3, (uint64_t)sub_100029DE0);
  sub_10003DF50(5, (uint64_t)sub_10002A114);
  sub_10003DF50(7, (uint64_t)sub_10002A27C);
  sub_10003E0D4((uint64_t)sub_100043670, 0x830uLL);
  sub_10003E0D4((uint64_t)sub_1000438CC, 0x2CuLL);
  mach_port_t v4 = mach_host_self();
  uint64_t result = host_set_special_port(v4, 22, dword_10006A940);
  if ((_DWORD)result) {
    return sub_100047794();
  }
  return result;
}

char *sub_10002997C(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  if ((void *)a1 == qword_100069750 && a2 == 0) {
    sub_100039448("Can't create PID domain for PID 0");
  }
  size_t v14 = strlen(*(const char **)(a1 + 120));
  size_t v15 = v14;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v57 = 0u;
  *(void *)uint64_t v54 = 0LL;
  v55[0] = 0LL;
  *(void *)((char *)v55 + 5) = 0LL;
  if (a3)
  {
    snprintf(__str, 0x80uLL, ".%s", a3);
    size_t v16 = v15 + strlen(a3) + 22;
LABEL_8:
    snprintf(v54, 0x15uLL, ".%lu", a2);
    goto LABEL_9;
  }

  size_t v16 = v14 + 21;
  if ((_UNKNOWN *)a1 != &unk_1000695B8) {
    goto LABEL_8;
  }
LABEL_9:
  uint64_t v17 = (char *)sub_100016CF4(v16);
  *((void *)v17 + 13) = a1;
  *((void *)v17 + 14) = a2;
  uint64_t v18 = (uint64_t *)(v17 + 112);
  *((void *)v17 + 25) = a6;
  snprintf(v17 + 976, v16, "%s%s%s", *(const char **)(a1 + 120), __str, v54);
  __int128 v19 = *(_OWORD *)a7;
  *(_OWORD *)(v17 + 264) = *(_OWORD *)(a7 + 16);
  *(_OWORD *)(v17 + 248) = v19;
  if (*(void *)(*((void *)v17 + 13) + 88LL) && sub_10002A7D4(*((void **)v17 + 13), *v18)) {
    sub_100039448( "refusing to add a duplicate domain: type=%s handle=%lu",  *(const char **)(*((void *)v17 + 13) + 112LL),  *((void *)v17 + 14));
  }
  uint64_t v20 = (uint64_t *)(*((void *)v17 + 13) + 8 * (sub_100012B1C(v18, 8LL) % 0xBuLL));
  uint64_t v21 = *v20;
  *((void *)v17 + 4) = *v20;
  if (v21) {
    *(void *)(v21 + 40) = v17 + 32;
  }
  *uint64_t v20 = (uint64_t)v17;
  *((void *)v17 + 5) = v20;
  os_map_str_init(v17 + 488, 0LL, 1LL);
  if (a5) {
    *((_DWORD *)v17 + 38) = a5;
  }
  memset(v53, 0, sizeof(v53));
  uint64_t v22 = sub_100039990(a7, (char *)v53);
  *((void *)v17 + 35) = sub_1000126A0(v22);
  if ((void *)a1 == qword_100069750)
  {
    int v23 = *(_DWORD *)(a7 + 4);
    if (v23 || *(_UNKNOWN **)(a6 + 104) != &unk_1000695B8)
    {
      *((_DWORD *)v17 + 14) = v23;
      v17[96] |= 1u;
    }
  }

  sub_100025B08((uint64_t)v17);
  if (*((_UNKNOWN **)v17 + 13) == &unk_1000695B8)
  {
    sub_10002A790((uint64_t)v17, v24, v25, v26, v27, v28, v29, v30, v38);
    *((_WORD *)v17 + 484) |= 0x40u;
  }

  if ((_UNKNOWN *)a1 == &unk_1000695B8)
  {
    if (a6) {
      sub_100046EB4();
    }
  }

  else
  {
    if ((void *)a1 == qword_100069750)
    {
      sub_10002A790((uint64_t)v17, v24, v25, v26, v27, v28, v29, v30, v38);
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      *(_OWORD *)tuint64_t n = 0u;
      __int128 v42 = 0u;
      int v31 = sub_100039954(a2, tn);
      if (v31 != 3)
      {
        if (v31) {
          _os_assumes_log_ctx(sub_100025848, v17);
        }
        else {
          *((void *)v17 + 15) = *((void *)&v50 + 1);
        }
      }

      uint64_t v40 = 0LL;
      memset(buffer, 0, sizeof(buffer));
      int v32 = sub_100039A7C(a2, buffer);
      if (v32 != 3)
      {
        if (v32) {
          _os_assumes_log_ctx(sub_100025848, v17);
        }
        else {
          *(_OWORD *)(v17 + 952) = buffer[0];
        }
      }
    }

    uint64_t v33 = *(void *)(a6 + 288);
    *((void *)v17 + 2) = v33;
    if (v33) {
      *(void *)(v33 + 24) = v17 + 16;
    }
    *(void *)(a6 + 288) = v17;
    *((void *)v17 + 3) = a6 + 288;
    sub_1000167B0(v17);
    sub_100025B08(a6);
    sub_10001685C(v17);
  }

  tn[0] = -1;
  uint64_t v34 = (void *)*((void *)v17 + 13);
  if (v34 == (void *)&unk_1000695B8)
  {
    uint64_t v35 = sub_10000AB70(0x33u, 6u, (mach_port_context_t)v17);
LABEL_38:
    sub_100033FEC((uint64_t)v17, v35, v25, v26, v27, v28, v29, v30, v38);
    goto LABEL_39;
  }

  if (v34 == qword_100069750)
  {
    uint64_t v35 = *((unsigned int *)v17 + 38);
    if (!(_DWORD)v35)
    {
      task_name_for_pid(mach_task_self_, *(_DWORD *)v18, tn);
      uint64_t v35 = tn[0];
    }

    goto LABEL_38;
  }

uint64_t sub_100029DE0(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  unsigned int v11 = 0;
  uint64_t v7 = sub_10002A864(a3, a2 != 817, (int *)&v11);
  if (!v7) {
    return v11;
  }
  uint64_t v8 = v7;
  uint64_t v9 = sub_10003DF34();
  uint64_t result = 45LL;
  switch(a2)
  {
    case 800:
      uint64_t result = sub_10002CD60(v8, (uint64_t)v9, a3, a4);
      break;
    case 801:
      uint64_t result = sub_10002CF54((void *)v8, (uint64_t)v9, a3, a4);
      break;
    case 802:
      uint64_t result = sub_10002D2B8(v8, (uint64_t)v9, a3, a4);
      break;
    case 803:
      uint64_t result = sub_10002D4B4(v8, (uint64_t)v9, a3, a4);
      break;
    case 804:
      uint64_t result = sub_10002D560(v8, (uint64_t)v9, a3, a4);
      break;
    case 805:
      uint64_t result = sub_10002D768(v8, (uint64_t)v9, a3, a4);
      break;
    case 806:
      uint64_t result = sub_10002DA78(v8, a3, a4);
      break;
    case 807:
      uint64_t result = sub_10002DADC(v8, a3, a4);
      break;
    case 808:
      uint64_t result = sub_10002DB50(v8, (uint64_t)v9, a3, a4);
      break;
    case 809:
      uint64_t result = sub_10002DCE0(v8, (uint64_t)v9, a3, a4);
      break;
    case 811:
      uint64_t result = sub_10002DE70(v8, (uint64_t)v9, a3, a4);
      break;
    case 812:
      uint64_t result = sub_10002E01C(v8, (uint64_t)v9, a3, a4);
      break;
    case 813:
      uint64_t result = sub_10002E24C((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 814:
      uint64_t result = sub_10002E378((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 815:
      uint64_t result = sub_10002E6A8((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 816:
      uint64_t result = sub_10002E534((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 817:
    case 818:
    case 823:
    case 824:
    case 827:
    case 835:
    case 836:
    case 838:
    case 841:
    case 842:
    case 843:
    case 845:
      return result;
    case 819:
      uint64_t result = sub_10002E88C(v8, (uint64_t)v9, a3, a4);
      break;
    case 820:
      uint64_t result = sub_10002E998(v8, (uint64_t)v9, a3, a4);
      break;
    case 821:
      uint64_t result = sub_10002EA90((void **)v8, (uint64_t)v9, a3, a4);
      break;
    case 822:
    case 826:
      uint64_t result = 142LL;
      break;
    case 825:
      uint64_t result = sub_10002EDC8(v8, (uint64_t)v9, a3, a4);
      break;
    case 828:
      uint64_t result = sub_10002EFEC(v8, (uint64_t)v9, a3, a4);
      break;
    case 829:
      if (*(_UNKNOWN **)(v8 + 104) == &unk_1000695B8) {
        uint64_t result = sub_100019988(a3, a4);
      }
      else {
        uint64_t result = 125LL;
      }
      break;
    case 830:
      uint64_t result = sub_100019AC4(a3, a4);
      break;
    case 831:
      uint64_t result = sub_10002F0B0((void **)v8, v9, a3);
      break;
    case 832:
      uint64_t result = sub_10002F1D8((void **)v8, (uint64_t)v9, a3);
      break;
    case 833:
      uint64_t result = sub_10002F428(v8, (uint64_t)v9, a3, a4);
      break;
    case 834:
      uint64_t result = sub_10002F644(v8, (uint64_t)v9, a3, a4);
      break;
    case 837:
      uint64_t result = sub_10002F73C(v8, (uint64_t)v9, a3, a4);
      break;
    case 839:
      uint64_t result = sub_10002F81C(v8, (uint64_t)v9, a3, a4);
      break;
    case 840:
      uint64_t result = sub_10002F994(v8, (uint64_t)v9, a3, a4);
      break;
    case 844:
      uint64_t result = sub_10002FA88((void *)v8, (uint64_t)v9, a3, a4);
      break;
    case 846:
      uint64_t result = sub_10002FB34(v8, (uint64_t)v9, a3, a4);
      break;
    case 847:
      uint64_t result = sub_10002FBDC(v8, (uint64_t)v9, a3);
      break;
    default:
      uint64_t result = 33LL;
      break;
  }

  return result;
}

uint64_t sub_10002A114(uint64_t a1, int a2, void *a3, void *a4)
{
  unsigned int v13 = 0;
  uint64_t v7 = sub_10002A864(a3, 1, (int *)&v13);
  if (!v7) {
    return v13;
  }
  uint64_t v8 = v7;
  if ((*(_WORD *)(v7 + 968) & 3) != 0) {
    return 124LL;
  }
  if (*(void **)(v7 + 104) == qword_100069750) {
    return 45LL;
  }
  if (*(_WORD *)(v7 + 172))
  {
    uint64_t v10 = *(void *)(v7 + 128);
    if (v10) {
      int right = xpc_mach_send_get_right(v10);
    }
    else {
      int right = 0;
    }
    sub_10002FF5C(v8, right, a3);
    return 0LL;
  }

  else
  {
    uint64_t v12 = sub_10003DF34();
    uint64_t result = 126LL;
    switch(a2)
    {
      case 200:
      case 201:
      case 202:
      case 205:
        return result;
      case 203:
        return sub_1000327A0(v8, a3, a4);
      case 204:
        return sub_100032820(v8, (uint64_t)v12, a3, a4);
      case 206:
        return sub_100032910(v8, (uint64_t)v12, a3, a4);
      case 207:
        return sub_100032A00(v8, (uint64_t)v12, a3, a4);
      case 208:
        return 45LL;
      case 209:
        if (xpc_dictionary_expects_reply(a3))
        {
          sub_10003DF40();
          return 45LL;
        }

        uint64_t result = 22LL;
        break;
      case 211:
        return sub_100032BF0(a3, a4);
      default:
        return 33LL;
    }
  }

  return result;
}

uint64_t sub_10002A27C(uint64_t a1, int a2, void *a3, void *a4)
{
  unsigned int v34 = 0;
  uint64_t v7 = sub_10002A864(a3, 1, (int *)&v34);
  if (!v7) {
    return v34;
  }
  uint64_t v13 = v7;
  if ((*(_WORD *)(v7 + 968) & 3) != 0) {
    return 124LL;
  }
  uint64_t v15 = *(void *)(v7 + 104);
  if ((_UNKNOWN *)v15 != &unk_1000695B8 && (*(_BYTE *)(v15 + 128) & 2) == 0)
  {
    sub_10002587C( v7,  3,  "The launch_msg(3) API may only be used on the system or user domains.",  v8,  v9,  v10,  v11,  v12,  v33);
    return 125LL;
  }

  if (xpc_dictionary_get_BOOL(a3, "justdoit")) {
    *(_WORD *)(v13 + 968) |= 0x100u;
  }
  size_t v16 = sub_10003DF34();
  uint64_t v17 = (uint64_t)v16;
  if (a2 == 101)
  {
    v35[0] = v13;
    size_t v20 = sub_1000308F8(v35, *((_DWORD *)v16 + 5), 0);
    if (!v20)
    {
      uint64_t result = 113LL;
      goto LABEL_37;
    }

    uint64_t v21 = v20;
    uint64_t result = (uint64_t)sub_10001DD94(v20);
    if (result)
    {
      xpc_object_t v22 = (xpc_object_t)result;
      sub_100033D30(v13, v21, (void *)result, 0);
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v24 = reply;
LABEL_19:
      xpc_dictionary_set_value(reply, "response", v22);
      xpc_release(v22);
      uint64_t result = 0LL;
      *a4 = v24;
    }
  }

  else
  {
    if (a2 != 100)
    {
      uint64_t result = 33LL;
      goto LABEL_37;
    }

    xpc_object_t value = xpc_dictionary_get_value(a3, "request");
    if (!value) {
      goto LABEL_15;
    }
    __int128 v19 = value;
    xpc_object_t v37 = 0LL;
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string)
    {
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v35[0] = v13;
        v35[1] = v17;
        xpc_object_t object = 0LL;
        xpc_dictionary_apply_f(v19);
        uint64_t v26 = *(void *)(v13 + 944);
        if (v26)
        {
          if (object)
          {
            xpc_release(object);
            uint64_t v26 = *(void *)(v13 + 944);
          }

          *(void *)(v13 + 944) = 0LL;
          xpc_object_t v27 = xpc_dictionary_create_reply(a3);
          xpc_dictionary_set_uint64(v27, "response", 0LL);
          uint64_t v28 = *(void *)(v26 + 272);
          if (v28) {
            sub_100047110(v28);
          }
          *(void *)(v26 + 272) = v27;
        }

        else
        {
          xpc_object_t v31 = xpc_dictionary_create_reply(a3);
          xpc_object_t v32 = object;
          if (!object)
          {
            xpc_object_t v32 = xpc_uint64_create(0LL);
            xpc_object_t object = v32;
          }

          xpc_dictionary_set_value(v31, "response", v32);
          xpc_release(object);
          *a4 = v31;
        }

        uint64_t result = 0LL;
        goto LABEL_37;
      }

LABEL_37:
  *(_WORD *)(v13 + 968) &= ~0x100u;
  return result;
}

void sub_10002A568()
{
  if (qword_10006A970)
  {
    uint64_t v0 = qword_10006A400;
    *(_WORD *)(qword_10006A400 + 968) |= 4u;
    *(void *)(v0 + 920) = sub_10004176C();
    if (*(_UNKNOWN **)(v0 + 104) == &unk_1000695B8 && qword_10006A970 != 0) {
      sub_100014618((void *)v0, 1, 0LL, (void *)qword_10006A970, (uint64_t)&qword_10006A8E0, 0x2000LL, v1, v2);
    }
    mach_port_t v4 = (dispatch_queue_s *)sub_100011938();
    qword_10006A410 = (uint64_t)dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_signal,  0xFuLL,  0LL,  v4);
    dispatch_set_context((dispatch_object_t)qword_10006A410, (void *)v0);
    dispatch_source_set_event_handler_f((dispatch_source_t)qword_10006A410, (dispatch_function_t)sub_10002A650);
    dispatch_activate((dispatch_object_t)qword_10006A410);
  }

void sub_10002A650( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void *sub_10002A680( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10002A694(qword_10006A400, a1, a2, a4, a5, a6, a7, a8);
}

void *sub_10002A694( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0LL;
  while (1)
  {
    uint64_t v12 = *(void **)(a1 + 8 * v11 + 672);
    if (v12) {
      break;
    }
LABEL_8:
    if (++v11 == 31)
    {
      if ((_DWORD)a3)
      {
        uint64_t v14 = 0LL;
        while (1)
        {
          uint64_t v15 = *(void *)(a1 + 8 * v14 + 304);
          if (v15) {
            break;
          }
LABEL_19:
          if (++v14 == 23) {
            goto LABEL_20;
          }
        }

        while (1)
        {
          uint64_t v12 = *(void **)(v15 + 184);
          if (v12) {
            break;
          }
LABEL_18:
          uint64_t v15 = *(void *)(v15 + 120);
          if (!v15) {
            goto LABEL_19;
          }
        }

        while (1)
        {
          uint64_t v16 = v12[9] ? v12[9] : (uint64_t)v12;
          uint64_t v12 = (void *)v12[2];
          if (!v12) {
            goto LABEL_18;
          }
        }
      }

      else
      {
LABEL_20:
        uint64_t v17 = *(void *)(a1 + 288);
        if (v17)
        {
          do
          {
            uint64_t v12 = (void *)sub_10002A694(v17, a2, a3);
            if (v12) {
              break;
            }
            uint64_t v17 = *(void *)(v17 + 16);
          }

          while (v17);
        }

        else
        {
          return 0LL;
        }
      }

      return v12;
    }
  }

  while (1)
  {
    uint64_t v13 = v12[9] ? v12[9] : (uint64_t)v12;
    uint64_t v12 = (void *)v12[4];
    if (!v12) {
      goto LABEL_8;
    }
  }

void sub_10002A790( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = *(_DWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 160) = v9 + 1;
  if (!v9 && *(void **)(a1 + 104) != qword_100069750) {
    sub_10002587C(a1, 5, "entering ondemand mode", a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_10002A7C8()
{
  return qword_10006A400;
}

uint64_t sub_10002A7D4(void *a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (a1 == (void *)&unk_1000695B8) {
    return qword_10006A400;
  }
  for (uint64_t result = a1[sub_100012B1C(&v3, 8LL) % 0xBuLL]; result; uint64_t result = *(void *)(result + 32))
  {
    if (*(void *)(result + 112) == v3) {
      break;
    }
  }

  return result;
}

uint64_t sub_10002A864(void *a1, char a2, int *a3)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  int v6 = sub_100032008(a1, &v14, (uint64_t *)&v13);
  int v12 = v6;
  if (v6)
  {
    int v7 = v6;
    uint64_t result = 0LL;
LABEL_3:
    *a3 = v7;
    return result;
  }

  unint64_t v9 = v13;
  uint64_t v10 = v14;
  uint64_t result = sub_100032124(v14, v13, (uint64_t)v11);
  if (!result)
  {
    if ((a2 & 1) != 0)
    {
      uint64_t result = (uint64_t)sub_100032188((uint64_t)v10, v9, 0LL, 0, (uint64_t)v11, &v12);
      int v7 = v12;
    }

    else
    {
      sub_10003AB08(3, "Could not find domain from request: type=%s handle=%lu", (const char *)v10[14], v9);
      uint64_t result = 0LL;
      int v7 = 112;
    }

    goto LABEL_3;
  }

  return result;
}

BOOL sub_10002A938(uint64_t a1, void *a2)
{
  int v2 = *(unsigned __int16 *)(a1 + 172);
  if (*(_WORD *)(a1 + 172))
  {
    uint64_t v5 = *(void *)(a1 + 128);
    if (v5) {
      int right = xpc_mach_send_get_right(v5);
    }
    else {
      int right = 0;
    }
    sub_10002FF5C(a1, right, a2);
  }

  return v2 == 0;
}

uint64_t sub_10002A994(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

uint64_t sub_10002A99C(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t sub_10002A9A4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 928);
  if (!result)
  {
    uint64_t v3 = sub_100010B00(0x18uLL);
    *(void *)(a1 + 928) = v3;
    os_map_str_init(v3, 0LL, 1LL);
    return *(void *)(a1 + 928);
  }

  return result;
}

uint64_t sub_10002A9E4(uint64_t a1, char *__s, int a3)
{
  if (!*(void *)(a1 + 920)) {
    return 125LL;
  }
  if (strchr(__s, 60))
  {
    sub_10002587C( a1,  4,  "refusing to persist enabled/disabled state for '%s' as it contains illegal XML character '<'",  v6,  v7,  v8,  v9,  v10,  (char)__s);
    return 140LL;
  }

  else
  {
    int v12 = "Disabling";
    if (a3 == 2) {
      int v12 = "Enabling";
    }
    sub_10002587C(a1, 5, "%s service %s", v6, v7, v8, v9, v10, (char)v12);
    xpc_object_t value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 920), __s);
    if (!value
      || (uint64_t v14 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL)
      || (a3 == 1) != xpc_BOOL_get_value(v14))
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 920), __s, a3 == 1);
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 920), "_dirty", 1);
    }

    return 0LL;
  }

xpc_object_t sub_10002AB0C(uint64_t a1, const char *a2)
{
  xpc_object_t result = *(xpc_object_t *)(a1 + 920);
  if (result)
  {
    xpc_object_t result = xpc_dictionary_get_value(result, a2);
    if (result)
    {
      uint64_t v3 = result;
      if (xpc_get_type(result) != (xpc_type_t)&_xpc_type_dictionary
        || (xpc_object_t result = xpc_dictionary_get_value(v3, "Disabled"), (v3 = result) != 0LL))
      {
        if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_BOOL) {
          return v3;
        }
        else {
          return 0LL;
        }
      }
    }
  }

  return result;
}

__n128 sub_10002AB7C(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a1 + 248);
  __int128 v3 = *(_OWORD *)(a1 + 264);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_10002AB90(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 312))
  {
    uint64_t v4 = *(void *)(a2 + 312);
    return sub_10000E618(v4);
  }

  if (a3) {
    goto LABEL_6;
  }
  if (*(_UNKNOWN **)(a1 + 104) != &unk_100069750)
  {
    if (*(void *)(a2 + 304))
    {
      uint64_t v9 = 0LL;
      __int128 v7 = 0u;
      __int128 v8 = 0u;
      v6[0] = 0LL;
      v6[1] = a2 + 1360;
      *(void *)&__int128 v7 = sub_10001E49C(a2);
      DWORD2(v7) = *(_DWORD *)(a2 + 872);
      __int128 v8 = *(_OWORD *)(a2 + 968);
      uint64_t v4 = sub_100019D80(*(const void **)(a2 + 304), v6);
      goto LABEL_10;
    }

LABEL_6:
    uint64_t v4 = (uint64_t)sub_10002AC78(a2, 0);
LABEL_10:
    *(void *)(a2 + 312) = v4;
    return sub_10000E618(v4);
  }

  return *(void *)(a1 + 952);
}

_BYTE *sub_10002AC78(uint64_t a1, unsigned int a2)
{
  uint64_t v7 = 0LL;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  v4[0] = a2;
  v4[1] = a1 + 1360;
  *(void *)&__int128 v5 = sub_10001E49C(a1);
  DWORD2(v5) = *(_DWORD *)(a1 + 872);
  __int128 v6 = *(_OWORD *)(a1 + 968);
  LOBYTE(v7) = (*(void *)(a1 + 1352) & 0x4000000000000000LL) != 0;
  return sub_100019D24((uint64_t)v4);
}

uint64_t sub_10002ACE8(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 320))
  {
    return sub_10000E618(*(void *)(a2 + 320));
  }

  else if (*(_UNKNOWN **)(a1 + 104) == &unk_100069750)
  {
    return *(void *)(a1 + 960);
  }

  else
  {
    __int128 v5 = sub_10002AC78(a2, 1u);
    *(void *)(a2 + 320) = v5;
    uint64_t v3 = sub_10000E618((uint64_t)v5);
    __int128 v6 = sub_10001E3C0(a2);
    if (v6)
    {
      uint64_t v7 = v6;
      size_t v8 = strlen(v6);
      coalition_info_set_name(v3, v7, v8);
    }
  }

  return v3;
}

const char *sub_10002ADC0(uint64_t a1, char *a2)
{
  if (*(void **)(a1 + 104) != qword_100069750) {
    return 0LL;
  }
  __n128 result = (const char *)sub_10002AE24(*(void *)(a1 + 200), a2);
  if (result)
  {
    uint64_t v3 = sub_10003FDE0((uint64_t)result);
    __n128 result = (const char *)sub_10001E464(v3);
    if (result)
    {
      if (!strcmp(result, "com.apple.keyboard-service")) {
        return (const char *)v3;
      }
      else {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10002AE24(uint64_t a1, char *a2)
{
  for (uint64_t i = *(void *)(a1 + 8 * (sub_100012B50(a2) % 0x1FuLL) + 672); i; uint64_t i = *(void *)(i + 32))
  {
  }

  return i;
}

uint64_t sub_10002AEC4(uint64_t a1, uint64_t a2, const char *a3)
{
  for (uint64_t i = *(void *)(a2 + 176); i; uint64_t i = *(void *)(i + 16))
  {
  }

  return i;
}

uint64_t sub_10002AF0C(size_t a1, void *a2, const char *a3)
{
  uint64_t v6 = sub_10002AEC4(a1, (uint64_t)a2, a3);
  if (!v6)
  {
    sub_10003F318((unint64_t)a2, a3, (unint64_t)sub_10002762C, (unint64_t)a2);
    uint64_t v6 = v7;
    *(_BYTE *)(v7 + 88) |= 8u;
    sub_100027850(a1, a2, v7, 16);
  }

  return v6;
}

xpc_object_t sub_10002AF84(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  unint64_t v9 = *(void *)(a1 + 72) + a5;
  xpc_object_t result = xpc_array_create(0LL, 0LL);
  if (v9 >> 62)
  {
    __break(1u);
  }

  else
  {
    xpc_object_t v11 = result;
    xpc_object_t result = sub_100010B00(4 * v9);
    int v12 = result;
    uint64_t v13 = *(uint64_t **)(a1 + 80);
    if (v13)
    {
      uint64_t v14 = 0LL;
      do
      {
        xpc_object_t result = (xpc_object_t)xpc_array_set_mach_send(v11, -1LL, *((unsigned int *)v13 + 4));
        uint64_t v15 = v14 + 1;
        v12[v14] = *((_DWORD *)v13 + 5);
        uint64_t v13 = (uint64_t *)*v13;
        ++v14;
      }

      while (v13);
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    *a2 = v11;
    *a3 = v12;
    *a4 = v15;
  }

  return result;
}

uint64_t sub_10002B03C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100028AF4(a1, a2, a3, a4, 0LL, 0LL);
}

uint64_t sub_10002B048(_DWORD *a1, void *a2, char *a3, uint64_t a4, unint64_t a5, _DWORD *a6)
{
  int v9 = 0;
  v8[0] = sub_100026D10;
  v8[1] = sub_1000270F8;
  v8[2] = sub_10002723C;
  void v8[3] = sub_1000273D4;
  v8[4] = sub_10002742C;
  void v8[5] = sub_100027520;
  void v8[6] = a1;
  uint64_t result = sub_100003668(a1, a2, a3, a4, (uint64_t)v8, a5, &v9);
  if (v9)
  {
    if (result) {
      sub_100046EB4();
    }
  }

  else if (!result)
  {
    sub_100046EB4();
  }

  *a6 = v9;
  return result;
}

const char *sub_10002B0DC(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 968) & 3) == 0) {
    return 0LL;
  }
  if (sub_100011008(0)) {
    return "system shutdown";
  }
  if (sub_100011008(1)) {
    return "userspace reboot";
  }
  uint64_t v3 = *(void *)(a1 + 104);
  if ((_UNKNOWN *)v3 == &unk_100069750) {
    return "teardown of process-scoped services after host exited";
  }
  if ((*(_BYTE *)(v3 + 128) & 2) != 0) {
    return "logout";
  }
  return 0LL;
}

_DWORD *sub_10002B170(uint64_t a1)
{
  int v2 = sub_100010B00(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 128);
  if (v3) {
    LODWORD(v3) = xpc_mach_send_get_right(v3);
  }
  v2[4] = v3;
  return v2;
}

uint64_t sub_10002B1AC(uint64_t a1, const void *a2)
{
  if (qword_10006A9D8)
  {
    if (sub_10003CB2C((rb_tree_t **)qword_10006A9D8, a2) == (rb_tree_t **)&_xpc_BOOL_true) {
      uint64_t v3 = 4LL;
    }
    else {
      uint64_t v3 = 6LL;
    }
    bzero(v16, 0x800uLL);
    uint64_t v15 = 512LL;
    if (sub_1000343B8(v3, (uint64_t)v16, &v15))
    {
      xpc_strerror();
      sub_10002587C(a1, 3, "Unable to find persona with type %d: %d - %s", v9, v10, v11, v12, v13, v3);
    }

    else if (v15 == 1)
    {
      uint64_t result = v16[0];
      if (v16[0] != -1) {
        return result;
      }
    }

    else
    {
      sub_10002587C(a1, 3, "Unable to select default persona of type %d, found %zu", v4, v5, v6, v7, v8, v3);
    }
  }

  return 0xFFFFFFFFLL;
}

void sub_10002B2AC(void *a1)
{
  uint64_t v2 = a1[25];
  uint64_t v3 = sub_1000258E0((uint64_t)a1, 1);
  sub_10002587C(v2, 5, "removing child: %s", v4, v5, v6, v7, v8, (char)v3);
  free(v3);
  uint64_t v9 = a1[2];
  if (v9) {
    *(void *)(v9 + 24) = a1[3];
  }
  *(void *)a1[3] = v9;
  a1[2] = -1LL;
  a1[3] = -1LL;
  sub_10001685C(a1);
  sub_100025B64(v2);
  sub_10001685C(a1);
}

uint64_t sub_10002B35C(uint64_t a1)
{
  if ((sub_10000D114(a1, 3LL) & 1) != 0) {
    return 1LL;
  }
  else {
    return sub_10000D114(a1, 4LL);
  }
}

void sub_10002B39C(uint64_t a1)
{
}

uint64_t sub_10002B3D0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 288);
  if (!(_DWORD)v8) {
    sub_100046EB4();
  }
  *(_DWORD *)(a1 + 288) = 0;
  return sub_10001D3D8(a1, v8, a3, a4, a5, a6, a7, a8);
}

void sub_10002B3F0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 248) != a1) {
    sub_100047868(a2);
  }
  uint64_t v10 = *(unsigned int *)(a2 + 296);
  int v11 = (__int16)(*(_WORD *)(a2 + 300))--;
  if (v11 <= 0) {
    sub_10004782C(v10, a2);
  }
  if ((_DWORD)v10) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  if (v12 >= v11)
  {
    int v13 = *(_DWORD *)(a2 + 368);
    if ((v13 & 2) != 0)
    {
      *(_DWORD *)(a2 + 368) = v13 & 0xFFFFFFFD;
      if (!(_DWORD)v10) {
        goto LABEL_16;
      }
    }

    else
    {
      sub_10002587C(a1, 5, "service inactive: %s%s", a4, a5, a6, a7, a8, a2 + 80);
      uint64_t v14 = *(void *)(a2 + 88);
      if (v14) {
        *(void *)(v14 + 96) = *(void *)(a2 + 96);
      }
      **(void **)(a2 + 96) = v14;
      *(void *)(a2 + 88) = -1LL;
      *(void *)(a2 + 96) = -1LL;
      if (!*(_DWORD *)(a2 + 296))
      {
        --*(_DWORD *)(a1 + 168);
LABEL_16:
        uint64_t v16 = sub_10001E50C(a2);
        BOOL v17 = sub_10003DD04(v16);
        unsigned int v25 = *(_DWORD *)(a2 + 368) & 0xFFFFDFFF;
        if (!v17) {
          unsigned int v25 = *(_DWORD *)(a2 + 368);
        }
        int v26 = *(_DWORD *)(a2 + 296);
        *(_DWORD *)(a2 + 360) = -1;
        unsigned int v15 = v25 & 0xFFFFFF3F;
        *(_DWORD *)(a2 + 368) = v25 & 0xFFFFFF3F;
        *(_WORD *)(a2 + 300) = 0;
        if (!(v26 | v25 & 0x2000))
        {
          sub_10001DA98(a2, v18, v19, v20, v21, v22, v23, v24);
          unsigned int v15 = *(_DWORD *)(a2 + 368);
        }

        goto LABEL_20;
      }
    }

    *(_DWORD *)(a2 + 360) = -1;
    unsigned int v15 = *(_DWORD *)(a2 + 368) & 0xFFFFFF3F;
    *(_WORD *)(a2 + 300) = 0;
LABEL_20:
    *(_DWORD *)(a2 + 368) = v15 & 0xFFFFDFFF;
    xpc_object_t v27 = *(void **)(a2 + 272);
    if (v27)
    {
      *(void *)(a2 + 272) = 0LL;
      xpc_release(v27);
    }

    uint64_t v28 = *(dispatch_group_s **)(a2 + 328);
    if (v28)
    {
      *(void *)(a2 + 328) = 0LL;
      dispatch_group_leave(v28);
      dispatch_release(v28);
    }

    uint64_t v29 = *(dispatch_group_s **)(a2 + 336);
    if (v29)
    {
      dispatch_group_leave(v29);
      *(void *)(a2 + 336) = 0LL;
    }

    *(_DWORD *)(a2 + 368) &= ~0x8000u;
    sub_10002B6F8(a2);
    if (*(_DWORD *)(a2 + 296))
    {
      if (*(void *)(a2 + 160)) {
        sub_100039448("unmanaged service deactivated with active dynamic endpoints");
      }
      if (*(void *)(a2 + 168)) {
        sub_100039448("unmanaged service deactivated with active pid endpoints");
      }
      sub_10002587C(a1, 5, "removing inactive unmanaged service: %s", v31, v32, v33, v34, v35, a2 + 80);
      memset((void *)a2, 204, 0x550uLL);
      free((void *)a2);
      sub_10001685C((void *)a1);
    }

    else if ((*(_WORD *)(a1 + 968) & 1) != 0 || (*(_BYTE *)(a2 + 368) & 0x10) != 0)
    {
      __int128 v43 = *(dispatch_group_s **)(a2 + 280);
      if (v43)
      {
        dispatch_group_leave(v43);
        *(void *)(a2 + 280) = 0LL;
      }

      sub_10002B73C(a1, a2, v30, v31, v32, v33, v34, v35);
    }

    else
    {
      sub_10002BA6C((void *)a2);
      if (!*(_WORD *)(a1 + 172) && *(_DWORD *)(a2 + 288)) {
        sub_10002B3D0(a2, v36, v37, v38, v39, v40, v41, v42);
      }
    }
  }

void sub_10002B6F8(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 296) && (*(_BYTE *)(a1 + 369) & 0x40) != 0)
  {
    dispatch_group_leave((dispatch_group_t)qword_10006A418);
    *(_DWORD *)(a1 + 368) &= ~0x4000u;
  }

void sub_10002B73C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 248) != a1)
  {
    uint64_t v34 = sub_10001C2A0(a2, 1);
    uint64_t v35 = sub_1000258E0(a1, 1);
    sub_100039448("%s is being removed from a mismatched domain %s", v34, v35);
  }

  if (*(_UNKNOWN **)(a1 + 104) != &unk_100069750 || *(_WORD *)(a2 + 300)) {
    sub_10002587C(a1, 5, "removing service: %s", a4, a5, a6, a7, a8, a2 + 80);
  }
  *(_DWORD *)(a2 + 368) = *(_DWORD *)(a2 + 368) & 0xFFFFFFEE | 0x10;
  sub_10002BB28(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(a2 + 152);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 16);
      sub_10002BBE0(a1, v10);
      uint64_t v10 = v11;
    }

    while (v11);
  }

  uint64_t v12 = *(void *)(a2 + 176);
  if (v12)
  {
    do
    {
      uint64_t v13 = *(void *)(v12 + 16);
      sub_10002BBE0(a1, v12);
      uint64_t v12 = v13;
    }

    while (v13);
  }

  uint64_t v14 = *(void *)(a2 + 184);
  if (v14)
  {
    do
    {
      uint64_t v15 = *(void *)(v14 + 16);
      sub_10002BBE0(a1, v14);
      uint64_t v14 = v15;
    }

    while (v15);
  }

  uint64_t v16 = *(void **)(a2 + 192);
  if (v16)
  {
    uint64_t v18 = (void *)v16[2];
    uint64_t v19 = (void *)v16[3];
    BOOL v17 = v16 + 2;
    if (v18)
    {
      do
      {
        uint64_t v20 = v18;
        _OWORD v18[3] = v19;
        *(void *)v16[3] = v18;
        *BOOL v17 = -1LL;
        v17[1] = -1LL;
        sub_10001685C(v16);
        BOOL v17 = v20 + 2;
        uint64_t v18 = (void *)v20[2];
        uint64_t v19 = (void *)v20[3];
        uint64_t v16 = v20;
      }

      while (v18);
    }

    else
    {
      uint64_t v20 = *(void **)(a2 + 192);
    }

    *uint64_t v19 = 0LL;
    *BOOL v17 = -1LL;
    v17[1] = -1LL;
    sub_10001685C(v20);
  }

  uint64_t v21 = *(void *)(a2 + 200);
  if (v21)
  {
    do
    {
      uint64_t v22 = *(void *)(v21 + 40);
      sub_1000266FC(a1);
      uint64_t v21 = v22;
    }

    while (v22);
  }

  if ((*(_DWORD *)(a2 + 368) & 0x600) == 0x200)
  {
    uint64_t v23 = *(void *)(a2 + 40);
    *(_DWORD *)(a2 + 368) |= 0x400u;
    uint64_t v24 = *(void **)(a2 + 48);
    if (v23)
    {
      *(void *)(v23 + 48) = v24;
      uint64_t v24 = *(void **)(a2 + 48);
    }

    else
    {
      uint64_t v25 = *(void *)(a2 + 256);
      *(_DWORD *)(v25 + 240) = *(_DWORD *)(v25 + 224);
      *(void *)(v25 + 232) = *(void *)(v25 + 216);
      *(_DWORD *)(v25 + 224) = 5474;
      *(void *)(v25 + 208) = v24;
      *(void *)(v25 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
    }

    *uint64_t v24 = v23;
    *(void *)(a2 + 40) = -1LL;
    *(void *)(a2 + 48) = -1LL;
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 64);
    *(void *)(a2 + 72) = *(void *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = 5474;
    *(void *)(a2 + 56) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
  }

  if (sub_10001CB2C(a2))
  {
    int v26 = *(_DWORD **)(a2 + 256);
    --v26[66];
    sub_10001685C(v26);
  }

  xpc_object_t v27 = *(void **)(a1 + 88);
  if (v27)
  {
    do
    {
      uint64_t v28 = (void *)*v27;
      if (v27[2] == a2)
      {
        if (v28) {
          v28[1] = v27[1];
        }
        *(void *)v27[1] = v28;
        void *v27 = -1LL;
        v27[1] = -1LL;
        j__free(v27);
      }

      xpc_object_t v27 = v28;
    }

    while (v28);
  }

  uint64_t v29 = *(void *)(a2 + 120);
  if (v29) {
    *(void *)(v29 + 128) = *(void *)(a2 + 128);
  }
  **(void **)(a2 + 128) = v29;
  *(void *)(a2 + 120) = -1LL;
  *(void *)(a2 + 128) = -1LL;
  --*(_DWORD *)(a1 + 164);
  uint64_t v30 = *(void *)(a2 + 312);
  if (v30)
  {
    uint64_t v31 = (void *)sub_10000F650(v30);
    os_release(v31);
    *(void *)(a2 + 312) = 0LL;
  }

  uint64_t v32 = *(void *)(a2 + 320);
  if (v32)
  {
    uint64_t v33 = (void *)sub_10000F650(v32);
    os_release(v33);
    *(void *)(a2 + 320) = 0LL;
  }

  if (*(void *)(a1 + 64) == a2) {
    *(void *)(a1 + 64) = 0LL;
  }
  sub_100004AB0((void *)a2);
  sub_10001685C((void *)a2);
  sub_100025B64(a1);
  sub_10001685C((void *)a1);
}

void sub_10002BA6C(void *a1)
{
  for (uint64_t i = a1[19]; i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 4) != 0) {
      sub_100039448("service deactivated with active endpoints");
    }
    sub_100040070(i);
  }

  for (uint64_t j = a1[22]; j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 4) != 0) {
      sub_100039448("service deactivated with active event endpoints");
    }
    sub_100040070(j);
  }

  for (uint64_t k = a1[23]; k; uint64_t k = *(void *)(k + 16))
  {
    if ((*(_BYTE *)(k + 88) & 4) != 0) {
      sub_100039448("service deactivated with active instance endpoints");
    }
    sub_100040070(k);
  }

  for (uint64_t m = a1[24]; m; uint64_t m = *(void *)(m + 16))
    sub_100018D2C(m);
  sub_10001DB8C((uint64_t)a1);
}

void sub_10002BB28( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a1 + 369) & 8) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 160);
    if (v9)
    {
      do
      {
        uint64_t v10 = *(void *)(v9 + 16);
        sub_1000404D4(v9, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v9 = v10;
      }

      while (v10);
    }

    uint64_t v11 = *(void *)(a1 + 168);
    if (v11)
    {
      do
      {
        uint64_t v12 = *(void *)(v11 + 16);
        sub_1000404D4(v11, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v11 = v12;
      }

      while (v12);
    }
  }

  uint64_t v13 = *(void *)(a1 + 152);
  if (v13)
  {
    do
    {
      uint64_t v14 = *(void *)(v13 + 16);
      sub_1000404D4(v13, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v13 = v14;
    }

    while (v14);
  }

  uint64_t v15 = *(void *)(a1 + 176);
  if (v15)
  {
    do
    {
      uint64_t v16 = *(void *)(v15 + 16);
      sub_1000404D4(v15, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v15 = v16;
    }

    while (v16);
  }

  uint64_t v17 = *(void *)(a1 + 184);
  if (v17)
  {
    do
    {
      uint64_t v18 = *(void *)(v17 + 16);
      sub_1000404D4(v17, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v17 = v18;
    }

    while (v18);
  }

  uint64_t v19 = *(void *)(a1 + 192);
  if (v19)
  {
    do
    {
      uint64_t v20 = *(void *)(v19 + 16);
      sub_1000190EC(v19);
      uint64_t v19 = v20;
    }

    while (v20);
  }

  sub_10001DCF0(a1);
}

void sub_10002BBE0(uint64_t a1, uint64_t a2)
{
  kern_return_t v13;
  uint64_t v14;
  uint64_t v15;
  if (*(void *)(a2 + 72))
  {
    sub_10002BD2C((void *)a2);
  }

  else
  {
    uint64_t v4 = *(void **)(a2 + 64);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)v4[6];
        sub_10002BD2C(v4);
        uint64_t v4 = v5;
      }

      while (v5);
    }

    if ((*(_BYTE *)(a2 + 88) & 0x20) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 80);
      if (v6)
      {
        uint64_t v7 = (mach_port_name_t *)(a1 + 80);
        do
        {
          uint64_t v7 = *(mach_port_name_t **)v7;
          if (!v7) {
            sub_100039448("domain has no corresponding special port entry");
          }
        }

        while (v7[5] != v6);
        sub_100025814(a1, v7);
      }

      int v8 = *(_DWORD *)(a2 + 84);
      if (v8)
      {
        if (v8 == 24)
        {
          task_t v9 = mach_host_self();
          sub_10003C50C(v9, 0);
          uint64_t v10 = &qword_10006A420;
        }

        else
        {
          uint64_t v11 = v8;
          mach_port_t v12 = mach_host_self();
          uint64_t v13 = host_set_special_port(v12, v11, 0);
          if (v13) {
            _os_assumes_log(v13);
          }
          uint64_t v10 = (uint64_t *)((char *)&unk_10006A428 + 8 * v11);
        }

        *uint64_t v10 = 0LL;
      }

      uint64_t v14 = *(void *)(a2 + 32);
      if (v14) {
        *(void *)(v14 + 40) = *(void *)(a2 + 40);
      }
      **(void **)(a2 + 40) = v14;
      *(void *)(a2 + 32) = -1LL;
      *(void *)(a2 + 40) = -1LL;
    }

    uint64_t v15 = *(void *)(a2 + 16);
    if (v15) {
      *(void *)(v15 + 24) = *(void *)(a2 + 24);
    }
    **(void **)(a2 + 24) = v15;
    *(void *)(a2 + 16) = -1LL;
    *(void *)(a2 + 24) = -1LL;
    sub_10001685C((void *)a2);
  }

void sub_10002BD2C(void *a1)
{
  if (!a1[9]) {
    sub_100039448("alias-removal attempt of non-aliased endpoint");
  }
  uint64_t v1 = a1[4];
  if (v1) {
    *(void *)(v1 + 40) = a1[5];
  }
  *(void *)a1[5] = v1;
  uint64_t v2 = a1[6];
  if (v2) {
    *(void *)(v2 + 56) = a1[7];
  }
  *(void *)a1[7] = v2;
  free(a1);
}

void sub_10002BD80(uint64_t a1, uint64_t a2)
{
  pid_t v4 = sub_10001DD5C(a2);
  if (sub_10003A508(v4) && sub_100011008(1))
  {
    int v12 = sub_10000D8B8("kern.darkboot");
    sub_10002587C(a1, 5, "Queried sysctl kern.darkboot: %u", v13, v14, v15, v16, v17, v12);
    if (v12 == 1)
    {
      sub_10002587C(a1, 5, "Setting sysctl kern.darkboot to %u", v18, v19, v20, v21, v22, 2);
      sub_10000D8B4("kern.darkboot", 2LL);
    }

    sub_100011028("Abandoning service: %s", (const char *)(a2 + 1360));
  }

  *(_DWORD *)(a2 + 368) |= 0x800u;
  sub_10002BB28(a2, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_10002BE4C(uint64_t a1, uint64_t a2)
{
  kern_return_t v82;
  pid_t v4 = (const char *)sub_10003FDE0(a2);
  uint64_t v5 = sub_10002AE24(a1, (char *)(a2 + 168));
  if (v5)
  {
    if (*(void *)(v5 + 72)) {
      uint64_t v6 = *(void *)(v5 + 72);
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = sub_10003FDE0(v6);
    if (sub_10003FE08(a2) && !sub_10003FE08(v6))
    {
      sub_10001A4D8( v7,  4,  "Unmanaged endpoint %s was canceled to transfer the ownership to: %s",  v9,  v10,  v11,  v12,  v13,  v6 - 88);
      sub_1000404D4(v6, v21, v22, v23, v24, v25, v26, v27);
    }

    else
    {
      uint64_t v14 = sub_10003F1E0(v6, 2, v8, v9, v10, v11, v12, v13);
      if (!sub_10002C17C(v14))
      {
        sub_10001A4D8( (uint64_t)v4,  4,  "The endpoint %s defined in plist already exists and is owned by: %s",  v15,  v16,  v17,  v18,  v19,  a2 - 88);
        return 37LL;
      }

      *(_BYTE *)(v6 + 88) |= 0x40u;
    }
  }

  if ((*(_BYTE *)(a2 + 88) & 0x10) != 0)
  {
    if (*(_UNKNOWN **)(a1 + 104) == &unk_1000695B8) {
      *(_DWORD *)(a2 + 84) = 24;
    }
    else {
      *(_DWORD *)(a2 + 80) = 128;
    }
  }

  uint64_t v28 = sub_10003FDE0(a2);
  if ((sub_1000032C4(v28, 2) & 1) != 0)
  {
    uint64_t v35 = (_DWORD *)(a2 + 84);
    uint64_t v34 = *(unsigned int *)(a2 + 84);
    if (!(_DWORD)v34 || *(_UNKNOWN **)(a1 + 104) == &unk_1000695B8) {
      goto LABEL_23;
    }
LABEL_22:
    mach_host_special_port_description(v34);
    sub_10001A4D8(v28, 3, "Non-system service tried to claim host-special port: %d: %s", v36, v37, v38, v39, v40, v34);
    *uint64_t v35 = 0;
    goto LABEL_23;
  }

  if (*(_DWORD *)(a2 + 80))
  {
    sub_10001A4D8( v28,  3,  "Non-system service tried to claim task-special port: %d",  v29,  v30,  v31,  v32,  v33,  *(_DWORD *)(a2 + 80));
    *(_DWORD *)(a2 + 80) = 0;
  }

  uint64_t v35 = (_DWORD *)(a2 + 84);
  uint64_t v34 = *(unsigned int *)(a2 + 84);
  if ((_DWORD)v34) {
    goto LABEL_22;
  }
LABEL_23:
  __int128 v47 = (uint64_t *)(a1 + 8 * (sub_100012B50((_BYTE *)(a2 + 168)) % 0x1FuLL) + 672);
  uint64_t v48 = *v47;
  *(void *)(a2 + 32) = *v47;
  if (v48) {
    *(void *)(v48 + 40) = a2 + 32;
  }
  *__int128 v47 = a2;
  *(void *)(a2 + 40) = v47;
  if (*(_DWORD *)(a2 + 80))
  {
    mach_port_name_t v49 = sub_10003F1E0(a2, 1, v41, v42, v43, v44, v45, v46);
  }

  uint64_t v54 = *(int *)(a2 + 84);
  if (!(_DWORD)v54) {
    goto LABEL_39;
  }
  uint64_t v60 = sub_10003FDE0(a2);
  if ((_DWORD)v54 == 24)
  {
    if (!qword_10006A420)
    {
      qword_10006A420 = a2;
      task_t v66 = mach_host_self();
      mach_port_t v73 = sub_10003F1E0(a2, 1, v67, v68, v69, v70, v71, v72);
      sub_10003C50C(v66, v73);
      goto LABEL_39;
    }

    sub_10001A4D8( v60,  3,  "Endpoint %s tried to steal host exception port from %s",  v55,  v56,  v57,  v58,  v59,  a2 - 88);
  }

  else
  {
    if (!qword_10006A428[v54])
    {
      mach_port_t v74 = mach_host_self();
      mach_port_t v81 = sub_10003F1E0(a2, 1, v75, v76, v77, v78, v79, v80);
      uint64_t v82 = host_set_special_port(v74, v54, v81);
      if (v82) {
        _os_assumes_log(v82);
      }
      qword_10006A428[v54] = a2;
      goto LABEL_39;
    }

    mach_host_special_port_description(v54);
    sub_10001A4D8( v60,  3,  "Endpoint %s tried to steal host %s port (%d) from %s",  v61,  v62,  v63,  v64,  v65,  a2 - 88);
  }

  *(_DWORD *)(a2 + 84) = 0;
LABEL_39:
  uint64_t result = 0LL;
  *(_BYTE *)(a2 + 88) |= 0x20u;
  return result;
}

uint64_t sub_10002C17C(uint64_t name)
{
  pxpc_type_t type = 0;
  if ((_DWORD)name)
  {
    if (mach_port_type(mach_task_self_, name, &ptype)) {
      return 1LL;
    }
    else {
      return (BYTE2(ptype) >> 4) & 1;
    }
  }

  return name;
}

uint64_t sub_10002C1C8( uint64_t a1, const char *a2, mach_port_name_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void **)(a1 + 80);
  uint64_t v12 = a1 + 80;
  while (1)
  {
    uint64_t v12 = *(void *)v12;
    if (!v12) {
      break;
    }
    if (*(_DWORD *)(v12 + 20) == (_DWORD)a4)
    {
      sub_10002A694(a1, *(unsigned int *)(v12 + 16), 0LL, a4, a5, a6, a7, a8);
      if (a2) {
        LOBYTE(a2) = (_BYTE)a2 + 80;
      }
      else {
        a2 = "(unknown)";
      }
      if ((_DWORD)a4 != 128) {
        mach_task_special_port_description(a4);
      }
      sub_10002587C( a1,  3,  "service %s tried to claim task-%s port from endpoint %s",  v13,  v14,  v15,  v16,  v17,  (char)a2);
      return 17LL;
    }
  }

  uint64_t v18 = sub_100016BA4(a3, a4);
  uint64_t v19 = *v11;
  if (*v11)
  {
    uint64_t v20 = (void *)*v19;
    *uint64_t v18 = *v19;
    if (v20) {
      v20[1] = v18;
    }
    uint64_t v11 = (void **)v19;
  }

  else
  {
    *uint64_t v18 = 0LL;
  }

  uint64_t v21 = 0LL;
  *uint64_t v11 = v18;
  v18[1] = v11;
  ++*(void *)(a1 + 72);
  return v21;
}

unint64_t sub_10002C2D4(unint64_t result, uint64_t a2)
{
  unint64_t v3 = result;
  if (*(void *)(a2 + 248) != result) {
    sub_100047928(a2);
  }
  int v4 = (__int16)(*(_WORD *)(a2 + 300))++;
  if (v4 < 0) {
    sub_1000478EC(a2);
  }
  if (!v4)
  {
    if (*(_DWORD *)(a2 + 296))
    {
      int v9 = *(_DWORD *)(a2 + 296);
      uint64_t result = sub_100012B1C(&v9, 4LL);
      uint64_t v5 = (uint64_t *)(v3 + 8 * (result % 7) + 616);
      uint64_t v6 = *v5;
      *(void *)(a2 + 88) = *v5;
      if (v6) {
        *(void *)(v6 + 96) = a2 + 88;
      }
      uint64_t *v5 = a2;
      *(void *)(a2 + 96) = v5;
    }

    else
    {
      int v9 = sub_10001DD5C(a2);
      uint64_t result = sub_100012B1C(&v9, 4LL);
      uint64_t v7 = (uint64_t *)(v3 + 8 * (result % 0xD) + 512);
      uint64_t v8 = *v7;
      *(void *)(a2 + 88) = *v7;
      if (v8) {
        *(void *)(v8 + 96) = a2 + 88;
      }
      *uint64_t v7 = a2;
      *(void *)(a2 + 96) = v7;
      ++*(_DWORD *)(v3 + 168);
    }
  }

  return result;
}

void sub_10002C424(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 248);
  BOOL v63 = 0;
  int v7 = sub_10001E514(a3, &v63);
  if (a2 == 2)
  {
    if (byte_10006A919)
    {
      return;
    }

    if (v63) {
      int v18 = 0;
    }
    else {
      int v18 = v7;
    }
    if (v18 != 1)
    {
      int v37 = sub_10001D3D8(a3, 2LL, v8, v9, v10, v11, v12, v13);
      if ((v37 & 0xFFFFFFFE) == 0x24) {
        int v38 = 0;
      }
      else {
        int v38 = v37;
      }
      if (v38)
      {
        if (v38 == 37) {
          sub_100039448("socket event received for running service");
        }
        _os_assumes_log_ctx(sub_10001C1B0, a3);
      }

      return;
    }

    unint64_t v66 = 0LL;
    uint64_t v67 = 0LL;
    uint64_t v19 = sub_100019124((void *)a1, (unsigned int **)&v67, &v66);
    unsigned int v65 = v19;
    if ((_DWORD)v19)
    {
      char v25 = v19;
      if ((_DWORD)v19 == 35) {
        sub_100039448("EWOULDBLOCK returned on socket that should not block");
      }
      xpc_strerror(v19);
      sub_10001A4D8(a3, 3, "Could not accept new inetd connection: %d: %s", v26, v27, v28, v29, v30, v25);
      return;
    }

    if (!v66)
    {
      sub_10001A4D8( a3,  3,  "Got a socket event for an inetd service, but couldn't accept any sockets",  v20,  v21,  v22,  v23,  v24,  v62);
      if (!v66)
      {
LABEL_44:
        free(v67);
        return;
      }
    }

    unint64_t v39 = 0LL;
    while (1)
    {
      __s[0] = (char *)sub_100026D10;
      __s[1] = (char *)sub_1000270F8;
      __s[2] = (char *)sub_10002723C;
      __s[3] = (char *)sub_1000273D4;
      __s[4] = (char *)sub_10002742C;
      __s[5] = (char *)sub_100027520;
      __s[6] = (char *)v6;
      memset(out, 0, sizeof(out));
      uuid_generate(out);
      unsigned int v40 = *(_DWORD *)(a3 + 268);
      if (v40 && *(_DWORD *)(a3 + 264) >= v40)
      {
        uint64_t v56 = 67LL;
        unsigned int v65 = 67;
      }

      else
      {
        uint64_t v41 = sub_100003C3C(a3, out, *((unsigned int *)v67 + v39), 0LL, 0LL, (uint64_t)__s, 0LL, (int *)&v65);
        if (v41)
        {
          uint64_t v42 = (uint64_t)v41;
          *((_DWORD *)v41 + 92) |= 0x100u;
          sub_1000265C0((_DWORD *)v6, (uint64_t)v41);
          ++*(_DWORD *)(a3 + 264);
          *(void *)(v42 + 256) = a3;
          sub_1000167B0((void *)a3);
          unsigned int v49 = sub_10001D3D8(v42, 2LL, v43, v44, v45, v46, v47, v48);
          if ((v49 & 0xFFFFFFFE) == 0x24) {
            uint64_t v50 = 0LL;
          }
          else {
            uint64_t v50 = v49;
          }
          unsigned int v65 = v50;
          if ((_DWORD)v50)
          {
            xpc_strerror(v50);
            sub_10001A4D8(v42, 3, "Could not spawn dedicated inetd instance: %d: %s", v51, v52, v53, v54, v55, v50);
          }

          goto LABEL_43;
        }

        uint64_t v56 = v65;
      }

      xpc_strerror(v56);
      sub_10001A4D8(a3, 3, "Could not create new instance of inetd service: %d: %s", v57, v58, v59, v60, v61, v56);
LABEL_43:
      sub_100036D70((int *)*((unsigned int *)v67 + v39++));
      if (v39 >= v66) {
        goto LABEL_44;
      }
    }
  }

  if (a2 != 1)
  {
    if (a2) {
      return;
    }
    __s[0] = 0LL;
    uint64_t v14 = (const char *)sub_100018D10(a1, __s);
    if (v14)
    {
      *(void *)uuid_t out = 0LL;
      uint64_t v15 = sub_1000168AC(__s[0], v14, 0LL, (size_t *)out, 0);
      if (v15)
      {
        uint64_t v16 = (char **)(v6 + 88);
        uint64_t v17 = *(void *)(v6 + 88);
        *(void *)uint64_t v15 = v17;
        if (v17) {
          *(void *)(v17 + 8) = v15;
        }
        *uint64_t v16 = v15;
        *((void *)v15 + 1) = v16;
        *((void *)v15 + 2) = a3;
      }

      else
      {
        sub_10001A4D8( a3,  3,  "Service attempted to specify secure socket key with reserved name: %s",  v9,  v10,  v11,  v12,  v13,  (char)__s[0]);
      }
    }

    *(_BYTE *)(a1 + 48) |= 1u;
  }

  sub_10002B3F0(v6, a3, v8, v9, v10, v11, v12, v13);
  sub_1000262C4(v6, 9LL, v31, v32, v33, v34, v35, v36);
}

BOOL sub_10002C7C4(id a1, const char *a2, void *a3)
{
  return 1;
}

uint64_t sub_10002C7EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(FILE **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40) + 2LL;
  uint64_t v6 = sub_100001238(a3);
  return sub_10003D32C(v4, v5, "%s (%d records)", v7, v8, v9, v10, v11, a2, v6);
}

uint64_t sub_10002C840( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10003D32C(*(FILE **)(a3 + 8), *(void *)(a3 + 16), "%s", a4, a5, a6, a7, a8, a1);
}

uint64_t sub_10002C870( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1LL;
}

void *sub_10002C8AC( uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a3;
  sub_10003D3A8(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v19);
  uint64_t result = *(void **)(a1 + 920);
  if (result && (uint64_t result = (void *)xpc_dictionary_get_count(result)) != 0LL)
  {
    sub_10003D32C(a2, 1LL, "disabled services = {", v11, v12, v13, v14, v15);
    xpc_object_t v17 = xpc_copy(*(xpc_object_t *)(a1 + 920));
    xpc_dictionary_set_value(v17, "_dirty", 0LL);
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_10002CA48;
    applier[3] = &unk_100064940;
    applier[4] = a2;
    xpc_dictionary_apply(v17, applier);
    xpc_release(v17);
    int v18 = "}";
  }

  else
  {
    if ((v8 & 1) != 0) {
      return result;
    }
    int v18 = "disabled services = (no disabled services)";
  }

  return (void *)sub_10003D32C(a2, 1LL, v18, v11, v12, v13, v14, v15);
}

uint64_t sub_10002C9A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 128);
  if (v4) {
    LODWORD(v4) = xpc_mach_send_get_right();
  }
  if ((_DWORD)v4 != (_DWORD)a2)
  {
    uint64_t v5 = *(void *)(v3 + 288);
    if (v5)
    {
      while (1)
      {
        uint64_t v6 = sub_10002C9A0(v5, a2);
        if (v6) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 16);
        if (!v5) {
          return 0LL;
        }
      }

      return v6;
    }

    else
    {
      return 0LL;
    }
  }

  return v3;
}

uint64_t sub_10002CA0C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1LL;
}

uint64_t sub_10002CA48( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *(FILE **)(a1 + 32);
  if (a3 == &_xpc_BOOL_true) {
    uint64_t v9 = "disabled";
  }
  else {
    uint64_t v9 = "enabled";
  }
  sub_10003D32C(v8, 2LL, "%s => %s", a4, a5, a6, a7, a8, a2, v9);
  return 1LL;
}

uint64_t sub_10002CA9C(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 20);
  if (v2 == getpid()) {
    return 1LL;
  }
  else {
    return sub_10003A47C(a1, 0x4000000);
  }
}

uint64_t sub_10002CAE0(int a1, char *a2)
{
  size_t v4 = 1024LL;
  int v5 = a1;
  while (1)
  {
    memset(buffer, 0, sizeof(buffer));
    uint64_t result = sub_100039918(v5, buffer);
    int v7 = result;
    if (v5 == a1)
    {
      if (v4 < 2) {
        goto LABEL_11;
      }
      uint64_t result = snprintf(a2, v4, "%s[%d]");
    }

    else
    {
      if (v4 < 2)
      {
LABEL_11:
        size_t v8 = 0LL;
        if ((_DWORD)result) {
          return result;
        }
        goto LABEL_12;
      }

      uint64_t result = snprintf(a2, v4, "<-%s[%d]");
    }

    size_t v8 = (int)result;
    if (v7) {
      return result;
    }
LABEL_12:
    if (v5 != 1)
    {
      int v5 = DWORD1(buffer[0]);
      if (DWORD1(buffer[0]) > 1)
      {
        a2 += v8;
        v4 -= v8;
        if (v4) {
          continue;
        }
      }
    }

    return result;
  }

uint64_t sub_10002CC20(uint64_t a1, uint64_t a2, void *a3)
{
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!info_dictionary) {
    return 22LL;
  }
  xpc_object_t value = xpc_dictionary_get_value(info_dictionary, "XPCService");
  if (!value)
  {
    uint64_t v13 = 0LL;
    *a3 = qword_100069750;
    return v13;
  }

  int v7 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10002587C(a1, 3, "Invalid XPCService dictionary.", v8, v9, v10, v11, v12, v23);
    return 22LL;
  }

  char string = xpc_dictionary_get_string(v7, "ServiceType");
  if (!string)
  {
    uint64_t v16 = qword_100069750;
LABEL_14:
    uint64_t v13 = 0LL;
    *a3 = v16;
    goto LABEL_15;
  }

  uint64_t v15 = string;
  if (!strcmp(string, "System"))
  {
    uint64_t v16 = &unk_1000695B8;
    goto LABEL_14;
  }

  if (!strcmp(v15, "Application"))
  {
    uint64_t v16 = qword_100069750;
    goto LABEL_14;
  }

  uint64_t v13 = 22LL;
LABEL_15:
  if (xpc_dictionary_get_BOOL(v7, "_MultipleInstances") && (void *)*a3 != qword_100069750)
  {
    sub_10002587C( a1,  4,  "MultipleInstance XPC services are not supported for any service type other than Application. Forcing service to PID domain.",  v17,  v18,  v19,  v20,  v21,  v23);
    *a3 = qword_100069750;
  }

  return v13;
}

uint64_t sub_10002CD60(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  if ((*(_WORD *)(a1 + 968) & 3) != 0) {
    return 124LL;
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, "paths");
  if (value)
  {
    uint64_t v10 = value;
    if ((xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(v10) == (xpc_type_t)&_xpc_type_array)
      && xpc_dictionary_expects_reply(xdict))
    {
      if (xpc_dictionary_get_BOOL(xdict, "enable")) {
        uint64_t v11 = 2048LL;
      }
      else {
        uint64_t v11 = 0LL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "force")) {
        v11 |= 0x8000uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "legacy-load")) {
        v11 |= 0x100uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "angel")) {
        v11 |= 0x40000uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "managed-lwcr")) {
        v11 |= 0x80000uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "by-cli")) {
        v11 |= 0x100000uLL;
      }
      if (*(void **)(a1 + 104) == qword_100069750)
      {
        uint64_t v22 = sub_10002FCF8(a1, a2, v12, v13, v14, v15, v16, v17);
        if ((_BYTE)v22)
        {
          if (v22 != 37)
          {
            char v23 = v22;
            xpc_strerror(v22);
            sub_10002587C( a1,  5,  "failed to uncork PID domain on first bootstrap: %d - %s",  v24,  v25,  v26,  v27,  v28,  v23);
          }
        }
      }

      uint64_t v18 = (void *)sub_10003424C(xdict);
      sub_100013F88((void *)a1, 1, v18, v10, a2, v11, v19, v20);
      xpc_release(v18);
      return 0LL;
    }

    else
    {
      return 22LL;
    }
  }

  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(xdict);
    uint64_t result = 0LL;
    *a4 = reply;
  }

  return result;
}

uint64_t sub_10002CF54(void *a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8 = sub_100028AF4((uint64_t)a1, 4LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
LABEL_4:
    sub_100028BC8((uint64_t)a1, a2, v9, "bootout");
    return v9;
  }

  if (xpc_dictionary_get_value(a3, "paths"))
  {
    xpc_object_t value = xpc_dictionary_get_value(a3, "paths");
    if (value)
    {
      uint64_t v11 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
      {
        if (xpc_dictionary_get_BOOL(a3, "disable")) {
          uint64_t v12 = 2048LL;
        }
        else {
          uint64_t v12 = 0LL;
        }
        if (xpc_dictionary_get_BOOL(a3, "no-einprogress")) {
          v12 |= 0x20000uLL;
        }
        if (xpc_dictionary_get_BOOL(a3, "by-cli")) {
          v12 |= 0x100000uLL;
        }
        uint64_t v13 = (void *)sub_10003424C(a3);
        sub_100013F88(a1, 2, v13, v11, a2, v12, v14, v15);
        xpc_release(v13);
        return 0LL;
      }
    }

    return 22LL;
  }

  if (!xpc_dictionary_get_string(a3, "name"))
  {
    uint64_t v9 = sub_100028AF4((uint64_t)a1, 7LL, 128LL, a2, 0LL, 0LL);
    if (!(_DWORD)v9)
    {
      sub_10002FDD8((uint64_t)a1, a2, a3, a4);
      return v9;
    }

    goto LABEL_4;
  }

  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v17 = (char *)string;
  xpc_dictionary_get_BOOL(a3, "legacy-service-lookup");
  uint64_t v18 = sub_100028EF4(a1, v17);
  if (!v18) {
    return 3LL;
  }
  mach_port_context_t v19 = (mach_port_context_t)v18;
  bzero(v32, 0x400uLL);
  sub_10002CAE0(*(_DWORD *)(a2 + 20), v32);
  sub_10001A4D8(v19, 65541, "bootout initiated by: %s", v20, v21, v22, v23, v24, (char)v32);
  xpc_dictionary_get_BOOL(a3, "attempt-unload-protected");
  uint64_t v25 = sub_10001C0CC();
  if ((_DWORD)v25)
  {
    uint64_t v9 = v25;
    sub_100028BC8((uint64_t)a1, a2, v25, "bootout (%s)");
  }

  else
  {
    uint64_t v9 = sub_1000266FC((uint64_t)a1, v19);
    BOOL v27 = xpc_dictionary_get_BOOL(a3, "no-einprogress");
    BOOL v28 = xpc_dictionary_get_BOOL(a3, "wait");
    if ((_DWORD)v9 && ((_DWORD)v9 != 36 || !v27))
    {
      if ((_DWORD)v9 == 36 && v28)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        uint64_t v30 = sub_100020930(v19);
        uint64_t v31 = (void *)xpc_mach_send_create_with_disposition(v30, 20LL);
        xpc_dictionary_set_value(reply, "monitor", v31);
        xpc_release(v31);
        uint64_t v9 = 0LL;
        *a4 = reply;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }

  return v9;
}

uint64_t sub_10002D2B8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v13 = *(_DWORD *)(a2 + 28);
  if (v13 > *(_DWORD *)(a1 + 276) || *(_DWORD *)(a2 + 20) != *(_DWORD *)(a1 + 268))
  {
    sub_10002587C( a1,  5,  "exec count or caller mismatch: caller exec cnt = %u, creator exec cnt = %u, caller pid = %d, creator pid = %d",  v8,  v9,  v10,  v11,  v12,  v13);
    if (*(void *)(a1 + 184))
    {
      sub_10002587C(a1, 5, "rebirth already in progress", v15, v16, v17, v18, v19, v41);
      return 131LL;
    }

    else
    {
      sub_10002587C(a1, 5, "slaying domain for rebirth", v15, v16, v17, v18, v19, v41);
      *(_WORD *)(a1 + 968) |= 0x80u;
      *(void *)(a1 + 184) = xpc_retain(a3);
      sub_100025C50(a1, v20, v21, v22, v23, v24, v25, v26, v42);
      return 0LL;
    }
  }

  if ((*(_WORD *)(a1 + 968) & 8) != 0 || *(void *)(a1 + 216))
  {
    sub_10002587C(a1, 5, "domain already initialized", v8, v9, v10, v11, v12, v40);
    return 37LL;
  }

  xpc_object_t value = xpc_dictionary_get_value(a3, "paths");
  if (!value
    || (uint64_t v35 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    || (xpc_object_t v36 = xpc_dictionary_get_value(a3, "environment")) == 0LL
    || (xpc_object_t v37 = v36, xpc_get_type(v36) != (xpc_type_t)&_xpc_type_dictionary))
  {
    sub_100025C50(a1, v28, v29, v30, v31, v32, v33, v34, v40);
    return 22LL;
  }

  char string = xpc_dictionary_get_string(a3, "origin");
  if (string) {
    *(void *)(a1 + 208) = sub_1000126A0(string);
  }
  *(void *)(a1 + 216) = xpc_retain(v35);
  xpc_dictionary_apply_f(v37);
  *(_WORD *)(a1 + 968) |= 8u;
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_10002D4B4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v14 = sub_10002FCF8(a1, a2, v8, v9, v10, v11, v12, v13);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0LL;
  if ((_BYTE)v14 && v14 != 37 && v14 != 124)
  {
    xpc_dictionary_set_int64(reply, "error", v14);
    uint64_t result = v14;
  }

  *a4 = reply;
  return result;
}

uint64_t sub_10002D560(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (xpc_dictionary_get_uint64(a3, "type") != 7)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 104)
                                                                                              + 104LL))( a1,  6LL,  0LL,  *(void *)(a1 + 112),  a2,  0LL,  0LL);
    if ((_DWORD)v8)
    {
      uint64_t v9 = v8;
      sub_100028BC8(a1, a2, v8, "endpoint lookup");
      return v9;
    }
  }

  if ((*(_WORD *)(a1 + 968) & 3) != 0) {
    return 124LL;
  }
  if (*(_WORD *)(a1 + 172))
  {
    uint64_t v10 = *(void *)(a1 + 128);
    if (v10) {
      int right = xpc_mach_send_get_right(v10);
    }
    else {
      int right = 0;
    }
    sub_10002FF5C(a1, right, a3);
    return 0LL;
  }

  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v13 = (char *)string;
  uint int64 = xpc_dictionary_get_uint64(a3, "flags");
  uint64_t v15 = (uint64 & 0x10) != 0 ? xpc_dictionary_get_uint64(a3, "lookup-handle") : 0LL;
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  uint64_t v17 = (unsigned __int8 *)uuid;
  size_t length = 0LL;
  int data = xpc_dictionary_get_data(a3, "cputypes", &length);
  if ((uint64 & 0x400) == 0 || (uint64_t v9 = 22LL, data) && length == 36 && *(void **)(a1 + 104) == qword_100069750)
  {
    uint64_t v19 = sub_10002FFCC(a1, v13, v15, uint64, v17, (unint64_t)data, a2);
    uint64_t v9 = 0LL;
    *a4 = sub_100030594(a3, v19, v20);
  }

  return v9;
}

uint64_t sub_10002D768(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  if ((*(_WORD *)(a1 + 968) & 3) != 0) {
    return 124LL;
  }
  if (*(_WORD *)(a1 + 172))
  {
    uint64_t v7 = *(void *)(a1 + 128);
    if (v7) {
      int right = xpc_mach_send_get_right(v7);
    }
    else {
      int right = 0;
    }
    sub_10002FF5C(a1, right, xdict);
    return 0LL;
  }

  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v12 = (char *)string;
  uint int64 = xpc_dictionary_get_uint64(xdict, "flags");
  uint64_t v19 = uint64;
  if (*(void **)(a1 + 104) == qword_100069750)
  {
    if ((uint64 & 1) != 0) {
      sub_10002587C( a1,  4,  "Ignoring lax activation attempt for unsupported domain: %s",  v14,  v15,  v16,  v17,  v18,  (char)v12);
    }
    v19 &= ~1uLL;
    if ((v19 & 0x20) == 0) {
      goto LABEL_9;
    }
  }

  else if ((uint64 & 0x20) == 0)
  {
LABEL_9:
    xpc_object_t object = 0LL;
    LOBYTE(__src) = 0;
    uint64_t v20 = sub_100030AC0(a1, a2, v12, v19, 0LL, &object, &__src);
    if (!(_DWORD)v20)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(xdict);
      uint64_t v37 = xpc_mach_send_get_right(object);
      xpc_dictionary_set_mach_recv(reply, "port", v37);
      if ((_BYTE)__src) {
        xpc_dictionary_set_BOOL(reply, "non-launching", 1);
      }
      xpc_release(object);
      goto LABEL_40;
    }

    return v20;
  }

  int v22 = *(_DWORD *)(a2 + 20);
  xpc_object_t object = (xpc_object_t)a1;
  size_t v23 = sub_1000308F8((uint64_t *)&object, v22, 1);
  if (v23)
  {
    uint64_t v24 = v23;
    uint64_t v25 = (char *)sub_100010B00(0x200uLL);
    uint64_t v26 = v25;
    uint64_t v27 = *(void *)(v24 + 192);
    if (!v27)
    {
      uint64_t v4 = 3LL;
      goto LABEL_35;
    }

    unint64_t v28 = 0LL;
    uint64_t v4 = 3LL;
    uint64_t v29 = v25;
    while (1)
    {
      if (!strcmp((const char *)(v27 + 208), v12))
      {
        uint64_t v46 = 0LL;
        __src = 0LL;
        uint64_t v30 = sub_100018F94(v27, &__src, 0LL, &v46);
        uint64_t v4 = v30;
        if ((_DWORD)v30)
        {
          xpc_strerror(v30);
          sub_10001A4D8(v24, 3, "Could not activate socket named %s: %d: %s", v38, v39, v40, v41, v42, (char)v12);
          goto LABEL_34;
        }

        v28 += v46;
        if (v28 >= 0x80)
        {
          sub_10001A4D8( v24,  4,  "Too many sockets for name %s. Some will be skipped.",  v31,  v32,  v33,  v34,  v35,  (char)v12);
          sub_10001905C(v27);
          *(_WORD *)(v27 + 204) &= ~1u;
LABEL_34:
          if ((_DWORD)v4)
          {
LABEL_35:
            free(v26);
            return v4;
          }

          xpc_object_t reply = xpc_dictionary_create_reply(xdict);
          xpc_object_t v43 = xpc_array_create(0LL, 0LL);
          if (v28)
          {
            uint64_t v44 = (int *)v26;
            do
            {
              int v45 = *v44++;
              xpc_array_set_fd(v43, 0xFFFFFFFFFFFFFFFFLL, v45);
              --v28;
            }

            while (v28);
          }

          xpc_dictionary_set_value(reply, "port", v43);
          xpc_release(v43);
          free(v26);
LABEL_40:
          uint64_t v4 = 0LL;
          *a4 = reply;
          return v4;
        }

        memcpy(v29, __src, 4 * v46);
        uint64_t v4 = 0LL;
        v29 += 4 * v46;
      }

      uint64_t v27 = *(void *)(v27 + 16);
      if (!v27) {
        goto LABEL_34;
      }
    }
  }

  return 113LL;
}

uint64_t sub_10002DA78(uint64_t a1, xpc_object_t original, void *a3)
{
  if ((*(_WORD *)(a1 + 968) & 3) != 0) {
    return 124LL;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (!reply) {
    return 22LL;
  }
  xpc_object_t v14 = reply;
  sub_10002A790(a1, v7, v8, v9, v10, v11, v12, v13, v15);
  uint64_t result = 0LL;
  *a3 = v14;
  return result;
}

uint64_t sub_10002DADC(uint64_t a1, xpc_object_t original, void *a3)
{
  if ((*(_WORD *)(a1 + 968) & 3) != 0) {
    return 124LL;
  }
  if (!*(_DWORD *)(a1 + 160)) {
    return 34LL;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (!reply) {
    return 22LL;
  }
  xpc_object_t v14 = reply;
  sub_1000263E4(a1, v7, v8, v9, v10, v11, v12, v13);
  uint64_t result = 0LL;
  *a3 = v14;
  return result;
}

uint64_t sub_10002DB50(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "names");
  if (!value) {
    return 22LL;
  }
  uint64_t v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_array) {
    return 22LL;
  }
  uint64_t v12 = sub_100028AF4(a1, 4LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v12)
  {
    uint64_t v10 = v12;
    if ((_DWORD)v12 != 1 || *(_UNKNOWN **)(a1 + 104) != &unk_1000695B8 || (sub_10003107C(a2, v9) & 1) == 0)
    {
      sub_100028BC8(a1, a2, v10, "enable service");
      return v10;
    }
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (!reply) {
    return 22LL;
  }
  xpc_object_t v14 = reply;
  if (xpc_array_get_count(v9))
  {
    size_t v15 = 0LL;
    do
    {
      char string = (char *)xpc_array_get_string(v9, v15);
      if (string)
      {
        uint64_t v17 = string;
        uint64_t v18 = sub_10002A9E4(a1, string, 2);
        if ((_DWORD)v18)
        {
          uint64_t v19 = v18;
          xpc_dictionary_set_int64(v14, v17, 0LL);
          xpc_strerror(v19);
          sub_10002587C(a1, 4, "Failed to enable service %s, error=%d - %s", v20, v21, v22, v23, v24, (char)v17);
        }
      }

      ++v15;
    }

    while (v15 < xpc_array_get_count(v9));
  }

  sub_1000417C0();
  uint64_t v10 = 0LL;
  *a4 = v14;
  return v10;
}

uint64_t sub_10002DCE0(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "names");
  if (!value) {
    return 22LL;
  }
  uint64_t v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_array) {
    return 22LL;
  }
  uint64_t v12 = sub_100028AF4(a1, 4LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v12)
  {
    uint64_t v10 = v12;
    if ((_DWORD)v12 != 1 || *(_UNKNOWN **)(a1 + 104) != &unk_1000695B8 || (sub_10003107C(a2, v9) & 1) == 0)
    {
      sub_100028BC8(a1, a2, v10, "disable service");
      return v10;
    }
  }

  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (!reply) {
    return 22LL;
  }
  xpc_object_t v14 = reply;
  if (xpc_array_get_count(v9))
  {
    size_t v15 = 0LL;
    do
    {
      char string = (char *)xpc_array_get_string(v9, v15);
      if (string)
      {
        uint64_t v17 = string;
        uint64_t v18 = sub_10002A9E4(a1, string, 1);
        if ((_DWORD)v18)
        {
          uint64_t v19 = v18;
          xpc_dictionary_set_int64(v14, v17, v18);
          xpc_strerror(v19);
          sub_10002587C(a1, 4, "Failed to disable service %s, error=%d - %s", v20, v21, v22, v23, v24, (char)v17);
        }
      }

      ++v15;
    }

    while (v15 < xpc_array_get_count(v9));
  }

  sub_1000417C0();
  uint64_t v10 = 0LL;
  *a4 = v14;
  return v10;
}

uint64_t sub_10002DE70(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!*(void *)(a1 + 920)) {
    return 125LL;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 104)
                                                                                            + 104LL))( a1,  5LL,  0LL,  *(void *)(a1 + 112),  a2,  0LL,  0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100028BC8(a1, a2, v8, "query service enabled state");
  }

  else if (*(_WORD *)(a1 + 172))
  {
    uint64_t v10 = *(void *)(a1 + 128);
    if (v10) {
      int right = xpc_mach_send_get_right(v10);
    }
    else {
      int right = 0;
    }
    sub_10002FF5C(a1, right, a3);
    return 0LL;
  }

  else
  {
    char string = xpc_dictionary_get_string(a3, "name");
    if (string
      && (uint64_t v13 = (char *)string,
          xpc_object_t value = xpc_dictionary_get_value(a3, "default-enabled"),
          (xpc_object_t reply = xpc_dictionary_create_reply(a3)) != 0LL))
    {
      uint64_t v16 = reply;
      BOOL v17 = sub_100028EF4((_DWORD *)a1, v13) != 0LL;
      xpc_dictionary_set_BOOL(v16, "loaded", v17);
      xpc_object_t v18 = sub_10002AB0C(a1, v13);
      if (v18 == &_xpc_BOOL_true)
      {
        BOOL v19 = 0;
      }

      else
      {
        BOOL v19 = 1;
        if (v18 != &_xpc_BOOL_false && value) {
          BOOL v19 = xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(value);
        }
      }

      xpc_dictionary_set_BOOL(v16, "enabled", v19);
      uint64_t v9 = 0LL;
      *a4 = v16;
    }

    else
    {
      return 22LL;
    }
  }

  return v9;
}

uint64_t sub_10002E01C(uint64_t a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint64_t v8 = *(void **)(a1 + 104);
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v10 = (char *)string;
  uint64_t v11 = sub_100028AF4(a1, 4LL, (unint64_t)(v8 != qword_100069750) << 7, a2, 0LL, 0LL);
  if ((_DWORD)v11)
  {
    uint64_t v12 = v11;
    sub_100028BC8(a1, a2, v11, "kill service (%s)", v10);
    return v12;
  }

  int64_t int64 = xpc_dictionary_get_int64(xdict, "signal");
  xpc_object_t v14 = sub_100028EF4((_DWORD *)a1, v10);
  if (!v14)
  {
    xpc_object_t v14 = sub_10002ADC0(a1, v10);
    if (!v14) {
      return 113LL;
    }
  }

  bzero(v24, 0x400uLL);
  sub_10002CAE0(*(_DWORD *)(a2 + 20), (char *)v24);
  sub_10001A4D8((uint64_t)v14, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v15, v16, v17, v18, v19, (char)"signal service");
  int v20 = sub_10001DD5C((uint64_t)v14);
  if (!v20) {
    return 3LL;
  }
  if ((v14[1357] & 0x10) != 0) {
    return 1LL;
  }
  memset(v24, 0, 32);
  uint64_t v12 = sub_10003A5AC(v20, (integer_t *)v24);
  if ((_DWORD)v12) {
    return v12;
  }
  if (*(void **)(a1 + 104) != qword_100069750
    || (unint64_t v22 = *(void *)(a1 + 112), v22 >> 31)
    || (uint64_t v23 = *(unsigned int *)(a2 + 20), (v23 & 0x80000000) != 0)
    || v22 != v23)
  {
  }

  uint64_t v12 = sub_10003A54C(v24);
  if (!(_DWORD)v12) {
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v12;
}

uint64_t sub_10002E24C(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v9 = (char *)string;
  if ((sub_10000D114(a2, 14LL) & 1) == 0)
  {
    uint64_t v11 = 144LL;
    sub_100028BC8((uint64_t)a1, a2, 144LL, "start service (%s)");
    return v11;
  }

  uint64_t v10 = sub_100028AF4((uint64_t)a1, 4LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v10)
  {
    uint64_t v11 = v10;
    sub_100028BC8((uint64_t)a1, a2, v10, "start service (%s)");
    return v11;
  }

  uint64_t v12 = sub_100028EF4(a1, v9);
  if (!v12) {
    return 3LL;
  }
  unsigned int v19 = sub_10001D3D8((uint64_t)v12, 10LL, v13, v14, v15, v16, v17, v18);
  if ((v19 & 0xFFFFFFFE) == 0x24) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = v19;
  }
  if ((_DWORD)v11 == 37 || !(_DWORD)v11)
  {
    uint64_t v11 = 0LL;
    *a4 = xpc_dictionary_create_reply(xdict);
  }

  return v11;
}

uint64_t sub_10002E378(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v9 = (char *)string;
  if ((sub_10000D114(a2, 14LL) & 1) == 0)
  {
    uint64_t v11 = 144LL;
    sub_100028BC8((uint64_t)a1, a2, 144LL, "service stop (%s)");
    return v11;
  }

  uint64_t v10 = sub_100028AF4((uint64_t)a1, 4LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v10)
  {
    uint64_t v11 = v10;
    sub_100028BC8((uint64_t)a1, a2, v10, "service stop (%s)");
    return v11;
  }

  uint64_t v12 = sub_100028EF4(a1, v9);
  if (!v12) {
    return 3LL;
  }
  uint64_t v13 = (uint64_t)v12;
  bzero(v27, 0x400uLL);
  sub_10002CAE0(*(_DWORD *)(a2 + 20), v27);
  sub_10001A4D8(v13, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v14, v15, v16, v17, v18, (char)"legacy-stop service");
  uint64_t v25 = sub_10001D4CC(v13, a2, v19, v20, v21, v22, v23, v24);
  if (!(_DWORD)v25 || (uint64_t v11 = v25, (_DWORD)v25 == 89) || (_DWORD)v25 == 37)
  {
    uint64_t v11 = 0LL;
    *a4 = xpc_dictionary_create_reply(xdict);
  }

  return v11;
}

uint64_t sub_10002E534(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v9 = (char *)string;
  uint64_t v10 = sub_100028AF4((uint64_t)a1, 4LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v10)
  {
LABEL_3:
    uint64_t v11 = v10;
    sub_100028BC8((uint64_t)a1, a2, v10, "service remove (%s)", v9);
    return v11;
  }

  uint64_t v12 = sub_100028EF4(a1, v9);
  if (!v12) {
    return 3LL;
  }
  uint64_t v13 = (uint64_t)v12;
  uint64_t v10 = sub_10001C0CC();
  if ((_DWORD)v10) {
    goto LABEL_3;
  }
  memset(v22, 0, sizeof(v22));
  char v14 = sub_100039990(a2, (char *)v22);
  sub_10001A4D8(v13, 5, "caller removing service: caller = %s[%d]", v15, v16, v17, v18, v19, v14);
  uint64_t v20 = sub_1000266FC((uint64_t)a1, v13);
  if ((_DWORD)v20 == 36 || (uint64_t v11 = v20, !(_DWORD)v20))
  {
    uint64_t v11 = 0LL;
    *a4 = xpc_dictionary_create_reply(xdict);
  }

  return v11;
}

uint64_t sub_10002E6A8(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_100028AF4((uint64_t)a1, 5LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100028BC8((uint64_t)a1, a2, v8, "service enumeration");
  }

  else if (xpc_dictionary_expects_reply(a3))
  {
    char string = (char *)xpc_dictionary_get_string(a3, "name");
    if (string)
    {
      uint64_t v11 = sub_100028EF4(a1, string);
      if (!v11) {
        return 113LL;
      }
      uint64_t v12 = v11;
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v14 = sub_10001DD94((uint64_t)v12);
      sub_1000311A8(v12, v14);
      xpc_dictionary_set_value(reply, "service", v14);
      xpc_release(v14);
    }

    else
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v15 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_value(reply, "services", v15);
      xpc_release(v15);
      for (uint64_t i = 0LL; i != 23; ++i)
      {
        for (uint64_t j = *(void *)&a1[2 * i + 76]; j; uint64_t j = *(void *)(j + 120))
        {
          xpc_object_t v18 = xpc_dictionary_create(0LL, 0LL, 0LL);
          int v19 = sub_10001DD5C(j);
          xpc_dictionary_set_int64(v18, "pid", v19);
          uint64_t v20 = sub_10001E50C(j);
          xpc_dictionary_set_int64(v18, "status", *(int *)(v20 + 28));
          xpc_dictionary_set_value(v15, (const char *)(j + 1360), v18);
          xpc_release(v18);
        }
      }
    }

    uint64_t v9 = 0LL;
    *a4 = reply;
  }

  else
  {
    return 22LL;
  }

  return v9;
}

uint64_t sub_10002E88C(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100028BC8(a1, a2, v8, "set domain environment");
  }

  else if (xpc_dictionary_expects_reply(a3) {
         && (xpc_object_t value = xpc_dictionary_get_value(a3, "envvars")) != 0LL
  }
         && (uint64_t v11 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary))
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    v13[2] = sub_100031388;
    v13[3] = &unk_100064960;
    v13[4] = a1;
    void v13[5] = a2;
    xpc_dictionary_apply(v11, v13);
    uint64_t v9 = 0LL;
    *a4 = xpc_dictionary_create_reply(a3);
  }

  else
  {
    return 22LL;
  }

  return v9;
}

uint64_t sub_10002E998(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_100028AF4(a1, 5LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100028BC8(a1, a2, v8, "get domain environment");
  }

  else if (xpc_dictionary_expects_reply(a3) && (char string = xpc_dictionary_get_string(a3, "envvar")) != 0LL)
  {
    uint64_t v11 = string;
    uint64_t v12 = (void *)(a1 + 88);
    while (1)
    {
      uint64_t v12 = (void *)*v12;
      if (!v12) {
        break;
      }
      if (sub_100016A84((uint64_t)v12, v11))
      {
        uint64_t v13 = sub_100016AE0((uint64_t)v12);
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_string(reply, "value", v13);
        uint64_t v9 = 0LL;
        *a4 = reply;
        return v9;
      }
    }

    return 3LL;
  }

  else
  {
    return 22LL;
  }

  return v9;
}

uint64_t sub_10002EA90(void **a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, "flags");
  if (a1[13] != &unk_1000695B8) {
    return 125LL;
  }
  uint64_t v10 = uint64;
  else {
    uint64_t v11 = 0LL;
  }
  uint64_t v12 = sub_100028AF4((uint64_t)a1, 4LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v12 == 150) {
    int v13 = 0;
  }
  else {
    int v13 = v12;
  }
  if (v13)
  {
    uint64_t v9 = v12;
    if (v13 == 1)
    {
      if ((sub_10000D114(a2, 20LL) & 1) != 0) {
        goto LABEL_12;
      }
      uint64_t v9 = 1LL;
    }

    sub_100028BC8((uint64_t)a1, a2, v9, "reboot");
    return v9;
  }

uint64_t sub_10002EDC8(uint64_t a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    return 125LL;
  }
  if (a2 && (int v9 = *(_DWORD *)(a2 + 20), v9 != getpid()))
  {
    int v10 = 0;
  }

  else
  {
    int v10 = 1;
  }

  int int64 = xpc_dictionary_get_int64(xdict, "which");
  if (xpc_dictionary_get_BOOL(xdict, "print"))
  {
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 0x40000000LL;
    v22[2] = sub_1000318FC;
    v22[3] = &unk_1000649A0;
    int v23 = int64;
    return sub_10003D10C(xdict, a4, (uint64_t)v22);
  }

  uint64_t v12 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v12)
  {
    uint64_t v4 = v12;
    sub_100028BC8(a1, a2, v12, "modify rlimits");
    return v4;
  }

  xpc_object_t value = xpc_dictionary_get_value(xdict, "hardlimit");
  if (!value) {
    return 22LL;
  }
  uint64_t v14 = value;
  xpc_object_t v16 = xpc_dictionary_get_value(xdict, "softlimit");
  if (!v16) {
    return 22LL;
  }
  uint64_t v17 = v16;
  int64_t v18 = xpc_int64_get_value(v14);
  int64_t v19 = xpc_int64_get_value(v17);
  if (v19 < 0) {
    unint64_t v20 = -1LL;
  }
  else {
    unint64_t v20 = v19;
  }
  if (v18 < 0) {
    int64_t v18 = -1LL;
  }
  sub_100039E38(int64, v20, v18, 0);
  if (v10)
  {
    xpc_object_t empty = xpc_dictionary_create_empty();
    *a4 = empty;
    xpc_dictionary_set_int64(empty, "softlimit", v20);
    xpc_dictionary_set_int64(*a4, "hardlimit", v18);
    return 0LL;
  }

  else
  {
    uint64_t v4 = 0LL;
    *a4 = xpc_dictionary_create_reply(xdict);
  }

  return v4;
}

uint64_t sub_10002EFEC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_100028AF4(a1, 5LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100028BC8(a1, a2, v8, "domain print");
  }

  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = sub_100031A7C;
    v11[3] = &unk_1000649C0;
    v11[4] = a3;
    void v11[5] = a1;
    return sub_10003D10C(a3, a4, (uint64_t)v11);
  }

  return v9;
}

uint64_t sub_10002F0B0(void **a1, _OWORD *a2, void *a3)
{
  if ((sub_10000D114((uint64_t)a2, 2LL) & 1) != 0)
  {
    if (a1[13] == qword_100069750)
    {
      if (xpc_dictionary_expects_reply(a3) && (char string = xpc_dictionary_get_string(a3, "path")) != 0LL)
      {
        uint64_t v8 = string;
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000LL;
        _OWORD v11[2] = sub_100031D30;
        v11[3] = &unk_100064A00;
        v11[4] = a1;
        void v11[5] = sub_1000126A0(string);
        void v11[6] = xpc_dictionary_create_reply(a3);
        xpc_object_t value = xpc_dictionary_get_value(a3, "overlay");
        sub_100014620(a1, v8, value, a2, (uint64_t)v11);
        return 0LL;
      }

      else
      {
        return 22LL;
      }
    }

    else
    {
      return 125LL;
    }
  }

  else
  {
    uint64_t v6 = 144LL;
    sub_100028BC8((uint64_t)a1, (uint64_t)a2, 144LL, "pid-extend");
  }

  return v6;
}

uint64_t sub_10002F1D8(void **a1, uint64_t a2, void *a3)
{
  if (a1[13] != &unk_1000695B8) {
    return 125LL;
  }
  if ((sub_10000D114(a2, 2LL) & 1) == 0)
  {
    uint64_t v3 = 144LL;
    sub_100028BC8((uint64_t)a1, a2, 144LL, "extension removal");
    return v3;
  }

  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 22LL;
  }
  uint64_t v8 = (char *)string;
  memset(v30, 0, sizeof(v30));
  sub_100039990(a2, (char *)v30);
  sub_10002587C( (uint64_t)a1,  5,  "%s: caller = %s.%d, extensiouint64_t n = %s",  v9,  v10,  v11,  v12,  v13,  (char)"remove all extension instances");
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v15 = dispatch_group_create();
  dispatch_group_enter(v15);
  xpc_object_t v16 = sub_10001675C(a1, 19LL, (uint64_t)v15, (uint64_t)reply);
  uint64_t v17 = (dispatch_queue_s *)sub_100011938();
  dispatch_group_notify_f(v15, v17, v16, (dispatch_function_t)sub_100031DCC);
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  for (uint64_t i = 0LL; i != 11; ++i)
  {
    for (uint64_t j = qword_100069750[i]; j; uint64_t j = *(void *)(j + 32))
    {
      uint64_t v27 = sub_100028EF4((_DWORD *)j, v8);
      if (v27)
      {
        ++v24;
      }
    }
  }

  if (!v24)
  {
    uint64_t v28 = sub_100028EF4(a1, v8);
    if (v28)
    {
      sub_100031E4C(*((void *)v28 + 31), (uint64_t)v28, v15);
      LOBYTE(v24) = 1;
    }

    else
    {
      xpc_dictionary_set_int64(reply, "error", 3LL);
      LOBYTE(v24) = 0;
    }
  }

  sub_10002587C( (uint64_t)a1,  5,  "total of %lu extension (%s) instances were found to remove, of which %lu were removed instantly",  v18,  v19,  v20,  v21,  v22,  v24);
  dispatch_group_leave(v15);
  return 0LL;
}

uint64_t sub_10002F428(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    return 125LL;
  }
  if ((sub_10000D114(a2, 2LL) & 1) != 0)
  {
    xpc_object_t value = xpc_dictionary_get_value(a3, "names");
    if (value
      && (uint64_t v10 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
      && (xpc_object_t reply = xpc_dictionary_create_reply(a3)) != 0LL)
    {
      uint64_t v13 = reply;
      xpc_object_t v14 = xpc_array_create(0LL, 0LL);
      for (uint64_t i = 0LL; i != 11; ++i)
      {
        for (uint64_t j = qword_100069750[i]; j; uint64_t j = *(void *)(j + 32))
        {
          if (xpc_array_get_count(v10))
          {
            size_t v17 = 0LL;
            do
            {
              char string = (char *)xpc_array_get_string(v10, v17);
              if (string)
              {
                uint64_t v19 = sub_100028EF4((_DWORD *)j, string);
                if (v19)
                {
                  uint64_t v20 = (uint64_t)v19;
                  if (!*((_DWORD *)v19 + 74))
                  {
                    uint64_t v21 = sub_10001DD5C((uint64_t)v19);
                    if ((_DWORD)v21)
                    {
                      v24[0] = 0LL;
                      v24[1] = 0LL;
                      uint64_t v25 = 0LL;
                      int v22 = memorystatus_control(1LL, v21, 0LL, v24, 24LL);
                      if (v22)
                      {
                        if (v22 == 24)
                        {
                          if ((v25 & 0x4000000000LL) != 0)
                          {
                            xpc_object_t v23 = sub_10001E010(v20, 0);
                            xpc_array_set_value(v14, 0xFFFFFFFFFFFFFFFFLL, v23);
                            xpc_release(v23);
                          }
                        }

                        else
                        {
                          _os_assumes_log_ctx(sub_10001C1B0, v20);
                        }
                      }
                    }
                  }
                }
              }

              ++v17;
            }

            while (v17 < xpc_array_get_count(v10));
          }
        }
      }

      xpc_dictionary_set_value(v13, "instances", v14);
      xpc_release(v14);
      uint64_t v4 = 0LL;
      *a4 = v13;
    }

    else
    {
      return 22LL;
    }
  }

  else
  {
    uint64_t v4 = 144LL;
    sub_100028BC8(a1, a2, 144LL, "copy busy extensions");
  }

  return v4;
}

uint64_t sub_10002F644(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    return 125LL;
  }
  uint64_t v9 = sub_100028AF4(a1, 5LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v9)
  {
    uint64_t v4 = v9;
    sub_100028BC8(a1, a2, v9, "dump state");
  }

  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = sub_100031F30;
    v11[3] = &unk_100064A20;
    v11[4] = a1;
    return sub_10003D10C(a3, a4, (uint64_t)v11);
  }

  return v4;
}

uint64_t sub_10002F73C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    return 125LL;
  }
  uint64_t v9 = sub_100028AF4(a1, 5LL, 128LL, a2, 0LL, 0LL);
  if ((_DWORD)v9)
  {
    uint64_t v4 = v9;
    sub_100028BC8(a1, a2, v9, "dump jetsam property category");
  }

  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000LL;
    _OWORD v11[2] = sub_100031F38;
    v11[3] = &unk_100064A40;
    v11[4] = a1;
    return sub_10003D10C(a3, a4, (uint64_t)v11);
  }

  return v4;
}

uint64_t sub_10002F81C(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  xpc_object_t value = xpc_dictionary_get_value(a3, "properties");
  if (!value) {
    return 22LL;
  }
  uint64_t v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 22LL;
  }
  xpc_object_t v12 = xpc_dictionary_get_value(a3, "flags");
  if (!v12) {
    return 22LL;
  }
  uint64_t v13 = v12;
  char v14 = xpc_uint64_get_value(v13);
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    return 125LL;
  }
  char v15 = v14;
  uint64_t v27 = 0LL;
  uint64_t v28 = 0LL;
  uint64_t v10 = sub_100032008(v9, &v28, (uint64_t *)&v27);
  unsigned int v26 = v10;
  if (!(_DWORD)v10)
  {
    unint64_t v17 = v27;
    xpc_object_t v16 = v28;
    uint64_t v18 = sub_100032124(v28, v27, a2);
    if (v18)
    {
      sub_10002587C(v18, 5, "Domain creation failed: it already exists", v19, v20, v21, v22, v23, v25);
      return 37LL;
    }

    else
    {
      sub_100032188((uint64_t)v16, v17, 0LL, v15, a2, (int *)&v26);
      uint64_t v10 = v26;
      if (v26)
      {
        uint64_t v24 = (const char *)xpc_strerror(v26);
        sub_10003AB08(4, "Domain creation failed: %d %s", v10, v24);
      }

      else
      {
        *a4 = xpc_dictionary_create_reply(a3);
      }
    }
  }

  return v10;
}

uint64_t sub_10002F994(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if ((*(_WORD *)(a1 + 968) & 3) != 0)
  {
    uint64_t v8 = 124LL;
LABEL_6:
    sub_100028BC8(a1, a2, v8, "unpend launches");
    return v8;
  }

  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 104)
                                                                                            + 104LL))( a1,  4LL,  0LL,  *(void *)(a1 + 112),  a2,  0LL,  0LL);
  if ((_DWORD)v8) {
    goto LABEL_6;
  }
  if ((*(_WORD *)(a1 + 968) & 0x2000) == 0) {
    return 37LL;
  }
  sub_10002587C(a1, 5, "unpending launches", v9, v10, v11, v12, v13, v15);
  *(_WORD *)(a1 + 968) &= ~0x2000u;
  sub_100026360(a1);
  uint64_t v8 = 0LL;
  *a4 = xpc_dictionary_create_reply(a3);
  return v8;
}

uint64_t sub_10002FA88(void *a1, uint64_t a2, void *a3, void *a4)
{
  char string = xpc_dictionary_get_string(a3, "query");
  if (!string) {
    return 22LL;
  }
  uint64_t v9 = string;
  xpc_object_t empty = xpc_array_create_empty();
  sub_10003242C(a1, v9, empty, a2);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "services", empty);
  xpc_release(empty);
  uint64_t result = 0LL;
  *a4 = reply;
  return result;
}

uint64_t sub_10002FB34(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if ((sub_10000D114(a2, 4LL) & 1) != 0)
  {
    char string = xpc_dictionary_get_string(a3, "mount-point");
    uint64_t v9 = sub_10000B9CC(string);
    if (!(_DWORD)v9) {
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }

  else
  {
    uint64_t v9 = 144LL;
    sub_100028BC8(a1, a2, 144LL, "load-jetsam-properties");
  }

  return v9;
}

uint64_t sub_10002FBDC(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    return 125LL;
  }
  char string = xpc_dictionary_get_string(a3, "cryptex");
  if (!string) {
    return 22LL;
  }
  uint64_t v8 = string;
  uint64_t v9 = dispatch_group_create();
  dispatch_group_enter(v9);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v11 = (dispatch_queue_s *)sub_100011938();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100032554;
  block[3] = &unk_100064A60;
  block[4] = reply;
  void block[5] = a1;
  block[6] = v9;
  dispatch_group_notify(v9, v11, block);
  sub_1000325A8(a1, v8, v9, a2);
  dispatch_group_leave(v9);
  return 0LL;
}

uint64_t sub_10002FCF8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = *(_WORD *)(a1 + 968);
  if ((v8 & 4) != 0) {
    return 37LL;
  }
  if ((v8 & 3) != 0)
  {
    sub_10002587C(a1, 5, "domain shutting down, not uncorking", a4, a5, a6, a7, a8, v14);
    return 124LL;
  }

  else if ((v8 & 8) != 0 && *(void *)(a1 + 216))
  {
    sub_10002587C(a1, 5, "uncorking domain", a4, a5, a6, a7, a8, v14);
    sub_10000E638(570425364LL, *(void *)(a1 + 112));
    sub_100013F88((void *)a1, 1, 0LL, *(void **)(a1 + 216), a2, 9216LL, v12, v13);
    xpc_release(*(xpc_object_t *)(a1 + 216));
    uint64_t result = 0LL;
    *(void *)(a1 + 216) = 0LL;
    *(_WORD *)(a1 + 968) |= 4u;
  }

  else
  {
    sub_10002587C(a1, 5, "domain is not initialized, can't uncork", a4, a5, a6, a7, a8, v14);
    return 131LL;
  }

  return result;
}

xpc_object_t sub_10002FDD8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  xpc_object_t result = xpc_dictionary_create_reply(a3);
  *a4 = result;
  return result;
}

void sub_10002FE90(char *a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    size_t v16 = 0LL;
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    uint64_t v7 = sub_1000168AC(a1, string_ptr, 0LL, &v16, 0);
    if (v7)
    {
      uint64_t v15 = *(void *)(a3 + 88);
      uint64_t v14 = (char **)(a3 + 88);
      uint64_t v13 = v15;
      *(void *)uint64_t v7 = v15;
      if (v15) {
        *(void *)(v13 + 8) = v7;
      }
      *uint64_t v14 = v7;
      *((void *)v7 + 1) = v14;
    }

    else
    {
      sub_10002587C( a3,  3,  "Service attempted to %s environment variable with reserved name: %s",  v8,  v9,  v10,  v11,  v12,  (char)"set");
    }
  }

xpc_object_t sub_10002FF5C(uint64_t a1, int a2, void *a3)
{
  uint64_t v6 = sub_100010B00(0x30uLL);
  v6[4] = a2;
  xpc_object_t result = xpc_retain(a3);
  *((void *)v6 + 3) = result;
  v6[8] = 1;
  if (!a1) {
    sub_100046EB4();
  }
  uint64_t v10 = *(void *)(a1 + 176);
  uint64_t v9 = (void *)(a1 + 176);
  uint64_t v8 = v10;
  *(void *)uint64_t v6 = v10;
  if (v10) {
    *(void *)(v8 + 8) = v6;
  }
  *uint64_t v9 = v6;
  *((void *)v6 + 1) = v9;
  return result;
}

uint64_t sub_10002FFCC( uint64_t a1, char *a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v14 = sub_10001CB68(*(_DWORD *)(a7 + 20));
  if (!v14) {
    goto LABEL_5;
  }
  uint64_t v15 = v14;
  if ((sub_10001E5D4(v14) & 1) == 0)
  {
    if ((*(_BYTE *)(v15 + 369) & 0x80) != 0) {
      return 0LL;
    }
LABEL_5:
    uint64_t v68 = a1;
    if ((a4 & 2) != 0)
    {
      *(void *)&__int128 v70 = a1;
      size_t v23 = sub_1000308F8((uint64_t *)&v70, a3, 0);
      if (v23) {
        goto LABEL_13;
      }
      uint64_t v30 = sub_10001CB68(a3);
      if (!v30) {
        goto LABEL_36;
      }
      size_t v23 = v30;
      uint64_t v31 = *(void *)(v30 + 248);
      if (*(void **)(v31 + 104) != qword_100069750) {
        goto LABEL_13;
      }
      uint64_t v32 = (uint64_t *)(v31 + 80);
      do
        uint64_t v32 = (uint64_t *)*v32;
      while (v32 && *((_DWORD *)v32 + 5) != 4);
      uint64_t v69 = sub_10002C9A0(qword_10006A400, *((unsigned int *)v32 + 4));
      if (v69) {
        size_t v23 = sub_1000308F8(&v69, a3, 1);
      }
      if (v23)
      {
LABEL_13:
        uint64_t v16 = *(void *)(v23 + 168);
        if (v16)
        {
          while ((*(_BYTE *)(v16 + 88) & 0x40) != 0 || !sub_1000129FC((char *)(v16 + 168), a2))
          {
            uint64_t v16 = *(void *)(v16 + 16);
            if (!v16) {
              goto LABEL_17;
            }
          }

          goto LABEL_23;
        }

LABEL_45:
          uint64_t v16 = 0LL;
          uint64_t v28 = 159LL;
          goto LABEL_46;
        }

        if ((a4 & 0x100) != 0) {
          goto LABEL_27;
        }
        if (*(void **)(a1 + 104) == qword_100069750)
        {
        }

        else if (sub_100015988((_OWORD *)a7, (uint64_t)"mach-lookup", 1))
        {
LABEL_27:
          uint64_t v16 = sub_10002AE24(a1, a2);
          uint64_t v28 = v29;
LABEL_74:
          if ((_DWORD)v28 == 3)
          {
            uint64_t v36 = sub_1000307B4(a1, a2);
            if (v36)
            {
              unint64_t v35 = a4 & 0x100;
              goto LABEL_50;
            }
          }

LABEL_38:
          uint64_t v28 = 3LL;
          goto LABEL_46;
        }
      }
    }

    uint64_t v16 = 0LL;
    goto LABEL_38;
  }

  return 0LL;
}

xpc_object_t sub_100030594(void *a1, uint64_t a2, int a3)
{
  if (a3)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    xpc_dictionary_set_int64(reply, "error", a3);
  }

  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    uint64_t v12 = (void *)sub_10003FB6C(a2, 1, v6, v7, v8, v9, v10, v11);
    xpc_dictionary_set_value(reply, "port", v12);
  }

  return reply;
}

void sub_100030624( uint64_t a1, uint64_t a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if ((_DWORD)a7 != 145)
  {
    uint64_t v13 = (void **)sub_10000D8E8(0x100uLL);
    uint64_t v20 = v13;
    uint64_t v21 = "failed lookup";
    if ((_DWORD)a7 == 159) {
      uint64_t v21 = "denied lookup";
    }
    sub_10000D960((uint64_t)v13, "%s: mach_port_name_t name = %s, ", v14, v15, v16, v17, v18, v19, (char)v21);
    if (a4) {
      sub_10000D960((uint64_t)v20, "pid_t handle = %llu, ", v22, v23, v24, v25, v26, v27, a4);
    }
    memset(out, 0, 37);
    if ((a5 & 0x24) != 0)
    {
      uuid_unparse(a3, out);
      sub_10000D960((uint64_t)v20, "instance = %s, ", v28, v29, v30, v31, v32, v33, (char)out);
    }

    else if (!a5)
    {
LABEL_10:
      memset(v46, 0, sizeof(v46));
      char v34 = sub_100039990(a6, (char *)v46);
      xpc_strerror(a7);
      sub_10000D960((uint64_t)v20, "requestor = %s[%d], int error = %d: %s", v35, v36, v37, v38, v39, v40, v34);
      sub_10002587C(a1, 4, "%s", v41, v42, v43, v44, v45, (char)*v20);
      sub_10000D938(v20);
      return;
    }

    sub_10000D960((uint64_t)v20, "flags = 0x%llx, ", v22, v23, v24, v25, v26, v27, a5);
    goto LABEL_10;
  }

uint64_t sub_1000307B4(uint64_t a1, char *a2)
{
  if (*(void **)(a1 + 104) == qword_100069750 && (uint64_t v4 = sub_100028EF4((_DWORD *)a1, a2)) != 0LL) {
    return sub_100026C3C(a1, (uint64_t)v4);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100030804(uint64_t *a1, int a2)
{
  int v9 = a2;
  unint64_t v3 = sub_100012B1C(&v9, 4LL);
  uint64_t v4 = *a1;
  uint64_t i = *(void *)(*a1 + 8 * (v3 % 0xD) + 512);
  if (i)
  {
    while (1)
    {
      int v6 = sub_10001DD5C(i);
      int v7 = v9;
      if (v6 == v9) {
        break;
      }
      uint64_t i = *(void *)(i + 88);
      if (!i)
      {
        uint64_t v4 = *a1;
        goto LABEL_6;
      }
    }
  }

  else
  {
    int v7 = v9;
LABEL_6:
    int v10 = v7;
    for (uint64_t i = *(void *)(v4 + 8 * (sub_100012B1C(&v10, 4LL) % 7uLL) + 616); i; uint64_t i = *(void *)(i + 88))
    {
      if (*(_DWORD *)(i + 296) == v10) {
        break;
      }
    }
  }

  return i;
}

size_t sub_1000308F8(uint64_t *a1, int a2, int a3)
{
  uint64_t v6 = sub_100030804(a1, a2);
  if (v6) {
    return v6;
  }
  if (sub_10001CC20(a2))
  {
    uint64_t v6 = sub_100030804(a1, a2);
    if (v6) {
      return v6;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  if (!a3) {
    return v6;
  }
  uint64_t v8 = (void *)*a1;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v26 = 0u;
  memset(buffer, 0, sizeof(buffer));
  int v9 = sub_100039918(a2, buffer);
  if (v9)
  {
    if (v9 == 3) {
      return 0LL;
    }
    snprintf(__str, 0x80uLL, "com.apple.xpc.launchd.unmanaged.confusing.%d.%d");
  }

  else
  {
    snprintf(__str, 0x80uLL, "com.apple.xpc.launchd.unmanaged.%s.%d");
  }

  size_t v10 = strlen(__str);
  size_t v11 = v10 + 1360;
  BOOL v12 = v10 >= 0xFFFFFFFFFFFFFAB0LL;
  size_t result = v10 + 1361;
  uint64_t v13 = v11 == -1LL;
  uint64_t v14 = v13 << 63 >> 63;
  BOOL v15 = v14 != v13;
  if (!v12 && !v15 && (v14 & 0x8000000000000000LL) == 0)
  {
    uint64_t v6 = (uint64_t)sub_100010B00(result);
    size_t result = strlen(__str);
    uint64_t v16 = result == -1LL;
    uint64_t v17 = v16 << 63 >> 63;
    if (v17 == v16 && (v17 & 0x8000000000000000LL) == 0)
    {
      strlcpy((char *)(v6 + 1360), __str, result + 1);
      *(void *)(v6 + 248) = sub_1000167B0(v8);
      *(_DWORD *)(v6 + 296) = a2;
      sub_10002C2D4((unint64_t)v8, v6);
      sub_10001A4D8(v6, 5, "added unmanaged active", v18, v19, v20, v21, v22, v23);
      return v6;
    }
  }

  __break(1u);
  return result;
}

uint64_t sub_100030AC0(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, void *a5, xpc_object_t *a6, _BYTE *a7)
{
  uint64_t v95 = a1;
  size_t v14 = sub_1000308F8(&v95, *(_DWORD *)(a2 + 20), 1);
  if (v14)
  {
    uint64_t v15 = v14;
    if ((a4 & 2) == 0)
    {
      if ((a4 & 0x10) != 0)
      {
        if (*(_DWORD *)(v14 + 296))
        {
          uint64_t v24 = 45LL;
          goto LABEL_54;
        }

        uint64_t v45 = sub_10002AEC4(v14, v14, a3);
        if (!v45) {
          uint64_t v45 = sub_10002AF0C(a1, (void *)v15, a3);
        }
        uint64_t v24 = sub_10003F3D4(v45, v38, v39, v40, v41, v42, v43, v44);
        if ((_DWORD)v24) {
          goto LABEL_54;
        }
        *(_BYTE *)(v45 + 88) |= 4u;
        if (!a6) {
          goto LABEL_34;
        }
        uint64_t v52 = v45;
      }

      else
      {
        if ((*(_BYTE *)(v14 + 369) & 2) == 0) {
          goto LABEL_37;
        }
        uint64_t v16 = *(void *)(v14 + 184);
        if (!v16) {
          goto LABEL_37;
        }
        while ((*(_BYTE *)(v16 + 88) & 0x40) != 0 || !sub_1000129FC((char *)(v16 + 168), a3))
        {
          uint64_t v16 = *(void *)(v16 + 16);
          if (!v16) {
            goto LABEL_37;
          }
        }

        if (sub_10003F3D4(v16, v17, v18, v19, v20, v21, v22, v23))
        {
LABEL_37:
          uint64_t v61 = sub_10002AE24(a1, a3);
          if (v68)
          {
            if ((a4 & 1) != 0) {
              goto LABEL_39;
            }
          }

          else
          {
            uint64_t v69 = v61;
            uint64_t v70 = sub_10003F1E0(v61, 2, v62, v63, v64, v65, v66, v67);
            if (sub_10002C17C(v70))
            {
              *(_BYTE *)(v69 + 88) |= 0x40u;
              if ((a4 & 1) != 0) {
                goto LABEL_39;
              }
            }

            else if (*(void *)(v69 + 72))
            {
              sub_10002587C( a1,  3,  "Service %s tried to register for aliased endpoint: %s",  v71,  v72,  v73,  v74,  v75,  v15 + 80);
            }

            else
            {
              if ((a4 & 0x200) == 0 && ((a4 >> 8) & 1) != *(unsigned __int8 *)(v69 + 88) >> 7)
              {
                sub_10002587C( a1,  3,  "Preventing %s from registering for %s due to non-launching property mismatch",  v71,  v72,  v73,  v74,  v75,  v15 + 80);
                goto LABEL_39;
              }

              if (sub_10003FDE0(v69) == v15)
              {
                if (a5)
                {
                  sub_10002587C( a1,  3,  "Service tried to register a port for an endpoint declared in its launchd.plist(5): service = %s, endpoint = %s",  v78,  v79,  v80,  v81,  v82,  v15 + 80);
                  uint64_t v24 = 56LL;
                  goto LABEL_54;
                }

                uint64_t v87 = sub_10003F3D4(v69, v76, v77, v78, v79, v80, v81, v82);
                if ((_DWORD)v87 != 3)
                {
                  uint64_t v24 = v87;
                  if ((_DWORD)v87) {
                    goto LABEL_54;
                  }
                  *(_DWORD *)(v15 + 368) |= 0x2000u;
                  *(_BYTE *)(v69 + 88) |= 4u;
                  if (a6)
                  {
                    uint64_t v94 = (void *)sub_10003FB6C(v69, 4, v88, v89, v90, v91, v92, v93);
                    *a6 = xpc_retain(v94);
                  }

                  if (a7) {
                    *a7 = *(_BYTE *)(v69 + 88) >> 7;
                  }
                  goto LABEL_34;
                }

void sub_100030FC8(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_10002587C( a1,  4,  "failed activation: mach_port_name_t name = %s, flags = 0x%llx, requestor = %s[%d], error = %d: %s",  v8,  v9,  v10,  v11,  v12,  a2);
}

uint64_t sub_10003107C(uint64_t a1, void *a2)
{
  uint64_t result = (uint64_t)sub_10003A4FC(a1);
  if (result)
  {
    xpc_object_t array = xpc_dictionary_get_array( (xpc_object_t)result,  "com.apple.private.xpc.launchd.enable-disable-system-services");
    if (!array) {
      return 0LL;
    }
    int v5 = array;
    if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array || xpc_get_type(a2) != (xpc_type_t)&_xpc_type_array) {
      sub_10003A6F8("Given object not of required type.");
    }
    size_t count = xpc_array_get_count(v5);
    size_t v7 = xpc_array_get_count(a2);
    if (!count) {
      return 0LL;
    }
    size_t v8 = v7;
    if (!v7) {
      return 1LL;
    }
    BOOL v9 = 0;
    size_t v10 = 0LL;
LABEL_8:
    char string = xpc_array_get_string(a2, v10);
    if (string)
    {
      uint64_t v12 = string;
      char v13 = 0;
      unint64_t v14 = 1LL;
      while (1)
      {
        uint64_t v15 = xpc_array_get_string(v5, v14 - 1);
        if (!v15) {
          break;
        }
        int v16 = strcmp(v12, v15);
        v13 |= v16 == 0;
        if (v16)
        {
          if (v14++ < count) {
            continue;
          }
        }

        if ((v13 & 1) != 0)
        {
          BOOL v9 = ++v10 >= v8;
          if (v10 != v8) {
            goto LABEL_8;
          }
        }

        return v9;
      }
    }

    return v9;
  }

  return result;
}

void sub_1000311A8(void *a1, void *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  for (uint64_t i = a1[19]; i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0) {
      xpc_dictionary_set_mach_send(v4, i + 168, 0LL);
    }
  }

  for (uint64_t j = a1[20]; j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 0x40) == 0) {
      xpc_dictionary_set_mach_send(v4, j + 168, 0LL);
    }
  }

  if (xpc_dictionary_get_count(v4)) {
    xpc_dictionary_set_value(a2, "MachServices", v4);
  }
  xpc_release(v4);
  xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
  for (uint64_t k = a1[21]; k; uint64_t k = *(void *)(k + 16))
  {
    if ((*(_BYTE *)(k + 88) & 0x40) == 0) {
      xpc_dictionary_set_mach_send(v7, k + 168, 0LL);
    }
  }

  if (xpc_dictionary_get_count(v7)) {
    xpc_dictionary_set_value(a2, "PerJobMachServices", v7);
  }
  xpc_release(v7);
  xpc_object_t v9 = xpc_dictionary_create(0LL, 0LL, 0LL);
  for (uint64_t m = a1[24]; m; uint64_t m = *(void *)(m + 16))
  {
    unint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    xpc_object_t v11 = xpc_array_create(0LL, 0LL);
    sub_100019040(m, &v14, &v13);
    if (v13)
    {
      for (unint64_t n = 0LL; n < v13; ++n)
        xpc_array_set_fd(v11, 0xFFFFFFFFFFFFFFFFLL, *(_DWORD *)(v14 + 4 * n));
    }

    xpc_dictionary_set_value(v9, (const char *)(m + 208), v11);
    xpc_release(v11);
  }

  if (xpc_dictionary_get_count(v9)) {
    xpc_dictionary_set_value(a2, "Sockets", v9);
  }
  xpc_release(v9);
}

uint64_t sub_100031388(uint64_t a1, const char *a2, void *a3)
{
  if (!sub_100016B08(a2)) {
    goto LABEL_7;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v6 + 968) & 3) == 0)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void, void))(*(void *)(v6 + 104)
                                                                                               + 104LL))( v6,  4LL,  4LL,  *(void *)(v6 + 112),  v7,  0LL,  0LL);
    if ((_DWORD)v9)
    {
      uint64_t v8 = v9;
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      goto LABEL_6;
    }

void sub_100031474(uint64_t a1, char *__s, const char *a3, uint64_t a4)
{
  uint64_t v8 = (char **)(a1 + 88);
  uint64_t v9 = (void *)(a1 + 88);
  while (1)
  {
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      break;
    }
    if (sub_100016A84((uint64_t)v9, __s))
    {
      size_t v10 = (void *)*v9;
      if (*v9) {
        v10[1] = v9[1];
      }
      *(void *)v9[1] = v10;
      *uint64_t v9 = -1LL;
      v9[1] = -1LL;
      j__free(v9);
      break;
    }
  }

  if (a3)
  {
    size_t v18 = 0LL;
    uint64_t v11 = sub_1000168AC(__s, a3, a4, &v18, 0);
    if (v11)
    {
      uint64_t v17 = *v8;
      *(void *)uint64_t v11 = *v8;
      if (v17) {
        *((void *)v17 + 1) = v11;
      }
      *uint64_t v8 = v11;
      *((void *)v11 + 1) = v8;
    }

    else
    {
      sub_10002587C( a1,  3,  "Service tried to %s global environment variable with reserved name: %s",  v12,  v13,  v14,  v15,  v16,  (char)"set");
    }
  }

void sub_100031578( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  byte_10006A9E2 = 1;
  qword_10006A418 = (uint64_t)dispatch_group_create();
  dispatch_group_enter((dispatch_group_t)qword_10006A418);
  sub_1000167B0(a1);
  size_t v10 = (dispatch_group_s *)qword_10006A418;
  uint64_t v11 = (dispatch_queue_s *)sub_100011938();
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000LL;
  _OWORD v18[2] = sub_1000316CC;
  _OWORD v18[3] = &unk_100064980;
  v18[4] = a1;
  v18[5] = a2;
  dispatch_group_notify(v10, v11, v18);
  sub_10003174C((uint64_t)a1, (dispatch_group_s *)qword_10006A418, v12, v13, v14, v15, v16, v17);
  byte_10006A9B1 = 1;
  byte_10006A919 = 1;
  dispatch_group_leave((dispatch_group_t)qword_10006A418);
}

uint64_t sub_100031678(mach_port_context_t guard)
{
  if (*(_UNKNOWN **)(guard + 104) != &unk_1000695B8) {
    sub_100046EB4();
  }
  uint64_t result = *(unsigned int *)(guard + 152);
  if ((_DWORD)result)
  {
    uint64_t result = sub_10000AC84(result, 0, guard);
    if ((_DWORD)result) {
      sub_100046EF4(result);
    }
    *(_DWORD *)(guard + 152) = 0;
  }

  return result;
}

void sub_1000316CC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  sub_10002587C(v9, 5, "obliteration complete, sending reply", a4, a5, a6, a7, a8, v11);
  sub_10001685C(*(void **)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
}

void sub_10003174C( uint64_t a1, dispatch_group_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 296);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 104);
      sub_10002587C(a1, 5, "obliterating semi-active service: %s", a4, a5, a6, a7, a8, v10 + 80);
      int v12 = sub_10001DA70(v10);
      if ((v12 - 36) >= 2)
      {
        if (v12 != 89) {
          sub_100039448("inconsistency between domain and service semi-active state during obliterate");
        }
      }

      else
      {
        dispatch_group_enter(a2);
        *(_DWORD *)(v10 + 368) |= 0x4000u;
      }

      uint64_t v10 = v11;
    }

    while (v11);
  }

  for (uint64_t i = 0LL; i != 13; ++i)
  {
    for (uint64_t j = *(void *)(a1 + 8 * i + 512); j; uint64_t j = *(void *)(j + 88))
    {
      if (sub_10001DD5C(j) == dword_10006A548)
      {
        sub_10002587C(a1, 5, "skipping over obliterator: %s", v15, v16, v17, v18, v19, j + 80);
      }

      else
      {
        sub_10002587C(a1, 5, "obliterating active service: %s", v15, v16, v17, v18, v19, j + 80);
        unsigned int v20 = sub_10001DA70(j);
        if (v20 > 0x25 || ((1LL << v20) & 0x2000010001LL) == 0) {
          sub_100039448("failed to stop active service %s: %d", (const char *)(j + 1360), v20);
        }
        dispatch_group_enter(a2);
        *(_DWORD *)(j + 368) |= 0x4000u;
      }
    }
  }

  sub_10002A790(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v22);
  for (uint64_t k = *(void *)(a1 + 288); k; uint64_t k = *(void *)(k + 16))
    sub_10003174C(k, a2);
}

char *sub_1000318FC(uint64_t a1, FILE *a2)
{
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3) {
    return sub_10003194C(a2, v3);
  }
  for (uint64_t i = 0LL; i != 9; ++i)
    uint64_t result = sub_10003194C(a2, i);
  return result;
}

char *sub_10003194C(FILE *a1, int a2)
{
  rlim_t v11 = -2LL;
  rlim_t v12 = -2LL;
  sub_100039DE0(a2, &v11, &v12);
  uint64_t result = sub_10003A05C(a2);
  if (result)
  {
    uint64_t v10 = result;
    *(_OWORD *)__str = 0u;
    __int128 v16 = 0u;
    if (v12 == -1LL) {
      strcpy(__str, "unlimited");
    }
    else {
      snprintf(__str, 0x20uLL, "%lld", v12);
    }
    *(_OWORD *)uint64_t v13 = 0u;
    __int128 v14 = 0u;
    if (v11 == -1LL) {
      strcpy(v13, "unlimited");
    }
    else {
      snprintf(v13, 0x20uLL, "%lld", v11);
    }
    return (char *)sub_10003D32C(a1, 1LL, "%-12s%-15s%-15s", v5, v6, v7, v8, v9, v10, v13, __str);
  }

  return result;
}

xpc_type_t sub_100031A7C(uint64_t a1, FILE *a2)
{
  BOOL v4 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "version");
  BOOL v5 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "variant");
  BOOL v6 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "disabled");
  BOOL v7 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "cache");
  if (v4)
  {
    uint64_t v13 = off_100069A70;
LABEL_5:
    uint64_t v56 = *v13;
    __int128 v14 = "%s";
    return (xpc_type_t)sub_10003D32C(a2, 0LL, v14, v8, v9, v10, v11, v12, v56);
  }

  if (v5)
  {
    uint64_t v13 = off_100069A78;
    goto LABEL_5;
  }

  if (v7)
  {
    if (sub_1000162B8()) {
      uint64_t v21 = "system services must be in cache";
    }
    else {
      uint64_t v21 = "disk will be searched for uncached services";
    }
    sub_10003D32C(a2, 0LL, v21, v16, v17, v18, v19, v20);
    if (qword_10006A900)
    {
      sub_10003D2C0(a2, 0LL, "cached daemons = {", v22, v23, v24, v25, v26);
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 0x40000000LL;
      v57[2] = sub_100031CCC;
      v57[3] = &unk_1000649E0;
      v57[4] = a2;
      sub_10003CB60((rb_tree_t **)qword_10006A900, (uint64_t)v57);
      uint64_t v27 = "}";
    }

    else
    {
      uint64_t v27 = "(no daemon cache)";
    }

    sub_10003D32C(a2, 0LL, v27, v22, v23, v24, v25, v26);
    if (qword_10006A908)
    {
      sub_10003D3A8(a2, v29, v30, v31, v32, v33, v34, v35, (char)v56);
      sub_10003D2C0(a2, 0LL, "framework cache = ", v36, v37, v38, v39, v40);
      sub_100012BB0(a2, 0LL, 1LL, (void *)qword_10006A908, v41, v42, v43, v44);
    }

    else
    {
      sub_10003D32C(a2, 0LL, "(no framework cache)", v31, v32, v33, v34, v35);
    }

    if (qword_10006A910)
    {
      sub_10003D3A8(a2, v45, v46, v8, v9, v10, v11, v12, (char)v56);
      sub_10003D2C0(a2, 0LL, "bundle cache = ", v47, v48, v49, v50, v51);
      return sub_100012BB0(a2, 0LL, 1LL, (void *)qword_10006A910, v52, v53, v54, v55);
    }

    __int128 v14 = "(no bundle cache)";
    return (xpc_type_t)sub_10003D32C(a2, 0LL, v14, v8, v9, v10, v11, v12, v56);
  }

  uint64_t v28 = *(void *)(a1 + 40);
  if (v6) {
    return (xpc_type_t)sub_10002C8AC(v28, a2, 0LL, v8, v9, v10, v11, v12);
  }
  else {
    return (xpc_type_t)sub_100027A2C(v28, a2);
  }
}

void sub_100031CCC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D2C0(*(FILE **)(a1 + 32), 1LL, "%s => ", a4, a5, a6, a7, a8, a2);
  uint64_t v10 = (void *)sub_10003CD44(a3);
  sub_100012BB0(*(FILE **)(a1 + 32), 1LL, 0LL, v10, v11, v12, v13, v14);
  xpc_release(v10);
}

void sub_100031D30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a3 && (_DWORD)a3 != 121)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    xpc_strerror(a3);
    sub_10002587C(v4, 5, "failed to add extension %s: %d - %s", v6, v7, v8, v9, v10, v5);
  }

  xpc_release(*(xpc_object_t *)(a1 + 48));
  free(*(void **)(a1 + 40));
}

void sub_100031DCC( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *a1;
  uint64_t v9 = (dispatch_object_s *)a1[1];
  uint64_t v11 = (void *)a1[2];
  sub_10002587C(*a1, 5, "extension removal request finished, sending reply", a4, a5, a6, a7, a8, v12);
  dispatch_release(v9);
  xpc_release(v11);
  sub_100016828(a1);
}

uint64_t sub_100031E4C(uint64_t a1, uint64_t a2, dispatch_group_s *a3)
{
  uint64_t v5 = sub_1000266FC(a1, a2);
  uint64_t v6 = v5;
  if ((_DWORD)v5)
  {
    if ((_DWORD)v5 == 36)
    {
      dispatch_retain(a3);
      dispatch_group_enter(a3);
      if (*(void *)(a2 + 328))
      {
        sub_10001A4D8(a2, 5, "An extension-removal request is already in flight; chaining", v7, v8, v9, v10, v11, v20);
        char v12 = *(dispatch_group_s **)(a2 + 328);
        uint64_t v13 = (dispatch_queue_s *)sub_100011938();
        dispatch_group_notify_f(v12, v13, a3, (dispatch_function_t)sub_100031F0C);
      }

      else
      {
        *(void *)(a2 + 328) = a3;
      }
    }

    else
    {
      xpc_strerror(v5);
      sub_10001A4D8(a2, 4, "An extension-removal request failed, error: %d - %s", v14, v15, v16, v17, v18, v6);
    }
  }

  return v6;
}

void sub_100031F0C(dispatch_group_s *a1)
{
}

uint64_t sub_100031F30(uint64_t a1, FILE *a2)
{
  return sub_1000279B0(*(void *)(a1 + 32), a2);
}

uint64_t sub_100031F38( uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100031F40(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100031F40( uint64_t result, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_UNKNOWN **)(result + 104) == &unk_1000695B8)
  {
    if (qword_10006A8A8) {
      uint64_t result = sub_10003D32C(a2, 0LL, "JetsamProperties loaded from path : %s", a4, a5, a6, a7, a8, qword_10006A8A8);
    }
    else {
      uint64_t result = sub_10003D32C(a2, 0LL, "JetsamProperties not loaded", a4, a5, a6, a7, a8);
    }
  }

  for (uint64_t i = 0LL; i != 23; ++i)
  {
    for (uint64_t j = *(void *)(v9 + 8 * i + 304); j; uint64_t j = *(void *)(j + 120))
      uint64_t result = sub_100020614(j, a2, 0LL);
  }

  for (uint64_t k = *(void *)(v9 + 288); k; uint64_t k = *(void *)(k + 16))
    uint64_t result = sub_100031F40(k, a2);
  return result;
}

uint64_t sub_100032008(void *a1, void *a2, uint64_t *a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "type");
  if (!value) {
    return 22LL;
  }
  uint64_t v7 = value;
  uint64_t v9 = xpc_uint64_get_value(v7);
  xpc_object_t v10 = xpc_dictionary_get_value(a1, "handle");
  if (!v10) {
    return 22LL;
  }
  uint64_t v11 = v10;
  uint64_t v12 = xpc_uint64_get_value(v11);
  uint64_t v13 = 0LL;
  uint64_t result = 125LL;
  while (dword_1000698E8[v13] != (_DWORD)v9)
  {
    v13 += 4LL;
    if (v13 == 24) {
      return result;
    }
  }

  uint64_t v14 = *(void **)&dword_1000698E8[v13 + 2];
  if (!v14) {
    return 125LL;
  }
  if ((v9 & 0xFFFFFFFFFFFFFFFELL) == 2) {
    return 45LL;
  }
  if (v14 == &unk_100069750 && v12 == 0) {
    return 112LL;
  }
  uint64_t result = 0LL;
  *a2 = v14;
  *a3 = v12;
  return result;
}

uint64_t sub_100032124(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1 == (void *)&unk_1000697D8)
  {
    uint64_t v4 = sub_10001CB68(*(_DWORD *)(a3 + 20));
    uint64_t v5 = (uint64_t *)(v4 + 248);
    if (!v4) {
      uint64_t v5 = &qword_10006A400;
    }
    return *v5;
  }

  else if (a1 == (void *)&unk_100069860)
  {
    return qword_10006A400;
  }

  else
  {
    return sub_10002A7D4(a1, a2);
  }

char *sub_100032188(uint64_t a1, unint64_t a2, char *a3, char a4, uint64_t a5, int *a6)
{
  uint64_t v7 = *(uint64_t (**)(void, uint64_t, void, unint64_t, uint64_t, void, void))(a1 + 104);
  if (!v7)
  {
    uint64_t v13 = 0LL;
    int v14 = 112;
LABEL_8:
    *a6 = v14;
    return v13;
  }

  if ((*(_WORD *)(qword_10006A400 + 968) & 1) != 0)
  {
    uint64_t v11 = 124LL;
    goto LABEL_17;
  }

  if ((void *)a1 != qword_100069750)
  {
    if ((sub_10002CA9C(a5) & 1) != 0)
    {
      uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t, unint64_t, uint64_t, void, void))(a1 + 104))( 0LL,  1LL,  128LL,  a2,  a5,  0LL,  0LL);
      if (!(_DWORD)v11)
      {
        uint64_t v12 = sub_100012884("%s/%lu", *(const char **)(a1 + 120), a2);
        sub_100030624(qword_10006A400, (uint64_t)v12, 0LL, 0LL, 0LL, a5, 112LL);
        *a6 = 112;
        free(v12);
        return 0LL;
      }
    }

    else
    {
      uint64_t v11 = 154LL;
    }

void sub_10003242C(void *a1, const char *a2, void *a3, uint64_t a4)
{
  if (!(*(unsigned int (**)(void *, uint64_t, void, void, uint64_t, void, void))(a1[13] + 104LL))( a1,  5LL,  0LL,  a1[14],  a4,  0LL,  0LL))
  {
    for (uint64_t i = 0LL; i != 23; ++i)
    {
      for (uint64_t j = a1[i + 38]; j; uint64_t j = *(void *)(j + 120))
      {
        int v10 = strtonum(a2, 1LL, 0x7FFFFFFFLL, 0LL);
        if (v10)
        {
        }

        else if (!sub_1000129E0((const char *)(j + 1360), a2))
        {
          uint64_t v11 = (const char *)sub_10001E38C(j);
          if (!sub_1000129E0(v11, a2)) {
            continue;
          }
        }

        uint64_t v12 = sub_10001C2A0(j, 1);
        xpc_array_set_string(a3, 0xFFFFFFFFFFFFFFFFLL, v12);
        free(v12);
      }
    }

    for (uint64_t k = a1[36]; k; uint64_t k = *(void *)(k + 16))
      sub_10003242C(k, a2, a3, a4);
  }

void sub_100032554(uint64_t a1)
{
}

uint64_t sub_1000325A8(uint64_t a1, const char *a2, dispatch_group_s *a3, uint64_t a4)
{
  for (uint64_t i = 0LL; i != 13; ++i)
  {
    uint64_t v8 = *(void *)(a1 + 8 * i + 512);
    if (v8)
    {
      do
      {
        uint64_t v9 = *(void *)(v8 + 88);
        int v10 = (char *)sub_100020ABC(v8);
        if (sub_1000129FC(v10, a2))
        {
          memset(v30, 0, sizeof(v30));
          char v11 = sub_100020ABC(v8);
          sub_100039990(a4, (char *)v30);
          sub_10001A4D8(v8, 5, "Terminating with cryptex %s, caller = %s[%d]", v12, v13, v14, v15, v16, v11);
          dispatch_group_enter(a3);
          uint64_t v17 = *(dispatch_group_s **)(v8 + 336);
          if (v17)
          {
            uint64_t v18 = (dispatch_queue_s *)sub_100011938();
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000LL;
            block[2] = sub_100032798;
            block[3] = &unk_100064A80;
            block[4] = a3;
            dispatch_group_notify(v17, v18, block);
          }

          else
          {
            *(void *)(v8 + 336) = a3;
          }

          *(_DWORD *)(v8 + 368) |= 0x8000u;
          uint64_t v19 = sub_10001DA70(v8);
          char v20 = v19;
          if ((v19 - 36) > 0x35 || ((1LL << (v19 - 36)) & 0x20000000000003LL) == 0)
          {
            if ((_DWORD)v19)
            {
              xpc_strerror(v19);
              sub_10002587C(a1, 3, "Error during cryptex termination: %d - %s", v21, v22, v23, v24, v25, v20);
            }
          }
        }

        uint64_t v8 = v9;
      }

      while (v9);
    }
  }

  uint64_t result = *(void *)(a1 + 288);
  if (result)
  {
    do
    {
      uint64_t v27 = *(void *)(result + 16);
      sub_1000325A8();
      uint64_t result = v27;
    }

    while (v27);
  }

  return result;
}

void sub_100032798(uint64_t a1)
{
}

uint64_t sub_1000327A0(uint64_t a1, void *a2, void *a3)
{
  if (*(_UNKNOWN **)(a1 + 104) != &unk_1000695B8) {
    a1 = *(void *)(a1 + 200);
  }
  uint64_t v6 = *(void **)(a1 + 128);
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  xpc_dictionary_set_value(reply, "parent", v6);
  uint64_t result = 0LL;
  *a3 = reply;
  return result;
}

uint64_t sub_100032820(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 4294966992LL;
  }
  uint64_t v9 = (char *)string;
  xpc_object_t value = xpc_dictionary_get_value(a3, "port");
  if (!value) {
    return 1102LL;
  }
  char v11 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_mach_send) {
    return 1102LL;
  }
  uint int64 = xpc_dictionary_get_uint64(a3, "flags");
  uint64_t v14 = sub_100030AC0(a1, a2, v9, ((2 * (uint64 & 1)) | (uint64 >> 6) & 1) ^ 1, v11, 0LL, 0LL);
  uint64_t result = sub_100032C4C(v14);
  if (!(_DWORD)result)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    uint64_t result = 0LL;
    *a4 = reply;
  }

  return result;
}

uint64_t sub_100032910(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 4294966992LL;
  }
  uint64_t v9 = (char *)string;
  uint int64 = xpc_dictionary_get_uint64(a3, "flags");
  xpc_object_t object = 0LL;
  uint64_t v11 = sub_100030AC0(a1, a2, v9, ((2 * (uint64 & 1)) | (uint64 >> 6) & 1) ^ 1, 0LL, &object, 0LL);
  uint64_t v12 = sub_100032C4C(v11);
  if (!(_DWORD)v12)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    uint64_t right = xpc_mach_send_get_right(object);
    xpc_dictionary_set_mach_recv(reply, "port", right);
    xpc_release(object);
    *a4 = reply;
  }

  return v12;
}

uint64_t sub_100032A00(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (xpc_dictionary_get_uint64(a3, "type") != 7)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 104)
                                                                                              + 104LL))( a1,  6LL,  0LL,  *(void *)(a1 + 112),  a2,  0LL,  0LL);
    if ((_DWORD)v8)
    {
      uint64_t v9 = v8;
      sub_100028BC8(a1, a2, v8, "endpoint lookup");
      return v9;
    }
  }

  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 4294966992LL;
  }
  uint64_t v11 = (char *)string;
  unsigned int int64 = xpc_dictionary_get_int64(a3, "targetpid");
  uuid = (unsigned __int8 *)xpc_dictionary_get_uuid(a3, "instance");
  uunsigned int int64 = xpc_dictionary_get_uint64(a3, "flags");
  uint64_t v15 = sub_10002FFCC( a1,  v11,  int64,  (uint64 & 8 | (2 * (uint64 & 1)) | (uint64 >> 7) & 1 | (uint64 >> 3) & 0x64) ^ 1,  uuid,  0LL,  a2);
  uint64_t v17 = v16;
  if ((_DWORD)v16)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    unsigned int v19 = sub_100032C4C(v17);
    xpc_dictionary_set_int64(reply, "error", v19);
  }

  else
  {
    uint64_t v21 = v15;
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    uint64_t v28 = (void *)sub_10003FB6C(v21, 1, v22, v23, v24, v25, v26, v27);
    xpc_dictionary_set_value(reply, "port", v28);
  }

  uint64_t v9 = 0LL;
  *a4 = reply;
  return v9;
}

uint64_t sub_100032BF0(void *a1, void *a2)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  xpc_dictionary_set_value(reply, "rootport", *(xpc_object_t *)(qword_10006A400 + 128));
  uint64_t result = 0LL;
  *a2 = reply;
  return result;
}

uint64_t sub_100032C4C(uint64_t result)
{
  if ((int)result <= 36)
  {
    if (!(_DWORD)result) {
      return result;
    }
    if ((_DWORD)result != 1)
    {
      if ((_DWORD)result == 3) {
        return 1102LL;
      }
      return 1105LL;
    }

    return 1100LL;
  }

  if ((int)result > 144)
  {
    if ((_DWORD)result != 159)
    {
      if ((_DWORD)result == 145) {
        return 1102LL;
      }
      return 1105LL;
    }

    return 1100LL;
  }

  if ((_DWORD)result != 37)
  {
    if ((_DWORD)result == 56) {
      return 1101LL;
    }
    return 1105LL;
  }

  return 1103LL;
}

uint64_t sub_100032CB8(mach_port_context_t a1, uint64_t a2, char *__s1, void *a4, xpc_object_t *a5)
{
  if (!strcmp(__s1, "SubmitJob"))
  {
    if (!a4
      || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_dictionary && xpc_get_type(a4) != (xpc_type_t)&_xpc_type_array)
    {
      return 22LL;
    }

    if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_array)
    {
      *a5 = xpc_array_create(0LL, 0LL);
      if (xpc_array_get_count(a4))
      {
        size_t v42 = 0LL;
        do
        {
          xpc_object_t value = xpc_array_get_value(a4, v42);
          int v44 = sub_100033A8C((_DWORD *)a1, a2, value, 0LL);
          xpc_array_set_uint64(*a5, 0xFFFFFFFFFFFFFFFFLL, v44);
          ++v42;
        }

        while (v42 < xpc_array_get_count(a4));
      }

      return 0LL;
    }

    *(void *)uint64_t v92 = 0LL;
    uint64_t v21 = sub_100033A8C((_DWORD *)a1, a2, a4, v92);
    if (!(_DWORD)v21)
    {
      uint64_t v22 = *(void *)v92;
      if (!*(void *)v92) {
        goto LABEL_71;
      }
      int v23 = *(_DWORD *)(*(void *)v92 + 368LL);
      if ((v23 & 8) == 0) {
        goto LABEL_71;
      }
      *(_DWORD *)(*(void *)v92 + 368LL) = v23 & 0xFFFFFFF7;
      *(void *)(a1 + 944) = v22;
      return 36LL;
    }

    return v21;
  }

  if (!strcmp(__s1, "RemoveJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22LL;
    }
    int64_t string_ptr = (char *)xpc_string_get_string_ptr(a4);
    uint64_t v25 = sub_100028EF4((_DWORD *)a1, string_ptr);
    if (!v25) {
      return 3LL;
    }
    uint64_t v26 = (uint64_t)v25;
    uint64_t v21 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
    if (!(_DWORD)v21)
    {
      uint64_t v21 = sub_10001C0CC();
      if (!(_DWORD)v21)
      {
        bzero(v92, 0x400uLL);
        sub_10002CAE0(*(_DWORD *)(a2 + 20), v92);
        sub_10001A4D8(v26, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v79, v80, v81, v82, v83, (char)"legacy-remove service");
        uint64_t v84 = sub_1000266FC(a1, v26);
        uint64_t v21 = v84;
        if ((_DWORD)v84)
        {
          if ((_DWORD)v84 != 36)
          {
            xpc_strerror(v84);
            sub_10001A4D8( v26,  3,  "Could not stop service: mach_port_name_t name = %s, error = %d: %s",  v85,  v86,  v87,  v88,  v89,  (char)string_ptr);
          }

          return v21;
        }

LABEL_79:
        xpc_object_t v67 = xpc_uint64_create(0LL);
        goto LABEL_72;
      }
    }

    sub_100028BC8(a1, a2, v21, "service removal (%s)");
    return v21;
  }

  if (!strcmp(__s1, "StartJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22LL;
    }
    uint64_t v27 = (char *)xpc_string_get_string_ptr(a4);
    uint64_t v28 = sub_100028EF4((_DWORD *)a1, v27);
    if (!v28) {
      return 3LL;
    }
    uint64_t v29 = (uint64_t)v28;
    uint64_t v30 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
    if ((_DWORD)v30)
    {
      uint64_t v21 = v30;
      sub_100028BC8(a1, a2, v30, "service start (%s)");
      return v21;
    }

    uint64_t v66 = sub_10001D3D8(v29, 9LL, v31, v32, v33, v34, v35, v36);
    uint64_t v21 = v66;
LABEL_71:
    xpc_object_t v67 = xpc_uint64_create(0LL);
    uint64_t v21 = 0LL;
LABEL_72:
    *a5 = v67;
    return v21;
  }

  if (!strcmp(__s1, "StopJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22LL;
    }
    uint64_t v37 = (char *)xpc_string_get_string_ptr(a4);
    uint64_t v38 = sub_100028EF4((_DWORD *)a1, v37);
    if (v38)
    {
      uint64_t v39 = (uint64_t)v38;
      uint64_t v40 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
      if ((_DWORD)v40)
      {
        uint64_t v21 = v40;
        sub_100028BC8(a1, a2, v40, "service stop (%s)");
        return v21;
      }

      bzero(v92, 0x400uLL);
      sub_10002CAE0(*(_DWORD *)(a2 + 20), v92);
      sub_10001A4D8(v39, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v68, v69, v70, v71, v72, (char)"legacy-stop service");
      uint64_t v21 = sub_10001D4CC(v39, a2, v73, v74, v75, v76, v77, v78);
      if ((_DWORD)v21) {
        return v21;
      }
      goto LABEL_79;
    }

    return 3LL;
  }

  if (!strcmp(__s1, "GetJob"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v48 = (char *)xpc_string_get_string_ptr(a4);
      uint64_t v46 = (_DWORD *)a1;
      uint64_t v47 = a2;
      uint64_t v49 = 0LL;
      return sub_100033548(v46, v47, v48, v49, a5, v10, v11, v12);
    }

    return 22LL;
  }

  if (!strcmp(__s1, "GetJobs"))
  {
    uint64_t v45 = sub_100028AF4(a1, 5LL, 128LL, a2, 0LL, 0LL);
    if ((_DWORD)v45)
    {
      uint64_t v21 = v45;
      sub_100028BC8(a1, a2, v45, "all services read");
    }

    else
    {
      xpc_object_t v54 = xpc_dictionary_create(0LL, 0LL, 0LL);
      for (uint64_t i = 0LL; i != 23; ++i)
      {
        for (uint64_t j = *(void *)(a1 + 8 * i + 304); j; uint64_t j = *(void *)(j + 120))
        {
          xpc_object_t v57 = sub_10001DD94(j);
          uint64_t v58 = (const char *)(j + 1360);
          if (v57)
          {
            uint64_t v59 = v57;
            xpc_dictionary_set_value(v54, v58, v57);
            xpc_release(v59);
          }

          else
          {
            xpc_dictionary_set_uint64(v54, v58, 0x99uLL);
          }
        }
      }

      uint64_t v21 = 0LL;
      *a5 = v54;
    }

    return v21;
  }

  if (!strcmp(__s1, "CheckIn"))
  {
    uint64_t v46 = (_DWORD *)a1;
    uint64_t v47 = a2;
    uint64_t v48 = 0LL;
    uint64_t v49 = 1LL;
    return sub_100033548(v46, v47, v48, v49, a5, v10, v11, v12);
  }

  if (!strcmp(__s1, "SetUserEnvironment"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary) {
      return sub_1000336F4(a1, a2, (uint64_t)a4, a5, v50, v51, v52, v53);
    }
    return 22LL;
  }

  if (!strcmp(__s1, "UnsetUserEnvironment"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v60 = (char *)xpc_string_get_string_ptr(a4);
      return sub_1000337B8(a1, a2, v60, v61, v62, v63, v64, v65);
    }

    return 22LL;
  }

  if (!strcmp(__s1, "Shutdown")) {
    return sub_100033864(a1, a2, a5);
  }
  if (!strcmp(__s1, "SingleUser"))
  {
    uint64_t v90 = "LAUNCH_KEY_SINGLEUSER never did anything anyway.";
    goto LABEL_82;
  }

  if (!strcmp(__s1, "GetResourceLimits") || !strcmp(__s1, "SetResourceLimits"))
  {
    uint64_t v90 = "rlimit(3)? Really?";
LABEL_82:
    sub_10002587C(a1, 5, v90, v13, v14, v15, v16, v17, v91);
    return 126LL;
  }

  if (!strcmp(__s1, "GetResourceUsageSelf"))
  {
    uint64_t v18 = a1;
    uint64_t v19 = a2;
    int v20 = 0;
    return sub_1000339B0(v18, v19, v20, a5);
  }

  if (strcmp(__s1, "GetResourceUsageChildren")) {
    return 22LL;
  }
  uint64_t v18 = a1;
  uint64_t v19 = a2;
  int v20 = -1;
  return sub_1000339B0(v18, v19, v20, a5);
}

void sub_1000334E8(char *__s1, void *a2, mach_port_context_t *a3)
{
  mach_port_context_t v6 = *a3;
  uint64_t v7 = a3[1];
  xpc_object_t v10 = 0LL;
  int v8 = sub_100032CB8(v6, v7, __s1, a2, &v10);
  if (v8) {
    xpc_object_t v10 = xpc_uint64_create(v8);
  }
  uint64_t v9 = (void *)a3[2];
  if (v9) {
    xpc_release(v9);
  }
  a3[2] = (mach_port_context_t)v10;
}

uint64_t sub_100033548( _DWORD *a1, uint64_t a2, char *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = a4;
  uint64_t v24 = a1;
  if (!a3 || !(_DWORD)a4)
  {
    if (a3) {
      uint64_t v13 = (uint64_t)sub_100028EF4(a1, a3);
    }
    else {
      uint64_t v13 = sub_1000308F8((uint64_t *)&v24, *(_DWORD *)(a2 + 20), 0);
    }
    uint64_t v14 = (void *)v13;
    if (!v13 || *(_DWORD *)(v13 + 296)) {
      return 3LL;
    }
    if ((v9 & 1) != 0)
    {
      if (sub_10001DD5C(v13) != *(_DWORD *)(a2 + 20))
      {
        memset(v25, 0, sizeof(v25));
        char v18 = sub_100039990(a2, (char *)v25);
        sub_10002587C( (uint64_t)a1,  3,  "Unprivileged caller tried to check into job's endpoints: caller = %s.%d, owner = %s",  v19,  v20,  v21,  v22,  v23,  v18);
        return 1LL;
      }

      xpc_object_t v16 = sub_10001DD94((uint64_t)v14);
      sub_100033D30((uint64_t)a1, (uint64_t)v14, v16, 1);
    }

    else
    {
      uint64_t v17 = sub_100028AF4((uint64_t)a1, 5LL, 8LL, a2, 0LL, 0LL);
      if ((_DWORD)v17)
      {
        uint64_t v12 = v17;
        sub_100028BC8((uint64_t)a1, a2, v17, "service read");
        return v12;
      }

      sub_10001DD5C((uint64_t)v14);
      xpc_object_t v16 = sub_10001DD94((uint64_t)v14);
      sub_1000311A8(v14, v16);
    }

    uint64_t v12 = 0LL;
    *a5 = v16;
    return v12;
  }

  sub_10002587C((uint64_t)a1, 3, "Caller tried to check into a named job: %s", a4, (uint64_t)a5, a6, a7, a8, (char)a3);
  return 1LL;
}

uint64_t sub_1000336F4( uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(*(void *)(a1 + 104) + 128LL) & 2) != 0)
  {
    uint64_t v9 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
    if ((_DWORD)v9)
    {
      sub_100028BC8(a1, a2, v9, "set domain environment");
    }

    else
    {
      *a4 = xpc_uint64_create(0LL);
      xpc_dictionary_apply_f(a3);
    }
  }

  else
  {
    sub_10002587C( a1,  3,  "LAUNCH_KEY_SETUSERENVIRONMENT is only valid for user domains.",  (uint64_t)a4,  a5,  a6,  a7,  a8,  v14);
    return 125LL;
  }

  return v9;
}

uint64_t sub_1000337B8( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(*(void *)(a1 + 104) + 128LL) & 2) != 0)
  {
    sub_10002587C(a1, 3, "LAUNCH_KEY_UNSETUSERENVIRONMENT is only valid for user domains.", a4, a5, a6, a7, a8, v13);
    return 125LL;
  }

  else
  {
    uint64_t v11 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
    if ((_DWORD)v11) {
      sub_100028BC8(a1, a2, v11, "unset domain environment");
    }
    else {
      sub_100031474(a1, a3, 0LL, 0LL);
    }
  }

  return v11;
}

uint64_t sub_100033864(mach_port_context_t a1, uint64_t a2, xpc_object_t *a3)
{
  uint64_t v6 = sub_100028AF4(a1, 4LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    sub_100028BC8(a1, a2, v6, "domain shutdown");
  }

  else if ((*(_WORD *)(a1 + 968) & 3) != 0)
  {
    return 37LL;
  }

  else
  {
    bzero(v19, 0x400uLL);
    sub_10002CAE0(*(_DWORD *)(a2 + 20), v19);
    sub_10002587C(a1, 196613, "legacy shutdown initiated by: %s", v8, v9, v10, v11, v12, (char)v19);
    sub_10002587C(a1, 5, "legacy shutdown, caller = %s", v13, v14, v15, v16, v17, (char)v19);
    uint64_t v7 = sub_10000AC84(*(_DWORD *)(a1 + 152), -1, a1);
    if ((_DWORD)v7)
    {
      _os_assumes_log_ctx(sub_100025848, a1);
    }

    else
    {
      *(_DWORD *)(a1 + 152) = 0;
      *a3 = xpc_uint64_create(0LL);
    }
  }

  return v7;
}

uint64_t sub_1000339B0(uint64_t a1, uint64_t a2, int a3, xpc_object_t *a4)
{
  uint64_t v8 = sub_100028AF4(a1, 5LL, 8LL, a2, 0LL, 0LL);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100028BC8(a1, a2, v8, "read resource usage");
  }

  else
  {
    memset(&v12, 0, sizeof(v12));
    int v10 = getrusage(a3, &v12);
    if (v10)
    {
      if (v10 == -1) {
        sub_1000477BC(a1);
      }
      return *__error();
    }

    else
    {
      uint64_t v9 = 0LL;
      *a4 = xpc_data_create(&v12, 0x90uLL);
    }
  }

  return v9;
}

uint64_t sub_100033A8C(_DWORD *a1, uint64_t a2, xpc_object_t object, void *a4)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unsigned int v15 = sub_100028AF4((uint64_t)a1, 3LL, 8LL, a2, 0LL, 0LL);
    unsigned int v32 = v15;
    if (v15)
    {
      uint64_t v16 = 0LL;
      uint64_t v17 = v15;
    }

    else
    {
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      *(_OWORD *)__str = 0u;
      __int128 v35 = 0u;
      memset(v33, 0, sizeof(v33));
      uint64_t v24 = sub_100039990(a2, (char *)v33);
      snprintf(__str, 0x80uLL, "(submitted by %s[%d])", v24, *(_DWORD *)(a2 + 20));
      v31[0] = sub_100026D10;
      v31[1] = sub_1000270F8;
      v31[2] = sub_10002723C;
      v31[3] = sub_1000273D4;
      _OWORD v31[4] = sub_10002742C;
      v31[5] = sub_100027520;
      v31[6] = a1;
      else {
        unint64_t v25 = 512LL;
      }
      uint64_t v26 = (void *)sub_100003668(a1, object, __str, a2, (uint64_t)v31, v25, (int *)&v32);
      if (v26)
      {
        uint64_t v16 = v26;
        sub_1000167B0(v26);
        sub_1000265C0(a1, (uint64_t)v16);
        uint64_t v30 = v16[169];
        sub_10001685C(v16);
        if ((v30 & 0x10000000) != 0)
        {
          uint64_t v16 = 0LL;
          uint64_t v17 = 124LL;
        }

        else
        {
          uint64_t v17 = 0LL;
        }
      }

      else
      {
        uint64_t v17 = v32;
        if (!v32) {
          sub_100046E9C(0LL, v27, v28, v29);
        }
        uint64_t v16 = 0LL;
      }
    }

    uint64_t result = 0LL;
    if ((_DWORD)v17)
    {
      if ((_DWORD)v17 != 17 && (_DWORD)v17 != 37)
      {
        xpc_dictionary_get_string(object, "Label");
        __int128 v36 = 0u;
        __int128 v37 = 0u;
        *(_OWORD *)__str = 0u;
        __int128 v35 = 0u;
        char v18 = sub_100039990(a2, __str);
        xpc_strerror(v17);
        sub_10002587C( (uint64_t)a1,  3,  "Could not import service from caller: caller = %s[%d], service = %s, int error = %d: %s",  v19,  v20,  v21,  v22,  v23,  v18);
        return v17;
      }
    }

    else if (a4)
    {
      *a4 = v16;
    }
  }

  else
  {
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    *(_OWORD *)__str = 0u;
    __int128 v35 = 0u;
    char v8 = sub_100039990(a2, __str);
    sub_10002587C( (uint64_t)a1,  3,  "Could not import service from caller: caller = %s[%d], job is not a dictionary",  v9,  v10,  v11,  v12,  v13,  v8);
    return 22LL;
  }

  return result;
}

void sub_100033D30(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  xpc_object_t v8 = xpc_dictionary_create(0LL, 0LL, 0LL);
  for (uint64_t i = *(void *)(a2 + 192); i; uint64_t i = *(void *)(i + 16))
  {
    xpc_object_t value = xpc_dictionary_get_value(v8, (const char *)(i + 208));
    if (value)
    {
      xpc_object_t v11 = xpc_retain(value);
    }

    else
    {
      xpc_object_t v11 = xpc_array_create(0LL, 0LL);
      xpc_dictionary_set_value(v8, (const char *)(i + 208), v11);
    }

    *(void *)&__int128 v34 = 0LL;
    xpc_object_t object = 0LL;
    uint64_t v12 = sub_100018F94(i, &v34, 0LL, &object);
    if ((_DWORD)v12)
    {
      xpc_strerror(v12);
      sub_10001A4D8(a2, 3, "Could not activate socket group: %s: %d: %s", v13, v14, v15, v16, v17, i - 48);
    }

    else if (object)
    {
    }

    xpc_release(v11);
  }

  xpc_dictionary_set_value(a3, "Sockets", v8);
  xpc_release(v8);
  if (a4)
  {
    xpc_object_t v24 = xpc_dictionary_create(0LL, 0LL, 0LL);
    if ((*(_BYTE *)(a2 + 369) & 2) != 0) {
      sub_10001A4D8( a2,  4,  "The launch(3) APIs cannot be used to check in MultipleInstance endpoints.",  v19,  v20,  v21,  v22,  v23,  v33);
    }
    for (uint64_t k = *(void *)(a2 + 152); k; uint64_t k = *(void *)(k + 16))
    {
      xpc_object_t object = 0LL;
      *(void *)&__int128 v26 = -1LL;
      *((void *)&v26 + 1) = -1LL;
      __int128 v34 = v26;
      __int128 v35 = v26;
      DWORD1(v35) = 0;
      DWORD1(v35) = sub_10001DD5C(a2);
      if (sub_100030AC0(a1, (uint64_t)&v34, (char *)(k + 168), 0LL, 0LL, &object, 0LL))
      {
        sub_10001A4D8( a2,  3,  "Failed to activate endpoint for legacy check-in. Please just don't use this API: %s",  v27,  v28,  v29,  v30,  v31,  k - 88);
      }

      else
      {
        sub_10001A4D8( a2,  4,  "Endpoint has been activated through legacy launch(3) APIs. Please switch to XPC or bootstrap_check_in(): %s",  v27,  v28,  v29,  v30,  v31,  k - 88);
        uint64_t right = xpc_mach_send_get_right(object);
        xpc_dictionary_set_mach_recv(v24, k + 168, right);
        xpc_release(object);
      }
    }

    xpc_dictionary_set_value(a3, "MachServices", v24);
    xpc_release(v24);
  }

void sub_100033F80(char *a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    sub_100031474(a3, a1, string_ptr, 0LL);
  }

void sub_100033FEC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(_DWORD *)(a1 + 152) = a2;
  uintptr_t v11 = a2;
  uint64_t v12 = (dispatch_queue_s *)sub_100011938();
  *(void *)(a1 + 144) = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_mach_send,  v11,  1uLL,  v12);
  sub_100016C50(a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 144), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 144), (dispatch_function_t)sub_100025D60);
  dispatch_source_set_mandatory_cancel_handler_f(*(void *)(a1 + 144), sub_10003416C);
  dispatch_activate(*(dispatch_object_t *)(a1 + 144));
  if (*(void **)(a1 + 104) == qword_100069750)
  {
    uintptr_t v20 = *(void *)(a1 + 112);
    uint64_t v21 = (dispatch_queue_s *)sub_100011938();
    *(void *)(a1 + 136) = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_proc,  v20,  0x20000000uLL,  v21);
    sub_100016C50(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 136), (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 136), (dispatch_function_t)sub_1000341B0);
    uint64_t v22 = sub_10001CB68(*(_DWORD *)(a1 + 112));
    if (v22 && !sub_10001E55C(v22))
    {
      sub_10002587C(a1, 5, "deferring exec source uncork", v23, v24, v25, v26, v27, v28);
      *(_WORD *)(a1 + 968) |= 0x200u;
    }

    else
    {
      sub_10002587C(a1, 5, "uncorking exec source upfront", v23, v24, v25, v26, v27, v28);
      dispatch_activate(*(dispatch_object_t *)(a1 + 136));
    }
  }

void sub_10003416C(dispatch_source_s *a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(a1);
  if (handle - 1 <= 0xFFFFFFFD)
  {
    int v3 = sub_10000AC70(handle);
    if (v3) {
      _os_assumes_log(v3);
    }
  }

  dispatch_release(a1);
}

void sub_1000341B0( unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_WORD *)(a1 + 968) |= 0x80u;
  sub_100025D60(a1, v9, v10, v11, v12, v13, v14, v15);
}

char *sub_1000341EC()
{
  return sub_1000258E0(v0, 1);
}

char *sub_1000341F8(uint64_t a1, uint64_t a2)
{
  return sub_10001C2A0(a2, 1);
}

char *sub_100034210(uint64_t a1)
{
  return sub_10001C2A0(a1, 1);
}

char *sub_100034228(uint64_t a1)
{
  return sub_10001C2A0(a1, 1);
}

void sub_100034238()
{
  qword_10006A550 = 0LL;
  qword_10006A558 = 0LL;
}

uint64_t sub_10003424C(void *a1)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  if (!reply) {
    sub_100046EC8();
  }
  uint64_t v3 = (uint64_t)reply;
  os_unfair_lock_lock_with_options(&unk_10006A560, 0x10000LL);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A560);
  return v3;
}

void sub_1000342B0(uint64_t a1)
{
  qword_10006A550 = a1;
  qword_10006A558 = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A560);
}

uint64_t sub_1000342FC(uint64_t a1, dispatch_queue_s *a2, void *a3)
{
  if (qword_10006A558) {
    BOOL v6 = qword_10006A558 == a1;
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v7 = v6;
  if (v6)
  {
    os_unfair_lock_assert_owner((os_unfair_lock_t)&unk_10006A560);
    qword_10006A550 = 0LL;
    qword_10006A558 = 0LL;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A560);
    xpc_dictionary_handoff_reply(a1, a2, a3);
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A560);
    dispatch_async(a2, a3);
  }

  return v7;
}

uint64_t sub_1000343B8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = *a3;
  int v4 = kpersona_find_by_type(a1, a2, &v10);
  if (v4 < 0)
  {
    int v6 = v4;
    int v7 = *__error();
    xpc_object_t v8 = __error();
    uint64_t v9 = strerror(*v8);
    sub_10003AB08(4, "kpersona_find_by_type() failed with ret %d errno %d - %s", v6, v7, v9);
    *a3 = 0LL;
    return *__error();
  }

  else
  {
    uint64_t result = 0LL;
    *a3 = v10;
  }

  return result;
}

_DWORD *sub_100034444()
{
  return sub_10003DF50(11, (uint64_t)sub_100034454);
}

uint64_t sub_100034454(uint64_t a1, int a2, void *a3, void *a4)
{
  int v7 = sub_10003DF34();
  int v8 = *((_DWORD *)v7 + 5);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v16 = 0u;
  memset(buffer, 0, sizeof(buffer));
  uint64_t result = sub_100039954(v8, buffer);
  if (!(_DWORD)result)
  {
    uint64_t v14 = 0LL;
    uint64_t result = sub_10003775C(v8, &v14);
    if ((_DWORD)result)
    {
      if (v14) {
        sub_100046EC8();
      }
    }

    else if (*((void *)&v16 + 1) == *(void *)(*(void *)v14 + 1120LL))
    {
      if (a2 == 1200)
      {
        uint64_t v10 = *(void *)v14;
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_object_t v12 = reply;
        uint64_t v13 = *(void **)(v10 + 640);
        if (v13) {
          xpc_dictionary_set_value(reply, "additional-properties", v13);
        }
        uint64_t result = 0LL;
        *a4 = v12;
      }

      else
      {
        return 33LL;
      }
    }

    else
    {
      return 113LL;
    }
  }

  return result;
}

FILE *sub_10003458C(const char *a1)
{
  if (byte_10006A99B) {
    return 0LL;
  }
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/launchd.log", a1);
  if (!access(__str, 0))
  {
    bzero(v9, 0x400uLL);
    snprintf(v9, 0x400uLL, "%s/launchd.log.1", a1);
    if (!access(v9, 0))
    {
      bzero(v8, 0x400uLL);
      snprintf(v8, 0x400uLL, "%s/launchd.log.2", a1);
      renamex_np(v9, v8, 0x10u);
    }

    renamex_np(__str, v9, 0x10u);
  }

  int v4 = open(__str, 536872449, 438LL);
  if (v4 < 0)
  {
    int v6 = __error();
    sub_10000D024("launchd.log: open(%s): %d\n", __str, *v6);
    return 0LL;
  }

  uint64_t v5 = fdopen(v4, "w");
  uint64_t v1 = v5;
  if (v5)
  {
    setvbuf(v5, 0LL, 0, 0x4000uLL);
  }

  else
  {
    int v7 = __error();
    sub_10000D024("launchd.log: fdopen(%s): %d\n", __str, *v7);
  }

  return v1;
}

uint64_t *sub_100034728(void *a1, _BYTE *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v7 = 0LL;
    __int128 v8 = 0uLL;
    uint64_t v21 = 0LL;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2000000000LL;
    char v24 = 0;
    uint64_t v17 = 0LL;
    __int128 v18 = &v17;
    uint64_t v19 = 0x2000000000LL;
    char v20 = 0;
    applier = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = sub_1000349C8;
    xpc_object_t v12 = &unk_100064AC8;
    uint64_t v15 = a2;
    __int128 v16 = &v7;
    uint64_t v13 = &v21;
    uint64_t v14 = &v17;
    xpc_dictionary_apply(a1, &applier);
    if (*((_BYTE *)v22 + 24))
    {
      if (*((_BYTE *)v18 + 24))
      {
        sub_100011A84(a2, 3LL, "Found unsupported directives");
      }

      else if ((_BYTE)v7)
      {
        if (v8 != 0)
        {
          _Block_object_dispose(&v17, 8);
          _Block_object_dispose(&v21, 8);
          if (BYTE1(v7)) {
            int v6 = (__int128 *)((char *)&v8 + 8);
          }
          else {
            int v6 = &v8;
          }
          if (*(void *)v6) {
            return (uint64_t *)sub_100034728(*(void *)v6, a2);
          }
          else {
            return 0LL;
          }
        }

        sub_100011A84(a2, 3LL, "Either %s or %s must be present");
      }

      else
      {
        sub_100011A84(a2, 3LL, "Missing conditions");
      }
    }

    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
    xpc_object_t empty = (uint64_t *)xpc_dictionary_create_empty();
    applier = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = sub_100034970;
    xpc_object_t v12 = &unk_100064AA0;
    uint64_t v13 = (uint64_t *)a2;
    uint64_t v14 = empty;
    xpc_dictionary_apply(a1, &applier);
  }

  else
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array) {
      return (uint64_t *)xpc_copy(a1);
    }
    xpc_object_t empty = (uint64_t *)xpc_array_create_empty();
    applier = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000LL;
    uint64_t v11 = sub_100034B7C;
    xpc_object_t v12 = &unk_100064AE8;
    uint64_t v13 = (uint64_t *)a2;
    uint64_t v14 = empty;
    xpc_array_apply(a1, &applier);
  }

  return empty;
}

uint64_t sub_100034970(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v5 = (void *)sub_100034728(a3, *(void *)(a1 + 32));
  if (v5)
  {
    int v6 = v5;
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 40), a2, v5);
    xpc_release(v6);
  }

  return 1LL;
}

uint64_t sub_1000349C8(void *a1, char *__s1, void *a3)
{
  int v6 = (_BYTE *)a1[6];
  uint64_t v7 = a1[7];
  BOOL v8 = sub_1000129FC(__s1, "#IfFeatureFlagEnabled");
  BOOL v9 = sub_1000129FC(__s1, "#IfFeatureFlagDisabled");
  if (v8 || v9)
  {
    if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string)
    {
      int64_t string_ptr = xpc_string_get_string_ptr(a3);
      uint64_t v14 = strchr(string_ptr, 47);
      if (v14)
      {
        uint64_t v15 = v14;
        __int128 v16 = v14 + 1;
        if (!strchr(v14 + 1, 47))
        {
          uint64_t v17 = sub_1000126F4(string_ptr, v15 - string_ptr);
          char v18 = j___os_feature_enabled_impl(v17, v16);
          free(v17);
          *(_BYTE *)(v7 + 1) |= v8 ^ v18;
          char v11 = 1;
          *(_BYTE *)uint64_t v7 = 1;
          goto LABEL_12;
        }

        sub_100011A84(v6, 3LL, "Feature flag string must not have multiple '/' separators: %s");
      }

      else
      {
        sub_100011A84(v6, 3LL, "Feature flag string must have domain/feature format: %s");
      }
    }

    else
    {
      xpc_type_t type = xpc_get_type(a3);
      xpc_type_get_name(type);
      sub_100011A84(v6, 3LL, "Expected string for a feature flag, got %s");
    }

    goto LABEL_11;
  }

  if (!sub_1000129FC(__s1, "#Then"))
  {
    if (sub_1000129FC(__s1, "#Else"))
    {
      *(void *)(v7 + 16) = a3;
      goto LABEL_10;
    }

uint64_t sub_100034B7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = (void *)sub_100034728(a3, *(void *)(a1 + 32));
  if (v4)
  {
    uint64_t v5 = v4;
    xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v4);
    xpc_release(v5);
  }

  return 1LL;
}

void sub_100034BC4(uint64_t a1)
{
  if (*(void *)(a1 + 16) != -1LL || *(void *)(a1 + 24) != -1LL) {
    sub_100046EB4();
  }
  if (*(void *)(a1 + 48)) {
    sub_100046EB4();
  }
  sub_10001685C(*(void **)(a1 + 40));
}

void sub_100034C0C(void *a1)
{
  if (a1[5]) {
    sub_100046EB4();
  }
  if (sub_10003CBDC(a1[4])) {
    sub_100046EB4();
  }
  if (sub_10003CBDC(a1[7])) {
    sub_100046EB4();
  }
  if (a1[6])
  {
    uint64_t v2 = a1[2];
    if (v2) {
      *(void *)(v2 + 24) = a1[3];
    }
    *(void *)a1[3] = v2;
    a1[2] = -1LL;
    a1[3] = -1LL;
  }

  sub_10001685C((void *)a1[4]);
  sub_10001685C((void *)a1[7]);
}

uint64_t sub_100034CA4(uint64_t result)
{
  if (*(void *)(result + 16)) {
    sub_100046EB4();
  }
  return result;
}

void sub_100034CC0(uint64_t a1)
{
  if (*(void *)(a1 + 16) != -1LL || *(void *)(a1 + 24) != -1LL) {
    sub_100046EB4();
  }
  if (*(void *)(a1 + 32) != -1LL || *(void *)(a1 + 40) != -1LL) {
    sub_100046EB4();
  }
  xpc_release(*(xpc_object_t *)(a1 + 56));
}

_DWORD *sub_100034D0C()
{
  return sub_10003DF50(4, (uint64_t)sub_100034D1C);
}

uint64_t sub_100034D1C(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7 = sub_10003DF34();
  int v8 = a2 - 400;
  uint64_t v9 = (uint64_t)v7;
  uint64_t v10 = 45LL;
  switch(v8)
  {
    case 0:
      uint64_t v101 = 0LL;
      uint64_t v10 = sub_100035FF8(a3, 0LL, *(_DWORD *)(v9 + 20), 1, &v101);
      if (!(_DWORD)v10)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        *a4 = reply;
        if (v101) {
          uint64_t v12 = *(void *)(v101 + 72);
        }
        else {
          uint64_t v12 = 0LL;
        }
        xpc_dictionary_set_uint64(reply, "token", v12);
        return 0LL;
      }

      return v10;
    case 1:
      int v13 = *((_DWORD *)v7 + 5);
      uint64_t v14 = a3;
      uint64_t v15 = a4;
      return sub_100036248(v14, v15, v13);
    case 2:
      uint64_t v17 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v17) {
        return 1LL;
      }
      uint64_t v18 = v17;
      char string = xpc_dictionary_get_string(a3, "stream");
      uint int64 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22LL;
      if (!string) {
        return v10;
      }
      uint64_t v21 = uint64;
      uint64_t v22 = *(void *)(v18 + 144);
      if (!v22) {
        return 3LL;
      }
      while (1)
      {
        uint64_t v23 = *(void *)(v22 + 40);
        uint64_t v22 = *(void *)(v22 + 16);
        uint64_t v10 = 3LL;
        if (!v22) {
          return v10;
        }
      }

      uint64_t v71 = *(void *)(v23 + 16);
      if (!v71) {
        goto LABEL_107;
      }
      while (*(void *)(v71 + 72) != v21)
      {
        uint64_t v71 = *(void *)(v71 + 32);
        if (!v71) {
          goto LABEL_107;
        }
      }

      xpc_object_t v30 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_string(v30, "name", (const char *)(v71 + 88));
      goto LABEL_28;
    case 3:
      uint64_t v24 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v24) {
        return 1LL;
      }
      uint64_t v25 = v24;
      uint64_t v26 = xpc_dictionary_get_string(a3, "stream");
      if (!v26) {
        return 22LL;
      }
      uint64_t v27 = v26;
      uint64_t v28 = *(void *)(v25 + 144);
      if (!v28) {
        goto LABEL_23;
      }
      while (strcmp((const char *)(*(void *)(v28 + 40) + 40LL), v27))
      {
        uint64_t v28 = *(void *)(v28 + 16);
        if (!v28)
        {
LABEL_23:
          if ((*(_BYTE *)(v25 + 368) & 0x10) != 0) {
            return 124LL;
          }
          LODWORD(v101) = 0;
          uint64_t v29 = sub_100035544(v25, v27, 1, (int *)&v101);
          uint64_t v10 = v101;
          if ((_DWORD)v101) {
            return v10;
          }
          uint64_t v28 = (uint64_t)v29;
          if (!v29) {
            sub_100046EB4();
          }
          break;
        }
      }

      xpc_object_t v30 = xpc_dictionary_create_reply(a3);
      sub_1000363E8(v30, v28);
LABEL_28:
      uint64_t v10 = 0LL;
      goto LABEL_29;
    case 4:
      uint64_t v31 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v31) {
        return 1LL;
      }
      uint64_t v32 = v31;
      char v33 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v34 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22LL;
      if (!v33) {
        return v10;
      }
      uint64_t v35 = v34;
      uint64_t v22 = *(void *)(v32 + 144);
      if (!v22) {
        return 3LL;
      }
      while (1)
      {
        uint64_t v36 = *(void *)(v22 + 40);
        uint64_t v22 = *(void *)(v22 + 16);
        uint64_t v10 = 3LL;
        if (!v22) {
          return v10;
        }
      }

      uint64_t v72 = *(void *)(v36 + 16);
      if (!v72) {
        goto LABEL_107;
      }
      while (*(void *)(v72 + 72) != v35)
      {
        uint64_t v72 = *(void *)(v72 + 32);
        if (!v72) {
          goto LABEL_107;
        }
      }

      BOOL v78 = xpc_dictionary_get_BOOL(a3, "state");
      char v85 = *(_BYTE *)(v72 + 80);
      *(_BYTE *)(v72 + 80) = v85 & 0xFE | v78;
      if (v78)
      {
        if ((v85 & 2) != 0) {
          uint64_t v86 = 11LL;
        }
        else {
          uint64_t v86 = 8LL;
        }
        uint64_t v87 = sub_10001D3D8(*(void *)(v72 + 48), v86, v79, v80, v81, v82, v83, v84);
        if (v87 > 0x25 || ((1LL << v87) & 0x3000000001LL) == 0)
        {
          char v89 = v87;
          uint64_t v90 = *(void *)(v72 + 48);
          xpc_strerror(v87);
          sub_10001A4D8( v90,  3,  "Could not spawn service in response to XPC event state change: %d: %s",  v91,  v92,  v93,  v94,  v95,  v89);
        }

        if ((*(_BYTE *)(v72 + 80) & 2) != 0)
        {
          sub_100035ECC((void *)v72);
          sub_10001685C((void *)v72);
        }
      }

      uint64_t v10 = 0LL;
      *a4 = xpc_dictionary_create_reply(a3);
      return v10;
    case 5:
    case 7:
      return v10;
    case 6:
      uint64_t v37 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v37) {
        return 1LL;
      }
      uint64_t v38 = v37;
      __int128 v39 = xpc_dictionary_get_string(a3, "stream");
      if (!v39) {
        return 22LL;
      }
      __int128 v40 = v39;
      uint64_t v41 = *(void *)(v38 + 144);
      if (!v41)
      {
LABEL_44:
        BOOL v42 = (*(_BYTE *)(v38 + 368) & 0x10) == 0;
        unsigned int v43 = 124;
        goto LABEL_109;
      }

      while (strcmp((const char *)(*(void *)(v41 + 40) + 40LL), v40))
      {
        uint64_t v41 = *(void *)(v41 + 16);
        if (!v41) {
          goto LABEL_44;
        }
      }

      if ((*(_BYTE *)(v41 + 56) & 1) != 0)
      {
        xpc_object_t v76 = xpc_dictionary_create_reply(a3);
        int v77 = xpc_pipe_routine_reply(v76);
        if ((v77 & 0xFFFFFFDF) != 0) {
          _os_assumes_log(v77);
        }
        xpc_release(v76);
        return 0LL;
      }

      else
      {
        uint64_t v69 = *(void *)(v41 + 48);
        if (v69)
        {
          int v70 = xpc_pipe_routine_reply(v69);
          if ((v70 & 0xFFFFFFDF) != 0) {
            _os_assumes_log(v70);
          }
          xpc_release(*(xpc_object_t *)(v41 + 48));
          *(void *)(v41 + 48) = 0LL;
        }

        uint64_t v10 = 0LL;
        *(void *)(v41 + 48) = xpc_dictionary_create_reply(a3);
      }

      return v10;
    case 8:
      uint64_t v44 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v44) {
        return 1LL;
      }
      uint64_t v45 = v44;
      uint64_t v46 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v47 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22LL;
      if (!v46) {
        return v10;
      }
      uint64_t v48 = v47;
      uint64_t v49 = *(void *)(v45 + 144);
      if (!v49) {
        return 3LL;
      }
      while (1)
      {
        uint64_t v50 = *(void *)(v49 + 40);
        uint64_t v49 = *(void *)(v49 + 16);
        uint64_t v10 = 3LL;
        if (!v49) {
          return v10;
        }
      }

      uint64_t v73 = *(void *)(v50 + 16);
      if (!v73)
      {
LABEL_103:
        char v74 = *(_BYTE *)(v49 + 56);
        goto LABEL_108;
      }

      while (*(void *)(v73 + 72) != v48)
      {
        uint64_t v73 = *(void *)(v73 + 32);
        if (!v73) {
          goto LABEL_103;
        }
      }

      xpc_dictionary_set_string(a3, "name", (const char *)(v73 + 88));
      int int64 = xpc_dictionary_get_int64(a3, "subscriber-pid");
      uint64_t v101 = 0LL;
      uint64_t v10 = sub_100035FF8(a3, v49, int64, 0, &v101);
      if (!(_DWORD)v10)
      {
        xpc_object_t v30 = xpc_dictionary_create_reply(a3);
        sub_1000363E8(v30, v49);
        if (v101) {
          uint64_t v97 = *(void *)(v101 + 72);
        }
        else {
          uint64_t v97 = 0LL;
        }
        xpc_dictionary_set_uint64(v30, "token", v97);
LABEL_29:
        *a4 = v30;
      }

      return v10;
    case 9:
      uint64_t v51 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v51) {
        return 1LL;
      }
      uint64_t v52 = v51;
      uint64_t v53 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v54 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22LL;
      if (!v53) {
        return v10;
      }
      uint64_t v55 = v54;
      uint64_t v22 = *(void *)(v52 + 144);
      if (!v22) {
        return 3LL;
      }
      break;
    case 10:
      xpc_object_t v57 = &stru_100064B90;
      return sub_10003649C(a3, a4, (uint64_t)v7, (uint64_t)v57);
    case 11:
      xpc_object_t v57 = &stru_100064BF8;
      return sub_10003649C(a3, a4, (uint64_t)v7, (uint64_t)v57);
    case 12:
      uint64_t v58 = sub_10001CB68(*((_DWORD *)v7 + 5));
      if (!v58) {
        return 1LL;
      }
      uint64_t v59 = v58;
      uint64_t v60 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v61 = xpc_dictionary_get_string(a3, "name");
      xpc_object_t value = xpc_dictionary_get_value(a3, "descriptor");
      int v63 = xpc_dictionary_get_int64(a3, "subscriber-pid");
      uint64_t v10 = 22LL;
      if (!v60) {
        return v10;
      }
      if (!v61) {
        return v10;
      }
      int v64 = v63;
      if (!v63
        || !value
        || xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary
        || !xpc_dictionary_expects_reply(a3))
      {
        return v10;
      }

      uint64_t v65 = sub_10001CB68(v64);
      if (!v65) {
        return 113LL;
      }
      uint64_t v66 = *(void *)(v59 + 144);
      if (!v66) {
        return 3LL;
      }
      xpc_object_t v67 = (void *)v65;
      uint64_t v10 = 3LL;
      while (strcmp((const char *)(*(void *)(v66 + 40) + 40LL), v60))
      {
        uint64_t v66 = *(void *)(v66 + 16);
        if (!v66) {
          return v10;
        }
      }

      uint64_t v98 = sub_100035CF0(v67, v60, v61, value, 0);
      xpc_object_t v99 = xpc_dictionary_create_reply(a3);
      xpc_object_t v30 = v99;
      if (v98)
      {
        sub_1000363E8(v99, v66);
        uint64_t v100 = *((void *)v98 + 9);
      }

      else
      {
        uint64_t v100 = 0LL;
      }

      xpc_dictionary_set_uint64(v30, "token", v100);
      goto LABEL_28;
    default:
      return 33LL;
  }

  while (1)
  {
    uint64_t v56 = *(void *)(v22 + 40);
    uint64_t v22 = *(void *)(v22 + 16);
    uint64_t v10 = 3LL;
    if (!v22) {
      return v10;
    }
  }

  uint64_t v75 = *(void *)(v56 + 16);
  if (v75)
  {
    while (*(void *)(v75 + 72) != v55)
    {
      uint64_t v75 = *(void *)(v75 + 32);
      if (!v75) {
        goto LABEL_107;
      }
    }

    xpc_dictionary_set_string(a3, "name", (const char *)(v75 + 88));
    int v13 = xpc_dictionary_get_int64(a3, "subscriber-pid");
    uint64_t v14 = a3;
    uint64_t v15 = a4;
    return sub_100036248(v14, v15, v13);
  }

  else
  {
LABEL_107:
    char v74 = *(_BYTE *)(v22 + 56);
LABEL_108:
    BOOL v42 = (v74 & 1) == 0;
    unsigned int v43 = 132;
LABEL_109:
    if (v42) {
      return 3LL;
    }
    else {
      return v43;
    }
  }

void *sub_100035544(uint64_t a1, const void *a2, char a3, int *a4)
{
  int v8 = sub_1000264FC(*(void *)(a1 + 248));
  uint64_t v27 = 0LL;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x2000000000LL;
  xpc_object_t v30 = 0LL;
  xpc_object_t v30 = sub_100035714((uint64_t)v8, a2);
  uint64_t v9 = v28[3];
  if ((a3 & 1) == 0 && !v9)
  {
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000LL;
    _OWORD v26[2] = sub_1000357CC;
    v26[3] = &unk_100064B10;
    v26[4] = &v27;
    v26[5] = a2;
    sub_100035768((uint64_t)v8, (uint64_t)v26);
    uint64_t v9 = v28[3];
  }

  if (v9)
  {
    uint64_t v25 = sub_10001C2A0(*(void *)(v9 + 32), 2);
    sub_10001A4D8(a1, 3, "Event stream %s is already monitored by %s, ignoring", v10, v11, v12, v13, v14, (char)a2);
    free(v25);
    uint64_t v15 = 0LL;
    if (a4)
    {
      int v16 = 17;
LABEL_14:
      *a4 = v16;
    }
  }

  else if ((sub_1000032C4(a1, 5) & 1) != 0)
  {
    uint64_t v15 = sub_100016DC4(0LL);
    uint64_t v22 = sub_100016E1C((const char *)a2);
    v15[5] = v22;
    *((void *)v22 + 4) = v15;
    uint64_t v23 = *(void *)(a1 + 144);
    v15[2] = v23;
    if (v23) {
      *(void *)(v23 + 24) = v15 + 2;
    }
    *(void *)(a1 + 144) = v15;
    v15[3] = a1 + 144;
    sub_10003CA78(v8[4], a2, v15);
    _OWORD v15[4] = a1;
    *((_BYTE *)v15 + 56) = v15[7] & 0xF9 | (2 * (a3 & 3));
    sub_100035810((uint64_t)v15, (uint64_t)v8);
    if (a4)
    {
      int v16 = 0;
      goto LABEL_14;
    }
  }

  else
  {
    sub_10001A4D8(a1, 3, "Non-system service tried to claim event stream %s", v17, v18, v19, v20, v21, (char)a2);
    uint64_t v15 = 0LL;
    if (a4)
    {
      int v16 = 150;
      goto LABEL_14;
    }
  }

  _Block_object_dispose(&v27, 8);
  return v15;
}

rb_tree_t **sub_100035714(uint64_t a1, const void *a2)
{
  uint64_t v3 = a1;
  uint64_t result = sub_10003CB2C(*(rb_tree_t ***)(a1 + 32), a2);
  if (!result)
  {
    while (1)
    {
      uint64_t v3 = *(void *)(v3 + 48);
      if (!v3) {
        break;
      }
      uint64_t result = sub_10003CB2C(*(rb_tree_t ***)(v3 + 32), a2);
      if (result && ((_BYTE)result[7] & 2) == 0) {
        return result;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_100035768(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 40);
  if (v3)
  {
    uint64_t v4 = result;
    do
    {
      uint64_t v5 = *(void *)(v3 + 16);
      (*(void (**)(uint64_t))(a2 + 16))(a2);
      uint64_t v3 = v5;
    }

    while (v5);
    uint64_t result = *(void *)(v4 + 40);
    if (result)
    {
      do
      {
        uint64_t v6 = *(void *)(result + 16);
        sub_100035768();
        uint64_t result = v6;
      }

      while (v6);
    }
  }

  return result;
}

rb_tree_t **sub_1000357CC(rb_tree_t **result, uint64_t a2)
{
  if (!*((void *)result[4]->opaque[1] + 3))
  {
    uint64_t v2 = result;
    uint64_t result = sub_10003CB2C(*(rb_tree_t ***)(a2 + 32), result[5]);
    *((void *)v2[4]->opaque[1] + 3) = result;
  }

  return result;
}

uint64_t sub_100035810(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10003CB2C(*(rb_tree_t ***)(a2 + 56), (const void *)(*(void *)(a1 + 40) + 40LL));
  if (v4)
  {
    uint64_t v5 = v4;
    sub_1000167B0(v4);
    uint64_t v6 = v5[2];
    if (v6)
    {
      do
      {
        uint64_t v7 = (rb_tree_t *)v6->opaque[4];
        if ((*(_BYTE *)(a1 + 56) & 4) != 0 && !sub_1000032C4((uint64_t)v6->opaque[6], 6))
        {
          sub_10001A4D8( (uint64_t)v6->opaque[6],  4,  "Rejecting untrusted event subscription on stream %s",  v8,  v9,  v10,  v11,  v12,  *(_BYTE *)(a1 + 40) + 40);
          sub_100035ECC(v6);
          sub_10001685C(v6);
        }

        else
        {
          sub_100035B04(v6, 0, 1);
          if ((sub_100036660(v6, a1, 1) & 1) == 0) {
            sub_100046EB4();
          }
        }

        uint64_t v6 = v7;
      }

      while (v7);
    }

    sub_10003CA78(*(void *)(a2 + 56), v5 + 5, 0LL);
    sub_10001685C(v5);
    return 1LL;
  }

  else
  {
    if ((*(_BYTE *)(a1 + 56) & 2) != 0) {
      return 0LL;
    }
    uint64_t v14 = *(void *)(a2 + 40);
    if (!v14)
    {
      return 0LL;
    }

    else
    {
      do
      {
        uint64_t result = sub_100035810(a1, v14);
        if ((_DWORD)result) {
          break;
        }
        uint64_t v14 = *(void *)(v14 + 16);
      }

      while (v14);
    }
  }

  return result;
}

uint64_t sub_100035964(uint64_t a1, uint64_t a2)
{
  for (uint64_t result = *(void *)(*(void *)(a1 + 40) + 16LL); result; uint64_t result = *(void *)(result + 32))
  {
    if (*(void *)(result + 72) == a2) {
      break;
    }
  }

  return result;
}

uint64_t sub_100035988(uint64_t a1)
{
  return *(void *)(a1 + 40) + 40LL;
}

uint64_t sub_100035994(uint64_t a1)
{
  return *(_BYTE *)(a1 + 56) & 1;
}

void sub_1000359A0(uint64_t a1)
{
  uint64_t v2 = sub_1000264FC(*(void *)(*(void *)(a1 + 32) + 248LL));
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    *(void *)(v3 + 24) = *(void *)(a1 + 24);
  }
  **(void **)(a1 + 24) = v3;
  *(void *)(a1 + 16) = -1LL;
  *(void *)(a1 + 24) = -1LL;
  sub_10003CA78(v2[4], (const void *)(*(void *)(a1 + 40) + 40LL), 0LL);
  uint64_t v4 = *(void **)(*(void *)(a1 + 40) + 16LL);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)v4[4];
      uint64_t v6 = sub_1000264FC(*(void *)(v4[6] + 248LL));
      uint64_t v7 = sub_100035A98((uint64_t)v6, (const void *)(*(void *)(a1 + 40) + 40LL));
      sub_100035B04(v4, 0, 1);
      sub_100035BA0(v4, (uint64_t)v7);
      uint64_t v4 = v5;
    }

    while (v5);
  }

  uint64_t v8 = *(void **)(a1 + 48);
  if (v8)
  {
    xpc_dictionary_set_int64(v8, "error", 124LL);
    int v9 = xpc_pipe_routine_reply(*(void *)(a1 + 48));
    if ((v9 & 0xFFFFFFDF) != 0) {
      _os_assumes_log(v9);
    }
    xpc_release(*(xpc_object_t *)(a1 + 48));
    *(void *)(a1 + 48) = 0LL;
  }

void *sub_100035A98(uint64_t a1, const void *a2)
{
  uint64_t v4 = sub_10003CB2C(*(rb_tree_t ***)(a1 + 56), a2);
  if (!v4)
  {
    uint64_t v4 = sub_100016E1C((const char *)a2);
    sub_10003CA78(*(void *)(a1 + 56), a2, v4);
    sub_10001685C(v4);
  }

  return v4;
}

void sub_100035B04(void *a1, int a2, int a3)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[8];
  a1[8] = 0LL;
  a1[9] = 0LL;
  if (v3) {
    *(void *)(v3 + 40) = a1[5];
  }
  *(void *)a1[5] = v3;
  a1[4] = -1LL;
  a1[5] = -1LL;
  --*(_DWORD *)(v4 + 24);
  if (*(void *)(v4 + 32))
  {
    if (a3) {
      sub_100035FA0(*(void *)(v4 + 32));
    }
  }

  else if (a2 && !*(void *)(v4 + 16))
  {
    uint64_t v5 = sub_1000264FC(*(void *)(a1[6] + 248LL));
    sub_10003CA78(v5[7], (const void *)(v4 + 40), 0LL);
  }

void sub_100035BA0(void *a1, uint64_t a2)
{
  if (*(void *)(a2 + 32)) {
    sub_100046EB4();
  }
  sub_1000366E8(a1, a2);
}

uint64_t sub_100035BBC( uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D32C(a2, a3, "%s => {", a4, a5, a6, a7, a8, a1 + 88);
  if ((*(_BYTE *)(a1 + 80) & 1) != 0) {
    int v16 = "1";
  }
  else {
    int v16 = "0";
  }
  sub_10003D32C(a2, a3 + 1, "keepalive = %s", v11, v12, v13, v14, v15, v16);
  sub_10003D32C(a2, a3 + 1, "service = %s", v17, v18, v19, v20, v21, *(void *)(a1 + 48) + 1360LL);
  sub_10003D32C(a2, a3 + 1, "streauint64_t m = %s", v22, v23, v24, v25, v26, *(void *)(a1 + 64) + 40LL);
  uint64_t v32 = *(void *)(*(void *)(a1 + 64) + 32LL);
  if (v32) {
    sub_10003D32C(a2, a3 + 1, "monitor = %s", v27, v28, v29, v30, v31, *(void *)(v32 + 32) + 1360LL);
  }
  sub_10003D2C0(a2, a3 + 1, "descriptor = ", v27, v28, v29, v30, v31);
  sub_100012BB0(a2, a3 + 1, 0LL, *(void **)(a1 + 56), v33, v34, v35, v36);
  return sub_10003D32C(a2, a3, "}", v37, v38, v39, v40, v41);
}

char *sub_100035CE8(void *a1, const void *a2, const char *a3, void *a4)
{
  return sub_100035CF0(a1, a2, a3, a4, 1);
}

char *sub_100035CF0(void *a1, const void *a2, const char *a3, void *a4, int a5)
{
  uint64_t v10 = sub_1000264FC(a1[31]);
  uint64_t v11 = sub_100035714((uint64_t)v10, a2);
  uint64_t v12 = (uint64_t)v11;
  if (v11 && ((_BYTE)v11[7] & 4) != 0 && (sub_1000032C4((uint64_t)a1, 6) & 1) == 0)
  {
    sub_10001A4D8( (uint64_t)a1,  4,  "Rejecting untrusted event subscription on stream %s",  v13,  v14,  v15,  v16,  v17,  (char)a2);
    return 0LL;
  }

  uint64_t v18 = (char **)(a1 + 17);
  size_t v19 = strlen(a3);
  uint64_t v20 = (char *)sub_100016E68(v19 + 1);
  strcpy(v20 + 88, a3);
  *((void *)v20 + 6) = a1;
  *((void *)v20 + 7) = xpc_retain(a4);
  v20[80] = v20[80] & 0xFD | (2 * (strcmp((const char *)a2, "com.apple.launchd.helper") == 0));
  uint64_t v21 = a1[17];
  *((void *)v20 + 2) = v21;
  if (v21) {
    *(void *)(v21 + 24) = v20 + 16;
  }
  *uint64_t v18 = v20;
  *((void *)v20 + 3) = v18;
  if (v12)
  {
    if ((sub_100036660(v20, v12, a5) & 1) == 0) {
      sub_100046EB4();
    }
  }

  else
  {
    uint64_t v22 = sub_100035A98((uint64_t)v10, a2);
    sub_100035BA0(v20, (uint64_t)v22);
  }

  uint64_t v23 = sub_10002AF0C(a1[31], a1, (const char *)a2);
  int v24 = strcmp((const char *)a2, "com.apple.iokit.matching");
  if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    BOOL v25 = xpc_dictionary_get_BOOL(a4, "IOMatchLaunchStream");
    if (v24)
    {
LABEL_15:
      sub_10003F9E0(v23);
      return v20;
    }
  }

  else
  {
    BOOL v25 = 0;
    if (v24) {
      goto LABEL_15;
    }
  }

  if (v25) {
    goto LABEL_15;
  }
  return v20;
}

uint64_t sub_100035EB4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 80) & 1;
}

uint64_t sub_100035EC0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 80) >> 1) & 1;
}

void sub_100035ECC(void *a1)
{
  uint64_t v1 = a1[2];
  if (v1) {
    *(void *)(v1 + 24) = a1[3];
  }
  *(void *)a1[3] = v1;
  a1[2] = -1LL;
  a1[3] = -1LL;
  sub_100035B04(a1, 1, 1);
}

void *sub_100035EFC(uint64_t a1)
{
  uint64_t v2 = sub_100016DF0(0LL);
  uint64_t v3 = v2;
  if (a1)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 40);
    v2[2] = v5;
    v2[6] = a1;
    if (v5) {
      *(void *)(v5 + 24) = v2 + 2;
    }
    void *v4 = v2;
    v2[3] = v4;
  }

  v2[4] = sub_10003CBF8();
  v3[7] = sub_10003CBF8();
  v3[8] = 1LL;
  return v3;
}

rb_tree_t **sub_100035F64(rb_tree_t **result)
{
  if (((_BYTE)result[9] & 1) == 0)
  {
    *((_BYTE *)result + 72) |= 1u;
    return sub_10003CB60((rb_tree_t **)result[4], (uint64_t)&stru_100064B50);
  }

  return result;
}

void sub_100035F88(id a1, const char *a2, id a3)
{
  if (*(void *)(*((void *)a3 + 5) + 16LL)) {
    sub_100035FA0((uint64_t)a3);
  }
}

uint64_t sub_100035FA0(uint64_t a1)
{
  *(_BYTE *)(a1 + 56) |= 1u;
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    int v3 = xpc_pipe_routine_reply(v2);
    if ((v3 & 0xFFFFFFDF) != 0) {
      _os_assumes_log(v3);
    }
    xpc_release(*(xpc_object_t *)(a1 + 48));
    *(void *)(a1 + 48) = 0LL;
  }

  return sub_10001D218(*(void *)(a1 + 32));
}

uint64_t sub_100035FF8(void *a1, uint64_t a2, int a3, int a4, void *a5)
{
  if (a3)
  {
    int v9 = (void *)sub_10001CB68(a3);
    if (!v9) {
      return 113LL;
    }
  }

  else
  {
    int v9 = 0LL;
  }

  char string = (char *)xpc_dictionary_get_string(a1, "stream");
  uint64_t v12 = xpc_dictionary_get_string(a1, "name");
  xpc_object_t value = xpc_dictionary_get_value(a1, "descriptor");
  uint int64 = xpc_dictionary_get_uint64(a1, "token");
  uint64_t result = 22LL;
  if (string && v12)
  {
    if (value && xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
      return 22LL;
    }
    if (v9)
    {
      uint64_t v15 = (void *)sub_1000361E8((uint64_t)v9, string, v12);
      if (!a2) {
        goto LABEL_20;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
      if (!a2) {
        goto LABEL_20;
      }
    }

    if (!v15 && uint64)
    {
      uint64_t v15 = *(void **)(*(void *)(a2 + 40) + 16LL);
      if (!v15) {
        goto LABEL_27;
      }
      while (v15[9] != uint64)
      {
        uint64_t v15 = (void *)v15[4];
        if (!v15) {
          goto LABEL_27;
        }
      }

uint64_t sub_1000361E8(uint64_t a1, char *__s2, const char *a3)
{
  for (uint64_t i = *(void *)(a1 + 136); i; uint64_t i = *(void *)(i + 16))
  {
  }

  return i;
}

uint64_t sub_100036248(void *a1, void *a2, int a3)
{
  uint64_t v5 = sub_10001CB68(a3);
  if (!v5) {
    return 113LL;
  }
  uint64_t v6 = v5;
  char string = (char *)xpc_dictionary_get_string(a1, "stream");
  uint64_t v8 = xpc_dictionary_get_string(a1, "name");
  if (!string)
  {
    xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
    for (uint64_t i = *(void *)(v6 + 136); i; uint64_t i = *(void *)(i + 16))
    {
      uint64_t v13 = (const char *)(*(void *)(i + 64) + 40LL);
      xpc_object_t value = xpc_dictionary_get_value(v10, v13);
      if (!value)
      {
        xpc_object_t value = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_value(v10, v13, value);
        xpc_release(value);
      }

      xpc_dictionary_set_value(value, (const char *)(i + 88), *(xpc_object_t *)(i + 56));
    }

    goto LABEL_18;
  }

  if (!v8)
  {
    xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
    for (uint64_t j = *(void *)(v6 + 136); j; uint64_t j = *(void *)(j + 16))
    {
    }

    goto LABEL_18;
  }

  uint64_t v9 = sub_1000361E8(v6, string, v8);
  if (v9)
  {
    xpc_object_t v10 = xpc_retain(*(xpc_object_t *)(v9 + 56));
LABEL_18:
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    xpc_dictionary_set_value(reply, "event", v10);
    xpc_release(v10);
    uint64_t result = 0LL;
    *a2 = reply;
    return result;
  }

  return 3LL;
}

void sub_1000363E8(void *a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  for (uint64_t i = *(void *)(*(void *)(a2 + 40) + 16LL); i; uint64_t i = *(void *)(i + 32))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(void *)(i + 72));
    xpc_array_append_value(v4, *(xpc_object_t *)(i + 56));
  }

  xpc_dictionary_set_value(a1, "events", v4);
  xpc_release(v4);
  uint64_t v6 = sub_1000264FC(*(void *)(*(void *)(a2 + 32) + 248LL));
  xpc_dictionary_set_BOOL(a1, "initial-load-completed", v6[72] & 1);
  *(_BYTE *)(a2 + 56) &= ~1u;
}

uint64_t sub_10003649C(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_10001CB68(*(_DWORD *)(a3 + 20));
  if (!v7) {
    return 1LL;
  }
  uint64_t v8 = v7;
  uint int64 = xpc_dictionary_get_uint64(a1, "token");
  uint64_t v10 = uint64;
  uint64_t v11 = sub_1000264FC(*(void *)(v8 + 248));
  v21[0] = 0LL;
  v21[1] = v21;
  v21[2] = 0x2000000000LL;
  char v22 = 0;
  uint64_t v17 = 0LL;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000LL;
  uint64_t v20 = 0LL;
  uint64_t v12 = (rb_tree_t **)*((void *)v11 + 4);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000LL;
  v16[2] = sub_1000365E8;
  v16[3] = &unk_100064BB8;
  void v16[5] = &v17;
  v16[6] = v10;
  v16[4] = v21;
  sub_10003CB60(v12, (uint64_t)v16);
  uint64_t v13 = v18[3];
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  if (!v13) {
    return 3LL;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  (*(void (**)(uint64_t, uint64_t, xpc_object_t))(a4 + 16))(a4, v13, reply);
  uint64_t result = 0LL;
  *a2 = reply;
  return result;
}

void sub_1000365D4(id a1, _launch_service_s *a2, void *a3)
{
}

void *sub_1000365E8(void *result, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(*(void *)(result[4] + 8LL) + 24LL))
  {
    int v3 = *(void **)(*(void *)(a3 + 40) + 16LL);
    if (v3)
    {
      while (v3[9] != result[6])
      {
        int v3 = (void *)v3[4];
        if (!v3) {
          return result;
        }
      }

      *(void *)(*(void *)(result[5] + 8LL) + 24LL) = v3[6];
      *(_BYTE *)(*(void *)(result[4] + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

void sub_100036648(id a1, _launch_service_s *a2, void *a3)
{
}

uint64_t sub_100036660(void *a1, uint64_t a2, int a3)
{
  if ((*(_BYTE *)(a2 + 56) & 4) == 0 || (uint64_t result = sub_1000032C4(a1[6], 6), (_DWORD)result))
  {
    sub_1000366E8(a1, *(void *)(a2 + 40));
    uint64_t v7 = sub_1000264FC(*(void *)(*(void *)(a2 + 32) + 248LL));
    uint64_t v8 = v7[8];
    a1[9] = v8;
    v7[8] = v8 + 1;
    if (v8 == -1) {
      v7[8] = 1LL;
    }
    if (a3) {
      sub_100035FA0(a2);
    }
    return 1LL;
  }

  return result;
}

void sub_1000366E8(void *a1, uint64_t a2)
{
  if (a1[8]) {
    sub_100046EB4();
  }
  uint64_t v2 = *(void *)(a2 + 16);
  a1[4] = v2;
  a1[8] = a2;
  if (v2) {
    *(void *)(v2 + 40) = a1 + 4;
  }
  *(void *)(a2 + 16) = a1;
  a1[5] = a2 + 16;
  int v3 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v3 + 1;
  if (v3 == 512) {
    sub_10003AB08(4, "Accumulated more than %d subscriptions for stream %s", 512, (const char *)(a2 + 40));
  }
}

_DWORD *sub_100036760()
{
  return sub_10003DF50(8, (uint64_t)sub_100036770);
}

uint64_t sub_100036770(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7 = sub_10003DF34();
  switch(a2)
  {
    case 902:
      regiounint64_t n = 0LL;
      char string = xpc_dictionary_get_string(a3, "monitor_id");
      if (!string) {
        return 22LL;
      }
      uint64_t v9 = sub_100001538((uint64_t)string);
      if (!v9) {
        return 96LL;
      }
      uint64_t v10 = (_DWORD *)v9;
      xpc_object_t value = xpc_dictionary_get_value(a3, "shmem");
      if (!value) {
        return 22LL;
      }
      vm_size_t v12 = xpc_shmem_map(value, &region);
      size_t v13 = v12;
      BOOL v42 = (char *)region;
      if (region && v12 >= vm_page_size)
      {
        unint64_t v14 = v12 / 0x33;
        int v15 = sub_100001240((uint64_t)v10);
        xpc_object_t v16 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xxpc_object_t array = xpc_array_create(0LL, 0LL);
        if ((_DWORD)v14)
        {
          uint64_t v17 = 0LL;
          uint64_t v38 = v14;
          size_t v39 = v13;
          uint64_t v18 = 51LL * v14;
          unsigned int v19 = v15 - v14;
          uint64_t v40 = v16;
          do
          {
            uint64_t v20 = sub_100001248(v10, v19);
            uint64_t v21 = *(const char **)v20;
            xpc_object_t v22 = xpc_dictionary_get_value(v16, *(const char **)v20);
            if (v22)
            {
              unsigned int count = xpc_uint64_get_value(v22);
            }

            else
            {
              unsigned int count = xpc_array_get_count(xarray);
              xpc_object_t v16 = v40;
              xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, v21);
              xpc_dictionary_set_uint64(v40, v21, count);
            }

            int v24 = &v42[v17];
            *(_DWORD *)int v24 = count;
            *(_OWORD *)(v24 + 4) = *(_OWORD *)(v20 + 8);
            *(void *)(v24 + 20) = *(void *)(v20 + 24);
            v24[28] = *(_BYTE *)(v20 + 32);
            *(void *)(v24 + 29) = *(void *)(v20 + 33);
            *(void *)(v24 + memset(out, 0, 37) = *(void *)(v20 + 41);
            *(_DWORD *)(v24 + 45) = *(_DWORD *)(v20 + 49);
            *(_WORD *)(v24 + 49) = *(_WORD *)(v20 + 53);
            v17 += 51LL;
            ++v19;
          }

          while (v18 != v17);
          uint64_t v25 = v38;
          size_t v13 = v39;
        }

        else
        {
          uint64_t v25 = 0LL;
        }

        xpc_release(v16);
        uint64_t v36 = v10[5];
        sub_100001194((uint64_t)v10);
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uint64(reply, "count", v25);
        xpc_dictionary_set_uint64(reply, "dropped-count", v36);
        xpc_dictionary_set_value(reply, "labels", xarray);
        xpc_release(xarray);
        uint64_t v26 = 0LL;
        *a4 = reply;
      }

      else
      {
        uint64_t v35 = *__error();
        if ((_DWORD)v35) {
          _os_assumes_log(v35);
        }
        uint64_t v26 = 22LL;
      }

      if (region && v13) {
        munmap(region, v13);
      }
      return v26;
    case 903:
      uint64_t v27 = xpc_dictionary_get_string(a3, "monitor_id");
      if (!v27) {
        return 22LL;
      }
      uint64_t v28 = sub_100001538((uint64_t)v27);
      xpc_object_t v29 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_BOOL(v29, "enabled", v28 != 0);
      goto LABEL_24;
    case 904:
      xpc_object_t v29 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_BOOL(v29, "enabled", 0);
      xpc_dictionary_set_uint64(v29, "foreground_uid", 0xFFFFFF9BuLL);
      xpc_dictionary_set_uint64(v29, "session_uid", 0xFFFFFF9BuLL);
LABEL_24:
      uint64_t v26 = 0LL;
      *a4 = v29;
      return v26;
    case 905:
      uint64_t v30 = xpc_dictionary_get_string(a3, "monitor_id");
      uint int64 = xpc_dictionary_get_uint64(a3, "capacity");
      uint64_t v26 = 22LL;
      uint64_t v32 = sub_1000014A4(v30, uint64);
      goto LABEL_34;
    case 906:
      uint64_t v33 = xpc_dictionary_get_string(a3, "monitor_id");
      if (!v33) {
        return 22LL;
      }
      uint64_t v32 = sub_100001504((uint64_t)v33);
LABEL_34:
      uint64_t v26 = v32;
      if (!(_DWORD)v32) {
        *a4 = xpc_dictionary_create_reply(a3);
      }
      return v26;
    default:
      return 33LL;
  }

char *sub_100036BD0(int a1)
{
  if (a1 < 0)
  {
    int v3 = __error();
    uint64_t result = 0LL;
    *int v3 = 9;
  }

  else
  {
    while (fcntl(a1, 50, v4) == -1)
    {
      if (*__error() != 35) {
        return 0LL;
      }
    }

    return sub_1000126A0(v4);
  }

  return result;
}

void *sub_100036C8C(int a1, uint64_t a2, void *a3, ssize_t *a4)
{
  uint64_t v8 = sub_100010B00(*(void *)(a2 + 96));
  ssize_t v9 = read(a1, v8, *(void *)(a2 + 96));
  ssize_t v10 = v9;
  if (v9 != *(void *)(a2 + 96))
  {
    if (v9)
    {
      if (v9 != -1 || (ssize_t v9 = *__error(), (_DWORD)v9)) {
        _os_assumes_log(v9);
      }
    }

    goto LABEL_8;
  }

  uint64_t v11 = (void *)xpc_create_from_plist(v8, v9);
  vm_size_t v12 = v11;
  if (v11)
  {
    if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_release(v12);
LABEL_8:
      vm_size_t v12 = 0LL;
      goto LABEL_9;
    }

    if (a3 && a4)
    {
      *a4 = v10;
      *a3 = v8;
      return v12;
    }
  }

LABEL_9:
  free(v8);
  return v12;
}

int *sub_100036D70(int *result)
{
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = (int *)close((int)result);
    if ((_DWORD)result)
    {
      uint64_t v1 = *__error();
      if ((_DWORD)v1) {
        _os_assumes_log(v1);
      }
      uint64_t result = __error();
      if (*result == 9) {
        sub_100046EB4();
      }
    }
  }

  return result;
}

void *sub_100036DB4(const char *a1)
{
  return sub_100036DC0(a1, 0LL, 0LL);
}

void *sub_100036DC0(const char *a1, void *a2, ssize_t *a3)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v5 = (int *)open(a1, 0);
  if ((_DWORD)v5 == -1) {
    return 0LL;
  }
  uint64_t v6 = v5;
  memset(&v10, 0, sizeof(v10));
  int v7 = fstat((int)v5, &v10);
  if (v7 | v10.st_uid || (v10.st_mode & 0x12) != 0) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = sub_100036C8C((int)v6, (uint64_t)&v10, a2, a3);
  }
  sub_100036D70(v6);
  return v8;
}

uint8_t *sub_100036E7C(mach_header_64 *a1, const char *a2, const char *a3)
{
  if (!a1) {
    a1 = _NSGetMachExecuteHeader();
  }
  unint64_t size = 0LL;
  memset(&v7, 0, sizeof(v7));
  if (!dladdr(a1, &v7)) {
    return 0LL;
  }
  uint64_t result = getsectiondata((const mach_header_64 *)v7.dli_fbase, a2, a3, &size);
  if (result) {
    return (uint8_t *)xpc_create_from_plist(result, size);
  }
  return result;
}

int *sub_100036EEC(FILE *a1)
{
  uint64_t result = (int *)fclose(a1);
  if ((_DWORD)result)
  {
    uint64_t v2 = *__error();
    if ((_DWORD)v2) {
      _os_assumes_log(v2);
    }
    uint64_t result = __error();
    if (*result == 9) {
      sub_100046EB4();
    }
  }

  return result;
}

BOOL sub_100036F2C(const char *a1)
{
  int v1 = stat(a1, &v4);
  if (v1)
  {
    uint64_t v2 = __error();
    if (v1 == -1 && *v2 != 2) {
      sub_100047024();
    }
  }

  return v1 == 0;
}

void sub_100036F9C()
{
  uint64_t v8 = 0LL;
  size_t v9 = 0LL;
  if (!byte_10006A998 && sub_100036F2C("/System/Library/xpc/WorkloadProperties.plist"))
  {
    uint64_t v0 = sub_100036E78("/System/Library/xpc/WorkloadProperties.plist", &v8, (ssize_t *)&v9);
    int v1 = v0;
    if (v0 && xpc_get_type(v0) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t dictionary = xpc_dictionary_get_dictionary(v1, "SystemCallMasks");
      if (!dictionary
        || (int v3 = dictionary,
            __int128 v21 = 0u,
            __int128 v22 = 0u,
            *(_OWORD *)uint64_t v20 = 0u,
            v23[0] = 12LL,
            sysctlnametomib("kern.syscall_rejection_masks", v20, v23)))
      {
        xpc_release(v1);
        goto LABEL_9;
      }

      uint64_t v18 = 0x2000000000LL;
      *((void *)&applier + 1) = 0x40000000LL;
      *(_OWORD *)&void v12[8] = *(_OWORD *)v20;
      uint64_t v16 = 0LL;
      uint64_t v17 = &v16;
      int v19 = 0;
      *(void *)&__int128 applier = _NSConcreteStackBlock;
      *(void *)&__int128 v11 = sub_100037198;
      *((void *)&v11 + 1) = &unk_100064C48;
      *(void *)vm_size_t v12 = &v16;
      __int128 v13 = v21;
      __int128 v14 = v22;
      size_t v15 = v23[0];
      xpc_dictionary_apply(v3, &applier);
      int v4 = *((_DWORD *)v17 + 6);
      _Block_object_dispose(&v16, 8);
      xpc_release(v1);
      if (!v4)
      {
LABEL_9:
        uint64_t v5 = v8;
        size_t v6 = v9;
        __int128 v11 = 0u;
        *(_OWORD *)vm_size_t v12 = 0u;
        __int128 applier = 0u;
        *(void *)&v12[16] = 12LL;
        if (sysctlnametomib("kern.workload_config", (int *)&applier, (size_t *)&v12[16]))
        {
          free(v8);
        }

        else
        {
          int v7 = sysctl((int *)&applier, *(u_int *)&v12[16], 0LL, 0LL, v5, v6);
          free(v8);
          if (v7) {
            sub_100039448("error parsing the workload properties plist in the kernel (%u)", v7);
          }
        }

        return;
      }
    }

    else
    {
      xpc_release(v1);
      int v4 = 109;
    }

    sub_100039448("error parsing the workload properties plist in launchd (%u)", v4);
  }

uint64_t sub_100037198(uint64_t a1, char *__str, void *a3)
{
  __endptr = 0LL;
  strtol(__str, &__endptr, 10);
  if (*__str && !*__endptr)
  {
    xpc_object_t array = xpc_dictionary_get_array(a3, "SystemCalls");
    if (array)
    {
      uint64_t v18 = array;
      int v19 = (void **)sub_10000D8E8(0x800uLL);
      sub_10000D960((uint64_t)v19, "%s:", v20, v21, v22, v23, v24, v25, (char)__str);
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000LL;
      applier[2] = sub_100037380;
      applier[3] = &unk_100064C20;
      applier[4] = *(void *)(a1 + 32);
      void applier[5] = v19;
      xpc_array_apply(v18, applier);
      if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
      {
        sub_10000D938(v19);
      }

      else
      {
        uint64_t v26 = sub_10000D930((const char **)v19);
        sub_10000D938(v19);
        size_t v27 = strlen(v26);
        int v28 = sysctl((int *)(a1 + 40), *(_DWORD *)(a1 + 88), 0LL, 0LL, v26, v27);
        free(v26);
        if (!v28) {
          return 1LL;
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v28;
        sub_10003B008( "com.apple.xpc.workload_properties",  65541,  "sysctl failed with error (%i)",  v29,  v30,  v31,  v32,  v33,  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
      }
    }

    else
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 109;
      sub_10003B008( "com.apple.xpc.workload_properties",  65541,  "invalid syscall mask array type (%i)",  v13,  v14,  v15,  v16,  v17,  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    }
  }

  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 109;
    sub_10003B008( "com.apple.xpc.workload_properties",  65541,  "invalid syscall mask key: %s (%i)",  v6,  v7,  v8,  v9,  v10,  (char)__str);
  }

  return 0LL;
}

BOOL sub_100037380(uint64_t a1, char a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v12 = *(void *)(a1 + 40);
    char string_ptr = xpc_string_get_string_ptr(object);
    sub_10000D960(v12, " %s", v14, v15, v16, v17, v18, v19, string_ptr);
  }

  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 109;
    sub_10003B008( "com.apple.xpc.workload_properties",  65541,  "invalid syscall mask value at index: %zu  (%i)",  v6,  v7,  v8,  v9,  v10,  a2);
  }

  return type == (xpc_type_t)&_xpc_type_string;
}

void sub_100037440(uint64_t a1)
{
  int v1 = *(void **)(a1 + 344);
  if (v1)
  {
    if (v1[9]) {
      sub_100046EB4();
    }
    uint64_t v3 = v1[8];
    if (v3)
    {
      do
      {
        uint64_t v4 = *(void *)(v3 + 24);
        sub_1000374DC(v3);
        uint64_t v3 = v4;
      }

      while (v4);
    }

    uint64_t v5 = (void *)v1[6];
    if (v5)
    {
      xpc_release(v5);
      v1[6] = 0LL;
    }

    uint64_t v6 = (void *)v1[7];
    if (v6) {
      xpc_release(v6);
    }
    uint64_t v7 = v1[4];
    if (v7) {
      *(void *)(v7 + 40) = v1[5];
    }
    *(void *)v1[5] = v7;
    *(void *)(a1 + 344) = 0LL;
    free(v1);
  }

void sub_1000374DC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 16) = 0LL;
  }

  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 8));
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    *(void *)(v3 + 32) = *(void *)(a1 + 32);
  }
  **(void **)(a1 + 32) = v3;
  free((void *)a1);
}

BOOL sub_10003752C(uint64_t a1, void *a2)
{
  if (!a2) {
    sub_100046EB4();
  }
  xpc_object_t v3 = sub_10003A4FC(a1);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    char string = xpc_dictionary_get_string(v4, "com.apple.private.xpc.launchd.job-manager");
    BOOL v5 = sub_1000375AC(a2, string);
  }

  else
  {
    BOOL v5 = 0LL;
  }

  xpc_release(v4);
  return v5;
}

BOOL sub_1000375AC(void *a1, const char *a2)
{
  BOOL v2 = 0LL;
  if (!a1 || !a2) {
    return v2;
  }
  if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_string)
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(a1)) {
      return 0LL;
    }
    size_t v7 = 0LL;
    do
    {
      char string = (char *)xpc_array_get_string(a1, v7);
      BOOL v2 = sub_1000129FC(string, a2);
      if (v2) {
        break;
      }
      ++v7;
    }

    while (v7 < xpc_array_get_count(a1));
    return v2;
  }

  char string_ptr = (char *)xpc_string_get_string_ptr(a1);
  return sub_1000129FC(string_ptr, a2);
}

unsigned __int8 *sub_100037674( void *a1, _DWORD *a2, char a3, unint64_t a4, uint64_t a5, char *a6, _DWORD *a7)
{
  char string = xpc_dictionary_get_string(a1, "Label");
  if (string && sub_100012944(string, "com.apple.")) {
    a4 |= 0x80uLL;
  }
  int v19 = 0;
  uint64_t v15 = sub_10002B048(a2, a1, a6, a5, a4, &v19);
  uint64_t v16 = v15;
  int v17 = v19;
  if (v19)
  {
    if (v15) {
      sub_100046EB4();
    }
    uint64_t result = 0LL;
  }

  else
  {
    if (!v15) {
      sub_100046EB4();
    }
    if ((a3 & 1) == 0) {
      sub_1000208C4(v15, 15);
    }
    sub_1000265BC(*(void *)(v16 + 248), v16);
    uint64_t result = sub_10003874C(v16);
  }

  *a7 = v17;
  return result;
}

uint64_t sub_10003775C(int a1, unsigned __int8 **a2)
{
  uint64_t v3 = sub_10001CB68(a1);
  if (!v3) {
    return 113LL;
  }
  uint64_t v4 = *(unsigned __int8 **)(v3 + 344);
  if (!v4) {
    uint64_t v4 = sub_1000377A0(v3);
  }
  uint64_t result = 0LL;
  *a2 = v4;
  return result;
}

unsigned __int8 *sub_1000377A0(uint64_t a1)
{
  if (*(void *)(a1 + 344)) {
    sub_100046EB4();
  }
  BOOL v2 = sub_10003874C(a1);
  uint64_t v9 = v2;
  *((_DWORD *)v2 + 3) = *(_DWORD *)(a1 + 364);
  int v10 = *(_DWORD *)(a1 + 352);
  if (v10) {
    sub_100038554(v2, v10, v3, v4, v5, v6, v7, v8);
  }
  *(_DWORD *)(a1 + 352) = 0;
  return v9;
}

_DWORD *sub_1000377F0()
{
  return sub_10003DF50(10, (uint64_t)sub_100037800);
}

uint64_t sub_100037800(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7 = sub_10003DF34();
  switch(a2)
  {
    case 1000:
      xpc_object_t value = (uint64_t *)xpc_dictionary_get_value(a3, "plist");
      uint64_t v9 = value;
      if (!value) {
        goto LABEL_7;
      }
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v9 = 0LL;
LABEL_7:
        uint64_t v10 = 22LL;
LABEL_140:
        if ((_DWORD)v10) {
          return v10;
        }
        LODWORD(v185) = 0;
        if (xpc_dictionary_get_BOOL(a3, "monitor"))
        {
          uint64_t v158 = (unsigned int *)sub_10003888C(v9, (int *)&v185);
          uint64_t v159 = v158;
          uint64_t v10 = v185;
          if ((_DWORD)v185)
          {
            if (v158) {
              sub_100046EB4();
            }
            goto LABEL_147;
          }

          uint64_t v181 = sub_10003424C(a3);
          uint64_t v160 = v181;
          if (v159) {
            xpc_dictionary_set_mach_recv(v181, "monitor", *v159);
          }
        }

        else
        {
          uint64_t v160 = sub_10003424C(a3);
        }

        uint64_t v10 = sub_100038A2C((uint64_t)v9, v160);
        if (!(_DWORD)v10) {
          return v10;
        }
LABEL_147:
        uint64_t v161 = *(void *)(*v9 + 248);
        uint64_t v162 = *v9 + 1360;
        xpc_strerror(v10);
        sub_10002587C(v161, 3, "Start job failed: service = %s, int error = %d: %s", v163, v164, v165, v166, v167, v162);
        sub_1000266F8(v161, *v9);
        return v10;
      }

      char string = xpc_dictionary_get_string(v9, "Label");
      LODWORD(v185) = 0;
      uint64_t v136 = (_DWORD *)sub_10002A864(a3, 0, (int *)&v185);
      int v137 = v185;
      if ((_DWORD)v185)
      {
        uint64_t v138 = (const char *)xpc_strerror(v185);
        sub_10003AB08(3, "Submit job failed. Unable to find domain. Service = %s, int error = %d: %s", string, v137, v138);
        unsigned int v143 = v185;
        if (!(_DWORD)v185) {
          sub_100046E9C(v139, v140, v141, v142);
        }
        goto LABEL_138;
      }

      uint64_t v148 = (uint64_t)v136;
      uint64_t v149 = sub_100038B7C(v9, v136, 0, (uint64_t)v7, (int *)&v185);
      uint64_t v9 = (uint64_t *)v149;
      if (!(_DWORD)v185)
      {
        if (!v149) {
          sub_100046E84(0LL, v150, v151, v152);
        }
        unsigned int v143 = 0;
        goto LABEL_139;
      }

      if (v149) {
        sub_100046EB4();
      }
      xpc_strerror(v185);
      sub_10002587C( v148,  3,  "Submit job failed: service = %s, int error = %d: %s",  v153,  v154,  v155,  v156,  v157,  (char)string);
      unsigned int v143 = v185;
      if ((_DWORD)v185)
      {
LABEL_138:
        uint64_t v9 = 0LL;
LABEL_139:
        uint64_t v10 = v143;
        goto LABEL_140;
      }

      goto LABEL_171;
    case 1001:
      LODWORD(v185) = 0;
      uint64_t v81 = (uint64_t *)sub_100038CC8(a3, (int *)&v185);
      if (!v81) {
        return v185;
      }
      uint64_t v82 = v81;
      uint64_t v83 = (unsigned int *)sub_10003888C(v81, (int *)&v185);
      uint64_t v84 = v83;
      uint64_t v10 = v185;
      if (!(_DWORD)v185)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_mach_recv(reply, "monitor", *v84);
        sub_100038D4C((uint64_t)v82, reply, 0);
        goto LABEL_119;
      }

      if (v83) {
        sub_100046EB4();
      }
      uint64_t v85 = *v82;
      xpc_strerror(v185);
      sub_10001A4D8(v85, 3, "Could not monitor job: int error = %d: %s", v86, v87, v88, v89, v90, v10);
      return v185;
    case 1002:
      LODWORD(v185) = 0;
      uint64_t v31 = sub_100038CC8(a3, (int *)&v185);
      if (!v31) {
        return v185;
      }
      uint64_t v32 = (uint64_t *)v31;
      mach_port_name_t v33 = xpc_dictionary_copy_mach_send(a3, "client-port");
      if (!v33) {
        return 22LL;
      }
      for (uint64_t i = v32[8]; i; uint64_t i = *(void *)(i + 24))
      {
        if (*(_DWORD *)i == v33) {
          break;
        }
      }

      int v35 = sub_10000AC70(v33);
      if (v35) {
        sub_100046EE0(v35);
      }
      if (i)
      {
        if (*(void *)(i + 16))
        {
          uint64_t v41 = *v32;
          BOOL v42 = "job is already monitored";
          int v43 = 5;
          goto LABEL_123;
        }

        char v145 = *(_BYTE *)(i + 40);
        xpc_object_t v146 = xpc_dictionary_create_reply(a3);
        xpc_object_t v147 = v146;
        if ((v145 & 1) != 0)
        {
          sub_100038D4C((uint64_t)v32, v146, 0);
          uint64_t v10 = 0LL;
          *a4 = v147;
          *(_BYTE *)(i + 40) &= ~1u;
        }

        else
        {
          uint64_t v10 = 0LL;
          *(void *)(i + 16) = v146;
        }
      }

      else
      {
        sub_10001A4D8(*v32, 5, "job is not monitored, can't poll", v36, v37, v38, v39, v40, v182);
        return 3LL;
      }

      return v10;
    case 1003:
      unsigned int v184 = 0;
      uint64_t v44 = (uint64_t *)sub_100038CC8(a3, (int *)&v184);
      if (!v44) {
        return v184;
      }
      uint64_t v45 = *v44;
      uint64_t v46 = (void *)v44[6];
      if (v46 && sub_10003752C((uint64_t)v7, v46))
      {
        __int128 v187 = 0u;
        __int128 v188 = 0u;
        __int128 v185 = 0u;
        __int128 v186 = 0u;
        char v47 = sub_100039990((uint64_t)v7, (char *)&v185);
        sub_10001A4D8(v45, 5, "removing job: caller = %s", v48, v49, v50, v51, v52, v47);
        uint64_t v53 = sub_1000266F8(*(void *)(v45 + 248), v45);
        unsigned int v184 = v53;
        if ((_DWORD)v53 == 36) {
          return v184;
        }
        uint64_t v54 = v53;
        if (!(_DWORD)v53)
        {
          *a4 = xpc_dictionary_create_reply(a3);
          return v184;
        }
      }

      else
      {
        uint64_t v54 = 144LL;
        unsigned int v184 = 144;
      }

      xpc_strerror(v54);
      sub_10001A4D8(v45, 3, "Could not remove job: int error = %d: %s", v127, v128, v129, v130, v131, v54);
      return v184;
    case 1004:
      uint64_t v55 = xpc_dictionary_get_string(a3, "manager");
      if (!v55) {
        return 22LL;
      }
      uint64_t v56 = v55;
      xpc_object_t v57 = xpc_array_create(0LL, 0LL);
      for (uint64_t j = qword_10006A568; j; uint64_t j = *(void *)(j + 32))
      {
      }

      xpc_object_t v59 = xpc_dictionary_create_reply(a3);
      xpc_object_t reply = v59;
      uint64_t v61 = "handles";
      goto LABEL_116;
    case 1005:
      uint64_t v91 = xpc_dictionary_get_string(a3, "label");
      if (!v91) {
        return 22LL;
      }
      uint64_t v92 = (char *)v91;
      LODWORD(v185) = 0;
      uint64_t v93 = (_DWORD *)sub_10002A864(a3, 0, (int *)&v185);
      uint64_t v10 = v185;
      if ((_DWORD)v185) {
        return v10;
      }
      uint64_t v94 = (uint64_t)v93;
      uint64_t v78 = (uint64_t)sub_100028EF4(v93, v92);
      if (v78) {
        goto LABEL_78;
      }
      sub_10002587C(v94, 3, "Could not find job with label %s", v95, v96, v97, v98, v99, (char)v92);
      return 113LL;
    case 1006:
      LODWORD(v185) = 0;
      uint64_t v102 = sub_100038CC8(a3, (int *)&v185);
      if (!v102) {
        return v185;
      }
      uint64_t v103 = (void *)v102;
      if (*(_DWORD *)(v102 + 8) == 1)
      {
        xpc_object_t v104 = xpc_dictionary_create_reply(a3);
        sub_100038D4C((uint64_t)v103, v104, 0);
        LODWORD(v185) = xpc_pipe_routine_reply(v104);
        xpc_release(v104);
      }

      else
      {
        if (*(void *)(v102 + 72))
        {
          uint64_t v41 = *(void *)v102;
          BOOL v42 = "Start job failed: another start request is already inflight";
          int v43 = 3;
LABEL_123:
          sub_10001A4D8(v41, v43, v42, v36, v37, v38, v39, v40, v182);
          return 37LL;
        }

        uint64_t v144 = sub_10003424C(a3);
        sub_100038A2C((uint64_t)v103, v144);
      }

      return 0LL;
    case 1007:
      xpc_object_t v105 = xpc_dictionary_get_value(a3, "overlay");
      uint64_t v106 = v105;
      if (v105)
      {
        if (xpc_get_type(v105) != (xpc_type_t)&_xpc_type_dictionary) {
          return 22LL;
        }
      }

      unint64_t v107 = xpc_dictionary_get_string(a3, "path");
      if (!v107) {
        return 22LL;
      }
      uint64_t v108 = v107;
      unsigned int v184 = 0;
      uint64_t v109 = sub_10002A864(a3, 0, (int *)&v184);
      uint64_t v10 = v184;
      if (!v184)
      {
        uint64_t v110 = (void *)v109;
        uint64_t v111 = sub_1000126A0(v108);
        xpc_object_t v112 = xpc_dictionary_create_reply(a3);
        *(void *)&__int128 v185 = _NSConcreteStackBlock;
        *((void *)&v185 + 1) = 0x40000000LL;
        *(void *)&__int128 v186 = sub_100038F28;
        *((void *)&v186 + 1) = &unk_100064CA8;
        *(void *)&__int128 v187 = v112;
        *((void *)&v187 + 1) = v110;
        *(void *)&__int128 v188 = v111;
        sub_100014620(v110, v108, v106, v7, (uint64_t)&v185);
      }

      return v10;
    case 1008:
      int int64 = xpc_dictionary_get_int64(a3, "pid");
      *(void *)&__int128 v185 = 0LL;
      uint64_t v10 = sub_10003775C(int64, (unsigned __int8 **)&v185);
      if (!(_DWORD)v10)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uuid(reply, "job-handle", (const unsigned __int8 *)(v185 + 16));
        goto LABEL_119;
      }

      if ((void)v185) {
        sub_100046EB4();
      }
      return v10;
    case 1009:
      LODWORD(v185) = 0;
      uint64_t v62 = sub_100038CC8(a3, (int *)&v185);
      if (!v62) {
        return v185;
      }
      int v63 = (uint64_t *)v62;
      int v64 = *(void **)(v62 + 48);
      char v65 = v64 && *(void *)(v62 + 56) && sub_10003752C((uint64_t)v7, v64);
      uint64_t v132 = *v63;
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v57 = sub_10001E010(v132, v65);
      uint64_t v61 = "attrs";
      xpc_object_t v59 = reply;
LABEL_116:
      xpc_dictionary_set_value(v59, v61, v57);
      uint64_t v133 = v57;
      goto LABEL_117;
    case 1010:
      unsigned int v184 = 0;
      uint64_t v114 = sub_100038CC8(a3, (int *)&v184);
      if (!v114) {
        return v184;
      }
      uint64_t v115 = (uint64_t *)v114;
      uuid = (unsigned __int8 *)xpc_dictionary_get_uuid(a3, "instance-uuid");
      *(void *)&__int128 v185 = 0LL;
      *((void *)&v185 + 1) = xpc_dictionary_get_string(a3, "sandbox-profile");
      *(void *)&__int128 v186 = xpc_dictionary_get_dictionary(a3, "envvars");
      uint64_t v117 = *v115;
      uint64_t v118 = sub_1000268C8(*(_DWORD **)(*v115 + 248), *v115, uuid, 1, (uint64_t *)&v185, v7, (int *)&v184);
      if (v118)
      {
        uint64_t v119 = (uint64_t)v118;
        if (sub_1000208E0(v117)) {
          sub_1000208C4(v119, 15);
        }
        uint64_t v101 = (uint64_t)sub_10003874C(v119);
        if (v101) {
          goto LABEL_106;
        }
      }

      uint64_t v120 = *v115;
      char v121 = v184;
      xpc_strerror(v184);
      sub_10001A4D8(v120, 4, "instance creation failed: %d %s", v122, v123, v124, v125, v126, v121);
      return v184;
    case 1011:
      xpc_object_t v66 = xpc_dictionary_create_reply(a3);
      int v67 = sub_10003900C((uint64_t)v7, a3, v66);
      if (v67) {
        xpc_dictionary_set_int64(v66, "error", v67);
      }
      uint64_t v10 = 0LL;
      *a4 = v66;
      return v10;
    case 1012:
      xpc_object_t v68 = xpc_dictionary_get_value(a3, "endpoint");
      if (!v68) {
        return 22LL;
      }
      xpc_object_t v69 = v68;
      if (xpc_get_type(v68) != (xpc_type_t)&_xpc_type_mach_send) {
        return 22LL;
      }
      uint64_t right = xpc_mach_send_get_right(v69);
      int v77 = sub_10002A680(right, 1LL, v71, v72, v73, v74, v75, v76);
      if (!v77) {
        return 113LL;
      }
      uint64_t v78 = sub_10003FDE0((uint64_t)v77);
LABEL_78:
      uint64_t v100 = *(void *)(v78 + 344);
      if (!v100)
      {
        uint64_t v101 = (uint64_t)sub_1000377A0(v78);
LABEL_106:
        uint64_t v100 = v101;
      }

      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_uuid(reply, "job-handle", (const unsigned __int8 *)(v100 + 16));
      goto LABEL_118;
    case 1013:
      LODWORD(v185) = 0;
      uint64_t v101 = sub_100038CC8(a3, (int *)&v185);
      if (v101) {
        goto LABEL_106;
      }
      return v185;
    case 1014:
      xpc_object_t array = xpc_dictionary_get_array(a3, "all-jobs");
      if (!array) {
        return 22LL;
      }
      uint64_t v12 = array;
      if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array) {
        return 22LL;
      }
      size_t count = xpc_array_get_count(v12);
      if (count >> 61)
      {
        __break(1u);
LABEL_171:
        sub_100046E9C(count, v14, v15, v16);
      }

      int v17 = sub_100010B00(8 * count);
      if (!xpc_array_get_count(v12))
      {
        xpc_array_get_count(v12);
        size_t v19 = 0LL;
        goto LABEL_150;
      }

      size_t v18 = 0LL;
      size_t v19 = 0LL;
      break;
    case 1015:
      LODWORD(v185) = 0;
      uint64_t v79 = sub_100038CC8(a3, (int *)&v185);
      if (!v79) {
        return v185;
      }
      uint64_t v80 = v79;
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      sub_100038D4C(v80, reply, 1);
      goto LABEL_118;
    default:
      return 33LL;
  }

  do
  {
    xpc_object_t v20 = xpc_array_get_value(v12, v18);
    LODWORD(v185) = 0;
    uint64_t v21 = sub_10002A864(v20, 0, (int *)&v185);
    uint64_t v10 = v185;
    if ((_DWORD)v185)
    {
      free(v17);
      return v10;
    }

    if (v19)
    {
      if (*v17 == v21) {
        goto LABEL_23;
      }
      uint64_t v22 = 1LL;
      while (v19 != v22)
      {
        uint64_t v23 = v17[v22++];
        if (v23 == v21)
        {
          if (v22 - 1 < v19) {
            goto LABEL_23;
          }
          break;
        }
      }
    }

    v17[v19++] = v21;
LABEL_23:
    ++v18;
  }

  while (v18 < xpc_array_get_count(v12));
  if (v19 > xpc_array_get_count(v12)) {
    sub_100046EB4();
  }
  if (v19)
  {
    for (uint64_t k = 0LL; k != v19; ++k)
      sub_100026264(v17[k], 47LL, v24, v25, v26, v27, v28, v29, v182);
    char v183 = 0;
    goto LABEL_151;
  }

LABEL_150:
  char v183 = 1;
LABEL_151:
  xpc_object_t empty = xpc_array_create_empty();
  if (xpc_array_get_count(v12))
  {
    size_t v175 = 0LL;
    do
    {
      xpc_object_t v176 = xpc_array_get_value(v12, v175);
      xpc_object_t v177 = xpc_dictionary_create_empty();
      int v178 = sub_10003900C((uint64_t)v7, v176, v177);
      if (v178) {
        xpc_dictionary_set_int64(v177, "error", v178);
      }
      xpc_array_set_value(empty, 0xFFFFFFFFFFFFFFFFLL, v177);
      xpc_release(v177);
      ++v175;
    }

    while (v175 < xpc_array_get_count(v12));
  }

  if ((v183 & 1) == 0)
  {
    uint64_t v179 = v17;
    do
    {
      uint64_t v180 = *v179++;
      sub_1000262C4(v180, 47LL, v169, v170, v171, v172, v173, v174);
      --v19;
    }

    while (v19);
  }

  free(v17);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "results", empty);
  uint64_t v133 = empty;
LABEL_117:
  xpc_release(v133);
LABEL_118:
  uint64_t v10 = 0LL;
LABEL_119:
  *a4 = reply;
  return v10;
}

void sub_100038488( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 344);
  if (v9)
  {
    switch(a2)
    {
      case 9:
        sub_100038554((void *)v9, 4, a3, a4, a5, a6, a7, a8);
        sub_100037440(a1);
        return;
      case 5:
        if (*(_DWORD *)(v9 + 8) == 1)
        {
          int v10 = 3;
LABEL_22:
          sub_100038554((void *)v9, v10, a3, a4, a5, a6, a7, a8);
        }

        break;
      case 4:
        if (a3)
        {
          *(_DWORD *)(v9 + 12) = a3;
          int v10 = 2;
        }

        else
        {
          int v10 = 1;
        }

        goto LABEL_22;
    }
  }

  else
  {
    switch(a2)
    {
      case 9:
        int v11 = 4;
        break;
      case 5:
        if (*(_DWORD *)(a1 + 352) != 1) {
          return;
        }
        int v11 = 3;
        break;
      case 4:
        if (a3) {
          int v11 = 2;
        }
        else {
          int v11 = 1;
        }
        break;
      default:
        return;
    }

    *(_DWORD *)(a1 + 352) = v11;
  }

void sub_100038554( void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_100046EB4();
  }
  *((_DWORD *)a1 + 2) = a2;
  uint64_t v9 = *a1;
  int v10 = *(char **)(v9 + 344);
  if (v10)
  {
    uint64_t v11 = *((int *)v10 + 2);
    else {
      int v10 = off_100064CC8[v11];
    }
  }

  sub_10001A4D8(v9, 5, "job state = %s", a4, a5, a6, a7, a8, (char)v10);
  uint64_t v12 = (void *)a1[9];
  if (v12)
  {
    sub_100038D4C((uint64_t)a1, (xpc_object_t)a1[9], 0);
    xpc_dictionary_set_uuid(v12, "job-handle", (const unsigned __int8 *)a1 + 16);
    xpc_release((xpc_object_t)a1[9]);
    a1[9] = 0LL;
  }

  for (uint64_t i = a1[8]; i; uint64_t i = *(void *)(i + 24))
  {
    *(_BYTE *)(i + 40) |= 1u;
    uint64_t v14 = *(void *)(i + 16);
    if (v14)
    {
      sub_100038D4C((uint64_t)a1, *(xpc_object_t *)(i + 16), 0);
      xpc_release(*(xpc_object_t *)(i + 16));
      *(void *)(i + 16) = 0LL;
      *(_BYTE *)(i + 40) &= ~1u;
    }
  }

uint64_t sub_1000386B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 344);
  if (v1) {
    return *(void *)(v1 + 72);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000386C8(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_array)
  {
    uint64_t result = (uint64_t)xpc_get_type(object);
    if ((_UNKNOWN *)result != &_xpc_type_string) {
      return result;
    }
    goto LABEL_6;
  }

  uint64_t result = xpc_array_get_count(object);
  if (result)
  {
    uint64_t result = sub_100012AE8(object);
    if ((result & 1) != 0)
    {
LABEL_6:
      uint64_t v5 = sub_10003874C(a1);
      uint64_t result = (uint64_t)xpc_retain(object);
      *((void *)v5 + 6) = result;
    }
  }

  return result;
}

unsigned __int8 *sub_10003874C(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 344);
  if (!v1)
  {
    uint64_t v1 = (unsigned __int8 *)sub_100010B00(0x50uLL);
    *(void *)(a1 + 344) = v1;
    *(void *)uint64_t v1 = a1;
    uuid_generate(v1 + 16);
    uint64_t v3 = qword_10006A568;
    *((void *)v1 + 4) = qword_10006A568;
    if (v3) {
      *(void *)(v3 + 40) = v1 + 32;
    }
    qword_10006A568 = (uint64_t)v1;
    *((void *)v1 + 5) = &qword_10006A568;
  }

  return v1;
}

uint64_t sub_1000387B4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 344);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 48);
    if (v3) {
      return sub_1000386C8(a2, v3);
    }
  }

  return result;
}

uint64_t sub_1000387D4(uint64_t a1, xpc_object_t object)
{
  uint64_t result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_array)
  {
    uint64_t result = xpc_array_get_count(object);
    if (result)
    {
      uint64_t result = sub_100012AE8(object);
      if ((_DWORD)result)
      {
        uint64_t v5 = sub_10003874C(a1);
        uint64_t result = (uint64_t)xpc_retain(object);
        *((void *)v5 + 7) = result;
      }
    }
  }

  return result;
}

uint64_t sub_100038840(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 344);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 56);
    if (v3) {
      return sub_1000387D4(a2, v3);
    }
  }

  return result;
}

char *sub_100038860(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 344);
  else {
    return 0LL;
  }
}

void *sub_10003888C(uint64_t *a1, int *a2)
{
  mach_port_name_t v4 = sub_10000AB70(0x12u, 1u, 0LL);
  if (!v4)
  {
LABEL_11:
    uint64_t v16 = *a1;
    int v14 = 12;
    xpc_strerror(12LL);
    sub_10001A4D8(v16, 3, "Failed to create a job monitor. int error = %d: %s", v17, v18, v19, v20, v21, 12);
    uint64_t v7 = 0LL;
    goto LABEL_12;
  }

  mach_port_name_t v5 = v4;
  mach_port_t poly = 0;
  int v6 = sub_10000AC18(v4, &poly);
  if (v6 || !poly)
  {
    if (!v6) {
      _os_assumes_log(0LL);
    }
    int v15 = sub_10000AC84(v5, 0, 0LL);
    if (v15) {
      sub_100046EE0(v15);
    }
    goto LABEL_11;
  }

  uint64_t v7 = sub_100010B00(0x30uLL);
  *(_DWORD *)uint64_t v7 = v5;
  reply_with_uint64_t port = _xpc_dictionary_create_reply_with_port(poly);
  _OWORD v7[2] = reply_with_port;
  if (!reply_with_port) {
    sub_100046EB4();
  }
  uint64_t v11 = a1[8];
  int v10 = a1 + 8;
  uint64_t v9 = v11;
  void v7[3] = v11;
  if (v11) {
    *(void *)(v9 + 32) = v7 + 3;
  }
  *int v10 = v7;
  v7[4] = v10;
  uint64_t v12 = (dispatch_queue_s *)sub_100011938();
  uint64_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v5, 1uLL, v12);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_100038C8C;
  handler[3] = &unk_100064C68;
  handler[4] = v7;
  dispatch_source_set_event_handler(v13, handler);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000LL;
  size_t v23[2] = sub_100038C94;
  v23[3] = &unk_100064C88;
  v23[4] = v13;
  dispatch_source_set_mandatory_cancel_handler(v13, v23);
  dispatch_activate(v13);
  int v14 = 0;
  v7[1] = v13;
LABEL_12:
  *a2 = v14;
  return v7;
}

uint64_t sub_100038A2C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 72)) {
    sub_100046EB4();
  }
  if (*(_DWORD *)(a1 + 8) == 1) {
    sub_100046EB4();
  }
  uint64_t v3 = *(void **)a1;
  *(void *)(a1 + 72) = a2;
  sub_1000167B0(v3);
  uint64_t v4 = *(void *)a1;
  if (sub_100003C1C(*(void *)a1))
  {
    uint64_t v5 = 137LL;
  }

  else
  {
    uint64_t v6 = sub_10001D28C(v4, 15LL);
    if ((_DWORD)v6 == 36) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = v6;
    }
    if (!(_DWORD)v7)
    {
      uint64_t v5 = v7;
      goto LABEL_18;
    }

    uint64_t v5 = v6;
    if ((_DWORD)v7 == 37)
    {
      if (sub_10001DD5C(*(void *)a1))
      {
        uint64_t v5 = 0LL;
        goto LABEL_18;
      }

      uint64_t v5 = 37LL;
    }
  }

  if (*(void *)(a1 + 72))
  {
    xpc_strerror(v5);
    sub_10001A4D8((uint64_t)v3, 3, "Start job failed: int error = %d: %s", v8, v9, v10, v11, v12, v5);
    uint64_t v13 = *(void **)(a1 + 72);
    xpc_dictionary_set_int64(v13, "error", (int)v5);
    *(void *)(a1 + 72) = 0LL;
    xpc_release(v13);
  }

unsigned __int8 *sub_100038B7C(void *a1, _DWORD *a2, char a3, uint64_t a4, int *a5)
{
  uint64_t result = (unsigned __int8 *)xpc_dictionary_get_value(a1, "_ManagedBy");
  if (result)
  {
    if (sub_10003752C(a4, result))
    {
      memset(v21, 0, sizeof(v21));
      uint64_t v11 = sub_100039990(a4, (char *)v21);
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      *(_OWORD *)__str = 0u;
      __int128 v14 = 0u;
      snprintf(__str, 0x80uLL, "(submitted by %s.%d)", v11, *(_DWORD *)(a4 + 20));
      return sub_100037674(a1, a2, a3, 0x200uLL, a4, __str, a5);
    }

    uint64_t result = 0LL;
    int v12 = 144;
  }

  else
  {
    int v12 = 109;
  }

  *a5 = v12;
  return result;
}

void sub_100038C8C(uint64_t a1)
{
}

void sub_100038C94(uint64_t a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  int v3 = sub_10000AC70(handle);
  if (v3) {
    sub_100046EE0(v3);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_100038CC8(void *a1, int *a2)
{
  if (!a2) {
    sub_100046EB4();
  }
  uuid = xpc_dictionary_get_uuid(a1, "job-handle");
  if (uuid)
  {
    uint64_t v4 = qword_10006A568;
    if (qword_10006A568)
    {
      uint64_t v5 = uuid;
      while (uuid_compare((const unsigned __int8 *)(v4 + 16), v5))
      {
        uint64_t v4 = *(void *)(v4 + 32);
        if (!v4) {
          goto LABEL_7;
        }
      }

      int v6 = 0;
    }

    else
    {
LABEL_7:
      int v6 = 3;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    int v6 = 22;
  }

  *a2 = v6;
  return v4;
}

void sub_100038D4C(uint64_t a1, xpc_object_t xdict, char a3)
{
  uint64_t v6 = *(void *)a1;
  xpc_dictionary_set_uint64(xdict, "job-state", *(unsigned int *)(a1 + 8));
  uint64_t v7 = *(void **)(v6 + 640);
  if (v7) {
    xpc_dictionary_set_value(xdict, "additional-properties", v7);
  }
  xpc_dictionary_set_BOOL(xdict, "removing", (*(_DWORD *)(v6 + 368) & 0x10) != 0);
  if (sub_10001CB2C(v6))
  {
    uint64_t v8 = (const unsigned __int8 *)sub_10001E4D4(v6);
    xpc_dictionary_set_uuid(xdict, "instance", v8);
  }

  switch(*(_DWORD *)(a1 + 8))
  {
    case 1:
      int v9 = sub_10001DD5C(v6);
      xpc_dictionary_set_int64(xdict, "pid", v9);
      if ((a3 & 1) != 0) {
        goto LABEL_10;
      }
      break;
    case 2:
      int64_t v10 = *(int *)(a1 + 12);
      uint64_t v11 = "spawn-error";
      xpc_object_t v12 = xdict;
      goto LABEL_14;
    case 3:
      xpc_dictionary_set_int64(xdict, "wait4-status", 0LL);
      xpc_dictionary_set_uint64(xdict, "os-reason-ns", 7uLL);
      xpc_dictionary_set_uint64(xdict, "os-reason-code", 5uLL);
      xpc_dictionary_set_uint64(xdict, "os-reason-flags", 0LL);
LABEL_10:
      uint64_t v13 = sub_10001E50C(v6);
      if (sub_10003DAF8((_DWORD *)v13))
      {
        xpc_dictionary_set_int64(xdict, "wait4-status", *(int *)(v13 + 28));
        xpc_dictionary_set_uint64(xdict, "os-reason-ns", *(unsigned int *)(v13 + 4));
        xpc_dictionary_set_uint64(xdict, "os-reason-code", *(void *)(v13 + 8));
        xpc_dictionary_set_uint64(xdict, "os-reason-flags", *(void *)(v13 + 16));
      }

      break;
    case 4:
      uint64_t v11 = "error";
      xpc_object_t v12 = xdict;
      int64_t v10 = 113LL;
LABEL_14:
      xpc_dictionary_set_int64(v12, v11, v10);
      break;
    default:
      return;
  }

void sub_100038F28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = sub_10003874C(a2);
    xpc_dictionary_set_uuid(*(xpc_object_t *)(a1 + 32), "job-handle", v5 + 16);
    sub_1000208C4(a2, 15);
  }

  else
  {
    if (!(_DWORD)a3) {
      sub_100046EB4();
    }
    xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "error", (int)a3);
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 48);
    xpc_strerror(a3);
    sub_10002587C(v7, 4, "Could not submit extension %s: %d - %s", v9, v10, v11, v12, v13, v8);
  }

  xpc_release(*(xpc_object_t *)(a1 + 32));
  free(*(void **)(a1 + 48));
}

uint64_t sub_10003900C(uint64_t a1, xpc_object_t object, void *a3)
{
  if (!object) {
    return 22LL;
  }
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    return 22LL;
  }
  xpc_object_t value = xpc_dictionary_get_value(object, "plist");
  if (!value) {
    return 22LL;
  }
  uint64_t v8 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 22LL;
  }
  char string = xpc_dictionary_get_string(v8, "Label");
  unsigned int v26 = 0;
  uint64_t v10 = (_DWORD *)sub_10002A864(object, 0, (int *)&v26);
  uint64_t result = v26;
  if (!v26)
  {
    uint64_t v11 = sub_100038B7C(v8, v10, 1, a1, (int *)&v26);
    uint64_t v12 = v11;
    uint64_t v13 = v26;
    if (v26)
    {
      if (v11) {
        sub_100046EB4();
      }
LABEL_10:
      xpc_strerror(v13);
      sub_10002587C((uint64_t)v10, 3, "Submit job failed: service = %s, int error = %d: %s", v14, v15, v16, v17, v18, string);
      if (v12) {
        sub_1000266F8(v10, *(void *)v12);
      }
      return v26;
    }

    if (xpc_dictionary_get_BOOL(object, "monitor"))
    {
      __int128 v19 = (unsigned int *)sub_10003888C((uint64_t *)v12, (int *)&v26);
      __int128 v20 = v19;
      uint64_t v13 = v26;
      if (v26)
      {
        if (v19) {
          sub_100046EB4();
        }
        goto LABEL_10;
      }

      xpc_dictionary_set_uuid(a3, "job-handle", v12 + 16);
      if (v20) {
        xpc_dictionary_set_mach_recv(a3, "monitor", *v20);
      }
    }

    else
    {
      xpc_dictionary_set_uuid(a3, "job-handle", v12 + 16);
    }

    sub_10002587C((uint64_t)v10, 5, "Submit job succeeded: service = %s", v21, v22, v23, v24, v25, string);
    return 0LL;
  }

  return result;
}

BOOL sub_1000391C0(const char *a1)
{
  uint64_t v7 = 0LL;
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    sub_10003AB08(65540, "Unable to get boot-object-path. Giving up");
    return 0LL;
  }

  else
  {
    uint64_t v4 = sub_100012884("%s/%s/%s", a1, (const char *)v7, ".roots-installed");
    BOOL v5 = sub_100036F2C(v4);
    BOOL v3 = v5;
    if (v5) {
      sub_10003AB08(65541, "Found cookie: %s");
    }
    else {
      sub_10003AB08(65541, "No cookie: %s");
    }
    free(v7);
    free(v4);
  }

  return v3;
}

uint64_t sub_100039294(const char *a1)
{
  BOOL v2 = sub_100012884("%s/%s", a1, ".DarwinDepot");
  if (sub_100036F2C(v2) || (free(v2), BOOL v2 = sub_100012884("%s/%s", a1, ".roots-installed"), sub_100036F2C(v2)))
  {
    sub_10003AB08(65541, "Found cookie: %s", v2);
    uint64_t v3 = 1LL;
  }

  else
  {
    sub_10003AB08(65541, "No cookie from system volume");
    uint64_t v3 = 0LL;
  }

  free(v2);
  return v3;
}

BOOL sub_10003934C(BOOL result)
{
  kern_return_t special_port;
  int v4;
  kern_return_t v5;
  int v6;
  mach_port_t port;
  _OWORD v8[8];
  if (result)
  {
    BOOL v1 = result;
    uint64_t port = 0;
    mach_port_t v2 = mach_host_self();
    special_uint64_t port = host_get_special_port(v2, -1, 3, &port);
    if (special_port)
    {
      _os_assumes_log(special_port);
      return 0LL;
    }

    else
    {
      memset(v8, 0, sizeof(v8));
      __strlcpy_chk(v8, v1, 128LL, 128LL);
      uint64_t v6 = 0;
      uint64_t v4 = sub_1000436F8(port, (const char *)v8, &v6);
      if (v4) {
        _os_assumes_log(v4);
      }
      BOOL v5 = mach_port_deallocate(mach_task_self_, port);
      if (v5) {
        _os_assumes_log(v5);
      }
      return v6 != 0;
    }
  }

  return result;
}

void sub_100039448(char *a1, ...)
{
  v2[0] = 0LL;
  va_copy((va_list)&v2[1], va);
  vasprintf(v2, a1, va);
  if (!v2[0]) {
    v2[0] = a1;
  }
  sub_100039488((uint64_t)v2[0]);
}

void sub_100039488(uint64_t a1)
{
  BOOL v1 = (char *)abort_with_reason(7LL, 1LL, a1, 0LL);
  sub_1000394A4(v1);
}

void sub_1000394A4(char *a1, ...)
{
  v3[0] = 0LL;
  va_copy((va_list)&v3[1], va);
  vasprintf(v3, a1, va);
  if (!v3[0]) {
    v3[0] = a1;
  }
  sub_10003ABB4();
  uint64_t v2 = syscall(55, 3072LL, v3[0]);
  _os_avoid_tail_call(v2);
  __break(1u);
}

void sub_1000394FC()
{
  mach_port_t v0 = mach_host_self();
  host_reboot(v0, 4096);
  __break(1u);
}

void *sub_100039514(int a1)
{
  if (a1)
  {
    if (dlopen("/usr/lib/system/libsystem_notify.dylib", 1)) {
      notify_set_options(0x8000000LL);
    }
    if (!dlopen("/usr/lib/system/libsystem_info.dylib", 1))
    {
LABEL_8:
      uint64_t result = dlopen("/usr/lib/system/libsystem_trace.dylib", 1);
      if (!result) {
        return result;
      }
      return (void *)os_trace_set_mode(256LL);
    }
  }

  else
  {
    notify_set_options(0x8000000LL);
  }

  si_search_module_set_flags("mdns", 1LL);
  si_search_module_set_flags("ds", 1LL);
  if (a1) {
    goto LABEL_8;
  }
  return (void *)os_trace_set_mode(256LL);
}

char *sub_1000395B8(uint64_t a1, uint64_t a2)
{
  return sub_1000395C0(a1, a2, 11LL);
}

char *sub_1000395C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((v6 & 0x80000000) == 0)
  {
    if (!v6) {
      return sub_1000126F4(&__size_4, __size - 8LL);
    }
    return 0LL;
  }

  if (*__error() != 34) {
    return 0LL;
  }
  uint64_t v8 = __size;
  uint64_t v9 = (int8x8_t *)sub_100010B00(__size);
  sub_10003986C(a1, a2, a3, v9, v8);
  if (v10)
  {
    if (*__error() != 3)
    {
      uint64_t v11 = *__error();
      if ((_DWORD)v11) {
        _os_assumes_log(v11);
      }
    }

    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = sub_1000126F4((const char *)&v9[1], v9->u32[1] - 8LL);
  }

  free(v9);
  return v7;
}

xpc_object_t sub_100039700(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a3 != 16 && (_DWORD)a3 != 7) {
    return 0LL;
  }
  sub_10003986C(a1, a2, a3, (int8x8_t *)&v14, 1032LL);
  if (v6 < 0)
  {
    if (*__error() != 34) {
      return 0LL;
    }
    uint64_t v8 = __size;
    uint64_t v9 = (int8x8_t *)sub_100010B00(__size);
    sub_10003986C(a1, a2, a3, v9, v8);
    if (v10)
    {
      if (*__error() != 3)
      {
        uint64_t v11 = *__error();
        if ((_DWORD)v11) {
          _os_assumes_log(v11);
        }
      }
    }

    else
    {
      uint64_t v13 = v9->u32[1];
      if ((_DWORD)v13 && v9->i32[0])
      {
        xpc_object_t v7 = xpc_data_create(&v9[1], v13 - 8);
LABEL_19:
        free(v9);
        return v7;
      }
    }

    xpc_object_t v7 = 0LL;
    goto LABEL_19;
  }

  if (v6) {
    return 0LL;
  }
  xpc_object_t v7 = 0LL;
  if (__size && v14) {
    return xpc_data_create(&__size_4, __size - 8LL);
  }
  return v7;
}

int8x8_t sub_10003986C(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t *a4, uint64_t a5)
{
  if (a2) {
    csops_audittoken(a1, a3, a4, a5, a2);
  }
  else {
    csops(a1, a3, a4, a5);
  }
  int8x8_t result = vrev32_s8(*a4);
  *a4 = result;
  return result;
}

xpc_object_t sub_1000398C4(uint64_t a1, uint64_t a2)
{
  xpc_object_t result = sub_100039700(a1, a2, 16LL);
  if (result)
  {
    uint64_t v3 = result;
    bytes_ptr = xpc_data_get_bytes_ptr(result);
    size_t length = xpc_data_get_length(v3);
    uint64_t v6 = xpc_create_from_ce_der((unint64_t)bytes_ptr, length);
    xpc_release(v3);
    return (xpc_object_t)v6;
  }

  return result;
}

uint64_t sub_100039918(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 13, 1uLL, buffer, 64) == 64) {
    return 0LL;
  }
  else {
    return *__error();
  }
}

uint64_t sub_100039954(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 18, 1uLL, buffer, 192) == 192) {
    return 0LL;
  }
  else {
    return *__error();
  }
}

const char *sub_100039990(uint64_t a1, char *a2)
{
  int v3 = sub_100039918(*(_DWORD *)(a1 + 20), a2);
  uint64_t v4 = "(dead-on-arrival)";
  if (v3 != 3) {
    uint64_t v4 = "(confusing)";
  }
  if (v3) {
    return v4;
  }
  else {
    return a2 + 16;
  }
}

char *sub_1000399D8(int a1, char *a2)
{
  __int128 buffer = 0u;
  memset(v8, 0, sizeof(v8));
  int v4 = sub_100039918(a1, &buffer);
  BOOL v5 = "(unknown)";
  if (!v4) {
    BOOL v5 = (const char *)v8;
  }
  snprintf(a2, 0x20uLL, "%s[%d]", v5, a1);
  return a2;
}

uint64_t sub_100039A7C(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40) {
    return 0LL;
  }
  else {
    return *__error();
  }
}

size_t sub_100039AB8(const char *a1, char **a2)
{
  *__error() = 0;
  memset(v12, 0, sizeof(v12));
  __unint64_t size = 128LL;
  int v4 = sysctlbyname(a1, v12, &__size, 0LL, 0LL);
  int v5 = v4;
  if (__size)
  {
    if (!v4) {
      goto LABEL_6;
    }
  }

  else
  {
    __unint64_t size = 128LL;
    *__error() = 12;
    if (!v5) {
      goto LABEL_6;
    }
  }

  if (*__error() != 12) {
    return 0LL;
  }
LABEL_6:
  if (__size != 128 || *__error() != 12)
  {
    int v10 = 0LL;
    uint64_t v8 = (char *)v12;
    if (v5) {
      goto LABEL_13;
    }
LABEL_16:
    *a2 = strdup(v8);
    goto LABEL_17;
  }

  int v6 = sysctlbyname(a1, 0LL, &__size, 0LL, 0LL);
  size_t result = 0LL;
  if (v6) {
    return result;
  }
  if (__size < 0x81)
  {
    int v10 = 0LL;
    uint64_t v8 = (char *)v12;
    goto LABEL_16;
  }

  uint64_t v8 = (char *)sub_100010B00(__size);
  int v9 = sysctlbyname(a1, v8, &__size, 0LL, 0LL);
  int v10 = v8;
  if (!v9) {
    goto LABEL_16;
  }
LABEL_13:
  __unint64_t size = 0LL;
LABEL_17:
  free(v10);
  return __size;
}

uint64_t sub_100039C44(const char *a1, void *a2)
{
  size_t v8 = 0LL;
  int v4 = sysctlbyname(a1, 0LL, &v8, 0LL, 0LL);
  uint64_t result = 0LL;
  if (!v4)
  {
    if (v8 == 8)
    {
      return 8LL * (sysctlbyname(a1, a2, &v8, 0LL, 0LL) == 0);
    }

    else if (v8 == 4)
    {
      int v7 = 0;
      int v6 = sysctlbyname(a1, &v7, &v8, 0LL, 0LL);
      uint64_t result = 0LL;
      if (!v6)
      {
        *a2 = v7;
        return 8LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

int *sub_100039D0C(const char *a1, int a2)
{
  int v4 = a2;
  uint64_t result = (int *)sysctlbyname(a1, 0LL, 0LL, &v4, 4uLL);
  if ((_DWORD)result)
  {
    int v3 = (int)result;
    uint64_t result = __error();
    if (v3 == -1 && *result != 2) {
      return (int *)sub_100047024();
    }
  }

  return result;
}

unint64_t sub_100039D6C(const char *a1, const char *a2, uint64_t a3)
{
  int v5 = strstr(a1, a2);
  if (v5)
  {
    __endptr = 0LL;
    int v6 = &v5[strlen(a2)];
    unint64_t v7 = strtoul(v6, &__endptr, 10);
    if (v6 != __endptr) {
      return v7;
    }
  }

  return a3;
}

unint64_t sub_100039DD8(const char *a1, const char *a2)
{
  return sub_100039D6C(a1, a2, 0LL);
}

uint64_t sub_100039DE0(int a1, rlim_t *a2, rlim_t *a3)
{
  v8.rlim_t rlim_cur = 0LL;
  v8.rlim_t rlim_max = 0LL;
  uint64_t result = getrlimit(a1, &v8);
  if (!(_DWORD)result)
  {
    rlim_t rlim_cur = v8.rlim_cur;
    if (v8.rlim_cur == 0x7FFFFFFFFFFFFFFFLL) {
      rlim_t rlim_cur = -1LL;
    }
    if (v8.rlim_max == 0x7FFFFFFFFFFFFFFFLL) {
      rlim_t rlim_max = -1LL;
    }
    else {
      rlim_t rlim_max = v8.rlim_max;
    }
    *a2 = rlim_cur;
    *a3 = rlim_max;
  }

  return result;
}

uint64_t sub_100039E38(int a1, unint64_t a2, uint64_t a3, int a4)
{
  if (a2 >= 0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v6 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v6 = a2;
  }
  if (a3 < 0) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = a3;
  }
  if (a3 >= 0) {
    rlim_t v8 = v7;
  }
  else {
    rlim_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (a1 == 8)
  {
    int v9 = "kern.maxfilesperproc";
    int v10 = "kern.maxfiles";
    goto LABEL_14;
  }

  if (a1 == 7)
  {
    int v9 = "kern.maxprocperuid";
    int v10 = "kern.maxproc";
LABEL_14:
    sub_100039F30(v10, v8, a4);
    sub_100039F30(v9, v6, a4);
  }

  v14.rlim_t rlim_cur = v6;
  v14.rlim_t rlim_max = v8;
  if (a4)
  {
    v13.rlim_t rlim_cur = 0LL;
    v13.rlim_t rlim_max = 0LL;
    if (!getrlimit(a1, &v13))
    {
      rlim_t rlim_max = 0x7FFFFFFFFFFFFFFFLL;
      if (v13.rlim_max == 0x7FFFFFFFFFFFFFFFLL || (rlim_t rlim_max = v13.rlim_max, v8 < v13.rlim_max)) {
        v14.rlim_t rlim_max = rlim_max;
      }
    }
  }

  uint64_t result = setrlimit(a1, &v14);
  if ((_DWORD)result) {
    return _os_assumes_log((int)result);
  }
  return result;
}

uint64_t sub_100039F30(const char *a1, unint64_t a2, int a3)
{
  unsigned int v10 = 0x7FFFFFFF;
  size_t v9 = 4LL;
  uint64_t result = sysctlbyname(a1, &v10, &v9, 0LL, 0LL);
  if (!a3 || !(_DWORD)result && v9 == 4 && (v10 & 0x80000000) == 0 && v10 < a2)
  {
    if (a2 >> 31) {
      int v7 = 0x7FFFFFFF;
    }
    else {
      int v7 = a2;
    }
    int v8 = v7;
    return sysctlbyname(a1, 0LL, 0LL, &v8, 4uLL);
  }

  return result;
}

uint64_t sub_100039FD4(char *__s2, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = 0LL;
  while (1)
  {
    uint64_t result = strcmp((&off_100069948)[v8], __s2);
    if (!(_DWORD)result) {
      break;
    }
    v8 += 2LL;
    if (v8 == 18) {
      return result;
    }
  }

  return sub_100039E38((int)(&off_100069948)[v8 + 1], a2, a3, a4);
}

char *sub_10003A05C(int a1)
{
  uint64_t v1 = 0LL;
  while (LODWORD((&off_100069948)[v1 + 1]) != a1)
  {
    v1 += 2LL;
    if (v1 == 18) {
      return 0LL;
    }
  }

  return (&off_100069948)[v1];
}

vm_address_t sub_10003A094(uint64_t a1)
{
  kern_return_t v1;
  vm_address_t address;
  address = 0LL;
  uint64_t v1 = vm_allocate(mach_task_self_, &address, (a1 + vm_page_size - 1) & -(uint64_t)vm_page_size, -268435455);
  if (v1) {
    _os_assumes_log(v1);
  }
  return address;
}

uint64_t sub_10003A0FC(int a1)
{
  return sub_100012B80(a1, (uint64_t)&unk_100064CF0, 27LL);
}

uint64_t sub_10003A10C(int a1)
{
  return sub_100012B80(a1, (uint64_t)&unk_100064EA0, 26LL);
}

void sub_10003A11C(int a1, int a2)
{
  switch(a1)
  {
    case 1:
      sub_10000E638(570425404LL, 0LL);
      reboot(a2);
      if (*__error() == 16) {
        sub_10003A1C0();
      }
      int v3 = __error();
      uint64_t v4 = _os_assert_log(*v3);
      _os_crash(v4, v5, v6, v7);
      __break(1u);
      break;
    case 2:
      sub_1000394FC();
    case 3:
      break;
    default:
      sub_10000E638(570425404LL, 2LL);
      sub_10003A1D0(a2);
  }

  sub_10000E638(570425404LL, 1LL);
  sub_10003C590("recovery-mode", v8, v9, v10, v11, v12, v13, v14, v15);
  __break(1u);
}

void sub_10003A1C0()
{
  while (1)
    pause();
}

void sub_10003A1D0(char a1)
{
  posix_spawnattr_t v34 = 0LL;
  uint64_t v2 = _NSGetArgv();
  int v3 = "-s";
  if ((a1 & 2) == 0) {
    int v3 = 0LL;
  }
  __argv[0] = **v2;
  __argv[1] = v3;
  __argv[2] = 0LL;
  pid_t v32 = 0;
  sub_100011804(0);
  int v35 = 1;
  if (sysctlbyname("vm.shared_region_pivot", 0LL, 0LL, &v35, 4uLL) == -1) {
    goto LABEL_11;
  }
  unsetenv("MallocProbGuard");
  unsetenv("XPC_IN_REM");
  unsetenv("XPC_IN_REM_DEVELOPMENT");
  if (setenv("XPC_USERSPACE_REBOOTED", "1", 1) == -1)
  {
LABEL_12:
    uint64_t v23 = __error();
    uint64_t v24 = _os_assert_log(*v23);
    int v11 = _os_crash(v24, v25, v26, v27);
    __break(1u);
    goto LABEL_13;
  }

  int v4 = posix_spawnattr_init(&v34);
  if (v4) {
    _os_assumes_log(v4);
  }
  int v5 = posix_spawnattr_setflags(&v34, 16448);
  if (v5) {
    _os_assumes_log(v5);
  }
  xpc_object_t empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_BOOL(empty, "on-system-volume", 1);
  xpc_dictionary_set_string(empty, "signing-identifier", "com.apple.xpc.launchd");
  xpc_dictionary_set_int64(empty, "validation-category", 1LL);
  xpc_object_t v7 = sub_10000E860(1LL, 0LL, empty);
  uint64_t v8 = (void *)sub_10000E90C(v7);
  bytes_ptr = xpc_data_get_bytes_ptr(v8);
  size_t length = xpc_data_get_length(v8);
  int v11 = amfi_launch_constraint_set_spawnattr(&v34, bytes_ptr, length);
  if (!v11)
  {
    uint64_t v12 = _NSGetEnviron();
    int v13 = posix_spawn(&v32, "/sbin/launchd", 0LL, &v34, __argv, *v12);
    uint64_t v14 = _os_assert_log(v13);
    _os_crash(v14, v15, v16, v17);
    __break(1u);
LABEL_11:
    uint64_t v18 = __error();
    uint64_t v19 = _os_assert_log(*v18);
    _os_crash(v19, v20, v21, v22);
    __break(1u);
    goto LABEL_12;
  }

LABEL_13:
  uint64_t v28 = _os_assert_log(v11);
  _os_crash(v28, v29, v30, v31);
  __break(1u);
}

    uint64_t v26 = 0u;
    uint64_t v27 = 0u;
    uint64_t v24 = 0u;
    uint64_t v25 = 0u;
    uint64_t v10 = sub_100039990((uint64_t)&xmmword_10006A650, (char *)&v24);
    sub_10003E648(xdict, "xpc demux failed");
    sub_10003AB08(65541, "%s.%d sent an invalid request", v10, dword_10006A664);
    if (byte_10006A9B5)
    {
      sub_10003AB08(65541, "Killing sender of bogus IPC message: %s.%d", v10, dword_10006A664);
      int v11 = sub_10003A3A0(dword_10006A664, 2u, (uint64_t)"unknown IPC", 0LL);
      if (v11) {
        _os_assumes_log(v11);
      }
    }

    goto LABEL_16;
  }

  uint int64 = xpc_dictionary_get_uint64(xdict, "subsystem");
  xpc_object_t v7 = uint64;
  int v4 = xpc_dictionary_get_uint64(xdict, "routine");
  if (!(_DWORD)v4) {
    goto LABEL_13;
  }
LABEL_9:
  if (!qword_10006A688) {
    goto LABEL_13;
  }
  uint64_t v9 = 0LL;
  while (*(_DWORD *)(qword_10006A698 + 4 * v9) != v7)
  {
    if (qword_10006A688 == ++v9) {
      goto LABEL_13;
    }
  }

  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, xpc_object_t *))(qword_10006A690 + 8 * v9))( a1,  v4,  xdict,  &xdicta);
  if (v12)
  {
    uint64_t v19 = v12;
    sub_10003E78C(xdict, "demux int error = %d", v13, v14, v15, v16, v17, v18, v12);
    xpc_object_t reply = xpc_dictionary_create_reply(xdict);
    if (reply)
    {
      uint64_t v21 = reply;
      xpc_dictionary_set_int64(reply, "error", v19);
      xdicta = v21;
    }
  }

  sub_10003E648(xdict, "xpc demux succeeded");
  if (xdicta)
  {
    sub_10003E648(xdict, "sending reply");
    if (byte_10006A678 == 1)
    {
      xpc_dictionary_set_uint64(xdicta, "req_pid", dword_10006A664);
      xpc_dictionary_set_uint64(xdicta, "rec_execcnt", dword_10006A66C);
    }

    uint64_t v22 = xpc_pipe_routine_reply(xdicta);
    if ((v22 & 0xFFFFFFDF) != 0) {
      _os_assumes_log(v22);
    }
    xpc_release(xdicta);
  }

uint64_t sub_10003A3A0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = terminate_with_reason(a1, 7LL, a2, a3, a4 | 0x100);
  if ((_DWORD)result)
  {
    if (*__error() == 3) {
      return 0LL;
    }
    else {
      return *__error();
    }
  }

  return result;
}

uint64_t sub_10003A3EC()
{
  uint64_t v0 = kill(-1, 9);
  if ((_DWORD)v0)
  {
    if (*__error() == 1)
    {
      sub_10003AB08(65540, "kill(-1, SIGKILL) returned EPERM (expected at most twice)");
    }

    else if ((_DWORD)v0 == -1)
    {
      sub_100047024();
    }
  }

  return v0;
}

uint64_t sub_10003A454(_OWORD *a1)
{
  __int128 v1 = a1[1];
  v3[0] = *a1;
  v3[1] = v1;
  return proc_terminate_with_audittoken(v3);
}

uint64_t sub_10003A47C(uint64_t a1, int a2)
{
  int v4 = 0;
  if (*__error() == 3) {
    return 0LL;
  }
  uint64_t result = *__error();
  if ((_DWORD)result)
  {
    _os_assumes_log(result);
    return 0LL;
  }

  return result;
}

xpc_object_t sub_10003A4FC(uint64_t a1)
{
  return sub_1000398C4(*(unsigned int *)(a1 + 20), a1);
}

BOOL sub_10003A508(pid_t a1)
{
  if (a1 < 1) {
    return 0LL;
  }
  if (kill(a1, 0)) {
    return *__error() != 3;
  }
  return 1LL;
}

uint64_t sub_10003A54C(_OWORD *a1)
{
  __int128 v1 = a1[1];
  v3[0] = *a1;
  v3[1] = v1;
  return proc_signal_with_audittoken(v3);
}

uint64_t sub_10003A574(pid_t a1, int *a2, int a3, rusage *a4)
{
  if (wait4(a1, a2, a3, a4) == -1) {
    return *__error();
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10003A5AC(int pid, integer_t *a2)
{
  tunint64_t n = 0;
  mach_msg_type_number_t task_info_outCnt = 8;
  uint64_t v3 = task_name_for_pid(mach_task_self_, pid, &tn);
  if (!(_DWORD)v3)
  {
    uint64_t v3 = task_info(tn, 0xFu, a2, &task_info_outCnt);
    mach_port_deallocate(mach_task_self_, tn);
  }

  return v3;
}

uint64_t sub_10003A628(uint64_t a1, uint64_t a2)
{
  int v2 = memorystatus_control(1LL, a1, 0LL, a2, 24LL);
  uint64_t result = 0LL;
  if (v2 != 24) {
    return *__error();
  }
  return result;
}

uint64_t sub_10003A668(int a1)
{
  __int128 v3 = 0u;
  __int128 v4 = 0u;
  memset(v2, 0, sizeof(v2));
  _os_assumes_log(0LL);
  return 0LL;
}

uint64_t sub_10003A6EC()
{
  return qword_100069AA0;
}

void sub_10003A6F8(const char *a1)
{
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  __int128 v3 = 0u;
  __int128 v4 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v2 = 0u;
  snprintf(__str, 0xA0uLL, "XPC API Misuse: %s", a1);
  qword_100069AA0 = (uint64_t)__str;
  __break(1u);
}

void sub_10003A748(uint64_t a1)
{
}

uint64_t sub_10003A770(const char *a1)
{
  if (byte_10006A580) {
    int v1 = 3;
  }
  else {
    int v1 = 65539;
  }
  sub_10003AB08(v1, "%s", a1);
  return 1LL;
}

void sub_10003A7BC()
{
  if (qword_10006A570 != -1) {
    dispatch_once_f(&qword_10006A570, 0LL, (dispatch_function_t)sub_10003AA98);
  }
  mkdir(off_100069A18[0], 0x1C0u);
  if (!byte_10006A99B)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "/private/%s", "/var/run/syslog");
    __int128 v18 = 0u;
    memset(v19, 0, sizeof(v19));
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    sockaddr v14 = (sockaddr)0;
    __int128 v15 = 0u;
    v14.sa_family = 1;
    strncpy(v14.sa_data, __str, 0x67uLL);
    __int128 v2 = (int *)socket(1, 2, 0);
    if ((_DWORD)v2 == -1)
    {
      int v6 = *__error();
      __int128 v7 = __error();
      __int128 v8 = (const char *)xpc_strerror(*v7);
      sub_10003AB08(65539, "Could not create system logger socket: int error = %d: %s", v6, v8);
      goto LABEL_4;
    }

    __int128 v3 = v2;
    if (unlink(v14.sa_data) == -1 && *__error() != 2)
    {
      __error();
      __int128 v9 = __error();
      xpc_strerror(*v9);
      sub_10003AB08(65539, "Could not unlink previous system logger socket: int error = %d: %s");
    }

    else
    {
      int v4 = bind((int)v3, &v14, 0x6Au);
      if (!v4) {
        goto LABEL_17;
      }
      int v5 = v4;
      while (*__error() == 35 || *__error() == 4)
      {
        int v5 = bind((int)v3, &v14, 0x6Au);
        if (!v5) {
          goto LABEL_17;
        }
      }

      if (v5 != -1)
      {
LABEL_17:
        if (chmod(v14.sa_data, 0x1B6u) == -1)
        {
          int v10 = *__error();
          int v11 = __error();
          uint64_t v12 = (const char *)xpc_strerror(*v11);
          sub_10003AB08(65539, "Could not make system logger socket world-writable: int error = %d: %s", v10, v12);
          if (unlink(v14.sa_data) == -1) {
            sub_100046FF0();
          }
        }

        else
        {
          _os_log_simple_reinit_4launchd();
          dword_1000699D8 = (int)v3;
        }

        goto LABEL_4;
      }

      __error();
      int v13 = __error();
      xpc_strerror(*v13);
      sub_10003AB08(65539, "Could not bind to system logger socket: int error = %d: %s");
    }

    sub_100036D70(v3);
  }

LABEL_4:
  dispatch_activate((dispatch_object_t)qword_10006A578);
  byte_10006A580 = 1;
  uint64_t v0 = off_100069A30;
  pid_t v1 = getpid();
  sub_10003AB08(65541, "launchd logging initialized. name: %s pid: %d", v0, v1);
}

void sub_10003AA98()
{
  uint64_t v0 = dispatch_queue_attr_make_with_qos_class(0LL, QOS_CLASS_UTILITY, 0);
  qword_10006A588 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.logq", v0);
  qword_10006A578 = (uint64_t)dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_data_or,  0LL,  0LL,  (dispatch_queue_t)qword_10006A588);
  dispatch_source_set_event_handler((dispatch_source_t)qword_10006A578, &stru_1000650E0);
  qword_10006A920 = 0LL;
  qword_10006A928 = (uint64_t)&qword_10006A920;
}

void sub_10003AB08(int a1, char *a2, ...)
{
}

void sub_10003AB40()
{
}

void sub_10003AB68(int a1, char *a2, ...)
{
}

void sub_10003ABB4()
{
}

void sub_10003ABC8(id a1)
{
  if (qword_10006A590)
  {
    int v1 = fileno((FILE *)qword_10006A590);
    fcntl(v1, 51);
  }

uint64_t sub_10003ABF8()
{
  uint64_t v15 = 0LL;
  __int128 v16 = &v15;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_10006A598);
  if (qword_10006A920)
  {
    *__int128 v16 = qword_10006A920;
    __int128 v16 = (uint64_t *)qword_10006A928;
    qword_10006A920 = 0LL;
    qword_10006A928 = (uint64_t)&qword_10006A920;
  }

  unint64_t v0 = qword_10006A5A0;
  qword_10006A5A0 = 0LL;
  uint64_t v1 = qword_10006A5A8;
  qword_10006A5A8 = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A598);
  uint64_t v2 = v15;
  if (v15)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = 0LL;
    while (1)
    {
      uint64_t v5 = qword_10006A5B0;
      if (!qword_10006A5B0) {
        goto LABEL_14;
      }
      if (*(_DWORD *)(qword_10006A5B0 + 16) != *(_DWORD *)(v2 + 16)
        || !sub_1000129FC(*(char **)(qword_10006A5B0 + 24), *(const char **)(v2 + 24))
        || !sub_1000129FC(*(char **)(v5 + 48), *(const char **)(v2 + 48)))
      {
        break;
      }

      ++qword_10006A5B8;
LABEL_16:
      uint64_t v15 = *(void *)(v15 + 80);
      if (!v15) {
        __int128 v16 = &v15;
      }
      sub_10001685C((void *)v2);
      ++v3;
      uint64_t v2 = v15;
      if (!v15) {
        goto LABEL_21;
      }
    }

    int v6 = (void *)qword_10006A5B0;
    if (qword_10006A5B0)
    {
      if (qword_10006A5B8)
      {
        __int128 v7 = sub_100012884("Last log repeated %llu times", qword_10006A5B8);
        __int128 v8 = sub_10003B038(5, 0LL, (__darwin_time_t)v7, 0LL);
        sub_10003B12C((uint64_t)v8, 0LL);
        sub_10001685C(v8);
        int v6 = (void *)qword_10006A5B0;
      }

      sub_10001685C(v6);
      qword_10006A5B0 = 0LL;
    }

void sub_10003AE8C(const char *a1, int a2, char *a3, va_list a4, uint64_t a5)
{
  if ((a2 & 0xFFFEu) <= 5)
  {
    void v13[5] = v5;
    void v13[6] = v6;
    v13[0] = 0LL;
    if (vasprintf(v13, a3, a4) != -1)
    {
      int v10 = sub_10003B038(a2, a1, (__darwin_time_t)v13[0], a5);
      int v11 = v10;
      if (!byte_10006A580 && BYTE4(v10[1].tv_sec))
      {
        uint64_t v12 = sub_10003B408((uint64_t)v10);
        sub_10000CFAC("%s|%s", off_100069A30, v12);
        BYTE4(v11[1].tv_sec) = 0;
        free(v12);
      }

      if (qword_10006A570 != -1) {
        dispatch_once_f(&qword_10006A570, 0LL, (dispatch_function_t)sub_10003AA98);
      }
      os_unfair_lock_lock((os_unfair_lock_t)&unk_10006A598);
      if ((unint64_t)qword_10006A5A0 >> 4 > 0x270)
      {
        ++qword_10006A5A8;
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A598);
        sub_10001685C(v11);
      }

      else
      {
        v11[5].tv_sec = 0LL;
        *(void *)qword_10006A928 = v11;
        qword_10006A928 = (uint64_t)&v11[5];
        ++qword_10006A5A0;
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_10006A598);
        dispatch_source_merge_data((dispatch_source_t)qword_10006A578, 1uLL);
      }
    }
  }

void sub_10003B008( const char *a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

timeval *sub_10003B038(int a1, const char *a2, __darwin_time_t a3, uint64_t a4)
{
  uint64_t v9 = (char *)sub_100016ECC(0LL);
  int v10 = (timeval *)v9;
  if ((a1 & 0x10000) != 0 || (!byte_10006A9E2 ? (BOOL v11 = dword_1000699D8 == -1) : (BOOL v11 = 1), v11)) {
    v9[20] = 1;
  }
  if ((a1 & 0x20000) != 0) {
    v9[23] = 1;
  }
  *(_WORD *)(v9 + 21) = 257;
  *((_DWORD *)v9 + 4) = (unsigned __int16)a1;
  if (a2) {
    uint64_t v12 = sub_1000126A0(a2);
  }
  else {
    uint64_t v12 = 0LL;
  }
  *(void *)&v10[1].tv_usec = v12;
  v10[3].tv_sec = a3;
  uint64_t v13 = gettimeofday(v10 + 2, 0LL);
  if (a4) {
    uint64_t v14 = a4;
  }
  else {
    uint64_t v14 = v4;
  }
  *(void *)&v10[3].tv_usec = v14;
  v10[4].tv_sec = os_log_simple_now(v13);
  __uint64_t v16 = 0LL;
  pthread_threadid_np(0LL, &v16);
  *(void *)&v10[4].tv_usec = v16;
  return v10;
}

void sub_10003B12C(uint64_t a1, _DWORD *a2)
{
  if (*(_BYTE *)(a1 + 21))
  {
    if (dword_1000699D8 == -1 || byte_10006A99B != 0)
    {
      int v5 = 0;
      if (!a2) {
        goto LABEL_12;
      }
LABEL_11:
      *a2 = v5;
      goto LABEL_12;
    }

    if (!(void)xmmword_10006A5E0)
    {
      *(void *)&xmmword_10006A5E0 = getpid();
      *(void *)&__int128 v19 = 0LL;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      __int128 buffer = 0u;
      pid_t v6 = getpid();
      proc_pidinfo(v6, 17, 0LL, &buffer, 56);
      *((void *)&xmmword_10006A5E0 + 1) = v17;
      *(void *)&xmmword_10006A5F0 = (int)v18;
      uuid_copy((unsigned __int8 *)&xmmword_10006A600 + 8, (const unsigned __int8 *)&buffer);
      uuid_copy(byte_10006A618, (const unsigned __int8 *)&buffer);
      uuid_clear((unsigned __int8 *)&xmmword_10006A620 + 8);
      _dyld_get_shared_cache_uuid((char *)&xmmword_10006A620 + 8);
      qword_10006A638 = (uint64_t)_NSGetMachExecuteHeader();
    }

    __int128 v20 = xmmword_10006A600;
    __int128 v21 = unk_10006A610;
    __int128 v22 = xmmword_10006A620;
    uint64_t v23 = qword_10006A630;
    __int128 buffer = xmmword_10006A5C0;
    __int128 v17 = *(_OWORD *)algn_10006A5D0;
    __int128 v18 = xmmword_10006A5E0;
    __int128 v19 = xmmword_10006A5F0;
    LOBYTE(buffer) = os_log_simple_type_from_asl(*(unsigned int *)(a1 + 16));
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    *((void *)&buffer + 1) = *(void *)(a1 + 24);
    *(void *)&__int128 v17 = v7;
    uint64_t v9 = *(void *)(a1 + 72);
    *((void *)&v17 + 1) = *(void *)(a1 + 64);
    *((void *)&v19 + 1) = v9;
    *(void *)&__int128 v20 = v8 - qword_10006A638;
    int v5 = _os_log_simple_send(&buffer);
    if (a2) {
      goto LABEL_11;
    }
  }

char *sub_10003B408(uint64_t a1)
{
  *(void *)__str = 0LL;
  uint64_t v5 = 0LL;
  memset(v6, 0, sizeof(v6));
  memset(&v3, 0, sizeof(v3));
  localtime_r((const time_t *)(a1 + 32), &v3);
  snprintf( __str,  0x1BuLL,  "%04d-%02d-%02d %02d:%02d:%02d.%06d",  v3.tm_year + 1900,  v3.tm_mon + 1,  v3.tm_mday,  v3.tm_hour,  v3.tm_min,  v3.tm_sec,  *(_DWORD *)(a1 + 40));
  if (*(void *)(a1 + 24)) {
    return sub_100012884("%s (%s) <%s>: %s\n");
  }
  else {
    return sub_100012884("%s <%s>: %s\n");
  }
}

void *sub_10003B504()
{
  return sub_100039514(0);
}

void sub_10003B50C( char *key, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!qword_10006A9E8) {
    sub_100039448("boot task dictionary is not populated");
  }
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_10006A9E8, key);
  if (!value) {
    sub_100039448("undefined boot task %s", key);
  }
  uint64_t v12 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100039448("boot task %s is not a dictionary", key);
  }
  else {
    sub_10003B008(key, 196613, "Skipping boot-task", v13, v14, v15, v16, v17, a9);
  }
}

uint64_t sub_10003B5E0(const char *a1, xpc_object_t xdict)
{
  if (xpc_dictionary_get_BOOL(xdict, "PerformAlways")) {
    return 1LL;
  }
  if (!byte_10006A9B8 || (uint64_t result = xpc_dictionary_get_BOOL(xdict, "PerformAfterUserspaceReboot"), (_DWORD)result))
  {
    BOOL v5 = xpc_dictionary_get_BOOL(xdict, "PerformInRestore");
    if (byte_10006A99C) {
      BOOL v6 = !v5;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      return 0LL;
    }
    BOOL v7 = xpc_dictionary_get_BOOL(xdict, "PerformInLeanTestEnvironment");
    if (byte_10006A999 && !v7)
    {
      sub_10003AB08(65543, "%s not set, Skipping boot-task: %s", "PerformInLeanTestEnvironment", a1);
      return 0LL;
    }

    LODWORD(result) = xpc_dictionary_get_BOOL(xdict, "PerformInBaseSystem");
    if (byte_10006A99D) {
      return result;
    }
    else {
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_10003B6E4( const char *a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (xpc_dictionary_get_string(a2, "Block"))
  {
    if (xpc_dictionary_get_string(a2, "Program")) {
      sub_100046EB4();
    }
    if (xpc_dictionary_get_value(a2, "ProgramArguments")) {
      sub_100046EB4();
    }
    char string = (char *)xpc_dictionary_get_string(a2, "Block");
    if (!string) {
      sub_100039448("Malformed boot-task (missing block key): %s", a1);
    }
    uint64_t v12 = (void (**)(void))sub_100024BCC(string);
    v12[2]();
    _Block_release(v12);
    return sub_10000E654(570425414LL, a1);
  }

  xpc_object_t value = xpc_dictionary_get_value(a2, "RebootOnExitCode");
  if (value)
  {
    uint64_t v15 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
    {
      int v16 = xpc_int64_get_value(v15);
      sub_10003AB08(65543, "%s: will reboot if exits with code: %d", a1, v16);
    }
  }

  if (xpc_dictionary_get_BOOL(a2, "RemoveOnSuccess"))
  {
    uint64_t v17 = sub_10003C630(a2);
    memset(&v82, 0, sizeof(v82));
    if (stat(v17, &v82)) {
      return sub_10000E654(570425414LL, a1);
    }
  }

  *(_OWORD *)&v82.st_dev = *(_OWORD *)off_100065140;
  *(_OWORD *)&v82.st_uid = *(_OWORD *)&off_100065150;
  __int128 v18 = sub_10003C630(a2);
  if (!v18) {
    sub_100039448("boot task has no program");
  }
  __int128 v19 = v18;
  xpc_object_t v20 = xpc_dictionary_get_value(a2, "ProgramArguments");
  if (v20)
  {
    __int128 v21 = v20;
    if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_array) {
      goto LABEL_107;
    }
    xpc_object_t v22 = xpc_retain(v21);
  }

  else
  {
    xpc_object_t v22 = xpc_array_create(0LL, 0LL);
  }

  uint64_t v23 = v22;
  if (!xpc_array_get_count(v22)) {
    xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v19);
  }
  if (xpc_dictionary_get_BOOL(a2, "PassLaunchBootModeAsArgument"))
  {
    uint64_t v24 = (const char *)sub_100001F54();
    if (v24) {
      xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v24);
    }
  }

  size_t count = xpc_array_get_count(v23);
  size_t v26 = count + 1;
  uint64_t v27 = count == -1LL;
  if (v27 << 63 >> 63 != v27 || v27 | (v26 >> 61))
  {
    __break(1u);
LABEL_107:
    sub_100039448("boot task argument vector is not an array");
  }

  size_t v28 = count;
  uint64_t v29 = (char **)sub_100010B00(8 * v26);
  if (v28)
  {
    for (size_t i = 0LL; i != v28; ++i)
    {
      uint64_t v31 = xpc_array_get_string(v23, i);
      if (v31) {
        v29[i] = (char *)v31;
      }
    }
  }

  posix_spawnattr_t v81 = 0LL;
  int v32 = posix_spawnattr_init(&v81);
  if (v32) {
    sub_100046EE0(v32);
  }
  int v33 = posix_spawnattr_setflags(&v81, 16524);
  if (v33) {
    sub_100046EE0(v33);
  }
  if ((a3 & 1) == 0)
  {
    uint64_t v34 = !xpc_dictionary_get_BOOL(a2, "AllowCrash");
    xpc_object_t v35 = xpc_dictionary_get_value(a2, "RebootOnExitCode");
    if (!v35 || xpc_get_type(v35) != (xpc_type_t)&_xpc_type_int64)
    {
      if (xpc_dictionary_get_BOOL(a2, "RequireSuccess")) {
        uint64_t v34 = 3LL;
      }
      else {
        uint64_t v34 = v34;
      }
    }

    int v36 = posix_spawnattr_set_crash_behavior_np(&v81, v34);
    if (v36) {
      sub_100046EE0(v36);
    }
  }

  int v37 = posix_spawnattr_setprocesstype_np(&v81, 1024LL);
  if (v37) {
    sub_100046EE0(v37);
  }
  int v38 = posix_spawnattr_set_launch_type_np(&v81, 1LL);
  if (v38) {
    sub_100046EE0(v38);
  }
  sigset_t v80 = 0;
  int v39 = posix_spawnattr_setsigmask(&v81, &v80);
  if (v39) {
    sub_100046EE0(v39);
  }
  sigset_t v79 = -1;
  int v40 = posix_spawnattr_setsigdefault(&v81, &v79);
  if (v40) {
    sub_100046EE0(v40);
  }
  posix_spawn_file_actions_t v78 = 0LL;
  if (posix_spawn_file_actions_init(&v78) == -1) {
    sub_1000470C8();
  }
  if (posix_spawn_file_actions_addopen(&v78, 0, "/dev/console", 0x20000, 0) == -1) {
    sub_1000470C8();
  }
  if (posix_spawn_file_actions_addopen(&v78, 1, "/dev/console", 131073, 0) == -1) {
    sub_1000470C8();
  }
  if (posix_spawn_file_actions_addopen(&v78, 2, "/dev/console", 131074, 0) == -1) {
    sub_1000470C8();
  }
  task_inspect_t v41 = mach_host_self();
  mach_port_t v42 = sub_10000AEA8(v41);
  task_t v43 = mach_host_self();
  sub_10003C50C(v43, 0);
  if ((a3 & 4) != 0)
  {
    if (qword_10006A648)
    {
      uint64_t v84 = 0LL;
      mach_uint64_t port = _xpc_shmem_get_mach_port();
    }

    else
    {
      sub_10003AB08(65539, "Skipping setting up shared memory with cache loader");
    }
  }

  pid_t v77 = 0;
  int v44 = posix_spawnp(&v77, v19, &v78, &v81, v29, (char *const *)&v82);
  if (posix_spawn_file_actions_destroy(&v78) == -1) {
    sub_1000470C8();
  }
  if (posix_spawnattr_destroy(&v81) == -1) {
    sub_1000470C8();
  }
  free(v29);
  xpc_release(v23);
  task_t v45 = mach_host_self();
  sub_10003C50C(v45, v42);
  if (v44)
  {
    BOOL v51 = (a3 & 1) == 0 && xpc_dictionary_get_BOOL(a2, "RequireRun");
    if (v44 != 2)
    {
      strerror(v44);
      sub_10003B008(a1, 196611, "posix_spawn(): %d: %s", v61, v62, v63, v64, v65, v44);
      if (!v51) {
        return sub_10000E654(570425414LL, a1);
      }
      memset(&v82, 0, 64);
      xpc_object_t v66 = strerror(v44);
      snprintf((char *)&v82, 0x40uLL, "posix_spawn: %d: %s", v44, v66);
      uint64_t v60 = (const char *)&v82;
LABEL_72:
      sub_10003C598(a1, v60);
    }

    if (v51) {
      int v58 = 196611;
    }
    else {
      int v58 = 196613;
    }
    xpc_object_t v59 = "optional";
    if (v51) {
      xpc_object_t v59 = "required";
    }
    sub_10003B008(a1, v58, "%s boot task not present", v46, v47, v48, v49, v50, (char)v59);
    if (v51)
    {
      uint64_t v60 = "required boot task executable not found";
      goto LABEL_72;
    }
  }

  else
  {
    uint64_t v52 = v77;
    uint64_t v53 = xpc_dictionary_get_string(a2, "CSIdentityOverride");
    mach_uint64_t port = 0;
    if (csops(v52, 0LL, &mach_port, 4LL) || (mach_port & 0x4000000) == 0)
    {
      uint64_t v73 = sub_10003C630(a2);
      sub_1000394A4("boot task is not a platform binary (%s, %s)", a1, v73);
    }

    *__error() = 0;
    uint64_t v54 = sub_1000395B8(v52, 0LL);
    uint64_t v55 = sub_10003C630(a2);
    uint64_t v56 = v55;
    if (!v54)
    {
      uint64_t v74 = __error();
      sub_100039448("failed to get the code signing identity for a boot-task (%s, %s) errno: %d", a1, v56, *v74);
    }

    if (v53)
    {
      xpc_object_t v57 = sub_1000126A0(v53);
    }

    else
    {
      int v67 = strrchr(v55, 47);
      if (v67) {
        xpc_object_t v68 = v67 + 1;
      }
      else {
        xpc_object_t v68 = v56;
      }
      xpc_object_t v57 = sub_100012884("com.apple.%s", v68);
    }

    xpc_object_t v69 = v57;
    if (!v57) {
      sub_100046EB4();
    }
    if (strcmp(v57, v54))
    {
      uint64_t v75 = sub_10003C630(a2);
      sub_1000394A4( "code signing identity mismatch for a boot-task (%s, %s) observed=%s expected=%s",  a1,  v75,  v54,  v69);
    }

    free(v54);
    free(v69);
    if (kill(v77, 19) == -1)
    {
      int v70 = *__error();
      if (v70) {
        sub_100046EE0(v70);
      }
    }

    int64_t v71 = v77;
    if (xpc_dictionary_get_BOOL(a2, "Async"))
    {
      if (a3) {
        sub_100039448("Async boot task %s must not have flags", a1);
      }
      xpc_object_t empty = (xpc_object_t)qword_10006A938;
      if (!qword_10006A938)
      {
        xpc_object_t empty = xpc_dictionary_create_empty();
        qword_10006A938 = (uint64_t)empty;
      }

      xpc_dictionary_set_int64(empty, a1, v71);
    }

    else
    {
      sub_10003C6B0(a1, a2, a3, v71);
    }
  }

  return sub_10000E654(570425414LL, a1);
}

void sub_10003BE98( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (statfs("/", &v205) == -1)
  {
    xpc_object_t v177 = __error();
    _os_assumes_log(*v177);
  }

  else if ((v205.f_flags & 1) != 0)
  {
    sub_10003B50C("fsck", 0, v8, v9, v10, v11, v12, v13, v179);
  }

  sub_10003B50C("mount-phase-1", 0, v8, v9, v10, v11, v12, v13, v179);
  sub_10003B50C("data-protection", 0, v14, v15, v16, v17, v18, v19, v180);
  sub_10003B50C("finish-obliteration", 0, v20, v21, v22, v23, v24, v25, v181);
  sub_10003B50C("detect-installed-roots", 0, v26, v27, v28, v29, v30, v31, v182);
  sub_10003B50C("commit-boot-mode", 0, v32, v33, v34, v35, v36, v37, v183);
  sub_10003B50C("restore-datapartition", 0, v38, v39, v40, v41, v42, v43, v184);
  sub_10003B50C("mount-phase-2", 0, v44, v45, v46, v47, v48, v49, v185);
  sub_10003B50C("init-with-data-volume", 0, v50, v51, v52, v53, v54, v55, v186);
  sub_10003B50C("fixup-mobile-tmp", 0, v56, v57, v58, v59, v60, v61, v187);
  sub_10003B50C("MSUEarlyBootTask", 0, v62, v63, v64, v65, v66, v67, v188);
  sub_10003B50C("fips", 0, v68, v69, v70, v71, v72, v73, v189);
  sub_10003B50C("keybag", 0, v74, v75, v76, v77, v78, v79, v190);
  sub_10003B50C("usermanagerd", 0, v80, v81, v82, v83, v84, v85, v191);
  sub_10003B50C("dirs_cleaner", 0, v86, v87, v88, v89, v90, v91, v192);
  sub_10003A7BC();
  sub_10003B50C("xpcroleaccountd", 0, v94, v95, v96, v97, v98, v99, v193);
  sub_10003B50C("init_featureflags", 0, v100, v101, v102, v103, v104, v105, v194);
  uint64_t v106 = j__libSystem_init_after_boot_tasks_4launchd();
  if (!byte_10006A99C && !byte_10006A99D && !byte_10006A9B8)
  {
    int v113 = ne_session_initialize_necp_drop_all(v106);
    if (v113)
    {
      int v114 = v113;
      uint64_t v115 = strerror(v113);
      sub_10003AB08(65539, "Could not opt into Always-On VPN: %d: %s", v114, v115);
    }
  }

  sub_10003B50C("auearlyboot", 0, v107, v108, v109, v110, v111, v112, v195);
  sub_10003B50C("tzinit", 0, v116, v117, v118, v119, v120, v121, v196);
  sub_10003B50C("finish-restore", 0, v122, v123, v124, v125, v126, v127, v197);
  sub_10003B50C("finish-demo-restore", 0, v128, v129, v130, v131, v132, v133, v198);
  sub_1000411FC();
  sub_10003B50C("sysstatuscheck", 0, v134, v135, v136, v137, v138, v139, v199);
  sub_10003B50C("prng_seedctl", 0, v140, v141, v142, v143, v144, v145, v200);
  if (!byte_10006A99C)
  {
    char v201 = -74;
    xpc_object_t v146 = (int *)open("/var/run/utmpx", 512);
    if ((_DWORD)v146 != -1) {
      sub_100036D70(v146);
    }
    remove("/etc/nologin");
  }

  xpc_object_t v147 = sub_100015E28();
  uint64_t v154 = v147;
  if (v147)
  {
    bytes_ptr = (void *)xpc_data_get_bytes_ptr(v147);
    size_t length = xpc_data_get_length(v154);
    xpc_object_t v157 = xpc_shmem_create(bytes_ptr, (length + vm_page_size - 1) & -(uint64_t)vm_page_size);
    if (!v157) {
      sub_100046EB4();
    }
    qword_10006A648 = (uint64_t)v157;
  }

  sub_10003B50C("launchd_cache_loader", 4, v148, v149, v150, v151, v152, v153, v201);
  uint64_t v159 = qword_10006A648;
  if (qword_10006A648)
  {
    xpc_release((xpc_object_t)qword_10006A648);
    qword_10006A648 = 0LL;
  }

  nullsub_23(v159, v158);
  sub_10003B50C("workload-properties-init", 0, v160, v161, v162, v163, v164, v165, v202);
  sub_10003B50C("init-exclavekit", 0, v166, v167, v168, v169, v170, v171, v203);
  if (qword_10006A938)
  {
    xpc_dictionary_apply((xpc_object_t)qword_10006A938, &stru_1000651C0);
    xpc_release((xpc_object_t)qword_10006A938);
    qword_10006A938 = 0LL;
  }

  sub_100015F5C(v154);
  if (v154) {
    xpc_release(v154);
  }
  sub_10003B008("boot", 196613, "Early boot complete. Continuing system boot.", v172, v173, v174, v175, v176, v204);
  sub_10002A568();
}

void sub_10003C268()
{
  if (!byte_10006A9B8 && sysctlbyname("kern.hostname", 0LL, 0LL, "localhost", 0xAuLL) == -1) {
    sub_1000470C8();
  }
  sub_10000E11C();
  if (!byte_10006A9B8)
  {
    __int128 v5 = 0u;
    __int128 v6 = 0u;
    LODWORD(v5) = 3174252;
    unint64_t v0 = (int *)socket(2, 2, 0);
    if ((_DWORD)v0 == -1)
    {
      sub_100047638();
    }

    else
    {
      uint64_t v1 = v0;
      LOWORD(sub_100010C04(15, v0, v1, v2, v3, v4, v5, v6) = v6 | 1;
      memset((char *)&v7[1] + 4, 0, 32);
      *(_OWORD *)((char *)v7 + 4) = 0u;
      *((void *)&v7[3] + 1) = 0LL;
      strcpy((char *)v7, "lo0");
      DWORD1(v7[1]) = 16777343;
      LOWORD(v7[1]) = 528;
      DWORD1(v7[3]) = 255;
      LOWORD(v7[3]) = 528;
      if (ioctl((int)v1, 0x8040691AuLL, v7) == -1) {
LABEL_17:
      }
        sub_100047970();
      else {
        sub_100036D70(v1);
      }
    }

    if (!byte_10006A9B8)
    {
      uint64_t v2 = (int *)socket(30, 2, 0);
      if ((_DWORD)v2 == -1)
      {
        sub_100047638();
      }

      else
      {
        tm v3 = v2;
        __int128 v5 = 0u;
        __int128 v6 = 0u;
        LODWORD(v5) = 3174252;
        memset(v7, 0, sizeof(v7));
        __int128 v8 = 0u;
        __int128 v9 = 0u;
        uint64_t v11 = 0LL;
        __int128 v10 = 0u;
        strcpy((char *)v7, "lo0");
        *(in6_addr *)((char *)&v7[1] + 8) = in6addr_loopback;
        LOWORD(v7[1]) = 7708;
        *(void *)&__int128 v9 = -1LL;
        *((void *)&v9 + 1) = -1LL;
        WORD4(v8) = 7708;
        uint64_t v12 = -1LL;
        if (*__error() != 17) {
LABEL_19:
        }
          sub_100047970();
        else {
LABEL_14:
        }
          sub_100036D70(v3);
      }
    }
  }

  uint64_t v4 = (dispatch_queue_s *)sub_100011938();
  dispatch_async(v4, &stru_100065180);
}

uint64_t sub_10003C50C(task_t a1, mach_port_t new_port)
{
  if (byte_10006A9E0) {
    exception_mask_t v3 = 7168;
  }
  else {
    exception_mask_t v3 = 10240;
  }
  if (mach_task_self_ == a1) {
    return task_set_exception_ports(a1, v3, new_port, -1610612732, 1);
  }
  mach_port_t v5 = mach_host_self();
  return host_set_exception_ports(v5, v3, new_port, -1610612732, 1);
}

void sub_10003C590( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_10003C598(const char *a1, const char *a2)
{
  if (a2) {
    uint64_t v2 = sub_100012884("%s - %s", a1, a2);
  }
  else {
    uint64_t v2 = sub_1000126A0(a1);
  }
  exception_mask_t v3 = v2;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v5 = 0u;
  snprintf(__str, 0x40uLL, "boot task failure: %s", v2);
  pthread_setname_np(__str);
  sub_10003AB08(196608, "Boot task failed: %s", v3);
  sub_10003AB08(196608, "Panicking in 3 seconds.");
  sleep(3u);
  sub_1000394A4("boot task failure: %s", v3);
}

char *sub_10003C630(void *a1)
{
  uint64_t result = (char *)xpc_dictionary_get_string(a1, "Program");
  if (!result)
  {
    uint64_t result = (char *)xpc_dictionary_get_value(a1, "ProgramArguments");
    if (result)
    {
      exception_mask_t v3 = result;
      if (xpc_get_type(result) == (xpc_type_t)&_xpc_type_array)
      {
        uint64_t result = (char *)xpc_array_get_count(v3);
        if (result) {
          return (char *)xpc_array_get_string(v3, 0LL);
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

void sub_10003C6B0(const char *a1, void *a2, char a3, pid_t pid)
{
  uint64_t v36 = 0LL;
  memset(v35, 0, sizeof(v35));
  memset(v37, 0, sizeof(v37));
  __int128 v7 = sub_10003D3B4((uint64_t)v35, pid, (uint64_t)v37);
  if (LODWORD(v35[0]) != 3)
  {
    uint64_t v32 = sub_10003C630(a2);
    sub_100039448("failed to reap boot-task (%s, %s)", a1, v32);
  }

  __int128 v8 = v7;
  if ((a3 & 1) != 0)
  {
    BOOL v11 = 0;
    BOOL v10 = 0;
    BOOL v9 = 0;
  }

  else
  {
    BOOL v9 = xpc_dictionary_get_BOOL(a2, "RequireSuccess");
    BOOL v10 = xpc_dictionary_get_BOOL(a2, "RebootOnSuccess");
    BOOL v11 = xpc_dictionary_get_BOOL(a2, "AssumeSingleUserSuccess");
    xpc_object_t value = xpc_dictionary_get_value(a2, "RebootOnExitCode");
    if (value)
    {
      uint64_t v13 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
      {
        int v14 = xpc_int64_get_value(v13);
        goto LABEL_8;
      }
    }
  }

  int v14 = -1;
LABEL_8:
  BOOL v15 = sub_10003DA48((uint64_t)v35) && sub_10003DA74(v35) == 0;
  if (xpc_dictionary_get_BOOL(a2, "RemoveOnSuccess"))
  {
    uint64_t v16 = sub_10003C630(a2);
    if (v16 && v15)
    {
      uint64_t v18 = v16;
      sub_10003AB08(65543, "%s: exited successfully, removing", a1);
      if (remove(v18) == -1 && *__error() != 2)
      {
        uint64_t v19 = *__error();
        if ((_DWORD)v19) {
          _os_assumes_log(v19);
        }
      }
    }
  }

  if (sub_10003DA48((uint64_t)v35) && sub_10003DA74(v35) == v14)
  {
    char v34 = v14;
    uint64_t v33 = "rebooting on exit code: %d";
LABEL_37:
    sub_10003B008(a1, 196615, v33, v20, v21, v22, v23, v24, v34);
    sub_10003A11C(1LL, 0LL, 0LL);
  }

  if (v15)
  {
    int v25 = 1;
  }

  else
  {
    else {
      int v31 = 196611;
    }
    sub_10003B008(a1, v31, "exited due to %s", v26, v27, v28, v29, v30, (char)v8);
    if (byte_10006A99A) {
      int v25 = v11;
    }
    else {
      int v25 = 0;
    }
    if ((v25 & 1) == 0 && v9)
    {
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      *(_OWORD *)__str = 0u;
      __int128 v39 = 0u;
      snprintf(__str, 0x80uLL, "exited due to %s", v8);
      sub_10003C598(a1, __str);
    }
  }

  if ((v10 & v25) == 1)
  {
    uint64_t v33 = "rebooting after success";
    goto LABEL_37;
  }

  free(v8);
}

BOOL sub_10003C9D8(id a1, const char *a2, void *a3)
{
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_10006A9E8, a2);
  LODWORD(a3) = xpc_int64_get_value(a3);
  sub_10003AB08(196615, "waiting for boot-task %s with pid %d", a2, (_DWORD)a3);
  sub_10003C6B0(a2, value, 0, (pid_t)a3);
  return 1;
}

int *sub_10003CA58()
{
  return sub_100036D70(v0);
}

uint64_t sub_10003CA60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return strcmp(*(const char **)(a2 + 24), *(const char **)(a3 + 24));
}

uint64_t sub_10003CA6C(int a1, uint64_t a2, char *__s2)
{
  return strcmp(*(const char **)(a2 + 24), __s2);
}

void sub_10003CA78(uint64_t a1, const void *a2, void *a3)
{
  if (*(_DWORD *)(a1 + 24) == 4981)
  {
    node = (void **)rb_tree_find_node(*(rb_tree_t **)(a1 + 16), a2);
    if (node)
    {
      __int128 v7 = node;
      rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), node);
      os_release(v7[4]);
      free(v7[3]);
      free(v7);
    }

    if (a3)
    {
      __int128 v8 = sub_100010B00(0x28uLL);
      _OWORD v8[3] = sub_1000126A0((const char *)a2);
      v8[4] = os_retain(a3);
      if (rb_tree_insert_node(*(rb_tree_t **)(a1 + 16), v8) != v8) {
        sub_100046EC8();
      }
    }
  }

  else
  {
    __break(1u);
  }

rb_tree_t **sub_10003CB2C(rb_tree_t **result, const void *a2)
{
  if (*((_DWORD *)result + 6) == 4981)
  {
    uint64_t result = (rb_tree_t **)rb_tree_find_node(result[2], a2);
    if (result) {
      return (rb_tree_t **)result[4];
    }
  }

  else
  {
    __break(1u);
  }

  return result;
}

rb_tree_t **sub_10003CB60(rb_tree_t **result, uint64_t a2)
{
  if (*((_DWORD *)result + 6) == 4981)
  {
    exception_mask_t v3 = result;
    uint64_t result = (rb_tree_t **)rb_tree_iterate(result[2], 0LL, 1u);
    if (result)
    {
      uint64_t v4 = result;
      do
      {
        (*(void (**)(uint64_t, rb_tree_t *, rb_tree_t *))(a2 + 16))(a2, v4[3], v4[4]);
        uint64_t result = (rb_tree_t **)rb_tree_iterate(v3[2], v4, 1u);
        uint64_t v4 = result;
      }

      while (result);
    }
  }

  else
  {
    __break(1u);
  }

  return result;
}

size_t sub_10003CBDC(size_t result)
{
  if (*(_DWORD *)(result + 24) == 4981) {
    return rb_tree_count(*(rb_tree_t **)(result + 16));
  }
  __break(1u);
  return result;
}

void *sub_10003CBF8()
{
  unint64_t v0 = sub_100016CC8(0LL);
  uint64_t v1 = (rb_tree_t *)sub_100010B00(0x40uLL);
  v0[2] = v1;
  rb_tree_init(v1, (const rb_tree_ops_t *)&off_1000699E0);
  *((_DWORD *)v0 + 6) = 4981;
  return v0;
}

void sub_10003CC40(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) == 4981)
  {
    *(_DWORD *)(a1 + 24) = 0;
    uint64_t v2 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), 0LL, 1u);
    if (v2)
    {
      exception_mask_t v3 = v2;
      do
      {
        uint64_t v4 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), v3, 1u);
        rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), v3);
        os_release(v3[4]);
        free(v3[3]);
        free(v3);
        exception_mask_t v3 = v4;
      }

      while (v4);
    }

    free(*(void **)(a1 + 16));
  }

  else
  {
    __break(1u);
  }

void *sub_10003CCD8(uint64_t a1)
{
  __unint64_t n = 0LL;
  serializatiounint64_t n = xpc_make_serialization(a1, &__n);
  if (!serialization) {
    sub_100046EB4();
  }
  uint64_t v2 = (void *)serialization;
  if (!__n) {
    sub_100046EB4();
  }
  exception_mask_t v3 = sub_100017040(__n);
  size_t v4 = __n;
  _OWORD v3[2] = __n;
  memcpy(v3 + 3, v2, v4);
  free(v2);
  return v3;
}

uint64_t sub_10003CD44(uint64_t a1)
{
  uint64_t result = xpc_create_from_serialization(a1 + 24, *(void *)(a1 + 16));
  if (!result) {
    sub_100046EB4();
  }
  return result;
}

void sub_10003CD6C(uint64_t a1, const void *a2, void *a3)
{
  __int128 v6 = sub_10003CB2C(*(rb_tree_t ***)(a1 + 16), a2);
  xpc_object_t v7 = v6;
  if (!v6)
  {
    if (sub_10003CBDC(*(void *)(a1 + 16)) >= *(void *)(a1 + 24))
    {
      v18[0] = 0LL;
      v18[1] = v18;
      _OWORD v18[2] = 0x2000000000LL;
      _OWORD v18[3] = -1LL;
      uint64_t v14 = 0LL;
      BOOL v15 = &v14;
      uint64_t v16 = 0x2000000000LL;
      uint64_t v17 = 0LL;
      __int128 v8 = *(rb_tree_t ***)(a1 + 16);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 0x40000000LL;
      v13[2] = sub_10003D09C;
      v13[3] = &unk_100065208;
      _BYTE v13[4] = v18;
      void v13[5] = &v14;
      sub_10003CB60(v8, (uint64_t)v13);
      char string = xpc_dictionary_get_string((xpc_object_t)v15[3], "key");
      pointer = (void *)xpc_dictionary_get_pointer(v15[3], "value");
      (*(void (**)(const char *, void *))(a1 + 40))(string, pointer);
      sub_10003CA78(*(void *)(a1 + 16), string, 0LL);
      os_release(pointer);
      if (sub_10003CBDC(*(void *)(a1 + 16)) >= *(void *)(a1 + 24)) {
        sub_100046EC8();
      }
      _Block_object_dispose(&v14, 8);
      _Block_object_dispose(v18, 8);
    }

    xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_string(v7, "key", (const char *)a2);
  }

  BOOL v11 = os_retain(a3);
  xpc_dictionary_set_pointer(v7, "value", v11);
  uint64_t v12 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v12 + 1;
  xpc_dictionary_set_uint64(v7, "timestamp", v12);
  if (!v6)
  {
    sub_10003CA78(*(void *)(a1 + 16), a2, v7);
    xpc_release(v7);
  }

rb_tree_t **sub_10003CF38(uint64_t a1, const void *a2)
{
  uint64_t result = sub_10003CB2C(*(rb_tree_t ***)(a1 + 16), a2);
  if (result)
  {
    size_t v4 = result;
    uint64_t v5 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v5 + 1;
    xpc_dictionary_set_uint64(result, "timestamp", v5);
    pointer = (void *)xpc_dictionary_get_pointer(v4, "value");
    return (rb_tree_t **)os_retain(pointer);
  }

  return result;
}

void *sub_10003CF98(uint64_t a1, uint64_t a2)
{
  size_t v4 = sub_100016FBC(0LL);
  void v4[2] = sub_10003CBF8();
  v4[3] = a1;
  _OWORD v4[4] = 1LL;
  v4[5] = a2;
  return v4;
}

void sub_10003CFE0(uint64_t a1)
{
  uint64_t v2 = *(rb_tree_t ***)(a1 + 16);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000LL;
  _OWORD v3[2] = sub_10003D048;
  v3[3] = &unk_1000651E0;
  v3[4] = a1;
  sub_10003CB60(v2, (uint64_t)v3);
  os_release(*(void **)(a1 + 16));
}

void sub_10003D048(uint64_t a1, uint64_t a2, uint64_t a3)
{
  pointer = (void *)xpc_dictionary_get_pointer(a3, "value");
  (*(void (**)(uint64_t, void *))(*(void *)(a1 + 32) + 40LL))(a2, pointer);
  os_release(pointer);
}

uint64_t sub_10003D09C(uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100046EC8();
  }
  uint64_t result = xpc_dictionary_get_uint64(object, "timestamp");
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (result < *(void *)(v6 + 24))
  {
    *(void *)(v6 + 24) = result;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = object;
  }

  return result;
}

uint64_t sub_10003D10C(void *a1, void *a2, uint64_t a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "shmem");
  if (!value) {
    return 22LL;
  }
  regiounint64_t n = 0LL;
  vm_size_t v7 = xpc_shmem_map(value, &region);
  if (region) {
    BOOL v8 = v7 >= vm_page_size;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    BOOL v11 = fmemopen(region, v7, "w");
    if (v11)
    {
      uint64_t v12 = v11;
      (*(void (**)(uint64_t, FILE *))(a3 + 16))(a3, v11);
      unint64_t v13 = ftello(v12);
      if (v13 <= 0x40000000)
      {
        uint64_t v15 = v13;
        xpc_object_t reply = xpc_dictionary_create_reply(a1);
        *a2 = reply;
        xpc_dictionary_set_uint64(reply, "bytes-written", v15);
        uint64_t v10 = 0LL;
      }

      else
      {
        uint64_t v10 = 153LL;
      }

      sub_100036EEC(v12);
    }

    else
    {
      uint64_t v14 = *__error();
      if ((_DWORD)v14) {
        _os_assumes_log(v14);
      }
      uint64_t v10 = 9LL;
    }
  }

  else
  {
    uint64_t v9 = *__error();
    if ((_DWORD)v9) {
      _os_assumes_log(v9);
    }
    uint64_t v10 = 22LL;
  }

  if (region)
  {
    if (!v7) {
      sub_100046EC8();
    }
    munmap(region, v7);
  }

  return v10;
}

uint64_t sub_10003D250( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = (FILE *)result;
    do
    {
      uint64_t result = sub_10003D298(v9, "\t", a3, a4, a5, a6, a7, a8, v10);
      --v8;
    }

    while (v8);
  }

  return result;
}

uint64_t sub_10003D298( FILE *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vfprintf(a1, a2, &a9);
}

uint64_t sub_10003D2C0(FILE *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  if (a2)
  {
    uint64_t v10 = a2;
    do
    {
      sub_10003D298(a1, "\t", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
      --v10;
    }

    while (v10);
  }

  return vfprintf(a1, a3, va);
}

uint64_t sub_10003D32C(FILE *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  if (a2)
  {
    uint64_t v10 = a2;
    do
    {
      sub_10003D298(a1, "\t", (uint64_t)a3, a4, a5, a6, a7, a8, v18);
      --v10;
    }

    while (v10);
  }

  vfprintf(a1, a3, va);
  return sub_10003D298(a1, "\n", v11, v12, v13, v14, v15, v16, v18);
}

uint64_t sub_10003D3A8( FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_10003D298(a1, "\n", a3, a4, a5, a6, a7, a8, a9);
}

char *sub_10003D3B4(uint64_t a1, pid_t pid, uint64_t a3)
{
  *(void *)(a1 + 48) = 0LL;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  uint32_t flags = 0;
  int dirty = j__proc_get_dirty(pid, &flags);
  if (dirty) {
    _os_assumes_log(dirty);
  }
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a1 + 48) & 0xFC | flags & 2 | ((flags & 4) != 0);
  vm_size_t v7 = (_DWORD *)(a1 + 4);
  if (j__proc_pidinfo(pid, 25, 1uLL, (void *)(a1 + 4), 24) != 24 && *__error() != 2)
  {
    uint64_t v8 = *__error();
    if ((_DWORD)v8) {
      _os_assumes_log(v8);
    }
  }

  int v9 = j__proc_pid_rusage(pid, 6, (rusage_info_t *)a3);
  if (v9) {
    _os_assumes_log(v9);
  }
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a3 + 80);
  if ((*(_BYTE *)(a1 + 48) & 3) == 2 && *v7 == 1)
  {
    uint64_t v10 = *(void *)(a1 + 8);
    if (v10 != 2 && v10 != 7) {
      *(void *)(a1 + 8) = 9LL;
    }
  }

  size_t v11 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v11)
  {
    uint64_t v12 = sub_100010B00(0x20uLL);
    *((void *)v12 + 3) = sub_100010B00(v11);
    void v12[5] = v11;
    if (proc_pidinfo(pid, 24, 1uLL, v12, 32) == 32) {
      goto LABEL_21;
    }
    uint64_t v13 = *__error();
    if ((_DWORD)v13) {
      _os_assumes_log(v13);
    }
    free(*((void **)v12 + 3));
    free(v12);
  }

  uint64_t v12 = 0LL;
LABEL_21:
  int v14 = sub_10003A574(pid, (int *)(a1 + 28), 0, 0LL);
  if (v14)
  {
    _os_assumes_log(v14);
    int v15 = 2;
  }

  else
  {
    int v15 = 3;
  }

  *(_DWORD *)a1 = v15;
  if (!v12)
  {
LABEL_63:
    __int128 v43 = sub_10003D968(a1);
    if (!v43) {
      __int128 v43 = "(unknown reason)";
    }
    __int128 v39 = sub_1000126A0(v43);
    goto LABEL_66;
  }

  uint64_t v16 = (char *)sub_10003D968(a1);
  uint64_t v17 = (int *)*((void *)v12 + 3);
  if (!v17) {
    goto LABEL_30;
  }
  uint64_t v18 = v12[5];
  if (!(_DWORD)v18) {
    goto LABEL_30;
  }
  unint64_t v19 = (unint64_t)v17 + v18;
  uint64_t v20 = v17 + 4;
  if (v17 + 4 <= (int *)((char *)v17 + v18))
  {
    unint64_t v21 = *((void *)v12 + 3);
    do
    {
      unint64_t v47 = (unint64_t)v20 + *(unsigned int *)(v21 + 4);
      if (v47 > v19 || *(_DWORD *)v21 == -242132755) {
        break;
      }
      if (*(_DWORD *)v21 == 4098) {
        goto LABEL_28;
      }
      uint64_t v20 = (_DWORD *)(v47 + 16);
      unint64_t v21 = v47;
    }

    while (v47 + 16 <= v19);
  }

  unint64_t v21 = 0LL;
  unint64_t v19 = 0LL;
LABEL_28:
  if (v21 + 16 > v19 || (uint64_t v22 = *(unsigned int *)(v21 + 4), v21 + 16 + v22 > v19))
  {
LABEL_30:
    uint64_t v23 = 0LL;
    goto LABEL_31;
  }

  int v48 = *(_DWORD *)v21;
  if ((*(_DWORD *)v21 & 0xFFFFFFF0) == 0x20) {
    int v48 = 17;
  }
  if (v48 <= 2309)
  {
    if (v48 == 17 || v48 == 19) {
      goto LABEL_97;
    }
    goto LABEL_94;
  }

  if (v48 != 2312)
  {
    if (v48 == 2310 && (_DWORD)v22 == 112 && (*(_BYTE *)(v21 + 8) & 0x8F) == 0)
    {
      LODWORD(v22) = 104;
      goto LABEL_97;
    }

LABEL_94:
    unsigned int v50 = *(_DWORD *)(v21 + 8) & 0xF;
    BOOL v33 = v22 >= v50;
    int v51 = v22 - v50;
    if (v33) {
      LODWORD(v22) = v51;
    }
    else {
      LODWORD(v22) = 0;
    }
    goto LABEL_97;
  }

  if ((_DWORD)v22 != 32 || (*(_BYTE *)(v21 + 8) & 0x8F) != 0) {
    goto LABEL_94;
  }
  LODWORD(v22) = 24;
LABEL_97:
  uint64_t v52 = (char *)(v21 + 16);
  else {
    uint64_t v23 = v52;
  }
LABEL_31:
  uint64_t v24 = 0LL;
  v55[0] = 0LL;
  if (*v12 == 2)
  {
    unint64_t v25 = (unint64_t)v17 + v12[5];
    uint64_t v26 = v17 + 4;
    uint64_t v53 = v23;
    uint64_t v27 = 0LL;
    int v28 = -1;
    do
    {
      uint64_t v29 = v17[1];
      uint64_t v30 = (_DWORD *)((char *)v26 + v29);
      int v31 = *v17;
      if (*v17 == -242132755) {
        break;
      }
      if ((v31 & 0xFFFFFFF0) == 0x20) {
        int v31 = 17;
      }
      if (v31 == 54)
      {
        unsigned int v36 = v17[2] & 0xF;
        BOOL v33 = v29 >= v36;
        int v37 = v29 - v36;
        if (!v33) {
          int v37 = 0;
        }
        if (v37 != 4) {
          sub_100039448("PID size for exit reason mismatch");
        }
        int v28 = v17[4];
      }

      else if (v31 == 55)
      {
        unsigned int v32 = v17[2] & 0xF;
        BOOL v33 = v29 >= v32;
        unsigned int v34 = v29 - v32;
        size_t v35 = v33 ? v34 : 0LL;
        uint64_t v27 = v17 + 4;
      }

      uint64_t v26 = v30 + 4;
      uint64_t v17 = v30;
    }

    while ((unint64_t)(v30 + 4) <= v25);
    uint64_t v23 = v53;
    if (!v27 || v28 == -1) {
LABEL_33:
    }
      asprintf(v55, "(signal info malformed)");
    else {
      asprintf(v55, "sent by %s[%d]");
    }
    uint64_t v24 = v55[0];
    vm_size_t v7 = (_DWORD *)(a1 + 4);
  }

  uint64_t v38 = 0LL;
  __int128 v39 = 0LL;
  v55[0] = v16;
  v55[1] = v23;
  void v55[2] = v24;
  do
  {
    __int128 v40 = v55[v38];
    if (v40)
    {
      if (v39) {
        __int128 v41 = sub_100012884("%s | %s", v39, v40);
      }
      else {
        __int128 v41 = sub_1000126A0(v40);
      }
      __int128 v42 = v41;
      free(v39);
      __int128 v39 = v42;
    }

    ++v38;
  }

  while (v38 != 3);
  free(v24);
  free(*((void **)v12 + 3));
  free(v12);
  if (!v39) {
    goto LABEL_63;
  }
LABEL_66:
  int v44 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 3)
  {
    if (*v7 || (*(_BYTE *)(a1 + 28) & 0x7F) != 0) {
      return v39;
    }
    free(v39);
    int v45 = sub_10003DA74((_DWORD *)a1);
    __int128 v39 = sub_100012884("exit(%d)", v45);
    int v44 = *(_DWORD *)a1;
  }

  if (!v44) {
    sub_100046EB4();
  }
  return v39;
}

const char *sub_10003D968(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)a1 != 3 || v2 != 0)
  {
    switch(v2)
    {
      case 0:
        if (*(_DWORD *)a1 != 3) {
          return (const char *)sub_10003A10C(v2);
        }
        int v4 = *(_DWORD *)(a1 + 28) & 0x7F;
        goto LABEL_9;
      case 1:
        goto LABEL_13;
      case 2:
        goto LABEL_11;
      case 7:
        uint64_t result = (const char *)xpc_exit_reason_get_label(*(void *)(a1 + 8));
        if (!result) {
          return (const char *)sub_10003A10C(v2);
        }
        return result;
      case 9:
        vm_size_t v7 = &unk_100065228;
        uint64_t v8 = *(void *)(a1 + 8);
        uint64_t v9 = 1LL;
        goto LABEL_18;
      default:
        return (const char *)sub_10003A10C(v2);
    }
  }

  int v4 = *(_DWORD *)(a1 + 28) & 0x7F;
  if (!v4) {
    return "exit()";
  }
LABEL_9:
  if (!v4 || v4 == 127) {
    return (const char *)sub_10003A10C(v2);
  }
LABEL_11:
  int v5 = sub_10003DB64((_DWORD *)a1);
  uint64_t result = (const char *)sub_10003A0FC(v5);
  if (result) {
    return result;
  }
  if (v2 != 1) {
    return (const char *)sub_10003A10C(v2);
  }
LABEL_13:
  vm_size_t v7 = &unk_100065238;
  LODWORD(v8) = v1;
  uint64_t v9 = 3LL;
LABEL_18:
  uint64_t result = (const char *)sub_100012B80(v8, (uint64_t)v7, v9);
  if (!result) {
    return (const char *)sub_10003A10C(v2);
  }
  return result;
}

BOOL sub_10003DA48(uint64_t a1)
{
  return *(_DWORD *)a1 == 3 && !*(_DWORD *)(a1 + 4) && (*(_BYTE *)(a1 + 28) & 0x7F) == 0;
}

uint64_t sub_10003DA74(_DWORD *a1)
{
  if (*a1 != 3 || a1[1] || (int v1 = a1[7], (v1 & 0x7F) != 0)) {
    sub_100046EB4();
  }
  return BYTE1(v1);
}

uint64_t sub_10003DAAC(uint64_t a1)
{
  return sub_10000AA58(*(void *)(a1 + 40) - *(void *)(a1 + 32));
}

uint64_t sub_10003DAB8(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

double sub_10003DAC0(uint64_t a1)
{
  *(void *)(a1 + 48) = 0LL;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)a1 = 1;
  return result;
}

uint64_t sub_10003DADC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4)) {
    return (*(unsigned __int8 *)(a1 + 16) >> 6) & 1;
  }
  else {
    return 0LL;
  }
}

BOOL sub_10003DAF8(_DWORD *a1)
{
  return *a1 == 3 || a1[1] != 0;
}

BOOL sub_10003DB1C(_DWORD *a1)
{
  int v1 = a1[1];
  if (v1 == 2) {
    return 1LL;
  }
  if (v1 || *a1 != 3) {
    return 0LL;
  }
  if ((a1[7] & 0x7F) != 0) {
    return (a1[7] & 0x7F) != 127;
  }
  return 0LL;
}

uint64_t sub_10003DB64(_DWORD *a1)
{
  int v1 = a1[1];
  if (v1 == 2) {
    return a1[2];
  }
  if (v1 || *a1 != 3 || ((uint64_t result = a1[7] & 0x7F, (_DWORD)result != 127) ? (v3 = (_DWORD)result == 0) : (v3 = 1), v3)) {
    sub_100046EB4();
  }
  return result;
}

uint64_t sub_10003DBAC(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 != 2)
  {
    if (v2)
    {
LABEL_9:
      if ((*(_BYTE *)(a1 + 17) & 2) != 0) {
        return 1LL;
      }
      return v2 == 30;
    }

    if (*(_DWORD *)a1 != 3)
    {
      int v2 = 0;
      return v2 == 30;
    }

    int v2 = 0;
    if ((*(_DWORD *)(a1 + 28) & 0x7F) == 0 || (*(_DWORD *)(a1 + 28) & 0x7F) == 0x7F) {
      return v2 == 30;
    }
  }

  unsigned int v3 = sub_10003DB64((_DWORD *)a1) - 4;
  if (v3 < 9 && ((0x1D7u >> v3) & 1) != 0) {
    return 1LL;
  }
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2) {
    goto LABEL_9;
  }
  return v2 == 30;
}

uint64_t sub_10003DC40(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 17) >> 2) & 1;
}

BOOL sub_10003DC4C(_DWORD *a1)
{
  int v1 = a1[1];
  return (*a1 == 3 || v1 != 0) && v1 == 1;
}

BOOL sub_10003DC64(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  if (!v2 || v1 != 1) {
    return 0LL;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  return v5 == 2 || v5 == 7;
}

BOOL sub_10003DC94(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  return v2 && v1 == 1 && *(void *)(a1 + 8) == 9LL;
}

BOOL sub_10003DCC0(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  return v2 && v1 == 9 && *(void *)(a1 + 8) == 10LL;
}

BOOL sub_10003DCEC(_DWORD *a1)
{
  int v1 = a1[1];
  return (*a1 == 3 || v1 != 0) && v1 == 3;
}

BOOL sub_10003DD04(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  return v2 && v1 == 7 && *(void *)(a1 + 8) == 3LL;
}

void sub_10003DD30(uint64_t a1)
{
}

__n128 sub_10003DD44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  vm_size_t v7 = sub_10000F7EC(a1, a2, a5);
  if (v7)
  {
    uint64_t v9 = v7;
    uint64_t v10 = sub_100016F44(0LL);
    __n128 result = *(__n128 *)a3;
    __int128 v11 = *(_OWORD *)(a3 + 16);
    v10[1] = *(_OWORD *)a3;
    v10[2] = v11;
    *((void *)v10 + 6) = a4;
    *((void *)v10 + 7) = v9;
  }

  return result;
}

uint64_t sub_10003DD90(uint64_t a1)
{
  return *(void *)(a1 + 56) + 40LL;
}

uint64_t sub_10003DD9C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 16LL);
}

uint64_t sub_10003DDA8(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 24LL);
}

uint64_t sub_10003DDB4()
{
  return 5LL;
}

uint64_t *sub_10003DDD8(uint64_t a1, int a2)
{
  if (dword_10006A664) {
    return (uint64_t *)5;
  }
  __n128 result = sub_10003DE1C(a2, 1);
  if (result)
  {
    dispatch_source_merge_data((dispatch_source_t)result[3], 0x45uLL);
    return 0LL;
  }

  return result;
}

uint64_t *sub_10003DE1C(int a1, int a2)
{
  int v5 = a1;
  for (__n128 result = (uint64_t *)qword_10006A6D0[sub_100012B1C(&v5, 4LL) % 0x35uLL]; result; __n128 result = (uint64_t *)*result)
  {
  }

  return result;
}

uint64_t sub_10003DEAC()
{
  return 5LL;
}

uint64_t sub_10003DED0()
{
  return 5LL;
}

uint64_t sub_10003DEF4()
{
  return 5LL;
}

double sub_10003DF18()
{
  qword_10006A670 = 0LL;
  double result = 0.0;
  xmmword_10006A650 = 0u;
  unk_10006A660 = 0u;
  return result;
}

__int128 *sub_10003DF34()
{
  return &xmmword_10006A650;
}

void sub_10003DF40()
{
  byte_10006A678 = 1;
}

_DWORD *sub_10003DF50(int a1, uint64_t a2)
{
  if (qword_10006A680 != -1) {
    dispatch_once_f(&qword_10006A680, 0LL, (dispatch_function_t)sub_10003E028);
  }
  uint64_t v4 = qword_10006A688;
  if (qword_10006A688 == qword_100069A00)
  {
    qword_10006A690 = (uint64_t)sub_100010B5C((void *)qword_10006A690, 8 * (int)qword_10006A688, 16 * qword_10006A688);
    double result = sub_100010B5C((void *)qword_10006A698, 4 * (int)qword_100069A00, 8 * qword_100069A00);
    qword_10006A698 = (uint64_t)result;
    qword_100069A00 *= 2LL;
    uint64_t v4 = qword_10006A688;
  }

  else
  {
    double result = (_DWORD *)qword_10006A698;
  }

  *(void *)(qword_10006A690 + 8 * v4) = a2;
  result[v4] = a1;
  qword_10006A688 = v4 + 1;
  return result;
}

void *sub_10003E028()
{
  double result = (void *)sub_10003E190(dword_10006A940, 0LL);
  if ((unint64_t)qword_100069A00 >> 61
    || (double result = sub_100010B00(8 * qword_100069A00),
        qword_10006A690 = (uint64_t)result,
        (unint64_t)qword_100069A00 >> 62)
    || (double result = sub_100010B00(4 * qword_100069A00),
        qword_10006A698 = (uint64_t)result,
        (unint64_t)qword_100069A08 >> 61))
  {
    __break(1u);
  }

  else
  {
    double result = sub_100010B00(8 * qword_100069A08);
    qword_10006A6A8 = (uint64_t)result;
    *double result = sub_100041FD8;
    qword_10006A6A0 = 1LL;
    qword_10006A6B0 = 40LL;
  }

  return result;
}

void *sub_10003E0D4(uint64_t a1, unint64_t a2)
{
  if (qword_10006A680 != -1) {
    dispatch_once_f(&qword_10006A680, 0LL, (dispatch_function_t)sub_10003E028);
  }
  uint64_t v4 = qword_10006A6A0;
  double result = (void *)qword_10006A6A8;
  if (qword_10006A6A0 == qword_100069A08)
  {
    double result = sub_100010B5C((void *)qword_10006A6A8, 8 * (int)qword_10006A6A0, 16 * qword_10006A6A0);
    qword_10006A6A8 = (uint64_t)result;
    qword_100069A08 *= 2LL;
    uint64_t v4 = qword_10006A6A0;
  }

  result[v4] = a1;
  qword_10006A6A0 = v4 + 1;
  if (qword_10006A6B0 < a2) {
    qword_10006A6B0 = a2;
  }
  return result;
}

uint64_t sub_10003E190(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100010B00(0x30uLL);
  _OWORD v4[4] = a1;
  *((_BYTE *)v4 + 40) = 0;
  *((void *)v4 + 4) = a2;
  uint64_t v5 = sub_100011938();
  uint64_t f = dispatch_mach_create_f("server", v5, v4, sub_10003EE6C);
  *((void *)v4 + 3) = f;
  if (dword_10006A940 == (_DWORD)a1) {
    qword_10006A878 = f;
  }
  int v7 = sub_10000AC54(a1);
  if (v7) {
    _os_assumes_log(v7);
  }
  sub_10003E528((uint64_t)v4);
  return dispatch_mach_connect(*((void *)v4 + 3), a1, 0LL, 0LL);
}

uint64_t *sub_10003E23C(int a1)
{
  int v1 = sub_10003DE1C(a1, 0);
  if (!v1) {
    sub_100039448("attempt to remove non-existent server port");
  }
  BOOL v2 = v1;
  dispatch_mach_cancel(v1[3]);
  return sub_10003E448(v2);
}

uint64_t sub_10003E27C(mach_port_name_t a1, int a2, uint64_t a3)
{
  if (a2 != 69) {
    sub_100046EB4();
  }
  uint64_t v5 = sub_100010B00(0x30uLL);
  v5[4] = a1;
  *((_BYTE *)v5 + 40) = 1;
  uint64_t v6 = (dispatch_queue_s *)sub_100011938();
  dispatch_source_t v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0LL, 0LL, v6);
  dispatch_set_context(v7, v5);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_10003E3EC;
  handler[3] = &unk_100065270;
  handler[4] = a3;
  void handler[5] = v7;
  dispatch_source_set_event_handler(v7, handler);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000LL;
  v13[2] = sub_10003E49C;
  v13[3] = &unk_100065290;
  _BYTE v13[4] = v7;
  dispatch_source_set_mandatory_cancel_handler(v7, v13);
  dispatch_activate(v7);
  int v8 = sub_10000ABFC(a1);
  if (v8) {
    _os_assumes_log(v8);
  }
  mach_port_name_t name = 0;
  uint64_t v9 = sub_10000ACC0(a1, dword_10006A940, &name);
  if (name)
  {
    sub_10003AB08(4, "Attempt to share port-destroyed. Ignoring.");
    int v10 = sub_10000AC70(name);
    if (v10) {
      _os_assumes_log(v10);
    }
  }

  *((void *)v5 + 3) = v7;
  sub_10003E528((uint64_t)v5);
  return v9;
}

uint64_t *sub_10003E3EC(uint64_t a1)
{
  BOOL v2 = *(dispatch_object_s **)(a1 + 40);
  context = (dispatch_object_s **)dispatch_get_context(v2);
  if (v2 != context[3]) {
    sub_100046EB4();
  }
  uint64_t v4 = (uint64_t *)context;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
  return sub_10003E448(v4);
}

uint64_t *sub_10003E448(uint64_t *result)
{
  uint64_t v1 = *result;
  if (*result == -1)
  {
    uint64_t v2 = result[1];
    if (v2 == -1) {
      sub_100039448("multiple removals of port entry");
    }
    goto LABEL_5;
  }

  if (v1)
  {
    uint64_t v2 = result[1];
LABEL_5:
    *(void *)(v1 + 8) = v2;
  }

  *(void *)result[1] = v1;
  *double result = -1LL;
  result[1] = -1LL;
  return result;
}

void sub_10003E49C(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(a1 + 32);
  context = dispatch_get_context(v2);
  if (v2 != *((dispatch_object_s **)context + 3)) {
    sub_100046EB4();
  }
  uint64_t v4 = context;
  char v5 = *((_BYTE *)context + 41);
  mach_port_name_t v6 = *((_DWORD *)context + 4);
  if ((v5 & 1) != 0)
  {
    sub_10003AB08(4, "Abandoning send right to 0x%x (canceled notification)", v6);
  }

  else
  {
    int v7 = sub_10000AC70(v6);
    if (v7) {
      _os_assumes_log(v7);
    }
  }

  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  free(v4);
}

unint64_t sub_10003E528(uint64_t a1)
{
  int v5 = *(_DWORD *)(a1 + 16);
  unint64_t result = sub_100012B1C(&v5, 4LL);
  unsigned int v3 = &qword_10006A6D0[result % 0x35];
  uint64_t v4 = *v3;
  *(void *)a1 = *v3;
  if (v4) {
    *(void *)(v4 + 8) = a1;
  }
  *unsigned int v3 = a1;
  *(void *)(a1 + 8) = v3;
  return result;
}

uint64_t *sub_10003E5AC(int a1)
{
  uint64_t v1 = sub_10003DE1C(a1, 1);
  if (!v1) {
    sub_100039448("attempt to cancel notification on non-existent port entry");
  }
  uint64_t v2 = v1;
  dispatch_source_cancel((dispatch_source_t)v1[3]);
  *((_BYTE *)v2 + 41) |= 1u;
  return sub_10003E448(v2);
}

void sub_10003E5F8(unsigned int a1, void *a2)
{
  unsigned int v3 = sub_1000167D8(a2, 0LL, a1);
  sub_10003E648(a2, "dispatching request");
  uint64_t v4 = (dispatch_queue_s *)sub_100011938();
  dispatch_async_f(v4, v3, (dispatch_function_t)sub_10003E720);
}

void sub_10003E648(void *a1, const char *a2)
{
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  if (byte_10006A9E3)
  {
    memset(v9, 0, sizeof(v9));
    uint int64 = xpc_dictionary_get_uint64(a1, "subsystem");
    int v5 = xpc_dictionary_get_uint64(a1, "routine");
    xpc_dictionary_get_audit_token(a1, &v7);
    mach_port_name_t v6 = sub_100039990((uint64_t)&v7, (char *)v9);
    sub_10003AB08(5, "ipc: caller = %s.%d, subsysteuint64_t m = %d, routine = %d, %s", v6, DWORD1(v8), uint64, v5, a2);
  }

void sub_10003E720(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = sub_10003DE1C(*(_DWORD *)(a1 + 16), 0);
  if (v4) {
    qword_10006A670 = v4[4];
  }
  sub_10003E648(v2, "processing dispatched request");
  sub_10003E820(v3, v2);
  qword_10006A670 = 0LL;
  sub_100016880((void **)a1);
}

void sub_10003E78C( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_10003E820(uint64_t a1, void *a2)
{
  if (byte_10006A6C8 == 1) {
    sub_100039448("attempt to re-enter the server layer");
  }
  uint64_t v4 = sub_10003DE1C(a1, 0);
  if (v4) {
    qword_10006A670 = v4[4];
  }
  xpc_object_t value = xpc_dictionary_get_value(a2, "mig-request");
  if (value)
  {
    mach_port_name_t v6 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_data)
    {
      byte_10006A950 = 1;
      bytes_ptr = xpc_data_get_bytes_ptr(v6);
      if (xpc_data_get_length(v6) <= 0x17) {
        sub_100039448("Message buffer was shorter than mach_msg_header");
      }
      size_t v8 = qword_10006A6B0;
      __chkstk_darwin();
      bzero((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), v8);
      bzero((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), v8);
      int v9 = _xpc_pipe_handle_mig(bytes_ptr, (char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL), sub_10003E99C);
      if (v9) {
        _os_assumes_log(v9);
      }
      byte_10006A950 = 0;
    }
  }

  else
  {
    sub_10003EB3C(a1, 0LL, a2);
  }

  qword_10006A670 = 0LL;
}

uint64_t sub_10003E99C(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = sub_10000ACF4((uint64_t)a1);
  __int128 v5 = *(_OWORD *)(v4 + 16);
  xmmword_10006A650 = *(_OWORD *)v4;
  unk_10006A660 = v5;
  qword_10006A6B8 = (uint64_t)a1;
  qword_10006A6C0 = ((a1[1] + 3LL) & 0x1FFFFFFFCLL) + 52;
  if (qword_10006A6A0)
  {
    uint64_t v6 = 0LL;
    while (!(*(unsigned int (**)(_DWORD *, uint64_t))(qword_10006A6A8 + 8 * v6))(a1, a2))
    {
    }

    uint64_t result = 1LL;
  }

  else
  {
LABEL_5:
    memset(v10, 0, sizeof(v10));
    __int128 v7 = sub_100039990((uint64_t)&xmmword_10006A650, (char *)v10);
    sub_10003AB08( 65540,  "%s.%d sent an invalid request: msgh_bits = 0x%x, msgh_size = %u, msgh_remote_uint64_t port = 0x%x, msgh_local_uint64_t port = 0x%x, msgh_id = 0x%x",  v7,  *(_DWORD *)(v4 + 20),  *a1,  a1[1],  a1[2],  a1[3],  a1[5]);
    if (byte_10006A9B5)
    {
      sub_10003AB08(65541, "Killing sender of bogus IPC message: %s.%d", v7, *(_DWORD *)(v4 + 20));
      int v8 = sub_10003A3A0(*(unsigned int *)(v4 + 20), 2u, (uint64_t)"unknown IPC", 0LL);
      if (v8) {
        _os_assumes_log(v8);
      }
    }

    uint64_t result = 0LL;
  }

  qword_10006A6B8 = 0LL;
  qword_10006A6C0 = 0LL;
  return result;
}

void sub_10003EB3C(uint64_t a1, uint64_t a2, xpc_object_t xdict)
{
  if (byte_10006A6C8 == 1) {
    sub_100039448("reentrant call into server layer", a2, xdict);
  }
  uint64_t v4 = a2;
  byte_10006A6C8 = 1;
  byte_10006A678 = 0;
  xpc_dictionary_set_value(xdict, "mig-request", 0LL);
  xpc_object_t xdicta = 0LL;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  xpc_dictionary_get_audit_token(xdict, &v24);
  xmmword_10006A650 = v24;
  unk_10006A660 = v25;
  if ((_DWORD)v4)
  {
    if (v4 <= 0x513)
    {
      uint64_t v6 = (unsigned __int16)v4 / 0x64u;
      if (((0x861uLL >> v6) & 1) == 0)
      {
        int v7 = dword_1000495FC[v6];
        xpc_dictionary_set_uint64(xdict, "subsystem", v7);
        xpc_dictionary_set_uint64(xdict, "routine", v4);
        goto LABEL_9;
      }
    }

void sub_10003EE6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 24));
    free((void *)a1);
  }

  else
  {
    uint64_t v4 = *(unsigned int *)(a1 + 16);
    if (a2 == 7)
    {
      uint64_t msg = dispatch_mach_msg_get_msg(a3, 0LL);
      uint64_t v6 = (const void *)*(unsigned int *)(msg + 8);
      int v7 = *(_DWORD *)(msg + 12);
      if ((v7 + 1) >= 2)
      {
        if ((_DWORD)v4 != v7) {
          sub_1000479B8(v6);
        }
        int v8 = sub_10000AC70(v4);
        if (v8) {
          _os_assumes_log(v8);
        }
        int v9 = sub_10000AC84(v4, 0, *(void *)(a1 + 32));
        if (v9) {
          sub_100046EF4(v9);
        }
      }
    }

    else if (a2 == 2)
    {
      qword_10006A670 = *(void *)(a1 + 32);
      sub_10003EF4C(v4, a3);
      qword_10006A670 = 0LL;
    }
  }

void sub_10003EF4C(uint64_t a1, uint64_t a2)
{
  unint64_t v15 = 0LL;
  uint64_t msg = dispatch_mach_msg_get_msg(a2, &v15);
  xpc_object_t v14 = 0LL;
  if (v15 <= 0x17) {
    sub_100039448("Message buffer was shorter than mach_msg_header");
  }
  uint64_t v5 = msg;
  int v6 = *(_DWORD *)(msg + 20);
  unsigned int v7 = v6 & 0xFF000000;
  if ((v6 & 0xFF000000) == 0x40000000 || v7 == 0x10000000)
  {
    *(_DWORD *)(msg + 20) = v7;
    if (!xpc_receive_mach_msg(a2, 0LL, 0LL, 0LL, &v14))
    {
      sub_1000342B0((uint64_t)v14);
      sub_10003EB3C(a1, v6 & 0xFFFFFF, v14);
      xpc_release(v14);
      sub_1000342B0(0LL);
    }
  }

  else
  {
    size_t v9 = qword_10006A6B0;
    __chkstk_darwin();
    bzero((char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL), v9);
    bzero((char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL), v9);
    int v10 = _xpc_pipe_handle_mig(v5, (char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL), sub_10003E99C);
    if (v10)
    {
      int v11 = v10;
      if (v10 == 22)
      {
        sub_10003AB08(65539, "Rejected invalid request.");
      }

      else
      {
        int v12 = strerror(v10);
        sub_10003AB08(65539, "Rejected bogus request: %d: %s", v11, v12);
      }
    }
  }

void sub_10003F0E8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) != -1LL || *(void *)(a1 + 24) != -1LL) {
    sub_100039448("endpoint deallocation while still in service list");
  }
  if (*(void *)(a1 + 32) != -1LL || *(void *)(a1 + 40) != -1LL) {
    sub_100039448("endpoint deallocation while still in domain list");
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  if ((v9 & 1) != 0) {
    sub_100039448("endpoint deallocation while still active");
  }
  if ((v9 & 2) != 0) {
    sub_100039448("endpoint deallocation while still being watched");
  }
  if ((v9 & 0x20) == 0 && (*(_BYTE *)(a1 + 88) & 0x20) != 0) {
    sub_100039448("endpoint deallocation without cancellation");
  }
  if (*(void *)(a1 + 104))
  {
    if ((v9 & 0x88) == 0)
    {
      mach_port_name_t v10 = sub_10003F1E0(a1, 4, a3, a4, a5, a6, a7, a8);
    }

    xpc_release(*(xpc_object_t *)(a1 + 104));
  }

uint64_t sub_10003F1E0( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  uint64_t result = sub_10003FBB0(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result) {
    return xpc_mach_send_get_right(result);
  }
  return result;
}

uint64_t sub_10003F214( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1LL;
}

void sub_10003F248( uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v19 = (const char **)sub_10000D8E8(0x40uLL);
  uint64_t v20 = *(void *)(a1 + 96);
  if (v20)
  {
    unint64_t v21 = sub_10001C2A0(v20, 1);
    sub_10000D960((uint64_t)v19, "%s - ", v22, v23, v24, v25, v26, v27, (char)v21);
    free(v21);
  }

  sub_10000D960((uint64_t)v19, "%s", v13, v14, v15, v16, v17, v18, a1 - 88);
  int v28 = sub_10000D930(v19);
  sub_10000D938((void **)v19);
  sub_10003AE8C(v28, a2, a3, &a9, v9);
  free(v28);
}

__n128 sub_10003F318(unint64_t a1, const char *a2, unint64_t a3, unint64_t a4)
{
  unsigned int v7 = (__n128 *)sub_100016D78(a2);
  v7[6].n128_u64[0] = a1;
  v7[9].n128_u64[0] = a3;
  v7[9].n128_u64[1] = a4;
  result.n128_u64[0] = -1LL;
  result.n128_u64[1] = -1LL;
  v7[1] = result;
  _OWORD v7[2] = result;
  return result;
}

char *sub_10003F35C(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = sub_100016D78(a2);
  *((void *)v9 + 12) = a1;
  *((void *)v9 + 18) = a4;
  *((void *)v9 + 19) = a5;
  *(void *)&__int128 v10 = -1LL;
  *((void *)&v10 + 1) = -1LL;
  *((_OWORD *)v9 + 1) = v10;
  *((_OWORD *)v9 + 2) = v10;
  *((void *)v9 + 13) = xpc_retain(a3);
  *((_WORD *)v9 + 80) |= 8u;
  sub_10003F3D4((uint64_t)v9, v11, v12, v13, v14, v15, v16, v17);
  return v9;
}

uint64_t sub_10003F3D4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  if ((v9 & 1) != 0) {
    return 37LL;
  }
  if ((v9 & 8) != 0)
  {
    uint64_t v12 = *(void **)(a1 + 104);
    uintptr_t right = xpc_mach_send_get_right(v12);
    uint64_t v14 = (dispatch_queue_s *)sub_100011938();
    dispatch_source_t v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, right, 1uLL, v14);
    xpc_retain(v12);
    dispatch_set_context(v15, (void *)a1);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000LL;
    handler[2] = sub_10004078C;
    handler[3] = &unk_100065350;
    handler[4] = v15;
    dispatch_source_set_event_handler(v15, handler);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000LL;
    v17[2] = sub_1000407FC;
    v17[3] = &unk_100065370;
    _OWORD v17[4] = v15;
    v17[5] = v12;
    dispatch_source_set_mandatory_cancel_handler(v15, v17);
    dispatch_activate(v15);
    sub_1000167B0((void *)a1);
    if (*(void *)(a1 + 120)) {
      sub_100046EB4();
    }
    *(void *)(a1 + 120) = v15;
  }

  else
  {
    mach_port_name_t v10 = sub_10003F1E0(a1, 1, a3, a4, a5, a6, a7, a8);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000LL;
    v16[2] = sub_100040438;
    v16[3] = &unk_1000652D0;
    v16[4] = a1;
    sub_10000AB9C(v10, *(void *)(a1 + 112));
  }

  uint64_t result = 0LL;
  *(_WORD *)(a1 + 160) |= 1u;
  return result;
}

char *sub_10003F590(uint64_t a1, const char *a2, xpc_object_t object, uint64_t a4, _BYTE *a5, uint64_t a6)
{
  if (object == &_xpc_BOOL_false) {
    return 0LL;
  }
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_BOOL && type != (xpc_type_t)&_xpc_type_dictionary) {
    return 0LL;
  }
  xpc_type_t v14 = type;
  dispatch_source_t v15 = sub_100016D78(a2);
  uint64_t v16 = v15;
  *((void *)v15 + 12) = a1;
  *((void *)v15 + 18) = a4;
  *((void *)v15 + 19) = a6;
  *(void *)&__int128 v17 = -1LL;
  *((void *)&v17 + 1) = -1LL;
  *((_OWORD *)v15 + 1) = v17;
  *((_OWORD *)v15 + 2) = v17;
  if (v14 == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_10003F700;
    applier[3] = &unk_1000652B0;
    applier[4] = v15;
    void applier[5] = a5;
    xpc_dictionary_apply(object, applier);
  }

  if (v16[88] < 0 && (*((_WORD *)v16 + 80) & 4) != 0)
  {
    sub_100011A84(a5, 3LL, "%s: _ExperimentalNonLaunching is not compatible with HideUntilCheckIn, ignoring", v16 + 168);
    sub_10001685C(v16);
    return 0LL;
  }

  if (strlen(v16 + 168) >= 0xFF) {
    sub_100011A84(a5, 4LL, "The endpoint name %s is too long to support some features", v16 + 168);
  }
  __int16 v18 = *((_WORD *)v16 + 80);
  if ((v18 & 4) == 0) {
    *((_WORD *)v16 + 80) = v18 | 0x200;
  }
  return v16;
}

uint64_t sub_10003F700(uint64_t a1, const char *a2, xpc_object_t object)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(_BYTE **)(a1 + 40);
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_int64)
  {
    if (type == (xpc_type_t)&_xpc_type_BOOL)
    {
      if (!strcasecmp(a2, "ResetAtClose"))
      {
        __int16 v11 = *(_WORD *)(v6 + 160) & 0xFFEF | (16 * (object == &_xpc_BOOL_true));
      }

      else if (!strcasecmp(a2, "HideUntilCheckIn"))
      {
        sub_100011A84( v5,  4LL,  "The HideUntilCheckIn property is an architectural performance issue. Please transition away from it.");
        __int16 v11 = *(_WORD *)(v6 + 160) & 0xFFFB | (4 * (object == &_xpc_BOOL_true));
      }

      else
      {
        if (strcasecmp(a2, "_ExperimentalNonLaunching"))
        {
          if (!strcasecmp(a2, "ExceptionServer"))
          {
            sub_100011A84(v5, 3LL, "An empty dictionary needs to be used as the value for %s.");
            return 1LL;
          }

          goto LABEL_20;
        }

        if (object != &_xpc_BOOL_true) {
          return 1LL;
        }
        *(_BYTE *)(v6 + 88) |= 0x80u;
        __int16 v11 = *(_WORD *)(v6 + 160) | 0x400;
      }

      *(_WORD *)(v6 + 160) = v11;
      return 1LL;
    }

    if (type != (xpc_type_t)&_xpc_type_string)
    {
      if (type != (xpc_type_t)&_xpc_type_dictionary) {
        return 1LL;
      }
      if (!strcmp(a2, "ExceptionServer"))
      {
        if (xpc_dictionary_get_count(object)) {
          sub_100011A84(v5, 3LL, "Non-empty dictionary property on MachService: %s");
        }
        else {
          *(_BYTE *)(v6 + 88) |= 0x10u;
        }
        return 1LL;
      }

uint64_t sub_10003F9E0(uint64_t result)
{
  *(_WORD *)(result + 160) |= 0x200u;
  return result;
}

__n128 sub_10003F9F0(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  int64_t v8 = (__n128 *)sub_100016D78((const char *)(a1 + 168));
  v8[6].n128_u64[0] = a3;
  v8[9].n128_u64[0] = a2;
  v8[9].n128_u64[1] = a4;
  result.n128_u64[0] = -1LL;
  result.n128_u64[1] = -1LL;
  v8[1] = result;
  v8[2] = result;
  v8[10].n128_u16[0] = v8[10].n128_u16[0] & 0xFFEB | *(_WORD *)(a1 + 160) & 0x14;
  return result;
}

xpc_object_t sub_10003FA58(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_string(v4, launch_perfcheck_property_endpoint_name, (const char *)(a1 + 168));
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_active, *(_WORD *)(a1 + 160) & 1);
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_needs_activation, (*(_WORD *)(a1 + 160) & 0x200) != 0);
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_event, (*(_BYTE *)(a1 + 88) & 8) != 0);
  xpc_dictionary_set_BOOL(v4, "XPCServiceEndpointNonLaunching", *(_BYTE *)(a1 + 88) >> 7);
  if (a2)
  {
    __int16 v11 = (void *)sub_10003FB6C(a1, 1, v5, v6, v7, v8, v9, v10);
    if (v11)
    {
      int v12 = v11;
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_mach_send) {
        xpc_dictionary_set_value(v4, "XPCServiceEndpointPort", v12);
      }
    }
  }

  return v4;
}

uint64_t sub_10003FB6C( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  if ((*(_WORD *)(a1 + 160) & 5) == 4) {
    return 0LL;
  }
  else {
    return sub_10003FBB0(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_10003FBB0( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(a1 + 104))
  {
    int v9 = a2 & 7;
    switch(v9)
    {
      case 1:
        __int16 v10 = *(_WORD *)(a1 + 160);
        if ((v10 & 8) != 0) {
          sub_100046EB4();
        }
        if ((v10 & 1) != 0) {
          sub_100046EB4();
        }
        if ((v10 & 0x20) != 0)
        {
          sub_10003F248(a1, 4, "Refusing to make a port for a canceled endpoint", a4, a5, a6, a7, a8, v19);
        }

        else
        {
          v20.reserved[1] = 0LL;
          *(_OWORD *)&v20.uint32_t flags = xmmword_100049630;
          uint64_t v11 = *(void *)(*(void *)(a1 + 96) + 248LL);
          int v12 = (const char *)(a1 + 168);
          uint64_t v13 = (const char **)sub_10002A994(v11);
          if (sub_1000259FC(v11))
          {
            char v14 = 1;
          }

          else if (v13 == (const char **)&unk_100069640 || v13 == (const char **)&unk_1000696C8)
          {
            char v14 = 2;
          }

          else
          {
            char v14 = 5;
          }

          memset(v21, 0, sizeof(v21));
          char v22 = v14;
          __strlcpy_chk(v21, v12, 255LL, 255LL);
          v20.uint32_t flags = 1079;
          v20.reserved[0] = (uint64_t)v21;
          if ((sub_1000032C4(*(void *)(a1 + 96), 4) & 1) == 0) {
            v20.uint32_t flags = 9271;
          }
          mach_port_context_t v16 = qword_100069A10++;
          uint64_t v17 = sub_10000AB40(&v20, v16);
          *(void *)(a1 + 112) = v16;
          *(void *)(a1 + 104) = xpc_mach_send_create_with_disposition(v17, 17LL);
          if ((*(_WORD *)(a1 + 160) & 0x402) == 2) {
            sub_1000401E0((void *)a1);
          }
        }

        break;
      case 2:
        break;
      case 4:
        sub_100039448("GET_PORT_FORCE for endpoint %s but port not yet made", (const char *)(a1 + 168));
      default:
        sub_100039448("Invalid get_port() flags");
    }
  }

  return *(void *)(a1 + 104);
}

uint64_t sub_10003FDE0(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  return *(void *)(a1 + 96);
}

BOOL sub_10003FE08(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  return (*(_WORD *)(a1 + 160) & 8) == 0;
}

uint64_t sub_10003FE38( uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface", a2);
  }
  sub_10003D32C(a2, a3, "%s = {", a4, a5, a6, a7, a8, a1 + 168);
  uint64_t v22 = sub_10003F1E0(a1, 2, v11, v12, v13, v14, v15, v16);
  pxpc_type_t type = 0;
  if ((_DWORD)v22 && (mach_port_type(mach_task_self_, v22, &ptype) || (ptype & 0x100000) != 0))
  {
    *(_BYTE *)(a1 + 88) |= 0x40u;
    uint64_t v23 = " (dead)";
  }

  else
  {
    uint64_t v23 = "";
  }

  sub_10003D32C(a2, a3 + 1, "uint64_t port = 0x%x%s", v17, v18, v19, v20, v21, v22, v23);
  uint64_t v29 = *(unsigned int *)(a1 + 84);
  if ((_DWORD)v29)
  {
    uint64_t v68 = mach_host_special_port_description(*(unsigned int *)(a1 + 84));
    sub_10003D32C(a2, a3 + 1, "host-special uint64_t port = %u (%s)", v30, v31, v32, v33, v34, v29, v68);
  }

  else
  {
    uint64_t v35 = *(unsigned int *)(a1 + 80);
    if ((_DWORD)v35)
    {
      if ((_DWORD)v35 == 128)
      {
        unsigned int v36 = "exception";
      }

      else
      {
        unsigned int v36 = (const char *)mach_task_special_port_description(v35);
        uint64_t v35 = *(unsigned int *)(a1 + 80);
      }

      sub_10003D32C(a2, a3 + 1, "task-special uint64_t port = %u (%s)", v24, v25, v26, v27, v28, v35, v36);
    }
  }

  if ((*(_WORD *)(a1 + 160) & 1) != 0) {
    int v37 = "1";
  }
  else {
    int v37 = "0";
  }
  sub_10003D32C(a2, a3 + 1, "active = %s", v24, v25, v26, v27, v28, v37);
  if ((*(_WORD *)(a1 + 160) & 8) != 0) {
    __int128 v43 = "0";
  }
  else {
    __int128 v43 = "1";
  }
  sub_10003D32C(a2, a3 + 1, "managed = %s", v38, v39, v40, v41, v42, v43);
  if ((*(_WORD *)(a1 + 160) & 0x10) != 0) {
    uint64_t v49 = "1";
  }
  else {
    uint64_t v49 = "0";
  }
  sub_10003D32C(a2, a3 + 1, "reset = %s", v44, v45, v46, v47, v48, v49);
  if ((*(_WORD *)(a1 + 160) & 4) != 0) {
    uint64_t v55 = "1";
  }
  else {
    uint64_t v55 = "0";
  }
  sub_10003D32C(a2, a3 + 1, "hide = %s", v50, v51, v52, v53, v54, v55);
  if ((*(_WORD *)(a1 + 160) & 2) != 0) {
    uint64_t v61 = "1";
  }
  else {
    uint64_t v61 = "0";
  }
  sub_10003D32C(a2, a3 + 1, "watching = %s", v56, v57, v58, v59, v60, v61);
  if ((*(_WORD *)(a1 + 160) & 0x400) != 0) {
    sub_10003D32C(a2, a3 + 1, "non-launching = 1", v62, v63, v64, v65, v66);
  }
  return sub_10003D32C(a2, a3, "}", v62, v63, v64, v65, v66);
}

void *sub_100040070(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  __int16 v2 = *(_WORD *)(a1 + 160);
  if ((v2 & 8) != 0) {
    sub_100039448("attempt to watch unmanaged endpoint");
  }
  if ((v2 & 2) != 0) {
    sub_100039448("attempt to watch endpoint that is already watched");
  }
  if ((v2 & 1) != 0) {
    sub_100039448("attempt to watch an active endpoint");
  }
  if ((v2 & 0x50) == 0x10)
  {
    sub_100040138((void *)a1);
    __int16 v2 = *(_WORD *)(a1 + 160);
  }

  *(_WORD *)(a1 + 160) = v2 & 0xFFBD | 2;
  __n128 result = (void *)sub_1000208CC(*(void *)(a1 + 96), 1);
  if ((_DWORD)result) {
    *(_WORD *)(a1 + 160) |= 0x400u;
  }
  if (*(void *)(a1 + 104))
  {
    if ((*(_WORD *)(a1 + 160) & 0x400) == 0) {
      return sub_1000401E0((void *)a1);
    }
  }

  return result;
}

void sub_100040138(void *a1)
{
  if (a1[16]) {
    sub_100046EB4();
  }
  if (a1[15]) {
    sub_100046EB4();
  }
  uint64_t v2 = a1[13];
  if (v2)
  {
    uint64_t v3 = a1[14];
    a1[13] = 0LL;
    sub_1000167B0(a1);
    xpc_object_t v4 = (dispatch_queue_s *)sub_100011938();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_1000406C8;
    block[3] = &unk_1000652F0;
    block[4] = v2;
    void block[5] = v3;
    block[6] = a1;
    dispatch_async(v4, block);
  }

void *sub_1000401E0(void *a1)
{
  uint64_t v2 = (void *)a1[13];
  uintptr_t right = xpc_mach_send_get_right(v2);
  xpc_object_t v4 = (dispatch_queue_s *)sub_100011938();
  dispatch_source_t v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_recv, right, 0x8000uLL, v4);
  dispatch_set_context(v5, a1);
  xpc_retain(v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_10004072C;
  handler[3] = &unk_100065310;
  handler[4] = v5;
  dispatch_source_set_event_handler(v5, handler);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  _OWORD v7[2] = sub_10004074C;
  void v7[3] = &unk_100065330;
  _OWORD v7[4] = v5;
  void v7[5] = v2;
  dispatch_source_set_cancel_handler(v5, v7);
  dispatch_activate(v5);
  __n128 result = sub_1000167B0(a1);
  if (a1[16]) {
    sub_100046EB4();
  }
  a1[16] = v5;
  return result;
}

void sub_1000402E8( uint64_t a1, integer_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_name_t v10 = sub_10003F1E0(a1, 2, a3, a4, a5, a6, a7, a8);
  if (v10 - 1 <= 0xFFFFFFFD)
  {
    integer_t port_info = a2;
    if (mach_port_set_attributes(mach_task_self_, v10, 9, &port_info, 1u))
    {
      uint64_t v16 = "mark";
      if (!port_info) {
        uint64_t v16 = "unmark";
      }
      sub_10001A4D8( *(void *)(a1 + 96),  4,  "Failed to %s endpoint '%s' as throttled",  v11,  v12,  v13,  v14,  v15,  (char)v16);
    }

    if (a2) {
      __int16 v17 = 2048;
    }
    else {
      __int16 v17 = 0;
    }
    *(_WORD *)(a1 + 160) = *(_WORD *)(a1 + 160) & 0xF7FF | v17;
  }

void sub_1000403A0(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  __int16 v2 = *(_WORD *)(a1 + 160);
  if ((v2 & 8) != 0) {
    sub_100039448("attempt to ignore unmanaged endpoint");
  }
  if ((v2 & 2) == 0) {
    sub_100039448("attempt to ignore endpoint that is already ignored");
  }
  *(_WORD *)(a1 + 160) = v2 & 0xFFFD;
  uint64_t v3 = *(dispatch_source_s **)(a1 + 128);
  if ((v2 & 0x400) != 0 || !*(void *)(a1 + 104))
  {
    if (v3) {
      sub_100039448("endpoint %s has unexpected receive_source", (const char *)(a1 + 168));
    }
  }

  else
  {
    dispatch_source_cancel(v3);
    *(void *)(a1 + 128) = 0LL;
  }

uint64_t sub_100040438( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 32);
  if ((*(_WORD *)(v8 + 160) & 0x10) != 0)
  {
    sub_100040138(*(void **)(a1 + 32));
  }

  else
  {
    mach_port_name_t v9 = sub_10003F1E0(*(void *)(a1 + 32), 4, a3, a4, a5, a6, a7, a8);
    sub_10000ABB4(v9, *(void *)(v8 + 112));
  }

  __int16 v17 = *(_WORD *)(v8 + 160);
  *(_WORD *)(v8 + 160) = v17 & 0xFFBE | 0x40;
  if ((v17 & 0x100) != 0)
  {
    sub_100040590(v8, v10, v11, v12, v13, v14, v15, v16);
    *(_WORD *)(v8 + 160) &= ~0x100u;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v8 + 144))(v8, 1LL, *(void *)(v8 + 152));
}

void sub_1000404D4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100039448("alias endpoint given to endpoint interface");
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  *(_WORD *)(a1 + 160) = v9 | 0x20;
  if ((v9 & 2) != 0)
  {
    sub_1000403A0(a1);
  }

  else if ((v9 & 1) != 0)
  {
    if ((v9 & 8) != 0)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
      *(void *)(a1 + 120) = 0LL;
    }

    else
    {
      int v10 = sub_10003F1E0(a1, 4, a3, a4, a5, a6, a7, a8);
      sub_10003E5AC(v10);
    }

    *(_WORD *)(a1 + 160) = *(_WORD *)(a1 + 160) & 0xFF7E | 0x80;
    (*(void (**)(uint64_t, uint64_t, void))(a1 + 144))(a1, 1LL, *(void *)(a1 + 152));
  }

void sub_100040574( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = *(_WORD *)(a1 + 160);
  if ((v8 & 0x100) == 0)
  {
    if ((v8 & 1) != 0) {
      *(_WORD *)(a1 + 160) = v8 | 0x100;
    }
    else {
      sub_100040590(a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }

void sub_100040590( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_msg_return_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE msg[32];
  if ((*(_WORD *)(a1 + 160) & 1) != 0) {
    sub_100039448("attempt to drain active endpoint");
  }
  mach_port_name_t v9 = sub_10003F1E0(a1, 2, a3, a4, a5, a6, a7, a8);
  if (v9 - 1 <= 0xFFFFFFFD)
  {
    mach_port_name_t v10 = v9;
    int v11 = 20;
    do
    {
      memset(msg, 0, sizeof(msg));
      uint64_t v12 = mach_msg((mach_msg_header_t *)msg, 258, 0, 0x20u, v10, 0, 0);
      if (v12)
      {
        if (v12 == 268451843) {
          return;
        }
      }

      else
      {
        sub_10003F248(a1, 5, "draining message: id = 0x%x", v13, v14, v15, v16, v17, msg[20]);
        mach_msg_destroy((mach_msg_header_t *)msg);
      }

      --v11;
    }

    while (v11);
  }

void sub_100040664(uint64_t a1, int a2, _BYTE *a3)
{
  if (a2 < 7 || a2 == 9)
  {
    sub_100011A84(a3, 3LL, "Tried to set a reserved task special port: %d");
  }

  else if (a2 > 11)
  {
    sub_100011A84(a3, 3LL, "Bogus TaskSpecialPort number: %d");
  }

  else
  {
    *(_DWORD *)(a1 + 80) = a2;
  }

void sub_1000406C8(uint64_t a1)
{
  mach_port_name_t right = xpc_mach_send_get_right(*(void *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  sub_10001685C(*(void **)(a1 + 48));
}

uint64_t sub_10004072C(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  return (*((uint64_t (**)(void *, void, void))context + 18))(context, 0LL, *((void *)context + 19));
}

void sub_10004074C(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  sub_10001685C(context);
  xpc_release(*(xpc_object_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_10004078C(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  *((_WORD *)context + 80) = *((_WORD *)context + 80) & 0xFFDE | 0x20;
  sub_1000167B0(context);
  (*((void (**)(void *, uint64_t, void))context + 18))(context, 1LL, *((void *)context + 19));
  dispatch_source_cancel(*((dispatch_source_t *)context + 15));
  *((void *)context + 15) = 0LL;
  sub_10001685C(context);
}

void sub_1000407FC(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  sub_10001685C(context);
  xpc_release(*(xpc_object_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_10004083C(uint64_t a1)
{
  return os_parse_boot_arg_from_buffer_string(qword_10006A880, a1, 0LL, 0LL);
}

char *sub_100040854()
{
  else {
    BOOL v0 = 1;
  }
  if (v0) {
    sub_100039448("no bootargs string");
  }
  uint64_t v1 = sub_100036E7C(0LL, "__TEXT", "__config");
  qword_10006A888 = (uint64_t)v1;
  if (!v1 || xpc_get_type(v1) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100039448("launchd built improperly: no __TEXT,__config");
  }
  byte_10006A9B8 = getenv("XPC_USERSPACE_REBOOTED") != 0LL;
  byte_10006A99E = os_variant_has_internal_content("com.apple.libxpc.launchd");
  if (sub_1000129E0((const char *)qword_10006A880, "rd=md0")
    || sub_10000E364("Restore")
    || sub_10000E364("Ramdisk")
    || sub_10000E364("RamDisk"))
  {
    byte_10006A99B = 1;
    byte_10006A99C = 1;
  }

  if (byte_10006A99D && byte_10006A9B8) {
    sub_100039448("after the userspace reboot, os_variant_is_basesystem() should not be true");
  }
  if (byte_10006A999)
  {
    byte_10006A99B = 0;
    byte_10006A99D = 0;
    byte_10006A99C = 0;
  }

  __int16 v2 = (const char *)qword_10006A880;
  byte_10006A9A0 = strstr((const char *)qword_10006A880, "-v") != 0LL;
  uint64_t v3 = strstr(v2, "-no-corpses");
  byte_10006A9E0 = v3 != 0LL;
  if (v3)
  {
    if (_os_alloc_once_table[2] == -1LL)
    {
      uint64_t v4 = _os_alloc_once_table[3];
      char v5 = 1;
    }

    else
    {
      uint64_t v4 = _os_alloc_once(&_os_alloc_once_table[2], 216LL, 0LL);
      char v5 = byte_10006A9E0;
      __int16 v2 = (const char *)qword_10006A880;
    }

    *(_BYTE *)(v4 + 42) = v5;
  }

  qword_10006A9D0 = sub_100039D6C(v2, "launchd_force_data_status=", 0LL);
  byte_100069A6C = sub_100039D6C((const char *)qword_10006A880, "launchd_proxyless_spawn=", 1LL) != 0;
  qword_10006A9A8 = sub_100039D6C((const char *)qword_10006A880, "launchd_instance_limit=", 0LL);
  byte_10006A9B9 = sub_100039DD8((const char *)qword_10006A880, "launchd_usr_abandon_unmanaged=") != 0;
  byte_10006A9BA = sub_100039DD8((const char *)qword_10006A880, "launchd_verbose_coalition_logs=") != 0;
  byte_10006A998 = sub_100039D6C((const char *)qword_10006A880, "launchd_workload_properties_disabled=", 0LL) != 0;
  uint64_t v6 = (const char *)qword_10006A880;
  if (strstr((const char *)qword_10006A880, "launchd_automation="))
  {
    byte_10006A99F = sub_100039DD8(v6, "launchd_automation=") != 0;
    uint64_t v6 = (const char *)qword_10006A880;
  }

  else if (strstr(v6, "BATS_TESTPLAN_ID="))
  {
    byte_10006A99F = 1;
  }

  if (sub_1000129E0(v6, "launch_prob_guard_self="))
  {
    BOOL v7 = sub_100039DD8((const char *)qword_10006A880, "launch_prob_guard_self=") != 0;
    qword_10006A9C0 = (uint64_t)xpc_BOOL_create(v7);
  }

  if (sub_1000129E0((const char *)qword_10006A880, "launch_prob_guard_sample_rate_self="))
  {
    uint64_t v8 = sub_100039DD8((const char *)qword_10006A880, "launch_prob_guard_sample_rate_self=");
    qword_10006A9C8 = (uint64_t)xpc_uint64_create(v8);
  }

  sub_100001D50(qword_10006A880, (uint64_t (*)(const char *, void **))sub_100039AB8);
  int v31 = 0;
  size_t v30 = 4LL;
  sysctlbyname("kern.minimalboot", &v31, &v30, 0LL, 0LL);
  if (v31) {
    byte_10006A930 = 1;
  }
  __str = 0LL;
  if (sub_100039AB8("kern.osrelease", &__str)) {
    qword_10006A960 = strtoul(__str, 0LL, 0);
  }
  free(__str);
  bufunint64_t size = 1024;
  _NSGetExecutablePath(byte_10006AA08, &bufsize);
  mach_port_name_t v9 = strrchr(byte_10006AA08, 47);
  mach_port_name_t v10 = "launchd";
  if (v9) {
    mach_port_name_t v10 = v9 + 1;
  }
  qword_10006A958 = (uint64_t)v10;
  byte_10006A9E1 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "LogServiceLifecycle");
  byte_10006A9E3 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "LogIPC");
  sub_100041894(&byte_10006A9E2, "LogToConsole", "launchd_log_serial=");
  byte_10006A9B3 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "UseGuardMalloc");
  byte_10006A9B4 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "UseNanoAllocator");
  byte_10006A9B5 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "AbortOnUnknownIPC");
  byte_10006A9B6 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "RequireDomainBinding");
  byte_10006A9A1 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "LogToFlatFile");
  sub_100041908(&qword_100069A60, "LogFileMaxSize");
  sub_100041958(&dword_100069A68, "LogFileVerboseMetaLimit", "launchd_log_verbose_meta_limit=");
  byte_10006A9B0 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "LogAllBootstrapErrors");
  byte_10006A9B1 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "PureOnDemand");
  if (!qword_10006A9A8)
  {
    uint64_t v34 = 0LL;
    sub_100041908(&v34, "MultipleInstanceLimit");
    unint64_t v11 = v34;
    if (v34 <= 0)
    {
      int v33 = 0;
      size_t v32 = 4LL;
      int v12 = sysctlbyname("kern.maxproc", &v33, &v32, 0LL, 0LL);
      if (v12) {
        sub_100046EF4(v12);
      }
      if (v33 <= 0) {
        sub_100046EC8();
      }
      unint64_t v11 = (unint64_t)v33 >> 1;
    }

    qword_10006A9A8 = v11;
  }

  sub_100041958(&dword_100069A38, "SIGTERMTimeout", 0LL);
  sub_100041958(&dword_100069A3C, "SIGKILLTimeout", 0LL);
  byte_10006A97C = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "CrashOnSIGTERMTimeout");
  byte_10006A9F0 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "ExtensionWatchdog");
  sub_100041958(&dword_100069A40, "ExtensionWatchdogTimeout", 0LL);
  sub_100041958(&dword_100069A44, "ShutdownTimeout", 0LL);
  sub_100041958(&dword_100069A5C, "HighWatermark", 0LL);
  uint64_t v34 = 0LL;
  byte_10006A97F = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "DisableAllMemoryLimit");
  byte_10006A980 = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, "DisableExtensionMemoryLimit");
  if (os_variant_allows_internal_security_policies("com.apple.libxpc.launchd")
    && !access("/usr/local/share/launchd-disable-memory-limits", 0))
  {
    byte_10006A97F = 1;
  }

  sub_100041958(&dword_100069A58, "SyncInterval", "launchd_sync_interval=");
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_10006A888, "Bootstrap");
  if (value)
  {
    uint64_t v14 = (uint64_t)value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary) {
      qword_10006A890 = v14;
    }
  }

  sub_100041894(&byte_10006A97D, "SuddenShutdown", "launchd_sudden_shutdown=");
  sub_100041894(&byte_10006A97E, "ServiceStubsDisabled", "launch_service_stubs_disabled=");
  if (sub_100039D6C((const char *)qword_10006A880, "launchd_disable_all_timeouts=", 0LL))
  {
    dword_100069A3C = 600;
    byte_10006A9F0 = 0;
    dword_100069A44 = 0;
    dword_10006AE08 = 0;
  }

  if (!qword_10006A890) {
    goto LABEL_72;
  }
  xpc_object_t v15 = xpc_dictionary_get_value((xpc_object_t)qword_10006A890, "Paths");
  if (v15)
  {
    uint64_t v16 = (uint64_t)v15;
    if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_array) {
      qword_10006A970 = v16;
    }
  }

  xpc_object_t v17 = sub_100041718();
  xpc_object_t v18 = v17;
  if (byte_10006A99D)
  {
    if (!v17) {
      xpc_object_t v18 = xpc_dictionary_create(0LL, 0LL, 0LL);
    }
    xpc_dictionary_set_string(v18, "__OSINSTALL_ENVIRONMENT", "1");
  }

  if (v18) {
    xpc_dictionary_apply_f(v18);
  }
  xpc_object_t v19 = xpc_dictionary_get_value((xpc_object_t)qword_10006A890, "ChildDefaults");
  if (v19)
  {
    xpc_object_t v20 = v19;
    if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_dictionary_apply_f(v20);
    }
  }

  xpc_object_t v21 = sub_1000416C4();
  if (v21)
  {
    xpc_object_t v22 = v21;
    __n128 result = (char *)xpc_dictionary_get_count(v21);
    unint64_t v24 = (unint64_t)(result + 2);
    uint64_t v25 = (unint64_t)result >= 0xFFFFFFFFFFFFFFFELL;
    if (v25 << 63 >> 63 != v25 || v25 | (v24 >> 61))
    {
      __break(1u);
      return result;
    }

    qword_10006A968 = (uint64_t)sub_100010B00(8 * v24);
    uint64_t v34 = 1LL;
    *(void *)qword_10006A968 = "XPC_FLAGS=0x0000000000000000";
    xpc_dictionary_apply_f(v22);
    *(void *)(qword_10006A968 + 8 * v34) = 0LL;
  }

  else
  {
LABEL_72:
    uint64_t v26 = sub_100010B00(0x10uLL);
    qword_10006A968 = (uint64_t)v26;
    *uint64_t v26 = "XPC_FLAGS=0x0000000000000000";
    v26[1] = 0LL;
  }

  if (!qword_10006A888)
  {
    qword_10006A9E8 = 0LL;
    goto LABEL_84;
  }

  xpc_object_t v27 = xpc_dictionary_get_value((xpc_object_t)qword_10006A888, "Boot");
  qword_10006A9E8 = (uint64_t)v27;
  if (!v27 || (__n128 result = (char *)xpc_get_type(v27), result != (char *)&_xpc_type_dictionary)) {
LABEL_84:
  }
    sub_100039448("no boot tasks");
  return result;
}

xpc_object_t sub_1000411E4(char *key)
{
  xpc_object_t result = (xpc_object_t)qword_10006A888;
  if (qword_10006A888) {
    return xpc_dictionary_get_value((xpc_object_t)qword_10006A888, key);
  }
  return result;
}

void *sub_1000411FC()
{
  if (!byte_10006A99B)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/disabled.migrated", off_100069A20[0]);
    memset(&v13, 0, sizeof(v13));
    if (stat(__str, &v13))
    {
      *(_OWORD *)uint64_t v16 = off_1000653D0;
      uint64_t v1 = fts_open(v16, 92, 0LL);
      if (v1)
      {
        __int16 v2 = v1;
        uint64_t v3 = fts_read(v1);
        if (v3)
        {
          uint64_t v4 = v3;
          uint64_t v5 = 0LL;
          do
          {
            int fts_info = v4->fts_info;
            if (fts_info == 6)
            {
              --v5;
            }

            else if (fts_info == 1)
            {
              if (v5) {
                fts_set(v2, v4, 4);
              }
              bzero(from, 0x400uLL);
              bzero(to, 0x400uLL);
              if (!strcmp(v4->fts_name, "com.apple.launchd"))
              {
                snprintf(from, 0x400uLL, "%s/overrides.plist", v4->fts_path);
                snprintf(to, 0x400uLL, "%s/disabled.plist", off_100069A20[0]);
                BOOL v7 = copyfile_state_alloc();
                if (copyfile(from, to, v7, 8u) == -1) {
                  sub_100047024();
                }
                if (copyfile_state_free(v7) == -1) {
                  sub_100047024();
                }
              }

              ++v5;
            }

            uint64_t v4 = fts_read(v2);
          }

          while (v4);
        }

        if (fts_close(v2) == -1) {
          sub_100046FF0();
        }
      }

      else
      {
        int v8 = *__error();
        mach_port_name_t v9 = __error();
        mach_port_name_t v10 = (const char *)xpc_strerror(*v9);
        sub_10003AB08(4, "failed to fts_open(/private/var/db/launchd.db, 0x%x): %d: %s", 92, v8, v10);
      }

      unint64_t v11 = (int *)open(__str, 512, 438LL);
      if ((_DWORD)v11 == -1)
      {
        if (*__error() != 30)
        {
          uint64_t v12 = *__error();
          if ((_DWORD)v12) {
            _os_assumes_log(v12);
          }
        }
      }

      else
      {
        sub_100036D70(v11);
      }
    }
  }

  qword_10006A898 = (uint64_t)sub_100012884("%s/disabled.plist", off_100069A20[0]);
  xpc_object_t result = sub_100036DB4((const char *)qword_10006A898);
  qword_10006A8A0 = (uint64_t)result;
  if (!result)
  {
    xpc_object_t result = xpc_dictionary_create(0LL, 0LL, 0LL);
    qword_10006A8A0 = (uint64_t)result;
  }

  return result;
}

void sub_1000414BC()
{
  BOOL v0 = sub_100036DB4("/private/etc/com.apple.xpc.launchd.limits.plist");
  if (v0)
  {
    uint64_t v1 = v0;
    xpc_dictionary_apply_f(v0);
    xpc_release(v1);
  }

  qword_10006A9D8 = (uint64_t)sub_10003CBF8();
  __int16 v2 = sub_100036DB4("/System/Library/UserManagement/com.apple.xpc.launchd.personas.plist");
  if (v2)
  {
    uint64_t v3 = v2;
    xpc_object_t value = xpc_dictionary_get_value(v2, "SystemPersonaServices");
    if (value)
    {
      uint64_t v5 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array) {
        xpc_array_apply(v5, &stru_100065400);
      }
    }

    xpc_release(v3);
  }

  sub_100039AB8("hw.targettype", (char **)&qword_10006A988);
  int is_darwinos = os_variant_is_darwinos("com.apple.xpc.launchd");
  BOOL v7 = "";
  if (is_darwinos) {
    BOOL v7 = ".darwin";
  }
  qword_10006A990 = (uint64_t)v7;
  sub_10000BFE4();
}

void *sub_1000415A0(char *a1, xpc_object_t object)
{
  xpc_object_t value = object;
  xpc_object_t result = xpc_get_type(value);
  if (result != &_xpc_type_array) {
    return result;
  }
  if (xpc_array_get_count(value) == 1)
  {
    xpc_object_t value = xpc_array_get_value(value, 0LL);
    xpc_object_t result = xpc_get_type(value);
    if (result == &_xpc_type_int64)
    {
LABEL_6:
      int64_t v5 = xpc_int64_get_value(value);
      uint64_t v6 = a1;
      int64_t v7 = v5;
      return (void *)sub_100039FD4(v6, v5, v7, 0);
    }
  }

  else
  {
    xpc_object_t result = (void *)xpc_array_get_count(value);
    if (result == (void *)2)
    {
      xpc_object_t v8 = xpc_array_get_value(value, 0LL);
      xpc_object_t v9 = xpc_array_get_value(value, 1uLL);
      xpc_object_t result = xpc_get_type(v8);
      if (result == &_xpc_type_int64)
      {
        xpc_object_t result = xpc_get_type(v9);
        if (result == &_xpc_type_int64)
        {
          int64_t v10 = xpc_int64_get_value(v8);
          int64_t v7 = xpc_int64_get_value(v9);
          uint64_t v6 = a1;
          int64_t v5 = v10;
          return (void *)sub_100039FD4(v6, v5, v7, 0);
        }
      }
    }
  }

  return result;
}

xpc_object_t sub_1000416C4()
{
  if (!qword_10006A890) {
    return 0LL;
  }
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_10006A890, "Self");
  if (!value) {
    return 0LL;
  }
  xpc_object_t v1 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0LL;
  }
  return v1;
}

xpc_object_t sub_100041718()
{
  if (!qword_10006A890) {
    return 0LL;
  }
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_10006A890, "Child");
  if (!value) {
    return 0LL;
  }
  xpc_object_t v1 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0LL;
  }
  return v1;
}

uint64_t sub_10004176C()
{
  return qword_10006A8A0;
}

uint64_t sub_100041778(uint64_t a1, char *__str)
{
  uint64_t result = snprintf(__str, 0x40uLL, "XPC_FLAGS=0x%llx", a1);
  *(void *)qword_10006A968 = __str;
  return result;
}

void sub_1000417C0()
{
  BOOL v0 = (void *)qword_10006A8A0;
  if (qword_10006A8A0)
  {
    xpc_object_t v1 = (const char *)qword_10006A898;
    if (xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A8A0, "_dirty"))
    {
      xpc_dictionary_set_value(v0, "_dirty", 0LL);
      xpc_object_t v2 = xpc_copy(v0);
      uint64_t v3 = sub_1000126A0(v1);
      uint64_t v4 = (dispatch_queue_s *)sub_100011950();
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000LL;
      v5[2] = sub_100041B80;
      v5[3] = &unk_100065420;
      v5[4] = v2;
      void v5[5] = v3;
      dispatch_async(v4, v5);
    }
  }

void sub_100041870()
{
  BOOL v0 = (dispatch_queue_s *)sub_100011950();
  dispatch_sync(v0, &stru_1000653B0);
}

BOOL sub_100041894(_BYTE *a1, char *key, char *__little)
{
  else {
    BOOL result = xpc_dictionary_get_BOOL((xpc_object_t)qword_10006A888, key);
  }
  *a1 = result;
  return result;
}

void *sub_100041908(void *a1, const char *a2)
{
  BOOL result = xpc_dictionary_get_value((xpc_object_t)qword_10006A888, a2);
  if (result)
  {
    uint64_t v4 = result;
    BOOL result = xpc_get_type(result);
    if (result == &_xpc_type_int64)
    {
      BOOL result = (void *)xpc_int64_get_value(v4);
      *a1 = result;
    }
  }

  return result;
}

void *sub_100041958(_DWORD *a1, char *key, char *__little)
{
  if (__little)
  {
    uint64_t v6 = (const char *)qword_10006A880;
    if (strstr((const char *)qword_10006A880, __little))
    {
      BOOL result = (void *)sub_100039DD8(v6, __little);
LABEL_7:
      *a1 = (_DWORD)result;
      return result;
    }
  }

  BOOL result = xpc_dictionary_get_value((xpc_object_t)qword_10006A888, key);
  if (result)
  {
    xpc_object_t v8 = result;
    BOOL result = xpc_get_type(result);
    if (result == &_xpc_type_int64)
    {
      BOOL result = (void *)xpc_int64_get_value(v8);
      goto LABEL_7;
    }
  }

  return result;
}

void *sub_1000419E8(char *a1, xpc_object_t object, uint64_t a3)
{
  BOOL result = xpc_get_type(object);
  if (result == (void *)&_xpc_type_string)
  {
    size_t v10 = 0LL;
    char string_ptr = xpc_string_get_string_ptr(object);
    BOOL result = sub_1000168AC(a1, string_ptr, 0LL, &v10, 1);
    if (result)
    {
      if (a3) {
        xpc_object_t v8 = &qword_10006AA00;
      }
      else {
        xpc_object_t v8 = &qword_10006A9F8;
      }
      uint64_t v9 = *v8;
      *BOOL result = *v8;
      if (v9) {
        *(void *)(v9 + 8) = result;
      }
      *xpc_object_t v8 = (uint64_t)result;
      result[1] = v8;
    }
  }

  return result;
}

uint64_t sub_100041A90(const char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_string)
  {
    uint64_t result = strcmp(a1, "MallocStackLogging");
    if ((_DWORD)result)
    {
      char string_ptr = xpc_string_get_string_ptr(object);
      uint64_t result = (uint64_t)sub_100012884("%s=%s", a1, string_ptr);
      uint64_t v8 = *a3;
      *(void *)(qword_10006A968 + 8 * *a3) = result;
      *a3 = v8 + 1;
    }
  }

  return result;
}

BOOL sub_100041B20(id a1, unint64_t a2, void *a3)
{
  if (a3 && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v4 = qword_10006A9D8;
    char string_ptr = xpc_string_get_string_ptr(a3);
    sub_10003CA78(v4, string_ptr, &_xpc_BOOL_true);
  }

  return 1;
}

void sub_100041B80(uint64_t a1)
{
  xpc_object_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = fopen(*(const char **)(a1 + 40), "w");
  if (v3)
  {
    uint64_t v4 = v3;
    fprintf( v3,  "%s\n",  "<?xml version=1.0 encoding=UTF-8?>\n <!DOCTYPE plist PUBLIC -//Apple//DTD PLIST 1.0//EN http://www.apple.com/DTDs/PropertyList-1.0.dtd>\n <plist version=1.0>");
    if (xpc_dictionary_get_count(v2))
    {
      fwrite("<dict>\n", 7uLL, 1uLL, v4);
      xpc_dictionary_apply_f(v2);
      int64_t v5 = "</dict>\n";
    }

    else
    {
      int64_t v5 = "<dict/>\n";
    }

    fwrite(v5, 8uLL, 1uLL, v4);
    fwrite("</plist>\n", 9uLL, 1uLL, v4);
    sub_100036EEC(v4);
  }

  else
  {
    uint64_t v6 = *__error();
    if ((_DWORD)v6) {
      _os_assumes_log(v6);
    }
  }

  xpc_release(*(xpc_object_t *)(a1 + 32));
  free(*(void **)(a1 + 40));
}

void *sub_100041C78(const char *a1, xpc_object_t object, FILE *a3)
{
  xpc_object_t v4 = object;
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary
    || (uint64_t result = xpc_dictionary_get_value(v4, "Disabled"), (v4 = result) != 0LL))
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_BOOL || (uint64_t result = xpc_get_type(v4), result == &_xpc_type_string))
    {
      uint64_t result = strchr(a1, 60);
      if (!result)
      {
        fprintf(a3, "\t<key>%s</key>\n", a1);
        if (v4 == &_xpc_BOOL_true)
        {
          uint64_t v8 = "\t<true/>\n";
          size_t v9 = 9LL;
        }

        else
        {
          if (v4 != &_xpc_BOOL_false)
          {
            char string_ptr = xpc_string_get_string_ptr(v4);
            return (void *)fprintf(a3, "\t<string>%s</string>\n", string_ptr);
          }

          uint64_t v8 = "\t<false/>\n";
          size_t v9 = 10LL;
        }

        return (void *)fwrite(v8, v9, 1uLL, a3);
      }
    }
  }

  return result;
}

uint64_t (*sub_100041DA8(uint64_t a1))()
{
  int v1 = *(_DWORD *)(a1 + 20);
  else {
    return 0LL;
  }
}

_DWORD *sub_100041DDC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10003DDB4();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  return result;
}

uint64_t *sub_100041E3C(uint64_t *result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 && *((_DWORD *)result + 6) == 1 && *((_DWORD *)result + 1) == 40)
  {
    if (*((unsigned __int16 *)result + 19) << 16 == 0x100000)
    {
      uint64_t result = sub_10003DDD8(*((unsigned int *)result + 3), *((_DWORD *)result + 7));
      *(_DWORD *)(a2 + 32) = (_DWORD)result;
      return result;
    }

    int v3 = -300;
  }

  else
  {
    int v3 = -304;
  }

  *(_DWORD *)(a2 + 32) = v3;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100041EC0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10003DEAC();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  return result;
}

_DWORD *sub_100041F20(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10003DED0();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  return result;
}

_DWORD *sub_100041F78(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10003DEF4();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  return result;
}

uint64_t sub_100041FD8(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 73) >= 0xFFFFFFF7
    && (int64_t v5 = (void (*)(void))off_100065440[5 * (v4 - 64) + 5]) != 0LL)
  {
    v5();
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }

  return result;
}

uint64_t sub_100042060(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  else {
    return 0LL;
  }
}

_DWORD *sub_100042094(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 552 || (uint64_t result = memchr(result + 8, 0, 0x200uLL)) == 0LL)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }

  *(void *)(a2 + 32) = 0x14000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004214C(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10000D094();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_1000421AC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 168 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0LL)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }

  *(void *)(a2 + 32) = 0x10000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D09C();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 64;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100042274(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 184) {
    goto LABEL_7;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }

  uint64_t result = (uint64_t)memchr((const void *)(result + 48), 0, 0x80uLL);
  if (!result)
  {
LABEL_7:
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }

  uint64_t result = sub_10000D09C();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100042320(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 188 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0LL)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }

  *(void *)(a2 + 32) = 0x13000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D0AC();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_1000423DC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0 && result[1] == 164 && (uint64_t result = memchr(result + 8, 0, 0x80uLL)) != 0LL)
  {
    uint64_t result = (_DWORD *)sub_10000D094();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  else
  {
    *(_DWORD *)(a2 + 32) = -304;
  }

  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100042460(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(void *)(a2 + 32) = 0x14000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_1000424EC(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 40)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }

  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }

  *(void *)(a2 + 32) = 0x13000000000000LL;
  uint64_t result = sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_1000425A0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(_DWORD *)(a2 + 68) = 16777473;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  int v3 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 84) << 7;
  *(_DWORD *)(a2 + 56) = v3 << 7;
  *(_DWORD *)(a2 + 72) = 4 * *(_DWORD *)(a2 + 92);
  *(NDR_record_t *)(a2 + 76) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 96;
  *(_DWORD *)(a2 + 24) = 3;
  return result;
}

uint64_t sub_10004267C(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 40)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }

  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }

  *(void *)(a2 + 32) = 0x14000000000000LL;
  uint64_t result = sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100042730(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 96) = 0;
  *(void *)(a2 + 32) = 0x11000000000000LL;
  *(void *)(a2 + 44) = 0x10000000000000LL;
  *(_DWORD *)(a2 + 60) = 16777473;
  *(_DWORD *)(a2 + 76) = (*(unsigned __int8 *)(a2 + 77) << 8) | 0x2110001;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  int v3 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a2 + 80) = v3;
  *(NDR_record_t *)(a2 + 84) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 100;
  *(_DWORD *)(a2 + 24) = 4;
  return result;
}

_DWORD *sub_100042818(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10000D094();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 164;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100042890(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10000D09C();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 44;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100042914(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0
    && (uint64_t v3 = result[1], v3 >= 0x30)
    && v3 <= 0x830
    && ((unsigned int v4 = result[11], v4 <= 0x800) ? (v5 = (int)v3 - 48 >= v4) : (v5 = 0),
        (unsigned int v6 = ((v4 + 3) & 0xFFFFFFFC) + 48, v5) ? (v7 = (_DWORD)v3 == v6) : (v7 = 0),
        v7 && (uint64_t result = memchr(result + 12, 0, v3 - 48)) != 0LL))
  {
    uint64_t result = (_DWORD *)sub_10000D094();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }

  else
  {
    *(_DWORD *)(a2 + 32) = -304;
  }

  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_1000429C4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(void *)(a2 + 32) = 0x13000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100042A54(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 196) {
    goto LABEL_8;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_9;
  }

  uint64_t result = (uint64_t)memchr((const void *)(result + 60), 0, 0x80uLL);
  if (!result)
  {
LABEL_8:
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }

  uint64_t result = sub_10000D094();
  *(_DWORD *)(a2 + 32) = result;
LABEL_10:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_100042B14(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 60))
  {
    int v3 = -300;
    goto LABEL_9;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100042BF8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100042CA0(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }

  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    int v3 = -300;
    goto LABEL_8;
  }

  uint64_t result = sub_10000D094();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100042D30(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0 && result[1] == 164 && (uint64_t result = memchr(result + 8, 0, 0x80uLL)) != 0LL)
  {
    uint64_t result = (_DWORD *)sub_10000D094();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }

  else
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100042DD4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 84) = 0;
  *(_DWORD *)(a2 + 36) = (*(unsigned __int8 *)(a2 + 37) << 8) | 0x2110001;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(_DWORD *)(a2 + 68) = 16777473;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  int v3 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 56) = v3 << 7;
  *(_DWORD *)(a2 + 72) = 4 * *(_DWORD *)(a2 + 92);
  *(NDR_record_t *)(a2 + 76) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 96;
  *(_DWORD *)(a2 + 24) = 3;
  return result;
}

uint64_t sub_100042EB8(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 188) {
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_10;
  }

  uint64_t result = (uint64_t)memchr((const void *)(result + 60), 0, 0x80uLL);
  if (!result)
  {
LABEL_9:
    int v3 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_11;
  }

  *(void *)(a2 + 32) = 0x14000000000000LL;
  uint64_t result = sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_11:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100042FA4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    uint64_t result = (_DWORD *)sub_10000D094();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100043024(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 160 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0LL)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }

  *(void *)(a2 + 32) = 0x14000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_1000430D4(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 176) {
    goto LABEL_7;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }

  uint64_t result = (uint64_t)memchr((const void *)(result + 48), 0, 0x80uLL);
  if (!result)
  {
LABEL_7:
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }

  uint64_t result = sub_10000D094();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_10004317C(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    int v3 = -304;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_8;
  }

  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_7;
  }

  uint64_t result = sub_10000D094();
  *(_DWORD *)(a2 + 32) = result;
LABEL_8:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_100043204(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 68)
  {
    int v3 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_11;
  }

  if (*(_BYTE *)(result + 39) != 1
    || *(unsigned __int16 *)(result + 54) << 16 != 1114112
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 64))
  {
    int v3 = -300;
    goto LABEL_10;
  }

  *(void *)(a2 + 32) = 0x10000000000000LL;
  uint64_t result = sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_11:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 52;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_1000432EC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(void *)(a2 + 32) = 0x11000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void sub_100043374(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) == 0 || *(_DWORD *)(a1 + 24) != 3 || *(_DWORD *)(a1 + 4) != 88)
  {
    int v5 = -304;
LABEL_12:
    *(_DWORD *)(a2 + 32) = v5;
    goto LABEL_13;
  }

  if (*(_BYTE *)(a1 + 39) != 1
    || *(_WORD *)(a1 + 54) != 529
    || *(unsigned __int16 *)(a1 + 70) << 16 != 1114112
    || *(_DWORD *)(a1 + 40) != *(_DWORD *)(a1 + 80)
    || *(_DWORD *)(a1 + 56) != *(_DWORD *)(a1 + 84))
  {
    int v5 = -300;
    goto LABEL_12;
  }

  *(_DWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = (*(unsigned __int8 *)(a2 + 53) << 8) | 0x2110001;
  int v4 = sub_10000D094();
  mig_deallocate(*(void *)(a1 + 44), (4 * *(_DWORD *)(a1 + 56)));
  *(void *)(a1 + 44) = 0LL;
  *(_DWORD *)(a1 + 56) = 0;
  if (v4)
  {
    *(_DWORD *)(a2 + 32) = v4;
LABEL_13:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return;
  }

  int v6 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 56) = v6;
  *(NDR_record_t *)(a2 + 60) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 76;
  *(_DWORD *)(a2 + 24) = 2;
}

_DWORD *sub_1000434E0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 52) = 0;
  *(_DWORD *)(a2 + 36) = (*(unsigned __int8 *)(a2 + 37) << 8) | 0x2140001;
  uint64_t result = (_DWORD *)sub_10000D094();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100043590(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 188 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0LL)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }

  *(void *)(a2 + 32) = 0x13000000000000LL;
  uint64_t result = (_DWORD *)sub_10000D0A0();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100043670(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 440) >= 0xFFFFFFD8
    && (int v5 = (void (*)(void))*(&off_1000655C8 + 5 * (v4 - 400) + 5)) != 0LL)
  {
    v5();
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }

  return result;
}

uint64_t sub_1000436F8(unsigned int a1, const char *a2, _DWORD *a3)
{
  uint64_t v15 = 0LL;
  memset(v14, 0, sizeof(v14));
  memset(&reply_port, 0, sizeof(reply_port));
  NDR_record_t v13 = NDR_record;
  if (&_mig_strncpy_zerofill) {
    int v5 = mig_strncpy_zerofill((char *)v14 + 8, a2, 128);
  }
  else {
    int v5 = mig_strncpy((char *)v14 + 8, a2, 128);
  }
  LODWORD(v14[0]) = 0;
  DWORD1(v14[0]) = v5;
  unint64_t v6 = ((v5 + 3) & 0xFFFFFFFC) + 40;
  uint64_t v7 = mig_get_reply_port();
  reply_port.msgh_bits = 5395;
  reply_port.msgh_unint64_t size = v6;
  *(void *)&reply_port.msgh_remote_uint64_t port = __PAIR64__(v7, a1);
  *(void *)&reply_port.msgh_voucher_uint64_t port = 0xB4700000000LL;
  uint64_t v8 = mach_msg2_internal( &reply_port,  0x200000003LL,  ((unint64_t)(v6 >> 2) << 34) | 0x1513,  __PAIR64__(v7, a1),  0xB4700000000LL,  v7 << 32,  48LL,  0LL);
  uint64_t v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v8)
    {
      mig_dealloc_reply_port(reply_port.msgh_local_port);
      return v9;
    }

    if (reply_port.msgh_id == 71)
    {
      uint64_t v9 = 4294966988LL;
    }

    else if (reply_port.msgh_id == 2987)
    {
      if ((reply_port.msgh_bits & 0x80000000) == 0)
      {
        if (reply_port.msgh_size == 40)
        {
          if (!reply_port.msgh_remote_port)
          {
            uint64_t v9 = LODWORD(v14[0]);
            if (!LODWORD(v14[0]))
            {
              *a3 = DWORD1(v14[0]);
              return v9;
            }

            goto LABEL_24;
          }
        }

        else if (reply_port.msgh_size == 36)
        {
          if (reply_port.msgh_remote_port) {
            BOOL v10 = 1;
          }
          else {
            BOOL v10 = LODWORD(v14[0]) == 0;
          }
          if (v10) {
            uint64_t v9 = 4294966996LL;
          }
          else {
            uint64_t v9 = LODWORD(v14[0]);
          }
          goto LABEL_24;
        }
      }

      uint64_t v9 = 4294966996LL;
    }

    else
    {
      uint64_t v9 = 4294966995LL;
    }

LABEL_24:
    mach_msg_destroy(&reply_port);
    return v9;
  }

  mig_put_reply_port(reply_port.msgh_local_port);
  return v9;
}

uint64_t sub_1000438CC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a2 = *(_DWORD *)a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = *(_DWORD *)(a1 + 20) + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  if (*(_DWORD *)(a1 + 20) == 5300)
  {
    if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 44)
    {
      *(_DWORD *)(a2 + 32) = -304;
      *(NDR_record_t *)(a2 + 24) = NDR_record;
    }

    else
    {
      *(_DWORD *)(a2 + 32) = sub_1000297FC(*(unsigned int *)(a1 + 12), *(void *)(a1 + 32));
    }

    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }

  return result;
}

char *sub_100043988(char *result, unint64_t a2, void *a3)
{
  *a3 = 0LL;
  uint64_t v10 = 0LL;
  if (a2 <= 1 || *(void *)result != 7LL) {
    return (char *)&unk_100065C68;
  }
  unint64_t v3 = (unint64_t)&result[32 * a2];
  int v4 = (char *)(v3 - 32);
  if (v3 >= 0x20 && v4 >= result)
  {
    if (*(void *)v4 == 8LL)
    {
      uint64_t v8 = result + 32;
      uint64_t v9 = &result[32 * a2];
      unint64_t v6 = sub_100046B9C(result, (uint64_t)&v8, &v10);
      if (v6 == (char *)&unk_100065C48)
      {
        if (v8 == v9)
        {
          uint64_t v7 = ccder_sizeof(2LL, 1LL);
          *a3 = ccder_sizeof(0x6000000000000010LL, v10 + v7);
        }

        else
        {
          return (char *)&unk_100065C88;
        }
      }

      return v6;
    }

    return (char *)&unk_100065C68;
  }

  __break(0x5519u);
  return result;
}

uint64_t sub_100043A64( uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v27 = result;
  unint64_t v32 = 0LL;
  unint64_t v33 = 0LL;
  if (a5 <= a6)
  {
    unint64_t v32 = a5;
    unint64_t v33 = a6;
    unint64_t v26 = a6 - a5;
    if (a6 > a5)
    {
      unint64_t v11 = a3 + 32 * a4;
      uint64_t v12 = (void *)(v11 - 32);
      uint64_t v13 = a4;
      while (2)
      {
        if ((--v13 & 0x8000000000000000LL) == 0)
        {
          if ((unint64_t)(v12 + 4) <= v11 && (unint64_t)v12 >= a3)
          {
            int v14 = 4;
            switch(*v12)
            {
              case 1LL:
                uint64_t v29 = 0LL;
                unint64_t v30 = 0LL;
                uint64_t result = ccder_blob_reserve_tl(&v32, 1LL, v12[2], &v29);
                if ((result & 1) == 0 || (unint64_t)v29 >= v30)
                {
                  unint64_t v6 = &unk_100065C68;
                  int v14 = 1;
                  goto LABEL_6;
                }

                if (v12[1]) {
                  char v15 = -1;
                }
                else {
                  char v15 = 0;
                }
                char *v29 = v15;
                goto LABEL_5;
              case 2LL:
              case 3LL:
                uint64_t result = ccder_blob_encode_body_tl(&v32, 12LL);
                if ((result & 1) == 0) {
                  return (uint64_t)&unk_100065C68;
                }
                goto LABEL_5;
              case 4LL:
                uint64_t result = sub_100046D4C((uint64_t)&v32, v12[1]);
                if ((result & 1) != 0) {
                  goto LABEL_5;
                }
                return (uint64_t)&unk_100065C68;
              case 5LL:
                uint64_t v16 = v12[2];
                unint64_t v17 = 0x2000000000000010LL;
                goto LABEL_23;
              case 7LL:
                uint64_t v16 = v12[2];
                unint64_t v17 = 0xA000000000000010LL;
LABEL_23:
                uint64_t result = ccder_blob_encode_tl(&v32, v17, v16);
                if ((result & 1) == 0) {
                  return (uint64_t)&unk_100065C68;
                }
LABEL_5:
                int v14 = 4;
                goto LABEL_6;
              case 9LL:
                int v14 = 4;
                uint64_t result = ccder_blob_encode_body_tl(&v32, 4LL);
                if ((result & 1) != 0) {
                  goto LABEL_6;
                }
                return (uint64_t)&unk_100065C68;
              default:
LABEL_6:
                v12 -= 4;
                if (v14 == 4) {
                  continue;
                }
                return (uint64_t)v6;
            }
          }

          goto LABEL_50;
        }

        break;
      }
    }

    uint64_t v29 = 0LL;
    unint64_t v30 = 0LL;
    uint64_t result = ccder_blob_reserve_tl(&v32, 2LL, 1LL, &v29);
    if ((result & 1) == 0) {
      return (uint64_t)&unk_100065C88;
    }
    xpc_object_t v18 = v29;
    unint64_t v19 = v30;
    if ((char *)v30 != v29)
    {
      xpc_object_t v20 = (char *)(v30 - 1);
      if (v30) {
        BOOL v21 = v20 >= v29;
      }
      else {
        BOOL v21 = 0;
      }
      if (!v21) {
        goto LABEL_50;
      }
      *xpc_object_t v20 = 1;
      if (v20 != v29)
      {
        xpc_object_t v22 = (char *)(v19 - 2);
        while ((unint64_t)v22 < v19 && v22 >= v18)
        {
          *xpc_object_t v22 = 0;
          if (v22-- == v29) {
            goto LABEL_43;
          }
        }

        goto LABEL_50;
      }
    }

LABEL_50:
  __break(0x5519u);
  return result;
}

uint64_t sub_100043D44(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (!*(_BYTE *)(a2 + 33))
  {
LABEL_6:
    __int128 v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
    uint64_t v11 = *(void *)(a2 + 48);
LABEL_7:
    *(void *)(v4 + 48) = v11;
    return result;
  }

  unint64_t v6 = *(void *)a2;
  unint64_t v7 = *(void *)a2 + 64LL;
  uint64_t v8 = *(void *)a3;
  switch(*(void *)a3 & 0xBFFFFFFFFFFFFFFFLL)
  {
    case 0uLL:
      uint64_t v9 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v9) {
        goto LABEL_6;
      }
      if (v6 >= v7) {
        goto LABEL_317;
      }
      uint64_t result = v9(v6, "[%s]: %s\n", "der_vm_execute_nocopy", "noop");
      goto LABEL_6;
    case 1uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v33 = *(_OWORD *)(a2 + 16);
      __int128 v131 = *(_OWORD *)a2;
      __int128 v132 = v33;
      LOBYTE(v133) = *(_BYTE *)(a2 + 32);
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 34);
      *(uint64_t *)((char *)&v130[1] + 6) = *(void *)(a2 + 48);
      *((void *)&v131 + 1) = 0LL;
      *(void *)&__int128 v132 = 0LL;
      if ((v8 & 0x4000000000000000LL) != 0)
      {
        __s1 = *(void **)(a3 + 8);
        uint64_t v34 = (size_t *)(a3 + 16);
      }

      else
      {
        __s1 = (void *)(a3 + 8);
        uint64_t v34 = (size_t *)(a3 + 248);
      }

      size_t v60 = *v34;
      uint64_t v61 = *(void *)(a2 + 16);
      if (v61)
      {
        unint64_t v6 = 0LL;
        __int128 v62 = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
        *(_OWORD *)(result + 32) = v62;
        *(_OWORD *)uint64_t result = *(_OWORD *)a2;
        uint64_t v63 = *(void *)(a2 + 40);
        *(void *)(result + 48) = *(void *)(a2 + 48);
        *(_BYTE *)(result + 33) = 0;
        unint64_t v64 = v61 - 1;
        *(void *)(result + 8) = 0LL;
        *(void *)(result + 16) = 0LL;
        if (__s1) {
          BOOL v65 = v60 == 0;
        }
        else {
          BOOL v65 = 1;
        }
        char v66 = v65;
        uint64_t v122 = *(void *)(a2 + 8);
        uint64_t v123 = v63;
        while (1)
        {
          unint64_t v67 = (v6 + v64) >> 1;
          if ((v66 & 1) != 0) {
            goto LABEL_325;
          }
          unint64_t v68 = *(void *)(v122 + 8 * v67);
          uint64_t v69 = (const void *)(v123 + v68);
          if (!v69) {
            goto LABEL_86;
          }
          if (v60 >= HIDWORD(v68)) {
            size_t v70 = HIDWORD(v68);
          }
          else {
            size_t v70 = v60;
          }
          if (v60 < HIDWORD(v68)) {
            int v71 = -1;
          }
          else {
            int v71 = 1;
          }
          uint64_t result = memcmp(__s1, v69, v70);
          if (v60 != HIDWORD(v68) && (_DWORD)result == 0) {
            int v73 = v71;
          }
          else {
            int v73 = result;
          }
          if (!v73)
          {
            *(_BYTE *)(v4 + 33) = 1;
            unint64_t v107 = *(void *)(v4 + 40);
            unint64_t v108 = v107 + (HIDWORD(v68) + v68);
            if (v108 <= *(void *)(v4 + 48) && v107 <= v108)
            {
              *(void *)(v4 + 40) = v108;
              return result;
            }

            while (1)
            {
              do
              {
LABEL_317:
                __break(0x5519u);
LABEL_318:
                uint64_t v121 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
                if (v121) {
                  v121(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
                }
              }

              while (v6 && v6 >= v6 + 64);
              (*(void (**)(unint64_t, const char *, ...))(v6 + 32))( v6,  "[%s]: %s\n",  "der_vm_string_from_context",  "Attempting to select a string value from a non-string DER object");
LABEL_316:
              v129[0] = 0LL;
              v129[1] = 0LL;
            }
          }

          if (v73 < 0)
          {
LABEL_325:
            if (v6 + v64 < 2) {
              return result;
            }
            unint64_t v64 = v67 - 1;
            if (v6 > v67 - 1) {
              return result;
            }
          }

          else
          {
LABEL_86:
            unint64_t v6 = v67 + 1;
            if (v67 + 1 > v64) {
              return result;
            }
          }
        }
      }

      v129[0] = 0LL;
      v129[1] = 0LL;
      __int128 v128 = *(_OWORD *)(a2 + 40);
      uint64_t result = sub_100046630(v6, 0LL, 0LL, v129, (uint64_t *)&v128);
      if ((result & 1) != 0)
      {
        if (v60)
        {
          if (v129[0] < v129[1])
          {
            if (v6 && v6 >= v7) {
              goto LABEL_317;
            }
            while (1)
            {
              __s2 = 0LL;
              size_t v127 = 0LL;
              __int128 v125 = 0uLL;
              uint64_t result = sub_1000467D0(v6, &__s2, &v125, v129);
              if (!(_DWORD)result) {
                break;
              }
              if (__s1 && __s2)
              {
                size_t v82 = v127;
                size_t v83 = v60 >= v127 ? v127 : v60;
                uint64_t result = memcmp(__s1, __s2, v83);
                if (!(_DWORD)result && v60 == v82)
                {
                  *(_OWORD *)((char *)v130 + 6) = v125;
                  LOBYTE(v85) = 1;
                  goto LABEL_294;
                }
              }

              if (v129[0] >= v129[1]) {
                goto LABEL_254;
              }
            }

            uint64_t v85 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
            if (v85)
            {
              uint64_t result = v85(v6, "[%s]: %s\n", "der_vm_execute_select_key", "invalid dictionary element");
              LOBYTE(v85) = 0;
            }

LABEL_294:
            __int128 v116 = v132;
            *(_OWORD *)uint64_t v4 = v131;
            *(_OWORD *)(v4 + 16) = v116;
            *(_BYTE *)(v4 + 32) = v133;
            *(_BYTE *)(v4 + 33) = (_BYTE)v85;
            goto LABEL_255;
          }

LABEL_254:
          __int128 v110 = v132;
          *(_OWORD *)uint64_t v4 = v131;
          *(_OWORD *)(v4 + 16) = v110;
          *(_BYTE *)(v4 + 32) = v133;
          *(_BYTE *)(v4 + 33) = 0;
LABEL_255:
          *(_OWORD *)(v4 + 34) = *(_OWORD *)v130;
          uint64_t v11 = *(uint64_t *)((char *)&v130[1] + 6);
          goto LABEL_7;
        }

        uint64_t v102 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v102) {
          goto LABEL_254;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v103 = "key length is invalid";
      }

      else
      {
        uint64_t v102 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v102) {
          goto LABEL_254;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v103 = "dictionary decoding failure";
      }

      uint64_t result = v102(v6, "[%s]: %s\n", "der_vm_execute_select_key", v103);
      goto LABEL_254;
    case 2uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v19 = *(_OWORD *)(a2 + 32);
      __int128 v20 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v19;
      *(_OWORD *)uint64_t result = v20;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      uint64_t v21 = *(void *)(a3 + 8);
      __int128 v131 = 0uLL;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      uint64_t result = sub_100046630(v6, 0LL, 0LL, &v131, v130);
      if (!(_DWORD)result)
      {
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v55 = "array decoding failure";
        goto LABEL_229;
      }

      BOOL v22 = (unint64_t)v131 < *((void *)&v131 + 1);
      if ((unint64_t)v131 < *((void *)&v131 + 1) && v21 >= 1)
      {
        while (1)
        {
          uint64_t result = sub_100046630(v6, 0LL, 0LL, 0LL, (uint64_t *)&v131);
          if ((result & 1) == 0) {
            break;
          }
          uint64_t v23 = v21 - 1;
          BOOL v22 = (unint64_t)v131 < *((void *)&v131 + 1);
        }

        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v55 = "encountered invalid element in an array";
LABEL_229:
        uint64_t v56 = "der_vm_execute_select_index";
        return v54(v6, "[%s]: %s\n", v56, v55);
      }

      uint64_t v23 = v21;
LABEL_148:
      if (v22 && v23 == 0)
      {
        if (!v6 || v6 < v7)
        {
          uint64_t result = sub_100046630(v6, 0LL, (void *)(v4 + 40), 0LL, (uint64_t *)&v131);
          *(_BYTE *)(v4 + 33) = result;
          return result;
        }

        goto LABEL_317;
      }

      return result;
    case 3uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      return sub_100045AA8(result, (__int128 *)a2, a3);
    case 4uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v25 = *(_OWORD *)(a2 + 32);
      __int128 v26 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v25;
      *(_OWORD *)uint64_t result = v26;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      if ((v8 & 0x4000000000000000LL) != 0)
      {
        uint64_t v27 = *(void *)(a3 + 8);
        uint64_t v28 = (size_t *)(a3 + 16);
      }

      else
      {
        uint64_t v27 = a3 + 8;
        uint64_t v28 = (size_t *)(a3 + 248);
      }

      size_t v57 = *v28;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      __int128 v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range(v130, 12LL, &v131);
      if ((result & 1) != 0)
      {
        if (!v57) {
          goto LABEL_308;
        }
        uint64_t v58 = (const void *)v131;
        if (v57 > *((void *)&v131 + 1) - (void)v131)
        {
LABEL_63:
          *(_BYTE *)(v4 + 33) = 0;
          return result;
        }

        uint64_t result = v27;
        size_t v104 = v57;
        goto LABEL_224;
      }

      uint64_t v59 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v59) {
        return result;
      }
      uint64_t result = v59(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_317;
      }
      uint64_t v55 = "string decode failure";
      uint64_t v56 = "der_vm_execute_match_string_prefix";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 5uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v35 = *(_OWORD *)(a2 + 32);
      __int128 v36 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v35;
      *(_OWORD *)uint64_t result = v36;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      __int128 v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range(v130, 1LL, &v131);
      if ((result & 1) == 0)
      {
        uint64_t v74 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v74) {
          goto LABEL_187;
        }
        uint64_t v75 = "Unknown BOOLean encoding";
        goto LABEL_186;
      }

      if (*((void *)&v131 + 1) - (void)v131 == 1LL)
      {
        BOOL v18 = *(void *)(a3 + 8) == (*(_BYTE *)v131 != 0);
        goto LABEL_235;
      }

      uint64_t v74 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (v74)
      {
        uint64_t v75 = "BOOLean should be exactly 1 byte";
LABEL_186:
        uint64_t result = v74(v6, "[%s]: %s\n", "der_decode_BOOLean", v75);
      }

LABEL_187:
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_317;
      }
      uint64_t v55 = "BOOL decode failure";
      uint64_t v56 = "der_vm_execute_match_BOOL";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 6uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v37 = *(_OWORD *)(a2 + 32);
      __int128 v38 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v37;
      *(_OWORD *)uint64_t result = v38;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      if ((v8 & 0x4000000000000000LL) != 0)
      {
        uint64_t v39 = *(const void **)(a3 + 8);
        uint64_t v40 = (size_t *)(a3 + 16);
      }

      else
      {
        uint64_t v39 = (const void *)(a3 + 8);
        uint64_t v40 = (size_t *)(a3 + 248);
      }

      size_t v76 = *v40;
      uint64_t v77 = *(void *)(a2 + 24);
      __int128 v78 = *(_OWORD *)(a2 + 40);
      v130[0] = 0LL;
      __int128 v131 = v78;
      uint64_t result = sub_100046630(v6, v130, 0LL, 0LL, (uint64_t *)&v131);
      if (!(_DWORD)result || v77 == v130[0]) {
        goto LABEL_112;
      }
      if (v130[0] != 12)
      {
        if (v130[0] == 0x2000000000000010LL || v130[0] == 0x6000000000000010LL)
        {
          v130[0] = v4;
          v130[1] = a3;
          __int128 v99 = *(_OWORD *)(a2 + 16);
          __int128 v131 = *(_OWORD *)a2;
          __int128 v132 = v99;
          __int128 v133 = *(_OWORD *)(a2 + 32);
          uint64_t v134 = *(void *)(a2 + 48);
          uint64_t v100 = sub_100045C04;
          return sub_100044F94((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
        }

LABEL_112:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v54)
        {
          if (v6 >= v7) {
            goto LABEL_317;
          }
          uint64_t v55 = "Unexpected type to match against";
          uint64_t v56 = "der_vm_execute_string_value_allowed";
          return v54(v6, "[%s]: %s\n", v56, v55);
        }

        return result;
      }

      uint64_t result = sub_100045AA8((uint64_t)&v131, (__int128 *)a2, a3);
      if (BYTE1(v133)) {
        goto LABEL_308;
      }
      unint64_t v6 = *(void *)a2;
      *(_OWORD *)uint64_t v129 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)uint64_t v130 = 0uLL;
      if ((ccder_blob_decode_range(v129, 12LL, v130) & 1) == 0) {
        goto LABEL_318;
      }
      uint64_t result = v130[0];
      if (v130[1] == v130[0]) {
        return result;
      }
      uint64_t v111 = (_BYTE *)(v130[1] - 1);
      if (*v111 != 42) {
        return result;
      }
      size_t v104 = ~v130[0] + v130[1];
      if (!v104) {
        goto LABEL_308;
      }
      if (v104 > v76) {
        goto LABEL_63;
      }
      uint64_t v58 = v39;
      goto LABEL_224;
    case 7uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v41 = *(_OWORD *)(a2 + 32);
      __int128 v42 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v41;
      *(_OWORD *)uint64_t result = v42;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      __int128 v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range(v130, 2LL, &v131);
      if ((result & 1) == 0)
      {
        __int128 v43 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v43) {
          goto LABEL_118;
        }
        uint64_t v44 = "unknown number encoding";
        goto LABEL_117;
      }

      if (*((void *)&v131 + 1) - (void)v131 < 9uLL)
      {
        if ((unint64_t)v131 >= *((void *)&v131 + 1))
        {
          uint64_t v95 = 0LL;
        }

        else
        {
          uint64_t v94 = 0LL;
          uint64_t v95 = 0LL;
          do
          {
            uint64_t v96 = (unsigned __int8 *)(v131 + v94);
            if ((unint64_t)(v131 + v94) >= *((void *)&v131 + 1)
              || (unint64_t)v96 < (unint64_t)v131)
            {
              goto LABEL_317;
            }

            uint64_t v95 = *v96 | (unint64_t)(v95 << 8);
            ++v94;
          }

          while (*((void *)&v131 + 1) - (void)v131 != v94);
        }

        BOOL v18 = v95 == *(void *)(a3 + 8);
        goto LABEL_235;
      }

      __int128 v43 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (v43)
      {
        uint64_t v44 = "number too large";
LABEL_117:
        uint64_t result = v43(v6, "[%s]: %s\n", "der_decode_number", v44);
      }

LABEL_118:
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_317;
      }
LABEL_121:
      uint64_t v55 = "BOOL decode failure";
      uint64_t v56 = "der_vm_execute_match_integer";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 8uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v45 = *(_OWORD *)(a2 + 32);
      __int128 v46 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v45;
      *(_OWORD *)uint64_t result = v46;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      uint64_t v47 = (const void *)(a3 + 8);
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      if ((v8 & 0x4000000000000000LL) != 0)
      {
        uint64_t v49 = *(void *)(a3 + 8);
        uint64_t v48 = (size_t *)(a3 + 16);
      }

      else
      {
        uint64_t v48 = (size_t *)(a3 + 248);
        uint64_t v49 = a3 + 8;
      }

      size_t v79 = *v48;
      uint64_t v80 = *(void *)(a2 + 24);
      __int128 v81 = *(_OWORD *)(a2 + 40);
      v130[0] = 0LL;
      __int128 v131 = v81;
      uint64_t result = sub_100046630(v6, v130, 0LL, 0LL, (uint64_t *)&v131);
      if (!(_DWORD)result || v80 == v130[0]) {
        goto LABEL_125;
      }
      if (v130[0] != 12)
      {
        if (v130[0] == 0x2000000000000010LL || v130[0] == 0x6000000000000010LL)
        {
          v130[0] = v4;
          v130[1] = a3;
          __int128 v101 = *(_OWORD *)(a2 + 16);
          __int128 v131 = *(_OWORD *)a2;
          __int128 v132 = v101;
          __int128 v133 = *(_OWORD *)(a2 + 32);
          uint64_t v134 = *(void *)(a2 + 48);
          uint64_t v100 = sub_100045DB4;
          return sub_100044F94((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
        }

LABEL_125:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v54)
        {
          if (v6 >= v7) {
            goto LABEL_317;
          }
          uint64_t v55 = "Unexpected type to match against";
          uint64_t v56 = "der_vm_execute_string_prefix_value_allowed";
          return v54(v6, "[%s]: %s\n", v56, v55);
        }

        return result;
      }

      if ((*(_BYTE *)(a3 + 7) & 0x40) != 0)
      {
        uint64_t v47 = *(const void **)(a3 + 8);
        uint64_t v112 = (size_t *)(a3 + 16);
      }

      else
      {
        uint64_t v112 = (size_t *)(a3 + 248);
      }

      unint64_t v6 = *(void *)a2;
      size_t v113 = *v112;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      __int128 v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range(v130, 12LL, &v131);
      if ((result & 1) != 0)
      {
        if (!v113) {
          goto LABEL_308;
        }
        if (v113 <= *((void *)&v131 + 1) - (void)v131)
        {
          uint64_t result = memcmp(v47, (const void *)v131, v113);
          if (!(_DWORD)result) {
            goto LABEL_308;
          }
        }
      }

      else
      {
        int v114 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v114)
        {
          v114(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
          uint64_t v115 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
          if (v115)
          {
            if (v6 && v6 >= v6 + 64) {
              goto LABEL_317;
            }
            v115(v6, "[%s]: %s\n", "der_vm_execute_match_string_prefix", "string decode failure");
          }
        }
      }

      unint64_t v6 = *(void *)a2;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      __int128 v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range(v130, 12LL, &v131);
      if ((result & 1) == 0) {
        goto LABEL_318;
      }
      if (v79)
      {
        uint64_t v58 = (const void *)v131;
        if (v79 > *((void *)&v131 + 1) - (void)v131) {
          goto LABEL_63;
        }
        uint64_t result = v49;
        size_t v104 = v79;
LABEL_224:
        uint64_t result = memcmp((const void *)result, v58, v104);
        BOOL v18 = (_DWORD)result == 0;
LABEL_235:
        char v105 = v18;
        goto LABEL_309;
      }

      goto LABEL_308;
    case 9uLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v29 = *(_OWORD *)(a2 + 32);
      __int128 v30 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v29;
      *(_OWORD *)uint64_t result = v30;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      __int128 v131 = 0uLL;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      uint64_t result = sub_100046630(v6, 0LL, 0LL, &v131, v130);
      if ((result & 1) == 0)
      {
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v55 = "dictionary decoding failure";
        goto LABEL_247;
      }

      if ((*(_BYTE *)(a3 + 7) & 0x40) != 0)
      {
        uint64_t v31 = *(const void **)(a3 + 8);
        unint64_t v32 = (void **)(a3 + 16);
      }

      else
      {
        uint64_t v31 = (const void *)(a3 + 8);
        unint64_t v32 = (void **)(a3 + 248);
      }

      uint64_t v87 = (char *)*v32;
      if (!*v32)
      {
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v55 = "key length is invalid";
        goto LABEL_247;
      }

      if (v6 && v6 >= v7) {
        goto LABEL_316;
      }
      while (2)
      {
        v129[0] = 0LL;
        v129[1] = 0LL;
        __int128 v128 = 0uLL;
        uint64_t result = sub_1000467D0(v6, v129, &v128, &v131);
        if ((_DWORD)result)
        {
          uint64_t v88 = (char *)v129[1];
          if (v129[1])
          {
            uint64_t v89 = v129[0];
            uint64_t v90 = (char *)v129[1] - 1;
            uint64_t v91 = (char *)v129[0] + (unint64_t)v129[1] - 1;
            if (*v91 == 42)
            {
              if (v129[1] == (void *)1 || v90 <= v87 && (uint64_t result = memcmp(v129[0], v31, (size_t)v90), !(_DWORD)result))
              {
LABEL_162:
                *(_BYTE *)(v4 + 33) = 1;
                *(_OWORD *)(v4 + 40) = v128;
              }

LABEL_163:
              continue;
            }
          }

          else
          {
            uint64_t v89 = v129[0];
          }

          if (v31 && v89)
          {
            uint64_t v93 = v87 >= v129[1] ? v129[1] : v87;
            uint64_t result = memcmp(v31, v89, (size_t)v93);
            if (v87 == v88 && !(_DWORD)result) {
              goto LABEL_162;
            }
          }

          goto LABEL_163;
        }

        break;
      }

      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      uint64_t v55 = "invalid dictionary element";
LABEL_247:
      uint64_t v56 = "der_vm_execute_select_longest_matching_key";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 0xAuLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v50 = *(_OWORD *)(a2 + 32);
      __int128 v51 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v50;
      *(_OWORD *)uint64_t result = v51;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      uint64_t v52 = *(void *)(a2 + 24);
      __int128 v53 = *(_OWORD *)(a2 + 40);
      v130[0] = 0LL;
      __int128 v131 = v53;
      uint64_t result = sub_100046630(v6, v130, 0LL, 0LL, (uint64_t *)&v131);
      if (!(_DWORD)result || v52 == v130[0]) {
        goto LABEL_56;
      }
      if (v130[0] == 0x6000000000000010LL || v130[0] == 0x2000000000000010LL)
      {
        v130[0] = v4;
        v130[1] = a3;
        __int128 v106 = *(_OWORD *)(a2 + 16);
        __int128 v131 = *(_OWORD *)a2;
        __int128 v132 = v106;
        __int128 v133 = *(_OWORD *)(a2 + 32);
        uint64_t v134 = *(void *)(a2 + 48);
        uint64_t v100 = sub_100045FC8;
        return sub_100044F94((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
      }

      if (v130[0] != 2)
      {
LABEL_56:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 >= v7) {
          goto LABEL_317;
        }
        uint64_t v55 = "Unexpected type to match against";
        uint64_t v56 = "der_vm_execute_integer_value_allowed";
        return v54(v6, "[%s]: %s\n", v56, v55);
      }

      unint64_t v6 = *(void *)a2;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      __int128 v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range(v130, 2LL, &v131);
      if ((result & 1) == 0)
      {
        uint64_t v97 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v97)
        {
          uint64_t v98 = "unknown number encoding";
          goto LABEL_272;
        }

LABEL_273:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v6 + 64) {
          goto LABEL_317;
        }
        goto LABEL_121;
      }

      if (*((void *)&v131 + 1) - (void)v131 >= 9uLL)
      {
        uint64_t v97 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v97)
        {
          uint64_t v98 = "number too large";
LABEL_272:
          uint64_t result = v97(v6, "[%s]: %s\n", "der_decode_number", v98);
          goto LABEL_273;
        }

        goto LABEL_273;
      }

      if ((unint64_t)v131 >= *((void *)&v131 + 1))
      {
        uint64_t v118 = 0LL;
      }

      else
      {
        uint64_t v117 = 0LL;
        uint64_t v118 = 0LL;
        do
        {
          uint64_t v119 = (unsigned __int8 *)(v131 + v117);
          if ((unint64_t)(v131 + v117) >= *((void *)&v131 + 1)
            || (unint64_t)v119 < (unint64_t)v131)
          {
            goto LABEL_317;
          }

          uint64_t v118 = *v119 | (unint64_t)(v118 << 8);
          ++v117;
        }

        while (*((void *)&v131 + 1) - (void)v131 != v117);
      }

      if (v118 != *(void *)(a3 + 8)) {
        return result;
      }
LABEL_308:
      char v105 = 1;
LABEL_309:
      *(_BYTE *)(v4 + 33) = v105;
      return result;
    case 0xBuLL:
      if (a2 + 56 < a2) {
        goto LABEL_317;
      }
      __int128 v12 = *(_OWORD *)(a2 + 32);
      __int128 v13 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v12;
      *(_OWORD *)uint64_t result = v13;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(void *)(result + 8) = 0LL;
      *(void *)(result + 16) = 0LL;
      uint64_t v14 = *(void *)(a3 + 8);
      uint64_t v15 = *(void *)(a2 + 24);
      __int128 v16 = *(_OWORD *)(a2 + 40);
      v130[0] = 0LL;
      __int128 v131 = v16;
      uint64_t result = sub_100046630(v6, v130, 0LL, 0LL, (uint64_t *)&v131);
      if (!(_DWORD)result) {
        return result;
      }
      if (v15 == v130[0])
      {
        int v17 = 1;
LABEL_13:
        BOOL v18 = v17 == (_DWORD)v14;
        goto LABEL_235;
      }

      if (v130[0] > 0x200000000000000FLL)
      {
        if (v130[0] == 0x6000000000000010LL || v130[0] == 0x2000000000000010LL)
        {
          int v17 = 2;
          goto LABEL_13;
        }
      }

      else
      {
        int v17 = 5;
        switch(v130[0])
        {
          case 1LL:
            goto LABEL_13;
          case 2LL:
            int v17 = 3;
            goto LABEL_13;
          case 4LL:
            int v17 = 6;
            goto LABEL_13;
          case 0xCLL:
            int v17 = 4;
            goto LABEL_13;
          default:
            return result;
        }
      }

      return result;
    default:
      if (v6) {
        BOOL v120 = v6 >= v7;
      }
      else {
        BOOL v120 = 0;
      }
      if (v120) {
        goto LABEL_317;
      }
      (*(void (**)(unint64_t, const char *, ...))(v6 + 32))( v6,  "[%s]: %s\n",  "der_vm_execute_nocopy",  "unhandled opcode");
      goto LABEL_316;
  }

uint64_t sub_100044E34@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 && a2 + 256 < a2)
  {
    __break(0x5519u);
  }

  else
  {
    __int128 v3 = *(_OWORD *)(result + 16);
    v4[0] = *(_OWORD *)result;
    v4[1] = v3;
    void v4[2] = *(_OWORD *)(result + 32);
    uint64_t v5 = *(void *)(result + 48);
    return sub_100043D44(a3, (unint64_t)v4, a2);
  }

  return result;
}

uint64_t sub_100044E88(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 33);
}

uint64_t sub_100044E90(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0LL;
  if (!*(_BYTE *)(a1 + 33)) {
    return 0LL;
  }
  uint64_t v4 = *(void *)a1;
  __int128 v7 = *(_OWORD *)(a1 + 40);
  uint64_t result = sub_100046630(v4, &v8, 0LL, 0LL, (uint64_t *)&v7);
  if (!(_DWORD)result) {
    return result;
  }
  uint64_t v6 = v8;
  if (a2) {
    *a2 = v8;
  }
  if (*(void *)(a1 + 24) == v6) {
    return 1LL;
  }
  if (v6 > 0x200000000000000FLL)
  {
    if (v6 == 0x6000000000000010LL || v6 == 0x2000000000000010LL) {
      return 2LL;
    }
    return 0LL;
  }

  uint64_t result = 5LL;
  switch(v6)
  {
    case 1LL:
      return result;
    case 2LL:
      uint64_t result = 3LL;
      break;
    case 3LL:
    case 5LL:
    case 6LL:
    case 7LL:
    case 8LL:
    case 9LL:
    case 10LL:
    case 11LL:
      return 0LL;
    case 4LL:
      uint64_t result = 6LL;
      break;
    case 12LL:
      uint64_t result = 4LL;
      break;
    default:
      return v6 == 0xA000000000000010LL;
  }

  return result;
}

unint64_t sub_100044F94(unint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  if (result && result + 56 < result) {
    goto LABEL_41;
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000LL;
  uint64_t v14 = sub_100045270;
  uint64_t v15 = &unk_100065C28;
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  if (!*(_BYTE *)(result + 33)) {
    return (unint64_t)&unk_100065C68;
  }
  unint64_t v4 = *(void *)result;
  unint64_t v5 = *(void *)result + 64LL;
  unint64_t v29 = 0LL;
  v30[0] = 0LL;
  unint64_t v28 = 0LL;
  __int128 v27 = *(_OWORD *)(result + 40);
  uint64_t result = sub_100046630(v4, v30, 0LL, &v28, (uint64_t *)&v27);
  if ((result & 1) != 0)
  {
    if (*(void *)(v3 + 24) == v30[0])
    {
LABEL_6:
      int v6 = 1;
      goto LABEL_14;
    }

    int v6 = 2;
    if (v30[0] != 0x6000000000000010LL && v30[0] != 0x2000000000000010LL)
    {
      if (v30[0] == 0xA000000000000010LL) {
        goto LABEL_6;
      }
      __int128 v12 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
      if (!v12) {
        return (unint64_t)&unk_100065C68;
      }
      if (!v4 || v4 < v5)
      {
        v12(v4, "[%s]: %s\n", "der_vm_iterate_b", "iteration over a non-iterable type");
        return (unint64_t)&unk_100065C68;
      }

      goto LABEL_41;
    }

    while (1)
    {
LABEL_14:
      if (v28 >= v29) {
        return (unint64_t)&unk_100065C48;
      }
      __int128 v10 = *(_OWORD *)(v3 + 16);
      __int128 v11 = *(_OWORD *)(v3 + 32);
      v18[0] = *(_OWORD *)v3;
      v18[1] = v10;
      _OWORD v18[2] = v11;
      uint64_t v19 = *(void *)(v3 + 48);
      __int128 v20 = v18[0];
      __int128 v21 = v10;
      __int128 v22 = v11;
      uint64_t v23 = v19;
      int v24 = v6;
      int v25 = 0;
      uint64_t v26 = 0LL;
      uint64_t result = sub_100046630(*(void *)v3, v30, (void *)&v22 + 1, 0LL, (uint64_t *)&v28);
      if ((result & 1) == 0) {
        break;
      }
      if (*((void *)&v21 + 1) == v30[0])
      {
        int v9 = 1;
      }

      else if (v30[0] > 0x200000000000000FLL)
      {
        if (v30[0] == 0x6000000000000010LL || v30[0] == 0x2000000000000010LL) {
          int v9 = 2;
        }
        else {
LABEL_23:
        }
          int v9 = 0;
      }

      else
      {
        int v9 = 5;
        switch(v30[0])
        {
          case 1LL:
            break;
          case 2LL:
            int v9 = 3;
            break;
          case 4LL:
            int v9 = 6;
            break;
          case 0xCLL:
            int v9 = 4;
            break;
          default:
            goto LABEL_23;
        }
      }

      int v25 = v9;
    }

    __int128 v7 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
    if (v7)
    {
      if (!v4 || v4 < v5)
      {
        uint64_t v8 = "encountered invalid element in an iterable";
        goto LABEL_39;
      }

      goto LABEL_41;
    }

    return (unint64_t)&unk_100065C88;
  }

  __int128 v7 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
  if (!v7) {
    return (unint64_t)&unk_100065C88;
  }
  if (!v4 || v4 < v5)
  {
    uint64_t v8 = "iterable decoding failure";
LABEL_39:
    v7(v4, "[%s]: %s\n", "der_vm_iterate_b", v8);
    return (unint64_t)&unk_100065C88;
  }

LABEL_41:
  __break(0x5519u);
  return result;
}

uint64_t sub_100045270(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 120) = *(void *)(a1 + 32);
  int v2 = *(uint64_t (**)(_OWORD *))(a1 + 40);
  __int128 v3 = *(_OWORD *)(a2 + 80);
  v8[4] = *(_OWORD *)(a2 + 64);
  void v8[5] = v3;
  __int128 v4 = *(_OWORD *)(a2 + 112);
  void v8[6] = *(_OWORD *)(a2 + 96);
  void v8[7] = v4;
  __int128 v5 = *(_OWORD *)(a2 + 16);
  v8[0] = *(_OWORD *)a2;
  v8[1] = v5;
  __int128 v6 = *(_OWORD *)(a2 + 48);
  v8[2] = *(_OWORD *)(a2 + 32);
  _OWORD v8[3] = v6;
  return v2(v8);
}

uint64_t sub_1000452BC(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  __int128 v8 = *(_OWORD *)(a1 + 40);
  int v9 = 0LL;
  unint64_t v10 = 0LL;
  if ((ccder_blob_decode_range(&v8, 2LL, &v9) & 1) == 0)
  {
    __int128 v5 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v5)
    {
      __int128 v6 = "unknown number encoding";
LABEL_18:
      v5(v1, "[%s]: %s\n", "der_decode_number", v6);
    }

uint64_t sub_1000453DC(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  v6[0] = 0LL;
  v6[1] = 0LL;
  if ((ccder_blob_decode_range(&v5, 12LL, v6) & 1) != 0) {
    return v6[0];
  }
  __int128 v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3) {
    v3(v1, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
  }
  if (v1)
  {
    if (v1 >= v1 + 64) {
      __break(0x5519u);
    }
  }

  uint64_t v4 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))( v1,  "[%s]: %s\n",  "der_vm_string_from_context",  "Attempting to select a string value from a non-string DER object");
  return sub_100045490(v4);
}

uint64_t sub_100045490(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  __int128 v6 = *(_OWORD *)(a1 + 40);
  uint64_t v7 = 0LL;
  unint64_t v8 = 0LL;
  if ((ccder_blob_decode_range(&v6, 1LL, &v7) & 1) == 0)
  {
    __int128 v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v3)
    {
      uint64_t v4 = "Unknown BOOLean encoding";
LABEL_9:
      v3(v1, "[%s]: %s\n", "der_decode_BOOLean", v4);
    }

uint64_t sub_100045574(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  v6[0] = 0LL;
  v6[1] = 0LL;
  if ((ccder_blob_decode_range(&v5, 4LL, v6) & 1) != 0) {
    return v6[0];
  }
  __int128 v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3) {
    v3(v1, "[%s]: %s\n", "der_decode_data", "Unknown data encoding");
  }
  if (v1)
  {
    if (v1 >= v1 + 64) {
      __break(0x5519u);
    }
  }

  uint64_t v4 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))( v1,  "[%s]: %s\n",  "der_vm_data_from_context",  "Attempting to select a data value from a non-data DER object");
  return sub_100045628(v4);
}

uint64_t sub_100045628(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  char v4 = 0;
  if (a3 <= a4) {
    return sub_100045664(result, &v4, a2, a3, a4);
  }
  __break(0x5519u);
  return result;
}

uint64_t sub_100045664(uint64_t result, _BYTE *a2, uint64_t *a3, unint64_t a4, unint64_t a5)
{
  __int128 v5 = (char *)result;
  if (!a3) {
    goto LABEL_16;
  }
  *a3 = 0LL;
  if (a4 > a5)
  {
LABEL_56:
    __break(0x5519u);
    return result;
  }

  a3[1] = a4;
  a3[2] = a5;
  if (a4 && a4 < a5)
  {
    if (a5 - a4 >= 5 && (*(_DWORD *)a4 == 1836597052 ? (BOOL v10 = *(_BYTE *)(a4 + 4) == 108) : (BOOL v10 = 0), v10))
    {
      uint64_t v17 = *(void (**)(uint64_t, const char *, ...))(result + 24);
      if (v17) {
        v17(result, "[%s]: %s\n", "CEValidateWithOptions", "xml-looking blob was passed in");
      }
      return (uint64_t)&unk_100065C58;
    }

    else
    {
      v23[1] = a5;
      uint64_t v24 = 0LL;
      v22[1] = a5;
      v23[0] = a4;
      v22[0] = a4;
      if (ccder_blob_decode_tl(v22, 0x6000000000000010LL, &v24))
      {
        __int128 v32 = 0uLL;
        if ((ccder_blob_decode_range(v23, 0x6000000000000010LL, &v32) & 1) == 0)
        {
          __int128 v11 = (void (*)(char *, const char *, ...))*((void *)v5 + 3);
          if (v11)
          {
            __int128 v12 = "entitlements blob does not have CCDER_ENTITLEMENTS coding";
LABEL_25:
            uint64_t v16 = "validate_VNext";
            goto LABEL_34;
          }

          return (uint64_t)&unk_100065C88;
        }

        uint64_t v26 = 0LL;
        unint64_t v27 = 0LL;
        uint64_t result = ccder_blob_decode_range(&v32, 2LL, &v26);
        if ((result & 1) == 0)
        {
          __int128 v11 = (void (*)(char *, const char *, ...))*((void *)v5 + 3);
          if (v11)
          {
            __int128 v12 = "unknown number encoding";
            goto LABEL_33;
          }

          return (uint64_t)&unk_100065C88;
        }

        if (v27 - (unint64_t)v26 >= 9)
        {
          __int128 v11 = (void (*)(char *, const char *, ...))*((void *)v5 + 3);
          if (v11)
          {
            __int128 v12 = "number too large";
LABEL_33:
            uint64_t v16 = "der_decode_number";
            goto LABEL_34;
          }

          return (uint64_t)&unk_100065C88;
        }

        if ((unint64_t)v26 >= v27)
        {
          uint64_t v19 = 0LL;
LABEL_52:
          __int128 v21 = (void (*)(char *, const char *, ...))*((void *)v5 + 3);
          if (v21) {
            v21(v5, "[%s]: entitlements blob has unexpected version %lld\n", "validate_VNext", v19);
          }
          return (uint64_t)&unk_100065C88;
        }

        uint64_t v18 = 0LL;
        uint64_t v19 = 0LL;
        while (1)
        {
          if (!v18 && (*v26 & 0x80u) != 0) {
            uint64_t v19 = -1LL;
          }
          __int128 v20 = &v26[v18];
          uint64_t v19 = *v20 | (unint64_t)(v19 << 8);
          if (v27 - (void)v26 == ++v18)
          {
            if (v19 != 1) {
              goto LABEL_52;
            }
            unint64_t v30 = 0LL;
            unint64_t v31 = 0LL;
            __int128 v25 = v32;
            if ((ccder_blob_decode_range(&v25, 0xA000000000000010LL, &v30) & 1) != 0)
            {
              uint64_t v29 = 0LL;
              uint64_t v26 = (unsigned __int8 *)v5;
              unint64_t v27 = 0xA000000000000010LL;
              uint64_t v28 = 1LL;
              LOBYTE(v29) = *a2;
              uint64_t v14 = 2LL;
              goto LABEL_22;
            }

            __int128 v11 = (void (*)(char *, const char *, ...))*((void *)v5 + 3);
            if (!v11) {
              return (uint64_t)&unk_100065C88;
            }
            __int128 v12 = "entitlements blob does not have CCDER_ENTITLEMENTS_DICT as the second element";
            goto LABEL_25;
          }
        }
      }

      __int128 v32 = 0uLL;
      unint64_t v30 = a4;
      unint64_t v31 = a5;
      if ((ccder_blob_decode_range(&v30, 0x2000000000000011LL, &v32) & 1) == 0)
      {
        __int128 v11 = (void (*)(char *, const char *, ...))*((void *)v5 + 3);
        if (v11)
        {
          __int128 v12 = "entitlements blob does not have CCDER_CONSTRUCTED_SET coding";
          uint64_t v16 = "validate_V0";
LABEL_34:
          v11(v5, "[%s]: %s\n", v16, v12);
          return (uint64_t)&unk_100065C88;
        }

        return (uint64_t)&unk_100065C88;
      }

      uint64_t v28 = 0LL;
      uint64_t v29 = 0LL;
      uint64_t v26 = (unsigned __int8 *)v5;
      unint64_t v27 = 0x2000000000000011LL;
      LOBYTE(v29) = *a2;
      if (sub_10004615C((uint64_t)&v26, v23))
      {
        uint64_t v14 = 1LL;
LABEL_22:
        *a3 = v14;
        uint64_t v15 = &off_100065CE0;
      }

      else
      {
LABEL_48:
        uint64_t v15 = &off_100065CE8;
      }

      return (uint64_t)*v15;
    }
  }

  else
  {
LABEL_16:
    __int128 v13 = *(void (**)(uint64_t, const char *, ...))(result + 24);
    if (v13) {
      v13(result, "[%s]: %s\n", "CEValidateWithOptions", "invalid arguments passed in");
    }
    return (uint64_t)&unk_100065C68;
  }

uint64_t sub_1000459A8(uint64_t result, void *a2, uint64_t a3)
{
  if (!a3 || !*a2 || !a2[1] || !a2[2])
  {
    unint64_t v8 = &off_100065CD8;
    return (uint64_t)*v8;
  }

  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  unint64_t v5 = a2[1];
  unint64_t v4 = a2[2];
  if (*a2 == 2LL)
  {
    if (v5 <= v4)
    {
      *(void *)(a3 + 8) = 0LL;
      *(void *)(a3 + 16) = 0LL;
      *(void *)a3 = result;
      *(_OWORD *)(a3 + 24) = xmmword_1000497F0;
      *(void *)(a3 + 40) = v5;
      *(void *)(a3 + 48) = v4;
      __int128 v6 = *(_OWORD *)(a3 + 16);
      v9[0] = *(_OWORD *)a3;
      v9[1] = v6;
      v9[2] = *(_OWORD *)(a3 + 32);
      unint64_t v10 = v4;
      sub_100043D44((uint64_t)v11, (unint64_t)v9, (uint64_t)&unk_1000496D8);
      __int128 v7 = v11[1];
      *(_OWORD *)a3 = v11[0];
      *(_OWORD *)(a3 + 16) = v7;
      *(_OWORD *)(a3 + 32) = v11[2];
      unint64_t v4 = v12;
LABEL_12:
      *(void *)(a3 + 48) = v4;
      unint64_t v8 = &off_100065CE0;
      return (uint64_t)*v8;
    }
  }

  else if (v5 <= v4)
  {
    *(void *)(a3 + 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(void *)a3 = result;
    *(_OWORD *)(a3 + 24) = xmmword_1000497E0;
    *(void *)(a3 + 40) = v5;
    goto LABEL_12;
  }

  __break(0x5519u);
  return result;
}

uint64_t sub_100045AA8(uint64_t a1, __int128 *a2, uint64_t a3)
{
  unint64_t v4 = *(void *)a2;
  __int128 v5 = a2[2];
  __int128 v6 = *a2;
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v6;
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(_BYTE *)(a1 + 33) = 0;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  if ((*(_BYTE *)(a3 + 7) & 0x40) != 0)
  {
    __int128 v7 = *(const void **)(a3 + 8);
    unint64_t v8 = (size_t *)(a3 + 16);
  }

  else
  {
    __int128 v7 = (const void *)(a3 + 8);
    unint64_t v8 = (size_t *)(a3 + 248);
  }

  size_t v9 = *v8;
  __int128 v19 = *(__int128 *)((char *)a2 + 40);
  __int128 v20 = 0LL;
  __int128 v21 = 0LL;
  uint64_t result = ccder_blob_decode_range(&v19, 12LL, &v20);
  if ((result & 1) != 0)
  {
    BOOL v11 = 0;
    unint64_t v12 = v20;
    __int128 v13 = v21;
    if (v7 && v9)
    {
      if (v20)
      {
        int64_t v14 = (_BYTE *)v21 - (_BYTE *)v20;
        if (v9 >= (_BYTE *)v21 - (_BYTE *)v20) {
          size_t v15 = (_BYTE *)v21 - (_BYTE *)v20;
        }
        else {
          size_t v15 = v9;
        }
        uint64_t result = memcmp(v7, v20, v15);
        BOOL v11 = (_DWORD)result == 0;
        if (v9 != v14) {
          BOOL v11 = 0;
        }
      }

      else
      {
        BOOL v11 = 0;
      }
    }

    if (v9) {
      BOOL v18 = 0;
    }
    else {
      BOOL v18 = v13 == v12;
    }
    if (v18) {
      BOOL v11 = 1;
    }
    *(_BYTE *)(a1 + 33) = v11;
  }

  else
  {
    uint64_t v16 = *(uint64_t (**)(unint64_t, const char *, ...))(v4 + 24);
    if (v16)
    {
      uint64_t result = v16(v4, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      uint64_t v17 = *(uint64_t (**)(unint64_t, const char *, ...))(v4 + 24);
      if (v17)
      {
        if (v4 && v4 >= v4 + 64) {
          __break(0x5519u);
        }
        else {
          return v17(v4, "[%s]: %s\n", "der_vm_execute_match_string", "string decode failure");
        }
      }
    }
  }

  return result;
}

uint64_t sub_100045C04(uint64_t *a1)
{
  uint64_t v2 = (void *)a1[15];
  uint64_t v3 = v2[1];
  if ((*(_BYTE *)(v3 + 7) & 0x40) != 0)
  {
    unint64_t v4 = *(const void **)(v3 + 8);
    __int128 v5 = (size_t *)(v3 + 16);
  }

  else
  {
    unint64_t v4 = (const void *)(v3 + 8);
    __int128 v5 = (size_t *)(v3 + 248);
  }

  if (*((_DWORD *)a1 + 29) != 4)
  {
    uint64_t v8 = *a1;
    size_t v9 = *(void (**)(uint64_t, const char *, ...))(*a1 + 24);
    if (v9) {
      v9(v8, "[%s]: %s\n", "string_value_allowed_iterate", "Unexpected type to match against during iteration");
    }
    return 1LL;
  }

  size_t v6 = *v5;
  sub_100045AA8((uint64_t)v17, (__int128 *)(a1 + 7), v3);
  if (v17[33])
  {
    uint64_t result = 0LL;
    *(_BYTE *)(*v2 + 33LL) = 1;
    return result;
  }

  unint64_t v10 = a1[7];
  __int128 v18 = *((_OWORD *)a1 + 6);
  __int128 v19 = 0LL;
  unint64_t v20 = 0LL;
  if ((ccder_blob_decode_range(&v18, 12LL, &v19) & 1) == 0)
  {
    size_t v15 = *(void (**)(unint64_t, const char *, ...))(v10 + 24);
    if (v15) {
      v15(v10, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
    }
    if (!v10 || v10 < v10 + 64) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  size_t v11 = v20 - (void)v19 - 1;
  unint64_t v12 = (_BYTE *)(v20 - 1);
  if (v20 - 1 >= v20 || v12 < v19)
  {
LABEL_26:
    __break(0x5519u);
LABEL_27:
    uint64_t v16 = (uint64_t *)(*(uint64_t (**)(unint64_t, const char *, ...))(v10 + 32))( v10,  "[%s]: %s\n",  "der_vm_string_from_context",  "Attempting to select a string value from a non-string DER object");
    return sub_100045DB4(v16);
  }

  if (*v12 != 42 || v11 > v6) {
    return 1LL;
  }
  int v14 = memcmp(v19, v4, v11);
  uint64_t result = 1LL;
  if (!v14)
  {
    *(_BYTE *)(*v2 + 33LL) = 1;
    return 0LL;
  }

  return result;
}

uint64_t sub_100045DB4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)a1[15];
  uint64_t v4 = v3[1];
  int v5 = *((_DWORD *)a1 + 29);
  if ((*(_BYTE *)(v4 + 7) & 0x40) == 0)
  {
    if (v5 == 4)
    {
      size_t v6 = (const void *)(v4 + 8);
      size_t v7 = *(void *)(v4 + 248);
      goto LABEL_6;
    }

uint64_t sub_100045FC8(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 29) != 3)
  {
    uint64_t v7 = *a1;
    unint64_t v8 = *(void (**)(uint64_t, const char *, ...))(v7 + 24);
    if (v8) {
      v8(v7, "[%s]: %s\n", "integer_allowed_iterate", "Unexpected type to match against during iteration");
    }
    return 0LL;
  }

  unint64_t v1 = (void *)a1[15];
  uint64_t v2 = v1[1];
  unint64_t v3 = a1[7];
  __int128 v13 = *((_OWORD *)a1 + 6);
  uint64_t v14 = 0LL;
  unint64_t v15 = 0LL;
  uint64_t result = ccder_blob_decode_range(&v13, 2LL, &v14);
  if ((result & 1) == 0)
  {
    int v5 = *(uint64_t (**)(unint64_t, const char *, ...))(v3 + 24);
    if (v5)
    {
      size_t v6 = "unknown number encoding";
      goto LABEL_11;
    }

LABEL_30:
    __break(0x5519u);
    return result;
  }

  if (v15 - (unint64_t)v14 >= 9)
  {
    int v5 = *(uint64_t (**)(unint64_t, const char *, ...))(v3 + 24);
    if (v5)
    {
      size_t v6 = "number too large";
LABEL_11:
      uint64_t result = v5(v3, "[%s]: %s\n", "der_decode_number", v6);
      goto LABEL_12;
    }

    goto LABEL_12;
  }

  if ((unint64_t)v14 < v15)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    while (1)
    {
      if (!v10 && (*v14 & 0x80u) != 0) {
        uint64_t v11 = -1LL;
      }
      unint64_t v12 = &v14[v10];
      uint64_t v11 = *v12 | (unint64_t)(v11 << 8);
      if (v15 - (void)v14 == ++v10) {
        goto LABEL_28;
      }
    }
  }

  uint64_t v11 = 0LL;
LABEL_28:
  uint64_t result = 1LL;
  if (v11 == *(void *)(v2 + 8))
  {
    *(_BYTE *)(*v1 + 33LL) = 1;
    return 0LL;
  }

  return result;
}

uint64_t sub_10004615C(uint64_t result, uint64_t *a2)
{
  unint64_t v2 = *(void *)result;
  unint64_t v3 = *(void *)result + 64LL;
  if (*(int *)(result + 20) > 12)
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (v4)
    {
      if (v2 < v3) {
        goto LABEL_33;
      }
      goto LABEL_95;
    }

    return 0LL;
  }

  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v20 = 0LL;
  if (v2) {
    BOOL v5 = v2 >= v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
LABEL_95:
    __break(0x5519u);
    return result;
  }

  uint64_t v6 = result;
  if ((sub_100046630(v2, &v22, &v20, 0LL, a2) & 1) == 0)
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (v4)
    {
LABEL_33:
      unint64_t v16 = v2;
LABEL_34:
      v4(v16, "[%s]: %s\n");
      return 0LL;
    }

    return 0LL;
  }

  if (v22 != *(void *)(v6 + 8))
  {
    switch(v22)
    {
      case 1LL:
        uint64_t v26 = 0LL;
        unint64_t v27 = 0LL;
        if ((ccder_blob_decode_range(&v20, 1LL, &v26) & 1) != 0)
        {
          if (v27 - (void)v26 == 1) {
            goto LABEL_89;
          }
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
        }

        else
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
        }

        goto LABEL_33;
      case 2LL:
        uint64_t v26 = 0LL;
        unint64_t v27 = 0LL;
        uint64_t result = ccder_blob_decode_range(&v20, 2LL, &v26);
        if ((result & 1) == 0)
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
          goto LABEL_33;
        }

        unint64_t v18 = v27 - (void)v26;
        if (v27 - (unint64_t)v26 >= 9)
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
          goto LABEL_33;
        }

        __int128 v19 = v26;
        while ((unint64_t)v19 < v27 && v19 >= v26)
        {
          ++v19;
          if (!--v18) {
            goto LABEL_89;
          }
        }

        goto LABEL_95;
      case 3LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 8LL:
      case 9LL:
      case 10LL:
      case 11LL:
        goto LABEL_51;
      case 4LL:
        if (*(_BYTE *)(v6 + 24))
        {
          uint64_t v26 = 0LL;
          unint64_t v27 = 0LL;
          goto LABEL_89;
        }

        uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
        if (!v4) {
          return 0LL;
        }
        goto LABEL_33;
      case 12LL:
        uint64_t v26 = 0LL;
        unint64_t v27 = 0LL;
        if ((ccder_blob_decode_range(&v20, 12LL, &v26) & 1) != 0)
        {
          if (!memchr(v26, 0, v27 - (void)v26)) {
            goto LABEL_89;
          }
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
        }

        else
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
        }

        goto LABEL_33;
      default:
        if (v22 != 0x2000000000000010LL)
        {
LABEL_51:
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0LL;
          }
          goto LABEL_33;
        }

        unint64_t v7 = *(void *)v6;
        unint64_t v17 = *(void *)v6 + 64LL;
        uint64_t v26 = 0LL;
        unint64_t v27 = 0LL;
        uint64_t result = ccder_blob_decode_sequence_tl(&v20, &v26);
        if ((_DWORD)result)
        {
          do
          {
            ++*(_DWORD *)(v6 + 20);
            uint64_t result = sub_10004615C(v6, &v26);
            --*(_DWORD *)(v6 + 20);
          }

          while ((result & 1) != 0);
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
          if (!v4) {
            return 0LL;
          }
          if (v7 >= v17) {
            goto LABEL_95;
          }
        }

        else
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
          if (!v4) {
            return 0LL;
          }
          if (v7 >= v17) {
            goto LABEL_95;
          }
        }

        break;
    }

    goto LABEL_43;
  }

  unint64_t v7 = *(void *)v6;
  unint64_t v8 = *(void *)v6 + 64LL;
  uint64_t v26 = 0LL;
  unint64_t v27 = 0LL;
  uint64_t result = ccder_blob_decode_range(&v20, v22, &v26);
  if (!(_DWORD)result)
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
    if (!v4) {
      return 0LL;
    }
    if (v7 >= v8) {
      goto LABEL_95;
    }
LABEL_43:
    unint64_t v16 = v7;
    goto LABEL_34;
  }

  if ((unint64_t)v26 < v27)
  {
    size_t v9 = 0LL;
    size_t v10 = 0LL;
    while (1)
    {
      uint64_t v24 = 0LL;
      size_t v25 = 0LL;
      __int128 v23 = 0uLL;
      uint64_t result = sub_1000467D0(v7, &v24, &v23, &v26);
      if ((result & 1) == 0)
      {
        uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
        if (!v4) {
          return 0LL;
        }
        if (v7 >= v8) {
          goto LABEL_95;
        }
        goto LABEL_43;
      }

      unint64_t v12 = v24;
      size_t v11 = v25;
      uint64_t result = (uint64_t)memchr(v24, 0, v25);
      if (result)
      {
        uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
        if (!v4) {
          return 0LL;
        }
        if (v7 >= v8) {
          goto LABEL_95;
        }
        goto LABEL_43;
      }

      if (*(_BYTE *)(v6 + 16) && v9 && v10)
      {
        if (!v12) {
          break;
        }
        size_t v13 = v10 >= v11 ? v11 : v10;
        uint64_t result = memcmp(v9, v12, v13);
        BOOL v14 = v10 != v11 && (_DWORD)result == 0;
        int v15 = (v10 < v11) << 31;
        if (!v14) {
          int v15 = result;
        }
        if ((v15 & 0x80000000) == 0) {
          break;
        }
      }

      ++*(_DWORD *)(v6 + 20);
      uint64_t result = sub_10004615C(v6, &v23);
      --*(_DWORD *)(v6 + 20);
      if ((result & 1) == 0)
      {
        uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
        if (!v4) {
          return 0LL;
        }
        if (v7 >= v8) {
          goto LABEL_95;
        }
        goto LABEL_43;
      }

      size_t v9 = v24;
      size_t v10 = v25;
    }

    uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
    if (!v4) {
      return 0LL;
    }
    if (v7 < v8) {
      goto LABEL_43;
    }
    goto LABEL_95;
  }

LABEL_89:
  if (v20 != v21)
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (!v4) {
      return 0LL;
    }
    goto LABEL_33;
  }

  return 1LL;
}

uint64_t sub_100046630(uint64_t a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v11 = *a5;
  uint64_t v10 = a5[1];
  unint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  if ((ccder_blob_decode_tag(a5, &v19) & 1) == 0)
  {
    BOOL v14 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v14)
    {
      int v15 = "could not decode tag for next DER sub-sequence";
      goto LABEL_10;
    }

    return 0LL;
  }

  if ((ccder_blob_decode_len(a5, &v18) & 1) == 0)
  {
    BOOL v14 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v14)
    {
      int v15 = "could not decode size for next DER sub-sequence";
      goto LABEL_10;
    }

    return 0LL;
  }

  uint64_t v12 = *a5;
  unint64_t v13 = v18;
  if (a5[1] - *a5 < v18)
  {
    BOOL v14 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v14)
    {
      int v15 = "sub-sequence size is larger than sequence size";
LABEL_10:
      v14(a1, "[%s]: %s\n", "der_decode_next", v15);
      return 0LL;
    }

    return 0LL;
  }

  if (a2) {
    *a2 = v19;
  }
  uint64_t v17 = v12 + v13;
  if (a3)
  {
    *a3 = v11;
    a3[1] = v17;
  }

  if (a4)
  {
    *a4 = v12;
    a4[1] = v17;
  }

  *a5 = v17;
  a5[1] = v10;
  return 1LL;
}

uint64_t sub_10004673C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v5 = ccder_blob_decode_range(a3, 4LL, &v9);
  if ((v5 & 1) != 0)
  {
    if (a2)
    {
      uint64_t v6 = v10 - v9;
      *a2 = v9;
      a2[1] = v6;
    }
  }

  else
  {
    unint64_t v7 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v7) {
      v7(a1, "[%s]: %s\n", "der_decode_data", "Unknown data encoding");
    }
  }

  return v5;
}

uint64_t sub_1000467D0(uint64_t a1, void *a2, _OWORD *a3, void *a4)
{
  __int128 v15 = 0uLL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  if ((ccder_blob_decode_sequence_tl(a4, &v15) & 1) == 0)
  {
    uint64_t v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v9)
    {
      uint64_t v10 = "key / value decoding failure";
LABEL_12:
      v9(a1, "[%s]: %s\n", "der_decode_key_value", v10);
    }

    return 0LL;
  }

  __int128 v16 = 0uLL;
  if ((ccder_blob_decode_range(&v15, 12LL, &v16) & 1) == 0)
  {
    uint64_t v11 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v11) {
      v11(a1, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
    }
LABEL_10:
    uint64_t v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v9)
    {
      uint64_t v10 = "dictionary key is not a valid string";
      goto LABEL_12;
    }

    return 0LL;
  }

  if (a2)
  {
    uint64_t v8 = *((void *)&v16 + 1) - v16;
    *a2 = v16;
    a2[1] = v8;
    if (!v8) {
      goto LABEL_10;
    }
  }

  else if (!MEMORY[8])
  {
    goto LABEL_10;
  }

  __int128 v16 = v15;
  if ((ccder_blob_decode_tag(&v16, &v14) & 1) == 0)
  {
    uint64_t v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (!v9) {
      return 0LL;
    }
    uint64_t v10 = "unable to decode value tag for key-value pair";
    goto LABEL_12;
  }

  if ((ccder_blob_decode_len(&v16, &v13) & 1) == 0)
  {
    uint64_t v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (!v9) {
      return 0LL;
    }
    uint64_t v10 = "unable to decode value size for key-value pair";
    goto LABEL_12;
  }

  if ((void)v16 + v13 != *a4)
  {
    uint64_t v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (!v9) {
      return 0LL;
    }
    uint64_t v10 = "key-value pair contains extra elements";
    goto LABEL_12;
  }

  *a3 = v15;
  return 1LL;
}

char *sub_100046958(void *a1, char **a2, void *a3)
{
  if (!a1) {
    return (char *)&unk_100065C68;
  }
  switch(*a1)
  {
    case 1LL:
      a1[2] = 1LL;
      uint64_t v6 = 1LL;
      uint64_t v7 = 1LL;
      goto LABEL_30;
    case 2LL:
      uint64_t v7 = a1[2];
      uint64_t v6 = 12LL;
      goto LABEL_30;
    case 4LL:
      unint64_t v9 = a1[1];
      unint64_t v10 = HIBYTE(v9);
      if ((HIBYTE(v9) + 1) > 1u)
      {
        uint64_t v16 = 8LL;
      }

      else
      {
        if ((_DWORD)v10 == BYTE6(v9))
        {
          if ((_DWORD)v10 == BYTE5(v9))
          {
            if ((_DWORD)v10 == BYTE4(v9))
            {
              if ((_DWORD)v10 == BYTE3(v9))
              {
                if ((_DWORD)v10 == BYTE2(v9))
                {
                  if (BYTE1(v9) == (_DWORD)v10) {
                    uint64_t v11 = 2LL;
                  }
                  else {
                    uint64_t v11 = 3LL;
                  }
                  uint64_t v12 = 1LL;
                  if (BYTE1(v9) != (_DWORD)v10) {
                    uint64_t v12 = 2LL;
                  }
                }

                else
                {
                  uint64_t v12 = 3LL;
                  uint64_t v11 = 4LL;
                }
              }

              else
              {
                uint64_t v12 = 4LL;
                uint64_t v11 = 5LL;
              }
            }

            else
            {
              uint64_t v12 = 5LL;
              uint64_t v11 = 6LL;
            }
          }

          else
          {
            uint64_t v12 = 6LL;
            uint64_t v11 = 7LL;
          }
        }

        else
        {
          uint64_t v12 = 7LL;
          uint64_t v11 = 8LL;
        }

        else {
          uint64_t v16 = v12;
        }
      }

      *a3 = ccder_sizeof(2LL, v16);
      a1[2] = v16;
      return (char *)&unk_100065C48;
    case 5LL:
      goto LABEL_18;
    case 7LL:
      return (char *)sub_100046B9C(a1, a2, a3);
    case 9LL:
      uint64_t v7 = a1[2];
      uint64_t v6 = 4LL;
LABEL_30:
      *a3 = ccder_sizeof(v6, v7);
      return (char *)&unk_100065C48;
    default:
      return (char *)&unk_100065C68;
  }

  while (1)
  {
LABEL_18:
    uint64_t result = *a2;
    unint64_t v13 = (unint64_t)a2[1];
    uint64_t v14 = result + 32;
    *a2 = v14;
    if (!result) {
      return (char *)&unk_100065C88;
    }
    if (*(void *)result == 6LL)
    {
      *a3 = ccder_sizeof(0x2000000000000010LL, 0LL);
      a1[2] = 0LL;
      return (char *)&unk_100065C48;
    }

    if (result >= v14) {
      break;
    }
    uint64_t result = (char *)sub_100046958();
  }

  __break(0x5519u);
  return result;
}

char *sub_100046B9C(char *result, uint64_t a2, void *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = 0LL;
  uint64_t v7 = *(char **)a2;
  unint64_t v8 = *(void *)(a2 + 8);
  if (*(void *)a2 >= v8) {
    return (char *)&unk_100065C88;
  }
  while (1)
  {
    unint64_t v9 = v7 + 32;
    if ((unint64_t)(v7 + 32) > v8 || v7 > v9)
    {
LABEL_28:
      __break(0x5519u);
      return result;
    }

    *(void *)a2 = v9;
    if (!v7) {
      return (char *)&unk_100065C88;
    }
    if (*(void *)v7 != 5LL) {
      break;
    }
    v7[24] = 1;
    unint64_t v10 = v7 + 64;
    *(void *)a2 = v10;
    if (*(void *)v9 != 3LL) {
      return (char *)&unk_100065C88;
    }
    uint64_t v11 = *((void *)v7 + 6);
    if (!v11) {
      return (char *)&unk_100065C88;
    }
    uint64_t v12 = ccder_sizeof(12LL, v11);
    uint64_t result = 0LL;
    uint64_t v17 = 0LL;
    if ((unint64_t)v10 < v8)
    {
      unint64_t v13 = v7 + 96;
      *(void *)a2 = v13;
      uint64_t result = v7 + 64;
    }

    uint64_t result = sub_100046958(result, (char **)a2, &v17);
    uint64_t v14 = *(char **)a2;
    unint64_t v8 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v8) {
      return (char *)&unk_100065C88;
    }
    __int128 v15 = v14 + 32;
    *(void *)a2 = v15;
    if (v14)
    {
      if (*(void *)v14 == 6LL)
      {
        v14[24] = 1;
        uint64_t v16 = v17 + v12;
        *((void *)v7 + 2) = v17 + v12;
        uint64_t result = (char *)ccder_sizeof(0x2000000000000010LL, v16);
        v6 += (uint64_t)result;
        uint64_t v7 = v15;
      }
    }

    return (char *)&unk_100065C88;
  }

  if (*(void *)v7 != 8LL) {
    return (char *)&unk_100065C88;
  }
  *a3 = ccder_sizeof(0xA000000000000010LL, v6);
  *((void *)v5 + 2) = v6;
  return (char *)&unk_100065C48;
}

uint64_t sub_100046D4C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v3 = HIBYTE(a2);
  if ((HIBYTE(a2) + 1) > 1u)
  {
    uint64_t v6 = 8LL;
  }

  else
  {
    if ((_DWORD)v3 == BYTE6(a2))
    {
      if ((_DWORD)v3 == BYTE5(a2))
      {
        if ((_DWORD)v3 == BYTE4(a2))
        {
          if ((_DWORD)v3 == BYTE3(a2))
          {
            if ((_DWORD)v3 == BYTE2(a2))
            {
              if (BYTE1(a2) == (_DWORD)v3) {
                uint64_t v4 = 2LL;
              }
              else {
                uint64_t v4 = 3LL;
              }
              uint64_t v5 = 1LL;
              if (BYTE1(a2) != (_DWORD)v3) {
                uint64_t v5 = 2LL;
              }
            }

            else
            {
              uint64_t v5 = 3LL;
              uint64_t v4 = 4LL;
            }
          }

          else
          {
            uint64_t v5 = 4LL;
            uint64_t v4 = 5LL;
          }
        }

        else
        {
          uint64_t v5 = 5LL;
          uint64_t v4 = 6LL;
        }
      }

      else
      {
        uint64_t v5 = 6LL;
        uint64_t v4 = 7LL;
      }
    }

    else
    {
      uint64_t v5 = 7LL;
      uint64_t v4 = 8LL;
    }

    else {
      uint64_t v6 = v5;
    }
  }

  uint64_t v12 = 0LL;
  unint64_t v13 = 0LL;
  uint64_t result = ccder_blob_reserve_tl(a1, 2LL, v6, &v12);
  if ((_DWORD)result)
  {
    unint64_t v8 = (unint64_t)v12;
    unint64_t v9 = (unint64_t)v13;
    if (v13 != v12)
    {
      unint64_t v10 = v13 - 1;
      while ((unint64_t)v10 < v9 && (unint64_t)v10 >= v8)
      {
        *unint64_t v10 = v2;
        v2 >>= 8;
        if (v10-- == v12) {
          return result;
        }
      }

      __break(0x5519u);
    }
  }

  return result;
}

void sub_100046E84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_100046E9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_100046EB4()
{
  uint64_t v0 = sub_1000015C0();
  _os_crash(v0, v1, v2, v3);
  __break(1u);
}

void sub_100046EC8()
{
  uint64_t v0 = _os_assert_log(0LL);
  _os_crash(v0, v1, v2, v3);
  __break(1u);
}

void sub_100046EE0(int a1)
{
  uint64_t v1 = sub_100001D48(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_100046EF4(int a1)
{
  uint64_t v1 = _os_assert_log(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_100046F0C(unint64_t a1)
{
  uint64_t v1 = _os_assert_log(HIBYTE(a1) ^ 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_100046F28(unint64_t a1)
{
  uint64_t v1 = _os_assert_log((a1 >> 27) ^ 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_100046F44(uint64_t a1)
{
  uint64_t result = _os_assumes_log_ctx(sub_10001C1B0, a1);
  *(void *)(a1 + 1352) |= 1uLL;
  return result;
}

void sub_100046F80(int a1)
{
  qword_100069AA0 = (uint64_t)"Bug in libxpc: mach_port_construct() failed";
  qword_100069AD0 = a1;
  __break(1u);
}

void sub_100046FA8(int a1)
{
  qword_100069AA0 = (uint64_t)"Bug in libxpc: mach_port_assert_attributes() failed";
  qword_100069AD0 = a1;
  __break(1u);
}

void sub_100046FD0()
{
  qword_100069AA0 = (uint64_t)"Configuration error: failed to fetch our own audit token";
  __break(1u);
}

void sub_100046FF0()
{
  uint64_t v0 = __error();
  uint64_t v1 = _os_assert_log(*v0);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_10004700C(char a1)
{
  uint64_t v1 = _os_assert_log(a1 & 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_100047024()
{
  uint64_t v0 = __error();
  return _os_assumes_log(*v0);
}

void sub_100047040(const char *a1)
{
  int v2 = *__error();
  uint64_t v3 = __error();
  uint64_t v4 = (const char *)xpc_strerror(*v3);
  sub_10003AB08(4, "Failed to set %s: %d - %s", a1, v2, v4);
}

void sub_100047098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1000470B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1000470C8()
{
  uint64_t v0 = __error();
  uint64_t v1 = sub_1000122A8(v0);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_1000470E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1000470F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_100047110(uint64_t a1)
{
  uint64_t v1 = _os_assert_log(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_100047610()
{
}

uint64_t sub_100047638()
{
  uint64_t v0 = __error();
  return sub_1000198A0(v0);
}

uint64_t sub_100047650(uint64_t a1)
{
  return _os_assumes_log_ctx(sub_10001C1B0, a1);
}

void sub_100047684(unsigned int a1)
{
  uint64_t v1 = _os_assert_log((a1 >> 4) ^ 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_1000476A0(unint64_t a1)
{
  uint64_t v1 = _os_assert_log((a1 >> 28) ^ 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_1000476BC(char a1)
{
  uint64_t v1 = _os_assert_log(a1 == 3);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_1000476DC(int a1, uint64_t a2, char a3)
{
  return _os_assumes_log_ctx(sub_10001C1B0, a2);
}

uint64_t sub_100047744( uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_assumes_log_ctx(sub_100025848, a1);
}

uint64_t sub_100047794()
{
  return _os_assumes_log_ctx(sub_100025848, qword_10006A400);
}

uint64_t sub_1000477BC(uint64_t a1)
{
  return _os_assumes_log_ctx(sub_100025848, a1);
}

void sub_1000477F0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1000341F8(a1, a2);
  uint64_t v4 = sub_1000341EC();
  uint64_t v5 = sub_100012884( "overflow of service activation count during deactivation. Managed:%d. Domain: %s. Service:%s",  v2,  v3,  v4);
  _os_crash(v5, v6, v7, v8);
  __break(1u);
}

void sub_10004782C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1000341F8(a1, a2);
  uint64_t v4 = sub_1000341EC();
  uint64_t v5 = sub_100012884( "underflow of service activation count during deactivate. Managed:%d. Domain: %s. Service:%s",  v2,  v3,  v4);
  _os_crash(v5, v6, v7, v8);
  __break(1u);
}

void sub_100047868(uint64_t a1)
{
  int v2 = sub_100034228(a1);
  uint64_t v3 = sub_1000341EC();
  uint64_t v4 = sub_100012884( "%s is being deactivated by a mismatched domain %s. Managed:%d.",  v2,  v3,  *(_DWORD *)(v1 + 296) != 0);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_1000478B0(uint64_t a1)
{
  int v2 = sub_100034210(a1);
  uint64_t v3 = sub_1000341EC();
  uint64_t v4 = sub_100012884( "overflow of service activation count during activate. Managed:%d. Domain:'%s'. Service:'%s'",  v1,  v2,  v3);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_1000478EC(uint64_t a1)
{
  int v2 = sub_100034210(a1);
  uint64_t v3 = sub_1000341EC();
  uint64_t v4 = sub_100012884( "underflow of service activation count during activate. Managed:%d. Domain:'%s'. Service:'%s'",  v1,  v2,  v3);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_100047928(uint64_t a1)
{
  int v2 = sub_100034228(a1);
  uint64_t v3 = sub_1000341EC();
  uint64_t v4 = sub_100012884("%s is being activated by a mismatched domain %s. Managed:%d.", v2, v3, *(_DWORD *)(v1 + 296) != 0);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_100047970()
{
  uint64_t v0 = sub_100019890();
  sub_1000198A0(v0);
  sub_10003CA58();
  sub_100019898();
}

void sub_100047990(unsigned int a1)
{
  qword_100069AA0 = (uint64_t)"libdispatch bug: Unknown send-right";
  qword_100069AD0 = a1;
  __break(1u);
}

void sub_1000479B8(const void *aBlock)
{
  qword_100069AA0 = (uint64_t)"libdispatch bug: Unknown receive-right";
  qword_100069AD0 = aBlock;
  __break(1u);
  _Block_copy(aBlock);
}