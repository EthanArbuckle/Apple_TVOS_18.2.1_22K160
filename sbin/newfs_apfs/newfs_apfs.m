uint64_t sub_1000029F0(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result;
  int v7;
  result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    result = 0LL;
    v7 = *a2 > *a4;
    if (*a2 < *a4) {
      v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

void *sub_100002A24(unsigned __int8 *a1, void *a2, unsigned int a3)
{
  unsigned int v6 = (2 * a3) | 1;
  bzero(a2, v6);
  if (a3)
  {
    uint64_t v7 = a3;
    v8 = (char *)a2;
    do
    {
      int v9 = *a1++;
      int v10 = snprintf(v8, v6, "%02hhx", v9);
      v8 += v10;
      v6 -= v10;
      --v7;
    }

    while (v7);
  }

  return a2;
}

uint64_t sub_100002AB4(int a1)
{
  switch(a1)
  {
    case 1:
      uint64_t result = ccsha256_di();
      break;
    case 2:
    case 5:
      uint64_t result = ccsha512_256_di();
      break;
    case 3:
      uint64_t result = ccsha384_di();
      break;
    case 4:
      uint64_t result = ccsha512_di();
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t sub_100002AF0(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 21) & 4) != 0) {
    return 0LL;
  }
  if ((sub_100037DC0(a1) & 0x8000000) != 0 || (*(_BYTE *)(a1 + 17) & 2) != 0)
  {
    LODWORD(v2) = 0;
  }

  else
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2) {
      LODWORD(v2) = (*(unsigned __int8 *)(*(void *)(v2 + 376) + 56LL) >> 5) & 1;
    }
  }

  if (*(_DWORD *)(a1 + 40) != 14) {
    return 0LL;
  }
  else {
    return v2 | ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 8) >> 3);
  }
}

uint64_t sub_100002B64(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  if (!a2) {
    return 22LL;
  }
  uint64_t result = sub_100002C74(a1, (uint64_t)__s1, a3, a4);
  if (!(_DWORD)result)
  {
    uint64_t result = memcmp(__s1, a2, a3);
    if ((_DWORD)result)
    {
      char v11 = -86;
      *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v10[6] = v7;
      v10[7] = v7;
      v10[4] = v7;
      v10[5] = v7;
      v10[2] = v7;
      v10[3] = v7;
      v10[0] = v7;
      v10[1] = v7;
      char v9 = -86;
      v8[6] = v7;
      v8[7] = v7;
      v8[4] = v7;
      v8[5] = v7;
      v8[2] = v7;
      v8[3] = v7;
      v8[0] = v7;
      v8[1] = v7;
      sub_100002A24((unsigned __int8 *)a2, v8, a3);
      sub_100002A24((unsigned __int8 *)__s1, v10, a3);
      sub_100013D94( "%s:%d: hash mismatch! expected: %s, actual: %s\n",  "authapfs_validate_node_hash",  234,  (const char *)v8,  (const char *)v10);
      return 80LL;
    }
  }

  return result;
}

uint64_t sub_100002C74(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t result = 22LL;
  if (a2 && (*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 8) != 0)
  {
    if (sub_100002E24(a4) || sub_100002E78(a4) != a3)
    {
      return 22LL;
    }

    else
    {
      uint64_t v9 = sub_100002AB4(a4);
      unsigned int v10 = sub_1000398C8(a1);
      ccdigest(v9, v10, *(void *)(a1 + 56), a2);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100002D08(void *a1, uint64_t a2)
{
  if ((byte_100070000 & 1) == 0) {
    return 0LL;
  }
  v4 = (const void *)a1[1];
  unint64_t v5 = a1[50];
  memset(__s2, 0, sizeof(__s2));
  if (!a2) {
    return a2;
  }
  __int128 v7 = (void *)(a2 + 32);
  if (!memcmp(v7, __s2, HIWORD(v5) & 0x7F)) {
    return 0LL;
  }
  a2 = sub_100002B64((uint64_t)a1, v7, HIWORD(v5) & 0x7F, (v5 >> 44) & 0xF);
  if ((_DWORD)a2)
  {
    uint64_t v8 = sub_10003965C((uint64_t)a1);
    uint64_t v9 = sub_100039664((uint64_t)a1);
    uint64_t v10 = sub_10003965C((uint64_t)v4);
    sub_100013D94("failed to validate node %p (oid:%llu, xid:%llu) of fs %p (%llu) - %d\n", a1, v8, v9, v4, v10, a2);
  }

  return a2;
}

uint64_t sub_100002E24(unsigned int a1)
{
  if (a1 <= 5 && (a1 & 0xFFFFFFFD) != 0) {
    return 0LL;
  }
  sub_100013D94("%s:%d: Invalid or unknown hash type: %d\n", "authapfs_valid_hash_type", 50, a1);
  return 22LL;
}

uint64_t sub_100002E78(int a1)
{
  else {
    return dword_100053940[a1 - 1];
  }
}

double sub_100002E9C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v3 = *a3;
  if (*a3 > 5u || (*a3 & 0xFFFFFFFD) == 0)
  {
    sub_100013D94("%s:%d: Invalid or unknown hash type: %d\n", "authapfs_valid_hash_type", 50, *a3);
  }

  else
  {
    *(void *)&double result = 2LL;
    *(void *)(a1 + 32) = 2LL;
    *(_DWORD *)(a1 + 40) = v3;
    *(_DWORD *)(a1 + 44) = 128;
  }

  return result;
}

uint64_t sub_100002F0C(uint64_t a1)
{
  v1 = *(_DWORD **)(a1 + 56);
  unsigned int v2 = v1[10];
  if (v2 - 1 > 4) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = dword_100053940[v2 - 1];
  }
  if (v1[8])
  {
    uint64_t v4 = v1[11];
    if (v4 >= 0x30)
    {
      if (v2 > 5 || (v2 & 0xFFFFFFFD) == 0)
      {
        sub_100013D94("%s:%d: Invalid or unknown hash type: %d\n", "authapfs_valid_hash_type", 50, v1[10]);
      }

      else if (*(_DWORD *)(a1 + 48) >= v4 + v3)
      {
        uint64_t v6 = 0LL;
        *(void *)(a1 + 376) = v1;
        *(void *)(a1 + 384) = (char *)v1 + v4;
        *(_DWORD *)(a1 + 392) = v3;
        return v6;
      }
    }
  }

  return 92LL;
}

uint64_t sub_100002FC0(uint64_t a1, char **a2, int a3)
{
  if (!a1) {
    return 22LL;
  }
  if (!a2 && !a3) {
    return 22LL;
  }
  unint64_t v7 = *(void *)(*(void *)(a1 + 376) + 1024LL);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 392);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1720));
    uint64_t v9 = *(char **)(a1 + 3600);
    if (v9)
    {
      if (a2)
      {
        sub_10003DC28(v9);
        *a2 = *(char **)(a1 + 3600);
      }

      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1720));
      return 0LL;
    }

    v13 = (char *)0xAAAAAAAAAAAAAAAALL;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1720));
    uint64_t result = sub_10003B574( *(void *)(v8 + 392),  0,  v7,  (int *)&xmmword_100053930,  0LL,  a1,  *(void *)(a1 + 432),  0LL,  (uint64_t *)&v13);
    if (!(_DWORD)result)
    {
      char v11 = v13;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 3904));
      v12 = (int32x2_t *)*((void *)v11 + 47);
      *(int32x2_t *)(a1 + 3972) = vrev64_s32(v12[4]);
      *(int32x2_t *)(a1 + 3984) = v12[6];
      *(_BYTE *)(a1 + 3968) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3904));
      if (a3)
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 1720));
        if (!*(void *)(a1 + 3600))
        {
          sub_10003DC28(v13);
          *(void *)(a1 + 3600) = v13;
        }

        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1720));
      }

      if (!a2)
      {
        sub_100038824((uint64_t *)v13);
        return 0LL;
      }

      uint64_t result = 0LL;
      *a2 = v13;
    }
  }

  else
  {
    uint64_t v10 = sub_10003965C(a1);
    sub_100013D94( "%s:%d: %s integrity_meta object of fs %llu, oid invalid\n",  "authapfs_integrity_meta_get_internal",  168,  (const char *)(a1 + 3992),  v10);
    return 2LL;
  }

  return result;
}

uint64_t sub_100003158(uint64_t a1, _DWORD *a2)
{
  uint64_t v8 = 0LL;
  if (!a2) {
    return 22LL;
  }
  uint64_t result = sub_100002FC0(a1, &v8, 0);
  if (!(_DWORD)result)
  {
    uint64_t v4 = (uint64_t *)v8;
    unsigned int v5 = *((_DWORD *)v8 + 98);
    if (v5 >= 0x40) {
      size_t v6 = 64LL;
    }
    else {
      size_t v6 = v5;
    }
    unint64_t v7 = (const void *)*((void *)v8 + 48);
    a2[6] = *(_DWORD *)(*((void *)v8 + 47) + 40LL);
    a2[7] = v5;
    a2[5] |= 0x180u;
    memcpy(a2 + 8, v7, v6);
    sub_100038824(v4);
    return 0LL;
  }

  return result;
}

uint64_t sub_1000031DC(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  int v14 = a2;
  v13 = 0LL;
  if (!a1) {
    return 22LL;
  }
  if (*(_DWORD *)(a1 + 1100)) {
    return 30LL;
  }
  uint64_t v8 = *(void *)(a1 + 392);
  if (!a4 && *(void *)(*(void *)(a1 + 376) + 1024LL)) {
    return 17LL;
  }
  uint64_t v9 = sub_10003CF9C((void *)a1, 0, a3);
  if ((_DWORD)v9)
  {
    uint64_t v5 = v9;
    sub_100013D94( "%s:%d: %s obj_modify failed - %d\n",  "authapfs_integrity_meta_create",  426,  (const char *)(a1 + 3992),  v9);
  }

  else
  {
    uint64_t v10 = sub_10003A068( *(pthread_mutex_t **)(v8 + 392),  0,  0LL,  (uint64_t)&xmmword_100053930,  (uint64_t)&v14,  a1,  a3,  (uint64_t *)&v13);
    if ((_DWORD)v10)
    {
      uint64_t v5 = v10;
      sub_100013D94( "%s:%d: %s obj_create failed - %d\n",  "authapfs_integrity_meta_create",  439,  (const char *)(a1 + 3992),  v10);
    }

    else
    {
      sub_10003E644((uint64_t)v13, a3, 0LL);
      uint64_t v11 = sub_10003965C((uint64_t)v13);
      if (a4)
      {
        uint64_t v5 = 0LL;
        *a4 = v13;
      }

      else
      {
        *(void *)(*(void *)(a1 + 376) + 1024LL) = v11;
        sub_10001AAF0(a1, a3);
        sub_100038824(v13);
        return 0LL;
      }
    }
  }

  return v5;
}

uint64_t sub_100003340(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 1720);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1720));
  uint64_t v5 = *(void *)(a1 + 3600);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 376);
    unint64_t v7 = (unsigned int *)(v6 + 36);
    uint64_t v8 = (unsigned int *)(v6 + 32);
    uint64_t v9 = (unint64_t *)(v6 + 48);
  }

  else
  {
    pthread_mutex_unlock(v4);
    if (!*(_BYTE *)(a1 + 3968)) {
      return 0LL;
    }
    uint64_t v4 = (pthread_mutex_t *)(a1 + 3904);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 3904));
    unint64_t v7 = (unsigned int *)(a1 + 3972);
    uint64_t v8 = (unsigned int *)(a1 + 3976);
    uint64_t v9 = (unint64_t *)(a1 + 3984);
  }

  unint64_t v10 = *v9;
  unsigned int v11 = *v8;
  unsigned int v12 = *v7;
  pthread_mutex_unlock(v4);
  if (a2) {
    BOOL v13 = v11 >= 2;
  }
  else {
    BOOL v13 = 0;
  }
  int v14 = !v13;
  uint64_t result = v14 & v12;
  if (v13 && (v12 & 1) != 0) {
    return sub_100039664(a2) >= v10;
  }
  return result;
}

uint64_t sub_100003404(void *a1)
{
  uint64_t v1 = a1[7];
  a1[47] = v1;
  a1[48] = v1 + 32;
  return 0LL;
}

uint64_t sub_100003418(uint64_t a1, uint64_t a2, unsigned __int16 **a3)
{
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  v8[0] = 5242881LL;
  v8[1] = a2;
  uint64_t v5 = sub_100019054(a1, 3, 0LL, (unsigned __int8 *)v8, a3);
  uint64_t v6 = v5;
  if ((_DWORD)v5) {
    sub_100013D94( "%s:%d: %s Couldn't find snap_meta for xid %llu: %d\n",  "fs_lookup_snapshot_metadata_by_xid",  445,  (const char *)(a1 + 3992),  a2,  v5);
  }
  return v6;
}

uint64_t sub_1000034B4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 392) + 392LL);
  unint64_t v7 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_10003B574(v4, 0x40000000u, a2, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, (uint64_t *)&v7);
  if (!(_DWORD)v5)
  {
    sub_10003B238(v7, a3);
    sub_100038824(v7);
  }

  return v5;
}

uint64_t sub_100003530(uint64_t a1, int a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 392) + 392LL);
  v16 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003B574(v9, 0x40000000u, a3, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, a4, (uint64_t *)&v16);
  if (!(_DWORD)result)
  {
    uint64_t v11 = v16[47];
    if (a2 == 6)
    {
      __int128 v12 = (unint64_t *)(v11 + 1048);
      BOOL v13 = (int *)(v11 + 1044);
    }

    else
    {
      if (a2 != 5)
      {
        sub_100038824(v16);
        return 45LL;
      }

      __int128 v12 = (unint64_t *)(v11 + 1032);
      BOOL v13 = (int *)(v11 + 1040);
    }

    int v14 = *v13;
    unint64_t v15 = *v12;
    sub_100038824(v16);
    if (v15) {
      return sub_100003864(a1, v14, a2, a4, v15, a5);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100003614(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v8 = 0LL;
  uint64_t v6 = sub_100016560(a1, 3, 0LL, &v8);
  if (!(_DWORD)v6)
  {
    uint64_t v6 = sub_100029238((size_t)v8, a2, a3);
    sub_100038824(v8);
    if (!(_DWORD)v6)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1464));
      *(void *)(*(void *)(a1 + 376) + 152LL) = 0LL;
      sub_10001AAF0(a1, a2);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1464));
    }
  }

  return v6;
}

uint64_t sub_1000036B0(uint64_t a1)
{
  unint64_t __dst = 0xAAAAAAAAAAAAAAAALL;
  else {
    return __dst;
  }
}

uint64_t sub_1000036FC(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v15 = 0LL;
  if (a3 == 5)
  {
    uint64_t v9 = 0x20000001FLL;
    __int128 v10 = sub_100004E88;
    unsigned int v12 = 16;
    int v11 = 16;
  }

  else
  {
    if (a3 != 6)
    {
      sub_100013D94( "%s:%d: %s unsupported tree type: %d\n",  "supplemental_tree_get_descriptor",  64,  (const char *)(a1 + 3992),  a3);
      return 45LL;
    }

    uint64_t v9 = 32LL;
    __int128 v10 = sub_1000029F0;
    int v11 = 24;
    unsigned int v12 = 8;
  }

  v16[1] = 0LL;
  __int128 v17 = 0u;
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v18 = 0u;
  v16[0] = (uint64_t)v10;
  v16[2] = v9;
  if ((unsigned __int16)a2 != 2)
  {
    uint64_t v13 = 22LL;
    goto LABEL_10;
  }

  uint64_t v13 = sub_100027934(a1, a2 & 0xFFFF0000, 0, v12, v11, v16, a4, (uint64_t *)&v15);
  if ((_DWORD)v13)
  {
LABEL_10:
    sub_100013D94( "%s:%d: %s Failed to create supplemental tree (type %d): %d\n",  "supplemental_tree_create",  123,  (const char *)(a1 + 3992),  a3,  v13);
    return v13;
  }

  *a5 = sub_10003965C((uint64_t)v15);
  sub_100038824(v15);
  return v13;
}

uint64_t sub_100003864(uint64_t a1, int a2, int a3, uint64_t a4, unint64_t a5, void *a6)
{
  if (a3 == 5)
  {
    uint64_t v11 = 0x20000001FLL;
    unsigned int v12 = sub_100004E88;
  }

  else
  {
    if (a3 != 6)
    {
      sub_100013D94( "%s:%d: %s unsupported tree type: %d\n",  "supplemental_tree_get_descriptor",  64,  (const char *)(a1 + 3992),  a3);
      return 45LL;
    }

    uint64_t v11 = 32LL;
    unsigned int v12 = sub_1000029F0;
  }

  __int128 v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  if (!a5)
  {
    uint64_t v13 = sub_100016560(a1, a3, a4, &v18);
    if ((_DWORD)v13) {
      return v13;
    }
    goto LABEL_11;
  }

  v19[1] = 0LL;
  __int128 v20 = 0u;
  uint64_t v24 = 0LL;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v21 = 0u;
  v19[0] = v12;
  v19[2] = v11;
  if ((unsigned __int16)a2 != 2)
  {
    uint64_t v13 = 22LL;
    goto LABEL_15;
  }

  uint64_t v13 = sub_100027CC4(a1, a2 & 0xFFFF0000, a5, 0LL, 0, (uint64_t)v19, 0LL, &v18);
  if ((_DWORD)v13)
  {
LABEL_15:
    v16 = strerror(v13);
    sub_100013D94( "%s:%d: %s Failed to get supplemental tree (type %d, oid %llu): %d (%s)\n",  "supplemental_tree_destroy",  159,  (const char *)(a1 + 3992),  a3,  a5,  v13,  v16);
    return v13;
  }

LABEL_11:
  uint64_t v14 = sub_100029238((size_t)v18, a4, a6);
  uint64_t v13 = v14;
  if ((_DWORD)v14)
  {
    unint64_t v15 = strerror(v14);
    sub_100013D94( "%s:%d: %s Failed to delete supplemental tree (type %d): %d (%s)\n",  "supplemental_tree_destroy",  167,  (const char *)(a1 + 3992),  a3,  v13,  v15);
  }

  sub_100038824(v18);
  return v13;
}

  v27 = 0LL;
LABEL_12:
  v28 = 0LL;
LABEL_109:
  v61 = v144;
  if ((void)v144)
  {
    if ((void)v144 != v28 && (void)v144 != v27)
    {
      sub_10003D514(v144, 2);
      sub_100038824(v61);
    }

    *(void *)&v144 = 0LL;
  }

  v63 = v143;
  if ((void)v143)
  {
    if ((void)v143 != v28 && (void)v143 != v27)
    {
      sub_10003D514(v143, 2);
      sub_100038824(v63);
    }

    *(void *)&v143 = 0LL;
  }

  v64 = v142;
  if ((void)v142)
  {
    if ((void)v142 != v28 && (void)v142 != v27)
    {
      sub_10003D514(v142, 2);
      sub_100038824(v64);
    }

    *(void *)&v142 = 0LL;
  }

  if (v28 && v28 != (void)v144 && v28 != (void)v143)
  {
    sub_10003D514(v28, 2);
    sub_100038824(v28);
    v27 = v141;
  }

  if (v27 && v27 != (void)v144 && v27 != (void)v143 && v27 != (void)v142)
  {
    sub_10003D514(v27, 2);
    sub_100038824(v27);
  }

  return v24;
}

  uint64_t v8 = sub_10004E8F0(a1, a2, 0);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)v4);
  }
  return v8;
}

const char *sub_100003A48()
{
  return "2317.60.23.0.1";
}

uint64_t sub_100003A54()
{
  return 0x83B5A93981BC1LL;
}

uint64_t sub_100003A68(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_100003A9C(void *a1)
{
  uint64_t v1 = a1[7];
  a1[47] = v1;
  a1[48] = v1 + 32;
  return 0LL;
}

uint64_t sub_100003AB0(void *a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 22LL;
  }
  uint64_t result = 0LL;
  uint64_t v5 = *a3;
  a1[4] = a3[2];
  a1[5] = v5;
  a1[6] = 0LL;
  return result;
}

uint64_t sub_100003AD8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 376) = *(void *)(a1 + 56);
  *(void *)(a1 + 408) = 8LL * *(unsigned int *)(a1 + 48) - 256;
  if (a2) {
    *(void *)(a1 + 384) = *(void *)(a2 + 24);
  }
  return 0LL;
}

uint64_t sub_100003B04(void *a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (void *)a1[1];
  uint64_t v9 = *(void *)(*a1 + 392LL);
  if (v8) {
    uint64_t v10 = a1[1];
  }
  else {
    uint64_t v10 = *(void *)(*a1 + 392LL);
  }
  uint64_t v37 = a1[2];
  v42 = 0LL;
  if (v8)
  {
    int v11 = sub_10003CF9C(v8, 0, a5);
    if (v11)
    {
      int v12 = v11;
      else {
        uint64_t v13 = (const char *)(v8[48] + 208LL);
      }
      uint64_t v14 = sub_10003965C((uint64_t)v8);
      sub_100013D94("%s:%d: %s obj_modify(fs %lld) failed: %d\n", "gbitmap_reap", 160, v13, v14, v12);
    }
  }

  int v15 = sub_100003E94(a1, 0LL, 0LL, &v42);
  if (v15)
  {
    int v16 = v15;
    else {
      __int128 v17 = (const char *)(*(void *)(v10 + 384) + 208LL);
    }
    sub_100013D94("%s:%d: %s Can't get tree: %d\n", "gbitmap_reap", 166, v17, v16);
  }

  if (v42)
  {
    unint64_t v18 = *a3;
    unint64_t v40 = 0LL;
    unint64_t v41 = v18;
    unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v38[2] = v19;
    v38[3] = v19;
    v38[0] = v19;
    v38[1] = v19;
    sub_100026ED4((uint64_t)v38, (uint64_t)v42, 0LL, 0, &v41, 8, 8u, &v40, 8u);
    int v21 = v20;
    v36 = (const char *)(v10 + 3992);
    int v22 = 1023;
    if (v20)
    {
LABEL_31:
      if (v21 != 2)
      {
        else {
          sub_100013D94( "%s:%d: %s Tree iteration threw %d at cursor %llu\n",  "gbitmap_reap",  203,  (const char *)(*(void *)(v10 + 384) + 208LL),  v21,  v41);
        }
      }
    }

    else
    {
      while (!sub_100026EFC((uint64_t)v38))
      {
        if ((v37 & 0x40000000) != 0 && (unint64_t v23 = v40, (v40 & 0x8000000000000000LL) != 0))
        {
          v40 &= ~0x8000000000000000LL;
          sub_10004BD08((const char *)v10, 0LL, v23 & 0x7FFFFFFFFFFFFFFFLL, 1LL, a5);
        }

        else
        {
          int v24 = *((_DWORD *)a1 + 4);
          if (v8) {
            unint64_t v25 = sub_10003965C((uint64_t)v8);
          }
          else {
            unint64_t v25 = 0LL;
          }
          uint64_t v26 = *(void *)(v9 + 392);
          unsigned int v27 = v24 & 0xD8000000 | 0x1B;
          int v28 = sub_1000398C8((uint64_t)a1);
          int v29 = sub_10003B27C(v26, v27, v28, v25, v40, a5);
          if (v29)
          {
            int v30 = v29;
            if (sub_100037DC8(v10) == 13) {
              sub_100013D94( "%s:%d: %s deletion threw %d for cursor %llu, oid %llu, oflags 0x%x\n",  "gbitmap_reap",  188,  v36,  v30,  v41,  v40,  v27);
            }
            else {
              sub_100013D94( "%s:%d: %s deletion threw %d for cursor %llu, oid %llu, oflags 0x%x\n",  "gbitmap_reap",  188,  (const char *)(*(void *)(v10 + 384) + 208LL),  v30,  v41,  v40,  v27);
            }
          }
        }

        *a3 = v41 + 1;
        if (!v22)
        {
          uint64_t v31 = 36LL;
          goto LABEL_41;
        }

        int v21 = sub_100026F18((uint64_t)v38);
        --v22;
        if (v21) {
          goto LABEL_31;
        }
      }
    }

    int v32 = sub_100029238((size_t)v42, a5, 0LL);
    if (v32)
    {
      int v33 = v32;
      uint64_t v34 = sub_10003965C((uint64_t)v42);
      sub_100013D94("%s:%d: %s Tree delete oid %llu threw %d\n", "gbitmap_reap", 208, v36, v34, v33);
    }
  }

  sub_10003B238(a1, a5);
  uint64_t v31 = 0LL;
LABEL_41:
  if (v42) {
    sub_100038824(v42);
  }
  return v31;
}

uint64_t sub_100003E94(void *a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  if (a1[1]) {
    uint64_t v8 = a1[1];
  }
  else {
    uint64_t v8 = *(void *)(*a1 + 392LL);
  }
  *a4 = 0LL;
  unsigned int v9 = sub_1000398C0((uint64_t)a1) & 0xFFFFFC00;
  return sub_100027FC4(v8, v9, *(void *)(a1[47] + 32LL), a2, 3, a3 != 0, 26, (uint64_t)sub_100003A68, a3, a4);
}

uint64_t sub_100003F20(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

void sub_100003F54()
{
  v0 = (char *)off_100070140;
  if (!off_100070140)
  {
    do
    {
      unsigned int v1 = 0;
      for (int i = 0; i != 8; ++i)
      {
        unsigned int v3 = (v0 >> i) ^ v1;
        unsigned int v4 = v1 >> 1;
        unsigned int v1 = (v1 >> 1) ^ 0x82F63B78;
        if ((v3 & 1) == 0) {
          unsigned int v1 = v4;
        }
      }

      dword_100070148[(void)v0++] = v1;
    }

    while (v0 != (char *)256);
    off_100070140 = (uint64_t (*)(void, void, void))sub_100003FC0;
  }
}

  ;
}

uint64_t sub_100003FC0(uint64_t result, char *a2, uint64_t a3)
{
  {
    char v3 = *a2++;
    uint64_t result = dword_100070148[(v3 ^ result)] ^ (result >> 8);
  }

  return result;
}

uint64_t sub_100003FEC( unint64_t a1, uint64_t a2, int a3, void (*a4)(_OWORD *, uint64_t, uint64_t), uint64_t a5)
{
  unint64_t v19 = a1;
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = a1 + a2;
  int v17 = 0;
  int v18 = -1431655766;
  int v16 = 0;
  char v15 = 1;
  do
  {
    *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[6] = v9;
    v21[7] = v9;
    v21[5] = v9;
    v21[3] = v9;
    v21[4] = v9;
    v21[1] = v9;
    v21[2] = v9;
    v20[1] = v9;
    v21[0] = v9;
    v20[0] = v9;
    unsigned int v14 = 0;
    char v13 = 0;
    uint64_t v10 = sub_100004144( &v19,  v8,  a3,  (unsigned int *)v22,  (uint64_t)&v18,  &v17,  &v16,  (uint64_t)v21,  (uint64_t)v20,  (int *)&v14,  &v13,  &v15);
    if ((_DWORD)v10) {
      break;
    }
    uint64_t v11 = v14;
    if ((int)v14 >= 1)
    {
      if (v13) {
        sub_1000048FC((uint64_t)v21, (uint64_t)v20, v14);
      }
      a4(v21, 4 * v11, a5);
    }
  }

  while (v19 < v8 || v17 > 0);
  return v10;
}

uint64_t sub_100004144( unint64_t *a1, unint64_t a2, int a3, unsigned int *a4, uint64_t a5, int *a6, int *a7, uint64_t a8, uint64_t a9, int *a10, _BYTE *a11, _BYTE *a12)
{
  int v18 = *a6;
  int v19 = *a7;
  if (*a6 >= 1 && v19 < v18)
  {
    int v22 = 0;
    *a11 = 0;
    *a10 = 0;
    int v19 = *a7;
    while (1)
    {
      if (v22 >= 1
        && *(_BYTE *)(a5 + v19)
        && *(unsigned __int8 *)(a5 + v19) < *(unsigned __int8 *)(a9 + (v22 - 1)))
      {
        *a11 = 1;
      }

      *(_DWORD *)(a8 + 4LL * v22) = a4[v19];
      uint64_t v23 = *a7;
      *a7 = v23 + 1;
      LOBYTE(v23) = *(_BYTE *)(a5 + v23);
      uint64_t v24 = *a10;
      *a10 = v24 + 1;
      *(_BYTE *)(a9 + v24) = v23;
      int v19 = *a7;
      int v18 = *a6;
      if (*a7 >= *a6 || !*(_BYTE *)(a5 + v19)) {
        break;
      }
      int v22 = *a10;
    }
  }

  if (v19 < v18) {
    return 0LL;
  }
  uint64_t result = 0LL;
  *a6 = 0;
  *a7 = 0;
  unint64_t v25 = (unsigned __int8 *)*a1;
  if (*a1 < a2)
  {
    while (1)
    {
      unsigned int v27 = v25 + 1;
      *a1 = (unint64_t)(v25 + 1);
      unsigned int v28 = *v25;
      uint64_t result = 92LL;
      if (!*v25 || v28 == 47) {
        return result;
      }
      if ((v28 & 0x80) == 0)
      {
        uint64_t result = 0LL;
        if (v28 - 91 < 0xFFFFFFE6) {
          int v66 = 1;
        }
        else {
          int v66 = a3;
        }
        if (v66) {
          unsigned int v67 = *v25;
        }
        else {
          unsigned int v67 = v28 + 32;
        }
        *a4 = v67;
        *a6 = 1;
        *(_BYTE *)a5 = 0;
        goto LABEL_136;
      }

      if (v28 - 225 > 0xB)
      {
        if (v28 - 194 <= 0x1D && (unint64_t)v27 < a2)
        {
          unsigned int v33 = *v27 ^ 0x80;
          if (v33 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0x1F) << 6) | v33;
            unsigned int v27 = v25 + 2;
            goto LABEL_52;
          }
        }
      }

      else if ((unint64_t)(v25 + 2) < a2)
      {
        unsigned int v29 = *v27 ^ 0x80;
        if (v29 <= 0x3F)
        {
          unsigned int v30 = v25[2] ^ 0x80;
          if (v30 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0xF) << 12) | (v29 << 6) | v30;
            unsigned int v27 = v25 + 3;
            goto LABEL_52;
          }
        }
      }

      if (v28 > 0xEF)
      {
        if (v28 > 0xFD)
        {
          unsigned __int8 v36 = 0;
          goto LABEL_41;
        }

        if (v28 <= 0xF7) {
          char v34 = 3;
        }
        else {
          char v34 = 4;
        }
        BOOL v35 = v28 > 0xFB;
      }

      else
      {
        char v34 = v28 > 0xDF;
        BOOL v35 = v28 > 0xBF;
      }

      if (v35) {
        unsigned __int8 v36 = v34 + 1;
      }
      else {
        unsigned __int8 v36 = v34;
      }
LABEL_41:
      unsigned int v31 = -1;
      if ((unint64_t)&v27[v36] <= a2)
      {
        unsigned int v37 = v28 & ~(-1 << (6 - v36));
        if (v36 == 1) {
          goto LABEL_49;
        }
        if (v36 == 2
          || v36 == 3
          && (unsigned int v27 = v25 + 2, v38 = v25[1] ^ 0x80, v31 = -1, v38 <= 0x3F)
          && (unsigned int v37 = v38 | (v37 << 6), v37 <= 0x10F))
        {
          int v39 = *v27++;
          int v40 = v39 ^ 0x80;
          unsigned int v31 = -1;
          if ((v39 ^ 0x80u) <= 0x3F)
          {
            unsigned int v37 = v40 | (v37 << 6);
            if ((v37 & 0xFFE0) != 0x360)
            {
LABEL_49:
              int v41 = *v27++;
              int v42 = v41 ^ 0x80;
            }
          }
        }
      }

LABEL_52:
      *a1 = (unint64_t)v27;
      *(_BYTE *)a5 = 0;
      if (v31 >= 0xF0000)
      {
        if ((~v31 & 0xFFFE) == 0) {
          goto LABEL_137;
        }
LABEL_55:
        *a4 = v31;
        goto LABEL_63;
      }

      int v43 = v31;
      if (v31 >> 10 >= 0xC9)
      {
        if (v31 - 918016 < 0xFFFFFE00) {
          goto LABEL_137;
        }
        int v43 = v31 - 711680;
      }

      int v44 = (unsigned __int16)word_1000539B8[v43 >> 8];
      if (!word_1000539B8[v43 >> 8]) {
        goto LABEL_62;
      }
      if (v44 == 0xFFFF) {
        goto LABEL_137;
      }
      if ((v44 & 0xFF00) == 0xAD00)
      {
LABEL_62:
        *a4 = v31;
        *(_BYTE *)a5 = v44;
        goto LABEL_63;
      }

      int v52 = word_1000563C0[16 * (v44 & 0xFFF) + (v43 >> 4)];
      if (!v52)
      {
LABEL_83:
        *a4 = v31;
        *(_BYTE *)a5 = v52;
        goto LABEL_84;
      }

      if (v52 == 0xFFFF) {
        goto LABEL_137;
      }
      if ((v52 & 0xFF00) == 0xAE00)
      {
        *a4 = v31;
        int v45 = 1;
        if (v31 <= 0x4FF && (a3 & 1) == 0) {
          *a4 = word_100057620[v31];
        }
        goto LABEL_64;
      }

      if ((v52 & 0xFF00) == 0xAD00) {
        goto LABEL_83;
      }
      if (v52 == 44032 || (unsigned int v54 = (unsigned __int16)word_100058020[16 * (v52 & 0xFFF) + (v43 & 0xF)], v54 == 44032))
      {
LABEL_77:
        signed int v48 = v31 - 44032;
        int v49 = v48 / 28;
        int v50 = v48 / 588;
        *(_WORD *)(a5 + 1) = 0;
        int v51 = v48 % 28;
        *a4 = v50 + 4352;
        a4[1] = (unsigned __int16)(v49
                                 - 21
                                 * (((__int16)((49933 * (__int16)v49) >> 16) >> 4)
        if (v51)
        {
          a4[2] = v51 + 4519;
          int v45 = 3;
        }

        else
        {
          int v45 = 2;
        }

        goto LABEL_64;
      }

      if (v54 == 0xFFFF)
      {
LABEL_137:
        int v68 = -1;
        goto LABEL_138;
      }

      if (((unsigned __int16)(v54 + 1792) >> 8) <= 0xB6u)
      {
        if (!v54 || (v54 & 0xFF00) == 0xAD00)
        {
          *a4 = v31;
          *(_BYTE *)a5 = v54;
        }

        else
        {
          *a4 = v54;
        }

LABEL_84:
        if ((a3 & 1) == 0)
        {
          uint64_t v53 = (int)*a4;
          if ((int)v53 <= 1279)
          {
            unsigned int v31 = word_100057620[v53];
            goto LABEL_55;
          }
        }

LABEL_63:
        int v45 = 1;
LABEL_64:
        *a6 = v45;
        goto LABEL_65;
      }

      switch(((v54 & 0xF000) - 45056) >> 12)
      {
        case 0u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_55;
          }
          v69 = 0LL;
          v55 = (char *)&unk_100054112 + 4 * (v54 & 0x7FF);
          int v45 = 2;
          goto LABEL_113;
        case 1u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_55;
          }
          v69 = 0LL;
          v55 = (char *)&unk_100054D26 + 6 * (v54 & 0x7FF);
          int v45 = 3;
          goto LABEL_113;
        case 2u:
          v69 = 0LL;
          v56 = (unsigned __int16 *)((char *)&unk_10005525A + 2 * (v54 & 0x3FF));
          unsigned int v58 = *v56;
          v55 = (char *)(v56 + 1);
          unsigned int v57 = v58;
          goto LABEL_112;
        case 3u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_55;
          }
          v55 = 0LL;
          v69 = (int *)((char *)&unk_1000553E8 + 4 * (v54 & 0x7FF));
          int v45 = 1;
          goto LABEL_113;
        case 4u:
          v55 = 0LL;
          v59 = (_DWORD *)((char *)&unk_100056264 + 4 * (v54 & 0x3FF));
          unsigned int v57 = *v59;
          v69 = v59 + 1;
LABEL_112:
          int v45 = v57 & 0xF;
          *(_BYTE *)a5 = v57 >> 4;
          if ((v45 - 5) < 0xFFFFFFFC)
          {
            int v68 = 0;
LABEL_138:
            *a6 = v68;
            return result;
          }

LABEL_113:
          uint64_t v60 = 0LL;
          v70 = a12;
          int v71 = a3;
          do
          {
            if (v55)
            {
              int v62 = *(unsigned __int16 *)v55;
              v55 += 2;
              int v61 = v62;
            }

            else
            {
              int v61 = *v69++;
            }

            a4[v60] = v61;
            if (v60)
            {
              uint64_t v72 = v60;
              v73 = v55;
              char v63 = sub_100004DC0(v61);
              uint64_t v60 = v72;
              v55 = v73;
              *(_BYTE *)(a5 + v72) = v63;
            }

            ++v60;
            a12 = v70;
            a3 = v71;
          }

          while (v45 != v60);
          if ((v71 & 1) != 0) {
            goto LABEL_126;
          }
          uint64_t v64 = (int)*a4;
          uint64_t v65 = (v45 - 1);
LABEL_126:
          *a6 = v45;
          if (v45 < 1) {
            return 92LL;
          }
          break;
        default:
          goto LABEL_137;
      }

      v84 = *(void *)(v67[47] + 56);
      if (v84)
      {
        sub_100013CBC( "%s:%d: %s unsupported nx_readonly_compatible_features (0x%llx): mount r/o\n",  "nx_mount",  1648,  (const char *)(v67[48] + 208),  v84);
        unsigned int v67 = v126;
        *((_BYTE *)v126 + 627) = 1;
      }

      sub_10003E8B8(v67[49]);
      v85 = (const char *)v126;
      if (((*((_BYTE *)v126 + 633) != 0) & v55) != 0)
      {
        v86 = 1;
      }

      else
      {
        v115 = *((_DWORD *)v20 + 36);
        v117 = *((_DWORD *)v20 + 34);
        sub_100013CBC( "%s:%d: %s stable checkpoint indices: desc %d data %d\n",  "nx_mount",  1662,  (const char *)(v126[48] + 208),  v117,  v115);
        v85 = (const char *)v126;
        v86 = *((unsigned __int8 *)v126 + 633);
      }

      if ((v86 == 0) | v55 & 1)
      {
        *(void *)(v50 + 136) = 0LL;
        *(void *)(v50 + 144) = 0LL;
        *(void *)(v50 + 1264) &= ~2uLL;
        sub_10001312C(v85);
        v88 = v126;
        if (*((_BYTE *)v126 + 629))
        {
          int v21 = sub_100044238(v126, (uint64_t *)&v124);
          if ((_DWORD)v21)
          {
LABEL_137:
            sub_100013D94("%s:%d: %s failed to set up spaceman for demo mode: %d\n");
            goto LABEL_146;
          }

          j__pthread_mutex_lock((pthread_mutex_t *)v126[49]);
          v89 = v126 + 52;
          v126[52] = 0LL;
          int v21 = sub_10003A0A0(v124, 0, v89, 0LL);
          sub_100036F84(v126[49]);
          if ((_DWORD)v21)
          {
            sub_100038824((uint64_t *)v124);
            goto LABEL_137;
          }

          sub_10003DE74(v126[52], 0);
          sub_100038824((uint64_t *)v124);
          v88 = v126;
        }

        v90 = v110 + 1;
        int v21 = sub_10004E2FC((uint64_t)v88, v110 + 1, v88 + 50);
        v91 = v126;
        if ((_DWORD)v21)
        {
          sub_100013D94("%s:%d: %s tx manager initialization failed: %d\n");
          goto LABEL_146;
        }

        v92 = v126[50];
        *(_DWORD *)(v92 + 104) = v117;
        *(_DWORD *)(v92 + 108) = v115;
        if ((v112 & 1) == 0)
        {
          sub_100013D04( "%s:%d: %s sanity checking all container state... please be patient.\n",  "nx_mount",  1719,  (const char *)(v91[48] + 208));
          int v21 = sub_100007718(v126, 0);
          v91 = v126;
          if ((_DWORD)v21)
          {
            sub_100013D94("%s:%d: %s failed nx_check sanity: %d\n");
            goto LABEL_146;
          }
        }

        if (*((_BYTE *)v91 + 627))
        {
LABEL_180:
          sub_100014004(v20, __na);
          v105 = v126;
          if (*(void *)(v126[47] + 1248))
          {
            if (!*((_BYTE *)v126 + 627))
            {
              int v21 = sub_100013384(v126);
              v105 = v126;
              if ((_DWORD)v21)
              {
                sub_100013D94( "%s:%d: %s nx_unblock_physical_range failed with error: %d\n",  "nx_mount",  1853,  (const char *)(v126[48] + 208),  v21);
                int v20 = 0LL;
                goto LABEL_146;
              }
            }
          }

          *v113 = v105;
          if (v125) {
            sub_100014004(v125, v125[9]);
          }
          return 0LL;
        }

        if (*((_BYTE *)v91 + 633)
          || *((_BYTE *)v91 + 632)
          && (sub_100013D04( "%s:%d: %s Enabling temporary checkpoints starting with xid %lld.\n",  "nx_mount",  1731,  (const char *)(v91[48] + 208),  v90),  v91 = v126,  *(void *)(v126[47] + 1408) = v90,  *((_BYTE *)v91 + 633)))
        {
          if (!*((_BYTE *)v91 + 632))
          {
            sub_100013D04( "%s:%d: %s Making temporary checkpoint %lld permanent (start %lld).\n",  "nx_mount",  1739,  (const char *)(v91[48] + 208),  *(void *)(v91[47] + 16),  *(void *)(v91[47] + 1408));
            v20[176] = 0LL;
            sub_10003E984((uint64_t)v126, (uint64_t)v20, v19, v93, v94);
            if (v120)
            {
              int v21 = sub_100051F74(v126[48], v120);
              if (!(_DWORD)v21)
              {
                int v21 = sub_10004EF7C((uint64_t)v126, 0x10u);
                if (!(_DWORD)v21)
                {
                  v91 = v126;
                  *(void *)(v126[47] + 1408) = 0LL;
                  v109 = 1;
                  goto LABEL_169;
                }
              }
            }

            else
            {
              int v21 = 22LL;
            }

            sub_100013D94("%s:%d: %s failed to write superblock to block %lld: %d\n");
            goto LABEL_146;
          }
        }

      v320 = v70;
      v73 = 0;
      v74 = v366;
      v75 = (LOBYTE(v366[13 * v62 + 138]) != 0) & (v72 >> 6);
      v306 = v75;
      if (v55 <= 4
        && (v75 & 1) == 0
        && ((v73 = v55 - 1,
             v76 = &v366[17 * v62 + 152],
             v77 = (v55 - 1),
             LOBYTE(v76[4 * v77 + 3]))
          ? (v78 = (v58 & 0x100) == 0)
          : (v78 = 0),
            v78))
      {
        v307 = v55 - 1;
        v81 = 0LL;
        v351 = v76[4 * v77];
        v82 = v55 <= (*(_DWORD *)(v366[v62 + 186] + 4 * (v351 / *(unsigned int *)(v37 + 36))) & 0xFFFFFFu);
      }

      else
      {
        if (v311 < 3) {
          v79 = (LOBYTE(v366[13 * v62 + 138]) != 0) & (v72 >> 6);
        }
        else {
          v79 = 0;
        }
        v307 = v73;
        if (v79 == 1)
        {
          v80 = sub_100030FD0(v366, v62, v311);
          uint64_t v72 = v340;
          v81 = 0LL;
          v82 = 0;
          v351 = v80;
          v74 = v366;
          goto LABEL_132;
        }

        if ((v58 & 2) != 0)
        {
          v83 = __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36LL)));
          if ((_DWORD)v62 == (((v303 << v83) & 0x4000000000000000LL) != 0))
          {
            v82 = 0;
            v81 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v83) & v303;
            v351 = v81;
            goto LABEL_131;
          }
        }

        v81 = 0LL;
        v82 = 0;
        if ((v58 & 0x800) != 0)
        {
          v351 = 0LL;
LABEL_131:
          v58 |= 0x4000u;
        }

        else
        {
          v351 = v366[v62 + 124];
        }
      }

LABEL_65:
      if (!*(_BYTE *)a5 || *a12)
      {
        uint64_t result = 0LL;
LABEL_136:
        *a12 = 0;
        return result;
      }

      int v46 = *a10;
      if (v45 + *a10 > 32) {
        return 92LL;
      }
      uint64_t v47 = 0LL;
      do
      {
        if (v46 >= 1
          && *(_BYTE *)(a5 + v47)
          && *(unsigned __int8 *)(a5 + v47) < *(unsigned __int8 *)(a9 + (v46 - 1)))
        {
          *a11 = 1;
        }

        *(_DWORD *)(a8 + 4LL * v46) = a4[v47];
        *(_BYTE *)(a9 + *a10) = *(_BYTE *)(a5 + v47++);
        int v46 = *a10 + 1;
        *a10 = v46;
      }

      while (v47 < *a6);
      *a6 = 0;
      unint64_t v25 = (unsigned __int8 *)*a1;
      if (*a1 >= a2) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1000048FC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if ((int)a3 >= 2)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = result + 4LL * a3 - 4;
    do
    {
      uint64_t v5 = *(unsigned __int8 *)(a2 + a3 - 1LL);
      uint64_t v6 = (int *)v4;
      uint64_t v7 = a3 - 2LL;
      do
      {
        uint64_t v8 = *(unsigned __int8 *)(a2 + v7);
        if (v5 < v8)
        {
          __int128 v9 = (_BYTE *)(a2 + v7);
          int v10 = *v6;
          *uint64_t v6 = *(v6 - 1);
          uint64_t result = *(unsigned __int8 *)(a2 + v7);
          v9[1] = result;
          *(v6 - 1) = v10;
          *__int128 v9 = v5;
          uint64_t v8 = v5;
        }

        --v6;
        uint64_t v5 = v8;
      }

      while (v7-- > v3);
      ++v3;
    }

    while (v3 != a3 - 1);
  }

  return result;
}

uint64_t sub_100004980(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, BOOL *a6)
{
  unint64_t v33 = a3;
  unint64_t v34 = a1;
  unint64_t v7 = a1 + a2;
  unint64_t v8 = a3 + a4;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __b[0] = v9;
  __b[1] = v9;
  __int128 v42 = v9;
  __int128 v43 = v9;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
  char v30 = 1;
  char v29 = 1;
  while (1)
  {
    *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __s1[6] = v10;
    __int128 v39 = v10;
    _OWORD __s1[4] = v10;
    __s1[5] = v10;
    __s1[2] = v10;
    __s1[3] = v10;
    __s1[0] = v10;
    __s1[1] = v10;
    __s2[6] = v10;
    __s2[7] = v10;
    _OWORD __s2[4] = v10;
    __s2[5] = v10;
    __s2[2] = v10;
    __s2[3] = v10;
    __s2[0] = v10;
    __s2[1] = v10;
    v36[0] = v10;
    v36[1] = v10;
    v35[0] = v10;
    v35[1] = v10;
    unsigned int v27 = 0;
    unsigned int v28 = 0;
    __int16 v26 = 0;
    uint64_t result = sub_100004144( &v34,  v7,  a5,  (unsigned int *)__b,  (uint64_t)&v41,  (int *)&v32 + 1,  (int *)&v31 + 1,  (uint64_t)__s1,  (uint64_t)v36,  (int *)&v28,  (_BYTE *)&v26 + 1,  &v30);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t result = sub_100004144( &v33,  v8,  a5,  (unsigned int *)&v42,  (uint64_t)&v40,  (int *)&v32,  (int *)&v31,  (uint64_t)__s2,  (uint64_t)v35,  (int *)&v27,  &v26,  &v29);
    if ((_DWORD)result) {
      return result;
    }
    unint64_t v12 = v27;
    unint64_t v13 = v28;
    if ((int)v28 > 0 || (int)v27 >= 1)
    {
      if (HIBYTE(v26)) {
        sub_1000048FC((uint64_t)__s1, (uint64_t)v36, v28);
      }
      if ((_BYTE)v26) {
        sub_1000048FC((uint64_t)__s2, (uint64_t)v35, v12);
      }
      if ((a5 & 1) != 0)
      {
        int v14 = v12;
        unsigned int v15 = v13;
        goto LABEL_50;
      }

      if ((int)v13 < 2 || *((_DWORD *)__s1 + (v13 - 1)) != 953 || HIDWORD(v31))
      {
        unsigned int v15 = v13;
      }

      else
      {
        int v16 = HIDWORD(v32);
        if (SHIDWORD(v32) >= 8)
        {
          int v17 = 0;
          unsigned int v28 = v13;
          goto LABEL_25;
        }

        int v17 = 0;
        while (*((_DWORD *)__s1 + (v13 - 1)) == 953)
        {
          ++v17;
          unsigned int v15 = v13 - 1;
          if (v17 < 8 - HIDWORD(v32))
          {
            BOOL v18 = v13-- > 2;
            if (v18) {
              continue;
            }
          }

          goto LABEL_24;
        }

        unsigned int v15 = v13;
LABEL_24:
        unsigned int v28 = v15;
        LODWORD(v13) = v15;
        if (SHIDWORD(v32) >= 1)
        {
LABEL_25:
          unint64_t v19 = HIDWORD(v32);
          do
          {
            *((_DWORD *)&v43 + v17 + v19 + 3) = *((_DWORD *)&v43 + v19 + 3);
            *((_BYTE *)&v40 + v17 + v19 + 7) = *((_BYTE *)&v40 + v19 + 7);
            BOOL v18 = v19-- > 1;
          }

          while (v18);
          unsigned int v15 = v13;
        }

        if (v17)
        {
          bzero(&v41, v17);
          memset_pattern16(__b, &unk_10005B6C0, 4LL * v17);
        }

        HIDWORD(v32) = v16 + v17;
      }

      if ((int)v12 >= 2
        && (*((_DWORD *)__s2 + (v12 - 1)) == 953 ? (BOOL v20 = (_DWORD)v31 == 0) : (BOOL v20 = 0), v20))
      {
        int v21 = v32;
        int v22 = 0;
        while (*((_DWORD *)__s2 + (v12 - 1)) == 953)
        {
          ++v22;
          int v14 = v12 - 1;
          if (v22 < 8 - (int)v32)
          {
            BOOL v18 = v12-- > 2;
            if (v18) {
              continue;
            }
          }

          goto LABEL_43;
        }

        int v14 = v12;
LABEL_43:
        unsigned int v27 = v14;
        LODWORD(v12) = v14;
        if ((int)v32 >= 1)
        {
LABEL_44:
          unint64_t v23 = v32;
          do
          {
            *((_DWORD *)&v41 + v22 + v23 + 1) = *((_DWORD *)&v41 + v23 + 1);
            *((_BYTE *)&v39 + v22 + v23 + 15) = *((_BYTE *)&v39 + v23 + 15);
            BOOL v18 = v23-- > 1;
          }

          while (v18);
          int v14 = v12;
        }

        if (v22)
        {
          bzero(&v40, v22);
          memset_pattern16(&v42, &unk_10005B6C0, 4LL * v22);
        }

        LODWORD(v32) = v21 + v22;
      }

      else
      {
        int v14 = v12;
      }

LABEL_50:
      if (v15 != v14 || memcmp(__s1, __s2, 4LL * v14))
      {
        uint64_t result = 0LL;
        *a6 = 0;
        return result;
      }
    }

    if (v34 >= v7 && SHIDWORD(v32) < 1 || v33 >= v8 && (int)v32 <= 0)
    {
      BOOL v24 = 0;
      if (v34 == v7 && !HIDWORD(v32) && v33 == v8) {
        BOOL v24 = (_DWORD)v32 == 0;
      }
      uint64_t result = 0LL;
      *a6 = v24;
      return result;
    }
  }

  sub_10003E644(a1, a3, 0LL);
}

uint64_t sub_100004DC0(int a1)
{
  if (a1 >= 983040) {
    return 0LL;
  }
  if (a1 == 953) {
    return 240LL;
  }
  int v2 = a1 - 711680;
  if (a1 <= 205823) {
    int v2 = a1;
  }
  LOWORD(v3) = word_1000539B8[v2 >> 8];
  if ((_WORD)v3) {
    BOOL v4 = (v3 & 0xFF00) == 44288;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return v3;
  }
  int v3 = word_1000563C0[16 * (v3 & 0xFFF) + (v2 >> 4)];
  if (!v3) {
    return v3;
  }
  if ((v3 & 0xFF00) == 0xAE00) {
    return 0LL;
  }
  if ((v3 & 0xFF00) == 0xAD00) {
    return v3;
  }
  __int16 v5 = word_100058020[16 * (v3 & 0xFFF) + (v2 & 0xF)];
  if ((v5 & 0xFF00) == 0xAD00) {
    return v5;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100004E88(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_100004EE4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(_BYTE *)(a4 + 48) & 0xFE;
  __int128 v8 = *(_OWORD *)(a4 + 8);
  uint64_t v5 = *(void *)(a4 + 24);
  v7[0] = *(void *)(a4 + 40) | (v4 << 56);
  v7[1] = v5;
  return sub_10001EADC(a1, a3, (unint64_t *)&v8, 16, v7, 0x10u, a2);
}

uint64_t sub_100004F3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v8 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = sub_100016560(a1, 5, a2, &v8);
  if (!(_DWORD)v6)
  {
    uint64_t v6 = sub_100004EE4(v8, a2, *(void *)(a1 + 432), a3);
    sub_100038824(v8);
  }

  return v6;
}

uint64_t sub_100004FB4(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  __int128 v8 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  v9[0] = a3;
  v9[1] = a4;
  uint64_t v6 = sub_100016560(a1, 5, a2, &v8);
  if (!(_DWORD)v6)
  {
    uint64_t v6 = sub_1000260EC((uint64_t)v8, *(void *)(a1 + 432), v9, 0x10u, a2);
    sub_100038824(v8);
  }

  return v6;
}

uint64_t sub_100005030( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, _OWORD *a6, int a7, uint64_t (*a8)(__int128 *, uint64_t), uint64_t a9)
{
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[2] = v14;
  v25[3] = v14;
  v25[0] = v14;
  v25[1] = v14;
  BOOL v24 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v29 = a4;
  uint64_t v30 = a5;
  uint64_t v15 = sub_10001656C(a1, 5, a2, a3, &v24);
  if (!(_DWORD)v15)
  {
    sub_100026D8C((uint64_t)v25, (uint64_t)v24, a3, (unsigned __int16)a7, &v29, 16, 0x10u, &v27, 0x10u, a6);
    if ((_DWORD)v16 != 2)
    {
      uint64_t v15 = v16;
      if ((_DWORD)v16)
      {
LABEL_13:
        sub_100038824(v24);
        return v15;
      }

      uint64_t v23 = 0LL;
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v20 = 0u;
      while (!sub_100026EFC((uint64_t)v25) && (!a4 || v29 == a4))
      {
        LODWORD(v20) = 3670280;
        *((void *)&v20 + 1) = v29;
        *(void *)&__int128 v21 = v30;
        *(void *)&__int128 v22 = 0LL;
        *((void *)&v22 + 1) = v27 & 0xFFFFFFFFFFFFFFLL;
        *((void *)&v21 + 1) = v28;
        LOBYTE(v23) = HIBYTE(v27);
        uint64_t v17 = a8(&v20, a9);
        if ((_DWORD)v17)
        {
          uint64_t v15 = v17;
          goto LABEL_13;
        }

        uint64_t v18 = sub_100026F18((uint64_t)v25);
        if ((a7 & 0x40000) == 0)
        {
          uint64_t v15 = v18;
          if ((_DWORD)v18) {
            goto LABEL_13;
          }
        }
      }
    }

    uint64_t v15 = 0LL;
    goto LABEL_13;
  }

  return v15;
}

uint64_t sub_100005194(uint64_t a1)
{
  if (a1)
  {
    BOOL v1 = sub_100010058(a1);
    sub_100013DDC( v1,  "%s:%d: %s Container corruption detected by %s:%u!\n",  v2,  v3,  v4,  v5,  v6,  v7,  (char)"nx_corruption_detected_int");
  }

  else
  {
    BOOL v8 = sub_100010058(0LL);
    sub_100013DDC( v8,  "%s:%d: Container corruption detected by %s:%u!\n",  v9,  v10,  v11,  v12,  v13,  v14,  (char)"nx_corruption_detected_int");
  }

  return 92LL;
}

unint64_t sub_100005224(void *a1, int a2, int8x16_t a3, int8x16_t a4)
{
  unint64_t result = sub_10001D980(a1, (uint32x4_t *)(a1 + 1), (a2 - 8), 0LL, a3, a4);
  if (result)
  {
    sub_100013D94( "%s:%d: failed: cksum 0x%016llx, oid 0x%llx, type 0x%x/0x%x, size %d\n",  "obj_checksum_verify_phys",  52,  *a1,  a1[1],  *((_DWORD *)a1 + 6),  *((_DWORD *)a1 + 7),  a2);
    BOOL v7 = sub_100010058(0LL);
    sub_100013DDC( v7,  "%s:%d: Container corruption detected by %s:%u!\n",  v8,  v9,  v10,  v11,  v12,  v13,  (char)"nx_corruption_detected_int");
    return 92LL;
  }

  return result;
}

uint64_t sub_1000052C0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  if ((*(_BYTE *)(a1 + 65) & 1) != 0)
  {
    if (a2)
    {
      unint64_t v7 = *(void *)(a2 + 48);
      unint64_t v5 = *(void *)(a2 + 96);
    }

    else
    {
      unint64_t v7 = *(void *)(a1 + 40);
      unint64_t v5 = v7;
    }

    int64_t v8 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(a1 + 36)));
    int64_t v9 = v8 | v5;
  }

  else
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = (unint64_t *)(a2 + 48);
    if (!a2) {
      uint64_t v6 = (unint64_t *)(a1 + 40);
    }
    unint64_t v7 = *v6;
    int64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v9 = v7;
  }

  uint64_t result = 22LL;
  if ((a5 ^ 1u) <= a3 && v9 - 1 >= a3)
  {
    if (v5 && v7 <= a3)
    {
      if (a5)
      {
        if (v8 > a3) {
          return result;
        }
      }

      else if (v8 >= a3)
      {
        return result;
      }
    }

    if (a4 >= 2)
    {
      if (v9 - a3 >= a4)
      {
        if (v7 - a3 >= a4 || v7 <= a3 || v5 == 0) {
          return 0LL;
        }
        else {
          return 22LL;
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

unint64_t sub_10000538C(uint64_t a1, unsigned int a2, int a3, int8x16_t a4, int8x16_t a5)
{
  if (a2 < 0x1000) {
    return 22LL;
  }
  if (*(_DWORD *)(a1 + 32) != 1112758350) {
    return 79LL;
  }
  if (a3 || (unsigned int v8 = *(_DWORD *)(a1 + 36), v8 == a2))
  {
    unint64_t result = sub_100005224((void *)a1, a2, a4, a5);
    if ((_DWORD)result) {
      return result;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 36);
  }

  int v9 = *(_DWORD *)(a1 + 24);
  int v10 = v9 != -2147483647;
  if (v9 == -2147483647) {
    int v11 = 1;
  }
  else {
    int v11 = 2;
  }
  if (*(_DWORD *)(a1 + 28)) {
    int v10 = v11;
  }
  if (*(void *)(a1 + 8) != 1LL) {
    ++v10;
  }
  if (v8 < 0x1000) {
    ++v10;
  }
  if (v8 <= 0x10000) {
    int v12 = v10;
  }
  else {
    int v12 = v10 + 1;
  }
  if (*(void *)(a1 + 88) < 0x400uLL) {
    ++v12;
  }
  int v13 = *(_DWORD *)(a1 + 104);
  if ((v13 & 0x7FFFFFF8) != 0) {
    int v14 = v12;
  }
  else {
    int v14 = v12 + 1;
  }
  unint64_t v15 = v13 & 0x7FFFFFFF;
  unint64_t v16 = *(void *)(a1 + 40);
  uint64_t v17 = *(void *)(a1 + 112);
  if (v13 < 0) {
    unint64_t v18 = 1LL;
  }
  else {
    unint64_t v18 = v13 & 0x7FFFFFFF;
  }
  if (v13 < 0) {
    int v19 = 1;
  }
  else {
    int v19 = v13 & 0x7FFFFFFF;
  }
  unsigned int v45 = v19;
  int v46 = v14;
  int v20 = sub_1000052C0(a1, 0LL, v17, v18, 0);
  unsigned int v44 = *(_DWORD *)(a1 + 128);
  int v21 = *(_DWORD *)(a1 + 108);
  unint64_t v22 = v21 & 0x7FFFFFFF;
  uint64_t v23 = *(void *)(a1 + 120);
  if (v21 < 0) {
    unint64_t v24 = 1LL;
  }
  else {
    unint64_t v24 = v21 & 0x7FFFFFFF;
  }
  if (v21 < 0) {
    unsigned int v25 = 1;
  }
  else {
    unsigned int v25 = v21 & 0x7FFFFFFF;
  }
  int v26 = sub_1000052C0(a1, 0LL, *(void *)(a1 + 120), v24, 0);
  int v27 = v46;
  if (v17 >= v23) {
    uint64_t v28 = v25;
  }
  else {
    uint64_t v28 = v45;
  }
  if (v17 >= v23) {
    uint64_t v29 = v23;
  }
  else {
    uint64_t v29 = v17;
  }
  if (v17 <= v23) {
    uint64_t v30 = v23;
  }
  else {
    uint64_t v30 = v17;
  }
  if (v16 <= v15) {
    ++v27;
  }
  if (v20) {
    ++v27;
  }
  if ((v21 & 0x7FFFFFF8) == 0) {
    ++v27;
  }
  if (v16 <= v22) {
    ++v27;
  }
  if (v26) {
    ++v27;
  }
  uint64_t v31 = v29 + v28;
  else {
    int v32 = v27 + 1;
  }
  if (v31 <= v30) {
    int v33 = v32;
  }
  else {
    int v33 = v32 + 1;
  }
  if ((*(void *)(a1 + 64) & 0xFFFFFFFFFFFFFEFDLL) == 0)
  {
    unsigned int v34 = *(_DWORD *)(a1 + 140);
    if (!*(void *)(a1 + 152)) {
      ++v33;
    }
    if (!*(void *)(a1 + 160)) {
      ++v33;
    }
    if (!(a3 | v34))
    {
      if (!*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 136) && !*(_DWORD *)(a1 + 144)) {
        goto LABEL_91;
      }
      unsigned int v34 = 0;
    }

    unsigned int v35 = *(_DWORD *)(a1 + 148);
    if (v34 < 2) {
      ++v33;
    }
    if (v35 < 2) {
      ++v33;
    }
LABEL_91:
    if (*(_DWORD *)(a1 + 180) <= 0x64u) {
      int v36 = 0;
    }
    else {
      int v36 = -1;
    }
    if (v33 != v36) {
      goto LABEL_96;
    }
    return 0LL;
  }

  if (!v33) {
    return 0LL;
  }
LABEL_96:
  BOOL v37 = sub_100010058(0LL);
  sub_100013DDC( v37,  "%s:%d: Container corruption detected by %s:%u!\n",  v38,  v39,  v40,  v41,  v42,  v43,  (char)"nx_corruption_detected_int");
  return 92LL;
}

uint64_t start(int a1, char *const *a2)
{
  uint64_t v56 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v67 = v4;
  __int128 v68 = v4;
  v65[30] = v4;
  *(_OWORD *)uuid_t out = v4;
  v65[28] = v4;
  v65[29] = v4;
  v65[26] = v4;
  v65[27] = v4;
  v65[24] = v4;
  v65[25] = v4;
  v65[22] = v4;
  v65[23] = v4;
  v65[20] = v4;
  v65[21] = v4;
  v65[18] = v4;
  v65[19] = v4;
  v65[16] = v4;
  v65[17] = v4;
  v65[14] = v4;
  v65[15] = v4;
  v65[12] = v4;
  v65[13] = v4;
  v65[10] = v4;
  v65[11] = v4;
  v65[8] = v4;
  v65[9] = v4;
  v65[6] = v4;
  v65[7] = v4;
  v65[4] = v4;
  v65[5] = v4;
  v65[2] = v4;
  v65[3] = v4;
  v65[0] = v4;
  v65[1] = v4;
  int outputStruct = -1431655766;
  v64[15] = v4;
  v64[16] = v4;
  v64[13] = v4;
  v64[14] = v4;
  v64[11] = v4;
  v64[12] = v4;
  v64[9] = v4;
  v64[10] = v4;
  v64[7] = v4;
  v64[8] = v4;
  v64[5] = v4;
  v64[6] = v4;
  v64[3] = v4;
  v64[4] = v4;
  v64[1] = v4;
  v64[2] = v4;
  v64[0] = v4;
  memset(v63, 170, sizeof(v63));
  memset(v62, 170, sizeof(v62));
  memset(__b, 170, sizeof(__b));
  memset(v60, 170, sizeof(v60));
  char v5 = 1;
  __strlcpy_chk(v63, "", 1LL, 1024LL);
  sub_100006AD0(0LL, out);
  sub_100006D6C(0LL, (unsigned __int8 *)v65);
  __strlcpy_chk((char *)&v65[28] + 8, "newfs_apfs", 32LL, 32LL);
  err_set_exit((void (__cdecl *)(int))sub_100006388);
  uint64_t v6 = 0LL;
  int v54 = 0;
  int v7 = 0;
  char v8 = 0;
  char v9 = 0;
  io_registry_entry_t v10 = 0;
  while (2)
  {
    int v11 = (char *)getopt(a1, a2, ":b:ieo:q:r:s:v:wACDWEF:G:PR:S:U:Txca");
    switch((int)v11)
    {
      case ':':
        sub_1000531C0((uint64_t)v11);
      case ';':
      case '<':
      case '=':
      case '>':
      case '@':
      case 'B':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'Q':
      case 'V':
      case 'X':
      case 'Y':
      case 'Z':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case 'd':
      case 'f':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'p':
      case 't':
      case 'u':
        continue;
      case '?':
        sub_100053198((uint64_t)v11);
      case 'A':
        int v54 = 1;
        char v9 = 1;
        continue;
      case 'C':
        int v7 = 1;
        char v8 = 1;
        continue;
      case 'D':
        char v9 = 1;
        char v5 = 1;
        continue;
      case 'E':
      case 'P':
        int v12 = "encrypted";
        goto LABEL_32;
      case 'F':
        if (v6) {
          sub_100053184((uint64_t)v11);
        }
        uint64_t v6 = optarg;
        char v8 = 1;
        continue;
      case 'G':
        snprintf((char *)v64, 0x110uLL, "gid=%s", optarg);
        unint64_t v16 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v16) {
          sub_10005315C((uint64_t)v16);
        }
        continue;
      case 'R':
        snprintf((char *)v64, 0x110uLL, "role=%s", optarg);
        int v21 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v21) {
          sub_10005315C((uint64_t)v21);
        }
        continue;
      case 'S':
        unint64_t v18 = (char *)snprintf((char *)v64, 0x110uLL, "password=%s", optarg);
        continue;
      case 'T':
        char v5 = 0;
        continue;
      case 'U':
        snprintf((char *)v64, 0x110uLL, "uid=%s", optarg);
        uint64_t v17 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v17) {
          sub_10005315C((uint64_t)v17);
        }
        continue;
      case 'W':
        int v12 = "empty_password";
        goto LABEL_32;
      case 'a':
        v10 |= 0x100u;
        continue;
      case 'b':
        snprintf((char *)v64, 0x110uLL, "blocksize=%s", optarg);
        int v19 = sub_100006AD0((char *)v64, out);
        char v8 = 1;
        if (v19) {
          sub_10005315C((uint64_t)v19);
        }
        continue;
      case 'c':
        v10 |= 0x80u;
        continue;
      case 'e':
        int v12 = "case=sensitive";
        goto LABEL_32;
      case 'i':
        int v12 = "case=insensitive";
LABEL_32:
        sub_100006D6C(v12, (unsigned __int8 *)v65);
        char v9 = 1;
        continue;
      case 'o':
        if (sub_100007628( optarg,  (uint64_t (*)(const char *, uint64_t))sub_100006AD0,  (uint64_t)out,  (uint64_t (*)(const char *, uint64_t))sub_100006D6C,  (uint64_t)v65))
        {
          errx(64, "unrecognized option '%s'");
        }

        continue;
      case 'q':
        snprintf((char *)v64, 0x110uLL, "fsquota=%s", optarg);
        unint64_t v15 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v15) {
          sub_10005315C((uint64_t)v15);
        }
        continue;
      case 'r':
        snprintf((char *)v64, 0x110uLL, "fsreserve=%s", optarg);
        int v20 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v20) {
          sub_10005315C((uint64_t)v20);
        }
        continue;
      case 's':
        snprintf((char *)v64, 0x110uLL, "fssize=%s", optarg);
        int v14 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v14) {
          sub_10005315C((uint64_t)v14);
        }
        continue;
      case 'v':
        snprintf((char *)v64, 0x110uLL, "volname=%s", optarg);
        int v13 = sub_100006D6C((char *)v64, (unsigned __int8 *)v65);
        char v9 = 1;
        if (v13) {
          sub_10005315C((uint64_t)v13);
        }
        continue;
      case 'w':
        v10 |= 0x10u;
        continue;
      case 'x':
        v10 |= 0x20u;
        continue;
      default:
        if ((_DWORD)v11 != -1) {
          continue;
        }
        if ((BYTE4(v65[3]) & 1) == 0) {
          goto LABEL_48;
        }
        if (WORD3(v65[3]) > 0xFFu)
        {
          if (WORD3(v65[3]) == 256 || WORD3(v65[3]) == 704 || WORD3(v65[3]) == 640) {
LABEL_122:
          }
            errx(73, "Can't create an encrypted volume with special role 0x%x", WORD3(v65[3]));
        }

        else if (WORD3(v65[3]) <= 0x20u && ((1LL << SBYTE6(v65[3])) & 0x100010110LL) != 0)
        {
          goto LABEL_122;
        }

LABEL_48:
        if ((v5 & 1) != 0)
        {
          int v11 = sub_100006D6C("uuid_from_role", (unsigned __int8 *)v65);
          if (v11) {
            errx(64, "Could not set uuid from role 0x%x, error %s");
          }
        }

        if ((v10 & 0xA0) == 0x80) {
          sub_100053010((uint64_t)v11);
        }
        uint64_t v22 = optind;
        if (a1 - optind != 1)
        {
          if (a1 == optind) {
            errx(64, "missing argument", v53);
          }
          errx(64, "unexpected argument");
        }

        if ((v54 & v7 & 1) != 0) {
          sub_100053024((uint64_t)v11);
        }
        if (*(void *)&v65[1] && *((void *)&v65[1] + 1) && *(void *)&v65[1] > *((void *)&v65[1] + 1)) {
          sub_10005304C((uint64_t)v11);
        }
        if (v6)
        {
          sub_1000307C0(v6, __b, v60, 0x400uLL, 0LL);
          sub_1000307C0(a2[v22], (char *)v63, v62, 0x400uLL, 0LL);
          uint64_t v23 = strcmp((const char *)v63, __b);
          if (!(_DWORD)v23) {
            sub_100053060(v23);
          }
          *((void *)&v67 + 1) = v60;
        }

        else
        {
          sub_1000307C0(a2[optind], (char *)v63, v62, 0x400uLL, 0LL);
        }

        if ((v54 & 1) != 0)
        {
          io_service_t v24 = sub_1000063A0((const char *)v63, 0);
          if (!v24) {
            errx(66, "%s is not an APFS container", (const char *)v63);
          }
          io_service_t v25 = v24;
          if ((v8 & 1) != 0) {
            warnx("some non-applicable container options were ignored");
          }
          goto LABEL_76;
        }

        uint64_t v26 = 5LL;
        if (v63[0] ^ 0x7665642F | LOBYTE(v63[1]) ^ 0x2F) {
          uint64_t v26 = 0LL;
        }
        int v27 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)v63 + v26);
        io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v27);
        if (!MatchingService) {
          goto LABEL_71;
        }
        io_registry_entry_t v29 = MatchingService;
        parent[0] = -1431655766;
        if (!IOObjectConformsTo(MatchingService, "AppleAPFSVolume")
          || IORegistryEntryGetParentEntry(v29, "IOService", parent))
        {
          goto LABEL_70;
        }

        BOOLean_t v33 = IOObjectConformsTo(parent[0], "AppleAPFSContainer");
        io_service_t v25 = parent[0];
        if (v33)
        {
          int v34 = sub_100030AC4((const char *)v63, 0);
          int outputStruct = v34;
          IOObjectRelease(v29);
          if (v25)
          {
            if (v7 & 1 | (v6 != 0LL)) {
              sub_10005311C();
            }
            LODWORD(inputStruct) = v34;
            io_connect_t connect = -1431655766;
            uint64_t v35 = IOServiceOpen(v25, mach_task_self_, 0, &connect);
            if (!(_DWORD)v35)
            {
              *(void *)parent = 0LL;
              uint64_t v35 = IOConnectCallStructMethod(connect, 1u, &inputStruct, 4uLL, 0LL, (size_t *)parent);
              IOServiceClose(connect);
            }

            int v36 = sub_100006874(v35);
            if (v36)
            {
              if (v36 == 16) {
                sub_100053134((const char *)v63);
              }
              errc(66, v36, "unable to reformat %s", (const char *)v63);
            }

            if ((v8 & 1) != 0) {
              warnx("some non-applicable container options were ignored");
            }
            LODWORD(v65[3]) = v34;
            int v32 = 1;
            if ((v7 & 1) != 0) {
              goto LABEL_77;
            }
            goto LABEL_88;
          }
        }

        else
        {
          IOObjectRelease(parent[0]);
LABEL_70:
          IOObjectRelease(v29);
        }

LABEL_71:
        sub_1000065E8((const char *)v63);
        if (v6)
        {
          sub_1000065E8(__b);
          sub_1000066E4(v62);
          uint64_t v30 = v60;
        }

        else
        {
          uint64_t v30 = v62;
        }

        sub_1000066E4(v30);
        int v31 = sub_100035BE8(v62, (uint64_t)out, 0LL, &v56);
        if (v31) {
          errc(73, v31, "unable to format %s", (const char *)v63);
        }
        sub_100035914(v56);
        io_service_t v25 = 0;
LABEL_76:
        int v32 = 0;
        if ((v7 & 1) != 0)
        {
LABEL_77:
          if ((v9 & 1) != 0) {
            warnx("some non-applicable volume options were ignored");
          }
          return 0LL;
        }

LABEL_88:
        if (WORD3(v65[3]) != 256) {
          goto LABEL_101;
        }
        *(void *)parent = 0LL;
        uint64_t v37 = getppid();
        if (*__error() != 34) {
          sub_100053104();
        }
        uint64_t v38 = calloc(1uLL, bswap32(parent[1]));
        if (!v38) {
          sub_100053098();
        }
        uint64_t v39 = v38;
        if (*(_DWORD *)v39 != 1903288058) {
          goto LABEL_142;
        }
        unsigned int v40 = bswap32(*((_DWORD *)v39 + 1));
        if (v40 <= 8) {
          goto LABEL_142;
        }
        uint64_t v41 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, (const UInt8 *)v39 + 8, v40 - 8, kCFAllocatorDefault);
        if (!v41) {
          sub_1000530B0(0LL);
        }
        TypeID = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v41, 0LL, 0LL, 0LL);
        if (!TypeID
          || (uint64_t v43 = TypeID,
              CFTypeID v44 = CFGetTypeID(TypeID),
              TypeID = (const __CFDictionary *)CFDictionaryGetTypeID(),
              (const __CFDictionary *)v44 != TypeID))
        {
          sub_1000530C4((uint64_t)TypeID);
        }

        Value = (const __CFBoolean *)CFDictionaryGetValue(v43, @"com.apple.private.apfs.xart");
        if (!Value)
        {
          CFRelease(v43);
LABEL_142:
          free(v39);
LABEL_143:
          sub_100053074((unsigned __int16 *)&v65[3] + 3);
        }

        int v46 = Value;
        CFTypeID v47 = CFGetTypeID(Value);
        CFTypeID v48 = CFBooleanGetTypeID();
        if (v47 != v48) {
          sub_1000530D8(v48);
        }
        int v49 = CFBooleanGetValue(v46);
        CFRelease(v43);
        free(v39);
        if (!v49) {
          goto LABEL_143;
        }
LABEL_101:
        if (v25 || (io_service_t v25 = sub_1000063A0((const char *)v63, 1u)) != 0 || v6 && (io_service_t v25 = sub_1000063A0(__b, 1u)) != 0)
        {
          io_connect_t connect = -1431655766;
          memset(&parent[124], 170, 0x788uLL);
          uint64_t v50 = IOServiceOpen(v25, mach_task_self_, 0, &connect);
          if (!(_DWORD)v50)
          {
            unint64_t inputStruct = 4LL;
            memcpy(parent, v65, 0x1F0uLL);
            parent[124] = v10;
            uint64_t v50 = IOConnectCallStructMethod(connect, 0, parent, 0x1F8uLL, &outputStruct, &inputStruct);
            IOServiceClose(connect);
          }

          int v51 = sub_100006874(v50);
          IOObjectRelease(v25);
        }

        else
        {
          if (((v54 | v32) & 1) != 0 || (BYTE4(v65[3]) & 1) != 0 || v6) {
            errx(69, "container not published on %s", (const char *)v63);
          }
          *(void *)parent = 0xAAAAAAAAAAAAAAAALL;
          unint64_t inputStruct = 0xAAAAAAAAAAAAAAAALL;
          int v51 = sub_100034464(v63, 0LL, (uint64_t **)parent);
          if (!v51)
          {
            int v51 = sub_10001BC2C(*(uint64_t *)parent, (uint64_t)v65, 0, 0LL, &inputStruct);
            if (!v51)
            {
              int outputStruct = *(_DWORD *)(*(void *)(inputStruct + 376) + 36LL);
              sub_100038824((uint64_t *)inputStruct);
            }

            sub_100035914(*(uint64_t *)parent);
          }
        }

        if (v51)
        {
          if (v32) {
            errc(73, v51, "unable to reformat volume %s");
          }
          if ((v54 & 1) == 0)
          {
            sub_1000066E4(v62);
            if (v6) {
              sub_1000066E4(v60);
            }
          }

          errc(73, v51, "unable to format volume inside %s");
        }

        return 0LL;
    }
  }

              ++*(_DWORD *)(v9 + 32);
              pthread_mutex_unlock((pthread_mutex_t *)v7);
              if (v10) {
                sub_100045114((void *)a1, v9);
              }
              return 0LL;
            }

void sub_100006388(int a1)
{
  if (a1 == 64) {
    warnx( "[-o options] [-b block-size] [[-s volume-size] | [-r volume-reserve] [-q volume-quota]] [-v volume-name] [-i | -e] [-U uid] [-G gid] [-E [-S passphrase | -W (empty password) ]] [-A | -C] [-F fusion] [-R role] [-D] [-w] [-x] [-T] [-c] [-a] device");
  }
}

uint64_t sub_1000063A0(const char *a1, IOOptionBits a2)
{
  mach_timespec_t waitTime = (mach_timespec_t)5LL;
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v4 = 5LL;
  }
  else {
    uint64_t v4 = 0LL;
  }
  char v5 = IOBSDNameMatching(kIOMainPortDefault, 0, &a1[v4]);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v5);
  io_object_t v14 = MatchingService;
  if (!MatchingService) {
    return 0LL;
  }
  io_object_t v7 = MatchingService;
  io_object_t object = -1431655766;
  IOServiceWaitQuiet(MatchingService, &waitTime);
  if (!IOObjectConformsTo(v7, "AppleAPFSMedia"))
  {
    char v8 = IOServiceMatching("AppleAPFSMedia");
    if (!IOServiceGetMatchingServices(kIOMainPortDefault, v8, &object) && object != 0)
    {
      IOObjectRelease(object);
      io_object_t object = 0;
      if ((sub_100030A14(&v14, "AppleAPFSContainerScheme") & 1) == 0) {
        sub_100053210(&v14);
      }
      char v10 = sub_100030A14(&v14, "AppleAPFSMedia");
      io_object_t v7 = v14;
      if ((v10 & 1) == 0) {
        sub_1000531E8(v14);
      }
    }
  }

  if (IORegistryEntryCreateIterator(v7, "IOService", a2, &object))
  {
    uint64_t i = 0LL;
  }

  else
  {
    for (uint64_t i = IOIteratorNext(object); (_DWORD)i; uint64_t i = IOIteratorNext(object))
    {
      if (IOObjectConformsTo(i, "AppleAPFSContainer")) {
        break;
      }
      IOObjectRelease(i);
    }

    IOObjectRelease(object);
  }

  IOObjectRelease(v14);
  return i;
}

const char *sub_100006544(const char *a1)
{
  io_object_t v7 = (statfs *)0xAAAAAAAAAAAAAAAALL;
  int v2 = getmntinfo(&v7, 2);
  if (v2)
  {
    int v3 = v2;
    f_mntfromname = v7->f_mntfromname;
    while (strcmp(a1, f_mntfromname))
    {
      io_object_t v7 = (statfs *)(f_mntfromname + 1056);
      f_mntfromname += 2168;
      if (!--v3) {
        goto LABEL_5;
      }
    }

    return f_mntfromname - 1024;
  }

  else
  {
LABEL_5:
    io_object_t v5 = sub_1000063A0(a1, 1u);
    if (v5)
    {
      IOObjectRelease(v5);
      return "an APFS configuration";
    }

    else
    {
      return "another file system";
    }
  }

uint64_t sub_1000065E8(const char *a1)
{
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v2 = 5LL;
  }
  else {
    uint64_t v2 = 0LL;
  }
  int v3 = IOBSDNameMatching(kIOMainPortDefault, 0, &a1[v2]);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  if (MatchingService)
  {
    io_object_t v5 = MatchingService;
    if (IOObjectConformsTo(MatchingService, "AppleAPFSMedia")) {
      sub_100053258(v5);
    }
    BOOLean_t v6 = IOObjectConformsTo(v5, "AppleAPFSVolume");
    IOObjectRelease(v5);
    if (v6) {
      sub_10005323C((uint64_t)a1, v7);
    }
  }

  int v8 = open(a1, 0);
  if (v8 == -1)
  {
    if (*__error() == 16) {
      sub_100053134(a1);
    }
    err(66, "unable to open %s", a1);
  }

  return close(v8);
}

uint64_t sub_1000066E4(const char *a1)
{
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = open(a1, 2);
  if ((_DWORD)v2 == -1)
  {
    int v3 = 1;
    do
    {
      uint64_t v4 = __error();
      if (v3 == 31 || *v4 != 16) {
        err(66, "%s", a1);
      }
      warnx("%s retry %d/30", a1, v3);
      sleep(1u);
      uint64_t v5 = open(a1, 2);
      ++v3;
    }

    while ((_DWORD)v5 == -1);
    uint64_t v2 = v5;
  }

  int v6 = wipefs_alloc(v2, 0LL, &v9);
  if (v6)
  {
    int v7 = v6;
    goto LABEL_11;
  }

  int v7 = wipefs_wipe(v9);
  wipefs_free(&v9);
  if (v7) {
LABEL_11:
  }
    warnc(v7, "wipefs");
  return close(v2);
}

uint64_t sub_1000067E0(io_registry_entry_t a1)
{
  io_iterator_t iterator = -1431655766;
  sub_100052F58(a1, "");
  uint64_t result = IORegistryEntryGetChildIterator(a1, "IOService", &iterator);
  if (!(_DWORD)result)
  {
    io_object_t v3 = IOIteratorNext(iterator);
    if (v3)
    {
      io_object_t v4 = v3;
      do
      {
        sub_100052F58(v4, "... ");
        IOObjectRelease(v4);
        io_object_t v4 = IOIteratorNext(iterator);
      }

      while (v4);
    }

    return IOObjectRelease(iterator);
  }

  return result;
}

uint64_t sub_100006874(uint64_t result)
{
  if ((_DWORD)result)
  {
    if ((result & 0x3FFF | 0xC000) == (_DWORD)result) {
      return result & 0x3FFF;
    }
    if ((int)result > -536870186)
    {
      switch((_DWORD)result)
      {
        case 0xE00002D7:
          return 75LL;
        case 0xE00002D9:
          return 6LL;
        case 0xE00002E2:
          return 1LL;
      }
    }

    else
    {
      switch((_DWORD)result)
      {
        case 0xE00002C0:
          return 2LL;
        case 0xE00002C1:
          return 13LL;
        case 0xE00002D2:
          return 16LL;
      }
    }

    return 22LL;
  }

  return result;
}

void sub_100006938(uint64_t a1, const char *a2)
{
}

void sub_100006940(uint64_t a1, uint64_t a2, const char *a3)
{
}

void sub_10000694C(uint64_t a1, uint64_t a2, const char *a3)
{
}

void sub_100006958(uint64_t a1, const char *a2)
{
}

uint64_t sub_100006960(uint64_t a1, const char *a2, uint64_t a3)
{
  int v6 = (char *)(a1 + 272);
  int v7 = sub_100003A48();
  if (snprintf(v6, 0x20uLL, "%s (%s)", a2, v7) >= 0x20)
  {
    size_t v8 = strlen(v7);
    snprintf((char *)(a1 - v8 + 300), v8 + 4, " (%s)", v7);
  }

  uint64_t result = sub_100032B28();
  *(void *)(a1 + 304) = result;
  *(void *)(a1 + 312) = a3;
  return result;
}

unint64_t sub_1000069F4(const char *a1)
{
  __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
  unint64_t result = strtoull(a1, &__endptr, 10);
  io_object_t v3 = __endptr;
  unsigned int v4 = *__endptr;
  if (v4 > 0x66)
  {
    if (*__endptr <= 0x6Cu)
    {
      if (v4 != 103)
      {
        if (v4 != 107) {
          goto LABEL_19;
        }
LABEL_9:
        result <<= 10;
LABEL_18:
        io_object_t v3 = __endptr + 1;
        goto LABEL_19;
      }

LABEL_16:
      result <<= 30;
      goto LABEL_18;
    }

    if (v4 != 109)
    {
      if (v4 != 116) {
        goto LABEL_19;
      }
      goto LABEL_15;
    }

  int v7 = 2LL;
LABEL_20:
  if (v16) {
    sub_100038824(v16);
  }
  sub_10003D514((uint64_t)v17, 1);
  sub_100038824((uint64_t *)v17);
  return v7;
}

LABEL_17:
    result <<= 20;
    goto LABEL_18;
  }

  if (*__endptr <= 0x4Cu)
  {
    if (v4 != 71)
    {
      if (v4 != 75) {
        goto LABEL_19;
      }
      goto LABEL_9;
    }

    goto LABEL_16;
  }

  if (v4 == 77) {
    goto LABEL_17;
  }
  if (v4 == 84)
  {
LABEL_15:
    result <<= 40;
    goto LABEL_18;
  }

            io_service_t v24 = -1;
            uint64_t v22 = sub_100003FEC( *((void *)v17 + 8),  (unsigned __int16)v18 - 1LL,  v21 != 0,  (void (*)(_OWORD *, uint64_t, uint64_t))sub_10001A204,  (uint64_t)&v24);
            if ((_DWORD)v22)
            {
              unint64_t v15 = v22;
              sub_100014004(*((void **)v17 + 8), *((unsigned __int16 *)v17 + 31));
              sub_100014004(v17, 72LL);
              return v15;
            }

            v17[14] = v24 & 0x3FFFFF;
            goto LABEL_15;
          }
        }

        v17[14] = a5;
        goto LABEL_15;
      }

      sub_100014004(v17, 72LL);
    }

    return 12LL;
  }

  return v15;
}

LABEL_19:
  if (v3 == a1) {
    return -1LL;
  }
  if (*v3) {
    return -1LL;
  }
  return result;
}

      if (!v9) {
        goto LABEL_28;
      }
    }

    unint64_t v16 = (unint64_t *)(v13 + 24);
    do
      uint64_t v17 = __ldxr(v16);
    while (__stxr(v17, v16));
    if ((v17 & 0xFFFFFF) == ((v17 >> 24) & 0xFFFFF))
    {
      if ((v15 & 0xC00000000LL) != 0)
      {
        unint64_t v18 = *(_DWORD *)(*(void *)(*(void *)a1[6].__opaque + 376LL) + 36LL);
        int v19 = (v18 + *(_DWORD *)(v13 + 48) - 1) / v18;
        if ((v15 & 0x800000000LL) != 0) {
          int v20 = 0LL;
        }
        else {
          int v20 = v19;
        }
        v11 += v20;
        v10 += v19 & (v15 << 28 >> 63);
        *(void *)(v13 + 16) = v15 & 0xFFFFFFF3FFFFFFFFLL;
      }

      --*(_DWORD *)&a1[10].__opaque[36];
      sub_10003CCD4(v13, 0);
      goto LABEL_19;
    }

    if ((v15 & 1) != 0)
    {
      if (v9) {
        *(void *)(v9 + 80) = *(void *)(v13 + 80);
      }
      **(void **)(v13 + 80) = v9;
    }

    int v21 = *opaque;
    *io_object_t v14 = *opaque;
    if (v21) {
      *(void *)(v21 + 80) = v14;
    }
    *opaque = v13;
    *(void *)(v13 + 80) = opaque;
    *(void *)(v13 + 16) = v15 | 9;
  }

  while (v9);
LABEL_28:
  sub_100036F84((uint64_t)a1);
  if (v11)
  {
    uint64_t v22 = sub_10004CFD4(v8, 0x48u, v11);
    if (v22)
    {
      if (*(_WORD *)(v8 + 36) == 13) {
        uint64_t v23 = (const char *)(v8 + 3992);
      }
      else {
        uint64_t v23 = (const char *)(*(void *)(v8 + 384) + 208LL);
      }
      sub_100013D94("%s:%d: %s error unreserving space, %lld blocks: %d\n", "obj_cache_remove", 1761, v23, v11, v22);
    }
  }

  if (v10)
  {
    io_service_t v24 = sub_10004CFD4(v8, 0x50u, v10);
    if (v24)
    {
      if (*(_WORD *)(v8 + 36) == 13) {
        io_service_t v25 = (const char *)(v8 + 3992);
      }
      else {
        io_service_t v25 = (const char *)(*(void *)(v8 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n",  "obj_cache_remove",  1767,  v25,  v10,  v24);
    }
  }

    if (sub_10003965C(*a5) != *(void *)(*(void *)(a2 + 376) + 48LL))
    {
      *(void *)(*(void *)(a2 + 376) + 48LL) = sub_10003965C(*a5);
      sub_10003E644(a2, a4, 0LL);
    }

    return 0LL;
  }

  int v12 = *(void *)(a2 + 376);
  int v13 = *(_DWORD *)(v12 + 40);
  io_object_t v14 = *(void *)(v12 + 48);
  v19[1] = 0LL;
  int v20 = 0u;
  io_service_t v24 = 0LL;
  uint64_t v22 = 0u;
  uint64_t v23 = 0u;
  int v21 = 0u;
  v19[0] = sub_10003F28C;
  v19[2] = 0x20000000BLL;
  char v10 = sub_100027CC4(a1, v13 & 0xFFFF0000, v14, 0LL, a3, v19, a4, a5);
  if (!(_DWORD)v10)
  {
    unint64_t v15 = (unint64_t *)(a2 + 472);
    unint64_t v16 = *a5;
    while (!__ldaxr(v15))
    {
      if (!__stlxr(v16, v15))
      {
        sub_10003DC28((char *)*a5);
        goto LABEL_18;
      }
    }

    __clrex();
LABEL_18:
    if ((a3 & 1) == 0) {
      return 0LL;
    }
    goto LABEL_19;
  }

  return v10;
}

  pthread_mutex_unlock((pthread_mutex_t *)v5);
  return v2;
}

char *sub_100006AD0(char *__s1, uuid_t out)
{
  io_object_t v3 = __s1;
  if (!__s1)
  {
    *((_OWORD *)out + 1) = 0u;
    *((_OWORD *)out + 2) = 0u;
    *(_OWORD *)uuid_t out = 0u;
    uuid_generate(out);
    *((_DWORD *)out + 5) = 1073741826;
    return v3;
  }

  unsigned int v4 = strdup(__s1);
  if (v4)
  {
    uint64_t v5 = v4;
    __lasts = (char *)0xAAAAAAAAAAAAAAAALL;
    int v6 = strtok_r(v4, ",", &__lasts);
    if (!v6)
    {
LABEL_33:
      io_object_t v3 = 0LL;
      goto LABEL_34;
    }

    int v7 = v6;
    while (1)
    {
      if (!strncasecmp(v7, "blocksize=", 0xAuLL))
      {
        unint64_t v9 = sub_1000069F4(v7 + 10);
        if (v9 - 4096 > 0xF000
          || (uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v10.i16[0] = vaddlv_u8(v10), v10.u32[0] >= 2uLL))
        {
LABEL_36:
          v3 += v7 - v5;
LABEL_34:
          free(v5);
          return v3;
        }

        *((_DWORD *)out + 4) = v9;
      }

      else if (!strcasecmp(v7, "omap=btree") || !strcasecmp(v7, "omap=physical"))
      {
        *((_DWORD *)out + 5) = 1073741826;
      }

      else if (!strcasecmp(v7, "omap=ephemeral"))
      {
        *((_DWORD *)out + 5) = -2147483646;
      }

      else
      {
        if (!strcasecmp(v7, "defragment=yes"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFFC | 2;
LABEL_26:
          *((_WORD *)out + 16) = v11;
          goto LABEL_27;
        }

        if (!strcasecmp(v7, "defragment=no"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFFC | 1;
          goto LABEL_26;
        }

        if (!strcasecmp(v7, "fusionlc=yes"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFF3 | 8;
          goto LABEL_26;
        }

        if (!strcasecmp(v7, "fusionlc=no"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFF3 | 4;
          goto LABEL_26;
        }

        if (!strncasecmp(v7, "wbcsize=", 8uLL))
        {
          unint64_t v12 = sub_1000069F4(v7 + 8);
          if (v12 - 102400 > 0x1FFFE7000LL || (v12 & 0xFFF) != 0) {
            goto LABEL_36;
          }
          *((void *)out + 5) = v12;
        }

        else
        {
          if (strncasecmp(v7, "maxfs=", 6uLL)) {
            goto LABEL_36;
          }
          unint64_t v8 = sub_1000069F4(v7 + 6);
          if (v8 >= 0x65) {
            goto LABEL_36;
          }
          out[34] = v8;
        }
      }

LABEL_27:
      int v7 = strtok_r(0LL, ",", &__lasts);
      if (!v7) {
        goto LABEL_33;
      }
    }
  }

  return v3;
}

        sub_100013D94( "%s:%d: %s dev %d Error %d, reinitializing\n",  "spaceman_free_extent_cache_insert",  1881,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v16);
        sub_10002B1A8(a1);
        goto LABEL_28;
      }

      v55 = sub_10002E75C(a1, a1 + 1068, 1);
      if ((_DWORD)v55)
      {
        unint64_t v16 = v55;
        uint64_t v56 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_77;
      }

      int v62 = *((unsigned __int16 *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165));
      uint64_t v64 = *v63;
      uint64_t v56 = *v63 & 0xFFFFFFFFFFFFFLL;
      if (v4 + v30 < v56)
      {
        unint64_t v16 = 2LL;
LABEL_77:
        sub_10002C1F4(a1, v30, v4);
        uint64_t v65 = a1 + 16LL * (a2 ^ 1u);
        *(void *)(v65 + 296) = v30;
        *(void *)(v65 + 304) = v56;
        if ((_DWORD)v16 != 2) {
          goto LABEL_27;
        }
LABEL_25:
        unint64_t v16 = 0LL;
        goto LABEL_28;
      }

      int v66 = v63[1] & 0xFFFFFFFFFFFFFLL;
      __int128 v67 = v56 - v30 + v66;
      if (v56 == *(void *)(a1 + 112)) {
        *(void *)(a1 + 112) = v30;
      }
      *char v63 = v64 & 0xFFF0000000000000LL | v30;
      unint64_t v16 = sub_10002C368(a1, v30, v66, v56 - v30 + v66, v62);
      if ((_DWORD)v16) {
        goto LABEL_27;
      }
      __int128 v68 = a1 + 48LL * ((*(_DWORD *)(a1 + 280) & 4) == 0);
      v70 = *(void *)(v68 + 176);
      v69 = (unint64_t *)(v68 + 176);
      if (v70 >= v67) {
        goto LABEL_25;
      }
      unint64_t v16 = 0LL;
      int *v69 = v67;
LABEL_28:
      if (*(void *)a1) {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      }
      return v16;
    }

    *(void *)(a1 + 120) = a2;
    goto LABEL_28;
  }

  if (v8) {
    unint64_t v12 = (const char *)(v8 + 3992);
  }
  else {
    unint64_t v12 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
  }
  sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object missing paddr!\n",  "obj_read",  6329,  v12,  *(void *)(a1 + 112),  *(void *)(a1 + 16),  *(_DWORD *)(a1 + 32),  *(_DWORD *)(a1 + 36),  *(_DWORD *)(a1 + 40));
  unint64_t v16 = 22LL;
  if (a4)
  {
    *(_DWORD *)(a4 + 96) = 22;
    (*(void (**)(uint64_t))a4)(a4);
  }

  return v16;
}

  int v21 = a1[7];
  int v20 = *(unsigned __int16 *)&v21->__opaque[16] | (*((unsigned __int16 *)a1 + 19) << 16);
  LODWORD(v21) = *(_DWORD *)&v21->__opaque[20];
  *((_DWORD *)a1 + 9) = v20;
  *((_DWORD *)a1 + 10) = (_DWORD)v21;
LABEL_28:
  unint64_t v12 = (unint64_t)a1[2];
  uint64_t v22 = v20 & 0x10000000;
  if ((v12 & 0x10000000) != v22)
  {
    unint64_t v12 = v12 & 0xFFFFFFFFEFFFFFFFLL | v22;
    a1[2] = (pthread_cond_t *)v12;
  }

  if (!(_DWORD)v13) {
    goto LABEL_2;
  }
LABEL_33:
  *((_DWORD *)a1 + 13) = v13;
  else {
    uint64_t v23 = 0xFFFFFE7FFFFFFFF9LL;
  }
  a1[2] = (pthread_cond_t *)(v12 & v23);
  if ((v12 & 4) != 0) {
    j__pthread_cond_broadcast(*a1 + 27);
  }
  return v13;
}

  if ((*(void *)(v23 + 16) & 0x80020000000LL) != 0)
  {
    pthread_mutex_lock(a1);
    goto LABEL_31;
  }

  int v36 = sub_10003D9B0(v23, v30, v31);
LABEL_30:
  int v13 = v36;
  pthread_mutex_lock(a1);
  if ((_DWORD)v13)
  {
LABEL_53:
    sub_100036F1C((uint64_t)a1, *(void *)(v23 + 16), *(_DWORD *)(v23 + 48), -1);
    do
      int v46 = __ldxr(v24);
    while (__stxr(v46 - 1, v24));
    goto LABEL_55;
  }

char *sub_100006D6C(char *a1, uuid_t out)
{
  io_object_t v3 = a1;
  if (!a1)
  {
    *((_OWORD *)out + 29) = 0u;
    *((_OWORD *)out + 30) = 0u;
    *((_OWORD *)out + 27) = 0u;
    *((_OWORD *)out + 28) = 0u;
    *((_OWORD *)out + 25) = 0u;
    *((_OWORD *)out + 26) = 0u;
    *((_OWORD *)out + 23) = 0u;
    *((_OWORD *)out + 24) = 0u;
    *((_OWORD *)out + 21) = 0u;
    *((_OWORD *)out + 22) = 0u;
    *((_OWORD *)out + 19) = 0u;
    *((_OWORD *)out + 20) = 0u;
    *((_OWORD *)out + 17) = 0u;
    *((_OWORD *)out + 18) = 0u;
    *((_OWORD *)out + 15) = 0u;
    *((_OWORD *)out + 16) = 0u;
    *((_OWORD *)out + 13) = 0u;
    *((_OWORD *)out + 14) = 0u;
    *((_OWORD *)out + 11) = 0u;
    *((_OWORD *)out + 12) = 0u;
    *((_OWORD *)out + 9) = 0u;
    *((_OWORD *)out + 10) = 0u;
    *((_OWORD *)out + 7) = 0u;
    *((_OWORD *)out + 8) = 0u;
    *((_OWORD *)out + 5) = 0u;
    *((_OWORD *)out + 6) = 0u;
    *((_OWORD *)out + 3) = 0u;
    *((_OWORD *)out + 4) = 0u;
    *((_OWORD *)out + 1) = 0u;
    *((_OWORD *)out + 2) = 0u;
    *(_OWORD *)uuid_t out = 0u;
    uuid_generate(out);
    *((_OWORD *)out + 2) = xmmword_10005B760;
    *((_DWORD *)out + 123) = 1073741826;
    *((_DWORD *)out + 12) = -1;
    *((_DWORD *)out + 111) = getuid();
    *((_DWORD *)out + 112) = getgid();
    *((_WORD *)out + 26) &= ~0x80u;
    __strlcpy_chk(out + 56, "untitled", 256LL, 256LL);
    *((_WORD *)out + 26) = *((_WORD *)out + 26) & 0xFBF3 | 8;
    return (char *)v3;
  }

  if (!strncasecmp(a1, "uuid_from_role", 0xEuLL))
  {
    unsigned int v21 = *((unsigned __int16 *)out + 27);
    if (v21 > 0xBF)
    {
      if (*((unsigned __int16 *)out + 27) <= 0x1BFu)
      {
        if (*((unsigned __int16 *)out + 27) > 0x13Fu)
        {
          if (v21 == 320)
          {
            uint64_t v22 = "61706673-7575-6964-0140-766f6c756d00";
            goto LABEL_114;
          }

          if (v21 == 384)
          {
            uint64_t v22 = "61706673-7575-6964-0180-766f6c756d00";
            goto LABEL_114;
          }
        }

        else
        {
          if (v21 == 192)
          {
            uint64_t v22 = "61706673-7575-6964-00c0-766f6c756d00";
            goto LABEL_114;
          }

          if (v21 == 256)
          {
            uint64_t v22 = "61706673-7575-6964-0100-766f6c756d00";
            goto LABEL_114;
          }
        }
      }

      else if (*((unsigned __int16 *)out + 27) <= 0x23Fu)
      {
        if (v21 == 448)
        {
          uint64_t v22 = "61706673-7575-6964-01c0-766f6c756d00";
          goto LABEL_114;
        }

        if (v21 == 512)
        {
          uint64_t v22 = "61706673-7575-6964-0200-766f6c756d00";
          goto LABEL_114;
        }
      }

      else
      {
        switch(v21)
        {
          case 0x240u:
            uint64_t v22 = "61706673-7575-6964-0240-766f6c756d00";
            goto LABEL_114;
          case 0x280u:
            uint64_t v22 = "61706673-7575-6964-0280-766f6c756d00";
            goto LABEL_114;
          case 0x2C0u:
            uint64_t v22 = "61706673-7575-6964-02c0-766f6c756d00";
LABEL_114:
            uuid_parse(v22, out);
            return 0LL;
        }
      }
    }

    else
    {
      if (*((unsigned __int16 *)out + 27) <= 0xFu)
      {
        uint64_t v22 = "61706673-7575-6964-0000-766f6c756d00";
        switch(*((_WORD *)out + 27))
        {
          case 0:
            goto LABEL_114;
          case 1:
            uint64_t v22 = "61706673-7575-6964-0001-766f6c756d00";
            goto LABEL_114;
          case 2:
            uint64_t v22 = "61706673-7575-6964-0002-766f6c756d00";
            goto LABEL_114;
          case 4:
            uint64_t v22 = "61706673-7575-6964-0004-766f6c756d00";
            goto LABEL_114;
          case 8:
            uint64_t v22 = "61706673-7575-6964-0008-766f6c756d00";
            goto LABEL_114;
          default:
            return strerror(22);
        }
      }

      if (*((unsigned __int16 *)out + 27) > 0x3Fu)
      {
        if (v21 == 64)
        {
          uint64_t v22 = "61706673-7575-6964-0040-766f6c756d00";
          goto LABEL_114;
        }

        if (v21 == 128)
        {
          uint64_t v22 = "61706673-7575-6964-0080-766f6c756d00";
          goto LABEL_114;
        }
      }

      else
      {
        if (v21 == 16)
        {
          uint64_t v22 = "61706673-7575-6964-0010-766f6c756d00";
          goto LABEL_114;
        }

        if (v21 == 32)
        {
          uint64_t v22 = "61706673-7575-6964-0020-766f6c756d00";
          goto LABEL_114;
        }
      }
    }

    return strerror(22);
  }

  if (!strncasecmp(v3, "password=", 9uLL))
  {
    v3 += 9;
    __strlcpy_chk(out + 312, v3, 128LL, 128LL);
    int v23 = strnlen(v3, 0x80uLL);
    *((_DWORD *)out + 110) = v23;
    if ((v23 & 0xFFFFFF80) == 0) {
      return 0LL;
    }
    return (char *)v3;
  }

  if (!strncasecmp(v3, "empty_password", 0xFuLL))
  {
    io_object_t v3 = 0LL;
    out[312] = 0;
    *((_DWORD *)out + 110) = 0;
    return (char *)v3;
  }

  if (!strncasecmp(v3, "volname=", 8uLL))
  {
    __strlcpy_chk(out + 56, v3 + 8, 256LL, 256LL);
    return 0LL;
  }

  unsigned int v4 = strdup(v3);
  if (!v4) {
    return (char *)v3;
  }
  uint64_t v5 = v4;
  __lasts = (char *)0xAAAAAAAAAAAAAAAALL;
  int v6 = strtok_r(v4, ",", &__lasts);
  if (!v6)
  {
    io_object_t v3 = 0LL;
    goto LABEL_103;
  }

  int v7 = v6;
  unint64_t v8 = "fsquota=";
  unint64_t v9 = "fsindex=";
  while (1)
  {
    if (!strncasecmp(v7, "fssize=", 7uLL))
    {
      unint64_t v11 = sub_1000069F4(v7 + 7);
      if (v11 == -1LL) {
        goto LABEL_102;
      }
      *((void *)out + 2) = v11;
LABEL_36:
      *((void *)out + 3) = v11;
      goto LABEL_37;
    }

    if (!strncasecmp(v7, "fsreserve=", 0xAuLL))
    {
      unint64_t v12 = sub_1000069F4(v7 + 10);
      if (v12 == -1LL) {
        goto LABEL_102;
      }
      *((void *)out + 2) = v12;
      goto LABEL_37;
    }

    if (!strncasecmp(v7, v8, 8uLL))
    {
      unint64_t v11 = sub_1000069F4(v7 + 8);
      if (v11 == -1LL) {
        goto LABEL_102;
      }
      goto LABEL_36;
    }

    if (!strncasecmp(v7, v9, 8uLL)) {
      break;
    }
    if (!strcasecmp(v7, "omap=btree") || !strcasecmp(v7, "omap=physical"))
    {
      int v13 = 1073741826;
LABEL_40:
      *((_DWORD *)out + 8) = v13;
      goto LABEL_37;
    }

    if (!strcasecmp(v7, "omap=ephemeral"))
    {
      int v13 = -2147483646;
      goto LABEL_40;
    }

    if (!strcasecmp(v7, "fstree=btree"))
    {
      *(void *)(out + 36) = 0x4000000200000002LL;
      *((_DWORD *)out + 11) = 1073741826;
      *((_DWORD *)out + 123) = 1073741826;
      goto LABEL_37;
    }

    if (!strcasecmp(v7, "encrypted"))
    {
      __int16 v10 = *((_WORD *)out + 26) | 1;
LABEL_55:
      *((_WORD *)out + 26) = v10;
      goto LABEL_37;
    }

    if (!strncasecmp(v7, "role=", 5uLL))
    {
      uint64_t v17 = sub_100013AE0(v7 + 5);
      if (v17 == -1) {
        goto LABEL_102;
      }
      *((_WORD *)out + 27) = v17;
    }

    else
    {
      if (!strcasecmp(v7, "case=insensitive"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFF3 | 4;
        goto LABEL_55;
      }

      if (!strcasecmp(v7, "case=sensitive"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFF3 | 8;
        goto LABEL_55;
      }

      if (!strcasecmp(v7, "defragment=yes"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFCF | 0x20;
        goto LABEL_55;
      }

      if (!strcasecmp(v7, "defragment=no"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFCF | 0x10;
        goto LABEL_55;
      }

      if (!strncasecmp(v7, "uid=", 4uLL))
      {
        io_object_t v14 = v8;
        unint64_t v15 = v9;
        __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
        unint64_t v18 = strtoull(v7 + 4, &__endptr, 10);
        if (__endptr == v7 + 4 || *__endptr || v18 == -1LL) {
          goto LABEL_102;
        }
        *((_DWORD *)out + 111) = v18;
        goto LABEL_45;
      }

      if (!strncasecmp(v7, "gid=", 4uLL))
      {
        io_object_t v14 = v8;
        unint64_t v15 = v9;
        __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
        unint64_t v19 = strtoull(v7 + 4, &__endptr, 10);
        if (__endptr == v7 + 4 || *__endptr || v19 == -1LL) {
          goto LABEL_102;
        }
        *((_DWORD *)out + 112) = v19;
        goto LABEL_45;
      }

      if (!strcasecmp(v7, "sealed=yes"))
      {
        *((_WORD *)out + 26) |= 0x80u;
        *((_DWORD *)out + 122) = 1;
        *((_DWORD *)out + 9) = 2;
        goto LABEL_37;
      }

      if (!strcasecmp(v7, "conformance")) {
        goto LABEL_102;
      }
      if (strncasecmp(v7, "hash=", 5uLL))
      {
        if (!strcasecmp(v7, "unwritten"))
        {
          __int16 v10 = *((_WORD *)out + 26) | 0x400;
        }

        else
        {
          if (strcasecmp(v7, "unwritten=no")) {
            goto LABEL_102;
          }
          __int16 v10 = *((_WORD *)out + 26) & 0xFBFF;
        }

        goto LABEL_55;
      }

      int v20 = sub_100007580(v7 + 5);
      if (v20 == -1) {
        goto LABEL_102;
      }
      *((_DWORD *)out + 122) = v20;
    }

LABEL_37:
    int v7 = strtok_r(0LL, ",", &__lasts);
    if (!v7)
    {
      io_object_t v3 = 0LL;
      goto LABEL_103;
    }
  }

  io_object_t v14 = v8;
  unint64_t v15 = v9;
  __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v16 = strtoull(v7 + 8, &__endptr, 10);
  if (__endptr != v7 + 8 && !*__endptr && v16 != -1LL)
  {
    *((_DWORD *)out + 12) = v16;
LABEL_45:
    unint64_t v9 = v15;
    unint64_t v8 = v14;
    goto LABEL_37;
  }

  unint64_t result = 0LL;
  a1[47] = v2;
  return result;
}

  if ((v27 & 0x80000000) != 0)
  {
LABEL_91:
    sub_100013D94( "%s:%d: %s no space for a new file system (slot %d, max %d)\n",  "apfs_newfs",  31314,  (const char *)(*(void *)(a1 + 384) + 208LL),  v27,  *(_DWORD *)(v42 + 180));
    return 34LL;
  }

  LODWORD(v43) = *(_DWORD *)(v42 + 180);
LABEL_39:
  if (*(void *)(v42 + 8LL * v27 + 184))
  {
    sub_100013D94( "%s:%d: %s existing file system (slot %d)\n",  "apfs_newfs",  31317,  (const char *)(*(void *)(a1 + 384) + 208LL),  v27);
    return 16LL;
  }

  v108 = v26;
  v110 = v17;
  int v51 = v15;
  v113 = v25;
  v125 = v22;
  v122 = v14;
  v124 = v13;
  v116 = v20;
  v118 = v28;
  v112 = v23;
  v106 = v24;
  v126 = v12;
  v120 = v29;
  int v52 = sub_10004FD18(a1, &v132);
  if ((_DWORD)v52)
  {
    uint64_t v53 = v52;
    sub_100013D94( "%s:%d: %s tx_enter() failed: %d\n",  "apfs_newfs",  31323,  (const char *)(*(void *)(a1 + 384) + 208LL),  v52);
    return v53;
  }

  int v54 = sub_10003A068( *(pthread_mutex_t **)(a1 + 392),  0,  0LL,  (uint64_t)&xmmword_10005B954,  0LL,  0LL,  v132,  (uint64_t *)v135);
  if (!(_DWORD)v54)
  {
    v105 = (void *)a1;
    unsigned int v58 = (v51 | v110) != 0;
    v59 = *(void *)v135;
    if (v127 && v51 | v110) {
      *(void *)(*(void *)v135 + 1136LL) = v127;
    }
    *(_BYTE *)(v59 + 3893) = (a3 & 8) != 0;
    *(_DWORD *)(*(void *)(v59 + 376) + 36LL) = v27;
    sub_10002EA64(v59);
    uint64_t v60 = *(void *)(*(void *)v135 + 376LL);
    *(_WORD *)(v60 + 964) = v18;
    uuid_copy((unsigned __int8 *)(v60 + 1008), uu);
    int v61 = *(void *)v135;
    *(void *)(*(void *)v135 + 3880LL) = 0LL;
    sub_100006960(*(void *)(v61 + 376), (const char *)(a2 + 456), v132);
    if (a2 && !uuid_is_null((const unsigned __int8 *)a2))
    {
      int v66 = v30;
      __int128 v67 = a5;
      uuid_copy((unsigned __int8 *)(*(void *)(*(void *)v135 + 376LL) + 240LL), (const unsigned __int8 *)a2);
      __int128 v68 = *(void *)v135;
      v69 = *(void *)(*(void *)v135 + 376LL);
      if (!strncmp((const char *)(v69 + 240), "apfsuuid", 8uLL))
      {
        *(_BYTE *)(v69 + 255) = v27;
        v69 = *(void *)(v68 + 376);
      }

      v70 = sub_10001CDE8(v105, (const unsigned __int8 *)(v69 + 240));
      a5 = v67;
      uint64_t v30 = v66;
      if ((_DWORD)v70)
      {
        int v71 = v70;
        *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&uint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v72 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)uuid_t out = v72;
        *(_OWORD *)&out[16] = v72;
        uuid_unparse((const unsigned __int8 *)a2, out);
        a1 = (uint64_t)v105;
        sub_100013D94( "%s:%d: %s UUID %s is not allowed, error %d\n",  "apfs_newfs",  31378,  (const char *)(v105[48] + 208LL),  out,  v71);
        unint64_t v11 = v71;
        goto LABEL_132;
      }
    }

    else
    {
      uuid_generate((unsigned __int8 *)(*(void *)(*(void *)v135 + 376LL) + 240LL));
    }

    int v62 = *(void *)v135;
    char v63 = *(void *)(*(void *)v135 + 376LL);
    *(void *)(v63 + 176) = 16LL;
    *(_DWORD *)(v63 + 960) = 3;
    *(_WORD *)(v63 + 966) = 0;
    if (v21) {
      *(void *)(v63 + 40) |= 0x10uLL;
    }
    if (v108 == 1)
    {
      uint64_t v64 = 1LL;
    }

    else
    {
      if (v108 != 2) {
        goto LABEL_107;
      }
      uint64_t v64 = 8LL;
    }

    *(void *)(v63 + 56) |= v64;
LABEL_107:
    if (v126) {
      *(void *)(v63 + 56) |= 0x20uLL;
    }
    if (v125)
    {
      *(void *)(v63 + 56) |= 0x80uLL;
      sub_100013CBC( "%s:%d: %s allocated unwritten file extents are now supported\n",  "apfs_newfs",  31428,  (const char *)(v62 + 3992));
      int v62 = *(void *)v135;
      char v63 = *(void *)(*(void *)v135 + 376LL);
    }

    *(void *)(v63 + 40) |= 2uLL;
    unint64_t v11 = sub_10004D208(v105, v62, v124, v122, v132);
    if ((_DWORD)v11)
    {
      sub_100013D94("%s:%d: %s Could not set fs bounds for guarantee %lld and quota %lld: %d\n");
      goto LABEL_131;
    }

    if (v58)
    {
      sub_10002FBD8(*(uint64_t *)v135, 1);
      uint64_t v65 = sub_100030180();
      if ((_DWORD)v65)
      {
        unint64_t v11 = v65;
        sub_100013D94("%s:%d: %s unable to create/store metadata crypto (%d)\n");
        goto LABEL_131;
      }
    }

    else
    {
      sub_100013CBC( "%s:%d: %s FS will NOT be encrypted.\n",  "apfs_newfs",  31464,  (const char *)(*(void *)v135 + 3992LL));
      *(void *)(*(void *)(*(void *)v135 + 376LL) + 264LL) |= 1uLL;
      sub_100030180();
      sub_100030188(*(void *)v135 + 528LL);
    }

    v73 = *(void *)v135;
    v74 = *(void *)(*(void *)v135 + 376LL);
    *(void *)(v74 + 116) = 0x4000000200000002LL;
    *(_DWORD *)(v74 + 124) = 1073741826;
    *(_DWORD *)(v74 + 1104) = 2;
    v75 = sub_100040A44(v73, 0x40000000u, 0, v118, v132, &v134);
    if ((_DWORD)v75)
    {
      unint64_t v11 = v75;
      sub_100013D94("%s:%d: %s fs omap initialization failed: %d\n");
      goto LABEL_131;
    }

    v76 = sub_10003965C((uint64_t)v134);
    *(void *)(*(void *)(*(void *)v135 + 376LL) + 128LL) = v76;
    sub_100038824(v134);
    v138 = xmmword_10006C540;
    v139 = unk_10006C550;
    v140 = xmmword_10006C560;
    v141 = unk_10006C570;
    v136 = off_10006C520;
    v137 = unk_10006C530;
    if (v126)
    {
      unint64_t v11 = sub_1000031DC(*(uint64_t *)v135, *(_DWORD *)(a2 + 488), v132, 0LL);
      a1 = (uint64_t)v105;
      if ((_DWORD)v11) {
        goto LABEL_132;
      }
      HIDWORD(v137) = sub_100002E78(*(_DWORD *)(a2 + 488));
      DWORD2(v137) = *(_DWORD *)(a2 + 488);
      DWORD1(v137) |= 0x180u;
    }

    if ((unsigned __int16)*(_DWORD *)(*(void *)(*(void *)v135 + 376LL) + 116LL) == 2)
    {
      v77 = sub_100027934( *(uint64_t *)v135,  *(_DWORD *)(*(void *)(*(void *)v135 + 376LL) + 116LL) & 0xFFFF0000,  0,  0,  0,  (uint64_t *)&v136,  v132,  (uint64_t *)&v129);
      if (!(_DWORD)v77)
      {
        v88 = sub_10003965C((uint64_t)v129);
        v89 = *(void *)v135;
        v90 = *(void *)(*(void *)v135 + 376LL);
        *(void *)(v90 + 136) = v88;
        if (v112)
        {
          *(void *)(v90 + 56) |= 0x200uLL;
          sub_100013CBC( "%s:%d: %s expanded records are now supported\n",  "apfs_newfs",  31581,  (const char *)(v89 + 3992));
          v89 = *(void *)v135;
          if (v106)
          {
            *(void *)(*(void *)(*(void *)v135 + 376LL) + 48LL) |= 4uLL;
            sub_100013CBC( "%s:%d: %s clone mapping is enabled for this volume\n",  "apfs_newfs",  31585,  (const char *)(v89 + 3992));
            v89 = *(void *)v135;
          }
        }

        if (v113)
        {
          *(void *)(*(void *)(v89 + 376) + 48LL) |= 8uLL;
          sub_100013CBC( "%s:%d: %s attribution tags are supported on this volume\n",  "apfs_newfs",  31591,  (const char *)(v89 + 3992));
          v89 = *(void *)v135;
        }

        v91 = *(_DWORD *)(*(void *)(v89 + 376) + 120LL);
        *(void *)&out[8] = 0LL;
        v147 = 0LL;
        v146 = 0u;
        v145 = 0u;
        v144 = 0u;
        *(_OWORD *)&out[24] = 0u;
        *(void *)uuid_t out = sub_100015700;
        *(void *)&out[16] = 0x420000000FLL;
        if ((unsigned __int16)v91 == 2)
        {
          v92 = sub_100027934(v89, v91 & 0xBFFF0000 | 0x40000000, 0, 0, 0, (uint64_t *)out, v132, (uint64_t *)&v131);
          if (!(_DWORD)v92)
          {
            v93 = sub_10003965C((uint64_t)v131);
            v94 = *(void *)v135;
            v95 = *(void *)(*(void *)v135 + 376LL);
            *(void *)(v95 + 144) = v93;
            v96 = *(_DWORD *)(v95 + 124);
            *(void *)&out[8] = 0LL;
            v147 = 0LL;
            v146 = 0u;
            v145 = 0u;
            v144 = 0u;
            *(_OWORD *)&out[24] = 0u;
            *(void *)uuid_t out = sub_100015700;
            *(void *)&out[16] = 0x4200000010LL;
            if ((unsigned __int16)v96 == 2)
            {
              v97 = sub_100027934(v94, v96 & 0xBFFF0000 | 0x40000000, 0, 0, 0, (uint64_t *)out, v132, (uint64_t *)&v130);
              if (!(_DWORD)v97)
              {
                v98 = sub_10003965C((uint64_t)v130);
                v99 = *(void *)v135;
                *(void *)(*(void *)(*(void *)v135 + 376LL) + 152LL) = v98;
                if (v126)
                {
                  v100 = sub_1000036FC(v99, v120, 5, v132, (uint64_t *)&v128);
                  if ((_DWORD)v100)
                  {
                    unint64_t v11 = v100;
                    sub_100013D94("%s:%d: %s fs fext tree creation failed: %d\n");
                    goto LABEL_131;
                  }

                  v99 = *(void *)v135;
                  *(void *)(*(void *)(*(void *)v135 + 376LL) + 1032LL) = v128;
                }

                v101 = sub_100015E2C( v99,  1,  0LL,  "root",  0LL,  2LL,  0x41EDu,  v19,  v116,  0,  -1,  0LL,  0,  (void *)(v99 + 480),  v132,  0,  -1);
                if ((_DWORD)v101)
                {
                  unint64_t v11 = v101;
                  sub_100013D94("%s:%d: %s fs root dir creation failed: %d\n");
                }

                else
                {
                  __strlcpy_chk(*(void *)(*(void *)v135 + 376LL) + 704LL, v30, 256LL, 256LL);
                  unint64_t v11 = sub_100015E2C( *(uint64_t *)v135,  1,  0LL,  "private-dir",  0LL,  3LL,  0x41A4u,  0,  0,  0,  -1,  0LL,  0,  (void *)(*(void *)v135 + 488LL),  v132,  0,  -1);
                  if (!(_DWORD)v11)
                  {
                    *(void *)(v105[47] + 8LL * v27 + 184) = sub_10003965C(*(uint64_t *)v135);
                    v102 = sub_100032B28();
                    v103 = *(void *)v135;
                    *(void *)(*(void *)(*(void *)v135 + 376LL) + 256LL) = v102;
                    sub_10001AAF0(v103, v132);
                    sub_100038824(v130);
                    sub_100038824(v131);
                    sub_100038824(v129);
                    sub_10004FD28((uint64_t)v105, v132, 5);
                    *a5 = *(void *)v135;
                    return v11;
                  }

                  sub_100013D94("%s:%d: %s fs private dir creation failed: %d\n");
                }

                goto LABEL_131;
              }

              unint64_t v11 = v97;
            }

            else
            {
              unint64_t v11 = 22LL;
            }

            sub_100013D94("%s:%d: %s fs snapshot metadata tree creation failed: %d\n");
LABEL_131:
            a1 = (uint64_t)v105;
            goto LABEL_132;
          }

          unint64_t v11 = v92;
        }

        else
        {
          unint64_t v11 = 22LL;
        }

        sub_100013D94("%s:%d: %s fs extentref tree creation failed: %d\n");
        goto LABEL_131;
      }

      unint64_t v11 = v77;
    }

    else
    {
      unint64_t v11 = 22LL;
    }

    sub_100013D94("%s:%d: %s fs root tree creation failed: %d\n");
    goto LABEL_131;
  }

  v55 = v54;
  sub_100013D94( "%s:%d: %s failed to create fs: %d\n",  "apfs_newfs",  31338,  (const char *)(*(void *)(a1 + 384) + 208LL),  v54);
  unint64_t v11 = v55;
LABEL_132:
  sub_100013D94( "%s:%d: %s fs creation failed: %d ... cleaning up...\n",  "apfs_newfs",  31789,  (const char *)(*(void *)(a1 + 384) + 208LL),  v11);
  v133 = 0LL;
  if (*(void *)v135)
  {
    if (v129)
    {
      v78 = sub_100029238((size_t)v129, v132, &v133);
      if (v78) {
        sub_100013D94( "%s:%d: %s failed to delete fs root tree after fs creation failed: %d\n",  "apfs_newfs",  31801,  (const char *)(*(void *)v135 + 3992LL),  v78);
      }
      sub_100038824(v129);
    }

    if (v130)
    {
      v79 = sub_100029238((size_t)v130, v132, &v133);
      if (v79) {
        sub_100013D94( "%s:%d: %s failed to delete fs snap metadata tree after fs creation failed: %d\n",  "apfs_newfs",  31817,  (const char *)(*(void *)v135 + 3992LL),  v79);
      }
      sub_100038824(v130);
    }

    if (v131)
    {
      v80 = sub_100029238((size_t)v131, v132, &v133);
      if (v80) {
        sub_100013D94( "%s:%d: %s failed to delete fs extentref tree after fs creation failed: %d\n",  "apfs_newfs",  31824,  (const char *)(*(void *)v135 + 3992LL),  v80);
      }
      sub_100038824(v131);
    }

    v81 = *(void *)v135;
    if (v128)
    {
      v82 = sub_100003864(*(uint64_t *)v135, v120, 5, v132, v128, &v133);
      v81 = *(void *)v135;
      if (v82)
      {
        sub_100013D94( "%s:%d: %s failed to delete fs fext tree after fs creation failed: %d\n",  "apfs_newfs",  31832,  (const char *)(*(void *)v135 + 3992LL),  v82);
        v81 = *(void *)v135;
      }
    }

    v83 = *(void *)(*(void *)(v81 + 376) + 128LL);
    if (v83)
    {
      v84 = sub_100040C2C(v81, v83, v132, &v133);
      v81 = *(void *)v135;
      if (v84)
      {
        sub_100013D94( "%s:%d: %s failed to destroy omap after fs creation failed: %d\n",  "apfs_newfs",  31847,  (const char *)(*(void *)v135 + 3992LL),  v84);
        v81 = *(void *)v135;
      }
    }

    if (*(void *)(v81 + 3568))
    {
      sub_100038824(*(uint64_t **)(v81 + 3568));
      v81 = *(void *)v135;
    }

    if (*(void *)(v81 + 3544))
    {
      sub_100038824(*(uint64_t **)(v81 + 3544));
      v81 = *(void *)v135;
    }

    sub_100014300(v81, *(unsigned __int8 **)(v81 + 480));
    sub_100014300(v85, *(unsigned __int8 **)(*(void *)v135 + 488LL));
  }

  if (v132)
  {
    sub_10004FD28(a1, v132, 0);
    v132 = 0LL;
  }

  if (v133)
  {
    v86 = sub_100012734((uint64_t *)a1, v133);
    if (v86) {
      sub_100013D94( "%s:%d: %s failed to wait on reaper: %d\n",  "apfs_newfs",  31872,  (const char *)(*(void *)(a1 + 384) + 208LL),  v86);
    }
  }

  if (*(void *)v135)
  {
    v87 = sub_10004FD18(a1, &v132);
    if (v87)
    {
      sub_100013D94( "%s:%d: %s Couldn't reopen transaction to clean up: %d\n",  "apfs_newfs",  31880,  (const char *)(*(void *)(a1 + 384) + 208LL),  v87);
    }

    else
    {
      sub_10004D4EC((void *)a1, *(uint64_t *)v135, v132);
      sub_10003B238(*(uint64_t **)v135, v132);
      sub_10004FD28(a1, v132, 0);
      v132 = 0LL;
    }

    sub_100038824(*(uint64_t **)v135);
  }

  return v11;
}

LABEL_102:
  v3 += v7 - v5;
LABEL_103:
  free(v5);
  return (char *)v3;
}

uint64_t sub_100007580(const char *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!strncasecmp(a1, "sha256", 7uLL)) {
    return 1LL;
  }
  if (!strncasecmp(a1, "sha512_256", 0xBuLL)) {
    return 5LL;
  }
  if (!strncasecmp(a1, "sha384", 7uLL)) {
    return 3LL;
  }
  if (!strncasecmp(a1, "sha512", 7uLL)) {
    return 4LL;
  }
  return 0xFFFFFFFFLL;
}

const char *sub_100007628( const char *a1, uint64_t (*a2)(const char *, uint64_t), uint64_t a3, uint64_t (*a4)(const char *, uint64_t), uint64_t a5)
{
  size_t v10 = strlen(a1);
  size_t v11 = 0LL;
  size_t v12 = 0LL;
  do
  {
    if (v11 != v10 && v11 <= v12)
    {
      int v13 = (const char *)a2(&a1[v11], a3);
      size_t v11 = v10;
      if (v13)
      {
        size_t v11 = v13 - a1;
        if (v13 - a1 < v12)
        {
          io_object_t v14 = strchr(v13, 44);
          if (v14) {
            size_t v11 = v14 - a1;
          }
          else {
            size_t v11 = v10;
          }
        }
      }
    }

    if (v12 != v10 && v12 <= v11)
    {
      unint64_t v15 = (const char *)a4(&a1[v12], a5);
      size_t v12 = v10;
      if (v15)
      {
        size_t v12 = v15 - a1;
        if (v15 - a1 < v11)
        {
          unint64_t v16 = strchr(v15, 44);
          if (v16) {
            size_t v12 = v16 - a1;
          }
          else {
            size_t v12 = v10;
          }
        }
      }
    }
  }

  while (v11 != v12);
  if (v11 == v10) {
    return 0LL;
  }
  else {
    return &a1[v11];
  }
}

uint64_t sub_100007718(void *a1, char a2)
{
  io_object_t v3 = a1;
  v270 = (char *)0xAAAAAAAAAAAAAAAALL;
  v271 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  int v269 = 0;
  v267 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  v268 = 0LL;
  v266 = 0LL;
  memset(v265, 170, sizeof(v265));
  memset(v264, 170, sizeof(v264));
  uint64_t v4 = a1[47];
  uint64_t v5 = sub_100044238(a1, (uint64_t *)&v271);
  if ((_DWORD)v5)
  {
    uint64_t v6 = v5;
    sub_100013D94("%s:%d: %s unable to get spaceman: %d\n", "nx_check", 70, (const char *)(v3[48] + 208LL), v5);
    return v6;
  }

  int v7 = (uint32x2_t *)v271[47];
  unint64_t v252 = sub_100039664((uint64_t)v271);
  __int32 v8 = v7[4].i32[0];
  uint64_t v255 = v4;
  int v9 = *(_DWORD *)(v4 + 36);
  if (v8 != v9)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman block size %d doesn't match nx superblock block size %d\n",  "nx_check",  78,  (const char *)(v3[48] + 208LL),  v8,  v9);
    __int32 v8 = v7[4].i32[0];
  }

  char v241 = a2;
  __int32 v10 = v7[4].i32[1];
  LODWORD(v11) = v8;
  if (v10 != 8 * v8)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman blocks per chunk is bad: %d\n",  "nx_check",  82,  (const char *)(v3[48] + 208LL),  v10);
    LODWORD(v11) = v7[4].i32[0];
  }

  unint64_t v12 = v11 + 0x1FFFFFFFD8LL;
  unint64_t v13 = v12 >> 5;
  __int32 v14 = v7[5].i32[0];
  if (v14 == (v12 >> 5))
  {
    uint64_t v11 = v11;
  }

  else
  {
    ++v269;
    sub_100013D4C("%s:%d: %s spaceman chunks per cib is bad: %d\n", "nx_check", 86, (const char *)(v3[48] + 208LL), v14);
    uint64_t v11 = v7[4].u32[0];
  }

  unint64_t v259 = v11 + 0x7FFFFFFD8LL;
  unint64_t v15 = (unint64_t)(v11 + 0x7FFFFFFD8LL) >> 3;
  __int32 v16 = v7[5].i32[1];
  unsigned int v249 = v15;
  if (v16 != (_DWORD)v15)
  {
    ++v269;
    sub_100013D4C("%s:%d: %s spaceman cibs per cab is bad: %d\n", "nx_check", 90, (const char *)(v3[48] + 208LL), v16);
  }

  unint64_t v17 = (8 * v8);
  uint32x2_t v18 = v7[6];
  uint64_t v19 = *(void *)&v7[12] + *(void *)&v18;
  uint64_t v20 = *(void *)(v4 + 40);
  if (v19 != v20)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman block count %lld doesn't match nx superblock block count %lld\n",  "nx_check",  94,  (const char *)(v3[48] + 208LL),  v19,  v20);
    uint32x2_t v18 = v7[6];
  }

  uint32x2_t v21 = v7[7];
  if (*(void *)&v18 % v17) {
    uint64_t v22 = *(void *)&v18 / v17 + 1;
  }
  else {
    uint64_t v22 = *(void *)&v18 / v17;
  }
  if (*(void *)&v21 != v22)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman chunk count is bad: %lld\n",  "nx_check",  97,  (const char *)(v3[48] + 208LL),  *(void *)&v21);
    uint32x2_t v21 = v7[7];
  }

  uint64_t v23 = v7[8].u32[0];
  unint64_t v24 = (v12 >> 5);
  unint64_t v248 = v24;
  if (*(void *)&v21 % v24) {
    uint64_t v25 = *(void *)&v21 / v24 + 1;
  }
  else {
    uint64_t v25 = *(void *)&v21 / v24;
  }
  if (v25 != v23)
  {
    ++v269;
    sub_100013D4C("%s:%d: %s spaceman cib count is bad: %d\n", "nx_check", 100, (const char *)(v3[48] + 208LL), v23);
    LODWORD(v23) = v7[8].i32[0];
  }

  unsigned int v26 = v23 / v249;
  if (v26 == 1) {
    unsigned int v27 = 0;
  }
  else {
    unsigned int v27 = v26;
  }
  __int32 v28 = v7[8].i32[1];
  if (v28 != v27)
  {
    ++v269;
    sub_100013D4C("%s:%d: %s spaceman cab count is bad: %d\n", "nx_check", 109, (const char *)(v3[48] + 208LL), v28);
  }

  uint32x2_t v29 = v7[9];
  uint32x2_t v30 = v7[6];
  if (*(void *)&v29 > *(void *)&v30)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free count is too large: %lld > %lld\n",  "nx_check",  112,  (const char *)(v3[48] + 208LL),  *(void *)&v29,  *(void *)&v30);
  }

  uint32x2_t v32 = v7[12];
  uint32x2_t v31 = v7[13];
  if (*(void *)&v32 % v17) {
    uint64_t v33 = *(void *)&v32 / v17 + 1;
  }
  else {
    uint64_t v33 = *(void *)&v32 / v17;
  }
  if (*(void *)&v31 != v33)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman tier2 chunk count is bad: %lld\n",  "nx_check",  116,  (const char *)(v3[48] + 208LL),  *(void *)&v31);
    uint32x2_t v31 = v7[13];
  }

  uint64_t v34 = v7[14].u32[0];
  if (*(void *)&v31 % v248) {
    uint64_t v35 = *(void *)&v31 / v248 + 1;
  }
  else {
    uint64_t v35 = *(void *)&v31 / v248;
  }
  if (v35 != v34)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman tier2 cib count is bad: %d\n",  "nx_check",  119,  (const char *)(v3[48] + 208LL),  v34);
    LODWORD(v34) = v7[14].i32[0];
  }

  unsigned int v36 = v34 / v249;
  if (v36 == 1) {
    unsigned int v37 = 0;
  }
  else {
    unsigned int v37 = v36;
  }
  __int32 v38 = v7[14].i32[1];
  if (v38 != v37)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman tier2 cab count is bad: %d\n",  "nx_check",  128,  (const char *)(v3[48] + 208LL),  v38);
  }

  uint32x2_t v39 = v7[15];
  uint32x2_t v40 = v7[12];
  if (*(void *)&v39 > *(void *)&v40)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman tier2 free count is too large: %lld > %lld\n",  "nx_check",  131,  (const char *)(v3[48] + 208LL),  *(void *)&v39,  *(void *)&v40);
  }

  uint64_t v41 = vaddvq_s64((int64x2_t)vaddl_u32(v7[8], v7[14])) + *(void *)&v7[7] + *(void *)&v7[13];
  uint64_t v42 = *(void *)&v7[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v42 != 3 * v41)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP block count is bad: %lld\n",  "nx_check",  137,  (const char *)(v3[48] + 208LL),  v42);
    uint64_t v42 = *(void *)&v7[19] & 0x7FFFFFFFFFFFFFFFLL;
  }

  uint64_t v43 = v7[20].u32[0];
  if ((v7[4].u32[0] + 8 * ((unint64_t)(v42 + 63) >> 6) - 1) / v7[4].u32[0] != v43)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bm block count is bad: %d\n",  "nx_check",  140,  (const char *)(v3[48] + 208LL),  v43);
  }

  unsigned int v44 = v7[20].i32[1] & 0x7FFFFFFF;
  if (v44 >= 0xFFFF)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bitmap block count is too large: %d\n",  "nx_check",  143,  (const char *)(v3[48] + 208LL),  v44);
  }

  unsigned int v45 = v7[18].u32[1];
  if (v45 <= 3)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bitmap tx multiplier is too small: %d\n",  "nx_check",  146,  (const char *)(v3[48] + 208LL),  v45);
  }

  unsigned __int32 v46 = v7[20].u32[0];
  unsigned int v47 = v7[20].i32[1] & 0x7FFFFFFF;
  if (v47 / v46 <= 3)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bitmap block count per tx is too small: %d\n",  "nx_check",  149,  (const char *)(v3[48] + 208LL),  v47 / v46);
    unsigned __int32 v46 = v7[20].u32[0];
    unsigned int v47 = v7[20].i32[1] & 0x7FFFFFFF;
  }

  unsigned __int32 v48 = v7[18].u32[1];
  if (v47 != v48 * v46)
  {
    unsigned int v49 = 65534;
    if (v47 != 65534)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman IP bitmap block count is bad: %d\n",  "nx_check",  156,  (const char *)(v3[48] + 208LL),  v47);
      unsigned __int32 v46 = v7[20].u32[0];
      unsigned __int32 v48 = v7[18].u32[1];
      unsigned int v49 = v7[20].i32[1] & 0x7FFFFFFF;
    }

    if (v49 / v46 < v48 >> 1)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman IP bitmap block count is too low: %d\n",  "nx_check",  159,  (const char *)(v3[48] + 208LL),  v49);
    }
  }

  uint32x2_t v50 = v7[6];
  uint32x2_t v51 = v7[21];
  if (!*(void *)&v51 || *(void *)&v51 >= *(void *)&v50)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bm base address is bad: %lld\n",  "nx_check",  166,  (const char *)(v3[48] + 208LL),  *(void *)&v51);
  }

  uint32x2_t v52 = v7[22];
  if (!*(void *)&v52 || *(void *)&v52 >= *(void *)&v50)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP base address is bad: %lld\n",  "nx_check",  169,  (const char *)(v3[48] + 208LL),  *(void *)&v52);
  }

  uint64_t v261 = v41;
  v246 = v7;
  if (v7[20].i32[0])
  {
    unint64_t v53 = 0LL;
    unint64_t v243 = 0LL;
    do
    {
      int v54 = v271;
      unint64_t v55 = *(void *)(v271[108] + 8 * v53);
      if (v55 > v252)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman IP bitmap block %d xid %lld > spaceman xid %lld\n",  "nx_check",  176,  (const char *)(v3[48] + 208LL),  v53,  v55,  v252);
        int v54 = v271;
      }

      unsigned int v56 = *(unsigned __int16 *)(v54[109] + 2 * v53);
      if ((v7[20].i32[1] & 0x7FFFFFFFu) <= v56)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman IP bitmap block %d index %d out of range\n",  "nx_check",  179,  (const char *)(v3[48] + 208LL),  v53,  v56);
        unsigned int v56 = *(unsigned __int16 *)(v271[109] + 2 * v53);
      }

      int v57 = sub_1000441FC((uint64_t)v3, (uint64_t)v7, v56, &v264[2]);
      if (v57
        || (int v57 = sub_10003B574( v3[49],  0x40000000u,  v264[2],  (int *)&xmmword_10005BA74,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v266)) != 0)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman IP bitmap unable to get bitmap block %d @ %lld: %d\n",  "nx_check",  187,  (const char *)(v3[48] + 208LL),  v53,  v264[2],  v57);
      }

      else
      {
        if (v53 == v7[20].i32[0] - 1) {
          unint64_t v58 = (*(void *)&v7[19] & 0x7FFFFFFFFFFFFFFFuLL) % (8 * v7[4].i32[0]);
        }
        else {
          unint64_t v58 = (8 * v7[4].i32[0]);
        }
        v243 += sub_10001D7F0(v266[7], 0, 0LL, v58);
        sub_100038824(v266);
      }

      ++v53;
    }

    while (v53 < v7[20].u32[0]);
  }

  else
  {
    unint64_t v243 = 0LL;
  }

  uint64_t v59 = v41;
  unint64_t v60 = *(void *)&v7[7] + 2 * v41 + *(void *)&v7[13] - 1;
  if (v243 > v60)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bitmap has too many free blocks %lld > %lld\n",  "nx_check",  196,  (const char *)(v3[48] + 208LL),  v243,  v60);
  }

  unsigned int v61 = v7[40].u16[0];
  __int32 v62 = v7[20].i32[1];
  LODWORD(v63) = v62 & 0x7FFFFFFF;
  if ((v62 & 0x7FFFFFFFu) <= v61)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bitmap free head %d out of range\n",  "nx_check",  201,  (const char *)(v3[48] + 208LL),  v61);
    __int32 v62 = v7[20].i32[1];
    LODWORD(v63) = v62 & 0x7FFFFFFF;
  }

  unsigned int v64 = v7[40].u16[1];
  if (v63 > v64
    || (++v269,
        sub_100013D4C( "%s:%d: %s spaceman IP bitmap free head %d out of range\n",  "nx_check",  204,  (const char *)(v3[48] + 208LL),  v64),  __int32 v62 = v7[20].i32[1],  LODWORD(v63) = v62 & 0x7FFFFFFF,  (v62 & 0x7FFFFFFF) != 0))
  {
    unint64_t v65 = 0LL;
    uint64_t v66 = 0LL;
    uint64_t v67 = v271[110];
    do
    {
      unsigned int v68 = *(unsigned __int16 *)(v67 + 2 * v65);
      BOOL v69 = v68 == 0xFFFF || v63 > v68;
      if (!v69)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman IP bitmap free next %d, value %d invalid\n",  "nx_check",  209,  (const char *)(v3[48] + 208LL),  v65,  v68);
        __int32 v62 = v7[20].i32[1];
        uint64_t v67 = v271[110];
        unsigned int v68 = *(unsigned __int16 *)(v67 + 2 * v65);
      }

      unint64_t v63 = v62 & 0x7FFFFFFF;
      ++v65;
    }

    while (v65 < v63);
  }

  else
  {
    uint64_t v66 = 0LL;
  }

  v70 = v7;
  unsigned int v71 = v7[40].u16[0];
  if (v71 == 0xFFFF) {
    uint64_t v72 = v66;
  }
  else {
    uint64_t v72 = v66 + 1;
  }
  uint64_t v73 = (v63 - v7[20].i32[0]);
  if (v72 != v73)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP bitmap next array free count is wrong, %lld != %d\n",  "nx_check",  224,  (const char *)(v3[48] + 208LL),  v72,  v73);
    __int32 v62 = v7[20].i32[1];
    unsigned int v71 = v7[40].u16[0];
  }

  unsigned int v74 = v62 & 0x7FFFFFFF;
  unint64_t v75 = v252;
  if (v74 && v74 > v71)
  {
    uint64_t v76 = 0LL;
    do
    {
      ++v76;
      unsigned int v71 = *(unsigned __int16 *)(v271[110] + 2LL * v71);
    }

    while (v76 < v74 && v74 > v71);
    v72 -= v76;
  }

  if (v72 < 0)
  {
    ++v269;
    sub_100013D4C("%s:%d: %s spaceman IP bitmap free list corrupted, too long, count %lld\n");
  }

  else if (v72)
  {
    ++v269;
    sub_100013D4C("%s:%d: %s spaceman IP bitmap free list corrupted, too short, count %lld\n");
  }

  unint64_t v78 = (unint64_t)v7[25];
  unint64_t v79 = *(void *)&v7[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v78 > v79)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP free queue count is too large: %lld > %lld\n",  "nx_check",  244,  (const char *)(v3[48] + 208LL),  v78,  v79);
  }

  if (v7[26])
  {
    int v80 = sub_100045974((uint64_t)v3, (uint64_t)v271, 0, 0LL, 0, &v265[4]);
    if (v80)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s unable to get spaceman IP free queue tree: %d\n",  "nx_check",  252,  (const char *)(v3[48] + 208LL),  v80);
    }

    else if (v265[4])
    {
      int v151 = sub_10000FB54((void *)v265[4], 0LL, 0, 0);
      if (v151)
      {
        int v152 = v151;
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman IP free queue tree sanity check failed: %d\n",  "nx_check",  256,  (const char *)(v3[48] + 208LL),  v151);
        v264[1] = 0x1000000008LL;
      }

      else
      {
        v264[1] = 0x1000000008LL;
        int v152 = sub_1000261E0(v265[4], 0LL, &v265[1], (_DWORD *)&v264[1] + 1, &v265[3], (unsigned int *)&v264[1]);
      }

      unint64_t v178 = 0LL;
      uint64_t v81 = 0LL;
      for (uint64_t i = 0LL;
            !v152;
            int v152 = sub_100026464( v265[4],  0LL,  (unint64_t *)&v265[1],  (unsigned int *)&v264[1] + 1,  HIDWORD(v264[1]),  &v265[3],  (unsigned int *)&v264[1],  4u,  0,  0LL))
      {
        if (LODWORD(v264[1]))
        {
          uint64_t v180 = v265[3];
        }

        else
        {
          v265[3] = 1LL;
          uint64_t v180 = 1LL;
        }

        unint64_t v181 = v265[1];
        if (v265[1] > v252)
        {
          ++v269;
          sub_100013D4C( "%s:%d: %s spaceman IP free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n",  "nx_check",  269,  (const char *)(v3[48] + 208LL),  v265[1],  v265[2],  v252);
          unint64_t v181 = v265[1];
        }

        if (v181 >= v178)
        {
          unint64_t v182 = v265[2];
          if (v181 == v178)
          {
            if (v265[2] < i)
            {
              ++v269;
              sub_100013D4C( "%s:%d: %s spaceman IP free queue tree entries out of order: addr %lld < %lld\n",  "nx_check",  277,  (const char *)(v3[48] + 208LL),  v265[2],  i);
              unint64_t v182 = v265[2];
            }

            uint64_t i = v265[3] + v182;
          }

          else
          {
            uint64_t i = 0LL;
            unint64_t v178 = v181;
          }
        }

        else
        {
          ++v269;
          sub_100013D4C( "%s:%d: %s spaceman IP free queue tree entries out of order: xid %lld < %lld\n",  "nx_check",  272,  (const char *)(v3[48] + 208LL),  v181,  v178);
          uint64_t i = 0LL;
          unint64_t v182 = v265[2];
          unint64_t v178 = v265[1];
        }

        int v183 = sub_100047D80((uint64_t)v3, (uint64_t)v271, v182, v264);
        if (v183)
        {
          ++v269;
          if (v183 == 2) {
            sub_100013D4C("%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld addr is bad\n");
          }
          else {
            sub_100013D4C("%s:%d: %s error getting IP block index for spaceman IP free queue tree entry %lld:%lld %lld\n");
          }
        }

        if (v265[3] >= 2uLL)
        {
          int v184 = sub_100047D80((uint64_t)v3, (uint64_t)v271, v265[3] + v265[2] - 1, v264);
          if (v184)
          {
            ++v269;
            if (v184 == 2) {
              sub_100013D4C("%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld end addr is bad\n");
            }
            else {
              sub_100013D4C("%s:%d: %s error getting end block index for spaceman IP free queue tree entry %lld:%lld %lld\n");
            }
          }
        }

        v81 += v180;
        LODWORD(v264[1]) = 8;
      }

      if (v152 != 2)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman IP free queue tree iteration aborted with error %d\n",  "nx_check",  304,  (const char *)(v3[48] + 208LL),  v152);
      }

      sub_100038824((uint64_t *)v265[4]);
      unint64_t v75 = v252;
      uint64_t v59 = v261;
      goto LABEL_127;
    }
  }

  uint64_t v81 = 0LL;
LABEL_127:
  uint32x2_t v82 = v7[25];
  if (v81 != *(void *)&v82)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP free queue count %lld doesn't match count in the free queue: %lld\n",  "nx_check",  310,  (const char *)(v3[48] + 208LL),  *(void *)&v82,  v81);
  }

  uint64_t v83 = 0LL;
  uint64_t v84 = 0LL;
  uint64_t v257 = 0LL;
  v258 = v3;
  uint64_t v242 = 2 * v59;
  unint64_t v85 = (v259 >> 3);
  char v86 = 1;
  uint64_t v244 = v81;
  unint64_t v250 = v85;
  do
  {
    v87 = v70;
    v88 = &v70[6 * v83];
    __int32 v90 = v88[8].i32[0];
    v89 = v88 + 8;
    char v245 = v86;
    if (v90)
    {
      unint64_t v91 = 0LL;
      uint64_t v262 = 0LL;
      uint64_t v260 = 0LL;
      uint64_t v254 = v83;
      v92 = &v87[6 * v83];
      v253 = (_DWORD *)&v92[8] + 1;
      v247 = v92 + 7;
      uint64_t v93 = 0xFFFFFFFFLL;
      while (1)
      {
        if (!*v253)
        {
          uint64_t v256 = v93;
          v98 = v271;
          v99 = (unint64_t *)(v271[v83 + 111] + 8 * v91);
          goto LABEL_157;
        }

        unint64_t v95 = v91 / v85;
        unint64_t v96 = *(void *)(v271[v83 + 111] + 8LL * (v91 / v85));
        if (v268)
        {
          sub_100038824(v268);
          v268 = 0LL;
        }

        int v97 = sub_10003B574(v3[49], 0x40000000u, v96, (int *)&xmmword_10005BA54, 0LL, 0LL, 0LL, 0LL, (uint64_t *)&v268);
        if (v97)
        {
          ++v269;
          sub_100013D4C( "%s:%d: %s unable to read cab %d @ %lld: %d\n",  "nx_check",  332,  (const char *)(v3[48] + 208LL),  v91 / v85,  v96,  v97);
          uint64_t v93 = v91 / v85;
          unint64_t v75 = v252;
          unint64_t v85 = v250;
        }

        else
        {
          uint64_t v100 = v268[7];
          unint64_t v101 = *(unsigned int *)(v100 + 36);
          if (v101 <= ((unint64_t)sub_1000398C8((uint64_t)v268) - 40) >> 3)
          {
            if (sub_100039664((uint64_t)v268) > v252)
            {
              ++v269;
              v102 = (const char *)(v3[48] + 208LL);
              uint64_t v103 = sub_100039664((uint64_t)v268);
              sub_100013D4C("%s:%d: %s cab %d xid %lld > spaceman xid %lld\n", "nx_check", 344, v102, v95, v103, v252);
            }

            int v104 = *(_DWORD *)(v100 + 32);
            uint64_t v93 = v95;
            if (v104 != (_DWORD)v95)
            {
              ++v269;
              sub_100013D4C( "%s:%d: %s cab %d index %d should be %d\n",  "nx_check",  347,  (const char *)(v3[48] + 208LL),  v95,  v104,  v95);
              uint64_t v93 = v95;
            }

            int v105 = *(_DWORD *)(v100 + 36);
            uint64_t v83 = v254;
            if (v105 != v249 && (*v253 - 1 != (_DWORD)v93 || v105 != v89->i32[0] % v249))
            {
              ++v269;
              int v106 = v249;
              if (*v253 - 1 == (_DWORD)v93) {
                int v106 = v89->i32[0] % v249;
              }
              sub_100013D4C( "%s:%d: %s cab %d cib count %d should be %d\n",  "nx_check",  352,  (const char *)(v3[48] + 208LL),  v93,  v105,  v106);
              uint64_t v93 = v95;
            }

            uint64_t v84 = v100;
            unint64_t v75 = v252;
            unint64_t v85 = v250;
LABEL_156:
            uint64_t v256 = v93;
            v99 = (unint64_t *)(v84 + 8 * (v91 - v93 * v249) + 40);
            v98 = v271;
LABEL_157:
            unint64_t v107 = *v99;
            int v108 = sub_100047D80((uint64_t)v3, (uint64_t)v98, *v99, v264);
            if (v108)
            {
              ++v269;
              if (v108 == 2) {
                sub_100013D4C("%s:%d: %s spaceman chunk info block %lld addr %lld not within IP block range\n");
              }
              else {
                sub_100013D4C("%s:%d: %s error getting IP block index for spaceman chunk info block %lld addr %lld\n");
              }
            }

            int v109 = sub_10003B574( v3[49],  0x40000000u,  v107,  (int *)&xmmword_10005BA64,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v267);
            if (v109)
            {
              ++v269;
              sub_100013D4C( "%s:%d: %s unable to read cib %lld @ %lld: %d\n",  "nx_check",  369,  (const char *)(v3[48] + 208LL),  v91,  v107,  v109);
LABEL_216:
              uint64_t v93 = v256;
              goto LABEL_217;
            }

            if (sub_100039664((uint64_t)v267) > v75)
            {
              ++v269;
              v110 = (const char *)(v3[48] + 208LL);
              uint64_t v111 = sub_100039664((uint64_t)v267);
              sub_100013D4C("%s:%d: %s cib %lld xid %lld > spaceman xid %lld\n", "nx_check", 374, v110, v91, v111, v75);
            }

            uint64_t v112 = v267[7];
            uint64_t v113 = *(unsigned int *)(v112 + 32);
            if (v91 != v113)
            {
              ++v269;
              sub_100013D4C( "%s:%d: %s cib %lld index %d should be %lld\n",  "nx_check",  378,  (const char *)(v3[48] + 208LL),  v91,  v113,  v91);
            }

            uint64_t v114 = *(unsigned int *)(v112 + 36);
            unsigned int v115 = v13;
            if ((_DWORD)v114 != (_DWORD)v13)
            {
              if (v91 != v89->i32[0] - 1 || (unsigned int v115 = *(_DWORD *)(v112 + 36), *(void *)v247 % v248 != v114))
              {
                ++v269;
                unint64_t v116 = v248;
                if (v91 == v89->i32[0] - 1) {
                  unint64_t v116 = *(void *)v247 % v248;
                }
                sub_100013D4C( "%s:%d: %s cib %lld chunk info count %d should be %lld\n",  "nx_check",  383,  (const char *)(v3[48] + 208LL),  v91,  v114,  v116);
                unsigned int v115 = *(_DWORD *)(v112 + 36);
              }

              if (v115 > v13)
              {
                ++v269;
                sub_100013D4C( "%s:%d: %s cib %lld cib_chunk_info_count %d invalid\n",  "nx_check",  387,  (const char *)(v3[48] + 208LL),  v107,  v115);
                unsigned int v115 = *(_DWORD *)(v112 + 36);
              }
            }

            uint64_t v251 = v84;
            else {
              unsigned int v117 = v115;
            }
            if (!v117)
            {
LABEL_215:
              sub_100038824(v267);
              uint64_t v84 = v251;
              unint64_t v75 = v252;
              unint64_t v85 = v250;
              uint64_t v83 = v254;
              goto LABEL_216;
            }

            unint64_t v118 = 0LL;
            unint64_t v119 = v17 * (unint64_t)v248 * v91;
            v120 = (unint64_t *)(v112 + 64);
            while (2)
            {
              unint64_t v121 = *(v120 - 3);
              if (v121 > sub_100039664((uint64_t)v267))
              {
                ++v269;
                v122 = (const char *)(v3[48] + 208LL);
                uint64_t v123 = *(v120 - 3);
                uint64_t v124 = sub_100039664((uint64_t)v267);
                uint64_t v240 = v123;
                io_object_t v3 = v258;
                sub_100013D4C( "%s:%d: %s cib %lld chunk info %d xid %lld > cib xid %lld\n",  "nx_check",  392,  v122,  v91,  v118,  v240,  v124);
              }

              uint64_t v125 = *(v120 - 2);
              if (v119 != v125)
              {
                ++v269;
                sub_100013D4C( "%s:%d: %s cib %lld chunk info %d addr %lld should be %lld\n",  "nx_check",  396,  (const char *)(v3[48] + 208LL),  v91,  v118,  v125,  v119);
              }

              uint64_t v126 = *(_DWORD *)(v120 - 1) & 0xFFFFF;
              if ((_DWORD)v126 != (_DWORD)v17
                && (v91 != v89->i32[0] - 1 || v118 != *(_DWORD *)(v112 + 36) - 1 || *(void *)&v89[-2] % v17 != v126))
              {
                ++v269;
                sub_100013D4C("%s:%d: %s cib %lld chunk info %d block count %d should be %d\n");
                goto LABEL_209;
              }

              if ((*((_DWORD *)v120 - 1) & 0xFFFFFu) > v126)
              {
                ++v269;
                sub_100013D4C( "%s:%d: %s cib %lld chunk info %d free count %d > chunk block count %d\n",  "nx_check",  407,  (const char *)(v3[48] + 208LL),  v91,  v118,  *((_DWORD *)v120 - 1) & 0xFFFFF,  *(_DWORD *)(v120 - 1) & 0xFFFFF);
              }

              if (*v120)
              {
                int v127 = sub_100047D80((uint64_t)v3, (uint64_t)v271, *v120, v264);
                if (v127)
                {
                  ++v269;
                  if (v127 == 2) {
                    sub_100013D4C("%s:%d: %s cib %lld ci %d bm addr %lld not within IP block range\n");
                  }
                  else {
                    sub_100013D4C("%s:%d: %s error getting IP block index for cib %lld ci %d bm addr %lld\n");
                  }
                  goto LABEL_209;
                }

                if (sub_10003B574( v3[49],  0x40000000u,  *v120,  (int *)&xmmword_10005BA74,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v266))
                {
                  ++v269;
                  sub_100013D4C("%s:%d: %s cib %lld chunk %d unable to get bitmap block @ %lld: %d\n");
                  goto LABEL_209;
                }

                unint64_t v128 = sub_10001D7F0(v266[7], 0, 0LL, *(_DWORD *)(v120 - 1) & 0xFFFFF);
              }

              else
              {
                ++v257;
                unint64_t v128 = *(_DWORD *)(v120 - 1) & 0xFFFFFLL;
              }

              uint64_t v129 = *((_DWORD *)v120 - 1) & 0xFFFFF;
              if (v128 != v129)
              {
                ++v269;
                sub_100013D4C( "%s:%d: %s cib %lld ci %d free count %d doesn't match free bits in bitmap block %lld\n",  "nx_check",  429,  (const char *)(v3[48] + 208LL),  v91,  v118,  *((_DWORD *)v120 - 1) & 0xFFFFF,  v128);
                uint64_t v129 = *((_DWORD *)v120 - 1) & 0xFFFFF;
              }

              v260 += v128;
              v262 += v129;
              uint64_t v130 = *(void *)(v255 + 1248);
              if (v130)
              {
                uint64_t v131 = *(void *)(v255 + 1240);
                char v132 = __clz(__rbit64(*(unsigned int *)(v3[47] + 36LL)));
                if (v254 == ((v131 << v132) & 0x4000000000000000uLL) >> 62)
                {
                  v272[0] = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
                  unint64_t v133 = sub_100013C78( *(v120 - 2),  *(_DWORD *)(v120 - 1) & 0xFFFFF,  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v132) & v131,  v130,  (unint64_t *)v272);
                  if (v133)
                  {
                    if (*v120) {
                      unint64_t v133 = sub_10001D7F0( v266[7],  0,  (uint64_t)v272[0] - *(v120 - 2),  (uint64_t)v272[0] + v133 - *(v120 - 2));
                    }
                    v260 -= v133;
                    v262 -= v133;
                  }
                }
              }

              if (*v120) {
                sub_100038824(v266);
              }
LABEL_209:
              ++v118;
              LODWORD(v134) = *(_DWORD *)(v112 + 36);
              else {
                unint64_t v134 = v134;
              }
              v119 += v17;
              v120 += 4;
              if (v118 >= v134) {
                goto LABEL_215;
              }
              continue;
            }
          }

          ++v269;
          sub_100013D4C( "%s:%d: %s cab %d @ %lld cab_cib_count %d invalid\n",  "nx_check",  337,  (const char *)(v3[48] + 208LL),  v95,  v96,  *(_DWORD *)(v100 + 36));
          uint64_t v93 = v95;
          unint64_t v91 = v91 + v250 - 1 + ~((v91 + v250 - 1) % v250);
          uint64_t v83 = v254;
          unint64_t v75 = v252;
          uint64_t v84 = v100;
          unint64_t v85 = v250;
        }

LABEL_217:
        if (++v91 >= v89->u32[0]) {
          goto LABEL_220;
        }
      }
    }

    uint64_t v260 = 0LL;
    uint64_t v262 = 0LL;
LABEL_220:
    if (v268)
    {
      sub_100038824(v268);
      v268 = 0LL;
    }

    v70 = v246;
    v135 = &v246[6 * v83];
    uint32x2_t v138 = v135[9];
    v137 = v135 + 9;
    uint64_t v136 = (uint64_t)v138;
    uint64_t v139 = v262;
    if (v262 != *(void *)&v138)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free count %lld doesn't match free count in chunks %lld\n",  "nx_check",  469,  (const char *)(v3[48] + 208LL),  v136,  v262);
      uint64_t v139 = (uint64_t)*v137;
    }

    if (v260 != v139)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free count %lld doesn't match free count in bitmap %lld\n",  "nx_check",  472,  (const char *)(v3[48] + 208LL),  v139,  v260);
    }

    char v86 = 0;
    uint64_t v83 = 1LL;
  }

  while ((v245 & 1) != 0);
  if (v244 + v243 != v257 + v242)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman IP free block count is wrong %lld != %lld\n",  "nx_check",  477,  (const char *)(v3[48] + 208LL),  v244 + v243,  v257 + v242);
  }

  uint32x2_t v140 = v246[30];
  uint32x2_t v141 = v246[6];
  if (*(void *)&v140 > *(void *)&v141)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free queue count is too large: %lld > %lld\n",  "nx_check",  482,  (const char *)(v3[48] + 208LL),  *(void *)&v140,  *(void *)&v141);
  }

  if (!*(void *)&v246[31]) {
    goto LABEL_234;
  }
  int v142 = sub_100045974((uint64_t)v3, (uint64_t)v271, 1u, 0LL, 0, &v265[4]);
  if (v142)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s unable to get spaceman free queue tree: %d\n",  "nx_check",  490,  (const char *)(v3[48] + 208LL),  v142);
    goto LABEL_234;
  }

  if (v265[4])
  {
    int v153 = sub_10000FB54((void *)v265[4], 0LL, 0, 0);
    if (v153)
    {
      int v154 = v153;
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free queue tree sanity check failed: %d\n",  "nx_check",  494,  (const char *)(v3[48] + 208LL),  v153);
      v264[1] = 0x1000000008LL;
    }

    else
    {
      v264[1] = 0x1000000008LL;
      int v154 = sub_1000261E0(v265[4], 0LL, &v265[1], (_DWORD *)&v264[1] + 1, &v265[3], (unsigned int *)&v264[1]);
    }

    unint64_t v185 = 0LL;
    uint64_t v143 = 0LL;
    uint64_t v186 = 0LL;
    while (!v154)
    {
      if (LODWORD(v264[1]))
      {
        uint64_t v187 = v265[3];
      }

      else
      {
        v265[3] = 1LL;
        uint64_t v187 = 1LL;
      }

      unint64_t v188 = v265[1];
      if (v265[1] > v252)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n",  "nx_check",  507,  (const char *)(v3[48] + 208LL),  v265[1],  v265[2],  v252);
        unint64_t v188 = v265[1];
      }

      if (v188 >= v185)
      {
        if (v188 == v185)
        {
          uint64_t v189 = v265[2];
          if (v265[2] < v186)
          {
            ++v269;
            sub_100013D4C( "%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n",  "nx_check",  515,  (const char *)(v3[48] + 208LL),  v265[2],  v186);
            uint64_t v189 = v265[2];
          }

          uint64_t v186 = v265[3] + v189;
          goto LABEL_340;
        }
      }

      else
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n",  "nx_check",  510,  (const char *)(v3[48] + 208LL),  v188,  v185);
        unint64_t v188 = v265[1];
      }

      uint64_t v186 = 0LL;
      uint64_t v189 = v265[2];
      unint64_t v185 = v188;
LABEL_340:
      if (v189 < 1 || (unint64_t v190 = (unint64_t)v246[6], v189 >= v190))
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n",  "nx_check",  524,  (const char *)(v3[48] + 208LL),  v265[1],  v189,  v265[3]);
        unint64_t v190 = (unint64_t)v246[6];
        uint64_t v189 = v265[2];
      }

      BOOL v69 = v190 > v265[3];
      unint64_t v191 = v190 - v265[3];
      if (!v69 || v189 > v191)
      {
        ++v269;
        sub_100013D4C( "%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n",  "nx_check",  527,  (const char *)(v3[48] + 208LL),  v265[1],  v189,  v265[3]);
      }

      v143 += v187;
      LODWORD(v264[1]) = 8;
      int v154 = sub_100026464( v265[4],  0LL,  (unint64_t *)&v265[1],  (unsigned int *)&v264[1] + 1,  HIDWORD(v264[1]),  &v265[3],  (unsigned int *)&v264[1],  4u,  0,  0LL);
    }

    if (v154 != 2)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free queue tree iteration aborted with error %d\n",  "nx_check",  534,  (const char *)(v3[48] + 208LL),  v154);
    }

    sub_100038824((uint64_t *)v265[4]);
    v70 = v246;
  }

  else
  {
LABEL_234:
    uint64_t v143 = 0LL;
  }

  uint32x2_t v144 = v70[30];
  if (v143 != *(void *)&v144)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n",  "nx_check",  540,  (const char *)(v3[48] + 208LL),  *(void *)&v144,  v143);
  }

  uint32x2_t v145 = v70[35];
  uint32x2_t v146 = v70[12];
  if (*(void *)&v145 > *(void *)&v146)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free queue count is too large: %lld > %lld\n",  "nx_check",  544,  (const char *)(v3[48] + 208LL),  *(void *)&v145,  *(void *)&v146);
  }

  if (!*(void *)&v70[36]) {
    goto LABEL_242;
  }
  int v147 = sub_100045974((uint64_t)v3, (uint64_t)v271, 2u, 0LL, 0, &v265[4]);
  if (v147)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s unable to get spaceman free queue tree: %d\n",  "nx_check",  552,  (const char *)(v3[48] + 208LL),  v147);
LABEL_242:
    uint64_t v148 = 0LL;
    goto LABEL_243;
  }

  if (!v265[4]) {
    goto LABEL_242;
  }
  int v155 = sub_10000FB54((void *)v265[4], 0LL, 0, 0);
  if (v155)
  {
    int v156 = v155;
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free queue tree sanity check failed: %d\n",  "nx_check",  556,  (const char *)(v3[48] + 208LL),  v155);
    v264[1] = 0x1000000008LL;
  }

  else
  {
    v264[1] = 0x1000000008LL;
    int v156 = sub_1000261E0(v265[4], 0LL, &v265[1], (_DWORD *)&v264[1] + 1, &v265[3], (unsigned int *)&v264[1]);
  }

  unint64_t v192 = 0LL;
  uint64_t v148 = 0LL;
  for (uint64_t j = 0LL;
        !v156;
        int v156 = sub_100026464( v265[4],  0LL,  (unint64_t *)&v265[1],  (unsigned int *)&v264[1] + 1,  HIDWORD(v264[1]),  &v265[3],  (unsigned int *)&v264[1],  4u,  0,  0LL))
  {
    if (LODWORD(v264[1]))
    {
      uint64_t v194 = v265[3];
    }

    else
    {
      v265[3] = 1LL;
      uint64_t v194 = 1LL;
    }

    unint64_t v195 = v265[1];
    if (v265[1] > v252)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n",  "nx_check",  569,  (const char *)(v3[48] + 208LL),  v265[1],  v265[2],  v252);
      unint64_t v195 = v265[1];
    }

    if (v195 >= v192)
    {
      uint64_t v196 = v265[2];
      if (v195 == v192)
      {
        if (v265[2] < j)
        {
          ++v269;
          sub_100013D4C( "%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n",  "nx_check",  577,  (const char *)(v3[48] + 208LL),  v265[2],  j);
          uint64_t v196 = v265[2];
        }

        uint64_t j = v265[3] + v196;
      }

      else
      {
        uint64_t j = 0LL;
        unint64_t v192 = v195;
      }
    }

    else
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n",  "nx_check",  572,  (const char *)(v3[48] + 208LL),  v195,  v192);
      uint64_t j = 0LL;
      uint64_t v196 = v265[2];
      unint64_t v192 = v265[1];
    }

    uint64_t v197 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v3[47] + 36LL)))) & v196;
    if (v197 < 1 || (unint64_t v198 = (unint64_t)v246[12], v197 >= v198))
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n",  "nx_check",  587,  (const char *)(v3[48] + 208LL),  v265[1],  v196,  v265[3]);
      unint64_t v198 = (unint64_t)v246[12];
    }

    BOOL v69 = v198 > v265[3];
    unint64_t v199 = v198 - v265[3];
    if (!v69 || v197 > v199)
    {
      ++v269;
      sub_100013D4C( "%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n",  "nx_check",  590,  (const char *)(v3[48] + 208LL),  v265[1],  v265[2],  v265[3]);
    }

    v148 += v194;
    LODWORD(v264[1]) = 8;
  }

  if (v156 != 2)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free queue tree iteration aborted with error %d\n",  "nx_check",  597,  (const char *)(v3[48] + 208LL),  v156);
  }

  sub_100038824((uint64_t *)v265[4]);
  v70 = v246;
LABEL_243:
  uint32x2_t v149 = v70[35];
  if (v148 != *(void *)&v149)
  {
    ++v269;
    sub_100013D4C( "%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n",  "nx_check",  603,  (const char *)(v3[48] + 208LL),  *(void *)&v149,  v148);
  }

  if (*(void *)(v255 + 168))
  {
    uint64_t v150 = sub_100010F28(v3, &v270);
    if ((_DWORD)v150)
    {
      uint64_t v6 = v150;
      sub_100013D94("%s:%d: %s unable to get reaper: %d\n");
      goto LABEL_386;
    }

    uint64_t v157 = *((void *)v270 + 47);
    unint64_t v158 = *(void *)(v157 + 32);
    if (*(void *)(v157 + 40) >= v158)
    {
      sub_100013D4C( "%s:%d: %s reaper completed ID 0x%llx not less than next reap ID 0x%llx\n",  "nx_check_reaper",  958,  (const char *)(v3[48] + 208LL),  *(void *)(v157 + 40),  v158);
      int v159 = 1;
    }

    else
    {
      int v159 = 0;
    }

    int v160 = *(_DWORD *)(v157 + 64);
    if ((v160 & 1) == 0)
    {
      ++v159;
      sub_100013D4C( "%s:%d: %s reaper needs more cowbell, flags 0x%x\n",  "nx_check_reaper",  961,  (const char *)(v3[48] + 208LL),  v160);
    }

    unint64_t v161 = *(void *)(v157 + 48);
    if (!v161)
    {
      if (!*(void *)(v157 + 56)
        || (++v159,
            sub_100013D4C( "%s:%d: %s reaper has tail with no head\n",  "nx_check_reaper",  965,  (const char *)(v3[48] + 208LL)),  (unint64_t v161 = *(void *)(v157 + 48)) == 0))
      {
LABEL_378:
        v269 += v159;
        sub_100038824((uint64_t *)v270);
        goto LABEL_379;
      }
    }

    v272[0] = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
    int v162 = *(_DWORD *)(v157 + 68);
    while (1)
    {
      uint64_t v163 = sub_10003B574(v3[49], 0x80000000, v161, (int *)&xmmword_10005B7A0, 0LL, 0LL, 0LL, 0LL, (uint64_t *)v272);
      if ((_DWORD)v163)
      {
        uint64_t v6 = v163;
        sub_100013D94( "%s:%d: %s failed to get reap list head: %d\n",  "nx_check_reaper",  974,  (const char *)(v3[48] + 208LL),  v163);
        sub_100038824((uint64_t *)v270);
        sub_100013D94("%s:%d: %s reaper check failed with error: %d\n");
        goto LABEL_386;
      }

      uint64_t v164 = v272[0][47];
      int v165 = *(_DWORD *)(v164 + 44);
      if (v165 != (((unint64_t)sub_1000398C8((uint64_t)v272[0]) - 64) / 0x28))
      {
        ++v159;
        v166 = (const char *)(v258[48] + 208LL);
        int v167 = *(_DWORD *)(v164 + 44);
        unsigned int v168 = sub_1000398C8((uint64_t)v272[0]);
        sub_100013D4C( "%s:%d: %s reap list object 0x%llx max record count %u not expected value %u\n",  "nx_check_reaper",  981,  v166,  v161,  v167,  ((unint64_t)v168 - 64) / 0x28);
      }

      unsigned int v169 = *(_DWORD *)(v164 + 44);
      if (*(_DWORD *)(v164 + 48) <= v169)
      {
        io_object_t v3 = v258;
      }

      else
      {
        ++v159;
        io_object_t v3 = v258;
        sub_100013D4C( "%s:%d: %s reap list object 0x%llx record count %d larger than max %d\n",  "nx_check_reaper",  984,  (const char *)(v258[48] + 208LL),  v161,  *(_DWORD *)(v164 + 48),  v169);
      }

      unsigned int v170 = *(_DWORD *)(v164 + 52);
      if (v170 != -1)
      {
        unsigned int v171 = *(_DWORD *)(v164 + 44);
        if (v170 > v171)
        {
          ++v159;
          sub_100013D4C( "%s:%d: %s reap list object 0x%llx first index %u larger than max %u\n",  "nx_check_reaper",  987,  (const char *)(v3[48] + 208LL),  v161,  *(_DWORD *)(v164 + 52),  v171);
        }
      }

      unsigned int v172 = *(_DWORD *)(v164 + 56);
      if (v172 != -1)
      {
        unsigned int v173 = *(_DWORD *)(v164 + 44);
        if (v172 > v173)
        {
          ++v159;
          sub_100013D4C( "%s:%d: %s reap list object 0x%llx last index %u larger than max %u\n",  "nx_check_reaper",  990,  (const char *)(v3[48] + 208LL),  v161,  *(_DWORD *)(v164 + 52),  v173);
        }
      }

      unsigned int v174 = *(_DWORD *)(v164 + 60);
      if (v174 != -1)
      {
        unsigned int v175 = *(_DWORD *)(v164 + 44);
        if (v174 > v175)
        {
          ++v159;
          sub_100013D4C( "%s:%d: %s reap list object 0x%llx free index %u larger than max %u\n",  "nx_check_reaper",  993,  (const char *)(v3[48] + 208LL),  v161,  *(_DWORD *)(v164 + 60),  v175);
        }
      }

      unint64_t v176 = *(void *)(v164 + 32);
      uint64_t v177 = *(void *)(v157 + 56);
      if (!v176)
      {
        if (v177 == v161) {
          goto LABEL_287;
        }
        ++v159;
        sub_100013D4C( "%s:%d: %s last reap list object 0x%llx doesn't match tail 0x%llx\n",  "nx_check_reaper",  1002,  (const char *)(v3[48] + 208LL),  v161,  v177);
        uint64_t v177 = *(void *)(v157 + 56);
        unint64_t v176 = *(void *)(v164 + 32);
      }

      if (v177 == v161)
      {
        if (!v176)
        {
LABEL_287:
          unint64_t v161 = 0LL;
          goto LABEL_288;
        }

        ++v159;
        sub_100013D4C( "%s:%d: %s reap list tail 0x%llx is not last reap list object, next 0x%llx\n",  "nx_check_reaper",  1005,  (const char *)(v3[48] + 208LL),  v161,  v176);
        unint64_t v161 = *(void *)(v164 + 32);
      }

      else
      {
        unint64_t v161 = v176;
      }

LABEL_288:
      sub_100038824(v272[0]);
      if (*(_DWORD *)(v157 + 68))
      {
        --v162;
        if (v161 && !v162)
        {
          ++v159;
          sub_100013D4C("%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n");
          goto LABEL_378;
        }

        if (!v161 && v162)
        {
          ++v159;
          sub_100013D4C("%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n");
          goto LABEL_378;
        }
      }

      if (!v161) {
        goto LABEL_378;
      }
    }
  }

LABEL_379:
  unint64_t v200 = *(void *)(v255 + 160);
  if (v200)
  {
    uint64_t v201 = sub_10003B574(v3[49], 0x40000000u, v200, (int *)&xmmword_10005B9F8, 0LL, 0LL, 0LL, 0LL, v265);
    if ((_DWORD)v201)
    {
      uint64_t v6 = v201;
      sub_100013D94("%s:%d: %s unable to get omap: %d\n");
LABEL_386:
      sub_100038824(v271);
      return v6;
    }

    if (sub_100039664(v265[0]) > v252)
    {
      ++v269;
      uint64_t v202 = v3[48] + 208LL;
      uint64_t v203 = sub_100039664(v265[0]);
      v234 = (const char *)v202;
      io_object_t v3 = v258;
      sub_100013D4C("%s:%d: %s omap xid %lld > spaceman xid %lld\n", "nx_check", 633, v234, v203, v252);
    }

    uint64_t v6 = sub_10000A854((uint64_t)v3, v265[0], v252, &v269);
    sub_100038824((uint64_t *)v265[0]);
    if ((_DWORD)v6)
    {
      sub_100013D94("%s:%d: %s omap check failed with error: %d\n");
      goto LABEL_386;
    }
  }

  v272[0] = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  v263 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  if (*(_DWORD *)(v255 + 180))
  {
    for (unint64_t k = 0LL; k < *(unsigned int *)(v255 + 180); ++k)
    {
      unint64_t v205 = *(void *)(v255 + 184 + 8 * k);
      if (v205)
      {
        int v206 = sub_10003B574(v3[49], 0, v205, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, (uint64_t *)v272);
        if (v206)
        {
          sub_100013D94( "%s:%d: %s unable to get fs[%d] oid %lld, %d\n",  "nx_check",  654,  (const char *)(v3[48] + 208LL),  k,  v205,  v206);
        }

        else
        {
          v207 = v272[0];
          uint64_t v208 = v272[0][47];
          unint64_t v209 = *(void *)(v208 + 128);
          if (!v209) {
            goto LABEL_398;
          }
          int v210 = sub_10003B574( v3[49],  0x40000000u,  v209,  (int *)&xmmword_10005B9F8,  0LL,  (uint64_t)v272[0],  0LL,  0LL,  v265);
          if (v210)
          {
            sub_100013D94( "%s:%d: %s unable to get omap %lld: %d\n",  "nx_check",  661,  (const char *)v272[0] + 3992,  *(void *)(v272[0][47] + 128),  v210);
            goto LABEL_446;
          }

          int v211 = sub_10000A854((uint64_t)v272[0], v265[0], v252, &v269);
          sub_100038824((uint64_t *)v265[0]);
          v207 = v272[0];
          if (!v211)
          {
            uint64_t v208 = v272[0][47];
LABEL_398:
            if (*(void *)(v208 + 136))
            {
              if ((*(_BYTE *)(v208 + 264) & 1) != 0 || (v241 & 1) != 0)
              {
                v263 = 0LL;
                int v212 = sub_10002F52C((uint64_t)v207, 0LL, 0LL, &v263);
                if (v212)
                {
                  sub_100013D94( "%s:%d: %s unable to get fs root tree: %d\n",  "nx_check",  680,  (const char *)v272[0] + 3992,  v212);
                }

                else
                {
                  if (sub_100039664((uint64_t)v263) > v252)
                  {
                    ++v269;
                    v213 = v272[0] + 499;
                    uint64_t v214 = sub_100039664((uint64_t)v263);
                    v235 = (const char *)v213;
                    io_object_t v3 = v258;
                    sub_100013D4C( "%s:%d: %s fs root tree xid %lld > spaceman xid %lld\n",  "nx_check",  683,  v235,  v214,  v252);
                  }

                  int v215 = sub_10000FB54(v263, 0LL, 0, 0);
                  if (v215)
                  {
                    ++v269;
                    sub_100013D4C( "%s:%d: %s fs root tree sanity check failed: %d\n",  "nx_check",  688,  (const char *)v272[0] + 3992,  v215);
                  }
                }

                if (v263) {
                  sub_100038824(v263);
                }
              }

              else
              {
                sub_100013D94( "%s:%d: %s skipping check of fs[%d] oid %lld fs root tree because it's encrypted\n",  "nx_check",  675,  (const char *)v207 + 3992,  k,  v205);
              }
            }

            unint64_t v216 = *(void *)(v272[0][47] + 144);
            if (v216)
            {
              v263 = 0LL;
              int v217 = sub_10002F554((uint64_t)v272[0], v216, 0LL, &v263);
              if (v217)
              {
                sub_100013D94( "%s:%d: %s unable to get fs extentref tree: %d\n",  "nx_check",  700,  (const char *)v272[0] + 3992,  v217);
              }

              else
              {
                if (sub_100039664((uint64_t)v263) > v252)
                {
                  ++v269;
                  v218 = v272[0] + 499;
                  uint64_t v219 = sub_100039664((uint64_t)v263);
                  v236 = (const char *)v218;
                  io_object_t v3 = v258;
                  sub_100013D4C( "%s:%d: %s fs extentref tree xid %lld > spaceman xid %lld\n",  "nx_check",  703,  v236,  v219,  v252);
                }

                int v220 = sub_10000FB54(v263, 0LL, 0, 0);
                if (v220)
                {
                  ++v269;
                  sub_100013D4C( "%s:%d: %s fs extentref tree sanity check failed: %d\n",  "nx_check",  708,  (const char *)v272[0] + 3992,  v220);
                }
              }

              if (v263) {
                sub_100038824(v263);
              }
            }

            if (*(void *)(v272[0][47] + 152))
            {
              v263 = 0LL;
              int v221 = sub_10002F598((uint64_t)v272[0], 0LL, &v263);
              if (v221)
              {
                sub_100013D94( "%s:%d: %s unable to get fs snap meta tree: %d\n",  "nx_check",  719,  (const char *)v272[0] + 3992,  v221);
              }

              else
              {
                if (sub_100039664((uint64_t)v263) > v252)
                {
                  ++v269;
                  v222 = v272[0] + 499;
                  uint64_t v223 = sub_100039664((uint64_t)v263);
                  v237 = (const char *)v222;
                  io_object_t v3 = v258;
                  sub_100013D4C( "%s:%d: %s fs snap meta tree xid %lld > spaceman xid %lld\n",  "nx_check",  722,  v237,  v223,  v252);
                }

                int v224 = sub_10000FB54(v263, 0LL, 0, 0);
                if (v224)
                {
                  ++v269;
                  sub_100013D4C( "%s:%d: %s fs snap meta tree sanity check failed: %d\n",  "nx_check",  727,  (const char *)v272[0] + 3992,  v224);
                }
              }

              if (v263) {
                sub_100038824(v263);
              }
            }

            if (*(void *)(v272[0][47] + 1072))
            {
              v263 = 0LL;
              int v225 = sub_10002F660((uint64_t)v272[0], 0, 0LL, 0LL, &v263);
              if (v225)
              {
                sub_100013D94( "%s:%d: %s unable to get doc-id tree: %d\n",  "nx_check",  738,  (const char *)v272[0] + 3992,  v225);
              }

              else
              {
                if (sub_100039664((uint64_t)v263) > v252)
                {
                  ++v269;
                  v226 = v272[0] + 499;
                  uint64_t v227 = sub_100039664((uint64_t)v263);
                  v238 = (const char *)v226;
                  io_object_t v3 = v258;
                  sub_100013D4C( "%s:%d: %s doc-id tree xid %lld > spaceman xid %lld\n",  "nx_check",  741,  v238,  v227,  v252);
                }

                int v228 = sub_10000FB54(v263, 0LL, 0, 0);
                if (v228)
                {
                  ++v269;
                  sub_100013D4C( "%s:%d: %s doc-id tree sanity check failed: %d\n",  "nx_check",  746,  (const char *)v272[0] + 3992,  v228);
                }
              }

              if (v263) {
                sub_100038824(v263);
              }
            }

            if (*(void *)(v272[0][47] + 1080))
            {
              v263 = 0LL;
              int v229 = sub_10002F660((uint64_t)v272[0], 1, 0LL, 0LL, &v263);
              if (v229)
              {
                sub_100013D94( "%s:%d: %s unable to get prev doc-id tree: %d\n",  "nx_check",  757,  (const char *)v272[0] + 3992,  v229);
              }

              else
              {
                if (sub_100039664((uint64_t)v263) > v252)
                {
                  ++v269;
                  v230 = v272[0] + 499;
                  uint64_t v231 = sub_100039664((uint64_t)v263);
                  v239 = (const char *)v230;
                  io_object_t v3 = v258;
                  sub_100013D4C( "%s:%d: %s prev doc-id tree xid %lld > spaceman xid %lld\n",  "nx_check",  760,  v239,  v231,  v252);
                }

                int v232 = sub_10000FB54(v263, 0LL, 0, 0);
                if (v232)
                {
                  ++v269;
                  sub_100013D4C( "%s:%d: %s prev doc-id tree sanity check failed: %d\n",  "nx_check",  765,  (const char *)v272[0] + 3992,  v232);
                }
              }

              if (v263) {
                sub_100038824(v263);
              }
            }

LABEL_446:
            sub_100038824(v272[0]);
            continue;
          }

          sub_100013D94( "%s:%d: %s omap check failed for omap %lld: %d\n",  "nx_check",  668,  (const char *)v272[0] + 3992,  *(void *)(v272[0][47] + 128),  v211);
          sub_100038824(v272[0]);
        }
      }
    }
  }

  sub_100038824(v271);
  if (v269) {
    return 22LL;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10000A854(uint64_t a1, uint64_t a2, unint64_t a3, int *a4)
{
  uint32x2_t v50 = 0LL;
  __int32 v8 = (void *)a1;
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v49 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v47[2] = v9;
  v47[3] = v9;
  v47[0] = v9;
  v47[1] = v9;
  uint64_t v10 = v8[47];
  unsigned int v11 = *(_DWORD *)(v10 + 36);
  if ((*(_BYTE *)(v10 + 65) & 1) != 0)
  {
    uint64_t v12 = sub_100044238(v8, (uint64_t *)&v50);
    if ((_DWORD)v12)
    {
      uint64_t v13 = v12;
      else {
        __int32 v14 = (const char *)(*(void *)(a1 + 384) + 208LL);
      }
      sub_100013D94("%s:%d: %s unable to get spaceman: %d\n", "nx_check_omap", 805, v14, v13);
      return v13;
    }
  }

  if (*(_DWORD *)(*(void *)(a2 + 376) + 36LL) >= 0x400u)
  {
    else {
      unint64_t v15 = (const char *)(*(void *)(a1 + 384) + 208LL);
    }
    sub_100013D4C( "%s:%d: %s omap snapshot count %d seems excessive\n",  "nx_check_omap",  811,  v15,  *(_DWORD *)(*(void *)(a2 + 376) + 36LL));
  }

  uint64_t v16 = *(void *)(a2 + 376);
  int v17 = *(_DWORD *)(v16 + 40);
  if (v17 == 1073741826 || v17 == -2147483646)
  {
    unint64_t v19 = *(void *)(v16 + 48);
    __int128 v52 = 0u;
    uint64_t v57 = 0LL;
    __int128 v56 = 0u;
    __int128 v55 = 0u;
    __int128 v54 = 0u;
    __int128 v53 = 0u;
    uint32x2_t v51 = sub_10003F28C;
    DWORD2(v52) = 11;
    if ((unsigned __int16)v17 == 2)
    {
      uint64_t v13 = sub_100027CC4(a1, v17 & 0xFFFF0000, v19, 0LL, 0, (uint64_t)&v51, 0LL, &v49);
      if (!(_DWORD)v13)
      {
        if (sub_100039664((uint64_t)v49) <= a3)
        {
          int v25 = 0;
        }

        else
        {
          else {
            uint64_t v20 = (const char *)(*(void *)(a1 + 384) + 208LL);
          }
          uint64_t v26 = sub_100039664((uint64_t)v49);
          sub_100013D4C("%s:%d: %s omap tree xid %lld > spaceman xid %lld\n", "nx_check_omap", 829, v20, v26, a3);
          int v25 = 1;
        }

        int v27 = sub_10000FB54(v49, 0LL, 0, 0);
        if (v27)
        {
          int v28 = v27;
          ++v25;
          else {
            uint32x2_t v29 = (const char *)(*(void *)(a1 + 384) + 208LL);
          }
          sub_100013D4C("%s:%d: %s omap tree sanity check failed: %d\n", "nx_check_omap", 834, v29, v28);
          goto LABEL_92;
        }

        unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
        uint32x2_t v51 = 0LL;
        *(void *)&__int128 v52 = 0LL;
        sub_100026D8C((uint64_t)v47, (uint64_t)v49, 0LL, 0, (unint64_t *)&v51, 16, 0x10u, &v45, 0x10u, 0LL);
        if (sub_100026EFC((uint64_t)v47))
        {
LABEL_92:
          sub_100038824(v49);
          goto LABEL_93;
        }

        uint32x2_t v30 = 0LL;
        *(_DWORD *)&v43[8] = 0;
        unsigned int v44 = (const char *)(a1 + 3992);
        *(void *)uint64_t v43 = v11 - 1;
        uint64_t v31 = -1LL;
        while (1)
        {
          if ((unint64_t)v51 >= (unint64_t)v30)
          {
            unint64_t v32 = v52;
            if (v51 != v30)
            {
              *(void *)&v43[4] = 0LL;
              uint64_t v31 = -1LL;
              uint32x2_t v30 = v51;
              goto LABEL_53;
            }

            if ((unint64_t)v52 <= *(void *)&v43[4])
            {
              ++v25;
              if (sub_100037DC8(a1) == 13) {
                sub_100013D4C( "%s:%d: %s omap tree entries out of order: oid %lld xid %lld <= lastxid %lld\n",  "nx_check_omap",  853,  v44,  v51,  (void)v52,  *(void *)&v43[4]);
              }
              else {
                sub_100013D4C( "%s:%d: %s omap tree entries out of order: oid %lld xid %lld <= lastxid %lld\n",  "nx_check_omap",  853,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52,  *(void *)&v43[4]);
              }
            }
          }

          else
          {
            if (sub_100037DC8(a1) == 13) {
              sub_100013D4C( "%s:%d: %s omap tree entries out of order: oid %lld < %lld\n",  "nx_check_omap",  847,  v44,  v51,  v30);
            }
            else {
              sub_100013D4C( "%s:%d: %s omap tree entries out of order: oid %lld < %lld\n",  "nx_check_omap",  847,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  v30);
            }
            ++v25;
            uint64_t v31 = -1LL;
            uint32x2_t v30 = v51;
          }

          unint64_t v32 = v52;
          *(void *)&v43[4] = v52;
LABEL_53:
          if (v32 > a3)
          {
            ++v25;
            if (sub_100037DC8(a1) == 13) {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld xid > spaceman xid %lld\n",  "nx_check_omap",  862,  v44,  v51,  (void)v52,  a3);
            }
            else {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld xid > spaceman xid %lld\n",  "nx_check_omap",  862,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52,  a3);
            }
          }

          if (v45 >= 0x800)
          {
            ++v25;
            if (sub_100037DC8(a1) == 13) {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld unknown flags are set: 0x%x\n",  "nx_check_omap",  865,  v44,  v51,  (void)v52,  v45 & 0xFFFFFFFE);
            }
            else {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld unknown flags are set: 0x%x\n",  "nx_check_omap",  865,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52,  v45 & 0xFFFFFFFE);
            }
          }

          if ((v45 & 1) != 0 && v31 == -1)
          {
            ++v25;
            if (sub_100037DC8(a1) == 13) {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld marks deletion of object with no earlier mappings\n",  "nx_check_omap",  868,  v44,  v51,  (void)v52);
            }
            else {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld marks deletion of object with no earlier mappings\n",  "nx_check_omap",  868,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52);
            }
          }

          else if (v31 != -1)
          {
            if (v31)
            {
              ++v25;
              if (sub_100037DC8(a1) == 13) {
                sub_100013D4C( "%s:%d: %s omap entry %lld:%lld beyond deletion entry @ xid %lld\n",  "nx_check_omap",  873,  v44,  v51,  (void)v52,  v31);
              }
              else {
                sub_100013D4C( "%s:%d: %s omap entry %lld:%lld beyond deletion entry @ xid %lld\n",  "nx_check_omap",  873,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52,  v31);
              }
            }

            else if ((v45 & 1) != 0)
            {
              uint64_t v31 = v52;
            }

            else
            {
              uint64_t v31 = 0LL;
            }

            goto LABEL_77;
          }

          if ((v45 & 1) != 0) {
            uint64_t v31 = v52;
          }
          else {
            uint64_t v31 = 0LL;
          }
LABEL_77:
          if (HIDWORD(v45) >= 0x100000)
          {
            ++v25;
            if (sub_100037DC8(a1) == 13) {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld size %d seems excessive\n",  "nx_check_omap",  878,  v44,  v51,  (void)v52,  HIDWORD(v45));
            }
            else {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld size %d seems excessive\n",  "nx_check_omap",  878,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52,  HIDWORD(v45));
            }
          }

          if (v50) {
            uint64_t v33 = v50[47];
          }
          else {
            uint64_t v33 = 0LL;
          }
          if (sub_1000052C0(v8[47], v33, v46, (*(_DWORD *)v43 + HIDWORD(v45)) / v11, 0))
          {
            ++v25;
            if (sub_100037DC8(a1) == 13) {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld addr %lld size %d is bad\n",  "nx_check_omap",  883,  v44,  v51,  (void)v52,  v46,  HIDWORD(v45));
            }
            else {
              sub_100013D4C( "%s:%d: %s omap entry %lld:%lld addr %lld size %d is bad\n",  "nx_check_omap",  883,  (const char *)(*(void *)(a1 + 384) + 208LL),  v51,  (void)v52,  v46,  HIDWORD(v45));
            }
          }

          sub_100026F18((uint64_t)v47);
        }
      }
    }

    else
    {
      uint64_t v13 = 22LL;
    }

    else {
      uint64_t v23 = (const char *)(*(void *)(a1 + 384) + 208LL);
    }
    sub_100013D4C("%s:%d: %s unable to get omap tree: %d\n", "nx_check_omap", 821, v23, v13);
    int v24 = *a4 + 1;
    goto LABEL_106;
  }

  int v21 = sub_100037DC8(a1);
  if (v21 == 13) {
    uint64_t v22 = (const char *)(a1 + 3992);
  }
  else {
    uint64_t v22 = (const char *)(*(void *)(a1 + 384) + 208LL);
  }
  sub_100013D4C( "%s:%d: %s omap tree type 0x%x is bad\n",  "nx_check_omap",  893,  v22,  *(_DWORD *)(*(void *)(a2 + 376) + 40LL));
  int v25 = 1;
LABEL_93:
  uint64_t v34 = *(void *)(a2 + 376);
  unint64_t v35 = *(void *)(v34 + 56);
  if (!v35)
  {
LABEL_120:
    *a4 += v25;
    if (v50) {
      sub_100038824(v50);
    }
    return 0LL;
  }

  int v36 = *(_DWORD *)(v34 + 44);
  if (v36 != 1073741826 && v36 != -2147483646)
  {
    ++v25;
    else {
      __int32 v38 = (const char *)(*(void *)(a1 + 384) + 208LL);
    }
    sub_100013D4C( "%s:%d: %s omap snapshot tree type 0x%x is bad\n",  "nx_check_omap",  935,  v38,  *(_DWORD *)(*(void *)(a2 + 376) + 40LL));
    goto LABEL_120;
  }

  __int128 v52 = 0u;
  uint64_t v57 = 0LL;
  __int128 v56 = 0u;
  __int128 v55 = 0u;
  __int128 v54 = 0u;
  __int128 v53 = 0u;
  uint32x2_t v51 = sub_10003F2E8;
  DWORD2(v52) = 19;
  uint64_t v13 = sub_100027CC4(a1, v36 & 0xFFFF0000, v35, 0LL, 0, (uint64_t)&v51, 0LL, &v49);
  if (!(_DWORD)v13)
  {
    if (sub_100039664((uint64_t)v49) > a3)
    {
      ++v25;
      else {
        unsigned int v37 = (const char *)(*(void *)(a1 + 384) + 208LL);
      }
      uint64_t v40 = sub_100039664((uint64_t)v49);
      sub_100013D4C("%s:%d: %s omap snapshot tree xid %lld > spaceman xid %lld\n", "nx_check_omap", 911, v37, v40, a3);
    }

    if (sub_10000FB54(v49, 0LL, 0, 0))
    {
      ++v25;
      sub_100037DC8(a1);
      sub_100013D4C("%s:%d: %s omap snapshot tree sanity check failed: %d\n");
    }

    else
    {
      uint32x2_t v51 = (uint64_t (*)(uint64_t, void *, int, void *, int, int *))0xAAAAAAAAAAAAAAAALL;
      *(void *)&__int128 v52 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v45 = 0LL;
      sub_100026D8C((uint64_t)v47, (uint64_t)v49, 0LL, 0, &v45, 8, 8u, &v51, 0x10u, 0LL);
      uint64_t v41 = 0LL;
      if (!sub_100026EFC((uint64_t)v47))
      {
        uint64_t v41 = 0LL;
        do
        {
          ++v41;
          sub_100026F18((uint64_t)v47);
        }

        while (!sub_100026EFC((uint64_t)v47));
      }

      if (v41 != *(_DWORD *)(*(void *)(a2 + 376) + 36LL))
      {
        ++v25;
        sub_100037DC8(a1);
        sub_100013D4C("%s:%d: %s omap snapshot count %d doesn't match snapshot tree record count %lld\n");
      }
    }

    sub_100038824(v49);
    goto LABEL_120;
  }

  else {
    uint32x2_t v39 = (const char *)(*(void *)(a1 + 384) + 208LL);
  }
  sub_100013D4C("%s:%d: %s unable to get omap snapshot tree: %d\n", "nx_check_omap", 903, v39, v13);
  int v24 = v25 + 1 + *a4;
LABEL_106:
  *a4 = v24;
  if (v50) {
    sub_100038824(v50);
  }
  return v13;
}

uint64_t sub_10000B334( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, int a5, _DWORD *a6, int a7)
{
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  int v13 = sub_100037DC8(a1);
  uint64_t v14 = 0LL;
  uint64_t v15 = a1;
  if (v13 == 13)
  {
    uint64_t v15 = *(void *)(a1 + 392);
    uint64_t v14 = a1;
  }

  uint64_t v16 = 22LL;
  if (a5 == 16 && a7 == 16)
  {
    unint64_t v17 = a4[1];
    if (v17 <= a3) {
      return 0LL;
    }
    int v18 = *a6;
    if ((*a6 & 5) != 0)
    {
      return 0LL;
    }

    else
    {
      uint64_t v23 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      if ((v18 & 8) != 0) {
        unsigned int v20 = 536870936;
      }
      else {
        unsigned int v20 = 24;
      }
      LODWORD(v22) = a6[1];
      uint64_t v16 = sub_10003B574(*(void *)(v15 + 392), v20, *a4, (int *)&v21, 0LL, v14, v17, 0LL, (uint64_t *)&v23);
      if ((_DWORD)v16)
      {
        if (sub_100037DC8(a1) == 13) {
          sub_100013D94( "%s:%d: %s check of oid:xid %lld:%lld  size %d paddr 0x%llx flags 0x%x failed: %d\n",  "omap_recent_sanity_callback",  1089,  (const char *)(a1 + 3992),  *a4,  a4[1],  a6[1],  *((void *)a6 + 1),  *a6,  v16);
        }
        else {
          sub_100013D94( "%s:%d: %s check of oid:xid %lld:%lld  size %d paddr 0x%llx flags 0x%x failed: %d\n",  "omap_recent_sanity_callback",  1089,  (const char *)(*(void *)(a1 + 384) + 208LL),  *a4,  a4[1],  a6[1],  *((void *)a6 + 1),  *a6,  v16);
        }
      }

      else
      {
        sub_100038824(v23);
      }
    }
  }

  return v16;
}

uint64_t sub_10000B4A8(void *a1)
{
  unsigned int v47 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = sub_100044238(a1, &v48[2]);
  if ((_DWORD)v2)
  {
    uint64_t v3 = v2;
    sub_100013D94("%s:%d: %s unable to get spaceman: %d\n");
    return v3;
  }

  uint64_t v4 = *(void *)(v48[2] + 376);
  unint64_t v5 = sub_100039664(v48[2]);
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  unint64_t v8 = v5 - 3;
  if (v5 < 3) {
    unint64_t v8 = 0LL;
  }
  unint64_t v44 = v8;
  memset(v45, 170, sizeof(v45));
  uint64_t v46 = 0LL;
  do
  {
    uint64_t v9 = v4 + 48 * v6;
    int v11 = *(_DWORD *)(v9 + 64);
    uint64_t v10 = (unsigned int *)(v9 + 64);
    if (!v11)
    {
      uint64_t v3 = 0LL;
      goto LABEL_30;
    }

    unint64_t v12 = 0LL;
    LODWORD(v13) = -1;
    while (1)
    {
      if (!*(_DWORD *)(v4 + 48 * v6 + 68))
      {
        int v18 = (unint64_t *)(*(void *)(v48[2] + 8 * v6 + 888) + 8 * v12);
        goto LABEL_22;
      }

      unint64_t v14 = *(unsigned int *)(v4 + 44);
LABEL_20:
      int v18 = (unint64_t *)(v7 + 8 * (v12 - (v14 * v13)) + 40);
LABEL_22:
      unint64_t v19 = *v18;
      v45[0] = v4;
      v45[1] = __PAIR64__(v12, v6);
      uint64_t v20 = sub_10003B574(a1[49], 0x40000000u, v19, (int *)&xmmword_10005BA64, v45, 0LL, 0LL, 0LL, &v45[4]);
      if ((_DWORD)v20)
      {
        uint64_t v22 = v20;
        sub_100013D94( "%s:%d: %s unable to read cib %lld @ %lld: %d\n",  "nx_check_recent_sanity",  1170,  (const char *)(a1[48] + 208LL),  v12,  v19,  v20);
        uint64_t v3 = v22;
        goto LABEL_30;
      }

      sub_100038824((uint64_t *)v45[4]);
      uint64_t v21 = 1LL;
LABEL_24:
      v12 += v21;
      if (v12 >= *v10)
      {
        uint64_t v3 = 0LL;
        goto LABEL_30;
      }
    }

    unint64_t v13 = v12 / v14;
    unint64_t v16 = *(void *)(*(void *)(v48[2] + 8 * v6 + 888) + 8LL * (v12 / v14));
    if (v46)
    {
      sub_100038824(v46);
      uint64_t v46 = 0LL;
    }

    v45[2] = v4;
    v45[3] = __PAIR64__(v13, v6);
    uint64_t v17 = sub_10003B574(a1[49], 0x40000000u, v16, (int *)&xmmword_10005BA54, &v45[2], 0LL, 0LL, 0LL, (uint64_t *)&v46);
    if (!(_DWORD)v17)
    {
      uint64_t v7 = v46[7];
      if (sub_100039664((uint64_t)v46) <= v44)
      {
        uint64_t v21 = *(unsigned int *)(v7 + 36);
        goto LABEL_24;
      }

      LODWORD(v14) = *(_DWORD *)(v4 + 44);
      goto LABEL_20;
    }

    uint64_t v3 = v17;
    sub_100013D94( "%s:%d: %s unable to read cab %d @ %lld: %d\n",  "nx_check_recent_sanity",  1143,  (const char *)(a1[48] + 208LL),  v13,  v16,  v17);
LABEL_30:
    if (v46)
    {
      sub_100038824(v46);
      uint64_t v46 = 0LL;
    }
  }

  while (!(v3 | v6++));
  sub_100038824((uint64_t *)v48[2]);
  if ((_DWORD)v3) {
    return v3;
  }
  unint64_t v25 = *(void *)(a1[47] + 160LL);
  if (v25)
  {
    uint64_t v26 = sub_10003B574(a1[49], 0x40000000u, v25, (int *)&xmmword_10005B9F8, 0LL, 0LL, 0LL, 0LL, &v48[1]);
    if ((_DWORD)v26)
    {
      uint64_t v3 = v26;
      sub_100013D94("%s:%d: %s unable to get omap: %d\n");
      return v3;
    }

    if (sub_100039664(v48[1]) <= v44)
    {
      sub_100038824((uint64_t *)v48[1]);
    }

    else
    {
      uint64_t v3 = sub_10000BBAC((uint64_t)a1, v48[1], v44);
      sub_100038824((uint64_t *)v48[1]);
      if ((_DWORD)v3)
      {
        sub_100013D94("%s:%d: %s omap check failed with error: %d\n");
        return v3;
      }
    }
  }

  uint64_t v27 = a1[47];
  if (!*(_DWORD *)(v27 + 180)) {
    return 0LL;
  }
  unint64_t v28 = 0LL;
  while (2)
  {
    unint64_t v29 = *(void *)(v27 + 8 * v28 + 184);
    if (!v29) {
      goto LABEL_75;
    }
    uint64_t v30 = sub_10003B574(a1[49], 0, v29, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, v48);
    if ((_DWORD)v30)
    {
      uint64_t v42 = v30;
      sub_100013D94( "%s:%d: %s unable to get fs[%d] oid %lld, %d\n",  "nx_check_recent_sanity",  1212,  (const char *)(a1[48] + 208LL),  v28,  v29,  v30);
      return v42;
    }

    unint64_t v31 = sub_100039664(v48[0]);
    unint64_t v32 = (uint64_t *)v48[0];
    if (v31 <= v44) {
      goto LABEL_74;
    }
    unint64_t v33 = *(void *)(*(void *)(v48[0] + 376) + 128LL);
    if (!v33) {
      goto LABEL_53;
    }
    uint64_t v34 = sub_10003B574(a1[49], 0x40000000u, v33, (int *)&xmmword_10005B9F8, 0LL, v48[0], 0LL, 0LL, &v48[1]);
    if (!(_DWORD)v34)
    {
      if (sub_100039664(v48[1]) <= v44)
      {
        sub_100038824((uint64_t *)v48[1]);
        unint64_t v32 = (uint64_t *)v48[0];
      }

      else
      {
        uint64_t v35 = sub_10000BBAC(v48[0], v48[1], v44);
        sub_100038824((uint64_t *)v48[1]);
        unint64_t v32 = (uint64_t *)v48[0];
        if ((_DWORD)v35)
        {
          sub_100013D94("%s:%d: %s omap check failed for omap %lld: %d\n");
          goto LABEL_80;
        }
      }

LABEL_53:
      uint64_t v36 = v32[47];
      unint64_t v37 = *(void *)(v36 + 144);
      if (v37)
      {
        unsigned int v47 = 0LL;
        uint64_t v38 = sub_10002F554((uint64_t)v32, v37, 0LL, (uint64_t **)&v47);
        if ((_DWORD)v38)
        {
          uint64_t v35 = v38;
          sub_100013D94( "%s:%d: %s unable to get extentref tree %lld: %d\n",  "nx_check_recent_sanity",  1246,  (const char *)(v48[0] + 3992),  *(void *)(*(void *)(v48[0] + 376) + 144LL),  v38);
        }

        else if (sub_100039664((uint64_t)v47) <= v44)
        {
          uint64_t v35 = 0LL;
        }

        else
        {
          uint64_t v39 = sub_10000FB6C(v47, v44, 0LL, 0LL);
          uint64_t v35 = v39;
          if ((_DWORD)v39) {
            sub_100013D94( "%s:%d: %s extentref tree %lld: %d\n",  "nx_check_recent_sanity",  1251,  (const char *)(v48[0] + 3992),  *(void *)(*(void *)(v48[0] + 376) + 144LL),  v39);
          }
        }

        if (v47) {
          sub_100038824((uint64_t *)v47);
        }
        unint64_t v32 = (uint64_t *)v48[0];
        if ((_DWORD)v35)
        {
LABEL_78:
          uint64_t v43 = v32;
          goto LABEL_81;
        }

        uint64_t v36 = *(void *)(v48[0] + 376);
      }

      if (*(void *)(v36 + 152))
      {
        unsigned int v47 = 0LL;
        uint64_t v40 = sub_10002F598((uint64_t)v32, 0LL, (uint64_t **)&v47);
        if ((_DWORD)v40)
        {
          uint64_t v35 = v40;
          sub_100013D94( "%s:%d: %s unable to get snap meta tree %lld: %d\n",  "nx_check_recent_sanity",  1268,  (const char *)(v48[0] + 3992),  *(void *)(*(void *)(v48[0] + 376) + 152LL),  v40);
        }

        else if (sub_100039664((uint64_t)v47) <= v44)
        {
          uint64_t v35 = 0LL;
        }

        else
        {
          uint64_t v41 = sub_10000FB6C(v47, v44, 0LL, 0LL);
          uint64_t v35 = v41;
          if ((_DWORD)v41) {
            sub_100013D94( "%s:%d: %s snap meta tree %lld: %d\n",  "nx_check_recent_sanity",  1273,  (const char *)(v48[0] + 3992),  *(void *)(*(void *)(v48[0] + 376) + 144LL),  v41);
          }
        }

        if (v47) {
          sub_100038824((uint64_t *)v47);
        }
        unint64_t v32 = (uint64_t *)v48[0];
        if ((_DWORD)v35) {
          goto LABEL_78;
        }
      }

LABEL_74:
      sub_100038824(v32);
LABEL_75:
      ++v28;
      uint64_t v27 = a1[47];
      continue;
    }

    break;
  }

  uint64_t v35 = v34;
  sub_100013D94("%s:%d: %s unable to get omap %lld: %d\n");
LABEL_80:
  uint64_t v43 = (uint64_t *)v48[0];
LABEL_81:
  sub_100038824(v43);
  return v35;
}

uint64_t sub_10000BBAC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v14 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = *(void *)(a2 + 376);
  unint64_t v7 = *(void *)(v6 + 48);
  if (!v7) {
    goto LABEL_10;
  }
  int v8 = *(_DWORD *)(v6 + 40);
  __int128 v16 = 0u;
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  uint64_t v15 = sub_10003F28C;
  DWORD2(v16) = 11;
  if ((unsigned __int16)v8 != 2)
  {
    uint64_t v9 = 22LL;
    goto LABEL_8;
  }

  uint64_t v9 = sub_100027CC4(a1, v8 & 0xFFFF0000, v7, 0LL, 0, (uint64_t)&v15, 0LL, &v14);
  if ((_DWORD)v9)
  {
LABEL_8:
    sub_100037DC8(a1);
    sub_100013D94("%s:%d: %s unable to get omap tree: %d\n");
    return v9;
  }

  if (sub_100039664((uint64_t)v14) <= a3)
  {
    sub_100038824(v14);
  }

  else
  {
    uint64_t v9 = sub_10000FB6C( (char *)v14,  a3,  (uint64_t (*)(uint64_t, uint64_t, unint64_t, unint64_t, void, uint64_t, void))sub_10000B334,  0LL);
    sub_100038824(v14);
    if ((_DWORD)v9) {
      return v9;
    }
  }

LABEL_10:
  uint64_t v10 = *(void *)(a2 + 376);
  unint64_t v11 = *(void *)(v10 + 56);
  if (!v11) {
    return 0LL;
  }
  int v12 = *(_DWORD *)(v10 + 44);
  __int128 v16 = 0u;
  uint64_t v21 = 0LL;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  uint64_t v15 = sub_10003F2E8;
  DWORD2(v16) = 19;
  if ((unsigned __int16)v12 != 2)
  {
    uint64_t v9 = 22LL;
    goto LABEL_17;
  }

  uint64_t v9 = sub_100027CC4(a1, v12 & 0xFFFF0000, v11, 0LL, 0, (uint64_t)&v15, 0LL, &v14);
  if ((_DWORD)v9)
  {
LABEL_17:
    sub_100037DC8(a1);
    sub_100013D94("%s:%d: %s unable to get omap snapshot tree: %d\n");
    return v9;
  }

  else {
    uint64_t v9 = sub_10000FB6C((char *)v14, a3, 0LL, 0LL);
  }
  sub_100038824(v14);
  return v9;
}

    sub_10003D514((uint64_t)v8, 2);
    sub_100038824((uint64_t *)v8);
  }

  return v4;
}

uint64_t sub_10000BE18(void *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  unint64_t v5 = (unsigned __int16 *)a1[7];
  *a2 = (a1[50] >> 27) & 0x1F000;
  LODWORD(v5) = v5[25] + v5[23] + v5[27];
  *a3 = (_DWORD)v5;
  BOOL v6 = *a2 >= v5;
  int v7 = *a2 - (_DWORD)v5;
  if (v6)
  {
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t v11 = a1[1];
    if (v11) {
      int v12 = (const char *)(v11 + 3992);
    }
    else {
      int v12 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v14 = sub_10003965C((uint64_t)a1);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): freespace %u larger than nodespace %u\n",  "btree_node_space_stats",  52,  v12,  v14,  *(unsigned __int16 *)(a1[7] + 34LL),  *a3,  *a2);
    int v7 = 0;
    uint64_t result = 22LL;
  }

  *a4 = v7;
  return result;
}

uint64_t sub_10000BF04(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = a2[7];
  if ((*(_WORD *)(v7 + 32) & 2) != 0)
  {
    ++*(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 16) += *(_DWORD *)(v7 + 36);
  }

  else
  {
    ++*(_DWORD *)a4;
    *(_DWORD *)(a4 + 12) += *(_DWORD *)(v7 + 36);
  }

  if (*(_DWORD *)(a4 + 8) < a3) {
    *(_DWORD *)(a4 + 8) = a3;
  }
  unint64_t v8 = *(unsigned __int16 *)(v7 + 34);
  if (v8 <= 0xF) {
    ++*(_DWORD *)(a4 + 4 * v8 + 216);
  }
  uint64_t v9 = sub_10001DB34(a2, 0LL);
  if (!(_DWORD)v9)
  {
    unsigned int v33 = -1431655766;
    unsigned int v31 = -1431655766;
    int v32 = -1431655766;
    uint64_t v9 = sub_10000BE18(a2, &v33, &v32, (int *)&v31);
    uint64_t v10 = v31;
    uint64_t v11 = v33;
    uint64_t v12 = 5 * v31 / v33;
    ++*(_DWORD *)(a4 + 4LL * v12 + 20);
    uint64_t v13 = *(void *)(a4 + 56) + v10;
    *(void *)(a4 + 48) += v11;
    *(void *)(a4 + 56) = v13;
    if ((*(_BYTE *)(a2[7] + 32LL) & 2) != 0)
    {
      ++*(_DWORD *)(a4 + 4 * v12 + 104);
      uint64_t v15 = *(void *)(a4 + 136);
      *(void *)(a4 + 128) += v11;
      *(void *)(a4 + 136) = v15 + v10;
      if (*(_DWORD *)(v7 + 36))
      {
        unsigned int v16 = 0;
        do
        {
          unsigned int v17 = sub_10001E588((uint64_t)a2, (unsigned __int16)v16);
          unsigned int v18 = sub_10001E5DC((uint64_t)a2, (unsigned __int16)v16);
          uint64_t v19 = *(void *)(a1 + 392);
          if (*(_DWORD *)(v19 + 16) < v17)
          {
            if ((_DWORD)v9) {
              uint64_t v9 = v9;
            }
            else {
              uint64_t v9 = 22LL;
            }
            uint64_t v20 = a2[1];
            if (v20) {
              uint64_t v21 = (const char *)(v20 + 3992);
            }
            else {
              uint64_t v21 = (const char *)(*(void *)(*(void *)(*a2 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v22 = sub_10003965C((uint64_t)a2);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): index %d key length %d longer than tree longest %d\n",  "btree_node_debug_stats",  110,  v21,  v22,  *(unsigned __int16 *)(a2[7] + 34LL),  v16,  v17,  *(_DWORD *)(*(void *)(a1 + 392) + 16LL));
            uint64_t v19 = *(void *)(a1 + 392);
            unsigned int v17 = *(unsigned __int16 *)(v19 + 16);
          }

          if (v18 == 65534
            || *(_DWORD *)(v19 + 20) < v18
            && ((_DWORD)v9 ? (uint64_t v9 = v9) : (uint64_t v9 = 22LL),
                (uint64_t v23 = a2[1]) == 0
              ? (int v24 = (const char *)(*(void *)(*(void *)(*a2 + 392LL) + 384LL) + 208LL))
              : (int v24 = (const char *)(v23 + 3992)),
                uint64_t v25 = sub_10003965C((uint64_t)a2),
                sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): index %d val length %d longer than tree longest %d\n",  "btree_node_debug_stats",  115,  v24,  v25,  *(unsigned __int16 *)(a2[7] + 34LL),  v16,  v18,  *(_DWORD *)(*(void *)(a1 + 392) + 20LL)),  v19 = *(void *)(a1 + 392),  unsigned int v18 = (unsigned __int16)*(_DWORD *)(v19 + 20),  v18 == 65534))
          {
            unsigned int v18 = 0;
          }

          if (*(_DWORD *)(a4 + 208) < v17) {
            *(_DWORD *)(a4 + 208) = v17;
          }
          if (*(_DWORD *)(a4 + 212) < v18) {
            *(_DWORD *)(a4 + 212) = v18;
          }
          *(void *)(a4 + 144) += v17;
          unsigned int v26 = *(_DWORD *)(v19 + 16);
          uint64_t v27 = (_DWORD *)(a4 + 180);
          if (v26) {
            uint64_t v27 = (_DWORD *)(a4 + 4LL * (5 * v17 / v26) + 160);
          }
          ++*v27;
          *(void *)(a4 + 152) += v18;
          unsigned int v28 = *(_DWORD *)(v19 + 20);
          unint64_t v29 = (_DWORD *)(a4 + 204);
          if (v28) {
            unint64_t v29 = (_DWORD *)(a4 + 4LL * (5 * v18 / v28) + 184);
          }
          ++*v29;
          ++v16;
        }

        while (v16 < *(_DWORD *)(v7 + 36));
      }
    }

    else
    {
      ++*(_DWORD *)(a4 + 4 * v12 + 64);
      uint64_t v14 = *(void *)(a4 + 96) + v10;
      *(void *)(a4 + 88) += v11;
      *(void *)(a4 + 96) = v14;
    }
  }

  return v9;
}

uint64_t sub_10000C288( void *a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, unsigned int a6, uint64_t a7, int a8, uint64_t a9, char a10, unsigned __int8 a11)
{
  if (!a5 || (uint64_t v12 = a5[7]) == 0)
  {
    uint64_t v19 = a5[1];
    if (v19) {
      uint64_t v20 = (const char *)(v19 + 3992);
    }
    else {
      uint64_t v20 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94("%s:%d: %s btree_node is null\n", "btree_node_check", 152, v20);
    return 22LL;
  }

  unsigned int v15 = a6;
  unsigned int v277 = a4;
  v279 = (_BYTE *)a3;
  uint64_t v276 = a2;
  uint64_t v17 = a5[1];
  if (!v17) {
    uint64_t v17 = *(void *)(*a5 + 392LL);
  }
  uint64_t v278 = v17;
  if (a9)
  {
    uint64_t v18 = sub_10000BF04((uint64_t)a1, a5, a6, a9);
    if ((_DWORD)v18) {
      return v18;
    }
  }

  if (!a1 && (a5[4] & 1) == 0) {
    return 0LL;
  }
  uint64_t v274 = a9;
  int v273 = a11;
  unsigned int v275 = v15;
  if ((a11 & 1) != 0)
  {
LABEL_17:
    uint64_t v286 = 0LL;
    unint64_t v287 = 0xAAAAAAAAAAAAAAAALL;
    unsigned __int16 v285 = -21846;
    unsigned __int16 v284 = 0;
    int v283 = 0;
    uint64_t v22 = a5[7];
    uint64_t v23 = (uint64_t)v279;
    unsigned int v24 = v277;
    if (v279 && *(_DWORD *)(v22 + 36))
    {
      uint64_t v25 = sub_10001E654((uint64_t)v279, v277, &v287, &v285);
      if ((_DWORD)v25)
      {
        uint64_t v18 = v25;
        sub_10003965C((uint64_t)v279);
LABEL_249:
        sub_100013D94("%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n");
        return v18;
      }

      uint64_t v33 = sub_10001E654((uint64_t)a5, 0, &v286, &v284);
      if ((_DWORD)v33)
      {
        uint64_t v18 = v33;
        sub_10003965C((uint64_t)a5);
        goto LABEL_249;
      }

      uint64_t v54 = ((uint64_t (*)(uint64_t, unint64_t, void, uint64_t, void, int *))a5[52])( v278,  v287,  v285,  v286,  v284,  &v283);
      if ((_DWORD)v54)
      {
        uint64_t v18 = v54;
        sub_10003965C((uint64_t)a5);
        sub_100013D94("%s:%d: %s oid 0x%llx (level %d): minkey compare error: %d\n");
        return v18;
      }

      if (v283 >= 1)
      {
        sub_10003965C((uint64_t)a5);
        sub_100013D94("%s:%d: %s oid 0x%llx (level %d): minkey not correct\n");
        return 22LL;
      }

      if (v283)
      {
        sub_10003965C((uint64_t)a5);
        sub_100013D94("%s:%d: %s oid 0x%llx (level %d): minkey not in sync\n");
        return 22LL;
      }

      uint64_t v22 = a5[7];
      uint64_t v23 = (uint64_t)v279;
      unsigned int v24 = v277;
    }

    unsigned int v82 = *(_DWORD *)(v22 + 36);
    if (v82 >= 2)
    {
      uint64_t v271 = a7;
      int v272 = a8;
      uint64_t v18 = 0LL;
      for (unsigned int i = 1; i < v82; ++i)
      {
        if (sub_10001E564((uint64_t)a5, (unsigned __int16)(i - 1)) != 0xFFFF
          && sub_10001E564((uint64_t)a5, (unsigned __int16)i) != 0xFFFF)
        {
          unsigned int v84 = sub_10001E654((uint64_t)a5, (unsigned __int16)(i - 1), &v287, &v285);
          if (v84)
          {
            int v85 = v84;
            if ((_DWORD)v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = v84;
            }
            uint64_t v86 = a5[1];
            if (v86) {
              v87 = (const char *)(v86 + 3992);
            }
            else {
              v87 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v88 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n",  "btree_node_check",  536,  v87,  v88,  *(unsigned __int16 *)(a5[7] + 34LL),  i - 1,  v85);
          }

          else
          {
            unsigned int v89 = sub_10001E654((uint64_t)a5, (unsigned __int16)i, &v286, &v284);
            if (v89)
            {
              int v90 = v89;
              if ((_DWORD)v18) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = v89;
              }
              uint64_t v91 = a5[1];
              if (v91) {
                v92 = (const char *)(v91 + 3992);
              }
              else {
                v92 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
              }
              uint64_t v93 = sub_10003965C((uint64_t)a5);
              sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n",  "btree_node_check",  543,  v92,  v93,  *(unsigned __int16 *)(a5[7] + 34LL),  i,  v90);
            }
          }

          if (!(_DWORD)v18)
          {
            uint64_t v94 = ((uint64_t (*)(uint64_t, unint64_t, void, uint64_t, void, int *))a5[52])( v278,  v287,  v285,  v286,  v284,  &v283);
            if ((_DWORD)v94)
            {
              uint64_t v18 = v94;
              uint64_t v95 = a5[1];
              if (v95) {
                unint64_t v96 = (const char *)(v95 + 3992);
              }
              else {
                unint64_t v96 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
              }
              uint64_t v97 = sub_10003965C((uint64_t)a5);
              sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n",  "btree_node_check",  547,  v96,  v97,  *(unsigned __int16 *)(a5[7] + 34LL),  i,  v18);
            }

            else if (v283 < 0)
            {
              uint64_t v18 = 0LL;
            }

            else
            {
              uint64_t v98 = a5[1];
              if (v98) {
                v99 = (const char *)(v98 + 3992);
              }
              else {
                v99 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
              }
              uint64_t v100 = sub_10003965C((uint64_t)a5);
              sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): keys out of order: %d\n",  "btree_node_check",  550,  v99,  v100,  *(unsigned __int16 *)(a5[7] + 34LL),  i);
              uint64_t v18 = 22LL;
            }
          }
        }

        unsigned int v82 = *(_DWORD *)(a5[7] + 36LL);
      }

      a8 = v272;
      a7 = v271;
      LOWORD(v15) = v275;
      if ((_DWORD)v18) {
        return v18;
      }
      uint64_t v23 = (uint64_t)v279;
      unsigned int v24 = v277;
    }

    if (!v23) {
      goto LABEL_203;
    }
    int v101 = sub_10001E654((uint64_t)a5, (unsigned __int16)(v82 - 1), &v287, &v285);
    if (v101)
    {
      int v102 = v101;
      uint64_t v103 = a5[1];
      if (v103) {
        int v104 = (const char *)(v103 + 3992);
      }
      else {
        int v104 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v105 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n",  "btree_node_check",  559,  v104,  v105,  *(unsigned __int16 *)(a5[7] + 34LL),  *(_DWORD *)(a5[7] + 36LL) - 1,  v102);
      return 22LL;
    }

    if (*(_DWORD *)(*(void *)(v23 + 56) + 36LL) - 1 <= v24)
    {
      uint64_t v286 = a7;
      unsigned __int16 v284 = a8;
      int v107 = a8;
      uint64_t v108 = a7;
    }

    else
    {
      uint64_t v106 = sub_10001E654(v23, (unsigned __int16)(v24 + 1), &v286, &v284);
      if ((_DWORD)v106)
      {
        uint64_t v18 = v106;
        sub_10003965C((uint64_t)v279);
        goto LABEL_249;
      }

      uint64_t v108 = v286;
      int v107 = v284;
    }

    if (!v108 || !v107 || !v285) {
      goto LABEL_203;
    }
    uint64_t v109 = ((uint64_t (*)(uint64_t, unint64_t))a5[52])(v278, v287);
    if ((_DWORD)v109)
    {
      uint64_t v18 = v109;
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n");
      return v18;
    }

    if (v283 < 0)
    {
LABEL_203:
      if (a1)
      {
        uint64_t v110 = a5[7];
        if ((*(_WORD *)(v110 + 32) & 2) != 0 || *(_DWORD *)(v110 + 36))
        {
          uint64_t v18 = 0LL;
        }

        else
        {
          uint64_t v127 = a5[1];
          if (v127) {
            unint64_t v128 = (const char *)(v127 + 3992);
          }
          else {
            unint64_t v128 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
          }
          uint64_t v129 = sub_10003965C((uint64_t)a5);
          sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): non-leaf node has no children?\n",  "btree_node_check",  595,  v128,  v129,  *(unsigned __int16 *)(a5[7] + 34LL));
          uint64_t v18 = 22LL;
        }

        if ((*(_WORD *)(a5[7] + 32LL) & 2) == 0 && (a10 & 1) == 0)
        {
          v279 = v261;
          __chkstk_darwin();
          uint64_t v112 = &v261[-v111];
          bzero(&v261[-v111], v113);
          if (*(_DWORD *)(a5[7] + 36LL))
          {
            uint64_t v271 = a7;
            int v272 = a8;
            __int16 v114 = v15;
            unsigned int v115 = 0;
            LODWORD(v278) = (unsigned __int16)(v114 + 1);
            while (1)
            {
              if (sub_10001E564((uint64_t)a5, (unsigned __int16)v115) != 0xFFFF
                && sub_10001E5B0((uint64_t)a5, (unsigned __int16)v115) != 0xFFFF)
              {
                int v116 = sub_10001E938((uint64_t)a5, (unsigned __int16)v115, v112);
                if (v116)
                {
                  int v117 = v116;
                  if ((_DWORD)v18) {
                    uint64_t v18 = v18;
                  }
                  else {
                    uint64_t v18 = 22LL;
                  }
                  uint64_t v118 = a5[1];
                  if (v118) {
                    unint64_t v119 = (const char *)(v118 + 3992);
                  }
                  else {
                    unint64_t v119 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
                  }
                  uint64_t v120 = sub_10003965C((uint64_t)a5);
                  sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): can't get child %d oid: %d\n",  "btree_node_check",  606,  v119,  v120,  *(unsigned __int16 *)(a5[7] + 34LL),  v115,  v117);
                }

                else if (*v112)
                {
                  uint64_t v281 = v271;
                  v282 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
                  __int16 v280 = v272;
                  uint64_t v121 = a5[7];
                  if (v115 < *(_DWORD *)(v121 + 36) - 1)
                  {
                    int v122 = sub_10001E654((uint64_t)a5, (unsigned __int16)(v115 + 1), &v281, &v280);
                    if (v122)
                    {
                      int v142 = v122;
                      if ((_DWORD)v18) {
                        uint64_t v18 = v18;
                      }
                      else {
                        uint64_t v18 = 22LL;
                      }
                      uint64_t v143 = a5[1];
                      if (v143) {
                        uint32x2_t v144 = (const char *)(v143 + 3992);
                      }
                      else {
                        uint32x2_t v144 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
                      }
                      uint64_t v161 = sub_10003965C((uint64_t)a5);
                      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n",  "btree_node_check",  625,  v144,  v161,  *(unsigned __int16 *)(a5[7] + 34LL),  v115 + 1,  v142);
                      return v18;
                    }

                    uint64_t v121 = a5[7];
                  }

                  uint64_t v123 = v276;
                  else {
                    BOOL v124 = v282 == 0LL;
                  }
                  if (v124)
                  {
                    if ((_DWORD)v18) {
                      uint64_t v18 = v18;
                    }
                    else {
                      uint64_t v18 = 22LL;
                    }
                    sub_10003965C((uint64_t)a5);
                    sub_100013D94("%s:%d: %s oid 0x%llx (level %d): can't get child: 0x%llx\n");
                  }

                  else
                  {
                    unsigned int v125 = sub_10000C288(a1, v123, a5, (unsigned __int16)v115);
                    if ((_DWORD)v18) {
                      BOOL v126 = 1;
                    }
                    else {
                      BOOL v126 = v125 == 0;
                    }
                    if (v126) {
                      uint64_t v18 = v18;
                    }
                    else {
                      uint64_t v18 = v125;
                    }
                    sub_10003D514((uint64_t)v282, 1);
                    sub_100038824(v282);
                  }
                }

                else
                {
                  if ((_DWORD)v18) {
                    uint64_t v18 = v18;
                  }
                  else {
                    uint64_t v18 = 22LL;
                  }
                  sub_10003965C((uint64_t)a5);
                  sub_100013D94("%s:%d: %s oid 0x%llx (level %d): invalid child oid: 0x%llx\n");
                }
              }

              if (++v115 >= *(_DWORD *)(a5[7] + 36LL)) {
                return v18;
              }
            }
          }
        }

        return v18;
      }

      return 0LL;
    }

    sub_10003965C((uint64_t)a5);
    sub_100013D94("%s:%d: %s oid 0x%llx (level %d): node's max key is not less than next sibling's entry in parent\n");
    return 22LL;
  }

  uint64_t v18 = 0LL;
  if (v279 && (*(_WORD *)(v12 + 32) & 1) != 0)
  {
    uint64_t v26 = a5[1];
    if (v26) {
      uint64_t v27 = (const char *)(v26 + 3992);
    }
    else {
      uint64_t v27 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v28 = sub_10003965C((uint64_t)a5);
    int v29 = *(unsigned __int16 *)(a5[7] + 34LL);
    uint64_t v30 = sub_10003965C((uint64_t)v279);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): root node has a parent 0x%llx (level %d)\n",  "btree_node_check",  183,  v27,  v28,  v29,  v30,  *(unsigned __int16 *)(*((void *)v279 + 7) + 34LL));
    uint64_t v18 = 22LL;
    unsigned int v15 = v275;
  }

  if ((*(_WORD *)(v12 + 32) & 2) != 0 && *(_WORD *)(v12 + 34))
  {
    uint64_t v31 = a5[1];
    if (v31) {
      int v32 = (const char *)(v31 + 3992);
    }
    else {
      int v32 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v34 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): leaf node has non-zero level\n",  "btree_node_check",  186,  v32,  v34,  *(unsigned __int16 *)(v12 + 34));
    uint64_t v18 = 22LL;
  }

  if (a1)
  {
    if (*(unsigned __int16 *)(a5[7] + 34LL) > *(unsigned __int16 *)(a1[7] + 34LL))
    {
      if ((_DWORD)v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22LL;
      }
      uint64_t v35 = a5[1];
      if (v35) {
        uint64_t v36 = (const char *)(v35 + 3992);
      }
      else {
        uint64_t v36 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v37 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): node level greater than root level %d\n",  "btree_node_check",  189,  v36,  v37,  *(unsigned __int16 *)(v12 + 34),  *(unsigned __int16 *)(a1[7] + 34LL));
    }

    unsigned int v38 = v15 - 1;
    if (*(unsigned __int16 *)(a1[7] + 34LL) - (v15 - 1) != *(unsigned __int16 *)(a5[7] + 34LL))
    {
      if ((_DWORD)v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22LL;
      }
      uint64_t v39 = a5[1];
      if (v39) {
        uint64_t v40 = (const char *)(v39 + 3992);
      }
      else {
        uint64_t v40 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v41 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): node level should be %d\n",  "btree_node_check",  192,  v40,  v41,  *(unsigned __int16 *)(v12 + 34),  *(unsigned __int16 *)(a1[7] + 34LL) - v38);
    }
  }

  if ((*(_WORD *)(v12 + 32) & 1) != 0) {
    __int16 v42 = -96;
  }
  else {
    __int16 v42 = -56;
  }
  unsigned __int16 v43 = v42 + ((a5[50] >> 27) & 0xF000);
  if (*(_WORD *)(v12 + 40))
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v44 = a5[1];
    if (v44) {
      unint64_t v45 = (const char *)(v44 + 3992);
    }
    else {
      unint64_t v45 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v46 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): invalid table space offset\n",  "btree_node_check",  203,  v45,  v46,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  if (*(unsigned __int16 *)(v12 + 42) > v43)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v47 = a5[1];
    if (v47) {
      unint64_t v48 = (const char *)(v47 + 3992);
    }
    else {
      unint64_t v48 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v49 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): table space length larger than available data space\n",  "btree_node_check",  206,  v48,  v49,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  if ((*(_WORD *)(v12 + 32) & 4) == 0)
  {
    unsigned int v50 = *(unsigned __int16 *)(v12 + 42);
    if (v50 < 8 * sub_10001E4A8((uint64_t)a5))
    {
      if ((_DWORD)v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22LL;
      }
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): table space length smaller than minimum\n");
      return v18;
    }
  }

  if ((_DWORD)v18) {
    return v18;
  }
  uint64_t v51 = (unsigned __int16)(v43 - *(_WORD *)(v12 + 42));
  if (*(unsigned __int16 *)(v12 + 44) <= (unsigned __int16)(v43 - *(_WORD *)(v12 + 42)))
  {
    uint64_t v18 = 0LL;
  }

  else
  {
    uint64_t v52 = a5[1];
    if (v52) {
      __int128 v53 = (const char *)(v52 + 3992);
    }
    else {
      __int128 v53 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v55 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): free space offset too large\n",  "btree_node_check",  218,  v53,  v55,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  if (*(unsigned __int16 *)(v12 + 46) + *(unsigned __int16 *)(v12 + 44) > v51)
  {
    uint64_t v56 = a5[1];
    if (v56) {
      uint64_t v57 = (const char *)(v56 + 3992);
    }
    else {
      uint64_t v57 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v58 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): free space extends beyond end of node\n",  "btree_node_check",  221,  v57,  v58,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  uint64_t v270 = *(unsigned __int16 *)(v12 + 44);
  int v59 = *(unsigned __int16 *)(v12 + 46);
  if (*(_DWORD *)(v12 + 36) > v51)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v60 = a5[1];
    if (v60) {
      unsigned int v61 = (const char *)(v60 + 3992);
    }
    else {
      unsigned int v61 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v62 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key count larger than possible\n",  "btree_node_check",  228,  v61,  v62,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  unsigned int v63 = *(_DWORD *)(v12 + 36);
  uint64_t v269 = v51;
  if (v63 > v270 && (*(__int16 *)(v12 + 32) & 0x80000000) == 0)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v64 = a5[1];
    if (v64) {
      unint64_t v65 = (const char *)(v64 + 3992);
    }
    else {
      unint64_t v65 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v66 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key count larger than gross key space\n",  "btree_node_check",  231,  v65,  v66,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  unsigned int v67 = *(_DWORD *)(v12 + 36);
  unsigned int v68 = *(unsigned __int16 *)(v12 + 42);
  if (v67 > v68 / sub_10001E4A8((uint64_t)a5))
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    sub_10003965C((uint64_t)a5);
    sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key count larger than TOC space\n");
    return v18;
  }

  if ((_DWORD)v18) {
    return v18;
  }
  if (a5[47] == v12 + 56)
  {
    uint64_t v18 = 0LL;
  }

  else
  {
    uint64_t v69 = a5[1];
    if (v69) {
      v70 = (const char *)(v69 + 3992);
    }
    else {
      v70 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v71 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): invalid TOC[] pointer\n",  "btree_node_check",  242,  v70,  v71,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  if (a5[48] != v12 + 56 + *(unsigned __int16 *)(v12 + 42))
  {
    uint64_t v72 = a5[1];
    if (v72) {
      uint64_t v73 = (const char *)(v72 + 3992);
    }
    else {
      uint64_t v73 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v74 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): invalid keys[] pointer\n",  "btree_node_check",  245,  v73,  v74,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  if ((*(_WORD *)(v12 + 32) & 1) != 0 && a5[49] != v12 + ((a5[50] >> 27) & 0x1F000LL) - 40)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v75 = a5[1];
    if (v75) {
      uint64_t v76 = (const char *)(v75 + 3992);
    }
    else {
      uint64_t v76 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v77 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n",  "btree_node_check",  248,  v76,  v77,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  if ((*(_WORD *)(v12 + 32) & 1) == 0 && a5[49] != v12 + ((a5[50] >> 27) & 0x1F000LL))
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    sub_10003965C((uint64_t)a5);
    sub_100013D94("%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n");
    return v18;
  }

  if ((_DWORD)v18) {
    return v18;
  }
  int v78 = v270 + v59;
  if (*(unsigned __int16 *)(v12 + 50) <= v270)
  {
    uint64_t v18 = 0LL;
    int v81 = v269;
  }

  else
  {
    uint64_t v79 = a5[1];
    if (v79) {
      int v80 = (const char *)(v79 + 3992);
    }
    else {
      int v80 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    int v81 = v269;
    uint64_t v130 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key free list space larger than key space available\n",  "btree_node_check",  259,  v80,  v130,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  int v131 = v81 - v78;
  unint64_t v132 = *(unsigned __int16 *)(v12 + 48);
  if (v132 != 0xFFFF && v270 - 4 < v132)
  {
    uint64_t v133 = a5[1];
    if (v133) {
      unint64_t v134 = (const char *)(v133 + 3992);
    }
    else {
      unint64_t v134 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v135 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key free list head beyond key space available\n",  "btree_node_check",  263,  v134,  v135,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  if (*(unsigned __int16 *)(v12 + 54) > (unsigned __int16)v131)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v136 = a5[1];
    if (v136) {
      v137 = (const char *)(v136 + 3992);
    }
    else {
      v137 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v138 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val free list space larger than val space available\n",  "btree_node_check",  266,  v137,  v138,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  unsigned int v139 = *(unsigned __int16 *)(v12 + 52);
  if (v139 != 0xFFFF)
  {
    if (v139 > (unsigned __int16)v131)
    {
      if ((_DWORD)v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22LL;
      }
      uint64_t v140 = a5[1];
      if (v140) {
        uint32x2_t v141 = (const char *)(v140 + 3992);
      }
      else {
        uint32x2_t v141 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v145 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val free list head beyond val space available\n",  "btree_node_check",  270,  v141,  v145,  *(unsigned __int16 *)(a5[7] + 34LL));
      unsigned int v139 = *(unsigned __int16 *)(v12 + 52);
    }

    if (v139 <= 3)
    {
      if ((_DWORD)v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22LL;
      }
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): val free list head beyond end of node\n");
      return v18;
    }
  }

  if ((_DWORD)v18) {
    return v18;
  }
  unint64_t v268 = v270 - 4;
  uint32x2_t v146 = sub_100013EEC((v269 + 63) >> 6, 8uLL);
  size_t v266 = (v269 + 63) >> 6;
  int v147 = sub_100013EEC(v266, 8uLL);
  v267 = v147;
  if (!v146 || !v147)
  {
    uint64_t v158 = a5[1];
    if (v158) {
      int v159 = (const char *)(v158 + 3992);
    }
    else {
      int v159 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v160 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): couldn't allocate bitmap to check btree node space usage\n",  "btree_node_check",  286,  v159,  v160,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 12LL;
    goto LABEL_343;
  }

  int v265 = v131;
  uint64_t v271 = a7;
  int v272 = a8;
  sub_10001D318((uint64_t)v146, *(unsigned __int16 *)(v12 + 44), *(unsigned __int16 *)(v12 + 46));
  unsigned __int16 v148 = 0;
  LOWORD(v149) = *(_WORD *)(v12 + 48);
  uint64_t v150 = v146;
  while (1)
  {
    uint64_t v151 = (unsigned __int16)v149;
    if ((unsigned __int16)v149 >= v270 || v268 < (unsigned __int16)v149)
    {
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key free list entry starts beyond key space available\n");
LABEL_341:
      uint64_t v18 = 22LL;
      goto LABEL_342;
    }

    int v152 = (unsigned __int16 *)(a5[48] + (unsigned __int16)v149);
    uint64_t v153 = v152[1];
    if (v153 <= 3)
    {
LABEL_339:
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key free list entry len value too small\n");
      goto LABEL_341;
    }

    if (v153 + (unsigned __int16)v149 > v270)
    {
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key free list entry extends beyond key space available\n");
      goto LABEL_341;
    }

    if (!sub_10001D234((uint64_t)v146, (unsigned __int16)v149, v153))
    {
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key free list entry overlaps with other free space\n");
      goto LABEL_341;
    }

    sub_10001D318((uint64_t)v146, v151, v152[1]);
    v148 += v152[1];
    unsigned int v154 = *(unsigned __int16 *)(v12 + 50);
    if (v148 <= v154)
    {
      uint64_t v18 = 0LL;
    }

    else
    {
      uint64_t v155 = a5[1];
      if (v155) {
        int v156 = (const char *)(v155 + 3992);
      }
      else {
        int v156 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v157 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key free list entries total space exceeds free list space\n",  "btree_node_check",  326,  v156,  v157,  *(unsigned __int16 *)(a5[7] + 34LL));
      uint64_t v18 = 22LL;
    }

    int v149 = *v152;
    if ((_DWORD)v151 == v149)
    {
LABEL_340:
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): key free list entry points to itself\n");
      goto LABEL_341;
    }

    uint32x2_t v146 = v150;
    if (v148 > v154) {
      goto LABEL_343;
    }
  }

  unsigned __int16 v162 = 0;
  LOWORD(v163) = *(_WORD *)(v12 + 52);
  while (1)
  {
    unsigned int v164 = (unsigned __int16)v163;
    if ((unsigned __int16)v163 <= 3u)
    {
      uint64_t v165 = a5[1];
      if (v165) {
        v166 = (const char *)(v165 + 3992);
      }
      else {
        v166 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v167 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val free list entry beyond end of node\n",  "btree_node_check",  342,  v166,  v167,  *(unsigned __int16 *)(a5[7] + 34LL));
      uint64_t v18 = 22LL;
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    if (v164 > (unsigned __int16)v265)
    {
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): val free list entry starts beyond val space available\n");
      goto LABEL_341;
    }

    uint32x2_t v146 = v150;
    if (v164 < 4) {
      goto LABEL_343;
    }
    unsigned int v168 = (unsigned __int16 *)(a5[49] - v164);
    unint64_t v169 = v168[1];
    if (v169 <= 3) {
      goto LABEL_339;
    }
    if (v164 < v169)
    {
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): val free list entry extends beyond val space available\n");
      goto LABEL_341;
    }

    if (!sub_10001D234((uint64_t)v150, (int)(v269 - v164), v169))
    {
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): val free list entry overlaps with other free space\n");
      goto LABEL_341;
    }

    sub_10001D318((uint64_t)v150, (int)(v269 - v164), v168[1]);
    v162 += v168[1];
    unsigned int v170 = *(unsigned __int16 *)(v12 + 54);
    if (v162 <= v170)
    {
      uint64_t v18 = 0LL;
    }

    else
    {
      uint64_t v171 = a5[1];
      if (v171) {
        unsigned int v172 = (const char *)(v171 + 3992);
      }
      else {
        unsigned int v172 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v173 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val free list entries total space exceeds free list space\n",  "btree_node_check",  372,  v172,  v173,  *(unsigned __int16 *)(a5[7] + 34LL));
      uint64_t v18 = 22LL;
    }

    int v163 = *v168;
    if (v164 == v163) {
      goto LABEL_340;
    }
    uint32x2_t v146 = v150;
    if (v162 > v170) {
      goto LABEL_343;
    }
  }

  if ((*(_WORD *)(v12 + 32) & 4) != 0 && (a5[50] & 0x7FFE00) == 0)
  {
    uint64_t v176 = a5[1];
    if (v176) {
      uint64_t v177 = (const char *)(v176 + 3992);
    }
    else {
      uint64_t v177 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v178 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says key size is variable\n",  "btree_node_check",  387,  v177,  v178,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  else
  {
    uint64_t v18 = 0LL;
  }

  if ((*(_WORD *)(a5[7] + 32LL) & 2) == 0 && (a5[50] & 0x7FFE00) != 0 && (*(_WORD *)(v12 + 32) & 4) == 0)
  {
    uint64_t v174 = a5[1];
    if (v174) {
      unsigned int v175 = (const char *)(v174 + 3992);
    }
    else {
      unsigned int v175 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v179 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): tree says key size is fixed, but node says kv size is variable\n",  "btree_node_check",  390,  v175,  v179,  *(unsigned __int16 *)(a5[7] + 34LL));
    uint64_t v18 = 22LL;
  }

  if ((*(_WORD *)(v12 + 32) & 4) != 0 && (*(_WORD *)(a5[7] + 32LL) & 2) != 0 && (a5[50] & 0x7FFF800000LL) == 0)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v180 = a5[1];
    if (v180) {
      unint64_t v181 = (const char *)(v180 + 3992);
    }
    else {
      unint64_t v181 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v182 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says val size is variable\n",  "btree_node_check",  393,  v181,  v182,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  uint64_t v183 = a5[7];
  __int16 v184 = *(_WORD *)(v183 + 32);
  if ((v184 & 2) != 0)
  {
    uint64_t v185 = a5[50];
    if ((v185 & 0x7FFF800000LL) != 0 && (v185 & 4) == 0 && (v185 & 0x7FFE00) != 0 && (*(_WORD *)(v12 + 32) & 4) == 0)
    {
      if ((_DWORD)v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22LL;
      }
      sub_10003965C((uint64_t)a5);
      sub_100013D94("%s:%d: %s oid 0x%llx (level %d): tree says kv sizes are fixed, but leaf says kv size is variable\n");
      goto LABEL_342;
    }
  }

  uint32x2_t v146 = v150;
  if ((_DWORD)v18) {
    goto LABEL_343;
  }
  uint64_t v186 = a5[47];
  if ((*(_WORD *)(v12 + 32) & 4) == 0)
  {
    if (*(_DWORD *)(v183 + 36))
    {
      unint64_t v187 = 0LL;
      unint64_t v188 = (unsigned __int16 *)(v186 + 4);
      while (1)
      {
        uint64_t v189 = *(v188 - 2);
        unint64_t v268 = *v188;
        uint64_t v190 = v188[1];
        if ((_DWORD)v189 == 0xFFFF)
        {
          uint64_t v18 = 0LL;
        }

        else
        {
          uint64_t v191 = *(v188 - 1);
          __int16 v192 = *(_WORD *)(v183 + 32);
          if ((v192 & 2) != 0
            && (a1 && *(_DWORD *)(a1[49] + 16LL) < v191
             || (v192 & 1) != 0 && *(_DWORD *)(a5[49] + 16LL) < v191))
          {
            uint64_t v193 = a5[1];
            if (v193) {
              uint64_t v194 = (const char *)(v193 + 3992);
            }
            else {
              uint64_t v194 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v195 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n",  "btree_node_check",  475,  v194,  v195,  *(unsigned __int16 *)(a5[7] + 34LL));
            uint64_t v18 = 22LL;
          }

          else
          {
            uint64_t v18 = 0LL;
          }

          if (v189 >= v270)
          {
            uint64_t v196 = a5[1];
            if (v196) {
              uint64_t v197 = (const char *)(v196 + 3992);
            }
            else {
              uint64_t v197 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v198 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key location not within key space\n",  "btree_node_check",  475,  v197,  v198,  *(unsigned __int16 *)(a5[7] + 34LL));
            uint64_t v18 = 22LL;
          }

          if ((int)v191 + (int)v189 <= v270)
          {
            if (!(_DWORD)v18)
            {
              if (sub_10001D234((uint64_t)v150, v189, v191))
              {
                uint64_t v18 = 0LL;
              }

              else
              {
                uint64_t v202 = a5[1];
                if (v202) {
                  uint64_t v203 = (const char *)(v202 + 3992);
                }
                else {
                  uint64_t v203 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
                }
                uint64_t v204 = sub_10003965C((uint64_t)a5);
                sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n",  "btree_node_check",  475,  v203,  v204,  *(unsigned __int16 *)(a5[7] + 34LL));
                uint64_t v18 = 22LL;
              }

              if (!sub_10001D234((uint64_t)v267, v189, v191))
              {
                uint64_t v205 = a5[1];
                if (v205) {
                  int v206 = (const char *)(v205 + 3992);
                }
                else {
                  int v206 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
                }
                uint64_t v207 = sub_10003965C((uint64_t)a5);
                sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n",  "btree_node_check",  475,  v206,  v207,  *(unsigned __int16 *)(a5[7] + 34LL));
                uint64_t v18 = 22LL;
              }

              if ((a5[50] & 0x40LL) != 0) {
                uint64_t v208 = v191;
              }
              else {
                uint64_t v208 = ((_DWORD)v191 + 7) & 0x1FFF8;
              }
              sub_10001D318((uint64_t)v267, v189, v208);
            }
          }

          else
          {
            if ((_DWORD)v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22LL;
            }
            uint64_t v199 = a5[1];
            if (v199) {
              unint64_t v200 = (const char *)(v199 + 3992);
            }
            else {
              unint64_t v200 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v201 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n",  "btree_node_check",  475,  v200,  v201,  *(unsigned __int16 *)(a5[7] + 34LL));
          }
        }

        if (v268 > 0xFFFD)
        {
          if ((_DWORD)v190 && (_DWORD)v190 != 65534)
          {
            if ((_DWORD)v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22LL;
            }
            sub_10003965C((uint64_t)a5);
            sub_100013D94("%s:%d: %s oid 0x%llx (level %d): invalid val offset has non-zero length\n");
            goto LABEL_342;
          }
        }

        else
        {
          __int16 v209 = *(_WORD *)(a5[7] + 32LL);
          if ((v209 & 2) != 0
            && (a1 && *(_DWORD *)(a1[49] + 20LL) < v190
             || (v209 & 1) != 0 && *(_DWORD *)(a5[49] + 20LL) < v190))
          {
            if ((_DWORD)v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22LL;
            }
            uint64_t v210 = a5[1];
            if (v210) {
              int v211 = (const char *)(v210 + 3992);
            }
            else {
              int v211 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v212 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n",  "btree_node_check",  478,  v211,  v212,  *(unsigned __int16 *)(a5[7] + 34LL));
          }

          if (v268 > (unsigned __int16)v265)
          {
            if ((_DWORD)v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22LL;
            }
            uint64_t v213 = a5[1];
            if (v213) {
              uint64_t v214 = (const char *)(v213 + 3992);
            }
            else {
              uint64_t v214 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v215 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val location not within val space\n",  "btree_node_check",  478,  v214,  v215,  *(unsigned __int16 *)(a5[7] + 34LL));
          }

          if (v268 < v190)
          {
            if ((_DWORD)v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22LL;
            }
            goto LABEL_575;
          }

          uint32x2_t v146 = v150;
          if ((_DWORD)v18) {
            goto LABEL_343;
          }
          uint64_t v216 = v269 - v268;
          if (sub_10001D234((uint64_t)v150, v269 - v268, v190))
          {
            uint64_t v18 = 0LL;
          }

          else
          {
            uint64_t v217 = a5[1];
            if (v217) {
              v218 = (const char *)(v217 + 3992);
            }
            else {
              v218 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v219 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n",  "btree_node_check",  478,  v218,  v219,  *(unsigned __int16 *)(a5[7] + 34LL));
            uint64_t v18 = 22LL;
          }

          if (!sub_10001D234((uint64_t)v267, v216, v190))
          {
            uint64_t v220 = a5[1];
            if (v220) {
              int v221 = (const char *)(v220 + 3992);
            }
            else {
              int v221 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v222 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n",  "btree_node_check",  478,  v221,  v222,  *(unsigned __int16 *)(a5[7] + 34LL));
            uint64_t v18 = 22LL;
          }

          if ((a5[50] & 0x40LL) != 0) {
            uint64_t v223 = v190;
          }
          else {
            uint64_t v223 = ((_DWORD)v190 + 7) & 0x1FFF8;
          }
          sub_10001D318((uint64_t)v267, v216, v223);
        }

        uint32x2_t v146 = v150;
        if ((_DWORD)v18) {
          goto LABEL_343;
        }
        v188 += 4;
        ++v187;
        uint64_t v183 = a5[7];
      }
    }

    goto LABEL_561;
  }

  unint64_t v224 = a5[50];
  if ((v184 & 2) != 0) {
    uint64_t v225 = (unsigned __int16)(v224 >> 23);
  }
  else {
    uint64_t v225 = 8LL;
  }
  if (!*(_DWORD *)(v183 + 36))
  {
LABEL_561:
    sub_100014004(v150, 8 * v266);
    sub_100014004(v267, 8 * v266);
    a8 = v272;
    a7 = v271;
    LOWORD(v15) = v275;
    goto LABEL_17;
  }

  unint64_t v226 = 0LL;
  unint64_t v264 = (v224 >> 9) & 0x3FFF;
  unsigned int v262 = ((_WORD)v264 + 7) & 0x7FF8;
  uint64_t v263 = ((_DWORD)v225 + 7) & 0x1FFF8;
  uint64_t v227 = (unsigned __int16 *)(v186 + 2);
  while (1)
  {
    uint64_t v228 = *(v227 - 1);
    unint64_t v268 = *v227;
    if ((_DWORD)v228 == 0xFFFF)
    {
      if ((*(__int16 *)(v12 + 32) & 0x80000000) == 0)
      {
LABEL_576:
        sub_10003965C((uint64_t)a5);
        sub_100013D94("%s:%d: %s oid 0x%llx (level %d): invalid key offset\n");
        goto LABEL_341;
      }

      uint64_t v18 = 0LL;
    }

    else
    {
      __int16 v229 = *(_WORD *)(v183 + 32);
      if ((v229 & 2) != 0
        && (a1 && *(_DWORD *)(a1[49] + 16LL) < v264
         || (v229 & 1) != 0 && *(_DWORD *)(a5[49] + 16LL) < v264))
      {
        uint64_t v230 = a5[1];
        if (v230) {
          uint64_t v231 = (const char *)(v230 + 3992);
        }
        else {
          uint64_t v231 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
        }
        uint64_t v232 = sub_10003965C((uint64_t)a5);
        sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n",  "btree_node_check",  452,  v231,  v232,  *(unsigned __int16 *)(a5[7] + 34LL));
        uint64_t v18 = 22LL;
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      if (v228 >= v270)
      {
        uint64_t v233 = a5[1];
        if (v233) {
          v234 = (const char *)(v233 + 3992);
        }
        else {
          v234 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
        }
        uint64_t v235 = sub_10003965C((uint64_t)a5);
        sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key location not within key space\n",  "btree_node_check",  452,  v234,  v235,  *(unsigned __int16 *)(a5[7] + 34LL));
        uint64_t v18 = 22LL;
      }

      if ((int)v264 + (int)v228 <= v270)
      {
        if (!(_DWORD)v18)
        {
          if (sub_10001D234((uint64_t)v150, v228, v264))
          {
            uint64_t v18 = 0LL;
          }

          else
          {
            uint64_t v239 = a5[1];
            if (v239) {
              uint64_t v240 = (const char *)(v239 + 3992);
            }
            else {
              uint64_t v240 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v241 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n",  "btree_node_check",  452,  v240,  v241,  *(unsigned __int16 *)(a5[7] + 34LL));
            uint64_t v18 = 22LL;
          }

          if (!sub_10001D234((uint64_t)v267, v228, v264))
          {
            uint64_t v242 = a5[1];
            if (v242) {
              unint64_t v243 = (const char *)(v242 + 3992);
            }
            else {
              unint64_t v243 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
            }
            uint64_t v244 = sub_10003965C((uint64_t)a5);
            sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n",  "btree_node_check",  452,  v243,  v244,  *(unsigned __int16 *)(a5[7] + 34LL));
            uint64_t v18 = 22LL;
          }

          if ((a5[50] & 0x40LL) != 0) {
            uint64_t v245 = v264;
          }
          else {
            uint64_t v245 = v262;
          }
          sub_10001D318((uint64_t)v267, v228, v245);
        }
      }

      else
      {
        uint64_t v18 = (_DWORD)v18 ? v18 : 22LL;
        uint64_t v236 = a5[1];
        v237 = (const char *)(v236 ? v236 + 3992 : *(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
        uint64_t v238 = sub_10003965C((uint64_t)a5);
        sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n",  "btree_node_check",  452,  v237,  v238,  *(unsigned __int16 *)(a5[7] + 34LL));
      }
    }

LABEL_559:
    uint32x2_t v146 = v150;
    if ((_DWORD)v18) {
      goto LABEL_343;
    }
    v227 += 2;
    ++v226;
    uint64_t v183 = a5[7];
  }

  __int16 v246 = *(_WORD *)(a5[7] + 32LL);
  if ((v246 & 2) != 0
    && (a1 && *(_DWORD *)(a1[49] + 20LL) < v225
     || (v246 & 1) != 0 && *(_DWORD *)(a5[49] + 20LL) < v225))
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v247 = a5[1];
    if (v247) {
      unint64_t v248 = (const char *)(v247 + 3992);
    }
    else {
      unint64_t v248 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v249 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n",  "btree_node_check",  455,  v248,  v249,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  if (v268 > (unsigned __int16)v265)
  {
    if ((_DWORD)v18) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = 22LL;
    }
    uint64_t v250 = a5[1];
    if (v250) {
      uint64_t v251 = (const char *)(v250 + 3992);
    }
    else {
      uint64_t v251 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
    }
    uint64_t v252 = sub_10003965C((uint64_t)a5);
    sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val location not within val space\n",  "btree_node_check",  455,  v251,  v252,  *(unsigned __int16 *)(a5[7] + 34LL));
  }

  if (v268 >= v225)
  {
    uint32x2_t v146 = v150;
    if ((_DWORD)v18) {
      goto LABEL_343;
    }
    uint64_t v253 = v269 - v268;
    if (sub_10001D234((uint64_t)v150, v269 - v268, v225))
    {
      uint64_t v18 = 0LL;
    }

    else
    {
      uint64_t v254 = a5[1];
      if (v254) {
        uint64_t v255 = (const char *)(v254 + 3992);
      }
      else {
        uint64_t v255 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v256 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n",  "btree_node_check",  455,  v255,  v256,  *(unsigned __int16 *)(a5[7] + 34LL));
      uint64_t v18 = 22LL;
    }

    if (!sub_10001D234((uint64_t)v267, v253, v225))
    {
      uint64_t v257 = a5[1];
      if (v257) {
        v258 = (const char *)(v257 + 3992);
      }
      else {
        v258 = (const char *)(*(void *)(*(void *)(*a5 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v259 = sub_10003965C((uint64_t)a5);
      sub_100013D94( "%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n",  "btree_node_check",  455,  v258,  v259,  *(unsigned __int16 *)(a5[7] + 34LL));
      uint64_t v18 = 22LL;
    }

    if ((a5[50] & 0x40LL) != 0) {
      uint64_t v260 = v225;
    }
    else {
      uint64_t v260 = v263;
    }
    sub_10001D318((uint64_t)v267, v253, v260);
    goto LABEL_559;
  }

  if ((_DWORD)v18) {
    uint64_t v18 = v18;
  }
  else {
    uint64_t v18 = 22LL;
  }
LABEL_575:
  sub_10003965C((uint64_t)a5);
  sub_100013D94("%s:%d: %s oid 0x%llx (level %d): val location extends beyond val space\n");
LABEL_342:
  uint32x2_t v146 = v150;
LABEL_343:
  if (v146) {
    sub_100014004(v146, (8 * v266));
  }
  if (v267) {
    sub_100014004(v267, (8 * v266));
  }
  return v18;
}

uint64_t sub_10000EF38(FILE *a1, void *a2, uint64_t a3, int a4, int a5)
{
  if (sub_100037DC8((uint64_t)a2) == 2)
  {
    uint64_t v34 = 0LL;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v17 = 0u;
    uint64_t v10 = sub_10000C288(a2, a3, 0LL, 0, a2, 1u, 0LL, 0, (uint64_t)&v17, 0, 0);
    uint64_t v11 = v10;
    if (*(void *)(a2[49] + 24LL) != v18)
    {
      if ((_DWORD)v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 22LL;
      }
      uint64_t v12 = a2[1];
      if (v12) {
        uint64_t v13 = (const char *)(v12 + 3992);
      }
      else {
        uint64_t v13 = (const char *)(*(void *)(*(void *)(*a2 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v14 = sub_10003965C((uint64_t)a2);
      sub_100013D94( "%s:%d: %s oid 0x%llx: btree key count (%llu) doesn't match # leaf entries (%u)\n",  "btree_check_ext",  681,  v13,  v14,  *(void *)(a2[49] + 24LL),  (_DWORD)v18);
    }

    if (*(void *)(a2[49] + 32LL) == DWORD1(v17) + (_DWORD)v17)
    {
      if (a5 && a4 && !(_DWORD)v11)
      {
        if (a1) {
          unsigned int v15 = a1;
        }
        else {
          unsigned int v15 = __stdoutp;
        }
        sub_10000F18C(v15, (uint64_t)a2, &v17, a5);
      }
    }

    else
    {
      if ((_DWORD)v11) {
        uint64_t v11 = v11;
      }
      else {
        uint64_t v11 = 22LL;
      }
      sub_10003965C((uint64_t)a2);
      sub_100013D94("%s:%d: %s oid 0x%llx: btree node count (%llu) doesn't match # nodes traversed (%u)\n");
    }
  }

  else
  {
    uint64_t v11 = 22LL;
    if (a2[1]) {
      sub_100013D94("%s:%d: %s btree check called with non-root btree node: %d\n");
    }
    else {
      sub_100013D94( "%s:%d: %s btree check called with non-root btree node: %d\n",  "btree_check_ext",  672,  (const char *)(*(void *)(*(void *)(*a2 + 392LL) + 384LL) + 208LL),  22);
    }
  }

  return v11;
}

uint64_t sub_10000F18C(FILE *a1, uint64_t a2, _DWORD *a3, int a4)
{
  if (a1) {
    a4 = 5;
  }
  if (a1) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = __stdoutp;
  }
  if (a4 >= 2)
  {
    unint64_t v8 = *(_DWORD **)(a2 + 392);
    int v9 = v8[1];
    int v10 = v8[2];
    int v11 = v8[3];
    if (v10) {
      int v12 = v10;
    }
    else {
      int v12 = 8;
    }
    if (v11) {
      int v13 = v11;
    }
    else {
      int v13 = 8;
    }
    unsigned int v14 = *a3;
    if (*a3 <= 1u) {
      unsigned int v14 = 1;
    }
    fprintf( v7,  "nodesize: %d  dataspace: %d  key size: %d  val size: %d  max keys: node %d leaf %d  avg keys: node %d leaf %d\n",  v9,  v9 - 56,  v10,  v11,  (v9 - 56) / (v12 + 8),  (v9 - 56) / (v13 + v12),  a3[3] / v14,  a3[4] / a3[1]);
  }

  unint64_t v16 = *((void *)a3 + 11);
  if (v16 <= 1) {
    unint64_t v16 = 1LL;
  }
  double v17 = (double)*((unint64_t *)a3 + 12) * 100.0 / (double)v16;
  unint64_t v18 = *((void *)a3 + 16);
  if (v18 <= 1) {
    unint64_t v18 = 1LL;
  }
  unsigned int v15 = a3[1];
  uint64_t result = fprintf( v7,  "levels: %d  keys: %lld  nodes: total %d  internal: %d (%.2f%%)  leaves: %d (%.2f%%)  usage: %.2f%% (%.2f%% %.2f%%)\n",  a3[2],  *(void *)(*(void *)(a2 + 392) + 24LL),  v15 + *a3,  *a3,  (double)*a3 * 100.0 / (double)(v15 + *a3),  v15,  (double)v15 * 100.0 / (double)(v15 + *a3),  (double)*((unint64_t *)a3 + 7) * 100.0 / (double)*((unint64_t *)a3 + 6),  v17,  (double)*((unint64_t *)a3 + 17) * 100.0 / (double)v18);
  if (a4 > 2)
  {
    uint64_t v20 = 0LL;
    int v21 = 0;
    __int128 v22 = a3 + 54;
    do
    {
      if (v22[v20])
      {
        if (v20) {
          uint64_t result = fprintf(v7, "level %d: %d nodes %.2f average descendents\n");
        }
        else {
          uint64_t result = fprintf(v7, "level %d: %d nodes\n");
        }
        v21 += v22[v20];
      }

      ++v20;
    }

    while (v20 != 16);
  }

  if (a4 >= 2)
  {
    LODWORD(v23) = a3[4];
    unint64_t v23 = v23 <= 1 ? 1LL : v23;
    uint64_t result = fprintf( v7,  "key/val sizes:  tree max k:%d v:%d  max k:%d v:%d  avg k:%llu v:%llu\n",  *(_DWORD *)(*(void *)(a2 + 392) + 16LL),  *(_DWORD *)(*(void *)(a2 + 392) + 20LL),  a3[52],  a3[53],  *((void *)a3 + 18) / v23,  *((void *)a3 + 19) / v23);
    if (a4 >= 4)
    {
      *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
      __int128 v66 = v24;
      __int128 v67 = v24;
      __int128 v64 = v24;
      __int128 v65 = v24;
      *(_OWORD *)__str = v24;
      __int128 v63 = v24;
      snprintf(__str, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 16LL) / 5u);
      snprintf((char *)&v63, 0x10uLL, "<%d", 2 * *(_DWORD *)(*(void *)(a2 + 392) + 16LL) / 5u);
      snprintf((char *)&v64, 0x10uLL, "<%d", 3 * *(_DWORD *)(*(void *)(a2 + 392) + 16LL) / 5u);
      snprintf((char *)&v65, 0x10uLL, "<%d", 4 * *(_DWORD *)(*(void *)(a2 + 392) + 16LL) / 5u);
      snprintf((char *)&v66, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 16LL));
      snprintf((char *)&v67, 0x10uLL, "=%d", *(_DWORD *)(*(void *)(a2 + 392) + 16LL));
      fprintf( v7,  "    keys: %9s %9s %9s %9s %9s %9s\n",  __str,  (const char *)&v63,  (const char *)&v64,  (const char *)&v65,  (const char *)&v66,  (const char *)&v67);
      fprintf(v7, "    keys: %9d %9d %9d %9d %9d %9d\n", a3[40], a3[41], a3[42], a3[43], a3[44], a3[45]);
      LODWORD(v30) = a3[40];
      double v31 = (double)v30 * 100.0;
      unsigned int v32 = a3[4];
      if (v32 <= 1) {
        unsigned int v32 = 1;
      }
      LODWORD(v25) = a3[41];
      LODWORD(v26) = a3[42];
      LODWORD(v27) = a3[43];
      LODWORD(v28) = a3[44];
      LODWORD(v29) = a3[45];
      fprintf( v7,  "    keys: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n",  v31 / (double)v32,  (double)v25 * 100.0 / (double)v32,  (double)v26 * 100.0 / (double)v32,  (double)v27 * 100.0 / (double)v32,  (double)v28 * 100.0 / (double)v32,  (double)v29 * 100.0 / (double)v32);
      snprintf(__str, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 20LL) / 5u);
      snprintf((char *)&v63, 0x10uLL, "<%d", 2 * *(_DWORD *)(*(void *)(a2 + 392) + 20LL) / 5u);
      snprintf((char *)&v64, 0x10uLL, "<%d", 3 * *(_DWORD *)(*(void *)(a2 + 392) + 20LL) / 5u);
      snprintf((char *)&v65, 0x10uLL, "<%d", 4 * *(_DWORD *)(*(void *)(a2 + 392) + 20LL) / 5u);
      snprintf((char *)&v66, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 20LL));
      snprintf((char *)&v67, 0x10uLL, "=%d", *(_DWORD *)(*(void *)(a2 + 392) + 20LL));
      fprintf( v7,  "  values: %9s %9s %9s %9s %9s %9s\n",  __str,  (const char *)&v63,  (const char *)&v64,  (const char *)&v65,  (const char *)&v66,  (const char *)&v67);
      fprintf(v7, "  values: %9d %9d %9d %9d %9d %9d\n", a3[46], a3[47], a3[48], a3[49], a3[50], a3[51]);
      LODWORD(v38) = a3[46];
      double v39 = (double)v38 * 100.0;
      unsigned int v40 = a3[4];
      if (v40 <= 1) {
        unsigned int v41 = 1;
      }
      else {
        unsigned int v41 = a3[4];
      }
      double v42 = v39 / (double)v41;
      LODWORD(v33) = a3[47];
      double v43 = (double)v33 * 100.0 / (double)v41;
      LODWORD(v34) = a3[48];
      LODWORD(v35) = a3[49];
      double v44 = (double)v34 * 100.0 / (double)v41;
      double v45 = (double)v35 * 100.0;
      double v46 = (double)v40;
      if (!v40) {
        double v46 = 1.0;
      }
      LODWORD(v36) = a3[50];
      LODWORD(v37) = a3[51];
      fprintf( v7,  "  values: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n",  v42,  v43,  v44,  v45 / v46,  (double)v36 * 100.0 / v46,  (double)v37 * 100.0 / v46);
      fprintf( v7,  "capacity: all    %llu / %llu => %.2f %% used\n",  *((void *)a3 + 7),  *((void *)a3 + 6),  (double)*((unint64_t *)a3 + 7) * 100.0 / (double)*((unint64_t *)a3 + 6));
      if (a4 == 4)
      {
        fprintf(v7, "capacity: nodes  %llu / %llu => %.2f %% used\n");
      }

      else
      {
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[5], a3[6], a3[7], a3[8], a3[9], a3[10]);
        LODWORD(v47) = a3[5];
        LODWORD(v48) = a3[6];
        unsigned int v49 = a3[1] + *a3;
        LODWORD(v50) = a3[7];
        LODWORD(v51) = a3[8];
        LODWORD(v52) = a3[9];
        LODWORD(v53) = a3[10];
        fprintf( v7,  "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n",  (double)v47 * 100.0 / (double)v49,  (double)v48 * 100.0 / (double)v49,  (double)v50 * 100.0 / (double)v49,  (double)v51 * 100.0 / (double)v49,  (double)v52 * 100.0 / (double)v49,  (double)v53 * 100.0 / (double)v49);
        fprintf( v7,  "capacity: nodes  %llu / %llu => %.2f %% used\n",  *((void *)a3 + 12),  *((void *)a3 + 11),  (double)*((unint64_t *)a3 + 12) * 100.0 / (double)*((unint64_t *)a3 + 11));
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[16], a3[17], a3[18], a3[19], a3[20], a3[21]);
        fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n");
      }

      uint64_t result = fprintf( v7,  "capacity: leaves %llu / %llu => %.2f %% used\n",  *((void *)a3 + 17),  *((void *)a3 + 16),  (double)*((unint64_t *)a3 + 17) * 100.0 / (double)*((unint64_t *)a3 + 16));
      if (a4 != 4)
      {
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[26], a3[27], a3[28], a3[29], a3[30], a3[31]);
        LODWORD(v54) = a3[26];
        LODWORD(v55) = a3[27];
        LODWORD(v56) = a3[1];
        double v57 = (double)v56;
        LODWORD(v58) = a3[28];
        LODWORD(v59) = a3[29];
        LODWORD(v60) = a3[30];
        LODWORD(v61) = a3[31];
        return fprintf( v7,  "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n",  (double)v54 * 100.0 / v57,  (double)v55 * 100.0 / v57,  (double)v58 * 100.0 / v57,  (double)v59 * 100.0 / v57,  (double)v60 * 100.0 / v57,  (double)v61 * 100.0 / v57);
      }
    }
  }

  return result;
}

uint64_t sub_10000FB54(void *a1, uint64_t a2, int a3, int a4)
{
  return sub_10000EF38(0LL, a1, a2, a3, a4);
}

uint64_t sub_10000FB6C( char *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t, unint64_t, void, uint64_t, void), uint64_t a4)
{
  uint64_t v40 = a4;
  unsigned int v41 = a3;
  uint64_t v6 = *((void *)a1 + 1);
  if (!v6) {
    uint64_t v6 = *(void *)(*(void *)a1 + 392LL);
  }
  __chkstk_darwin();
  unint64_t v8 = (uint64_t *)((char *)&v40 - v7);
  bzero((char *)&v40 - v7, v9);
  uint64_t v45 = 0LL;
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v44 = -1431655766;
  unsigned __int16 v43 = -21846;
  unsigned __int16 v42 = 0;
  sub_10003CF10((uint64_t)a1, 1);
  uint64_t v10 = sub_100028B04((uint64_t)a1, &v44);
  if ((_DWORD)v10)
  {
    uint64_t v11 = v10;
    sub_10003D514((uint64_t)a1, 1);
    return v11;
  }

  int v12 = sub_100013EEC(v44, 0x10uLL);
  if (!v12)
  {
    sub_10003D514((uint64_t)a1, 1);
    return 12LL;
  }

  int v13 = v12;
  void *v12 = a1;
  *((_WORD *)v12 + 4) = 0;
  sub_10003DC28(a1);
  unsigned __int16 v14 = 0;
  while (1)
  {
    while (1)
    {
      uint64_t v15 = v14;
      unint64_t v16 = &v13[2 * v14];
      if (sub_100039664(*v16) <= a2)
      {
        int v21 = (uint64_t *)*v16;
        goto LABEL_16;
      }

      double v17 = (char *)&v13[2 * v15];
      unsigned int v20 = *((unsigned __int16 *)v17 + 4);
      __int128 v19 = v17 + 8;
      unsigned int v18 = v20;
      int v21 = (uint64_t *)*v16;
      uint64_t v22 = *(void *)(*v16 + 56);
      if (*(_DWORD *)(v22 + 36) > v20) {
        break;
      }
LABEL_16:
      sub_10001E478(v21, 1);
      uint64_t *v16 = 0LL;
      unsigned __int16 v14 = v15 - 1;
      if ((((_WORD)v15 - 1) & 0x8000) != 0)
      {
LABEL_27:
        uint64_t v11 = 0LL;
        goto LABEL_29;
      }
    }

    if ((*(_WORD *)(v22 + 32) & 2) != 0) {
      break;
    }
    uint64_t v23 = sub_10001E938((uint64_t)v21, v18, v8);
    if ((_DWORD)v23)
    {
      uint64_t v11 = v23;
      sub_10003965C(*v16);
      sub_100013D94("%s:%d: %s node 0x%llx (level %d): error getting index %d child oid: %d\n");
      goto LABEL_29;
    }

    ++*v19;
    unsigned __int16 v24 = v15 + 1;
    if (v44 <= (__int16)v24)
    {
      uint64_t v36 = *((void *)a1 + 1);
      if (v36) {
        unint64_t v37 = (const char *)(v36 + 3992);
      }
      else {
        unint64_t v37 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
      }
      unint64_t v38 = (char *)&v13[2 * (__int16)v24];
      uint64_t v39 = sub_10003965C(*((void *)v38 - 2));
      sub_100013D94( "%s:%d: %s node 0x%llx (level %d) index %d: more levels than expected\n",  "btree_check_recent_sanity",  769,  v37,  v39,  *(unsigned __int16 *)(*(void *)(*((void *)v38 - 2) + 56LL) + 34LL),  *((unsigned __int16 *)v38 - 4));
      uint64_t v11 = 22LL;
      goto LABEL_29;
    }

    unint64_t v25 = (char *)&v13[2 * (__int16)v24];
    *((_WORD *)v25 + 4) = 0;
    uint64_t v26 = (__int16)v24 - 1LL;
    uint64_t v27 = sub_10001E24C(a1, v8, 0LL, 2, *(_WORD *)(*(void *)(v13[2 * v26] + 56LL) + 34LL) - 1, 0LL, v25);
    unsigned __int16 v14 = v24;
    if ((_DWORD)v27)
    {
      uint64_t v11 = v27;
      sub_10003965C(v13[2 * v26]);
      sub_100013D94("%s:%d: %s node 0x%llx (level %d): error getting index %d child: %d\n");
      goto LABEL_29;
    }

    if ((v24 & 0x8000) != 0) {
      goto LABEL_27;
    }
  }

  if (!v41) {
    goto LABEL_16;
  }
  unsigned int v28 = 0;
  while (1)
  {
    uint64_t v29 = sub_10001E654((uint64_t)v21, (unsigned __int16)v28, &v46, &v43);
    if ((_DWORD)v29 || (uint64_t v29 = sub_10001E764((void *)*v16, (unsigned __int16)v28, &v45, (__int16 *)&v42), (_DWORD)v29))
    {
      uint64_t v11 = v29;
      sub_10003965C(*v16);
      sub_100013D94("%s:%d: %s node 0x%llx (level %d): error getting index %d key/val: %d\n");
      goto LABEL_29;
    }

    uint64_t v30 = v41(v6, v40, a2, v46, v43, v45, v42);
    if ((_DWORD)v30) {
      break;
    }
    ++v28;
    int v21 = (uint64_t *)*v16;
    if (v28 >= *(_DWORD *)(*(void *)(*v16 + 56) + 36LL)) {
      goto LABEL_16;
    }
  }

  uint64_t v11 = v30;
LABEL_29:
  unsigned int v31 = v44;
  if ((((_WORD)v44 - 1) & 0x8000) == 0)
  {
    unsigned __int16 v32 = v44 - 1;
    do
    {
      unint64_t v33 = (uint64_t *)v13[2 * v32];
      if (v33) {
        sub_10001E478(v33, 1);
      }
      int v34 = (__int16)v32--;
    }

    while (v34 > 0);
    unsigned int v31 = v44;
  }

  sub_100014004(v13, 16LL * v31);
  return v11;
}

BOOL sub_100010058(uint64_t a1)
{
  if (a1) {
    return *(_BYTE *)(a1 + 637) != 0;
  }
  else {
    return byte_100070548 & 1;
  }
}

uint64_t sub_10001007C( unsigned int a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5)
{
  *(void *)(a5 + 208) = 0LL;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  uint64_t v5 = 22LL;
  *(_OWORD *)a5 = 0u;
  if (a1 - 65537 < 0xFFFF0FFF || !a2) {
    return v5;
  }
  unint64_t v6 = 8 * a1;
  unint64_t v7 = a1 - 40LL;
  *(void *)(a5 + 88) = v7 >> 5;
  *(void *)(a5 + 96) = v7 >> 3;
  *(void *)(a5 + 8) = a1;
  *(void *)(a5 + 16) = a2;
  unint64_t v8 = (a2 + v6 - 1) / v6;
  uint64_t v9 = (v7 >> 5) - 1;
  unint64_t v10 = (v9 + v8) / (v7 >> 5);
  *(void *)(a5 + 24) = v8;
  *(void *)(a5 + 32) = v10;
  uint64_t v11 = (v7 >> 3) - 1;
  unint64_t v12 = (v11 + v10) / (v7 >> 3);
  if (v12 == 1) {
    unint64_t v13 = 0LL;
  }
  else {
    unint64_t v13 = (v11 + v10) / (v7 >> 3);
  }
  *(void *)(a5 + 40) = v13;
  *(void *)(a5 + 48) = a3;
  unint64_t v14 = (a3 + v6 - 1) / v6;
  unint64_t v15 = (v9 + v14) / (v7 >> 5);
  *(void *)(a5 + 56) = v14;
  *(void *)(a5 + 64) = v15;
  unint64_t v16 = (v11 + v15) / (v7 >> 3);
  if (v16 == 1) {
    unint64_t v17 = 0LL;
  }
  else {
    unint64_t v17 = v16;
  }
  *(void *)(a5 + 72) = v17;
  *(void *)(a5 + 80) = v6;
  uint64_t v18 = 3 * (v10 + v8 + v14 + v15 + v13 + v17);
  *(void *)(a5 + 104) = v18;
  unint64_t v19 = (unint64_t)(v18 + 63) >> 6;
  unint64_t v20 = (a1 - 1LL + 8 * v19) / a1;
  if (HIDWORD(v20)) {
    return 27LL;
  }
  *(void *)(a5 + 112) = v20;
  *(void *)(a5 + 120) = 16LL;
  if (v20 < 0x1000)
  {
    uint64_t v21 = 16 * v20;
    goto LABEL_14;
  }

  if (v20 >> 13) {
    return 27LL;
  }
  uint64_t v21 = 65534LL;
LABEL_14:
  *(void *)(a5 + 128) = v21;
  uint64_t v22 = (2 * v21 + 6) & 0x7FFFFFFFFFFFFFF8LL;
  if (v13) {
    unint64_t v10 = v12;
  }
  if (v17) {
    unint64_t v23 = v16;
  }
  else {
    unint64_t v23 = v15;
  }
  unint64_t v24 = ((2 * v20 + 6) & 0x7FFFFFFFFFFFFFF8LL) + 8 * (v20 + v10 + v23) + v22 + 2520;
  if (v24 > 0x100000) {
    return 27LL;
  }
  *(void *)(a5 + 136) = v24;
  unint64_t v27 = 0x200000 / a1;
  uint64_t v28 = 15LL;
  if (a2 >= 0x100000) {
    uint64_t v29 = 15LL;
  }
  else {
    uint64_t v29 = 31LL;
  }
  if (a2 >= 0x100000) {
    char v30 = 4;
  }
  else {
    char v30 = 5;
  }
  if (a2 < 0x40000)
  {
    uint64_t v29 = 63LL;
    char v30 = 6;
  }

  unint64_t v31 = (v29 + a2) >> v30;
  unint64_t v32 = v26 - 1;
  unint64_t v33 = (v26 - 1 + v31) / v26;
  if (v33 >= v27) {
    unint64_t v33 = 0x200000 / a1;
  }
  if (v33 == 2) {
    unint64_t v33 = 3LL;
  }
  if (a3 >= 0x100000)
  {
    char v34 = 4;
  }

  else
  {
    uint64_t v28 = 31LL;
    char v34 = 5;
  }

  if (a3 < 0x40000)
  {
    uint64_t v28 = 63LL;
    char v34 = 6;
  }

  unint64_t v35 = (v32 + ((v28 + a3) >> v34)) / v26;
  if (v35 >= v27) {
    unint64_t v35 = 0x200000 / a1;
  }
  if (v35 == 2) {
    unint64_t v35 = 3LL;
  }
  *(void *)(a5 + 152) = v33;
  *(void *)(a5 + 160) = v35;
  unint64_t v36 = a3 + a2;
  if ((a3 + a2) >> 18)
  {
    if (v36 >> 20) {
      unint64_t v19 = (unint64_t)(v18 + 15) >> 4;
    }
    else {
      unint64_t v19 = (unint64_t)(v18 + 31) >> 5;
    }
  }

  unint64_t v37 = (v32 + v19) / v26;
  if (v37 >= v27) {
    unint64_t v37 = 0x200000 / a1;
  }
  if (v37 == 2) {
    unint64_t v37 = 3LL;
  }
  *(void *)(a5 + 144) = v37;
  uint64_t v38 = v24 / a1;
  uint64_t v39 = v38 - 1;
  uint64_t v40 = 8LL;
  if (v33 < 8) {
    uint64_t v40 = v33;
  }
  *(void *)(a5 + 192) = 4LL;
  *(void *)(a5 + 200) = v40;
  if (a4)
  {
    if (a4 > 0x64) {
      return 22LL;
    }
  }

  else
  {
    int v41 = v36 * a1;
    unint64_t v42 = (v36 * a1) >> 29;
    if ((v41 & 0x1FFFFFFF) != 0) {
      unint64_t v43 = v42 + 1;
    }
    else {
      unint64_t v43 = v42;
    }
    if (v43 >= 0x64) {
      a4 = 100;
    }
    else {
      a4 = v43;
    }
  }

  *(void *)(a5 + 184) = a4;
  uint64_t v44 = v40 * a4;
  uint64_t v45 = 2LL;
  if (a3) {
    uint64_t v45 = 3LL;
  }
  uint64_t v46 = v45 + v33 + v35 + v37 + v38 + v39 + 8 * v44;
  *(void *)(a5 + 168) = 4LL
                        * ((unsigned __int16)(v46 + (unsigned __int16)(a1 - 40) / 0x28u - 1)
                         / ((unsigned __int16)(a1 - 40)
                          / 0x28u))
                        + 4;
  *(void *)(a5 + 176) = 4 * v46;
  *(void *)(a5 + 208) = 0LL;
  uint64_t v5 = 0LL;
  if (a3)
  {
    unint64_t v47 = (unint64_t)&_mh_execute_header;
    if (0x800000000uLL / a1 < a2) {
      unint64_t v47 = 0x200000000LL;
    }
    unint64_t v48 = v47 / a1;
    if (v48 >= a2 / 5) {
      unint64_t v48 = a2 / 5;
    }
    *(void *)(a5 + 208) = v48;
  }

  return v5;
}

uint64_t sub_100010420(uint64_t a1, unsigned int a2, unint64_t a3, int a4, int a5, uint64_t **a6)
{
  *(void *)&__int128 v13 = 0LL;
  __int128 v14 = 0u;
  uint64_t v18 = 0LL;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v15 = 0u;
  unint64_t v12 = sub_10001AC0C;
  DWORD2(v13) = 33;
  HIDWORD(v13) = a4;
  uint64_t result = sub_100027CC4(a1, a2, a3, 0LL, 0, (uint64_t)&v12, 0LL, a6);
  if ((_DWORD)result == 92 && a5)
  {
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    uint64_t v18 = 0LL;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v15 = 0u;
    unint64_t v12 = sub_10001AC0C;
    HIDWORD(v13) = a4;
    uint64_t result = sub_100027CC4(a1, 0, a3, 0LL, 0, (uint64_t)&v12, 0LL, a6);
    if (!(_DWORD)result)
    {
      sub_100013CBC( "%s:%d: %s found mapping tree with old subtype\n",  "nx_get_evict_mapping_tree",  544,  (const char *)(*(void *)(a1 + 384) + 208LL));
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10001054C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 22LL;
  }
  int v5 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 32) = 1112758350;
  *(_DWORD *)(a1 + 36) = v5;
  *(void *)(a1 + 1264) = 0LL;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(a1 + 56) = xmmword_10005B7B0;
  uint64_t v6 = *(void *)(a3 + 32);
  *(void *)(a1 + 88) = 1024LL;
  *(void *)(a1 + 96) = v6;
  uuid_copy((unsigned __int8 *)(a1 + 72), (const unsigned __int8 *)(a3 + 64));
  unint64_t v7 = (const unsigned __int8 *)(a3 + 80);
  if (uuid_is_null(v7)) {
    return 0LL;
  }
  uuid_copy((unsigned __int8 *)(a1 + 1280), v7);
  uint64_t result = 0LL;
  *(void *)(a1 + 64) |= 0x100uLL;
  return result;
}

uint64_t sub_1000105EC(uint64_t a1, unsigned int *a2)
{
  if (!a2) {
    return 22LL;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  unsigned int v4 = *a2;
  *(_DWORD *)(a1 + 648) = *a2;
  *(_DWORD *)(a1 + 652) = *(_DWORD *)(v3 + 36) / v4;
  uint64_t v5 = *((void *)a2 + 3);
  *(void *)(a1 + 376) = v3;
  *(void *)(a1 + 384) = v5;
  LODWORD(v5) = a2[11];
  *(_BYTE *)(a1 + 627) = a2[10] != 0;
  *(_BYTE *)(a1 + 628) = (_DWORD)v5 != 0;
  LODWORD(v5) = a2[13];
  *(_BYTE *)(a1 + 629) = a2[12] != 0;
  *(_BYTE *)(a1 + 631) = (_DWORD)v5 != 0;
  LODWORD(v5) = a2[15];
  *(_BYTE *)(a1 + 632) = a2[14] != 0;
  *(_BYTE *)(a1 + 633) = (_DWORD)v5 != 0;
  *(void *)(a1 + 392) = *(void *)a1;
  sub_1000139BC((pthread_mutex_t *)(a1 + 656));
  sub_1000139BC((pthread_mutex_t *)(a1 + 848));
  *(_OWORD *)(a1 + 912) = 0u;
  sub_1000139C8((pthread_rwlock_t *)(a1 + 928));
  *(void *)(a1 + 1128) = 0LL;
  *(void *)(a1 + 1336) = 0LL;
  *(_BYTE *)(a1 + 635) = 0;
  sub_1000139BC((pthread_mutex_t *)(a1 + 1856));
  sub_1000139C8((pthread_rwlock_t *)(a1 + 1136));
  sub_1000139BC((pthread_mutex_t *)(a1 + 736));
  *(void *)(a1 + 812) = 0LL;
  *(void *)(a1 + 800) = 0LL;
  *(_WORD *)(a1 + 808) = 0;
  sub_1000139BC((pthread_mutex_t *)(a1 + 504));
  sub_1000139D4((pthread_cond_t *)(a1 + 568));
  return 0LL;
}

uint64_t sub_100010730(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 720);
  if (v2 && !*(_DWORD *)(*(void *)a1 + 912LL)) {
    sub_100038824(v2);
  }
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 928));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 1136));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 848));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 656));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1856));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 736));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 504));
  sub_1000139DC((pthread_cond_t *)(a1 + 568));
  return 0LL;
}

uint64_t sub_1000107A8(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  if ((*(_BYTE *)(v2 + 65) & 1) == 0) {
    return 0LL;
  }
  uint64_t v6 = sub_100014044(*(unsigned int *)(v2 + 36));
  memcpy(v6, a2, *(unsigned int *)(*(void *)(a1 + 376) + 36LL));
  v6[1295] |= 1u;
  sub_10003E984(a1, (uint64_t)v6, *(_DWORD *)(*(void *)(a1 + 376) + 36LL), v7, v8);
  uint64_t v9 = sub_100051F74( *(void *)(a1 + 384),  0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36LL))));
  sub_100014004(v6, *(unsigned int *)(*(void *)(a1 + 376) + 36LL));
  return v9;
}

uint64_t sub_100010860(uint64_t a1, size_t a2, uint64_t a3)
{
  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  unint64_t v43 = 0LL;
  unint64_t v42 = 0LL;
  uint64_t v6 = sub_100044238((void *)a1, (uint64_t *)&v45);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)(a1 + 400);
    if (!v8 || !*(_DWORD *)(v8 + 76))
    {
      LODWORD(v9) = 831;
      sub_100013D94("%s:%d: %s failed to get spaceman oid %lld for checkpoint %s traverse: %d\n");
      goto LABEL_9;
    }

    return v7;
  }

  uint64_t v7 = sub_100045674(a1, a2, (uint64_t)v45, a3);
  sub_100038824(v45);
  if ((_DWORD)v7)
  {
    uint64_t v10 = *(void *)(a1 + 400);
    if (!v10 || !*(_DWORD *)(v10 + 76))
    {
      LODWORD(v9) = 838;
      sub_100013D94("%s:%d: %s spaceman checkpoint %s traverse failed: %d\n");
      goto LABEL_9;
    }

    return v7;
  }

  uint64_t v13 = *(void *)(a1 + 376);
  unint64_t v14 = *(void *)(v13 + 160);
  if (v14 && !*(_DWORD *)(a1 + 728))
  {
    uint64_t v17 = sub_10003B574( *(void *)(a1 + 392),  0x40000000u,  v14,  (int *)&xmmword_10005B9F8,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v43);
    if ((_DWORD)v17)
    {
      uint64_t v7 = v17;
      uint64_t v18 = *(void *)(a1 + 400);
      if (!v18 || !*(_DWORD *)(v18 + 76))
      {
        LODWORD(v9) = 848;
        sub_100013D94("%s:%d: %s failed to get omap for checkpoint %s traverse: %d\n");
        goto LABEL_9;
      }

      return v7;
    }

    uint64_t v7 = sub_100040FB0(a1, a2, (uint64_t)v43, a3);
    sub_100038824(v43);
    if ((_DWORD)v7)
    {
      uint64_t v20 = *(void *)(a1 + 400);
      if (!v20 || !*(_DWORD *)(v20 + 76))
      {
        LODWORD(v9) = 854;
        sub_100013D94("%s:%d: %s omap checkpoint %s traverse failed: %d\n");
        goto LABEL_9;
      }

      return v7;
    }

    uint64_t v13 = *(void *)(a1 + 376);
  }

  if (*(void *)(v13 + 168))
  {
    uint64_t v15 = sub_100010F28((void *)a1, &v44);
    if ((_DWORD)v15)
    {
      uint64_t v7 = v15;
      uint64_t v16 = *(void *)(a1 + 400);
      if (!v16 || !*(_DWORD *)(v16 + 76))
      {
        LODWORD(v9) = 867;
        sub_100013D94("%s:%d: %s failed to get reaper for checkpoint %s traverse: %d\n");
        goto LABEL_9;
      }

      return v7;
    }

    uint64_t v7 = sub_100010FAC((uint64_t *)a1, a2, (uint64_t)v44, a3);
    sub_100038824((uint64_t *)v44);
    if ((_DWORD)v7)
    {
      uint64_t v19 = *(void *)(a1 + 400);
      if (!v19 || !*(_DWORD *)(v19 + 76))
      {
        LODWORD(v9) = 874;
        sub_100013D94("%s:%d: %s nx reaper checkpoint %s traverse failed: %d\n");
        goto LABEL_9;
      }

      return v7;
    }

    uint64_t v13 = *(void *)(a1 + 376);
  }

  if (*(_DWORD *)(v13 + 180))
  {
    for (unint64_t i = 0LL; i < *(unsigned int *)(v13 + 180); ++i)
    {
      unint64_t v22 = *(void *)(v13 + 8 * i + 184);
      if (v22)
      {
        uint64_t v23 = sub_10003B574( *(void *)(a1 + 392),  0,  v22,  (int *)&xmmword_10005B954,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v42);
        if ((_DWORD)v23)
        {
          uint64_t v7 = v23;
          uint64_t v28 = *(void *)(a1 + 400);
          if (v28 && *(_DWORD *)(v28 + 76)) {
            return v7;
          }
          uint64_t v29 = "<UNKNOWN>";
          if ((_DWORD)a3 == 2) {
            uint64_t v29 = "FIXUP";
          }
          if ((_DWORD)a3 == 1) {
            uint64_t v29 = "START";
          }
          uint64_t v36 = (uint64_t)v29;
          uint64_t v37 = v23;
          unint64_t v34 = i;
          unint64_t v35 = v22;
          uint64_t v33 = *(void *)(a1 + 384) + 208LL;
          uint64_t v9 = 898LL;
          unint64_t v27 = "%s:%d: %s failed to get fs[%d] oid %lld for checkpoint %s traverse: %d\n";
LABEL_58:
          sub_100013D94(v27, "nx_checkpoint_traverse", v9, v33, v34, v35, v36, v37, v38);
LABEL_9:
          uint64_t v11 = *(void *)(a1 + 400);
          if (v11)
          {
LABEL_10:
            *(_DWORD *)(v11 + 76) = v9;
            ++*(_WORD *)(v11 + 80);
          }

          return v7;
        }

        uint64_t v7 = sub_10002F178(a1, a2, (uint64_t)v42, a3);
        sub_100038824(v42);
        if ((_DWORD)v7)
        {
          uint64_t v30 = *(void *)(a1 + 400);
          if (!v30 || !*(_DWORD *)(v30 + 76))
          {
            LODWORD(v9) = 904;
            sub_100013D94("%s:%d: %s fs[%d] checkpoint %s traverse failed: %d\n");
            goto LABEL_9;
          }

          return v7;
        }

        uint64_t v13 = *(void *)(a1 + 376);
      }
    }
  }

  v41[0] = 0LL;
  v41[1] = 0LL;
  uint64_t v40 = 0LL;
  unsigned int v39 = 0;
  uint64_t v7 = sub_10003A3CC(*(_DWORD *)(*(void *)(a1 + 376) + 176LL), &v39, (uint64_t)v41);
  HIDWORD(v41[0]) = 255;
  if ((_DWORD)v7
    || (uint64_t v7 = sub_10003B574( *(void *)(a1 + 392),  v39,  *(void *)(*(void *)(a1 + 376) + 1344LL),  (int *)v41,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v40),  (_DWORD)v7))
  {
    uint64_t v24 = *(void *)(a1 + 400);
    if (!v24 || !*(_DWORD *)(v24 + 76))
    {
      uint64_t v25 = *(void *)(a1 + 376);
      unint64_t v26 = "<UNKNOWN>";
      if ((_DWORD)a3 == 2) {
        unint64_t v26 = "FIXUP";
      }
      if ((_DWORD)a3 == 1) {
        unint64_t v26 = "START";
      }
      uint64_t v37 = (uint64_t)v26;
      uint64_t v38 = v7;
      unint64_t v35 = *(unsigned int *)(v25 + 176);
      uint64_t v36 = 255LL;
      uint64_t v33 = *(void *)(a1 + 384) + 208LL;
      unint64_t v34 = *(void *)(v25 + 1344);
      uint64_t v9 = 925LL;
      unint64_t v27 = "%s:%d: %s unable to get test object 0x%llx of type 0x%x/0x%x for checkpoint %s traverse: %d\n";
      goto LABEL_58;
    }
  }

  else
  {
    uint64_t v7 = sub_10003E850(a1, a2, (uint64_t)v40, a3);
    sub_100038824(v40);
    if ((_DWORD)v7)
    {
      uint64_t v31 = *(void *)(a1 + 400);
      if (!v31 || !*(_DWORD *)(v31 + 76))
      {
        unint64_t v32 = "<UNKNOWN>";
        if ((_DWORD)a3 == 2) {
          unint64_t v32 = "FIXUP";
        }
        if ((_DWORD)a3 == 1) {
          unint64_t v32 = "START";
        }
        LODWORD(v9) = 931;
        sub_100013D94( "%s:%d: %s failed to checkpoint %s traverse test object 0x%llx of type 0x%x/0x%x: %d\n",  "nx_checkpoint_traverse",  931,  (const char *)(*(void *)(a1 + 384) + 208LL),  v32,  *(void *)(*(void *)(a1 + 376) + 1344LL),  *(_DWORD *)(*(void *)(a1 + 376) + 176LL),  255,  v7);
        uint64_t v11 = *(void *)(a1 + 400);
        if (v11) {
          goto LABEL_10;
        }
      }
    }
  }

  return v7;
}

uint64_t sub_100010F28(void *a1, char **a2)
{
  uint64_t v3 = (char *)a1[53];
  *a2 = v3;
  if (v3) {
    goto LABEL_2;
  }
  uint64_t result = sub_10003B574(a1[49], 0x80000000LL, *(void *)(a1[47] + 168LL), &xmmword_10005B790, 0LL, 0LL, 0LL, 0LL, a2);
  if (!(_DWORD)result)
  {
    a1[53] = *a2;
    uint64_t v3 = *a2;
LABEL_2:
    sub_10003DC28(v3);
    return 0LL;
  }

  return result;
}

uint64_t sub_100010FAC(uint64_t *a1, size_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v6 = *(void *)(a3 + 376);
  unsigned int v39 = 0LL;
  if ((_DWORD)a4 == 2)
  {
    uint64_t v7 = sub_10003E7D8(a3);
LABEL_5:
    uint64_t v8 = v7;
    if ((_DWORD)v7) {
      return v8;
    }
    goto LABEL_6;
  }

  if ((_DWORD)a4 == 1)
  {
    uint64_t v7 = sub_10003E754((unsigned int *)a3);
    goto LABEL_5;
  }

LABEL_6:
  uint64_t v40 = (char *)0xAAAAAAAAAAAAAAAALL;
  int v41 = (unsigned int *)0xAAAAAAAAAAAAAAAALL;
  if (*(void *)(v6 + 88) && sub_1000398D0(*(_DWORD *)(v6 + 72)))
  {
    uint64_t v8 = 0LL;
    if ((*(_DWORD *)(v6 + 104) & 0x10) == 0 && (*(_DWORD *)(v6 + 104) & 6) != 2)
    {
      uint64_t v9 = sub_1000116D0( a1,  *(_DWORD *)(v6 + 72),  *(_DWORD *)(v6 + 76),  *(void *)(v6 + 80),  *(void *)(v6 + 88),  &v39,  &v40);
      if ((_DWORD)v9)
      {
        uint64_t v8 = v9;
        uint64_t v10 = a1[50];
        if (!v10 || !*(_DWORD *)(v10 + 76)) {
          sub_100013D94( "%s:%d: %s failed to get object oid %lld: %d\n",  "nx_reaper_checkpoint_traverse",  1207,  (const char *)(a1[48] + 208),  *(void *)(v6 + 88),  v9);
        }
      }

      else
      {
        if (v39) {
          unint64_t v35 = v39;
        }
        else {
          unint64_t v35 = a1;
        }
        uint64_t v8 = sub_10003E850((uint64_t)v35, a2, (uint64_t)v40, v4);
        sub_100038824((uint64_t *)v40);
      }

      if (v39)
      {
        sub_100038824(v39);
        unsigned int v39 = 0LL;
      }
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  if ((_DWORD)v8) {
    return v8;
  }
  unint64_t v11 = *(void *)(v6 + 48);
  if (!v11) {
    return v8;
  }
  int v37 = *(_DWORD *)(v6 + 68);
  unsigned int v38 = v4;
  do
  {
    uint64_t v12 = sub_10003B574(a1[49], 0x80000000, v11, (int *)&xmmword_10005B7A0, 0LL, 0LL, 0LL, 0LL, (uint64_t *)&v41);
    if ((_DWORD)v12)
    {
      uint64_t v8 = v12;
      uint64_t v33 = a1[50];
      if (!v33 || !*(_DWORD *)(v33 + 76)) {
        sub_100013D94( "%s:%d: %s failed to get reap list object oid %lld: %d\n",  "nx_reaper_checkpoint_traverse",  1227,  (const char *)(a1[48] + 208),  v11,  v12);
      }
      return v8;
    }

    uint64_t v13 = *((void *)v41 + 47);
    if ((_DWORD)v4 == 2)
    {
      uint64_t v14 = sub_10003E7D8((uint64_t)v41);
      goto LABEL_23;
    }

    if ((_DWORD)v4 == 1)
    {
      uint64_t v14 = sub_10003E754(v41);
LABEL_23:
      uint64_t v8 = v14;
      goto LABEL_25;
    }

    uint64_t v8 = 0LL;
LABEL_25:
    unint64_t v11 = *(void *)(v13 + 32);
    if ((_DWORD)v8) {
      goto LABEL_56;
    }
    unsigned int v15 = *(_DWORD *)(v13 + 52);
    if (v15 == -1) {
      goto LABEL_56;
    }
    unsigned int v16 = -1;
    while (1)
    {
      unsigned int v17 = *(_DWORD *)(v13 + 40LL * v15 + 64);
      if (v17 != -1 && v17 > *(_DWORD *)(v13 + 44)) {
        break;
      }
      uint64_t v18 = v13 + 40LL * v15;
      int v21 = *(_DWORD *)(v18 + 72);
      uint64_t v20 = (int *)(v18 + 72);
      int v19 = v21;
      if ((v21 != *(_DWORD *)(v6 + 72) || *(void *)(v13 + 40LL * v15 + 88) != *(void *)(v6 + 88))
        && (v16 == -1
         || v19 != *(_DWORD *)(v13 + 40LL * v16 + 72)
         || *(void *)(v13 + 64 + 40LL * v15 + 24) != *(void *)(v13 + 64 + 40LL * v16 + 24)))
      {
        uint64_t v8 = 0LL;
        if ((*(_DWORD *)(v13 + 40LL * v15 + 68) & 0x10) != 0 || (*(_DWORD *)(v13 + 40LL * v15 + 68) & 6) == 2) {
          goto LABEL_49;
        }
        if (sub_1000398D0(v19))
        {
          uint64_t v22 = v13 + 40LL * v15;
          unint64_t v24 = *(void *)(v22 + 88);
          uint64_t v23 = (void *)(v22 + 88);
          uint64_t v25 = sub_1000116D0(a1, *v20, *((_DWORD *)v23 - 3), *(v23 - 1), v24, &v39, &v40);
          if ((_DWORD)v25)
          {
            uint64_t v8 = v25;
            uint64_t v26 = a1[50];
            if (!v26 || !*(_DWORD *)(v26 + 76)) {
              sub_100013D94( "%s:%d: %s failed to get object oid %lld: %d\n",  "nx_reaper_checkpoint_traverse",  1287,  (const char *)(a1[48] + 208),  *v23,  v25);
            }
          }

          else
          {
            if (v39) {
              unint64_t v27 = v39;
            }
            else {
              unint64_t v27 = a1;
            }
            uint64_t v8 = sub_10003E850((uint64_t)v27, a2, (uint64_t)v40, v38);
            sub_100038824((uint64_t *)v40);
          }

          if (v39)
          {
            sub_100038824(v39);
            unsigned int v39 = 0LL;
          }

          goto LABEL_49;
        }
      }

      uint64_t v8 = 0LL;
LABEL_49:
      if (!(_DWORD)v8)
      {
        unsigned int v16 = v15;
        unsigned int v15 = v17;
        if (v17 != -1) {
          continue;
        }
      }

      goto LABEL_56;
    }

    uint64_t v28 = a1[50];
    if (!v28 || !*(_DWORD *)(v28 + 76)) {
      sub_100013D94( "%s:%d: %s Invalid reap list entry nrl_entries[%d].nrle_next = %d\n",  "nx_reaper_checkpoint_traverse",  1249,  (const char *)(a1[48] + 208),  v15,  v17);
    }
    sub_100038824((uint64_t *)v41);
    uint64_t v8 = sub_100005194((uint64_t)a1);
LABEL_56:
    int v29 = *(_DWORD *)(v6 + 68);
    if (!v29) {
      goto LABEL_68;
    }
    int v30 = v37 - 1;
    if (v11 && v37 == 1)
    {
      uint64_t v31 = a1[50];
      LODWORD(v4) = v38;
      if (!v31 || !*(_DWORD *)(v31 + 76)) {
        sub_100013D94( "%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n",  "nx_reaper_checkpoint_traverse",  1303,  (const char *)(a1[48] + 208),  v29);
      }
      uint64_t v8 = sub_100005194((uint64_t)a1);
      int v37 = 0;
      goto LABEL_69;
    }

    --v37;
    if (v11)
    {
LABEL_68:
      LODWORD(v4) = v38;
      goto LABEL_69;
    }

    LODWORD(v4) = v38;
    if (v30)
    {
      uint64_t v32 = a1[50];
      if (!v32 || !*(_DWORD *)(v32 + 76)) {
        sub_100013D4C( "%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n",  "nx_reaper_checkpoint_traverse",  1308,  (const char *)(a1[48] + 208),  v29,  v37);
      }
    }

      uint64_t v12 = 1;
      goto LABEL_24;
    }

    uint64_t v6 = 22LL;
    if (a3 >= 0xC && a5 >= 0xC)
    {
      LODWORD(v13) = *((unsigned __int8 *)a2 + 8);
      unsigned int v16 = *((unsigned __int8 *)a4 + 8);
      goto LABEL_16;
    }
  }

  return v6;
}

LABEL_69:
    sub_100038824((uint64_t *)v41);
  }

  while (!(_DWORD)v8 && v11);
  return v8;
}

uint64_t sub_10001148C(uint64_t a1, int a2)
{
  *(void *)(a1 + 32) = 1LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 108) = (a2 & 0xFFFFFFFC) - 112;
  return 0LL;
}

uint64_t sub_1000114B0(void *a1)
{
  uint64_t v2 = a1[7];
  unint64_t v4 = *(void *)(v2 + 32);
  unint64_t v3 = *(void *)(v2 + 40);
  unint64_t v5 = *(unsigned int *)(v2 + 108);
  unint64_t v6 = (sub_1000398C8((uint64_t)a1) & 0xFFFFFFFCLL) - 112;
  if (v3 < v4) {
    int v7 = 1;
  }
  else {
    int v7 = 2;
  }
  if (v6 >= v5) {
    BOOL v8 = v3 >= v4;
  }
  else {
    BOOL v8 = v7;
  }
  int v9 = *(_DWORD *)(v2 + 68);
  if (v9 == 1)
  {
    BOOL v10 = *(void *)(v2 + 48) == *(void *)(v2 + 56);
  }

  else
  {
    if (v9)
    {
      if (v8) {
        goto LABEL_19;
      }
      goto LABEL_20;
    }

    if (*(void *)(v2 + 48)) {
      goto LABEL_19;
    }
    BOOL v10 = *(void *)(v2 + 56) == 0LL;
  }

  if (!v10 || v8)
  {
LABEL_19:
    uint64_t result = sub_100005194(*(void *)(*a1 + 392LL));
    if ((_DWORD)result) {
      return result;
    }
  }

LABEL_20:
  a1[47] = v2;
  unsigned int v13 = sub_1000398C8((uint64_t)a1);
  uint64_t result = 0LL;
  a1[48] = v2 + v13 - *(unsigned int *)(v2 + 108);
  return result;
}

      BOOL v10 = v23;
      goto LABEL_21;
    }

    int v19 = sub_10003B574( *(void *)(a1 + 392),  0x80000000,  v18,  (int *)&xmmword_10005B7A0,  0LL,  0LL,  0LL,  a3,  (uint64_t *)&v22);
    if ((_DWORD)v19) {
      break;
    }
    *(void *)(v4 + 48) = *(void *)(v11 + 32);
    uint64_t v20 = *(_DWORD *)(v4 + 68);
    if (v20) {
      *(_DWORD *)(v4 + 68) = v20 - 1;
    }
    sub_10003E644(a2, a3, 0LL);
    sub_10003B240((uint64_t)v23);
    sub_100038824(v23);
    BOOL v10 = v22;
    uint64_t v22 = 0LL;
    uint64_t v23 = v10;
    unint64_t v11 = v10[47];
    if (*(void *)(v4 + 88)) {
      goto LABEL_21;
    }
  }

  int v9 = v19;
  sub_100038824(v23);
  return v9;
}

        if (v10 > v15)
        {
          if (v15 == *(void *)(a1 + 112)) {
            *(void *)(a1 + 112) = v10;
          }
          void *v13 = v14 & 0xFFF0000000000000LL | v10 & 0xFFFFFFFFFFFFFLL;
          uint64_t v18 = sub_10002C368(a1, v10, v16, v17 - v10, v12);
          int v7 = v18;
          if (!(_DWORD)v18) {
            goto LABEL_9;
          }
          sub_100013D94( "%s:%d: %s dev %d Failed to update partially-covered node in length tree: %d\n",  "spaceman_free_extent_cache_remove",  2070,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v18);
          goto LABEL_8;
        }
      }
    }

    else
    {
      unint64_t v34 = 0;
      if (sub_10002C95C(a1, 0, v10, v25 - v10, &v34))
      {
LABEL_31:
        sub_10002C1F4(a1, v10, v25 - v10);
        goto LABEL_46;
      }

      if (sub_10002C95C(a1, 1u, v10, v25 - v10, &v34))
      {
        goto LABEL_31;
      }

      uint64_t v33 = *(void *)(a1 + 120);
      if (v26 < v33 || v26 == v33 && v10 > *(void *)(a1 + 112))
      {
        *(void *)(a1 + 112) = v10;
        *(void *)(a1 + 120) = v26;
      }

      if (v26 > *(void *)(a1 + 128))
      {
        int v7 = 0LL;
        *(void *)(a1 + 128) = v26;
LABEL_9:
        if (*(void *)a1) {
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
        }
        return v7;
      }
    }

  *(void *)uint64_t v12 = v14 * a4;
  if (v7 - 1 == a4) {
    uint64_t v25 = v15;
  }
  else {
    uint64_t v25 = v14 + v14 * a4;
  }
  *(void *)unsigned int v13 = v14 * a4;
  *((void *)v13 + 1) = v25;
  uint64_t v26 = v11 + 32 * a3;
  *(void *)(v26 + 8) = v25;
  v13[64] = a3 + 1;
  *(_BYTE *)(v26 + 25) = 0;
  if (*(_BYTE *)(v12 + 24)) {
    *(_DWORD *)(*(void *)(a1 + 8 * v8 + 1488) + 4 * (v16 / v14)) &= ~0x8000000u;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(*(void *)(a1 + 8 * v8 + 1488) + 4 * a4) |= 0x8000000u;
  return result;
}

uint64_t sub_100011588(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = ((unint64_t)a2 - 64) / 0x28;
  *(_DWORD *)(a1 + 44) = v2;
  *(void *)(a1 + 52) = -1LL;
  *(_DWORD *)(a1 + 60) = 0;
  uint64_t v3 = (v2 - 1);
  if ((_DWORD)v3)
  {
    uint64_t v4 = 0LL;
    unint64_t v5 = (_DWORD *)(a1 + 64);
    do
    {
      *unint64_t v5 = ++v4;
      v5 += 10;
    }

    while (v3 != v4);
  }

  else
  {
    LODWORD(v3) = 0;
  }

  *(_DWORD *)(a1 + 40LL * v3 + 64) = -1;
  return 0LL;
}

uint64_t sub_1000115F0(void *a1)
{
  unint64_t v2 = (_DWORD *)a1[7];
  unsigned int v3 = v2[11];
  BOOL v4 = v3 > (((unint64_t)sub_1000398C8((uint64_t)a1) - 64) / 0x28);
  unsigned int v6 = v2[11];
  unsigned int v5 = v2[12];
  if (v4) {
    int v7 = 2;
  }
  else {
    int v7 = 1;
  }
  if (v5 <= v6) {
    int v8 = v4;
  }
  else {
    int v8 = v7;
  }
  unsigned int v9 = v2[13];
  unsigned int v10 = v2[14];
  if (v9 != -1 && v9 >= v6) {
    ++v8;
  }
  if (v10 != -1 && v10 >= v6) {
    ++v8;
  }
  unsigned int v13 = v2[15];
  if (v13 != -1 && v13 >= v6) {
    int v15 = v8 + 1;
  }
  else {
    int v15 = v8;
  }
  if (v5 == 1)
  {
    BOOL v16 = v9 == v10;
  }

  else
  {
    if (v5)
    {
      if (v15) {
        goto LABEL_36;
      }
      goto LABEL_37;
    }

    BOOL v16 = v9 == -1 && v10 == -1;
  }

  if (!v16 || v15 != 0)
  {
LABEL_36:
    uint64_t result = sub_100005194(*(void *)(*a1 + 392LL));
    if ((_DWORD)result) {
      return result;
    }
  }

uint64_t sub_1000116D0( uint64_t *a1, int a2, int a3, unint64_t a4, unint64_t a5, uint64_t **a6, char **a7)
{
  uint64_t v23 = 0LL;
  unsigned int v22 = 0;
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  *a7 = 0LL;
  *a6 = 0LL;
  if (a4)
  {
    uint64_t v14 = sub_10003B574(a1[49], 0, a4, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, (uint64_t *)&v23);
    if ((_DWORD)v14)
    {
      uint64_t v15 = v14;
      sub_100013D94( "%s:%d: %s unable to get fs object 0x%llx: %d\n",  "nx_reaper_obj_get",  1140,  (const char *)(a1[48] + 208),  a4,  v14);
      return v15;
    }

    unsigned int v17 = v23;
  }

  else
  {
    unsigned int v17 = 0LL;
  }

  *a6 = v17;
  if ((a2 & 0x4000FFFF) == 0x4000000B)
  {
    uint64_t v18 = (uint64_t)(v17 ? v17 : a1);
  }

  uint64_t v16 = sub_10003A3CC(a2, &v22, (uint64_t)&v20);
  if ((_DWORD)v16
    || (LODWORD(v21) = a3,
        uint64_t v16 = sub_10003B574(a1[49], v22, a5, (int *)&v20, 0LL, (uint64_t)v23, 0LL, 0LL, (uint64_t *)a7),
        (_DWORD)v16))
  {
    sub_100013D94( "%s:%d: %s unable to get object 0x%llx: %d\n",  "nx_reaper_obj_get",  1161,  (const char *)(a1[48] + 208),  a5,  v16);
    if (v23) {
      sub_100038824(v23);
    }
    *a7 = 0LL;
    *a6 = 0LL;
  }

  return v16;
}

uint64_t sub_100011884(void *a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, void *a8)
{
  uint64_t v44 = 0LL;
  memset(v45, 170, sizeof(v45));
  uint64_t v16 = sub_100010F28(a1, (char **)&v45[2]);
  if ((_DWORD)v16) {
    return v16;
  }
  uint64_t v17 = *(void *)(v45[2] + 376);
  uint64_t v16 = sub_10003AE68(a2, &v44);
  if ((_DWORD)v16)
  {
LABEL_3:
    sub_100013D94( "%s:%d: %s object type 0x%x not reapable: %d\n",  "nx_reaper_add",  1357,  (const char *)(a1[48] + 208LL),  a2,  v16);
LABEL_14:
    sub_100038824(v45[2]);
    return v16;
  }

  if (!*(void *)(v44 + 24))
  {
    uint64_t v16 = 22LL;
    goto LABEL_3;
  }

  sub_10003CF10(v45[2], 2);
  uint64_t v18 = sub_10003CF9C(v45[2], 0LL, a6);
  if ((_DWORD)v18)
  {
    uint64_t v16 = v18;
LABEL_13:
    sub_10003D514(v45[2], 2);
    goto LABEL_14;
  }

  uint64_t v19 = a1[49];
  if (*(_OWORD *)(v17 + 48) == 0LL)
  {
    uint64_t v20 = sub_10003A068(v19, 0x80000000, 0, (int)&xmmword_10005B7A0, 0, 0, a6, (uint64_t)&v45[1]);
    if ((_DWORD)v20)
    {
      uint64_t v16 = v20;
      sub_100013D94("%s:%d: %s failed to create reap list: %d\n");
      goto LABEL_13;
    }

    uint64_t v23 = sub_10003965C(v45[1]);
    *(void *)(v17 + 48) = v23;
    *(void *)(v17 + 56) = v23;
    unint64_t v24 = (_DWORD *)(v17 + 68);
    goto LABEL_17;
  }

  uint64_t v21 = sub_10003B574(v19, 2147483649LL, *(void *)(v17 + 56), &xmmword_10005B7A0, 0LL, 0LL, 0LL, a6, &v45[1]);
  if ((_DWORD)v21)
  {
    uint64_t v16 = v21;
    sub_100013D94("%s:%d: %s failed to get reap list tail: %d\n");
    goto LABEL_13;
  }

  unint64_t v24 = (_DWORD *)(v17 + 68);
  if (!*(_DWORD *)(v17 + 68) && *(void *)(v17 + 48) == *(void *)(v17 + 56))
  {
LABEL_17:
    *unint64_t v24 = 1;
    sub_10003E644(v45[2], a6, 0LL);
  }

  uint64_t v25 = *(_DWORD **)(v45[1] + 376);
  if (v25[12] > (v25[11] - 2))
  {
    uint64_t v26 = sub_10003A068(a1[49], 0x80000000, 0, (int)&xmmword_10005B7A0, 0, 0, a6, (uint64_t)v45);
    if ((_DWORD)v26)
    {
      uint64_t v16 = v26;
      sub_10003D514(v45[2], 2);
      sub_100038824(v45[1]);
      goto LABEL_14;
    }

    uint64_t v27 = sub_10003965C(v45[0]);
    *(void *)(*(void *)(v45[1] + 376) + 32LL) = v27;
    *(void *)(v17 + 56) = sub_10003965C(v45[0]);
    int v28 = *(_DWORD *)(v17 + 68);
    if (v28) {
      *(_DWORD *)(v17 + 68) = v28 + 1;
    }
    sub_10003E644(v45[2], a6, 0LL);
    sub_100038824(v45[1]);
    v45[1] = v45[0];
    uint64_t v25 = *(_DWORD **)(v45[0] + 376);
  }

  uint64_t v29 = *(void *)(v17 + 32);
  *(void *)(v17 + 32) = v29 + 1;
  int v30 = v25[15];
  if (v30 == -1)
  {
    sub_100013D94( "%s:%d: %s reap list object free list erroneously empty?\n",  "nx_reaper_add",  1427,  (const char *)(a1[48] + 208LL));
    sub_10003D514(v45[2], 2);
    sub_100038824(v45[1]);
    sub_100038824(v45[2]);
    uint64_t v43 = (uint64_t)a1;
    return sub_100005194(v43);
  }

  uint64_t v31 = &v25[10 * v30];
  int v34 = v31[16];
  uint64_t v32 = v31 + 16;
  int v33 = v34;
  v25[15] = v34;
  int v35 = v25[14];
  if (v35 != -1) {
    v25[10 * v35 + 16] = v30;
  }
  if (v25[13] == -1) {
    v25[13] = v30;
  }
  v25[14] = v30;
  int v36 = v25[12];
  v25[12] = v36 + 1;
  *uint64_t v32 = -1;
  int v37 = &v25[10 * v30];
  if ((a7 & 2) != 0) {
    int v38 = 21;
  }
  else {
    int v38 = 5;
  }
  v37[17] = v38;
  v37[18] = a2;
  v37[19] = a3;
  *((void *)v37 + 10) = a4;
  *((void *)v37 + 11) = a5;
  *((void *)v37 + 12) = a6;
  if (v33 == -1)
  {
    sub_100013D94( "%s:%d: %s reap list object free list erroneously empty?\n",  "nx_reaper_add",  1458,  (const char *)(a1[48] + 208LL));
    sub_10003D514(v45[2], 2);
    sub_100038824(v45[1]);
    sub_100038824(v45[2]);
    uint64_t v43 = (uint64_t)a1;
    return sub_100005194(v43);
  }

  unsigned int v39 = &v25[10 * v33];
  int v40 = v39[16];
  *uint64_t v32 = v33;
  v25[14] = v33;
  v25[15] = v40;
  v25[12] = v36 + 2;
  if ((a7 & 2) != 0) {
    int v41 = 19;
  }
  else {
    int v41 = 3;
  }
  if ((a7 & 1) != 0) {
    v41 |= 0xCu;
  }
  v39[16] = -1;
  v39[17] = v41;
  v39[18] = a2;
  v39[19] = a3;
  *((void *)v39 + 10) = a4;
  *((void *)v39 + 11) = a5;
  *((void *)v39 + 12) = v29;
  sub_10003E644(v45[1], a6, 0LL);
  sub_10003D514(v45[2], 2);
  sub_100038824(v45[1]);
  sub_100038824(v45[2]);
  if (!a8) {
    return 0LL;
  }
  uint64_t v42 = v29;
  uint64_t v16 = 0LL;
  *a8 = v42;
  return v16;
}

uint64_t sub_100011D2C(void *a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v38 = 0LL;
  memset(v39, 170, sizeof(v39));
  uint64_t v14 = sub_100010F28(a1, (char **)&v39[2]);
  if ((_DWORD)v14) {
    return v14;
  }
  uint64_t v15 = *(void *)(v39[2] + 376LL);
  uint64_t v14 = sub_10003AE68(a2, &v38);
  if ((_DWORD)v14)
  {
LABEL_3:
    sub_100013D94( "%s:%d: %s object type 0x%x not reapable: %d\n",  "nx_reaper_add_sub_object",  1536,  (const char *)(a1[48] + 208LL),  a2,  v14);
LABEL_4:
    sub_100038824(v39[2]);
    return v14;
  }

  if (!*(void *)(v38 + 24))
  {
    uint64_t v14 = 22LL;
    goto LABEL_3;
  }

  sub_10003CF10(v39[2], 2);
  uint64_t v17 = sub_10003CF9C(v39[2], 0LL, a6);
  if ((_DWORD)v17)
  {
    uint64_t v14 = v17;
    sub_10003D514(v39[2], 2);
    goto LABEL_4;
  }

  uint64_t v18 = *(void *)(v15 + 48);
  if (!v18 && !*(void *)(v15 + 56))
  {
    uint64_t v21 = sub_10003A068(a1[49], 0x80000000, 0, (int)&xmmword_10005B7A0, 0, 0, a6, (uint64_t)&v39[1]);
    if ((_DWORD)v21)
    {
      uint64_t v14 = v21;
      sub_100013D94("%s:%d: %s failed to create reap list: %d\n");
      goto LABEL_14;
    }

    uint64_t v22 = sub_10003965C(v39[1]);
    *(void *)(v15 + 48) = v22;
    *(void *)(v15 + 56) = v22;
    uint64_t v20 = (_DWORD *)(v15 + 68);
    goto LABEL_21;
  }

  uint64_t v19 = sub_10003B574(a1[49], 2147483649LL, v18, &xmmword_10005B7A0, 0LL, 0LL, 0LL, a6, &v39[1]);
  if ((_DWORD)v19)
  {
    uint64_t v14 = v19;
    sub_100013D94("%s:%d: %s failed to get reap list head: %d\n");
LABEL_14:
    sub_100013D94( "%s:%d: %s failed to get reap list head: %d\n",  "nx_reaper_add_sub_object",  1572,  (const char *)(a1[48] + 208LL),  v14);
    sub_10003D514(v39[2], 2);
    sub_100038824(v39[2]);
    return v14;
  }

  uint64_t v20 = (_DWORD *)(v15 + 68);
  if (!*(_DWORD *)(v15 + 68) && *(void *)(v15 + 48) == *(void *)(v15 + 56))
  {
LABEL_21:
    *uint64_t v20 = 1;
    sub_10003E644(v39[2], a6, 0LL);
  }

  uint64_t v23 = *(_DWORD **)(v39[1] + 376LL);
  if (v23[12] > v23[11] + ~(a7 & 1u))
  {
    uint64_t v24 = sub_10003A068(a1[49], 0x80000000, 0, (int)&xmmword_10005B7A0, 0, 0, a6, (uint64_t)v39);
    if ((_DWORD)v24)
    {
      uint64_t v14 = v24;
      sub_10003D514(v39[2], 2);
      sub_100038824(v39[1]);
      goto LABEL_4;
    }

    uint64_t v25 = v39[0];
    *(void *)(*(void *)(v39[0] + 376LL) + 32LL) = *(void *)(v15 + 48);
    *(void *)(v15 + 48) = sub_10003965C(v25);
    int v26 = *(_DWORD *)(v15 + 68);
    if (v26) {
      *(_DWORD *)(v15 + 68) = v26 + 1;
    }
    sub_10003E644(v39[2], a6, 0LL);
    sub_100038824(v39[1]);
    v39[1] = v39[0];
    uint64_t v23 = *(_DWORD **)(v39[0] + 376LL);
  }

  int v27 = v23[15];
  if ((a7 & 1) != 0)
  {
    if (v27 == -1)
    {
      sub_100013D94( "%s:%d: %s reap list object free list erroneously empty?\n",  "nx_reaper_add_sub_object",  1608,  (const char *)(a1[48] + 208LL));
      sub_10003D514(v39[2], 2);
      sub_100038824(v39[1]);
      sub_100038824(v39[2]);
      uint64_t v37 = (uint64_t)a1;
      return sub_100005194(v37);
    }

    int v28 = &v23[10 * v27];
    int v29 = v28[16];
    v23[15] = v29;
    int v30 = v23[14];
    v28[16] = v23[13];
    v23[13] = v27;
    if (v30 == -1) {
      v23[14] = v27;
    }
    ++v23[12];
    uint64_t v31 = &v23[10 * v27];
    if ((a7 & 2) != 0) {
      int v32 = 29;
    }
    else {
      int v32 = 13;
    }
    v31[17] = v32;
    v31[18] = a2;
    v31[19] = a3;
    *((void *)v31 + 10) = a4;
    *((void *)v31 + 11) = a5;
    *((void *)v31 + 12) = a6;
    int v27 = v29;
  }

  if (v27 == -1)
  {
    sub_100013D94( "%s:%d: %s reap list object free list erroneously empty?\n",  "nx_reaper_add_sub_object",  1636,  (const char *)(a1[48] + 208LL));
    sub_10003D514(v39[2], 2);
    sub_100038824(v39[1]);
    sub_100038824(v39[2]);
    uint64_t v37 = (uint64_t)a1;
    return sub_100005194(v37);
  }

  int v33 = &v23[10 * v27];
  v23[15] = v33[16];
  int v34 = v23[14];
  v33[16] = v23[13];
  v23[13] = v27;
  if (v34 == -1) {
    v23[14] = v27;
  }
  ++v23[12];
  int v35 = &v23[10 * v27];
  if ((a7 & 2) != 0) {
    int v36 = 21;
  }
  else {
    int v36 = 5;
  }
  v35[17] = v36;
  v35[18] = a2;
  v35[19] = a3;
  *((void *)v35 + 10) = a4;
  *((void *)v35 + 11) = a5;
  *((void *)v35 + 12) = a6;
  sub_10003E644(v39[1], a6, 0LL);
  sub_10003D514(v39[2], 2);
  sub_100038824(v39[1]);
  sub_100038824(v39[2]);
  return 0LL;
}

void sub_1000121F8(uint64_t *a1)
{
  unsigned int v5 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v6 = (char *)0xAAAAAAAAAAAAAAAALL;
  if (!sub_100010F28(a1, &v6))
  {
    uint64_t v2 = *((void *)v6 + 47);
    sub_10003CF10((uint64_t)v6, 2);
    if (!*(void *)(v2 + 88))
    {
      unint64_t v3 = *(void *)(v2 + 48);
      if (!v3
        || sub_10003B574( a1[49],  0x80000000,  v3,  (int *)&xmmword_10005B7A0,  0LL,  0LL,  0LL,  0LL,  (uint64_t *)&v5))
      {
        goto LABEL_4;
      }

      uint64_t v4 = v5[47];
      if (!*(_DWORD *)(v4 + 48) && !*(void *)(v4 + 32))
      {
        sub_100038824(v5);
        goto LABEL_4;
      }

      sub_100038824(v5);
    }

    sub_10003D514((uint64_t)v6, 2);
    sub_1000122DC(a1);
    sub_10003CF10((uint64_t)v6, 2);
LABEL_4:
    sub_10003D514((uint64_t)v6, 2);
    sub_100038824((uint64_t *)v6);
  }

uint64_t sub_1000122DC(uint64_t *a1)
{
  uint64_t v20 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100010F28(a1, &v20);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v3 = *((void *)v20 + 47);
  sub_10003CF10((uint64_t)v20, 2);
  uint64_t v4 = v20;
  if (*((_DWORD *)v20 + 98) || *((_DWORD *)v20 + 99))
  {
    sub_10003D514((uint64_t)v20, 2);
    sub_100038824((uint64_t *)v20);
    sub_100013CBC("%s:%d: reaper thread is exiting, returning EBUSY\n", "nx_reaper", 1792);
    return 16LL;
  }

  int v5 = 0;
  *((_DWORD *)v20 + 98) = 1;
  while (1)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    sub_10003D514((uint64_t)v4, 2);
    uint64_t v19 = 0LL;
    unsigned int v6 = sub_10004FD18((uint64_t)a1, &v19);
    sub_10003CF10((uint64_t)v20, 2);
    uint64_t v4 = v20;
    if (v6)
    {
LABEL_37:
      int v13 = 0;
      goto LABEL_41;
    }

    unsigned int v7 = sub_10003CF9C(v20, 0, v19);
    uint64_t v4 = v20;
    if (v7)
    {
      unsigned int v6 = v7;
LABEL_40:
      int v13 = 1;
      goto LABEL_41;
    }

    if (*(void *)(v3 + 88)) {
      goto LABEL_13;
    }
    if (*((_DWORD *)v20 + 99)) {
      goto LABEL_39;
    }
    unsigned int v8 = sub_100013780((uint64_t)a1, (uint64_t)v20, v19);
    if (v8) {
      break;
    }
    uint64_t v4 = v20;
    if (!*(void *)(v3 + 88))
    {
LABEL_39:
      unsigned int v6 = 0;
      goto LABEL_40;
    }

LABEL_13:
    sub_10003D514((uint64_t)v4, 2);
    if ((*(_BYTE *)(v3 + 104) & 4) == 0) {
      goto LABEL_16;
    }
    int v9 = sub_10003AE68(*(_DWORD *)(v3 + 72), &v18);
    if (v9) {
      goto LABEL_15;
    }
    if (!*(void *)(v18 + 24))
    {
      int v9 = 22;
LABEL_15:
      sub_100013D94( "%s:%d: %s object type 0x%x not reapable?: %d\n",  "nx_reaper",  1833,  (const char *)(a1[48] + 208),  *(_DWORD *)(v3 + 72),  v9);
      int v5 = 1;
LABEL_16:
      sub_10003CF10((uint64_t)v20, 2);
      goto LABEL_17;
    }

    int v10 = sub_1000116D0( a1,  *(_DWORD *)(v3 + 72),  *(_DWORD *)(v3 + 76),  *(void *)(v3 + 80),  *(void *)(v3 + 88),  &v16,  &v17);
    if (v10)
    {
      int v11 = v10;
      sub_100013D94( "%s:%d: %s unable to get object 0x%llx of type 0x%x: %d\n",  "nx_reaper",  1838,  (const char *)(a1[48] + 208),  *(void *)(v3 + 88),  *(_DWORD *)(v3 + 72),  v10);
    }

    else
    {
      if ((*(_BYTE *)(v3 + 64) & 2) == 0) {
        bzero(*((void **)v20 + 48), *(unsigned int *)(v3 + 108));
      }
      int v12 = (*(uint64_t (**)(char *, void, void, void, uint64_t))(v18 + 24))( v17,  (*(_DWORD *)(v3 + 104) >> 3) & 3,  *((void *)v20 + 48),  *(unsigned int *)(v3 + 108),  v19);
      int v11 = v12;
      if (v12 && v12 != 36) {
        sub_100013D94( "%s:%d: %s error reaping object 0x%llx of type 0x%x: %d\n",  "nx_reaper",  1852,  (const char *)(a1[48] + 208),  *(void *)(v3 + 88),  *(_DWORD *)(v3 + 72),  v12);
      }
      sub_100038824((uint64_t *)v17);
      if (v16)
      {
        sub_100038824(v16);
        uint64_t v16 = 0LL;
      }
    }

    sub_10003CF10((uint64_t)v20, 2);
    if (v11 == 36)
    {
      *(_DWORD *)(v3 + 64) |= 2u;
      int v5 = 1;
      goto LABEL_20;
    }

    int v5 = 1;
LABEL_17:
    if ((*(_BYTE *)(v3 + 104) & 2) != 0) {
      *(void *)(v3 + 40) = *(void *)(v3 + 96);
    }
    *(_DWORD *)(v3 + 64) &= ~2u;
    *(void *)(v3 + 88) = 0LL;
LABEL_20:
    sub_10003E644((uint64_t)v20, v19, 0LL);
    sub_10003D514((uint64_t)v20, 2);
    sub_1000442BC((uint64_t)a1, &v15, &v14, 0LL, 0LL);
    unsigned int v6 = sub_10004FD28((uint64_t)a1, v19, (v14 < 0x3E8) | (4 * (v14 < 0x7D0)));
    sub_10003CF10((uint64_t)v20, 2);
    uint64_t v4 = v20;
    if (v6) {
      goto LABEL_37;
    }
    if (*((_DWORD *)v20 + 99))
    {
      int v13 = 0;
      unsigned int v6 = 0;
      goto LABEL_41;
    }
  }

  unsigned int v6 = v8;
  int v13 = 1;
  uint64_t v4 = v20;
LABEL_41:
  *((_DWORD *)v4 + 98) = 0;
  sub_10003D514((uint64_t)v4, 2);
  sub_100038824((uint64_t *)v20);
  if (v13) {
    sub_10004FD28((uint64_t)a1, v19, 0);
  }
  if (v6 | v5) {
    return v6;
  }
  else {
    return 2LL;
  }
}

  if (a7 && !(_DWORD)v15) {
    *a7 = v36;
  }
  return v15;
}

    if ((_DWORD)v21)
    {
      if ((_DWORD)v21 != 79) {
        sub_100013D94("%s:%d: %s superblock failed sanity checks: %d\n");
      }
      goto LABEL_37;
    }

    LODWORD(v22) = v17[9];
LABEL_15:
    if ((_DWORD)v22 == v15) {
      break;
    }
    sub_100014004(v17, v15);
    sub_100051DC0((uint64_t)v33);
    unint64_t v15 = v22;
    if (v22 < v13)
    {
      sub_100013D94("%s:%d: %s container block size too small for device block size (%d < %d)\n");
      goto LABEL_42;
    }
  }

  if (v32)
  {
    if (v15 < v12)
    {
      sub_100013D94( "%s:%d: %s container block size too small for tier2 device block size (%d < %d)\n",  "nx_dev_init",  816,  v33 + 208,  v15,  v12);
LABEL_41:
      uint64_t v21 = 22LL;
      goto LABEL_37;
    }

    int v28 = sub_100052A70((uint64_t)v33, (uint64_t)v32, 0x4000000000000000uLL >> __clz(__rbit64(v15)));
    if ((_DWORD)v28)
    {
      uint64_t v21 = v28;
      sub_100013D94("%s:%d: %s failed to set tier2 device: %d\n", "nx_dev_init", 824, v33 + 208, v28);
      goto LABEL_37;
    }

    int v32 = 0LL;
  }

  if ((*((_BYTE *)v17 + 65) & 1) != 0 && (a7 & 1) == 0)
  {
    int v29 = sub_100014044(v15);
    if (!v29)
    {
      sub_100013D94( "%s:%d: %s couldn't allocate memory for superblock of size %d\n",  "nx_dev_init",  842,  v33 + 208,  v15);
      uint64_t v21 = 12LL;
      goto LABEL_37;
    }

    int v30 = sub_100051DF4((uint64_t)v33, 0x4000000000000000uLL >> __clz(__rbit64(v15)));
    if ((_DWORD)v30)
    {
      uint64_t v21 = v30;
      sub_100013D94("%s:%d: %s couldn't read tier2 device superblock of size %d\n", "nx_dev_init", 848, v33 + 208, v15);
      sub_100014004(v29, v15);
      goto LABEL_37;
    }

    if (!sub_1000330B8((uint64_t)v17, (uint64_t)v29, "tier2", 1))
    {
      sub_100013D94( "%s:%d: %s tier2 device superblock doesn't agree with main superblock\n",  "nx_dev_init",  853,  v33 + 208);
      sub_100014004(v29, v15);
      goto LABEL_41;
    }

    sub_100014004(v29, v15);
  }

  uint64_t v21 = 0LL;
  *a9 = v17;
  *uint64_t v31 = v33;
  return v21;
}

  int v10 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v10) {
    panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  1985,  v10);
  }
  int v11 = v22;
  if (v22)
  {
    int v12 = 0LL;
    int v13 = 0LL;
    do
    {
      unint64_t v15 = *(void *)(v11 + 88);
      unint64_t v14 = *(uint64_t **)(v11 + 96);
      if (v15)
      {
        *(void *)(v15 + 96) = v14;
        unint64_t v14 = *(uint64_t **)(v11 + 96);
      }

      else
      {
        uint64_t v23 = *(uint64_t **)(v11 + 96);
      }

      *unint64_t v14 = v15;
      *(void *)(v11 + 88) = 3735928559LL;
      uint64_t v16 = *(void *)(v11 + 16);
      if ((v16 & 0xC00000000LL) != 0)
      {
        uint64_t v17 = *(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 376LL) + 36LL);
        uint64_t v18 = (v17 + *(_DWORD *)(v11 + 48) - 1) / v17;
        if ((v16 & 0x800000000LL) != 0) {
          uint64_t v19 = 0LL;
        }
        else {
          uint64_t v19 = v18;
        }
        v13 += v19;
        v12 += v18 & (v16 << 28 >> 63);
        *(void *)(v11 + 16) = v16 & 0xFFFFFFF3FFFFFFFFLL;
      }

      --*(_DWORD *)(a1 + 684);
      sub_10003CCD4(v11, 0);
      int v11 = v15;
    }

    while (v15);
    sub_100036F84(a1);
    if (v13)
    {
      uint64_t v20 = sub_10004CFD4(a2, 0x48u, v13);
      if (v20) {
        sub_100013D94( "%s:%d: %s error unreserving space, %lld blocks: %d\n",  "obj_cache_remove_new_fs_objects",  2010,  (const char *)(a2 + 3992),  v13,  v20);
      }
    }

    if (v12)
    {
      uint64_t v21 = sub_10004CFD4(a2, 0x50u, v12);
      if (v21) {
        sub_100013D94( "%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n",  "obj_cache_remove_new_fs_objects",  2016,  (const char *)(a2 + 3992),  v12,  v21);
      }
    }
  }

  else
  {
    sub_100036F84(a1);
  }

    *(void *)&v33[0] = a6;
    *((void *)&v33[0] + 1) = a4;
    uint64_t v16 = a5;
    *(void *)&v33[1] = a5;
    goto LABEL_14;
  }

  return v13;
}

void sub_1000126C0(void *a1)
{
  uint64_t v4 = (char *)0xAAAAAAAAAAAAAAAALL;
  if (!sub_100010F28(a1, &v4))
  {
    sub_10003CF10((uint64_t)v4, 2);
    uint64_t v2 = v4;
    ++*((_DWORD *)v4 + 99);
    sub_10003D514((uint64_t)v2, 2);
    uint64_t v3 = (uint64_t *)a1[53];
    if (v3)
    {
      sub_100038824(v3);
      a1[53] = 0LL;
    }

    sub_100038824((uint64_t *)v4);
  }

uint64_t sub_100012734(uint64_t *a1, unint64_t a2)
{
  unsigned int v8 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = sub_100010F28(a1, &v8);
  if (!(_DWORD)v4)
  {
    uint64_t v5 = *((void *)v8 + 7);
    sub_10003CF10((uint64_t)v8, 2);
    unint64_t v6 = *(void *)(v5 + 32);
    if (a2 == -1LL) {
      a2 = v6 - 1;
    }
    if (a2 >= v6)
    {
      sub_100013D94( "%s:%d: %s invalid reap_id (%llu), must be smaller than nr_next_reap_id (%llu)\n",  "nx_reaper_wait",  2081,  (const char *)(a1[48] + 208),  a2,  v6);
      uint64_t v4 = 22LL;
    }

    else
    {
      while (*(void *)(v5 + 40) < a2)
      {
        sub_10003D514((uint64_t)v8, 2);
        uint64_t v4 = sub_1000122DC(a1);
        sub_10003CF10((uint64_t)v8, 2);
        if ((_DWORD)v4) {
          goto LABEL_10;
        }
      }

      uint64_t v4 = 0LL;
    }

uint64_t sub_10001282C(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_100012860(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unsigned int v8 = 0LL;
  int v9 = 0LL;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_100027FC4(a1, 0x88000000, *a2 & 0x7FFFFFFFFFFFFFFFLL, 0LL, 0, 0, 10, (uint64_t)sub_10001282C, 0LL, &v9);
  if (!(_DWORD)v5)
  {
    uint64_t v5 = sub_100029148(v9, 0x40000000u, 0, a3, (uint64_t *)&v8);
    if (!(_DWORD)v5)
    {
      sub_100029238((size_t)v9, a3, &v7);
      *a2 = sub_10003965C((uint64_t)v8);
    }

    if (v9) {
      sub_100038824(v9);
    }
    if (v8) {
      sub_100038824(v8);
    }
  }

  return v5;
}

uint64_t sub_10001292C(uint64_t a1, uint64_t a2, char **a3)
{
  if (!a2) {
    return 22LL;
  }
  for (uint64_t i = 432LL; i != 464; i += 8LL)
  {
    unint64_t v7 = *(char **)(a1 + i);
    if (v7 && sub_10003965C(*(void *)(a1 + i)) == a2)
    {
      sub_10003DC28(v7);
      uint64_t v12 = 0LL;
      *a3 = v7;
      return v12;
    }
  }

  sub_10003CF10(a1, 2);
  uint64_t v8 = 0LL;
  int v9 = -1;
  do
  {
    uint64_t v10 = a1 + 8 * v8;
    int v11 = *(char **)(v10 + 432);
    if (v11)
    {
      if (sub_10003965C(*(void *)(v10 + 432)) == a2)
      {
        sub_10003DC28(v11);
        *a3 = v11;
        sub_10003D514(a1, 2);
        return 0LL;
      }
    }

    else if (v9 == -1)
    {
      int v9 = v8;
    }

    ++v8;
  }

  while (v8 != 4);
  if (a2 < 0)
  {
    uint64_t v12 = sub_100027FC4(a1, 2281701376LL, a2 & 0x7FFFFFFFFFFFFFFFLL, 0LL, 0LL, 0LL, 10LL, sub_10001282C, 0LL, a3);
  }

  else
  {
    uint64_t v12 = sub_100027FC4(a1, 0x40000000LL, a2, 0LL, 0LL, 0LL, 10LL, sub_10001282C, 0LL, a3);
    if (!(_DWORD)v12 && v9 != -1)
    {
      *(void *)(a1 + 8LL * v9 + 432) = *a3;
      sub_10003DC28(*a3);
      uint64_t v12 = 0LL;
    }
  }

  sub_10003D514(a1, 2);
  return v12;
}

uint64_t sub_100012AB4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v19 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[2] = v5;
  v14[3] = v5;
  v14[0] = v5;
  v14[1] = v5;
  uint64_t v6 = sub_10001292C(a1, a2, &v19);
  if (!(_DWORD)v6)
  {
    unint64_t v18 = 0LL;
    sub_100026ED4((uint64_t)v14, (uint64_t)v19, 0LL, 0, &v18, 8, 8u, &v16, 0x10u);
    uint64_t v6 = v7;
    if (!(_DWORD)v7)
    {
      uint64_t v9 = 0LL;
      while (!sub_100026EFC((uint64_t)v14))
      {
        if (v18 == v9) {
          uint64_t v6 = 0LL;
        }
        else {
          uint64_t v6 = sub_100005194(a1);
        }
        unint64_t v10 = v17;
        if (v17 > (unint64_t)a3 - v9)
        {
          uint64_t v6 = sub_100005194(a1);
          unint64_t v10 = v17;
        }

        if ((_DWORD)v6) {
          goto LABEL_3;
        }
        v9 += v10;
        uint64_t v11 = sub_100026F18((uint64_t)v14);
        if ((_DWORD)v11)
        {
          uint64_t v6 = v11;
          uint64_t v12 = (const char *)(*(void *)(a1 + 384) + 208LL);
          int v13 = strerror(v11);
          sub_100013D94( "%s:%d: %s failed to get next extent in metadata fragmented extent list tree, error %s(%d)\n",  "nx_metadata_fragmented_sanity_check",  2445,  v12,  v13,  v6);
          goto LABEL_3;
        }
      }

      if (a3 == v9) {
        uint64_t v6 = 0LL;
      }
      else {
        uint64_t v6 = sub_100005194(a1);
      }
    }

LABEL_3:
    sub_100038824((uint64_t *)v19);
  }

  return v6;
}

  int v13 = sub_100051C28((uint64_t)v33);
  unint64_t v14 = sub_100051C34((uint64_t)v33);
  if (v13 <= 0x1000) {
    unint64_t v15 = 4096;
  }
  else {
    unint64_t v15 = v13;
  }
  uint64_t v16 = v11 * v12 + v14 * v13;
  while (1)
  {
    if (v15 % v13)
    {
      sub_100013D94("%s:%d: %s block size %d is not an even multiple of device block size %d\n");
LABEL_42:
      uint64_t v21 = 22LL;
      goto LABEL_43;
    }

    if (v15 > v13) {
      sub_100051DC0((uint64_t)v33);
    }
    unint64_t v17 = (unsigned int *)sub_100014044(v15);
    if (!v17)
    {
      sub_100013D94( "%s:%d: %s couldn't allocate memory for superblock of size %d\n",  "nx_dev_init",  769,  v33 + 208,  v15);
      uint64_t v21 = 12LL;
      goto LABEL_43;
    }

    unint64_t v18 = sub_100051DF4((uint64_t)v33, 0LL);
    if ((_DWORD)v18)
    {
      uint64_t v21 = v18;
      sub_100013D94("%s:%d: %s couldn't read superblock of size %d\n");
LABEL_37:
      sub_100014004(v17, v15);
      goto LABEL_43;
    }

    uint64_t v21 = sub_10000538C((uint64_t)v17, v15, 0, v19, v20);
    if ((_DWORD)v21) {
      goto LABEL_13;
    }
    if (v17[9] % v13)
    {
      sub_100013D94( "%s:%d: %s superblock block size %d not an even multiple of device block size %d\n",  "nx_dev_init",  785,  v33 + 208,  v17[9],  v13);
      uint64_t v21 = sub_100005194(0LL);
      if ((a7 & 1) != 0) {
        goto LABEL_13;
      }
    }

    else
    {
      uint64_t v21 = 0LL;
      if ((a7 & 1) != 0) {
        goto LABEL_13;
      }
    }

    if (!(_DWORD)v21)
    {
      uint64_t v22 = v17[9];
      if (*((void *)v17 + 5) * v22 <= v16) {
        goto LABEL_15;
      }
      sub_100013D94( "%s:%d: %s superblock container size %lld greater than device size(s) %lld\n",  "nx_dev_init",  791,  v33 + 208,  *((void *)v17 + 5) * v22,  v16);
      uint64_t v21 = sub_100005194(0LL);
    }

uint64_t sub_100012C64(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, unint64_t *a5)
{
  uint64_t v16 = (char *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = sub_10001292C(a1, a2, &v16);
  if (!(_DWORD)v8)
  {
    unint64_t v15 = a3;
    unsigned int v11 = 16;
    unsigned int v12 = 8;
    uint64_t v8 = sub_100026464((uint64_t)v16, 0LL, &v15, &v12, 8u, &v13, &v11, 1u, 0, 0LL);
    if (!(_DWORD)v8)
    {
      unint64_t v9 = v14 - (a3 - v15);
      if (v14 <= a3 - v15)
      {
        uint64_t v8 = 2LL;
      }

      else
      {
        *a4 = v13 + a3 - v15;
        uint64_t v8 = 0LL;
        if (a5) {
          *a5 = v9;
        }
      }
    }

    sub_100038824(v16);
  }

  return v8;
}

uint64_t sub_100012D38(void *a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = a1[60];
  if (!v8)
  {
    unint64_t v15 = a2;
    unsigned int v12 = 8;
    unsigned int v11 = 16;
    LODWORD(result) = sub_100026464(a1[58], 0LL, &v15, &v12, 8u, &v13, &v11, 1u, 0, 0LL);
    if ((_DWORD)result || (unint64_t v10 = v15, a2 - v15 >= v14))
    {
      if ((_DWORD)result == 2) {
        uint64_t result = 0LL;
      }
      else {
        uint64_t result = result;
      }
      if (a3 < 2 || (_DWORD)result) {
        return result;
      }
      unint64_t v15 = a2;
      unsigned int v11 = 16;
      unsigned int v12 = 8;
      LODWORD(result) = sub_100026464(a1[58], 0LL, &v15, &v12, 8u, &v13, &v11, 4u, 0, 0LL);
      if ((_DWORD)result || (unint64_t v10 = v15, v15 - a2 >= a3))
      {
        if ((_DWORD)result == 2) {
          return 0LL;
        }
        else {
          return result;
        }
      }
    }

    if (a4) {
      *a4 = v10;
    }
    return 17LL;
  }

  if (sub_100013C78(a1[59], v8, a2, a3, a4)) {
    return 17LL;
  }
  if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(a1[47] + 36LL)))) & a2) == 0)
  {
    if (a4) {
      *a4 = a2;
    }
    return 17LL;
  }

  return 0LL;
}

uint64_t sub_100012E9C(void *a1, unint64_t a2, int a3, char a4, int a5)
{
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  if ((a4 & 1) == 0) {
    return sub_100012FF8(a1, a2, a3 & 0x7FFFFFFF, a5);
  }
  uint64_t v19 = (char *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v6;
  v14[1] = v6;
  v14[2] = v6;
  v14[3] = v6;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = sub_10001292C((uint64_t)a1, a2, &v19);
  if (!(_DWORD)v7)
  {
    uint64_t v8 = sub_100028040((uint64_t)v19, 0LL, 0, (uint64_t (*)(void))sub_1000130D0, 0LL, 0LL);
    if (!(_DWORD)v8)
    {
      unint64_t v18 = 0LL;
      sub_100026ED4((uint64_t)v14, (uint64_t)v19, 0LL, 0, &v18, 8, 8u, &v16, 0x10u);
      uint64_t v7 = v10;
      while (1)
      {
        uint64_t v8 = sub_100012FF8(a1, v16, v17, 0);
        if ((_DWORD)v8) {
          break;
        }
        uint64_t v11 = sub_100026F18((uint64_t)v14);
        if ((_DWORD)v11)
        {
          uint64_t v7 = v11;
          unsigned int v12 = (const char *)(a1[48] + 208LL);
          unint64_t v13 = strerror(v11);
          sub_100013D94( "%s:%d: %s failed to get next extent in metadata fragmented extent list tree, error %s(%d)\n",  "nx_metadata_range_add",  2681,  v12,  v13,  v7);
          goto LABEL_7;
        }

        if (sub_100026EFC((uint64_t)v14))
        {
          uint64_t v7 = 0LL;
          goto LABEL_7;
        }
      }
    }

    uint64_t v7 = v8;
LABEL_7:
    sub_100038824((uint64_t *)v19);
  }

  return v7;
}

uint64_t sub_100012FF8(void *a1, unint64_t a2, unint64_t a3, int a4)
{
  if (a1[58])
  {
    uint64_t result = sub_100012D38(a1, a2, a3, 0LL);
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_5;
  }

  uint64_t result = sub_100027C40((uint64_t)a1, 0x88000000, 0, 10, 0, 8u, 16, (uint64_t)sub_10001282C, 0LL, a1 + 58);
  if (!(_DWORD)result)
  {
LABEL_5:
    v8[1] = a3;
    unint64_t v9 = a2;
    v8[0] = a2;
    return sub_10001EADC((void *)a1[58], 0LL, &v9, 8, v8, 0x10u, 0LL);
  }

  return result;
}

uint64_t sub_1000130D0(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)a1 + 392LL);
  unint64_t v3 = sub_10003965C(a1);
  unint64_t v4 = (sub_1000398C8(a1) + *(_DWORD *)(v2[47] + 36LL) - 1) / *(_DWORD *)(v2[47] + 36LL);
  return sub_100012FF8(v2, v3, v4, 0);
}

const char *sub_10001312C(const char *result)
{
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = 0xAAAAAAAAAAAAAAAALL;
  *((void *)result + 59) = 0LL;
  *((void *)result + 60) = 0LL;
  uint64_t v1 = *((void *)result + 58);
  if (v1)
  {
    uint64_t v2 = result;
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v7[2] = v3;
    v7[3] = v3;
    v7[0] = v3;
    v7[1] = v3;
    v9[1] = 0LL;
    unint64_t v11 = 0LL;
    sub_100026ED4((uint64_t)v7, v1, 0LL, 0, &v11, 8, 8u, &v10, 0x10u);
    uint64_t result = (const char *)sub_100026EFC((uint64_t)v7);
    if (!(_DWORD)result)
    {
      uint64_t v4 = 0LL;
      while (1)
      {
        uint64_t v5 = v10;
        if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*((void *)v2 + 47) + 36LL)))) & (unint64_t)v10) != 0)
        {
          uint64_t v6 = *((void *)&v10 + 1);
          if (*((void *)&v10 + 1)) {
            goto LABEL_9;
          }
        }

        else
        {
          uint64_t v5 = v10 + 1;
          uint64_t v6 = *((void *)&v10 + 1) - 1LL;
          *(void *)&__int128 v10 = v10 + 1;
          *((void *)&v10 + 1) = v6;
          if (v6)
          {
LABEL_9:
            if (v9[1] && v9[0] + v9[1] == v5)
            {
              v9[1] += v6;
            }

            else
            {
              ++v4;
              *(_OWORD *)unint64_t v9 = v10;
            }
          }
        }

        sub_100026F18((uint64_t)v7);
        uint64_t result = (const char *)sub_100026EFC((uint64_t)v7);
        if ((_DWORD)result)
        {
          if (v4 == 1) {
            *(_OWORD *)(v2 + 472) = *(_OWORD *)v9;
          }
          return result;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000132F4(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 376);
  int v4 = *(_DWORD *)(v3 + 104);
  if ((v4 & 0x7FFFFFFFu) <= a2) {
    return 22LL;
  }
  uint64_t v7 = *(void *)(v3 + 112);
  if (v4 < 0) {
    return sub_100012C64(a1, v7, a2, a3, 0LL);
  }
  uint64_t result = 0LL;
  *a3 = v7 + a2;
  return result;
}

uint64_t sub_100013338(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v4 = *(void *)(a1 + 376);
  int v5 = *(_DWORD *)(v4 + 108);
  unint64_t v6 = (v5 & 0x7FFFFFFF) - a2;
  if ((v5 & 0x7FFFFFFFu) <= a2) {
    return 22LL;
  }
  uint64_t v10 = *(void *)(v4 + 120);
  if (v5 < 0) {
    return sub_100012C64(a1, v10, a2, a3, a4);
  }
  *a3 = v10 + a2;
  uint64_t result = 0LL;
  if (a4) {
    *a4 = v6;
  }
  return result;
}

uint64_t sub_100013384(void *a1)
{
  if (!*(void *)(a1[47] + 1256LL))
  {
LABEL_8:
    uint64_t v9 = 0LL;
    uint64_t v2 = sub_10004FD18((uint64_t)a1, &v9);
    if ((_DWORD)v2) {
      return v2;
    }
    uint64_t v4 = sub_10004D6A0(a1, v9);
    if (!(_DWORD)v4) {
      return sub_10004FD28((uint64_t)a1, v9, 0);
    }
    uint64_t v2 = v4;
    sub_100013D94("%s:%d: %s spaceman_unset_block_out_range failed with error %u\n");
    goto LABEL_11;
  }

  unint64_t v8 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v9 = 0LL;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v2 = sub_10004FD18((uint64_t)a1, &v9);
  if ((_DWORD)v2) {
    return v2;
  }
  uint64_t v3 = sub_100010420((uint64_t)a1, 0x40000000u, *(void *)(a1[47] + 1256LL), 1, 1, &v8);
  if ((_DWORD)v3)
  {
    uint64_t v2 = v3;
    sub_100013D94( "%s:%d: %s failed to get mapping tree, error: %d\n",  "nx_unblock_physical_range",  3023,  (const char *)(a1[48] + 208LL),  v3);
    goto LABEL_11;
  }

  uint64_t v2 = sub_100029238((size_t)v8, v9, &v7);
  sub_100038824(v8);
  if (!(_DWORD)v2)
  {
    *(void *)(a1[47] + 1256LL) = 0LL;
    uint64_t v2 = sub_10004FD28((uint64_t)a1, v9, 0);
    if ((_DWORD)v2) {
      return v2;
    }
    goto LABEL_8;
  }

  sub_100013D94("%s:%d: %s failed to delete mapping, error: %d\n");
LABEL_11:
  int v5 = sub_10004FD28((uint64_t)a1, v9, 0);
  if (v5) {
    sub_100013D94( "%s:%d: %s tx_leave failed with error: %d\n",  "nx_unblock_physical_range",  3067,  (const char *)(a1[48] + 208LL),  v5);
  }
  return v2;
}

uint64_t sub_100013538(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v2 = sub_100032B28();
  if ((unint64_t)(v2 - *(void *)(a1 + 1792)) >= 0x3B9ACA01)
  {
    unint64_t v3 = 0LL;
    *(void *)(a1 + 1792) = v2;
LABEL_6:
    *(void *)(a1 + 1800) = v3 + 1;
    return 1LL;
  }

  unint64_t v3 = *(void *)(a1 + 1800);
  if (v3 <= 0xF) {
    goto LABEL_6;
  }
  return 0LL;
}

uint64_t sub_1000135A8( uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, int64_t, unint64_t *, int64_t *), uint64_t a3, unint64_t *a4, int64_t *a5, int a6)
{
  int64_t v12 = *a5;
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  int64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = 0LL;
  uint64_t v13 = a2(a1, a3, v12, &v25, &v26);
  if (!(_DWORD)v13)
  {
    if (v26 >= v12)
    {
      uint64_t v13 = 0LL;
      *a4 = v25;
      return v13;
    }

    uint64_t v13 = sub_100027C40(a1, 0x88000000, 2, 10, 0, 8u, 16, (uint64_t)sub_10001282C, 0LL, (uint64_t *)&v24);
    if (!(_DWORD)v13)
    {
      unint64_t v21 = v25;
      int64_t v22 = v26;
      unint64_t v23 = 0LL;
      uint64_t v13 = sub_10001EADC(v24, 0LL, &v23, 8, &v21, 0x10u, 0LL);
      if (!(_DWORD)v13)
      {
        unint64_t v14 = v26;
        uint64_t v15 = v12 - v26;
        if (v15 < 1)
        {
LABEL_10:
          unint64_t v18 = 0x80000000LL;
          if (a6) {
            unint64_t v18 = 0x8000000000000000LL;
          }
          *a5 |= v18;
          uint64_t v13 = 0LL;
          *a4 = sub_10003965C((uint64_t)v24) | 0x8000000000000000LL;
          uint64_t v19 = v24;
          if (v24) {
            goto LABEL_19;
          }
          return v13;
        }

        while (1)
        {
          uint64_t v16 = a2(a1, a3, v15, &v25, &v26);
          if ((_DWORD)v16) {
            break;
          }
          unint64_t v21 = v25;
          int64_t v22 = v26;
          unint64_t v23 = v14;
          uint64_t v16 = sub_10001EADC(v24, 0LL, &v23, 8, &v21, 0x10u, 0LL);
          if ((_DWORD)v16) {
            break;
          }
          v14 += v26;
          BOOL v17 = v15 <= v26;
          v15 -= v26;
          if (v17) {
            goto LABEL_10;
          }
        }

        uint64_t v13 = v16;
      }

      if (v24)
      {
        sub_100029238((size_t)v24, 0LL, 0LL);
        uint64_t v19 = v24;
LABEL_19:
        sub_100038824(v19);
      }
    }
  }

  return v13;
}

uint64_t sub_100013780(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 376);
  unint64_t v5 = *(void *)(v4 + 48);
  if (!v5) {
    return 0LL;
  }
  int64_t v22 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v23 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = sub_10003B574( *(void *)(a1 + 392),  0x80000001,  v5,  (int *)&xmmword_10005B7A0,  0LL,  0LL,  0LL,  a3,  (uint64_t *)&v23);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    sub_100013D94( "%s:%d: %s failed to get reap list head: %d\n",  "nx_reaper_next_record",  1691,  (const char *)(*(void *)(a1 + 384) + 208LL),  v8);
    return v9;
  }

  uint64_t v10 = v23;
  if (*(void *)(v4 + 88))
  {
LABEL_21:
    sub_100038824(v10);
    return 0LL;
  }

  uint64_t v11 = v23[47];
  while (1)
  {
    while (1)
    {
      unsigned int v12 = *(_DWORD *)(v11 + 52);
      if (v12 == -1) {
        break;
      }
      uint64_t v13 = v11 + 40LL * v12;
      unint64_t v14 = (_DWORD *)(v13 + 68);
      *(_DWORD *)(v4 + 104) = *(_DWORD *)(v13 + 68);
      *(void *)(v4 + 72) = *(void *)(v13 + 72);
      *(_OWORD *)(v4 + 80) = *(_OWORD *)(v13 + 80);
      *(void *)(v4 + 96) = *(void *)(v13 + 96);
      sub_10003E644(a2, a3, 0LL);
      int v17 = *(_DWORD *)(v13 + 64);
      uint64_t v16 = (_DWORD *)(v13 + 64);
      int v15 = v17;
      if (*(_DWORD *)(v11 + 52) == *(_DWORD *)(v11 + 56)) {
        *(_DWORD *)(v11 + 56) = v15;
      }
      *unint64_t v14 = 0;
      _DWORD *v16 = *(_DWORD *)(v11 + 60);
      *(_DWORD *)(v11 + 60) = v12;
      --*(_DWORD *)(v11 + 48);
      *(_DWORD *)(v11 + 52) = v15;
      sub_10003E644((uint64_t)v23, a3, 0LL);
      if (*(void *)(v4 + 88)) {
        goto LABEL_20;
      }
    }

    unint64_t v18 = *(void *)(v11 + 32);
    if (!v18)
    {
      if (!*(_DWORD *)(v4 + 68) && *(void *)(v4 + 48) == *(void *)(v4 + 56))
      {
        *(_DWORD *)(v4 + 68) = 1;
        sub_10003E644(a2, a3, 0LL);
      }

uint64_t sub_1000139BC(pthread_mutex_t *a1)
{
  return pthread_mutex_init(a1, 0LL);
}

uint64_t sub_1000139C8(pthread_rwlock_t *a1)
{
  return pthread_rwlock_init(a1, 0LL);
}

uint64_t sub_1000139D4(pthread_cond_t *a1)
{
  return pthread_cond_init(a1, 0LL);
}

pthread_cond_t *sub_1000139DC(pthread_cond_t *result)
{
  if (result) {
    return (pthread_cond_t *)pthread_cond_destroy(result);
  }
  return result;
}

uint64_t sub_1000139E8(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3, uint64_t a4, timespec *a5)
{
  if (!a5) {
    return pthread_cond_wait(a1, a2);
  }
  v15.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v15.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_REALTIME, &v15);
  BOOL v8 = __OFADD__(a5->tv_sec, v15.tv_sec);
  __darwin_time_t v9 = a5->tv_sec + v15.tv_sec;
  a5->tv_sec = v9;
  if (v8) {
    return 35LL;
  }
  uint64_t tv_nsec = a5->tv_nsec;
  BOOL v8 = __OFADD__(tv_nsec, v15.tv_nsec);
  unint64_t v12 = tv_nsec + v15.tv_nsec;
  if (v8) {
    unint64_t v12 = 999999999LL;
  }
  a5->uint64_t tv_nsec = v12;
  if (v12 > 0x3B9ACA00)
  {
    unint64_t v13 = v12 - 1000000000;
    unint64_t v14 = (v13 - 1) / 0x3B9ACA00;
    a5->tv_sec = v9 + v14 + 1;
    a5->uint64_t tv_nsec = v13 - 1000000000 * v14;
  }

  LODWORD(result) = pthread_cond_timedwait(a1, a2, a5);
  if ((_DWORD)result == 60) {
    return 35LL;
  }
  else {
    return result;
  }
}

uint64_t sub_100013AD4(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3, timespec *a4)
{
  return sub_1000139E8(a1, a2, a3, (uint64_t)a4, a4);
}

uint64_t sub_100013AE0(const char *a1)
{
  if (strnlen(a1, 2uLL) > 1) {
    return -1LL;
  }
  int v3 = *a1;
  switch(*a1)
  {
    case 'S':
      return 448LL;
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'c':
    case 'f':
    case 'g':
    case 'j':
    case 'l':
    case 'm':
    case 'q':
    case 't':
    case 'w':
      return -1LL;
    case 'a':
      return 128LL;
    case 'b':
      return 16LL;
    case 'd':
      return 64LL;
    case 'e':
      return 576LL;
    case 'h':
      return 320LL;
    case 'i':
      return 32LL;
    case 'k':
      return 384LL;
    case 'n':
      return 512LL;
    case 'o':
      return 704LL;
    case 'p':
      return 192LL;
    case 'r':
      return 4LL;
    case 's':
      return 1LL;
    case 'u':
      return 2LL;
    case 'v':
      return 8LL;
    case 'x':
      return 256LL;
    default:
      if (v3 == 48)
      {
        uint64_t result = 0LL;
      }

      else
      {
        if (v3 != 68) {
          return -1LL;
        }
        uint64_t result = 640LL;
      }

      break;
  }

  return result;
}

uint64_t sub_100013BD8(unsigned int a1)
{
  unsigned int v1 = (a1 >> 12) ^ 8;
  if (v1 == 15) {
    return 0LL;
  }
  else {
    return word_10005B7F6[v1];
  }
}

void *sub_100013C00(int a1, _DWORD *a2)
{
  if (a1 < 1) {
    return 0LL;
  }
  int v3 = 1;
  do
  {
    unsigned int v4 = v3;
    v3 *= 2;
  }

  while (v4 <= a1);
  unsigned int v5 = v4 >> 1;
  unint64_t v6 = sub_100014044(8LL * (v4 >> 1));
  unint64_t v7 = v6;
  if (v6)
  {
    if (v5 <= 1) {
      unsigned int v8 = 1;
    }
    else {
      unsigned int v8 = v5;
    }
    bzero(v6, 8LL * v8);
    *a2 = v5 - 1;
  }

  return v7;
}

unint64_t sub_100013C78( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  unint64_t v5 = a2 + a1;
  unint64_t v6 = a4 + a3;
  if (a2 + a1 > a3)
  {
    BOOL v7 = v6 >= a1;
    BOOL v8 = v6 == a1;
  }

  else
  {
    BOOL v7 = 0;
    BOOL v8 = 0;
  }

  BOOL v9 = !v8 && v7 && v5 >= a1;
  if (!v9 || v6 < a3) {
    return 0LL;
  }
  if (a1 <= a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = a1;
  }
  if (v5 >= v6) {
    unint64_t v5 = a4 + a3;
  }
  if (a5) {
    *a5 = v11;
  }
  return v5 - v11;
}

const char *sub_100013CBC(const char *result, ...)
{
  if (dword_100070004 >= 5) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

const char *sub_100013D04(const char *result, ...)
{
  if (dword_100070004 >= 4) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

const char *sub_100013D4C(const char *result, ...)
{
  if (dword_100070004 >= 3) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

const char *sub_100013D94(const char *result, ...)
{
  if (dword_100070004 >= 2) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

uint64_t sub_100013DDC( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_100070004 >= 1) {
    return vfprintf(__stderrp, a2, &a9);
  }
  return result;
}

void *sub_100013E20(size_t __size, uint64_t a2)
{
  if (__size == 0x2000)
  {
    size_t v2 = qword_100070028;
  }

  else
  {
    size_t v2 = __size;
    if (__size == 4096) {
      size_t v2 = *(void *)((char *)&unk_100070008 + ((a2 << 63 >> 63) & 0x78) + 8);
    }
  }

  uint64_t result = calloc(1uLL, v2);
  if (result)
  {
    do
      unint64_t v4 = __ldxr(&qword_100070550);
    while (__stxr(v4 + v2, &qword_100070550));
  }

  return result;
}

void *sub_100013E98(unsigned int a1)
{
  size_t v1 = *((void *)&unk_100070008 + 3 * a1 + 1);
  uint64_t result = calloc(1uLL, v1);
  if (result)
  {
    do
      unint64_t v3 = __ldxr(&qword_100070550);
    while (__stxr(v3 + v1, &qword_100070550));
  }

  return result;
}

void *sub_100013EEC(size_t a1, size_t a2)
{
  uint64_t result = calloc(a1, a2);
  if (result)
  {
    do
      unint64_t v5 = __ldxr(&qword_100070550);
    while (__stxr(v5 + a2 * a1, &qword_100070550));
  }

  return result;
}

void sub_100013F30(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 0x2000)
  {
    if (!a1) {
      return;
    }
    unint64_t v4 = &qword_100070028;
  }

  else
  {
    uint64_t v3 = a2;
    if (a2 != 4096)
    {
      if (!a1) {
        return;
      }
      goto LABEL_9;
    }

    if (!a1) {
      return;
    }
    unint64_t v4 = (uint64_t *)((char *)&unk_100070008 + ((a3 << 63 >> 63) & 0x78) + 8);
  }

  uint64_t v3 = *v4;
LABEL_9:
  free(a1);
  do
    unint64_t v5 = __ldxr(&qword_100070550);
  while (__stxr(v5 - v3, &qword_100070550));
}

void sub_100013FB4(void *a1, unsigned int a2)
{
  if (a1)
  {
    uint64_t v2 = *((void *)&unk_100070008 + 3 * a2 + 1);
    free(a1);
    do
      unint64_t v3 = __ldxr(&qword_100070550);
    while (__stxr(v3 - v2, &qword_100070550));
  }

void sub_100014004(void *a1, uint64_t a2)
{
  if (a1)
  {
    free(a1);
    do
      unint64_t v3 = __ldxr(&qword_100070550);
    while (__stxr(v3 - a2, &qword_100070550));
  }

void *sub_100014044(size_t a1)
{
  uint64_t result = malloc(a1);
  if (result)
  {
    do
      unint64_t v3 = __ldxr(&qword_100070550);
    while (__stxr(v3 + a1, &qword_100070550));
  }

  return result;
}

void *sub_100014080(void *a1, uint64_t a2, size_t __size)
{
  uint64_t result = realloc(a1, __size);
  if (result)
  {
    do
      unint64_t v6 = __ldxr(&qword_100070550);
    while (__stxr(v6 + __size - a2, &qword_100070550));
  }

  return result;
}

uint64_t sub_1000140C8(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 4 && a5 == 4)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_1000140FC( unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5, void *a6)
{
  if (!a4) {
    return 28LL;
  }
  unint64_t v6 = a1;
  if (a1 <= a2 || a4 < a1)
  {
    if (0x180000000LL * (a2 >> 12) > a4) {
      return 28LL;
    }
    if (a4 >> 34)
    {
      uint64_t v9 = 0x1000000000LL;
      if (a4 >= 0x1000000000LL) {
        unint64_t v10 = 0x1000000000LL;
      }
      else {
        unint64_t v10 = a4;
      }
      uint64_t v8 = v10 >> 5;
      if (a4 >= 0x1000000001LL)
      {
        if (a4 - 0x1000000000LL < 0x1000000000LL) {
          uint64_t v9 = a4 - 0x1000000000LL;
        }
        v8 += ((unint64_t)v9 * (unsigned __int128)0x666666666666667uLL) >> 64;
        if (a4 >= 0x2000000001LL)
        {
          unint64_t v11 = a4 - 0x2000000000LL;
          if (a4 - 0x2000000000LL >= 0x2000000000LL) {
            unint64_t v11 = 0x2000000000LL;
          }
          v8 += v11 >> 7;
          if (a4 >= 0x4000000001LL) {
            v8 += (a4 - 0x4000000000LL) / 0xA0;
          }
        }
      }
    }

    else
    {
      uint64_t v8 = 0x20000000LL;
    }

    unint64_t v6 = v8 * (a2 >> 12);
    if (v6 >= a4 >> 2) {
      unint64_t v6 = a4 >> 2;
    }
  }

  uint64_t result = 0LL;
  unint64_t v12 = v6 / a2;
  *a5 = v12 * a2;
  *a6 = a3 - v12;
  return result;
}

unint64_t sub_100014204( unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  if (a5) {
    *a5 = (a2 >> 1) / result + a3;
  }
  if (a6)
  {
    unint64_t v6 = (a2 >> 4) / result;
    if (v6 >= 0x8000000 / result) {
      unint64_t v6 = 0x8000000 / result;
    }
    *a6 = a4 - v6;
  }

  return result;
}

uint64_t (*sub_100014240(unsigned __int16 a1))()
{
  int v1 = a1;
  uint64_t result = (uint64_t (*)())sub_1000479E8;
  switch(v1)
  {
    case 9:
      return result;
    case 10:
      uint64_t result = (uint64_t (*)())sub_10001282C;
      break;
    case 11:
      uint64_t result = (uint64_t (*)())sub_10003F28C;
      break;
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 35:
      goto LABEL_5;
    case 14:
    case 15:
    case 16:
    case 36:
      uint64_t result = (uint64_t (*)())sub_100015700;
      break;
    case 19:
      uint64_t result = (uint64_t (*)())sub_10003F2E8;
      break;
    case 21:
      uint64_t result = (uint64_t (*)())sub_100003F20;
      break;
    case 31:
      uint64_t result = (uint64_t (*)())sub_100004E88;
      break;
    case 32:
      uint64_t result = (uint64_t (*)())sub_1000029F0;
      break;
    case 33:
      uint64_t result = (uint64_t (*)())sub_10001AC0C;
      break;
    case 34:
      uint64_t result = (uint64_t (*)())sub_1000140C8;
      break;
    default:
      if (v1 == 255) {
        uint64_t result = off_100070098[0];
      }
      else {
LABEL_5:
      }
        uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t sub_1000142F8()
{
  return 22LL;
}

void sub_100014300(uint64_t a1, unsigned __int8 *a2)
{
  if (a2)
  {
    switch(*a2)
    {
      case 1u:
        sub_100014004(*((void **)a2 + 9), *((unsigned __int16 *)a2 + 32));
        goto LABEL_20;
      case 2u:
        unint64_t v4 = a2;
        uint64_t v3 = 40LL;
        goto LABEL_26;
      case 3u:
        if ((*((_WORD *)a2 + 48) & 0xF000) == 0xA000)
        {
          unint64_t v5 = (void *)*((void *)a2 + 44);
          if (v5)
          {
            sub_100014004(v5, *((int *)a2 + 90));
            *((void *)a2 + 44) = 0LL;
          }
        }

        sub_100051550((uint64_t)(a2 + 408));
        if ((a2[117] & 0x10) != 0)
        {
          j__pthread_rwlock_destroy((pthread_rwlock_t *)(a2 + 448));
          j__pthread_rwlock_destroy((pthread_rwlock_t *)(a2 + 120));
          *((void *)a2 + 14) &= ~0x100000000000uLL;
        }

        sub_100013FB4(a2, 2u);
        return;
      case 4u:
      case 5u:
      case 7u:
      case 0xBu:
        goto LABEL_3;
      case 6u:
      case 0xCu:
        unint64_t v4 = a2;
        uint64_t v3 = 24LL;
        goto LABEL_26;
      case 8u:
        unint64_t v4 = a2;
        uint64_t v3 = 56LL;
        goto LABEL_26;
      case 9u:
        sub_100051550((uint64_t)(a2 + 32));
        sub_100014004(*((void **)a2 + 8), *((unsigned __int16 *)a2 + 31));
        goto LABEL_25;
      case 0xAu:
      case 0x12u:
        sub_100051550((uint64_t)(a2 + 64));
        unint64_t v4 = a2;
        uint64_t v3 = 96LL;
        goto LABEL_26;
      case 0xDu:
        int v6 = a2[16];
        if (v6 == 2) {
          goto LABEL_19;
        }
        if (v6 != 1) {
          return;
        }
LABEL_3:
        uint64_t v3 = *((unsigned __int16 *)a2 + 1);
        unint64_t v4 = a2;
LABEL_26:
        sub_100014004(v4, v3);
        break;
      case 0x10u:
LABEL_19:
        sub_100051550((uint64_t)(a2 + 56));
LABEL_20:
        unint64_t v4 = a2;
        uint64_t v3 = 80LL;
        goto LABEL_26;
      case 0x11u:
        unint64_t v4 = a2;
        uint64_t v3 = 32LL;
        goto LABEL_26;
      case 0x13u:
        sub_100051550((uint64_t)(a2 + 48));
LABEL_25:
        unint64_t v4 = a2;
        uint64_t v3 = 72LL;
        goto LABEL_26;
      default:
        sub_100013D94("%s:%d: *** Can't release unknown obj type %d\n", "jobj_release", 2823, *a2);
        return;
    }
  }

uint64_t sub_10001449C(uint64_t result, unsigned __int8 *a2, uint64_t a3, int *a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *a2;
  unsigned int v9 = *a2;
  unint64_t v10 = v8 << 60;
  BOOL v11 = (v8 & 0xF0) == 0;
  unint64_t v12 = 0xE000000000000000LL;
  if (v11) {
    unint64_t v12 = v10;
  }
  *(void *)a3 = v12 & 0xF000000000000000LL | *((void *)a2 + 1) & 0xFFFFFFFFFFFFFFFLL;
  if (v9 >= 0x10)
  {
    if ((*(_BYTE *)(*(void *)(result + 376) + 57LL) & 2) == 0)
    {
      BOOL v13 = sub_100010058(*(void *)(result + 392));
      uint64_t result = sub_100013DDC( v13,  "%s:%d: %s ***: expanded obj type %d (obj_id %llu) found on unsupported volume\n",  v14,  v15,  v16,  v17,  v18,  v19,  (char)"make_jkey_from_jobj");
      *a4 = 0;
      return result;
    }

    if ((v9 & 0xFC) == 0x10)
    {
      *(_DWORD *)(a3 + 8) = v9;
    }

    else
    {
      BOOL v20 = sub_100010058(*(void *)(result + 392));
      uint64_t result = sub_100013DDC( v20,  "%s:%d: %s Cannot make large jkey from unknown type %d (obj_id %llu)\n",  v21,  v22,  v23,  v24,  v25,  v26,  (char)"make_large_jkey_header_from_jobj");
      unsigned int v9 = *a2;
    }
  }

  switch(v9)
  {
    case 4u:
      size_t v28 = *((unsigned __int16 *)a2 + 10);
      *(_WORD *)(a3 + 8) = v28;
      uint64_t result = (uint64_t)memcpy((void *)(a3 + 10), a2 + 24, v28);
      int v29 = *((unsigned __int16 *)a2 + 10);
      goto LABEL_19;
    case 5u:
    case 8u:
      *(void *)(a3 + 8) = *((void *)a2 + 2);
      int v27 = 16;
      goto LABEL_26;
    case 9u:
      unsigned int v30 = *((unsigned __int16 *)a2 + 31);
      if ((*(_BYTE *)(*(void *)(v7 + 376) + 56LL) & 9) != 0)
      {
        *(_DWORD *)(a3 + 8) = *((_WORD *)a2 + 31) & 0x3FF | (*((_DWORD *)a2 + 14) << 10);
        uint64_t v31 = (void *)(a3 + 12);
        int v32 = 12;
      }

      else
      {
        *(_WORD *)(a3 + 8) = v30;
        uint64_t v31 = (void *)(a3 + 10);
        int v32 = 10;
      }

      uint64_t result = (uint64_t)memcpy(v31, *((const void **)a2 + 8), v30);
      int v27 = v32 + *((unsigned __int16 *)a2 + 31);
      goto LABEL_26;
    case 0xAu:
      int v27 = 96;
      goto LABEL_26;
    case 0xBu:
      size_t v33 = *((unsigned __int16 *)a2 + 12);
      *(_WORD *)(a3 + 8) = v33;
      uint64_t result = (uint64_t)memcpy((void *)(a3 + 10), a2 + 26, v33);
      int v29 = *((unsigned __int16 *)a2 + 12);
LABEL_19:
      int v27 = v29 + 10;
      goto LABEL_26;
    case 0xDu:
      *a4 = 16;
      *(void *)(a3 + 8) = __ROR8__(*((void *)a2 + 2), 8);
      return result;
    case 0xEu:
      *a4 = 0;
      BOOL v34 = sub_100010058(*(void *)(v7 + 392));
      return sub_100013DDC( v34,  "%s:%d: %s ***: expanded type seen on in-memory obj!\n",  v35,  v36,  v37,  v38,  v39,  v40,  (char)"make_jkey_from_jobj");
    case 0x10u:
    case 0x13u:
      *(_OWORD *)(a3 + 12) = *((_OWORD *)a2 + 1);
      int v27 = 28;
      goto LABEL_26;
    case 0x11u:
      *(void *)(a3 + 12) = *((void *)a2 + 2);
      int v27 = 20;
      goto LABEL_26;
    case 0x12u:
      int v27 = 12;
      goto LABEL_26;
    default:
      int v27 = 8;
LABEL_26:
      *a4 = v27;
      break;
  }

  return result;
}

uint64_t sub_1000146EC(uint64_t a1, unsigned __int16 *__src, uint64_t a3, int *a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6 = *((void *)__src + 1);
  unsigned int v7 = *(unsigned __int8 *)__src;
  if (v7 <= 0xF) {
    unsigned __int8 v8 = *(_BYTE *)__src;
  }
  else {
    unsigned __int8 v8 = 14;
  }
  *(void *)a3 = v6 & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v8 << 60);
  unint64_t v9 = *a4;
  if (v7 < 0x10)
  {
    switch(v7)
    {
      case 1u:
        *(_OWORD *)a5 = *((_OWORD *)__src + 1);
        *(_OWORD *)(a5 + 16) = *((_OWORD *)__src + 2);
        *(void *)(a5 + 32) = *((void *)__src + 6);
        *(void *)(a5 + 40) = *((void *)__src + 7);
        size_t v16 = __src[32];
        *(_WORD *)(a5 + 48) = v16;
        strlcpy((char *)(a5 + 50), *((const char **)__src + 9), v16);
        goto LABEL_21;
      case 2u:
        unint64_t v55 = __src;
        int v25 = *((unsigned __int8 *)__src + 1);
        uint64_t v26 = *((void *)__src + 3);
        *(void *)a5 = *((void *)__src + 2) & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v25 << 60);
        *(void *)(a5 + 8) = v26;
        int v27 = *((_DWORD *)__src + 8);
        *(_DWORD *)(a5 + 16) = v27;
        if (v27 < 0 && v25 == 1)
        {
          sub_100013CBC( "%s:%d: inserting bad phy ext @ %p : kind %d refcnt %d\n",  "jobj_to_key_val",  1518,  &v55,  1,  v27);
          panic("bad pext.\n");
        }

        goto LABEL_21;
      case 3u:
        *a4 = 8;
        *(void *)a5 = *((void *)__src + 2);
        *(void *)(a5 + 8) = *((void *)__src + 3);
        *(void *)(a5 + 16) = *((void *)__src + 4);
        *(void *)(a5 + 24) = *((void *)__src + 5);
        *(void *)(a5 + 32) = *((void *)__src + 6);
        *(void *)(a5 + 40) = *((void *)__src + 7);
        *(_DWORD *)(a5 + 56) = *((_DWORD *)__src + 18);
        *(void *)(a5 + 48) = *((void *)__src + 8);
        *(_DWORD *)(a5 + 60) = *((_DWORD *)__src + 19);
        *(_DWORD *)(a5 + 64) = *((_DWORD *)__src + 20);
        *(_DWORD *)(a5 + 68) = *((_DWORD *)__src + 21);
        *(_DWORD *)(a5 + 72) = *((_DWORD *)__src + 22);
        *(_DWORD *)(a5 + 76) = *((_DWORD *)__src + 23);
        *(_WORD *)(a5 + 80) = __src[48];
        *(_WORD *)(a5 + 82) = __src[49];
        *(void *)(a5 + 84) = *((void *)__src + 13);
        if (!__src[204]) {
          return 0LL;
        }
        uint64_t result = sub_1000515A8(__src + 204, (_WORD *)(a5 + 92), a6 - 92LL);
        if (!(_DWORD)result) {
          return result;
        }
        sub_100013CBC("%s:%d: %s failed to serialize ino %lld into jval of size %u\n");
        return 7LL;
      case 4u:
        size_t v28 = __src[10];
        *(_WORD *)(a3 + 8) = v28;
        if (v28 + 10 > v9) {
          return 7LL;
        }
        strlcpy((char *)(a3 + 10), (const char *)__src + 24, v28);
        *a4 = *(unsigned __int16 *)(a3 + 8) + 10;
        *(_WORD *)a5 = *((_DWORD *)__src + 4);
        size_t v29 = __src[11];
        *(_WORD *)(a5 + 2) = v29;
        memcpy((void *)(a5 + 4), (char *)__src + __src[10] + 24, v29);
        return 0LL;
      case 5u:
        uint64_t v30 = *((void *)__src + 3);
        *(void *)(a3 + 8) = *((void *)__src + 2);
        *a4 = 16;
        *(void *)a5 = v30;
        size_t v31 = __src[16];
        *(_WORD *)(a5 + 8) = v31;
        strlcpy((char *)(a5 + 10), (const char *)__src + 34, v31);
        return 0LL;
      case 6u:
        uint64_t result = 0LL;
        *(_DWORD *)a5 = *((_DWORD *)__src + 4);
        goto LABEL_37;
      case 7u:
        *a4 = 8;
        sub_100014EB4(__src, (_DWORD *)a5);
        return 0LL;
      case 8u:
        uint64_t v32 = *((void *)__src + 2);
        *(void *)(a3 + 8) = v32;
        *a4 = 16;
        unint64_t v33 = *((void *)__src + 5);
        if (HIBYTE(v33))
        {
          sub_100013CBC( "%s:%d: %s File extent too large (%llu > %llu): laddr %llu, paddr %llu\n",  "jobj_to_key_val",  1553,  (const char *)(a1 + 3992),  v33,  0xFFFFFFFFFFFFFFLL,  v32,  *((void *)__src + 3));
          return 22LL;
        }

        uint64_t v52 = *((void *)__src + 4);
        if (v52 == -1) {
          panic( "fext %lld (pos %lld len %lld flags %x can not have crypto-id -1\n",  v6,  v32,  *((void *)__src + 5),  *((unsigned __int8 *)__src + 48));
        }
        uint64_t result = 0LL;
        uint64_t v53 = *((void *)__src + 3);
        *(void *)a5 = v33 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)__src + 48) << 56);
        *(void *)(a5 + 8) = v53;
        *(void *)(a5 + 16) = v52;
        return result;
      case 9u:
        size_t v34 = __src[31];
        if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 9) != 0)
        {
          if (v34 + 12 <= v9)
          {
            *(_DWORD *)(a3 + 8) = v34 & 0x3FF | (*((_DWORD *)__src + 14) << 10);
            uint64_t v35 = (char *)(a3 + 12);
            int v36 = 12;
            goto LABEL_64;
          }
        }

        else if (v34 + 10 <= v9)
        {
          *(_WORD *)(a3 + 8) = v34;
          uint64_t v35 = (char *)(a3 + 10);
          int v36 = 10;
LABEL_64:
          strlcpy(v35, *((const char **)__src + 8), v34);
          *a4 = v36 + __src[31];
          *(_WORD *)(a5 + 16) = __src[30];
          int v54 = __src[16];
          *(void *)a5 = *((void *)__src + 2);
          *(void *)(a5 + 8) = *((void *)__src + 3);
          if (v54)
          {
            uint64_t result = sub_1000515A8(__src + 16, (_WORD *)(a5 + 18), a6 - 18LL);
            if (!(_DWORD)result) {
              return result;
            }
            sub_100013CBC( "%s:%d: failed to serialize drec %lld/%s into jval of size %u\n",  "jobj_to_key_val",  1662,  *((void *)__src + 1),  *((const char **)__src + 8),  a6);
          }

          return 0LL;
        }

        return 7LL;
      case 0xAu:
        uint64_t result = 0LL;
        *(_OWORD *)a5 = *(_OWORD *)(__src + 12);
        *(int8x16_t *)(a5 + 16) = vextq_s8(*((int8x16_t *)__src + 3), *((int8x16_t *)__src + 3), 8uLL);
        goto LABEL_37;
      case 0xBu:
        size_t v38 = __src[12];
        *(_WORD *)(a3 + 8) = v38;
        if (v38 + 10 > v9) {
          return 7LL;
        }
        strlcpy((char *)(a3 + 10), (const char *)__src + 26, v38);
        uint64_t result = 0LL;
        int v39 = *(unsigned __int16 *)(a3 + 8) + 10;
LABEL_42:
        *a4 = v39;
        *(void *)a5 = *((void *)__src + 2);
        return result;
      case 0xCu:
        uint64_t result = 0LL;
        int v39 = 8;
        goto LABEL_42;
      case 0xDu:
        int v40 = *((unsigned __int8 *)__src + 16);
        if (v40 == 2)
        {
          if (__src[28] && sub_1000515A8(__src + 28, (_WORD *)(a5 + 26), a6 - 26LL))
          {
            sub_100013CBC("%s:%d: %s failed to serialize file info with obj_id <%lld> into jval of size <%u>\n");
            return 7LL;
          }

          *(_WORD *)(a5 + 24) = __src[24];
          *(void *)a5 = *((void *)__src + 3);
          *(void *)(a5 + 8) = *((void *)__src + 4);
          *(void *)(a5 + 16) = *((void *)__src + 5);
        }

        else
        {
          if (v40 != 1) {
            return 22LL;
          }
          size_t v41 = *((unsigned __int8 *)__src + 26);
          if (v41 + 3 > a6) {
            return 7LL;
          }
          *(_BYTE *)(a5 + 2) = v41;
          *(_WORD *)a5 = __src[12];
          memcpy((void *)(a5 + 3), (char *)__src + 27, v41);
        }

        uint64_t result = 0LL;
        *(void *)(a3 + 8) = __ROR8__(*((void *)__src + 2), 8);
        int v37 = 16;
        goto LABEL_38;
      case 0xEu:
        *a4 = 0;
        BOOL v42 = sub_100010058(*(void *)(a1 + 392));
        sub_100013DDC( v42,  "%s:%d: %s ***: expanded type seen on in-memory obj!\n",  v43,  v44,  v45,  v46,  v47,  v48,  (char)"jobj_to_key_val");
        return 22LL;
      default:
LABEL_21:
        uint64_t result = 0LL;
LABEL_37:
        int v37 = 8;
        goto LABEL_38;
    }
  }

  if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) == 0)
  {
    sub_100013D94( "%s:%d: %s expanded obj type %hhu found on unsupported volume\n",  "jobj_to_key_val",  1492,  (const char *)(a1 + 3992),  v7);
    return 22LL;
  }

  if (v9 <= 0xB)
  {
    BOOL v17 = sub_100010058(*(void *)(a1 + 392));
    sub_100013DDC( v17,  "%s:%d: %s large key size (%u) on record (%llu) is too small\n",  v18,  v19,  v20,  v21,  v22,  v23,  (char)"jobj_to_key_val");
    return 22LL;
  }

  *(_DWORD *)(a3 + 8) = v7;
  switch(v7)
  {
    case 0x10u:
      int v24 = __src[28];
      *(_OWORD *)(a3 + 12) = *((_OWORD *)__src + 1);
      *(void *)a5 = *((void *)__src + 4);
      *(void *)(a5 + 8) = *((void *)__src + 5);
      *(_DWORD *)(a5 + 16) = *((_DWORD *)__src + 12);
      *(_DWORD *)(a5 + 20) = *((_DWORD *)__src + 13);
      sub_100013D94("%s:%d: %s failed to serialize purgeable %llu into jval of size %u\n");
      return 7LL;
    case 0x11u:
      uint64_t result = 0LL;
      uint64_t v49 = *((void *)__src + 3);
      *(void *)(a3 + 12) = *((void *)__src + 2);
      *(void *)a5 = v49;
      int v37 = 20;
      break;
    case 0x12u:
      int v50 = __src[32];
      *(void *)(a5 + 24) = *((void *)__src + 2);
      *(void *)a5 = *((void *)__src + 3);
      *(void *)(a5 + 8) = *((void *)__src + 4);
      *(void *)(a5 + 16) = *((void *)__src + 5);
      *(void *)(a5 + 32) = *((void *)__src + 7);
      *(void *)(a5 + 40) = *((void *)__src + 6);
      *(_DWORD *)(a5 + 48) = *((_DWORD *)__src + 23);
      sub_100013D94("%s:%d: %s failed to serialize dir-stats %lld into jval of size %u\n");
      return 7LL;
    case 0x13u:
      int v51 = __src[24];
      *(_OWORD *)(a3 + 12) = *((_OWORD *)__src + 1);
      *(void *)a5 = *((void *)__src + 4) & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*((_DWORD *)__src + 10) << 56);
      if (v51 && sub_1000515A8(__src + 24, (_WORD *)(a5 + 8), a6 - 8LL))
      {
        sub_100013D94("%s:%d: %s failed to serialize clone mapping <%llu/%llu> into jval of size %u\n");
        return 7LL;
      }

LABEL_58:
      uint64_t result = 0LL;
      int v37 = 28;
      break;
    default:
LABEL_53:
      uint64_t result = 0LL;
      int v37 = 12;
      break;
  }

        if (v74) {
          sub_100038824(v74);
        }
        if (v73) {
          sub_100038824(v73);
        }
      }
    }
  }

  return v4;
}

LABEL_38:
  *a4 = v37;
  return result;
}

      BOOL v13 = sub_100028D34(a1, a2, v17, a4);
      BOOL v17 = (uint64_t *)v21;
      goto LABEL_39;
    }

void *sub_100014EB4(_DWORD *__src, _DWORD *a2)
{
  int v2 = *((unsigned __int16 *)__src + 10);
  *a2 = __src[4];
  uint64_t v3 = a2 + 1;
  if (v2 == 6) {
    uint64_t v4 = HIBYTE(*((unsigned __int16 *)__src + 19)) + *((_WORD *)__src + 19);
  }
  else {
    uint64_t v4 = *((unsigned __int16 *)__src + 19);
  }
  return memcpy(v3, __src + 5, v4 + 20);
}

uint64_t sub_100014EE8(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v3 = *a2;
  if (v3 < 0xF || (*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) != 0)
  {
    uint64_t result = 8LL;
    switch(*a2)
    {
      case 1u:
      case 2u:
      case 3u:
      case 6u:
      case 7u:
      case 0xAu:
      case 0xCu:
        return result;
      case 4u:
        uint64_t v12 = *((unsigned __int16 *)a2 + 10);
        goto LABEL_12;
      case 5u:
      case 8u:
      case 0xDu:
        return 16LL;
      case 9u:
        uint64_t v12 = *((unsigned __int16 *)a2 + 31);
        if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 9) == 0) {
          goto LABEL_12;
        }
        uint64_t result = v12 + 12;
        break;
      case 0xBu:
        uint64_t v12 = *((unsigned __int16 *)a2 + 12);
LABEL_12:
        uint64_t result = v12 + 10;
        break;
      case 0xEu:
        BOOL v13 = sub_100010058(*(void *)(a1 + 392));
        sub_100013DDC( v13,  "%s:%d: %s ***: expanded type seen on in-memory obj!\n",  v14,  v15,  v16,  v17,  v18,  v19,  (char)"key_size_for_jobj");
        return 0LL;
      case 0x10u:
      case 0x13u:
        uint64_t result = 28LL;
        break;
      case 0x11u:
        uint64_t result = 20LL;
        break;
      case 0x12u:
        uint64_t result = 12LL;
        break;
      default:
        sub_100013D94("%s:%d: ***: unknown obj type %d\n", "key_size_for_jobj", 1911, v3);
        return 0LL;
    }
  }

  else
  {
    BOOL v4 = sub_100010058(*(void *)(a1 + 392));
    sub_100013DDC( v4,  "%s:%d: %s ***: expanded obj type %d found on unsupported volume\n",  v5,  v6,  v7,  v8,  v9,  v10,  (char)"key_size_for_jobj");
    return 0LL;
  }

  return result;
}

uint64_t sub_100015028(uint64_t a1, unsigned __int16 *a2)
{
  if (*(unsigned __int8 *)a2 < 0xFu || (*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) != 0)
  {
    uint64_t result = 20LL;
    switch(*(_BYTE *)a2)
    {
      case 1:
        return a2[32] + 50LL;
      case 2:
        return result;
      case 3:
        if (a2[204]) {
          return (int)sub_100051594(a2 + 204) + 92LL;
        }
        else {
          return 92LL;
        }
      case 4:
        return a2[11] + 4LL;
      case 5:
        return a2[16] + 10LL;
      case 6:
        return 4LL;
      case 7:
        if (a2[10] == 6) {
          uint64_t v10 = HIBYTE(a2[19]) + a2[19];
        }
        else {
          uint64_t v10 = a2[19];
        }
        return v10 + 24;
      case 8:
        return 24LL;
      case 9:
        if (a2[16]) {
          return (int)sub_100051594(a2 + 16) + 18LL;
        }
        else {
          return 18LL;
        }
      case 0xA:
        return 32LL;
      case 0xB:
      case 0xC:
      case 0x11:
        return 8LL;
      case 0xD:
        int v11 = *((void *)a2 + 2);
        if (v11 == 2)
        {
          if (a2[28]) {
            return (int)sub_100051594(a2 + 28) + 26LL;
          }
          else {
            return 26LL;
          }
        }

        if (v11 == 1) {
          return *((unsigned __int8 *)a2 + 26) + 3LL;
        }
        sub_100013D94("%s:%d: Unknown subtype %d for file info object %lld\n");
        break;
      case 0xE:
        sub_100013D94("%s:%d: %s ***: expanded type seen on in-memory obj\n");
        return 0LL;
      case 0x10:
        if (!a2[28]) {
          return 24LL;
        }
        uint64_t v10 = (int)sub_100051594(a2 + 28);
        return v10 + 24;
      case 0x12:
        if (a2[32]) {
          return (int)sub_100051594(a2 + 32) + 52LL;
        }
        else {
          return 52LL;
        }
      case 0x13:
        if (a2[24]) {
          return (int)sub_100051594(a2 + 24) + 8LL;
        }
        else {
          return 8LL;
        }
      default:
        sub_100013D94("%s:%d: ***: unknown obj type %d\n");
        return 0LL;
    }
  }

  else
  {
    BOOL v2 = sub_100010058(*(void *)(a1 + 392));
    sub_100013DDC( v2,  "%s:%d: %s ***: expanded obj type %d found on unsupported volume\n",  v3,  v4,  v5,  v6,  v7,  v8,  (char)"val_size_for_jobj");
  }

  return 0LL;
}

uint64_t sub_100015280(uint64_t a1, uint64_t a2)
{
  if (a2) {
    __asm { BR              X11 }
  }

  return 22LL;
}

uint64_t sub_1000154D8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) != 0)
  {
    switch(*(_BYTE *)(a2 + 8))
    {
      case 0x10:
        if (a3 <= 0x1B)
        {
          sub_100013D94("%s:%d: %s key size (%zu) on purgeable record (%llu) is too small\n");
          return 22LL;
        }

        uint64_t result = 0LL;
        if (a4 && a5 <= 0x17)
        {
          sub_100013D94("%s:%d: %s value size (%zu) on purgeable record (%llu) is too small\n");
          return 22LL;
        }

        break;
      case 0x11:
        if (a3 <= 0x13)
        {
          sub_100013D94("%s:%d: %s key size (%zu) on purgeable tombstone (%llu) is too small\n");
          return 22LL;
        }

        uint64_t result = 0LL;
        if (a4 && a5 <= 7)
        {
          sub_100013D94("%s:%d: %s value size (%zu) on purgeable tombstone (%llu) is too small\n");
          return 22LL;
        }

        break;
      case 0x12:
        uint64_t result = 0LL;
        if (a4 && a5 <= 0x33)
        {
          sub_100013D94("%s:%d: %s value size (%zu) on dir stats (%llu) is too small\n");
          return 22LL;
        }

        break;
      case 0x13:
        if (a3 <= 0x1B)
        {
          sub_100013D94("%s:%d: %s key size (%zu) on clone mapping (%llu) is too small\n");
          return 22LL;
        }

        uint64_t result = 0LL;
        if (a4 && a5 <= 7)
        {
          sub_100013D94("%s:%d: %s value size (%zu) on clone mapping (%llu) is too small\n");
          return 22LL;
        }

        break;
      default:
        uint64_t result = 0LL;
        if (a4 && a5 <= 3)
        {
          sub_100013D94("%s:%d: %s value size (%zu) on unknown record (%llu) is too small\n");
          return 22LL;
        }

        break;
    }
  }

  else
  {
    sub_100013D94("%s:%d: %s ***: expanded obj type found on unsupported volume\n");
    return 22LL;
  }

  return result;
}

uint64_t sub_100015700(uint64_t a1, void *a2, unsigned int a3, void *a4, unsigned int a5, int *a6)
{
  uint64_t v6 = 22LL;
  if (a3 >= 8 && a5 >= 8)
  {
    unint64_t v10 = *a2 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v11 = *a4 & 0xFFFFFFFFFFFFFFFLL;
    if (v10 < v11)
    {
LABEL_4:
      int v12 = -1;
LABEL_24:
      uint64_t v6 = 0LL;
      *a6 = v12;
      return v6;
    }

    if (v10 > v11) {
      goto LABEL_6;
    }
    uint64_t v13 = *a2 >> 60;
    uint64_t v14 = *a4 >> 60;
    if (!(_DWORD)v13)
    {
      BOOL v17 = (_DWORD)v14 == 0;
LABEL_21:
      if (v17) {
        int v12 = 0;
      }
      else {
        int v12 = -1;
      }
      goto LABEL_24;
    }

    if (!(_DWORD)v14) {
      goto LABEL_6;
    }
    if ((_DWORD)v13 != 14)
    {
LABEL_16:
      int v12 = sub_100015280(a1, (uint64_t)a4);
      if (v12) {
        return 22LL;
      }
      switch((int)v13)
      {
        case 4:
        case 11:
          goto LABEL_27;
        case 5:
          unint64_t v23 = a2[1];
          unint64_t v24 = a4[1];
          if (!v23) {
            goto LABEL_60;
          }
          if (!v24) {
            break;
          }
          BOOL v25 = v23 >= v24;
          BOOL v26 = v23 > v24;
          goto LABEL_57;
        case 8:
          unint64_t v27 = a2[1];
          unint64_t v28 = a4[1];
          if (v27 == -1LL)
          {
            BOOL v17 = v28 == -1LL;
            goto LABEL_21;
          }

          if (v28 == -1LL) {
            break;
          }
          BOOL v29 = v27 > v28;
          if (v27 >= v28) {
            goto LABEL_73;
          }
          goto LABEL_4;
        case 9:
          if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 9) == 0)
          {
LABEL_27:
            uint64_t v19 = (unsigned __int8 *)a2 + 10;
            uint64_t v20 = (unsigned __int8 *)a4 + 10;
            unint64_t v21 = *((unsigned __int16 *)a2 + 4);
            unint64_t v22 = *((unsigned __int16 *)a4 + 4);
LABEL_28:
            int v12 = sub_1000198D8(v19, v20, v21, v22);
            goto LABEL_24;
          }

          unsigned int v30 = *((_DWORD *)a2 + 2);
          unsigned int v31 = *((_DWORD *)a4 + 2);
          if (v30 >> 10 < v31 >> 10) {
            goto LABEL_4;
          }
          if (v30 >> 10 <= v31 >> 10)
          {
            unint64_t v21 = v30 & 0x3FF;
            unint64_t v22 = v31 & 0x3FF;
            uint64_t v19 = (unsigned __int8 *)a2 + 12;
            uint64_t v20 = (unsigned __int8 *)a4 + 12;
            goto LABEL_28;
          }

          break;
        case 13:
          unint64_t v32 = a2[1];
          unint64_t v33 = HIBYTE(v32);
          unint64_t v34 = a4[1];
          unint64_t v35 = HIBYTE(v34);
          if (!HIBYTE(v32))
          {
            BOOL v17 = v35 == 0;
            goto LABEL_21;
          }

          if (!v35) {
            break;
          }
          if (v33 != v35)
          {
            if (v33 < v35) {
              int v12 = -1;
            }
            else {
              int v12 = 1;
            }
            goto LABEL_24;
          }

          unint64_t v44 = v32 & 0xFFFFFFFFFFFFFFLL;
          unint64_t v45 = v34 & 0xFFFFFFFFFFFFFFLL;
          if (v44 == 0xFFFFFFFFFFFFFFLL)
          {
            BOOL v17 = v45 == 0xFFFFFFFFFFFFFFLL;
            goto LABEL_21;
          }

          if (v45 == 0xFFFFFFFFFFFFFFLL) {
            break;
          }
          BOOL v25 = v44 >= v45;
          BOOL v39 = v44 == v45;
LABEL_54:
          BOOL v26 = !v39;
LABEL_57:
          if (v25) {
            int v12 = v26;
          }
          else {
            int v12 = -1;
          }
          goto LABEL_24;
        case 16:
          unint64_t v36 = *(void *)((char *)a2 + 12);
          unint64_t v24 = *(void *)((char *)a4 + 12);
          if (!v36) {
            goto LABEL_60;
          }
          if (!v24) {
            break;
          }
          if (v36 < v24) {
            goto LABEL_4;
          }
          if (v36 != v24)
          {
            BOOL v29 = v36 > v24;
LABEL_73:
            int v12 = v29;
            goto LABEL_24;
          }

          unint64_t v37 = *(void *)((char *)a2 + 20);
          unint64_t v24 = *(void *)((char *)a4 + 20);
          if (!v37)
          {
LABEL_60:
            BOOL v17 = v24 == 0;
            goto LABEL_21;
          }

          if (!v24) {
            break;
          }
          if (v37 >= v24)
          {
            int v12 = v37 != v24;
            goto LABEL_24;
          }

          goto LABEL_4;
        case 17:
          unint64_t v38 = *(void *)((char *)a2 + 12);
          unint64_t v24 = *(void *)((char *)a4 + 12);
          if (!v38) {
            goto LABEL_60;
          }
          if (!v24) {
            break;
          }
          BOOL v25 = v38 >= v24;
          BOOL v39 = v38 == v24;
          goto LABEL_54;
        case 19:
          unint64_t v40 = *(void *)((char *)a2 + 12);
          unint64_t v41 = *(void *)((char *)a4 + 12);
          if (v40 < v41) {
            goto LABEL_4;
          }
          if (v40 > v41) {
            break;
          }
          unint64_t v42 = *(void *)((char *)a2 + 20);
          unint64_t v43 = *(void *)((char *)a4 + 20);
          BOOL v29 = v42 > v43;
          if (v42 < v43) {
            goto LABEL_4;
          }
          goto LABEL_73;
        default:
          goto LABEL_24;
      }

uint64_t sub_1000159FC(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  unsigned int v10 = sub_100015028(a1, (unsigned __int16 *)a3);
  uint64_t v11 = sub_100014EE8(a1, a3);
  unsigned int v36 = v11;
  uint64_t v12 = 22LL;
  if (v10 && (_DWORD)v11)
  {
    if ((v11 & 7) != 0) {
      uint64_t v13 = (v11 & 0x1FFF8) + 8;
    }
    else {
      uint64_t v13 = v11;
    }
    uint64_t v14 = v13 + v10;
    __chkstk_darwin();
    BOOL v17 = (unint64_t *)((char *)&v29 - v16);
    if ((_DWORD)v15) {
      memset((char *)&v29 - v16, 170, v15);
    }
    if (v14 < 0x251 || (BOOL v17 = (unint64_t *)sub_100014044(v13 + v10)) != 0LL)
    {
      uint64_t v29 = (uint64_t)&v29;
      uint64_t v18 = (char *)v17 + v13;
      uint64_t v12 = sub_1000146EC(a1, (unsigned __int16 *)a3, (uint64_t)v17, (int *)&v36, (uint64_t)v17 + v13, v10);
      if (!(_DWORD)v12)
      {
        switch(a5)
        {
          case 1:
            goto LABEL_16;
          case 2:
            if (*a3 == 3) {
              uint64_t v19 = (uint64_t *)(a3 + 320);
            }
            else {
              uint64_t v19 = 0LL;
            }
            uint64_t v12 = sub_100023C40(a2, *(void *)(a1 + 432), v17, v36, v18, v10, a4, v19);
            if ((_DWORD)v12 != 28) {
              goto LABEL_26;
            }
LABEL_16:
            uint64_t v20 = sub_10001EADC(a2, *(void *)(a1 + 432), v17, v36, v18, v10, a4);
LABEL_25:
            uint64_t v12 = v20;
            goto LABEL_26;
          case 3:
            uint64_t v35 = 0LL;
            __int128 v34 = 0u;
            __int128 v33 = 0u;
            memset(&v32[2], 0, 32);
            v32[0] = a1;
            v32[1] = a4;
            int v21 = *a3;
            if (v21 == 18 || v21 == 10)
            {
              HIDWORD(v35) = *((_DWORD *)a3 + 22);
              *((void *)&v34 + 1) = *((void *)a3 + 6);
            }

            break;
          case 4:
            uint64_t v20 = sub_1000260EC((uint64_t)a2, *(void *)(a1 + 432), v17, v36, a4);
            goto LABEL_25;
          default:
            uint64_t v12 = 22LL;
            goto LABEL_26;
        }

        uint64_t v12 = sub_10002415C( (uint64_t)a2,  *(void *)(a1 + 432),  v17,  v36,  (uint64_t)v18,  v10,  1,  a4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100016BBC,  (uint64_t)v32);
        switch(*a3)
        {
          case 2u:
            *((_DWORD *)a3 + 8) = v32[2];
            break;
          case 3u:
          case 4u:
          case 5u:
          case 8u:
          case 9u:
          case 0xBu:
          case 0xCu:
            break;
          case 6u:
          case 7u:
            *((_DWORD *)a3 + 4) = v32[2];
            break;
          case 0xAu:
            goto LABEL_30;
          case 0xDu:
            if (a3[16] == 2LL) {
              *((void *)a3 + 3) = v32[2];
            }
            break;
          default:
            if (*a3 != 18) {
              break;
            }
LABEL_30:
            int v23 = *((_DWORD *)a3 + 22);
            if ((v23 & 8) != 0)
            {
              *(_OWORD *)(a3 + 24) = *(_OWORD *)&v32[3];
              uint64_t v28 = *((void *)&v34 + 1);
              *((void *)a3 + 5) = v32[5];
              *((void *)a3 + 6) = v28;
              *((_DWORD *)a3 + 23) = v35;
              unint64_t v24 = (unsigned __int16 *)(a3 + 64);
              sub_100051620((unsigned __int16 *)a3 + 32, 1, 0, &v33, 8uLL);
              sub_100051620((unsigned __int16 *)a3 + 32, 3, 0, (char *)&v33 + 8, 8uLL);
              unint64_t v27 = (unint64_t *)&v34;
              goto LABEL_44;
            }

            if ((v23 & 0x200) != 0)
            {
              *((void *)a3 + 6) = *((void *)&v34 + 1);
              *((_DWORD *)a3 + 23) = v35;
            }

            if ((v35 & 0x80000000000LL) != 0)
            {
              unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
              unint64_t __dst = 0xAAAAAAAAAAAAAAAALL;
              unint64_t v24 = (unsigned __int16 *)(a3 + 64);
              int v25 = sub_1000518D4((unsigned __int16 *)a3 + 32, 4, 0LL, (char *)&v30, 8uLL);
              unint64_t v26 = v30;
              if (v25) {
                unint64_t v26 = 0LL;
              }
              unint64_t v30 = v26 - v34;
              __dst -= *((void *)&v33 + 1);
              *((_DWORD *)a3 + 23) |= 8u;
              sub_100051620((unsigned __int16 *)a3 + 32, 3, 0, &__dst, 8uLL);
              if (v30)
              {
                *((_DWORD *)a3 + 23) |= 0x800u;
                unint64_t v27 = &v30;
LABEL_44:
                sub_100051620(v24, 4, 0, v27, 8uLL);
              }
            }

            *((void *)a3 + 7) = v32[2];
            *((_DWORD *)a3 + 22) = HIDWORD(v35);
            break;
        }
      }

LABEL_26:
    }

    else
    {
      return 12LL;
    }
  }

  return v12;
}

    int v23 = 1;
    goto LABEL_27;
  }

  int v23 = 0;
LABEL_27:
  if (v20 | v23)
  {
    if (v20)
    {
      *((void *)&v32 + 1) = a7;
      uint64_t v16 = sub_10001EADC(v29[1], 0LL, &v32, 16LL, v30, 16LL, a7);
    }

    else
    {
      uint64_t v16 = 0LL;
    }

    if (v23 && !(_DWORD)v16)
    {
      if (a3 == a7 && v20)
      {
        uint64_t v16 = 0LL;
      }

      else
      {
        *((void *)&v32 + 1) = a3;
        unint64_t v24 = sub_1000260EC(v29[1], 0LL, &v32, 16LL, a7);
        uint64_t v16 = v24;
        if (v20 && (_DWORD)v24)
        {
          *((void *)&v32 + 1) = a7;
          sub_1000260EC(v29[1], 0LL, &v32, 16LL, a7);
LABEL_44:
          sub_100038824(v29[1]);
          BOOL v17 = v29[2];
          goto LABEL_45;
        }
      }
    }

    if (!v23 || (_DWORD)v16) {
      goto LABEL_44;
    }
    unint64_t v22 = sub_10004BD08( a1,  0LL,  a4,  (a5 + *(_DWORD *)(*(void *)(v15 + 376) + 36LL) - 1)
          / *(_DWORD *)(*(void *)(v15 + 376) + 36LL),
            a7);
LABEL_43:
    uint64_t v16 = v22;
    goto LABEL_44;
  }

  sub_100038824(v29[1]);
  sub_10003D514(v29[2], 2);
  sub_100038824(v29[2]);
  return 0LL;
}

uint64_t sub_100015E2C( uint64_t a1, int a2, uint64_t a3, char *__s, size_t a5, uint64_t a6, unsigned int a7, int a8, int a9, int a10, int a11, uint64_t a12, int a13, void *a14, uint64_t a15, int a16, int a17)
{
  int v25 = a14;
  int v27 = a16;
  int v26 = a17;
  uint64_t v69 = 0LL;
  int v67 = a17;
  int v68 = -1431655766;
  *a14 = 0LL;
  if (v27)
  {
    unint64_t v61 = v25;
    int v28 = a2;
    if (a3) {
      uint64_t v29 = *(void *)(a3 + 8);
    }
    else {
      uint64_t v29 = 1LL;
    }
LABEL_10:
    uint64_t v31 = sub_100019FE8(a1, 1, __s, a5, v26, v29, a6, &v69);
    int v68 = v31;
    if (!(_DWORD)v31)
    {
      unint64_t v32 = sub_100013E98(2u);
      if (!v32)
      {
        sub_100014300(0LL, v69);
        return 12LL;
      }

      __int128 v33 = v32;
      uint64_t v60 = v29;
      uint64_t v34 = a15;
      uint64_t v35 = sub_100032B28();
      *((void *)v69 + 3) = v35;
      __int16 v36 = sub_100013BD8(a7);
      unint64_t v37 = v69;
      *((_WORD *)v69 + 30) = v36;
      int v38 = sub_10001811C(a1, v28, v37, v34);
      if (v38)
      {
        BOOL v39 = strerror(v38);
        unint64_t v40 = sub_100013D94( "%s:%d: %s %s: could not insert dir rec for obj-id %lld (name: %s)\n",  "fs_obj_create_name_checked",  13374,  (const char *)(a1 + 3992),  v39,  *((void *)v69 + 1),  __s);
        sub_100014300((uint64_t)v40, v69);
        sub_100013FB4(v33, 2u);
        return 22LL;
      }

      *__int128 v33 = 42467587;
      *((void *)v33 + 1) = a6;
      *((void *)v33 + 2) = v60;
      *((void *)v33 + 6) = v35;
      *((void *)v33 + 7) = v35;
      *((void *)v33 + 4) = v35;
      *((void *)v33 + 5) = v35;
      *((void *)v33 + 3) = a6;
      *((_WORD *)v33 + 48) = a7;
      v33[22] = a8;
      v33[23] = a9;
      v33[20] = 1;
      v33[21] = a10;
      if ((a7 & 0xF000) != 0x4000) {
        v33[18] = 1;
      }
      sub_1000139C8((pthread_rwlock_t *)(v33 + 112));
      sub_1000139C8((pthread_rwlock_t *)(v33 + 30));
      *((void *)v33 + 14) |= 0x100000000000uLL;
      uint64_t v41 = 48LL;
      if ((a7 & 0xF000) != 0x8000) {
        uint64_t v41 = 0LL;
      }
      sub_1000511D8((uint64_t)(v33 + 102), v41 + *((unsigned __int16 *)v69 + 31));
      sub_100051620((unsigned __int16 *)v33 + 204, 4, 2, *((void **)v69 + 8), *((unsigned __int16 *)v69 + 31));
      if ((v33[24] & 0xB000 | 0x4000) == 0x6000)
      {
        if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) != 0)
        {
          v33[26] = a11;
        }

        else
        {
          uint64_t v42 = sub_100051620((unsigned __int16 *)v33 + 204, 14, 34, &a11, 4uLL);
          if ((_DWORD)v42)
          {
            uint64_t v31 = v42;
            unint64_t v43 = sub_100013D94( "%s:%d: %s *** failed to set rdev as an extended field of ino %lld (ret %d)\n",  "fs_obj_create_name_checked",  13432,  (const char *)(a1 + 3992),  *((void *)v33 + 1),  v42);
            sub_100014300((uint64_t)v43, (unsigned __int8 *)v33);
            __int128 v33 = 0LL;
            goto LABEL_64;
          }
        }
      }

      if (a3)
      {
        *((void *)v33 + 8) = *(void *)(a3 + 64) & 0x20400002LL;
        if ((*(_BYTE *)(a3 + 64) & 2) != 0)
        {
          unint64_t __dst = 0xAAAAAAAAAAAAAAAALL;
          if (sub_1000518D4((unsigned __int16 *)(a3 + 408), 10, 0LL, (char *)&__dst, 8uLL))
          {
            if (sub_100013538(*(void *)(a1 + 392))) {
              sub_100013D94( "%s:%d: %s ino %llu is flagged to maintain dir-stats but has no dir-stats key\n",  "fs_obj_create_name_checked",  13449,  (const char *)(a1 + 3992),  *(void *)(a3 + 8));
            }
          }

          else
          {
            sub_100051620((unsigned __int16 *)v33 + 204, 10, 34, &__dst, 8uLL);
          }
        }

        if ((v33[24] & 0xF000) == 0x8000 && (*(_BYTE *)(a3 + 67) & 2) != 0)
        {
          *((void *)v33 + 8) |= 0x100000uLL;
          unint64_t __dst = sub_1000036B0(a3);
          sub_100051620((unsigned __int16 *)v33 + 204, 15, 2, &__dst, 8uLL);
        }
      }

      int v47 = a13;
      uint64_t v48 = a12;
      __int16 v49 = *((_WORD *)v33 + 48);
      if ((v49 & 0xF000) == 0x4000)
      {
        uint64_t v50 = *(void *)(a1 + 376);
        if ((*(_BYTE *)(v50 + 57) & 2) != 0)
        {
          v33[26] = 0;
        }

        else if ((*(_BYTE *)(v50 + 48) & 2) != 0)
        {
          unint64_t __dst = 0LL;
          sub_100051620((unsigned __int16 *)v33 + 204, 17, 0, &__dst, 8uLL);
          __int16 v49 = *((_WORD *)v33 + 48);
        }
      }

      *((void *)v33 + 14) |= 0x200000000uLL;
      *((void *)v33 + 8) |= v48 | 0x8000;
      v33[19] = v47;
      if ((v49 & 0xF000) == 0x8000
        && sub_10002F2C4(a1) == 3
        && (sub_10001AB90(a1, (uint64_t)v33) & 1) == 0
        && (v33[19] & 0x1F) == 6)
      {
        panic("assertion failed: %s", "ino_poison_vnode(apfs, inode)");
      }

      uint64_t v44 = sub_10001811C(a1, v28, (unsigned __int8 *)v33, v34);
      if ((_DWORD)v44)
      {
        uint64_t v31 = v44;
        int v51 = strerror(v44);
        sub_100013D94( "%s:%d: %s %s: could not insert inode obj-id %lld (name: %s)\n",  "fs_obj_create_name_checked",  13514,  (const char *)(a1 + 3992),  v51,  *((void *)v33 + 1),  *((const char **)v69 + 8));
        uint64_t v52 = v69;
        v69[1] = 3;
        uint64_t v53 = sub_100018458(a1, v28, v52, v34);
        int v54 = v61;
        if ((_DWORD)v53)
        {
          unint64_t v55 = strerror(v53);
          uint64_t v53 = (uint64_t)sub_100013D94( "%s:%d: %s %s: could not remove dir rec for obj-id %lld (name: %s)\n",  "fs_obj_create_name_checked",  13520,  (const char *)(a1 + 3992),  v55,  *((void *)v33 + 1),  *((const char **)v69 + 8));
        }

        sub_100014300(v53, (unsigned __int8 *)v33);
        __int128 v33 = 0LL;
        goto LABEL_65;
      }

      if (a3)
      {
        int v56 = v28;
        if (v28 != 4 || v60 != 2)
        {
          uint64_t v58 = sub_100032B28();
          *(void *)(a3 + 40) = v58;
          *(void *)(a3 + 48) = v58;
          *(void *)(a3 + 112) |= 0x40000uLL;
          __int128 v63 = 0u;
          __int128 v64 = 0u;
          __int128 v65 = 0u;
          uint64_t v62 = 1LL;
          sub_100032690((const char *)a1, a3, &v62, v34);
          int v54 = v61;
          if ((v33[24] & 0xF000) == 0x4000) {
            sub_10001A240(a1, a3);
          }
          ++*(_DWORD *)(a3 + 72);
          ++*(_DWORD *)(a3 + 80);
          *(_BYTE *)(a3 + 1) = 2;
          uint64_t v44 = sub_10001811C(a1, v56, (unsigned __int8 *)a3, v34);
          uint64_t v31 = v44;
          if ((_DWORD)v44)
          {
            unint64_t v59 = sub_100013D94( "%s:%d: %s failed to update parent ino %lld nchildren field on create of %s (err %d)\n",  "fs_obj_create_name_checked",  13545,  (const char *)(a1 + 3992),  *(void *)(a3 + 8),  *((const char **)v69 + 8),  v44);
            sub_100014300((uint64_t)v59, (unsigned __int8 *)v33);
            __int128 v33 = 0LL;
          }

          goto LABEL_65;
        }
      }

      uint64_t v31 = 0LL;
LABEL_64:
      int v54 = v61;
LABEL_65:
      sub_100014300(v44, v69);
      *int v54 = v33;
      return v31;
    }

    return v31;
  }

  if (!a5) {
    a5 = strlen(__s);
  }
  if (a5 > 0x2FD) {
    return 63LL;
  }
  unint64_t v30 = sub_10001A2F0((uint64_t)__s, a5, 1u, 0LL, &v68);
  if (v30 > 0xFF) {
    return 63LL;
  }
  if (!v30 && v68) {
    return 22LL;
  }
  unint64_t v61 = v25;
  int v28 = a2;
  if (a3) {
    uint64_t v29 = *(void *)(a3 + 8);
  }
  else {
    uint64_t v29 = 1LL;
  }
  if (a3) {
    unint64_t v45 = (uint64_t *)(a3 + 336);
  }
  else {
    unint64_t v45 = 0LL;
  }
  uint64_t v46 = sub_10001A630(a1, v29, __s, a5, v45, &v67, 0LL);
  int v68 = v46;
  if (!(_DWORD)v46)
  {
    sub_100014300(v46, v69);
    return 17LL;
  }

  uint64_t v31 = v46;
  if ((_DWORD)v46 == 2)
  {
    int v26 = v67;
    goto LABEL_10;
  }

  return v31;
}

uint64_t sub_100016560(uint64_t a1, int a2, uint64_t a3, uint64_t **a4)
{
  return sub_10001656C(a1, a2, a3, *(void *)(a1 + 432), a4);
}

uint64_t sub_10001656C(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t **a5)
{
  uint64_t v9 = 0LL;
  switch(a2)
  {
    case 1:
      goto LABEL_59;
    case 2:
      unsigned int v10 = (pthread_mutex_t *)(a1 + 1400);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1400));
      uint64_t v11 = *(char **)(a1 + 3568);
      if (v11)
      {
        sub_10003DC28(v11);
        if (a3)
        {
          uint64_t v9 = sub_10003CF9C(*(void **)(a1 + 3568), 2, a3);
          uint64_t v12 = *(uint64_t **)(a1 + 3568);
          if ((_DWORD)v9)
          {
            sub_100038824(v12);
            goto LABEL_93;
          }

          *(void *)(*(void *)(a1 + 376) + 144LL) = sub_10003965C((uint64_t)v12);
        }

        uint64_t v9 = 0LL;
        *a5 = *(uint64_t **)(a1 + 3568);
      }

      else
      {
        uint64_t v9 = sub_10002F554(a1, *(void *)(*(void *)(a1 + 376) + 144LL), a3, a5);
        if (!(_DWORD)v9)
        {
          if (a3) {
            *(void *)(*(void *)(a1 + 376) + 144LL) = sub_10003965C((uint64_t)*a5);
          }
          unint64_t v30 = *a5;
          *(void *)(a1 + 3568) = *a5;
          sub_10003DC28((char *)v30);
          uint64_t v9 = 0LL;
        }
      }

LABEL_93:
      unint64_t v45 = v10;
      goto LABEL_114;
    case 3:
      unsigned int v10 = (pthread_mutex_t *)(a1 + 1464);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1464));
      uint64_t v9 = sub_10002F598(a1, a3, a5);
      if (!(_DWORD)v9) {
        *(void *)(*(void *)(a1 + 376) + 152LL) = sub_10003965C((uint64_t)*a5);
      }
      goto LABEL_93;
    case 4:
      uint64_t v13 = *(uint64_t **)(a1 + 3560);
      if (v13)
      {
        sub_10003DC28(*(char **)(a1 + 3560));
        if (!a3) {
          goto LABEL_78;
        }
        uint64_t v14 = sub_10003CF9C(v13, 0, a3);
        if (!(_DWORD)v14) {
          goto LABEL_78;
        }
        uint64_t v9 = v14;
        sub_100038824(v13);
      }

      else
      {
        uint64_t v9 = 0LL;
      }

LABEL_59:
      uint64_t v13 = *(uint64_t **)(a1 + 3544);
      if (*(void *)(a1 + 432) != a4 || v13 == 0LL)
      {
        uint64_t v9 = sub_10002F52C(a1, a4, a3, a5);
        if ((_DWORD)v9) {
          return v9;
        }
        uint64_t v32 = *(void *)(a1 + 432);
        if (v32) {
          BOOL v33 = *(void *)(a1 + 496) == 0LL;
        }
        else {
          BOOL v33 = 0;
        }
        if (!v33 && v32 == a4)
        {
          uint64_t v44 = *a5;
          sub_10003DC28((char *)v44);
          uint64_t v9 = 0LL;
          *(void *)(a1 + 3544) = v44;
          return v9;
        }

        return 0LL;
      }

      sub_10003DC28(*(char **)(a1 + 3544));
      if (a3) {
        goto LABEL_74;
      }
      if ((_DWORD)v9) {
        return v9;
      }
      goto LABEL_78;
    case 5:
      uint64_t v15 = *(void *)(a1 + 376);
      if ((*(_BYTE *)(v15 + 56) & 0x20) == 0) {
        return 45LL;
      }
      int v16 = *(_DWORD *)(v15 + 1040);
      if (a3 && *(void *)(a1 + 440)) {
        return 30LL;
      }
      BOOL v17 = (pthread_mutex_t *)(a1 + 1528);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1528));
      __int16 v36 = *(char **)(a1 + 3576);
      if (!v36) {
        goto LABEL_100;
      }
      if ((v16 & 0xC0000000) == 0)
      {
        if (*(void *)(a1 + 432) == a4) {
          goto LABEL_96;
        }
LABEL_100:
        unint64_t v37 = *(void *)(a1 + 440);
        uint64_t v38 = *(void *)(a1 + 376);
        if (!v37) {
          unint64_t v37 = *(void *)(v38 + 1032);
        }
        goto LABEL_102;
      }

      if ((v16 & 0xC0000000) != 0x40000000) {
        goto LABEL_100;
      }
      unint64_t v37 = *(void *)(a1 + 440);
      if (!v37)
      {
LABEL_96:
        sub_10003DC28(v36);
        if (a3)
        {
          uint64_t v9 = sub_10003CF9C(*(void **)(a1 + 3576), 2, a3);
          int v27 = *(uint64_t **)(a1 + 3576);
          if ((_DWORD)v9) {
            goto LABEL_51;
          }
          *(void *)(*(void *)(a1 + 376) + 1032LL) = sub_10003965C((uint64_t)v27);
        }

        uint64_t v9 = 0LL;
        int v28 = *(uint64_t **)(a1 + 3576);
        goto LABEL_47;
      }

      uint64_t v38 = *(void *)(a1 + 376);
LABEL_102:
      int v46 = *(_DWORD *)(v38 + 1040);
      *(void *)&__int128 v52 = 0LL;
      __int128 v53 = 0u;
      uint64_t v57 = 0LL;
      __int128 v55 = 0u;
      __int128 v56 = 0u;
      __int128 v54 = 0u;
      int v51 = sub_100004E88;
      *((void *)&v52 + 1) = 0x20000001FLL;
      if ((unsigned __int16)v46 != 2)
      {
        uint64_t v9 = 22LL;
LABEL_108:
        uint64_t v48 = strerror(v9);
        sub_100013D94( "%s:%d: %s Failed to get fext tree w/oid %llu (modify_xid %llu): %d (%s)\n",  "jfs_get_tree_in_snap",  3887,  (const char *)(a1 + 3992),  v37,  a3,  v9,  v48);
        goto LABEL_113;
      }

      uint64_t v47 = sub_100027CC4(a1, v46 & 0xFFFF0000, v37, a4, a3 != 0, (uint64_t)&v51, a3, a5);
      uint64_t v9 = v47;
      if (a3 && !(_DWORD)v47)
      {
        *(void *)(*(void *)(a1 + 376) + 1032LL) = sub_10003965C((uint64_t)*a5);
        goto LABEL_113;
      }

      if ((_DWORD)v47) {
        goto LABEL_108;
      }
LABEL_113:
      unint64_t v45 = v17;
LABEL_114:
      pthread_mutex_unlock(v45);
      return v9;
    case 6:
      if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 0x40) == 0) {
        return 45LL;
      }
      BOOL v17 = (pthread_mutex_t *)(a1 + 1592);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1592));
      int v26 = *(char **)(a1 + 3584);
      if (!v26)
      {
        uint64_t v39 = *(void *)(a1 + 384);
        if (!v39) {
          uint64_t v39 = *(void *)(a1 + 376);
        }
        int v40 = *(_DWORD *)(v39 + 1044);
        unint64_t v41 = *(void *)(v39 + 1048);
        __int128 v52 = 0u;
        uint64_t v57 = 0LL;
        __int128 v55 = 0u;
        __int128 v56 = 0u;
        __int128 v54 = 0u;
        __int128 v53 = 0u;
        int v51 = sub_1000029F0;
        DWORD2(v52) = 32;
        if ((unsigned __int16)v40 == 2)
        {
          uint64_t v42 = sub_100027CC4(a1, v40 & 0xFFFF0000, v41, a4, a3 != 0, (uint64_t)&v51, a3, a5);
          uint64_t v43 = v42;
          if (a3 && !(_DWORD)v42)
          {
            uint64_t v9 = 0LL;
            *(void *)(*(void *)(a1 + 376) + 1048LL) = sub_10003965C((uint64_t)*a5);
            goto LABEL_113;
          }

          if (!(_DWORD)v42)
          {
LABEL_112:
            uint64_t v9 = 0LL;
            goto LABEL_113;
          }

          unint64_t v41 = *(void *)(v39 + 1048);
        }

        else
        {
          uint64_t v43 = 22LL;
        }

        __int16 v49 = strerror(v43);
        sub_100013D94( "%s:%d: %s Failed to get pfkur tree w/oid %llu (modify_xid %llu): %d (%s)\n",  "jfs_get_tree_in_snap",  3935,  (const char *)(a1 + 3992),  v41,  a3,  v43,  v49);
        uint64_t v9 = v43;
        goto LABEL_113;
      }

      sub_10003DC28(v26);
      if (a3)
      {
        uint64_t v9 = sub_10003CF9C(*(void **)(a1 + 3584), 2, a3);
        int v27 = *(uint64_t **)(a1 + 3584);
        if ((_DWORD)v9) {
          goto LABEL_51;
        }
        *(void *)(*(void *)(a1 + 376) + 1048LL) = sub_10003965C((uint64_t)v27);
      }

      uint64_t v9 = 0LL;
      int v28 = *(uint64_t **)(a1 + 3584);
LABEL_47:
      *a5 = v28;
      goto LABEL_113;
    case 7:
      BOOL v17 = (pthread_mutex_t *)(a1 + 1656);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1656));
      uint64_t v18 = *(uint64_t **)(a1 + 3592);
      if (*(void *)(a1 + 432) == a4 && v18 != 0LL)
      {
        sub_10003DC28(*(char **)(a1 + 3592));
        if (a3 && (uint64_t v29 = sub_10003CF9C(v18, 0, a3), (_DWORD)v29))
        {
          uint64_t v9 = v29;
          int v27 = v18;
LABEL_51:
          sub_100038824(v27);
        }

        else
        {
          uint64_t v9 = 0LL;
          *a5 = v18;
        }

        goto LABEL_113;
      }

      uint64_t v9 = sub_10002F660(a1, 0, a4, a3, a5);
      if ((_DWORD)v9) {
        goto LABEL_113;
      }
      if (*(void *)(a1 + 432) == a4)
      {
        uint64_t v20 = *a5;
        sub_10003DC28((char *)v20);
        uint64_t v9 = 0LL;
        *(void *)(a1 + 3592) = v20;
        goto LABEL_113;
      }

      goto LABEL_112;
    case 8:
      uint64_t v13 = *(uint64_t **)(a1 + 3552);
      if (*(void *)(a1 + 432) != a4 || v13 == 0LL)
      {
        uint64_t v9 = sub_10002F540(a1, a4, a3, a5);
        if (!(_DWORD)v9)
        {
          uint64_t v22 = *(void *)(a1 + 432);
          if (v22) {
            BOOL v23 = *(void *)(a1 + 496) == 0LL;
          }
          else {
            BOOL v23 = 0;
          }
          if (!v23 && v22 == a4)
          {
            int v25 = *a5;
            sub_10003DC28((char *)v25);
            uint64_t v9 = 0LL;
            *(void *)(a1 + 3552) = v25;
          }

          else
          {
            return 0LL;
          }
        }
      }

      else
      {
        sub_10003DC28(*(char **)(a1 + 3552));
        if (a3)
        {
LABEL_74:
          uint64_t v35 = sub_10003CF9C(v13, 0, a3);
          if ((_DWORD)v35)
          {
            uint64_t v9 = v35;
            sub_100038824(v13);
            return v9;
          }
        }

          sub_100038824(v106[0]);
          int v21 = *a3;
        }

        if (v21 != 2) {
          return v13;
        }
        uint64_t v35 = *(void *)(v8 + 56);
        if (v35)
        {
          __int16 v36 = *(_DWORD *)(v8 + 44);
          unint64_t v119 = 0u;
          BOOL v124 = 0LL;
          uint64_t v123 = 0u;
          int v122 = 0u;
          uint64_t v121 = 0u;
          uint64_t v120 = 0u;
          uint64_t v118 = sub_10003F2E8;
          DWORD2(v119) = 19;
          if ((unsigned __int16)v36 == 2)
          {
            uint64_t v13 = sub_100027CC4(v11, v36 & 0xFFFF0000, v35, 0LL, 0, (uint64_t)&v118, 0LL, v106);
            if (!(_DWORD)v13)
            {
              uint64_t v13 = sub_100029238((size_t)v106[0], v5, 0LL);
              if ((_DWORD)v13)
              {
                else {
                  unint64_t v37 = (const char *)(*(void *)(v11 + 384) + 208LL);
                }
                sub_100013D94("%s:%d: %s tree_delete() failed: %d\n", "omap_reap", 390, v37, v13);
              }

              sub_100038824(v106[0]);
              goto LABEL_72;
            }
          }

          else
          {
            uint64_t v13 = 22LL;
          }

          else {
            uint64_t v38 = (const char *)(*(void *)(v11 + 384) + 208LL);
          }
          sub_100013D94("%s:%d: %s failed to get omap snapshot tree for reaping: %d\n", "omap_reap", 386, v38, v13);
        }

LABEL_78:
        uint64_t v9 = 0LL;
        *a5 = v13;
      }

      return v9;
    default:
      return 22LL;
  }

uint64_t sub_100016BBC( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, unsigned int a6, int *a7, unsigned int a8, uint64_t a9)
{
  int v14 = sub_1000192DC(*(void *)a9, (uint64_t)a1);
  if (a6 < a8 && v14 != 18) {
    return 22LL;
  }
  uint64_t v16 = *a1 & 0xFFFFFFFFFFFFFFFLL;
  switch((unint64_t)*a1 >> 60)
  {
    case 2uLL:
      uint64_t result = 0LL;
      *(_DWORD *)(a9 + 16) = *((_DWORD *)a5 + 4);
      *((_DWORD *)a5 + 4) += a7[4];
      return result;
    case 6uLL:
      *(_DWORD *)(a9 + 16) = *(_DWORD *)a5;
      uint64_t v17 = *(unsigned int *)a5 + (uint64_t)*a7;
      uint64_t v18 = v17 << 31 >> 31;
      if (v18 == v17 && (v18 & 0x8000000000000000LL) == 0)
      {
        uint64_t result = 0LL;
        *(_DWORD *)a5 = v18;
        return result;
      }

      BOOL v65 = sub_100010058(*(void *)(*(void *)a9 + 392LL));
      sub_100013DDC( v65,  "%s:%d: %s dstream id %llu refcnt %u (delta: %d) would overflow\n",  v66,  v67,  v68,  v69,  v70,  v71,  (char)"jobj_refcnt_merge");
      return 0LL;
    case 7uLL:
      *(_DWORD *)(a9 + 16) = *(_DWORD *)a5;
      int v19 = *(_DWORD *)a5 + *a7;
      *(_DWORD *)a5 = v19;
      if (v19 < 0) {
        panic("can't have a negative refcnt on crypto state %llu refcnt %d\n", v16, v19);
      }
      return 0LL;
    case 9uLL:
      a5[1] = *((void *)a7 + 1);
      if (!*((_WORD *)a7 + 8)) {
        return 0LL;
      }
      uint64_t result = 0LL;
      *((_WORD *)a5 + 8) = *((_WORD *)a7 + 8);
      return result;
    case 0xAuLL:
      int v20 = *(_DWORD *)(a9 + 84);
      if ((v20 & 2) != 0)
      {
        if ((v20 & 4) != 0) {
          goto LABEL_33;
        }
      }

      else
      {
        uint64_t v21 = *(void *)a9;
        uint64_t v22 = *a5;
        uint64_t v23 = *(void *)a7;
        uint64_t v24 = *a5 + *(void *)a7;
        if (__CFADD__(*a5, *(void *)a7)) {
          uint64_t v25 = (*(uint64_t *)a7 >> 63) + 1;
        }
        else {
          uint64_t v25 = *(uint64_t *)a7 >> 63;
        }
        uint64_t v26 = v25 << 63 >> 63;
        if (v26 != v25 || v26 < 0)
        {
          if (sub_100013538(*(void *)(v21 + 392))) {
            sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v21 + 3992),  "num children",  "dir-stats",  v16,  "num children",  v22,  v23);
          }
          uint64_t v24 = v22;
        }

        *a5 = v24;
        uint64_t v27 = *(void *)a9;
        uint64_t v28 = a5[1];
        uint64_t v29 = *((void *)a7 + 1);
        uint64_t v30 = v28 + v29;
        if (__CFADD__(v28, v29)) {
          uint64_t v31 = (v29 >> 63) + 1;
        }
        else {
          uint64_t v31 = v29 >> 63;
        }
        uint64_t v32 = v31 << 63 >> 63;
        if (v32 != v31 || v32 < 0)
        {
          if (sub_100013538(*(void *)(v27 + 392))) {
            sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v27 + 3992),  "total size",  "dir-stats",  v16,  "total size",  v28,  v29);
          }
          uint64_t v30 = v28;
        }

        a5[1] = v30;
        int v20 = *(_DWORD *)(a9 + 84);
        if ((v20 & 4) != 0)
        {
LABEL_33:
          a5[2] = *((void *)a7 + 2);
          if ((*(_DWORD *)(a9 + 84) & 1) != 0) {
            goto LABEL_84;
          }
          goto LABEL_81;
        }
      }

      if ((v20 & 1) != 0) {
        goto LABEL_84;
      }
LABEL_81:
      unint64_t v64 = *((void *)a7 + 3);
      if (v64 <= 1) {
        unint64_t v64 = 1LL;
      }
      a5[3] += v64;
LABEL_84:
      if ((*(_BYTE *)(a9 + 84) & 8) != 0)
      {
        *(void *)(a9 + 24) = *a5;
        *(void *)(a9 + 32) = a5[1];
      }

      uint64_t result = 0LL;
      *(void *)(a9 + 16) = a5[2];
      return result;
    case 0xDuLL:
      unint64_t v33 = a1[1];
      if (HIBYTE(v33) != 2)
      {
        sub_100013D94("%s:%d: don't know how to merge refcounts on objects of file info type %llu\n");
        return 22LL;
      }

      uint64_t v34 = v33 & 0xFFFFFFFFFFFFFFLL;
      unsigned int v35 = *((unsigned __int16 *)a5 + 12);
      if (v35 >= 2) {
        *((_WORD *)a5 + 12) = v35 | 1;
      }
      *(void *)(a9 + 16) = *a5;
      uint64_t v36 = *(void *)a9;
      uint64_t v37 = a5[1];
      uint64_t v38 = *((void *)a7 + 1);
      uint64_t v39 = v37 + v38;
      if (__CFADD__(v37, v38)) {
        uint64_t v40 = (v38 >> 63) + 1;
      }
      else {
        uint64_t v40 = v38 >> 63;
      }
      uint64_t v41 = v40 << 63 >> 63;
      if (v41 != v40 || v41 < 0)
      {
        if (sub_100013538(*(void *)(v36 + 392))) {
          sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v36 + 3992),  "physical size",  "attr tag",  v34,  "physical size",  v37,  v38);
        }
        uint64_t v39 = v37;
      }

      a5[1] = v39;
      uint64_t v42 = *(void *)a9;
      uint64_t v43 = a5[2];
      uint64_t v44 = *((void *)a7 + 2);
      uint64_t v45 = v43 + v44;
      if (__CFADD__(v43, v44)) {
        uint64_t v46 = (v44 >> 63) + 1;
      }
      else {
        uint64_t v46 = v44 >> 63;
      }
      uint64_t v47 = v46 << 63 >> 63;
      if (v47 != v46 || v47 < 0)
      {
        if (sub_100013538(*(void *)(v42 + 392))) {
          sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v42 + 3992),  "full clone size",  "attr tag",  v34,  "full clone size",  v43,  v44);
        }
        uint64_t v45 = v43;
      }

      a5[2] = v45;
      uint64_t v48 = *(void *)a9;
      uint64_t v49 = *a5;
      uint64_t v50 = *(void *)a7;
      uint64_t v51 = *a5 + v50;
      if (__CFADD__(*a5, v50)) {
        uint64_t v52 = (v50 >> 63) + 1;
      }
      else {
        uint64_t v52 = v50 >> 63;
      }
      uint64_t v53 = v52 << 63 >> 63;
      if (v53 != v52 || v53 < 0)
      {
        if (sub_100013538(*(void *)(v48 + 392))) {
          sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v48 + 3992),  "total_count",  "attr tag",  v34,  "total_count",  v49,  v50);
        }
        uint64_t v51 = v49;
      }

      uint64_t result = 0LL;
      *a5 = v51;
      return result;
    case 0xEuLL:
      int v54 = *((unsigned __int8 *)a1 + 8);
      if (v54 != 19)
      {
        if (v54 != 18)
        {
          sub_100013D94("%s:%d: don't know how to merge refcounts on objects of expanded type %d\n");
          return 22LL;
        }

        unsigned int v55 = *(_DWORD *)(a9 + 84);
        *(_DWORD *)(a9 + 84) = 0;
        if ((v55 & 0x800000) != 0)
        {
          uint64_t result = 0LL;
          int v78 = a7[12];
          a5[3] = *((void *)a7 + 3);
          *((_DWORD *)a5 + 12) = v78 | 0x80;
          a5[4] = *((void *)a7 + 4);
          return result;
        }

        int v56 = *((_DWORD *)a5 + 12);
        uint64_t v57 = a5[4];
        BOOL v58 = (v56 & 0x20) == 0;
        if ((v55 & 0x4000) == 0) {
          BOOL v58 = 1;
        }
        if ((v55 & 0x100) != 0 && (v56 & 0x10) != 0 || !v58) {
          char v61 = 1;
        }
        else {
          char v61 = ((v55 & 0x40) == 0) & (((_DWORD)a5[6] & v55) >> 5) | ((a5[6] & 0x20) == 0) & (v55 >> 12);
        }
        unint64_t v62 = a6 - 52LL;
        uint64_t v188 = a5[1];
        uint64_t v187 = a5[2];
        if ((v56 & 8) != 0)
        {
          v194[0] = 0LL;
          LODWORD(v193) = 0;
          uint64_t v189 = 0LL;
          unsigned int v63 = *((_DWORD *)a5 + 12);
        }

        else
        {
          uint64_t v189 = 0LL;
          unsigned int v63 = *((_DWORD *)a5 + 12);
        }

        if ((v63 & 0x800) != 0)
        {
          v194[0] = 0LL;
          LODWORD(v193) = 0;
          int v80 = sub_100051390((unsigned __int16 *)a5 + 26, v62, 4, 0LL, v194, &v193);
          uint64_t v79 = 0LL;
          if (!v80 && (_DWORD)v193 == 8) {
            uint64_t v79 = *(void *)v194[0];
          }
          unsigned int v63 = *((_DWORD *)a5 + 12);
        }

        else
        {
          uint64_t v79 = 0LL;
        }

        if ((v63 & 0x200) != 0 && (v55 & 2) == 0)
        {
          uint64_t result = 0LL;
          *(void *)(a9 + 16) = *a1 & 0xFFFFFFFFFFFFFFFLL;
          int v81 = *(_DWORD *)(a9 + 84) | 0x400000;
LABEL_298:
          *(_DWORD *)(a9 + 84) = v81;
          return result;
        }

        uint64_t v184 = v79;
        if (v63 >= 0x1000)
        {
          v63 |= 0x100u;
          *((_DWORD *)a5 + 12) = v63;
        }

        if (a5[4] == (*a1 & 0xFFFFFFFFFFFFFFFLL))
        {
          *((_DWORD *)a5 + 12) = v63 | 0x400;
          a5[4] = 0LL;
        }

        int v186 = (v55 >> 1) & 1;
        if (!(v186 | v61 & 1))
        {
          unint64_t v185 = v62;
          uint64_t v183 = v57;
          uint64_t v82 = a8;
          uint64_t v83 = *(void *)a9;
          uint64_t v84 = *a1;
          uint64_t v85 = *a5;
          uint64_t v86 = *(void *)a7;
          uint64_t v87 = *a5 + *(void *)a7;
          if (__CFADD__(*a5, *(void *)a7)) {
            uint64_t v88 = (*(uint64_t *)a7 >> 63) + 1;
          }
          else {
            uint64_t v88 = *(uint64_t *)a7 >> 63;
          }
          uint64_t v89 = v88 << 63 >> 63;
          uint64_t v180 = v82;
          if (v89 != v88 || v89 < 0)
          {
            if (sub_100013538(*(void *)(v83 + 392))) {
              sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v83 + 3992),  "descendants",  "exp-dir-stats",  v84 & 0xFFFFFFFFFFFFFFFLL,  "descendants",  v85,  v86);
            }
            uint64_t v87 = v85;
            uint64_t v82 = v180;
          }

          *a5 = v87;
          uint64_t v90 = *(void *)a9;
          uint64_t v91 = *a1;
          uint64_t v92 = a5[1];
          uint64_t v93 = *((void *)a7 + 1);
          uint64_t v94 = v92 + v93;
          if (__CFADD__(v92, v93)) {
            uint64_t v95 = (v93 >> 63) + 1;
          }
          else {
            uint64_t v95 = v93 >> 63;
          }
          uint64_t v96 = v95 << 63 >> 63;
          if (v96 != v95 || v96 < 0)
          {
            if (sub_100013538(*(void *)(v90 + 392))) {
              sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v90 + 3992),  "physical size",  "exp-dir-stats",  v91 & 0xFFFFFFFFFFFFFFFLL,  "physical size",  v92,  v93);
            }
            uint64_t v94 = v92;
            uint64_t v82 = v180;
          }

          unint64_t v181 = v82 - 52;
          a5[1] = v94;
          int v97 = *((_DWORD *)a5 + 12);
          if ((v97 & 1) != 0)
          {
            uint64_t v98 = *(void *)a9;
            uint64_t v99 = *a1;
            uint64_t v100 = a5[2];
            uint64_t v101 = *((void *)a7 + 2);
            uint64_t v102 = v100 + v101;
            if (__CFADD__(v100, v101)) {
              uint64_t v103 = (v101 >> 63) + 1;
            }
            else {
              uint64_t v103 = v101 >> 63;
            }
            uint64_t v104 = v103 << 63 >> 63;
            if (v104 != v103 || v104 < 0)
            {
              if (sub_100013538(*(void *)(v98 + 392))) {
                sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v98 + 3992),  "resource fork size",  "exp-dir-stats",  v99 & 0xFFFFFFFFFFFFFFFLL,  "resource fork size",  v100,  v101);
              }
              uint64_t v102 = v100;
            }

            a5[2] = v102;
            int v97 = *((_DWORD *)a5 + 12);
          }

          uint64_t v57 = v183;
          unint64_t v62 = v185;
          if ((v97 & 4) != 0 && (a7[12] & 4) != 0)
          {
            unint64_t v191 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v105 = *(void *)a9;
            uint64_t v177 = *a1;
            uint64_t v193 = 0LL;
            v194[0] = 0LL;
            int v192 = 0;
            int v106 = sub_100051390((unsigned __int16 *)a5 + 26, v185, 1, 0LL, v194, &v192);
            unint64_t v107 = 0LL;
            if (!v106)
            {
              uint64_t v174 = v105;
              if (v192 == 8)
              {
                int v192 = 0;
                if (!sub_100051390((unsigned __int16 *)a7 + 26, v181, 1, 0LL, &v193, &v192)
                  && v192 == 8
                  && (uint64_t v108 = *v193) != 0)
                {
                  unint64_t v171 = *(void *)v194[0];
                  unint64_t v107 = *(void *)v194[0] + v108;
                  if (__CFADD__(*(void *)v194[0], v108)) {
                    uint64_t v109 = (v108 >> 63) + 1;
                  }
                  else {
                    uint64_t v109 = v108 >> 63;
                  }
                  uint64_t v110 = v109 << 63 >> 63;
                  if (v110 != v109 || v110 < 0)
                  {
                    if (sub_100013538(*(void *)(v174 + 392))) {
                      sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v174 + 3992),  "clone size",  "exp-dir-stats",  v177 & 0xFFFFFFFFFFFFFFFLL,  "clone size",  v171,  v108);
                    }
                    unint64_t v107 = v171;
                    uint64_t v57 = v183;
                    unint64_t v62 = v185;
                  }
                }

                else
                {
                  unint64_t v107 = *(void *)v194[0];
                }
              }
            }

            unint64_t v191 = v107;
            int v126 = sub_100051434((unsigned __int16 *)a5 + 26, v62, 1, &v191, 8);
            if (v126)
            {
              int v127 = v126;
              if (sub_100013538(*(void *)(*(void *)a9 + 392LL)))
              {
                uint64_t v128 = *(void *)a9 + 3992LL;
                uint64_t v129 = *a1 & 0xFFFFFFFFFFFFFFFLL;
                uint64_t v130 = strerror(v127);
                unsigned int v168 = (const char *)v128;
                unint64_t v62 = v185;
                sub_100013D94( "%s:%d: %s could not update clone size for dir-stats %llu: %s (%d)\n",  "exp_dir_stats_refcnt_merge",  3049,  v168,  v129,  v130,  v127);
              }
            }

            int v97 = *((_DWORD *)a5 + 12);
          }

          if ((v97 & 8) != 0 && (a7[12] & 8) != 0)
          {
            unint64_t v191 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v175 = *a1;
            uint64_t v178 = *(void *)a9;
            uint64_t v193 = 0LL;
            v194[0] = 0LL;
            int v192 = 0;
            unint64_t v131 = 0LL;
            if (!sub_100051390((unsigned __int16 *)a5 + 26, v62, 3, 0LL, v194, &v192) && v192 == 8)
            {
              int v192 = 0;
              if (!sub_100051390((unsigned __int16 *)a7 + 26, v181, 3, 0LL, &v193, &v192)
                && v192 == 8
                && (uint64_t v132 = *v193) != 0)
              {
                uint64_t v170 = *(void *)v194[0];
                uint64_t v172 = *v193;
                unint64_t v131 = *(void *)v194[0] + v132;
                if (__CFADD__(*(void *)v194[0], v132)) {
                  uint64_t v133 = (v132 >> 63) + 1;
                }
                else {
                  uint64_t v133 = v132 >> 63;
                }
                uint64_t v134 = v133 << 63 >> 63;
                if (v134 != v133 || v134 < 0)
                {
                  if (sub_100013538(*(void *)(v178 + 392))) {
                    sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v178 + 3992),  "purgeable size",  "exp-dir-stats",  v175 & 0xFFFFFFFFFFFFFFFLL,  "purgeable size",  v170,  v172);
                  }
                  uint64_t v57 = v183;
                  unint64_t v62 = v185;
                }
              }

              else
              {
                unint64_t v131 = *(void *)v194[0];
              }
            }

            unint64_t v191 = v131;
            int v135 = sub_100051434((unsigned __int16 *)a5 + 26, v62, 3, &v191, 8);
            if (v135)
            {
              int v136 = v135;
              if (sub_100013538(*(void *)(*(void *)a9 + 392LL)))
              {
                uint64_t v137 = *(void *)a9 + 3992LL;
                uint64_t v138 = *a1 & 0xFFFFFFFFFFFFFFFLL;
                unsigned int v139 = strerror(v136);
                unint64_t v169 = (const char *)v137;
                unint64_t v62 = v185;
                sub_100013D94( "%s:%d: %s could not update purgeable size for dir-stats %llu: %s (%d)\n",  "exp_dir_stats_refcnt_merge",  3062,  v169,  v138,  v139,  v136);
              }
            }

            int v97 = *((_DWORD *)a5 + 12);
          }

          if ((v97 & 0x800) != 0 && (*((_BYTE *)a7 + 49) & 8) != 0)
          {
            unint64_t v191 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v176 = *a1;
            uint64_t v179 = *(void *)a9;
            uint64_t v193 = 0LL;
            v194[0] = 0LL;
            int v192 = 0;
            unint64_t v140 = 0LL;
            if (!sub_100051390((unsigned __int16 *)a5 + 26, v62, 4, 0LL, v194, &v192) && v192 == 8)
            {
              int v192 = 0;
              if (!sub_100051390((unsigned __int16 *)a7 + 26, v181, 4, 0LL, &v193, &v192)
                && v192 == 8
                && (uint64_t v141 = *v193) != 0)
              {
                uint64_t v182 = *v193;
                uint64_t v173 = *(void *)v194[0];
                unint64_t v140 = *(void *)v194[0] + v141;
                if (__CFADD__(*(void *)v194[0], v141)) {
                  uint64_t v142 = (v141 >> 63) + 1;
                }
                else {
                  uint64_t v142 = v141 >> 63;
                }
                uint64_t v143 = v142 << 63 >> 63;
                if (v143 != v142 || v143 < 0)
                {
                  if (sub_100013538(*(void *)(v179 + 392))) {
                    sub_100013D94( "%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n",  "jobj_merge_maybe_clamp_64",  2839,  (const char *)(v179 + 3992),  "purgeable rsrc size",  "exp-dir-stats",  v176 & 0xFFFFFFFFFFFFFFFLL,  "purgeable rsrc size",  v173,  v182);
                  }
                  uint64_t v57 = v183;
                  unint64_t v62 = v185;
                }
              }

              else
              {
                unint64_t v140 = *(void *)v194[0];
              }
            }

            unint64_t v191 = v140;
            int v144 = sub_100051434((unsigned __int16 *)a5 + 26, v62, 4, &v191, 8);
            if (v144)
            {
              int v145 = v144;
              if (sub_100013538(*(void *)(**(void **)a9 + 392LL)))
              {
                int v146 = sub_100037DC8(*(void *)a9);
                uint64_t v147 = *(void *)a9;
                if (v146 == 13) {
                  unsigned __int16 v148 = (const char *)(v147 + 3992);
                }
                else {
                  unsigned __int16 v148 = (const char *)(*(void *)(v147 + 384) + 208LL);
                }
                uint64_t v149 = *a1 & 0xFFFFFFFFFFFFFFFLL;
                uint64_t v150 = strerror(v145);
                sub_100013D94( "%s:%d: %s could not update purgeable rsrc size for dir-stats %llu: %s (%d)\n",  "exp_dir_stats_refcnt_merge",  3076,  v148,  v149,  v150,  v145);
                unint64_t v62 = v185;
              }
            }
          }
        }

        if ((v55 & 0x8000) != 0) {
          *((_DWORD *)a5 + 12) |= 2u;
        }
        if ((v55 & 4) != 0) {
          a5[4] = *((void *)a7 + 4);
        }
        int v151 = *((_DWORD *)a5 + 12);
        if ((v151 & 8) != 0)
        {
          if ((v55 & 0x400) != 0 && (v56 & 0x40) == 0)
          {
            unsigned int v152 = v151 | 0x40;
            int v153 = 1024;
LABEL_231:
            *((_DWORD *)a5 + 12) = v152;
            *(_DWORD *)(a9 + 84) |= v153;
            goto LABEL_232;
          }

          if ((v55 & 0x800) != 0 && (v56 & 0x40) != 0)
          {
            unsigned int v152 = v151 & 0xFFFFFFBF;
            int v153 = 2048;
            goto LABEL_231;
          }
        }

LABEL_232:
        if ((v55 & 1) == 0)
        {
          unint64_t v154 = *((void *)a7 + 5);
          if (v154 <= 1) {
            unint64_t v154 = 1LL;
          }
          a5[5] += v154;
          char v155 = v186;
          if ((v56 & 0x40) == 0) {
            char v155 = 1;
          }
          if ((v155 & 1) == 0)
          {
            *((_DWORD *)a5 + 12) &= ~0x40u;
            *(_DWORD *)(a9 + 84) |= 0x800u;
          }
        }

        if ((v55 & 8) == 0)
        {
          if ((v55 & 0x200) != 0)
          {
            *(void *)(a9 + 72) = a5[5];
            *(_DWORD *)(a9 + 80) = *((_DWORD *)a5 + 12);
          }

          int v156 = *(_DWORD *)(a9 + 84);
          if ((v56 & 0x20) == 0 && (v156 & 0x800) != 0)
          {
            *(void *)(a9 + 56) = v188 - v189;
            if ((*((_BYTE *)a5 + 49) & 8) != 0) {
              *(void *)(a9 + 64) = v187 - v184;
            }
          }

LABEL_263:
          *(void *)(a9 + 16) = a5[4];
          if ((v56 & 0x20) == 0
            || (v55 & 0x80) != 0
            || (v55 & 0x20) != 0
            || (v55 & 0x100) != 0
            || (v194[0] = 0LL,
                LODWORD(v193) = 0,
                sub_100051390((unsigned __int16 *)a5 + 26, v62, 2, 0LL, v194, &v193))
            || (_DWORD)v193 != 8
            || !*(void *)v194[0])
          {
            if ((v55 & 0x2000) != 0 && (v56 & 0x40) != 0 && (v156 & 0xC00) == 0) {
              *(void *)(a9 + 16) = 0LL;
            }
          }

          else
          {
            *(void *)(a9 + 16) = *(void *)v194[0];
            *(_DWORD *)(a9 + 84) |= 0x100000u;
          }

          if ((v55 & 0x10) != 0)
          {
            int v165 = *((_DWORD *)a5 + 12);
            a5[3] = 0LL;
            *((_DWORD *)a5 + 12) = v165 & 0xFFFFFF6F | 0x10;
            v194[0] = 0LL;
            sub_100051434((unsigned __int16 *)a5 + 26, v62, 2, v194, 8);
            *((_DWORD *)a5 + 12) &= 0xFFFFFBDF;
            *(void *)(a9 + 16) = v57;
            if ((v55 & 0x80) != 0)
            {
LABEL_277:
              v194[0] = 0LL;
              sub_100051434((unsigned __int16 *)a5 + 26, v62, 2, v194, 8);
              *((_DWORD *)a5 + 12) &= ~0x20u;
              if ((v55 & 0x10000) != 0)
              {
LABEL_278:
                unsigned int v164 = *((_DWORD *)a5 + 12) | 0x100;
                goto LABEL_287;
              }

LABEL_281:
              if ((v55 & 0x20000) == 0)
              {
                if ((v55 & 0x200000) != 0) {
                  goto LABEL_288;
                }
                goto LABEL_283;
              }

              unsigned int v164 = a5[6] & 0xFFFFFEFF;
LABEL_287:
              *((_DWORD *)a5 + 12) = v164;
              if ((v55 & 0x200000) != 0)
              {
LABEL_288:
                int v167 = *((_DWORD *)a5 + 12);
                a5[3] = 0LL;
                *((_DWORD *)a5 + 12) = v167 & 0xFFFFFE4F | 0x100;
                if ((v55 & 0x40000) != 0) {
                  goto LABEL_289;
                }
                goto LABEL_284;
              }

LABEL_283:
              if ((v55 & 0x40000) != 0)
              {
LABEL_289:
                unsigned int v166 = *((_DWORD *)a5 + 12) | 0x200;
                goto LABEL_290;
              }

        ++v141;
        if (!--__nel)
        {
          uint64_t v13 = v190;
          if (v142)
          {
            sub_10002B884( *(void *)&v238[24].__opaque[8 * v221 + 24],  0,  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36LL)))) & v143,  v142);
            uint64_t v12 = v203;
            if (v218)
            {
              uint64_t v27 = v218(a5, v143, v142);
              if (BYTE14(v245))
              {
                ++*((void *)&v244 + 1);
                *(void *)&uint64_t v245 = v245 + v142;
              }
            }

            else
            {
              uint64_t v27 = 0LL;
            }

            uint64_t v26 = (char *)v205;
            int v54 = v182;
            int v158 = v212;
            if (v212) {
              uint64_t v159 = 1;
            }
            else {
              uint64_t v159 = (_DWORD)v27 == 0;
            }
            if (!v159) {
              int v158 = v27;
            }
            uint64_t v212 = v158;
          }

          else
          {
            uint64_t v12 = v203;
            uint64_t v26 = (char *)v205;
            uint64_t v27 = v138;
            int v54 = v182;
          }

LABEL_284:
              if ((v55 & 0x80000) == 0) {
                goto LABEL_291;
              }
              unsigned int v166 = a5[6] & 0xFFFFFDFF;
LABEL_290:
              *((_DWORD *)a5 + 12) = v166;
LABEL_291:
              if ((v55 & 0x100000) != 0 && (v56 & 0x10) == 0)
              {
                if (sub_100013538(*(void *)(*(void *)a9 + 392LL))) {
                  sub_100013D94( "%s:%d: %s fixing DIR_STATS_IS_SHADOW flag for dir-stats %llu\n",  "exp_dir_stats_refcnt_merge",  3242,  (const char *)(*(void *)a9 + 3992LL),  *a1 & 0xFFFFFFFFFFFFFFFLL);
                }
                *((_DWORD *)a5 + 12) |= 0x110u;
                goto LABEL_297;
              }

              if (v56 & 0x10 | v55 & 0x100000)
              {
LABEL_297:
                uint64_t result = 0LL;
                int v81 = *(_DWORD *)(a9 + 84) | 0x20;
                goto LABEL_298;
              }

              if ((v56 & 0x20) != 0)
              {
                uint64_t result = 0LL;
                int v81 = *(_DWORD *)(a9 + 84) | 0x40;
                goto LABEL_298;
              }

              return 0LL;
            }
          }

          else if ((v55 & 0x80) != 0)
          {
            goto LABEL_277;
          }

          if ((v55 & 0x10000) != 0) {
            goto LABEL_278;
          }
          goto LABEL_281;
        }

        *(void *)(a9 + 24) = *a5;
        *(void *)(a9 + 32) = a5[1];
        *(void *)(a9 + 40) = a5[2];
        int v157 = *((_DWORD *)a5 + 12);
        if ((v157 & 4) != 0)
        {
          v194[0] = 0LL;
          LODWORD(v193) = 0;
          int v158 = sub_100051390((unsigned __int16 *)a5 + 26, v62, 1, 0LL, v194, &v193);
          uint64_t v159 = 0LL;
          if (!v158 && (_DWORD)v193 == 8) {
            uint64_t v159 = *(void *)v194[0];
          }
          *(void *)(a9 + 48) = v159;
          int v157 = *((_DWORD *)a5 + 12);
          if ((v157 & 8) == 0)
          {
LABEL_248:
            if ((v157 & 0x800) == 0)
            {
LABEL_262:
              *(void *)(a9 + 72) = a5[5];
              *(_DWORD *)(a9 + 80) = *((_DWORD *)a5 + 12);
              int v156 = *(_DWORD *)(a9 + 84);
              goto LABEL_263;
            }

LABEL_258:
            v194[0] = 0LL;
            LODWORD(v193) = 0;
            int v162 = sub_100051390((unsigned __int16 *)a5 + 26, v62, 4, 0LL, v194, &v193);
            uint64_t v163 = 0LL;
            if (!v162 && (_DWORD)v193 == 8) {
              uint64_t v163 = *(void *)v194[0];
            }
            *(void *)(a9 + 64) = v163;
            goto LABEL_262;
          }
        }

        else if ((v157 & 8) == 0)
        {
          goto LABEL_248;
        }

        v194[0] = 0LL;
        LODWORD(v193) = 0;
        int v160 = sub_100051390((unsigned __int16 *)a5 + 26, v62, 3, 0LL, v194, &v193);
        uint64_t v161 = 0LL;
        if (!v160 && (_DWORD)v193 == 8) {
          uint64_t v161 = *(void *)v194[0];
        }
        *(void *)(a9 + 56) = v161;
        if ((a5[6] & 0x800) == 0) {
          goto LABEL_262;
        }
        goto LABEL_258;
      }

      *a5 |= (unint64_t)*((unsigned __int8 *)a7 + 7) << 56;
      uint64_t v72 = (unsigned __int16 *)(a5 + 1);
      unint64_t v73 = a6 - 8LL;
      unint64_t v74 = a8 - 8LL;
      uint64_t v75 = (unsigned __int16 *)(a7 + 2);
      v194[0] = 0LL;
      LODWORD(v191) = 0;
      if ((_DWORD)v191 != 8) {
        goto LABEL_162;
      }
      uint64_t v76 = *(uint64_t **)v194[0];
      uint64_t v193 = v76;
      if (!v76) {
        goto LABEL_162;
      }
      v194[0] = 0LL;
      LODWORD(v191) = 0;
      if (sub_100051390(v72, a6 - 8LL, 2, 0LL, v194, &v191) || (_DWORD)v191 != 8 || !*(void *)v194[0])
      {
        int v77 = 22;
LABEL_161:
        BOOL v190 = sub_100010058(*(void *)(*(void *)a9 + 392LL));
        strerror(v77);
        sub_100013DDC( v190,  "%s:%d: %s clone mapping <%llu, %llu>: failed to update dir-stats key: %s (%d)\n",  v111,  v112,  v113,  v114,  v115,  v116,  (char)"jobj_refcnt_merge");
        goto LABEL_162;
      }

      if (*(uint64_t **)v194[0] != v76)
      {
        int v77 = sub_100051434(v72, a6 - 8LL, 2, &v193, 8);
        if (v77) {
          goto LABEL_161;
        }
      }

LABEL_162:
      v194[0] = 0LL;
      LODWORD(v191) = 0;
      if ((_DWORD)v191 != 8) {
        return 0LL;
      }
      int v117 = *(uint64_t **)v194[0];
      uint64_t v193 = v117;
      if (!v117) {
        return 0LL;
      }
      v194[0] = 0LL;
      LODWORD(v191) = 0;
      if (sub_100051390(v72, v73, 1, 0LL, v194, &v191) || (_DWORD)v191 != 8 || !*(void *)v194[0])
      {
        int v118 = 22;
        goto LABEL_172;
      }

      uint64_t result = sub_100051434(v72, v73, 1, &v193, 8);
      int v118 = result;
      if ((_DWORD)result)
      {
LABEL_172:
        BOOL v119 = sub_100010058(*(void *)(*(void *)a9 + 392LL));
        strerror(v118);
        sub_100013DDC( v119,  "%s:%d: %s clone mapping <%llu, %llu>: failed to update attribution tag: %s (%d)\n",  v120,  v121,  v122,  v123,  v124,  v125,  (char)"jobj_refcnt_merge");
        return 0LL;
      }

      return result;
    default:
      sub_100013D94("%s:%d: don't know how to merge refcounts on objects of type %d\n");
      return 22LL;
  }

uint64_t sub_100017F94(uint64_t a1, unsigned int a2, int a3)
{
  if (a2 < 0x10)
  {
    unsigned __int8 v4 = 3;
    switch(a2)
    {
      case 1u:
      case 0xBu:
        return v4;
      case 2u:
        return 2;
      case 6u:
      case 7u:
        goto LABEL_5;
      case 8u:
        if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 0x20) == 0)
        {
LABEL_5:
          if (a3 == 100) {
            return 1;
          }
          if (a3 == 101)
          {
            if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 1) == 0) {
              panic("Requested forced secondary_fs_root but the tree is missing\n");
            }
          }

          else
          {
            if (!sub_10002F44C(a1)) {
              return a3;
            }
            if (a3 != 1) {
              panic("type = %u, req_tree != fs_root\n", a2);
            }
          }

          return 8;
        }

        if (a3 != 1) {
          panic("sealed, fext, req_tree != fs_root");
        }
        unsigned __int8 v4 = 5;
        break;
      default:
        return a3;
    }
  }

  else if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) != 0)
  {
    if ((a2 & 0xFC) == 0x10)
    {
      if (sub_10002F44C(a1)) {
        return 8;
      }
      else {
        return 1;
      }
    }

    else
    {
      sub_100013D4C( "%s:%d: %s Warning: attempting to place unknown expanded type %hhu into fsroot.\n",  "match_jobj_expanded_type_to_tree_type",  4214,  (const char *)(a1 + 3992),  a2);
      return 1;
    }
  }

  else
  {
    sub_100013D94( "%s:%d: %s expanded obj type %hhu found on unsupported volume\n",  "match_jobj_expanded_type_to_tree_type",  4193,  (const char *)(a1 + 3992),  a2);
    return 0;
  }

  return v4;
}

uint64_t sub_10001811C(uint64_t a1, int a2, unsigned __int8 *a3, uint64_t a4)
{
  int v7 = sub_100017F94(a1, *a3, a2);
  if (v7 != 5)
  {
    int v10 = v7;
    uint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v15 = 0LL;
    uint64_t v9 = sub_10001656C(a1, v7, a4, *(void *)(a1 + 432), &v15);
    if ((_DWORD)v9) {
      return v9;
    }
    int v11 = a3[1];
    if ((v11 - 1) >= 2)
    {
      if (v11 != 4)
      {
        sub_100013D94("%s:%d: %s X %d\n", "insert_jobj", 4319, (const char *)(a1 + 3992), v11);
        uint64_t v9 = 22LL;
LABEL_14:
        sub_100038824(v15);
        return v9;
      }

      int v12 = 3;
    }

    else
    {
      int v12 = 1;
    }

    uint64_t v9 = sub_1000182BC(a1, (uint64_t)a3, v10, &v14, "addition");
    if (!(_DWORD)v9)
    {
      uint64_t v9 = sub_1000159FC(a1, v15, a3, a4, v12);
      if (!(_DWORD)v9)
      {
        sub_10001835C(a1, v10, v15, (uint64_t)a3, a4, v12);
        uint64_t v9 = 0LL;
        if (*a3 == 3) {
          *((void *)a3 + 14) &= 0xFFFFFFFFFBFBFFFFLL;
        }
      }
    }

    goto LABEL_14;
  }

  uint64_t v8 = sub_100004F3C(a1, a4, (uint64_t)a3);
  uint64_t v9 = v8;
  if ((_DWORD)v8) {
    sub_100013D94( "%s:%d: %s failed to insert fext in fext_tree: %d\n",  "insert_jobj",  4281,  (const char *)(a1 + 3992),  v8);
  }
  return v9;
}

uint64_t sub_1000182BC(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, const char *a5)
{
  if (*(_BYTE *)a2 == 3) {
    uint64_t v5 = *(void *)(a2 + 16);
  }
  else {
    uint64_t v5 = 0LL;
  }
  *a4 = v5;
  if ((~*(void *)(a2 + 8) & 0xFFFFFFFFFFF0000LL) != 0 && (v5 & 0xFFFFFFFFFFF0000LL) != 0xFFFFFFFFFFF0000LL) {
    return 0LL;
  }
  uint64_t v7 = *(unsigned int *)(a1 + 1100);
  if ((_DWORD)v7) {
    return 0LL;
  }
  if (a3 == 1 && *(void *)(a1 + 3560))
  {
    sub_100013D94( "%s:%d: %s Preventing %s of objects to synthetic folder (id %lld, parent %lld)\n",  "prevent_synthetic_object_operation",  4159,  (const char *)(a1 + 3992),  a5,  *(void *)(a2 + 8),  v5);
    return 45LL;
  }

  return v7;
}

void sub_10001835C(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*(void *)(a4 + 8) == 2LL && !*(_DWORD *)(a1 + 1100) && a2 == 1)
  {
    if (*(void *)(a1 + 3560))
    {
      uint64_t v13 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      if (!sub_10001656C(a1, 4, a5, *(void *)(a1 + 432), &v13))
      {
        if (v13 != a3)
        {
          int v11 = sub_1000159FC(a1, v13, (unsigned __int8 *)a4, a5, a6);
          if (v11)
          {
            int v12 = v11;
            if (sub_100013538(*(void *)(a1 + 392))) {
              sub_100013D94( "%s:%d: %s Shadow create_or_modify_jobj(jobj %p id %lld xid %lld op %d) failed with error %d\n",  "duplicate_jobj_op_to_shadow_fs_root",  4179,  (const char *)(a1 + 3992),  (const void *)a4,  *(void *)(a4 + 8),  a5,  a6,  v12);
            }
          }
        }

        sub_100038824(v13);
      }
    }
  }

uint64_t sub_100018458(uint64_t a1, int a2, unsigned __int8 *a3, uint64_t a4)
{
  int v7 = sub_100017F94(a1, *a3, a2);
  if (v7 == 5)
  {
    uint64_t v8 = sub_100004FB4(a1, a4, *((void *)a3 + 1), *((void *)a3 + 2));
    uint64_t v9 = v8;
    if ((_DWORD)v8) {
      sub_100013D94("%s:%d: %s fext_tree_remove returned %d\n", "remove_jobj", 4450, (const char *)(a1 + 3992), v8);
    }
  }

  else
  {
    int v10 = v7;
    uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v13 = 0LL;
    uint64_t v9 = sub_10001656C(a1, v7, a4, *(void *)(a1 + 432), &v13);
    if (!(_DWORD)v9)
    {
      uint64_t v9 = sub_1000182BC(a1, (uint64_t)a3, v10, &v12, "removal");
      if (!(_DWORD)v9)
      {
        uint64_t v9 = sub_1000159FC(a1, v13, a3, a4, 4);
        if (!(_DWORD)v9) {
          sub_10001835C(a1, v10, v13, (uint64_t)a3, a4, 4);
        }
      }

      sub_100038824(v13);
    }
  }

  return v9;
}

unsigned __int16 *sub_100018580( uint64_t a1, uint64_t a2, unint64_t a3, unsigned __int16 *a4, unint64_t a5)
{
  uint64_t v12 = *(void *)a2 >> 60;
  LODWORD(v13) = 40;
  switch((int)v12)
  {
    case 1:
      if (!a4) {
        return 0LL;
      }
      uint64_t v14 = a4[24];
      uint64_t v15 = 80LL;
      goto LABEL_32;
    case 2:
      goto LABEL_36;
    case 3:
      LODWORD(v13) = 648;
      goto LABEL_36;
    case 4:
      if (!a4) {
        return 0LL;
      }
      uint64_t v14 = *(unsigned __int16 *)(a2 + 8) + 24LL;
      uint64_t v15 = a4[1];
      goto LABEL_32;
    case 5:
      if (!a4) {
        return 0LL;
      }
      uint64_t v14 = a4[4];
      goto LABEL_18;
    case 6:
    case 12:
      LODWORD(v13) = 24;
      goto LABEL_36;
    case 7:
      if (!a4) {
        return 0LL;
      }
      if (a4[2] == 6) {
        uint64_t v14 = HIBYTE(a4[11]) + a4[11];
      }
      else {
        uint64_t v14 = a4[11];
      }
LABEL_18:
      uint64_t v15 = 40LL;
      goto LABEL_32;
    case 8:
      LODWORD(v13) = 56;
      goto LABEL_36;
    case 9:
      if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 9) != 0)
      {
        LODWORD(v13) = (*(_DWORD *)(a2 + 8) & 0x3FF) + 72;
        goto LABEL_36;
      }

      uint64_t v14 = *(unsigned __int16 *)(a2 + 8);
      uint64_t v15 = 72LL;
LABEL_32:
      unint64_t v25 = v14 + v15;
      LODWORD(v13) = (unsigned __int16)v25;
      if (v25 >> 16) {
        BOOL v26 = 1;
      }
      else {
        BOOL v26 = (unsigned __int16)v25 == 0;
      }
      if (!v26) {
        goto LABEL_36;
      }
      return 0LL;
    case 10:
      LODWORD(v13) = 96;
      goto LABEL_36;
    case 11:
      uint64_t v14 = *(unsigned __int16 *)(a2 + 8);
      uint64_t v15 = 32LL;
      goto LABEL_32;
    case 13:
      if (!a4) {
        return 0LL;
      }
      int v16 = *(unsigned __int8 *)(a2 + 15);
      if (v16 == 2)
      {
        LODWORD(v13) = 80;
      }

      else
      {
        if (v16 != 1) {
          return 0LL;
        }
        LODWORD(v13) = *((unsigned __int8 *)a4 + 2) + 32;
      }

      goto LABEL_36;
    case 14:
      int v17 = *(_DWORD *)(a2 + 8);
      if ((v17 - 16) >= 4u)
      {
        BOOL v18 = sub_100010058(*(void *)(a1 + 392));
        sub_100013DDC( v18,  "%s:%d: %s *** unknown expanded obj type %hhu\n",  v19,  v20,  v21,  v22,  v23,  v24,  (char)"jobj_size_for_large_key_val");
        return 0LL;
      }

      unint64_t v13 = (0x48006000200050uLL >> (16 * (v17 - 16))) & 0x78;
LABEL_36:
      if (v12 == 14)
      {
        LODWORD(v27) = *(unsigned __int8 *)(a2 + 8);
        if (v27 <= 0xF)
        {
          sub_100013D94("%s:%d: unknown expanded type (%hhu) on record (%u)\n");
          return 0LL;
        }
      }

      else
      {
        uint64_t v27 = *(void *)a2 >> 60;
      }

      switch((int)v27)
      {
        case 1:
          int v10 = (unsigned __int16 *)sub_100013EEC(1uLL, 0x50uLL);
          if (!v10) {
            return v10;
          }
          uint64_t v30 = sub_100013EEC(1uLL, v13 - 80LL);
          *((void *)v10 + 9) = v30;
          if (v30) {
            goto LABEL_64;
          }
          uint64_t v31 = v10;
          uint64_t v32 = 80LL;
          goto LABEL_54;
        case 2:
          size_t v29 = 40LL;
          goto LABEL_62;
        case 3:
          uint64_t v28 = (unsigned __int16 *)sub_100013E98(2u);
          goto LABEL_63;
        case 4:
        case 5:
        case 7:
        case 11:
          goto LABEL_42;
        case 6:
        case 12:
          size_t v29 = 24LL;
          goto LABEL_62;
        case 8:
          size_t v29 = 56LL;
          goto LABEL_62;
        case 9:
          int v10 = (unsigned __int16 *)sub_100013EEC(1uLL, 0x48uLL);
          if (!v10) {
            return v10;
          }
          unint64_t v33 = sub_100014044(v13 - 72LL);
          *((void *)v10 + 8) = v33;
          if (v33) {
            goto LABEL_64;
          }
          uint64_t v31 = v10;
          uint64_t v32 = 72LL;
LABEL_54:
          sub_100014004(v31, v32);
          return 0LL;
        case 10:
        case 18:
          size_t v29 = 96LL;
          goto LABEL_62;
        case 13:
          uint64_t v34 = HIBYTE(*(void *)(a2 + 8));
          if ((_DWORD)v34 == 2) {
            goto LABEL_58;
          }
          if ((_DWORD)v34 != 1)
          {
            sub_100013D94("%s:%d: *** Unknown file info type %llu\n");
            return 0LL;
          }

LABEL_42:
          uint64_t v28 = (unsigned __int16 *)sub_100014044(v13);
LABEL_63:
          int v10 = v28;
          if (!v28) {
            return v10;
          }
LABEL_64:
          unint64_t v35 = *(void *)a2;
          uint64_t v36 = *(void *)a2 & 0xFFFFFFFFFFFFFFFLL;
          *((void *)v10 + 1) = v36;
          v35 >>= 60;
          *(_BYTE *)int v10 = v35;
          *((_BYTE *)v10 + 1) = 1;
          v10[1] = v13;
          switch((int)v35)
          {
            case 1:
              *((_OWORD *)v10 + 1) = *(_OWORD *)a4;
              *((_OWORD *)v10 + 2) = *((_OWORD *)a4 + 1);
              *((void *)v10 + 6) = *((void *)a4 + 4);
              *((void *)v10 + 7) = *((void *)a4 + 5);
              size_t v37 = a4[24];
              v10[32] = v37;
              uint64_t v38 = (char *)*((void *)v10 + 9);
              uint64_t v39 = (const char *)(a4 + 25);
              goto LABEL_72;
            case 2:
              uint64_t v40 = *((void *)a4 + 1);
              uint64_t v41 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
              *((_BYTE *)v10 + 1) = *(void *)a4 >> 60;
              *((_DWORD *)v10 + 8) = *((_DWORD *)a4 + 4);
              *((void *)v10 + 2) = v41;
              *((void *)v10 + 3) = v40;
              return v10;
            case 3:
              *((void *)v10 + 2) = *(void *)a4;
              *((void *)v10 + 3) = *((void *)a4 + 1);
              *((void *)v10 + 4) = *((void *)a4 + 2);
              *((void *)v10 + 5) = *((void *)a4 + 3);
              *((void *)v10 + 6) = *((void *)a4 + 4);
              *((void *)v10 + 7) = *((void *)a4 + 5);
              *((_DWORD *)v10 + 18) = *((_DWORD *)a4 + 14);
              *((void *)v10 + 8) = *((void *)a4 + 6);
              *((_DWORD *)v10 + 19) = *((_DWORD *)a4 + 15);
              *((_DWORD *)v10 + 20) = *((_DWORD *)a4 + 16);
              *((_DWORD *)v10 + 21) = *((_DWORD *)a4 + 17);
              *((_DWORD *)v10 + 22) = *((_DWORD *)a4 + 18);
              *((_DWORD *)v10 + 23) = *((_DWORD *)a4 + 19);
              v10[48] = a4[40];
              v10[49] = a4[41];
              *((void *)v10 + 13) = *(void *)(a4 + 42);
              if (a5 < 0x5D) {
                return v10;
              }
              if (sub_100051244(v10 + 204, a4 + 46, a5 - 92))
              {
                sub_100013CBC("%s:%d: failed to init extended fields on inode %lld from blob (xfret %d).\n");
                return v10;
              }

              uint64_t v61 = v10[204];
              if (!v10[204]) {
                return v10;
              }
              int v62 = 0;
              unsigned int v63 = (_WORD *)(*((void *)v10 + 52) + 2LL);
              break;
            case 4:
              size_t v42 = *(unsigned __int16 *)(a2 + 8);
              v10[10] = v42;
              strlcpy((char *)v10 + 24, (const char *)(a2 + 10), v42);
              *((_DWORD *)v10 + 4) = *a4;
              size_t v43 = a4[1];
              v10[11] = v43;
              uint64_t v44 = (char *)v10 + v10[10] + 24;
              uint64_t v45 = a4 + 2;
              goto LABEL_87;
            case 5:
              uint64_t v46 = *(void *)a4;
              *((void *)v10 + 2) = *(void *)(a2 + 8);
              *((void *)v10 + 3) = v46;
              size_t v37 = a4[4];
              v10[16] = v37;
              uint64_t v38 = (char *)(v10 + 17);
              uint64_t v39 = (const char *)(a4 + 5);
LABEL_72:
              strlcpy(v38, v39, v37);
              return v10;
            case 6:
              *((_DWORD *)v10 + 4) = *(_DWORD *)a4;
              return v10;
            case 7:
              *((_DWORD *)v10 + 4) = *(_DWORD *)a4;
              LODWORD(v47) = a4[11];
              int v49 = a4[2];
              uint64_t v48 = a4 + 2;
              uint64_t v44 = (char *)(v10 + 10);
              if (v49 == 6) {
                uint64_t v47 = (v47 >> 8) + v47;
              }
              else {
                uint64_t v47 = v47;
              }
              size_t v43 = v47 + 20;
              uint64_t v45 = v48;
              goto LABEL_87;
            case 8:
              *((void *)v10 + 2) = *(void *)(a2 + 8);
              uint64_t v50 = *(void *)a4;
              *((void *)v10 + 5) = *(void *)a4 & 0xFFFFFFFFFFFFFFLL;
              *(_OWORD *)(v10 + 12) = *(_OWORD *)(a4 + 4);
              *((_BYTE *)v10 + 48) = HIBYTE(v50);
              return v10;
            case 9:
              if ((*(_BYTE *)(*(void *)(a1 + 376) + 56LL) & 9) != 0)
              {
                unsigned int v51 = *(_DWORD *)(a2 + 8);
                *((_DWORD *)v10 + 14) = v51 >> 10;
                v10[31] = v51 & 0x3FF;
                uint64_t v52 = (char *)*((void *)v10 + 8);
                uint64_t v53 = (const char *)(a2 + 12);
                size_t v54 = v51 & 0x3FF;
              }

              else
              {
                *((_DWORD *)v10 + 14) = 0;
                size_t v54 = *(unsigned __int16 *)(a2 + 8);
                v10[31] = v54;
                uint64_t v52 = (char *)*((void *)v10 + 8);
                uint64_t v53 = (const char *)(a2 + 10);
              }

              strlcpy(v52, v53, v54);
              *((void *)v10 + 2) = *(void *)a4;
              *((void *)v10 + 3) = *((void *)a4 + 1);
              v10[30] = a4[8];
              unint64_t v59 = v10 + 16;
              if (a5 < 0x13)
              {
                sub_1000511D8((uint64_t)v59, 0LL);
              }

              else if (sub_100051244(v59, a4 + 9, a5 - 18))
              {
                sub_100013CBC("%s:%d: failed to init extended fields on drec %lld from blob.\n");
              }

              return v10;
            case 10:
              *(_OWORD *)(v10 + 12) = *(_OWORD *)a4;
              *((int8x16_t *)v10 + 3) = vextq_s8(*((int8x16_t *)a4 + 1), *((int8x16_t *)a4 + 1), 8uLL);
              return v10;
            case 11:
              size_t v55 = *(unsigned __int16 *)(a2 + 8);
              v10[12] = v55;
              strlcpy((char *)v10 + 26, (const char *)(a2 + 10), v55);
              goto LABEL_83;
            case 12:
LABEL_83:
              *((void *)v10 + 2) = *(void *)a4;
              return v10;
            case 13:
              unint64_t v56 = *(void *)(a2 + 8);
              *((_BYTE *)v10 + 16) = HIBYTE(v56);
              *((void *)&v57 + 1) = *(void *)(a2 + 8);
              *(void *)&__int128 v57 = v56;
              *((void *)v10 + 2) = v57 >> 56;
              if (HIBYTE(v56) == 2)
              {
                *((void *)v10 + 3) = *(void *)a4;
                *((void *)v10 + 4) = *((void *)a4 + 1);
                *((void *)v10 + 5) = *((void *)a4 + 2);
                v10[24] = a4[12];
                if (a5 < 0x1B)
                {
                  sub_100013D94( "%s:%d: %s s_hash <%llu> finfo attribution tag value <%zu> is less than sizeof(j_file_attribution_tag_val_t) <%lu\n");
                  return v10;
                }

                int v60 = sub_100051244(v10 + 28, a4 + 13, a5 - 26);
                if (v60)
                {
                  strerror(v60);
                  sub_100013CBC( "%s:%d: failed to init extended fields on attribution tag record with objid <%lld> from blob due to error <%d> %s\n");
                  return v10;
                }

                uint64_t v65 = v10[28];
                if (v10[28])
                {
                  int v66 = 0;
                  for (uint64_t i = (unsigned __int16 *)(*((void *)v10 + 8) + 2LL); ; i += 2)
                  {
                    int v68 = *i;
                    if (*((_BYTE *)i - 2) == 1) {
                      break;
                    }
                    v66 += (v68 + 7) & 0x1FFF8;
                    if (!--v65) {
                      return v10;
                    }
                  }

                  if ((__int16)*i <= 0) {
                    sub_100013D94( "%s:%d: %s size (%d) of FILE_INFO_TAG_EXT_TYPE_SIGNING_ID in attribution tag record with s_hash <%llu> <= 0 \n");
                  }
                  else {
                    *(_BYTE *)(*((void *)v10 + 9) + v66 + v68 - 1) = 0;
                  }
                }
              }

              else if (HIBYTE(v56) == 1)
              {
                v10[12] = *a4;
                size_t v43 = *((unsigned __int8 *)a4 + 2);
                *((_BYTE *)v10 + 26) = v43;
                uint64_t v44 = (char *)v10 + 27;
                uint64_t v45 = (unsigned __int16 *)((char *)a4 + 3);
LABEL_87:
                memcpy(v44, v45, v43);
              }

              return v10;
            case 14:
              if (a3 < 0xC) {
                goto LABEL_91;
              }
              uint64_t v36 = *((void *)v10 + 1);
LABEL_91:
              BOOL v58 = sub_100013D94( "%s:%d: %s cannot translate key-val (%llu) into valid jobj\n",  "key_val_to_jobj",  4923,  (const char *)(a1 + 3992),  v36);
              sub_100014300((uint64_t)v58, (unsigned __int8 *)v10);
              return 0LL;
            default:
              return v10;
          }

          break;
        case 16:
LABEL_58:
          size_t v29 = 80LL;
          goto LABEL_62;
        case 17:
          size_t v29 = 32LL;
          goto LABEL_62;
        case 19:
          size_t v29 = 72LL;
LABEL_62:
          uint64_t v28 = (unsigned __int16 *)sub_100013EEC(1uLL, v29);
          goto LABEL_63;
        default:
          sub_100013D94("%s:%d: *** Can't allocate unknown obj type %d\n");
          return 0LL;
      }

      break;
    default:
      sub_100013D94("%s:%d: *** unknown obj type %d\n");
      return 0LL;
  }

  while (1)
  {
    int v64 = (unsigned __int16)*v63;
    if (*((_BYTE *)v63 - 2) == 4)
    {
      if (*v63) {
        break;
      }
    }

    v63 += 2;
    v62 += (v64 + 7) & 0x1FFF8;
    if (!--v61) {
      return v10;
    }
  }

  *(_BYTE *)(*((void *)v10 + 53) + v62 + v64 - 1) = 0;
  return v10;
}

    unint64_t v264 = v49;
    size_t v55 = v42;
    unint64_t v56 = a5;
    __int128 v57 = (unsigned __int16)v43;
    BOOL v58 = a4[7];
    unint64_t v59 = *(unsigned __int16 *)(v58 + 32);
    uint64_t v259 = v59;
    if ((v59 & 2) == 0 || v256 + (unsigned __int16)v43 != (_DWORD)v56)
    {
      uint64_t v79 = v276;
      if ((v59 & 4) == 0) {
        goto LABEL_57;
      }
      goto LABEL_73;
    }

    int v60 = v56;
    uint64_t v251 = (unsigned __int16)v43;
    uint64_t v257 = v58;
    uint64_t v61 = v264;
    size_t v42 = v55;
    int v62 = v19;
    unsigned int v63 = v262;
    int v64 = v52 + v262;
    uint64_t v65 = sub_10001E4C4(v278, (__int16)(v52 + v262));
    int v66 = v268;
    uint64_t v67 = (v65 << v271) - v269;
    int v68 = v250 + (unsigned __int16)v277 + (__int16)(((_WORD)v65 << v271) - v269);
    uint64_t v69 = HIDWORD(v276);
    if (v69 == 1)
    {
      uint64_t v70 = v63 + (__int16)v52 + *(_DWORD *)(*(void *)(v278 + 56) + 36LL);
      uint64_t v71 = v70 >= sub_10001E4C4(v278, 0);
      uint64_t v19 = v267;
      if (v71) {
        goto LABEL_49;
      }
    }

    else
    {
      uint64_t v19 = v62;
      if (v68 > (unsigned __int16)v268)
      {
LABEL_49:
        a5 = v60;
        if (!v274)
        {
          a4 = v275;
          uint64_t v72 = sub_1000398C0((uint64_t)v275);
          unint64_t v73 = v278;
          sub_10003D514(v278, 2);
          sub_100038824(v73);
          unsigned __int16 v285 = 0LL;
          unint64_t v74 = v279[1];
          uint64_t v40 = v265;
          if (!v74) {
            unint64_t v74 = *(void *)(*v279 + 392LL);
          }
          uint64_t v75 = sub_1000398B8((uint64_t)a4);
          uint64_t v76 = sub_100027B58(v74, v72 & 0xFFFFFC00, v75, v286, v19, &v285);
          uint64_t v45 = v273;
          if ((_DWORD)v76) {
            return v76;
          }
          int v77 = (unint64_t *)(v279[49] + 32LL);
          do
            int v78 = __ldxr(v77);
          while (__stxr(v78 + 1, v77));
          goto LABEL_101;
        }

        if (v263) {
          LOWORD(v43) = v265 - 2;
        }
        if (v61 < 0)
        {
          LOWORD(v40) = v43 + 1;
          uint64_t v113 = 2840;
LABEL_137:
          uint64_t v114 = v257;
          goto LABEL_138;
        }

uint64_t sub_100018E54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5)
{
  unsigned int v5 = *(unsigned __int8 *)(a3 + 8);
  if (v5 > 0xF)
  {
    uint64_t v6 = a2;
    *(_BYTE *)a2 = v5;
    switch(v5)
    {
      case 0x10u:
        *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 12);
        *(void *)(a2 + 32) = *a4;
        *(void *)(a2 + 40) = a4[1];
        *(_DWORD *)(a2 + 48) = *((_DWORD *)a4 + 4);
        *(_DWORD *)(a2 + 52) = *((_DWORD *)a4 + 5);
        int v7 = (unsigned __int16 *)(a2 + 56);
        if (a5 < 0x19) {
          goto LABEL_15;
        }
        break;
      case 0x11u:
        uint64_t v8 = *a4;
        *(void *)(a2 + 16) = *(void *)(a3 + 12);
        *(void *)(a2 + 24) = v8;
        break;
      case 0x12u:
        *(void *)(a2 + 16) = a4[3];
        *(void *)(a2 + 24) = *a4;
        *(void *)(a2 + 32) = a4[1];
        *(void *)(a2 + 40) = a4[2];
        *(void *)(a2 + 56) = a4[4];
        *(void *)(a2 + 48) = a4[5];
        *(_DWORD *)(a2 + 92) = *((_DWORD *)a4 + 12);
        int v7 = (unsigned __int16 *)(a2 + 64);
        if (a5 < 0x35) {
          goto LABEL_15;
        }
        break;
      case 0x13u:
        *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 12);
        *(void *)(a2 + 32) = *a4 & 0xFFFFFFFFFFFFFFLL;
        *(_DWORD *)(a2 + 40) = *((unsigned __int8 *)a4 + 7);
        int v7 = (unsigned __int16 *)(a2 + 48);
        if (a5 < 9)
        {
LABEL_15:
          sub_1000511D8((uint64_t)v7, 0LL);
        }

        else if (sub_100051244(v7, (unsigned __int16 *)a4 + 4, a5 - 8))
        {
          sub_100013D94("%s:%d: %s failed to init extended fields on clone mapping <%llu/%llu> from blob\n");
        }

        break;
      default:
        return v6;
    }
  }

  else
  {
    sub_100013D94( "%s:%d: %s unknown expanded type (%hhu) on record (%u)\n",  "large_key_val_to_jobj",  4494,  (const char *)(a1 + 3992),  *(unsigned __int8 *)(a3 + 8),  *(void *)a3 >> 60);
    return 0LL;
  }

  return v6;
}

uint64_t sub_100019054(uint64_t a1, int a2, uint64_t *a3, unsigned __int8 *a4, unsigned __int16 **a5)
{
  return sub_100019060(a1, a2, a3, a4, *(void *)(a1 + 432), a5);
}

uint64_t sub_100019060( uint64_t a1, int a2, uint64_t *a3, unsigned __int8 *a4, unint64_t a5, unsigned __int16 **a6)
{
  int v11 = sub_100017F94(a1, *a4, a2);
  uint64_t v12 = sub_100013E98(3u);
  if (!v12) {
    return 12LL;
  }
  uint64_t v13 = (uint64_t)v12;
  unsigned int v18 = 832;
  unsigned int v19 = 3808;
  sub_10001449C(a1, a4, (uint64_t)v12, (int *)&v18);
  int v17 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = sub_10001656C(a1, v11, 0LL, a5, &v17);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
LABEL_6:
    sub_100013FB4((void *)v13, 3u);
    return v15;
  }

  uint64_t v15 = sub_100026464((uint64_t)v17, a5, (unint64_t *)v13, &v18, 0x340u, (void *)(v13 + 832), &v19, 0, 0, a3);
  sub_100038824(v17);
  if ((_DWORD)v15) {
    goto LABEL_6;
  }
  *a6 = sub_100018580(a1, v13, v18, (unsigned __int16 *)(v13 + 832), v19);
  sub_100013FB4((void *)v13, 3u);
  if (*a6) {
    return 0LL;
  }
  else {
    return sub_100005194(*(void *)(a1 + 392));
  }
}

uint64_t sub_1000191C0(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 96) = 0LL;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = a2;
  *(_DWORD *)(a1 + 92) = a2;
  unsigned int v5 = sub_100013EEC(a2, 0x10uLL);
  *(void *)a1 = v5;
  if (v5)
  {
    size_t v6 = (a2 + 63) >> 6;
    *(_DWORD *)(a1 + 88) = v6;
    int v7 = sub_100013EEC(v6, 8uLL);
    *(void *)(a1 + 72) = v7;
    if (v7)
    {
      uint64_t v8 = sub_100013EEC(*(unsigned int *)(a1 + 88), 8uLL);
      *(void *)(a1 + 80) = v8;
      if (v8)
      {
        sub_1000139BC((pthread_mutex_t *)(a1 + 8));
        return 0LL;
      }

      sub_100014004(*(void **)a1, 16 * v4);
      int v10 = *(void **)(a1 + 72);
      uint64_t v11 = 8LL * *(unsigned int *)(a1 + 88);
    }

    else
    {
      int v10 = *(void **)a1;
      uint64_t v11 = 16 * v4;
    }

    sub_100014004(v10, v11);
  }

  return 12LL;
}

uint64_t sub_10001928C(uint64_t a1)
{
  return j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 8));
}

uint64_t sub_1000192DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a2 >> 60;
  if (v2 == 14)
  {
    if (!a1 || (*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 2) != 0)
    {
      LODWORD(v2) = *(_DWORD *)(a2 + 8);
    }

    else
    {
      BOOL v3 = sub_100010058(*(void *)(a1 + 392));
      sub_100013DDC( v3,  "%s:%d: %s expanded record found on unsupported volume\n",  v4,  v5,  v6,  v7,  v8,  v9,  (char)"jobj_type_from_possibly_large_key");
      LOBYTE(v2) = 15;
    }
  }

  return v2;
}

uint64_t sub_10001935C( uint64_t a1, int a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, uint64_t (*a6)(__int128 *, uint64_t), uint64_t a7, _OWORD *a8, unsigned int a9)
{
  int v16 = sub_100017F94(a1, *a5, a2);
  if (v16 == 5)
  {
    uint64_t v17 = *((void *)a5 + 2);
    if (v17 == -1) {
      uint64_t v18 = 0LL;
    }
    else {
      uint64_t v18 = *((void *)a5 + 2);
    }
    else {
      unsigned int v20 = a9;
    }
    return sub_100005030(a1, a3, a4, *((void *)a5 + 1), v18, a8, v20, a6, a7);
  }

  int v22 = v16;
  uint64_t v23 = (unint64_t *)sub_100013E98(3u);
  if (!v23) {
    return 12LL;
  }
  uint64_t v24 = v23;
  int v41 = 832;
  uint64_t v39 = a6;
  if (!*((void *)a5 + 1) && !*a5)
  {
    if ((a9 & 0x10000) == 0 && a5[1]) {
      goto LABEL_16;
    }
LABEL_20:
    int v25 = 1;
    goto LABEL_21;
  }

  if ((a9 & 0x10000) != 0) {
    goto LABEL_20;
  }
LABEL_16:
  int v25 = 0;
LABEL_21:
  unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v42[2] = v27;
  __int128 v43 = v27;
  v42[0] = v27;
  v42[1] = v27;
  uint64_t v40 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  if ((a9 & 0x20000) != 0) {
    char v28 = v25;
  }
  else {
    char v28 = 1;
  }
  char v38 = v28;
  sub_10001449C(a1, a5, (uint64_t)v23, &v41);
  if (v22 == 1)
  {
    uint64_t v29 = *((void *)a5 + 1);
    if ((~v29 & 0xFFFFFFFFFFF0000LL) == 0 || v29 == 2) {
      int v22 = 4;
    }
    else {
      int v22 = 1;
    }
  }

  uint64_t v31 = sub_10001656C(a1, v22, a3, a4, &v40);
  if ((_DWORD)v31)
  {
    uint64_t v26 = v31;
    goto LABEL_37;
  }

  sub_100026D8C((uint64_t)v42, (uint64_t)v40, a4, (unsigned __int16)a9, v24, v41, 0x340u, v24 + 104, 0xEE0u, a8);
  uint64_t v26 = v32;
  if ((v32 & 0xFFFFFFFD) != 0) {
    goto LABEL_36;
  }
  if (sub_100026EFC((uint64_t)v42))
  {
LABEL_35:
    uint64_t v26 = 0LL;
    goto LABEL_36;
  }

  unsigned int v33 = v25 | ((a9 & 0x20000) >> 17);
  while (1)
  {
    if ((v33 & 1) != 0)
    {
      if ((v38 & 1) == 0)
      {
        if (*a5)
        {
          int v34 = *a5;
        }
      }
    }

    else if ((*v24 & 0xFFFFFFFFFFFFFFFLL) != *((void *)a5 + 1) {
           || *a5 && sub_1000192DC(a1, (uint64_t)v24) != *a5)
    }
    {
      goto LABEL_35;
    }

    unint64_t v35 = sub_100018580(a1, (uint64_t)v24, v43, (unsigned __int16 *)v24 + 416, DWORD1(v43));
    if (!v35) {
      break;
    }
    uint64_t v36 = (unsigned __int8 *)v35;
    uint64_t v26 = v39((__int128 *)v35, a7);
    sub_100014300(v26, v36);
    if ((_DWORD)v26) {
      goto LABEL_36;
    }
LABEL_53:
    uint64_t v37 = sub_100026F18((uint64_t)v42);
    if ((a9 & 0x40000) == 0)
    {
      uint64_t v26 = v37;
      if ((_DWORD)v37) {
        goto LABEL_36;
      }
    }
  }

  if ((a9 & 0x40000) != 0) {
    goto LABEL_53;
  }
  uint64_t v26 = 12LL;
LABEL_36:
  sub_100038824(v40);
LABEL_37:
  sub_100013FB4(v24, 3u);
  return v26;
}

uint64_t sub_100019618( uint64_t a1, int a2, uint64_t a3, unsigned __int8 *a4, size_t a5, uint64_t a6, uint64_t a7, _DWORD *a8, uint64_t *a9, int a10)
{
  v28[0] = a1;
  v28[1] = a6;
  unint64_t v14 = *(void *)a4;
  uint64_t v15 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  v28[2] = a7;
  v28[3] = v15;
  unint64_t v16 = v14 >> 60;
  if (v14 >> 60 == 14) {
    LODWORD(v16) = a4[8];
  }
  unint64_t v29 = 0xAAAAAAAAAA0000AALL;
  LOBYTE(v29) = v16;
  *(void *)__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
  if (a8) {
    *a8 = 0;
  }
  if (v15 || (_DWORD)v16)
  {
    if ((a10 & 0x20000) != 0) {
      BYTE2(v29) = 1;
    }
  }

  else
  {
    BYTE1(v29) = 1;
  }

  if ((~v14 & 0xFFFFFFFFFFF0000LL) == 0 || v15 == 2) {
    int v18 = 4;
  }
  else {
    int v18 = 1;
  }
  if (a2 == 1) {
    a2 = v18;
  }
  uint64_t result = sub_10001656C(a1, a2, a3, *(void *)(a1 + 432), (uint64_t **)v27);
  if (!(_DWORD)result)
  {
    if ((a10 & 0x800) != 0)
    {
      unsigned int v20 = (char *)sub_100013E98(3u);
      if (!v20) {
        return 12LL;
      }
    }

    else
    {
      unsigned int v20 = 0LL;
    }

    uint64_t v21 = *(void *)(a1 + 432);
    int v22 = a10 & 0xF1FF;
    int v23 = a10 & 0xE00;
    switch(v23)
    {
      case 2048:
        unsigned int v24 = sub_100026FA4( *(uint64_t *)v27,  v21,  v22,  a4,  a5,  a9,  (uint64_t (*)(void, void, void, void, uint64_t, __n128))sub_1000197DC,  (uint64_t)v28,  v20,  v20 + 832);
        break;
      case 1024:
        unsigned int v24 = sub_100027194( *(uint64_t *)v27,  v21,  v22,  (unint64_t *)a4,  a5,  a9,  (uint64_t (*)(void, uint64_t, void, void, uint64_t))sub_1000197DC,  (uint64_t)v28);
        break;
      case 512:
        unsigned int v24 = sub_1000275E8( *(uint64_t *)v27,  v21,  v22,  (unint64_t *)a4,  a5,  a9,  (uint64_t (*)(unint64_t, void, unint64_t, void, uint64_t))sub_1000197DC,  (uint64_t)v28);
        break;
      default:
        unsigned int v25 = 22;
        if ((a10 & 0x800) == 0) {
          goto LABEL_31;
        }
        goto LABEL_30;
    }

    unsigned int v25 = v24;
    if ((a10 & 0x800) == 0)
    {
LABEL_31:
      sub_100038824(*(uint64_t **)v27);
      if (v25 == 2 || v25 == 0x80000000) {
        uint64_t result = 0LL;
      }
      else {
        uint64_t result = v25;
      }
      if (a8) {
        *a8 = result == 0;
      }
      return result;
    }

LABEL_30:
    sub_100013FB4(v20, 3u);
    goto LABEL_31;
  }

  return result;
}

uint64_t sub_1000197DC(void *a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v8 = a2;
  uint64_t v9 = a4;
  uint64_t result = sub_100015280(*(void *)a5, (uint64_t)a1);
  if ((_DWORD)result) {
    return result;
  }
  if (*(_BYTE *)(a5 + 33))
  {
    if (!*(_BYTE *)(a5 + 34)) {
      return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, void))(a5 + 8))( a1,  v8,  a3,  v9,  *(void *)(a5 + 16));
    }
  }

  else if (!*(_BYTE *)(a5 + 34))
  {
    if ((*a1 & 0xFFFFFFFFFFFFFFFLL) == *(void *)(a5 + 24)
      && (!*(_BYTE *)(a5 + 32)
       || sub_1000192DC(*(void *)a5, (uint64_t)a1) == *(unsigned __int8 *)(a5 + 32)))
    {
      return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, void))(a5 + 8))( a1,  v8,  a3,  v9,  *(void *)(a5 + 16));
    }

    return 0x80000000LL;
  }

  if (!*(_BYTE *)(a5 + 32) || sub_1000192DC(*(void *)a5, (uint64_t)a1) == *(unsigned __int8 *)(a5 + 32)) {
    return (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, void))(a5 + 8))( a1,  v8,  a3,  v9,  *(void *)(a5 + 16));
  }
  return 0LL;
}

uint64_t sub_1000198D8(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4)
{
  if (a3 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a3;
  }
  unint64_t v5 = v4 - 2;
  if (v4 < 2)
  {
LABEL_11:
    if (a3 < a4) {
      LODWORD(v7) = -1;
    }
    else {
      LODWORD(v7) = 1;
    }
    if (a3 == a4) {
      return 0LL;
    }
    else {
      return v7;
    }
  }

  else
  {
    while (1)
    {
      int v6 = *a1;
      uint64_t v7 = v6 - *a2;
      if ((_DWORD)v7) {
        break;
      }
      ++a1;
      ++a2;
      if (v6) {
        BOOL v8 = v5 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      --v5;
      if (v8) {
        goto LABEL_11;
      }
    }
  }

  return v7;
}

void sub_100019944(uint64_t a1)
{
  int v1 = (char *)sub_100019998 + 4 * byte_10005B927[sub_10002F2C4(a1)];
  __asm { BR              X10 }

uint64_t sub_100019998()
{
  void *v1 = 0LL;
  uint64_t v2 = *(void *)(v0 + 496);
  if (!v2) {
    uint64_t v2 = v0;
  }
  if ((*(_BYTE *)(*(void *)(v2 + 376) + 264LL) & 9) == 0) {
    panic("assertion failed: %s", "!((err == 0) && (*crypto_id == 0) && fs_is_content_protected(apfs))");
  }
  return 0LL;
}

uint64_t sub_100019C64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    panic("assertion failed: %s", "xid");
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100019CEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 32) = 0LL;
  sub_100019944(a1);
  uint64_t v8 = v7;
  if (!(_DWORD)v7)
  {
    *(void *)(a4 + 16) = a5;
  }

  return v8;
}

uint64_t sub_100019D88(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __src[0] = v8;
  __src[1] = v8;
  uint64_t v22 = 0LL;
  if ((*(_WORD *)(a2 + 96) & 0xF000) != 0x8000)
  {
    uint64_t v11 = 0LL;
    int v12 = 0;
    int v13 = 0;
    int v14 = 22;
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  uint64_t v9 = *(void *)(a1 + 376);
  if ((*(_BYTE *)(v9 + 57) & 2) == 0 || (~*(_DWORD *)(a2 + 84) & 0x40000020) != 0)
  {
    uint64_t v11 = *(void *)(a2 + 8);
  }

  else
  {
    int v10 = (unint64_t *)(v9 + 176);
    do
      uint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  int v15 = sub_100019CEC(a1, a2, a3, (uint64_t)__src, v11);
  if (v15)
  {
    int v14 = v15;
    int v12 = 0;
    int v13 = 0;
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  int v16 = sub_100051620((unsigned __int16 *)(a2 + 408), 8, 32, __src, 0x28uLL);
  if (v16)
  {
    sub_100013D94( "%s:%d: %s *** failed to set dstream as an extended field of ino %lld (ret %d)\n",  "fs_create_dstream",  10933,  (const char *)(a1 + 3992),  *(void *)(a2 + 8),  v16);
    int v13 = 0;
    int v12 = 1;
    int v14 = 12;
    if (!a4) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

  int v21 = -1431655766;
  int v18 = sub_1000519B8((unsigned __int16 *)(a2 + 408), 8, 0LL, &v22, &v21);
  if (v18 || v21 != 40)
  {
    sub_100013D94( "%s:%d: %s *** failed to fetch the dstream pointer for %lld (ret %d)\n",  "fs_create_dstream",  10940,  (const char *)(a1 + 3992),  *(void *)(a2 + 8),  v18);
    uint64_t v22 = 0LL;
    int v12 = 1;
    int v14 = 2;
  }

  else
  {
    v20[1] = *(void *)(a2 + 24);
    v20[0] = 1573126LL;
    int v12 = 1;
    _OWORD v20[2] = 1LL;
    int v19 = sub_10001811C(a1, 1, (unsigned __int8 *)v20, a3);
    int v14 = v19;
    if (v19)
    {
      sub_100013D94( "%s:%d: %s failed to insert new dstream_id %llu (ret %d)",  "fs_create_dstream",  10957,  (const char *)(a1 + 3992),  *(void *)(a2 + 24),  v19);
      uint64_t v22 = 0LL;
    }
  }

  int v13 = 1;
  if (a4) {
LABEL_15:
  }
    *a4 = v14;
LABEL_16:
  if (v14)
  {
    if (v12) {
      sub_100019C64(a1, v11, a3);
    }
    if (v13) {
      sub_100051A44((unsigned __int16 *)(a2 + 408), 8);
    }
  }

  return v22;
}

uint64_t sub_100019FE8( uint64_t a1, char a2, const char *a3, size_t a4, int a5, uint64_t a6, uint64_t a7, void *a8)
{
  size_t v25 = a4;
  if (!a8) {
    return 22LL;
  }
  *a8 = 0LL;
  uint64_t v15 = sub_10001A19C(a3, &v25);
  if (!(_DWORD)v15)
  {
    int v16 = sub_100013EEC(1uLL, 0x48uLL);
    if (v16)
    {
      uint64_t v17 = v16;
      size_t v18 = v25;
      int v19 = sub_100014044(v25);
      *((void *)v17 + 8) = v19;
      if (v19)
      {
        *(_BYTE *)uint64_t v17 = 9;
        *((_BYTE *)v17 + 1) = a2;
        *((_WORD *)v17 + 1) = v18 + 72;
        *((void *)v17 + 1) = a6;
        memcpy(v19, a3, v18 - 1);
        *(_BYTE *)(*((void *)v17 + 8) + v18 - 1) = 0;
        *((_WORD *)v17 + 31) = v18;
        uint64_t v20 = *(void *)(*(void *)(a1 + 376) + 56LL);
        if ((v20 & 1) != 0)
        {
          if (a5 == -1)
          {
            uint64_t v21 = *(void *)(*(void *)(a1 + 376) + 56LL) & 8LL;
            goto LABEL_17;
          }
        }

        else
        {
          uint64_t v21 = *(void *)(*(void *)(a1 + 376) + 56LL) & 8LL;
          if (a5 == -1 || (v20 & 8) == 0)
          {
            if ((v20 & 9) == 0)
            {
              v17[14] = 0;
LABEL_15:
              *((_WORD *)v17 + 30) = 0;
              *((void *)v17 + 2) = a7;
              *((void *)v17 + 3) = 0LL;
              sub_1000511D8((uint64_t)(v17 + 8), 0LL);
              uint64_t v15 = 0LL;
              *a8 = v17;
              return v15;
            }

uint64_t sub_10001A19C(const char *a1, size_t *a2)
{
  size_t v3 = *a2;
  if (*a2)
  {
    if (a1[v3 - 1])
    {
      ++v3;
      goto LABEL_7;
    }
  }

  else
  {
    size_t v3 = strlen(a1) + 1;
  }

  if (v3 == 1) {
    return 22LL;
  }
LABEL_7:
  if (v3 > 0x2FE) {
    return 7LL;
  }
  uint64_t result = 0LL;
  *a2 = v3;
  return result;
}

uint64_t sub_10001A204(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = off_100070140(*a3, a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_10001A240(uint64_t a1, uint64_t a2)
{
  uint64_t __dst = 0LL;
  uint64_t v2 = *(void *)(a1 + 376);
  if ((*(_BYTE *)(v2 + 57) & 2) != 0)
  {
    uint64_t result = 0LL;
    ++*(_DWORD *)(a2 + 104);
  }

  else if ((*(_BYTE *)(v2 + 48) & 2) != 0)
  {
    unint64_t v4 = (unsigned __int16 *)(a2 + 408);
    uint64_t result = sub_1000518D4((unsigned __int16 *)(a2 + 408), 17, 0LL, (char *)&__dst, 8uLL);
    if (!(_DWORD)result)
    {
      ++__dst;
      return sub_100051620(v4, 17, 0, &__dst, 8uLL);
    }
  }

  else
  {
    return 0LL;
  }

  return result;
}

uint64_t sub_10001A2D8(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  *a5 = 0LL;
  return sub_10001ACF4(a1, a2, a3, a4, 0, a5);
}

uint64_t sub_10001A2E8(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return sub_10001B360(a1, a2, a3, a4, a5, 0);
}

uint64_t sub_10001A2F0(uint64_t a1, unint64_t a2, unsigned __int8 a3, _DWORD *a4, int *a5)
{
  if (a4) {
    *a4 = 0;
  }
  uint64_t v10 = 0LL;
  unint64_t v11 = 0LL;
  unsigned int v18 = -1431655766;
  if (!a2) {
    goto LABEL_6;
  }
LABEL_4:
  uint64_t v12 = a2 - v11;
  if (a2 > v11)
  {
    int v13 = (char *)(a1 + v11);
    while (1)
    {
      uint64_t v14 = sub_10001A45C(v13, v12, (int *)&v18);
      unsigned int v15 = v18;
      if ((v18 & 0x80000000) != 0) {
        break;
      }
      if (!v18) {
        goto LABEL_25;
      }
      if (a4 && v18 >= 0x80) {
        *a4 = 1;
      }
      if (v15 >= 0x2000)
      {
        if ((a3 & 2) != 0
          && (v15 - 8206 <= 0x21 && ((1LL << (v15 - 14)) & 0x3F0000003LL) != 0
           || v15 - 8298 < 6
           || (~v15 & 0xFFFE) == 0
           || v15 == 65279
           || v15 - 64976 <= 0x1F))
        {
          uint64_t v10 = 0LL;
          if (!a5) {
            return v10;
          }
          int v16 = 1;
          goto LABEL_29;
        }

        v10 += a3 & ((v15 & 0xFFFF0000) != 0);
      }

      v11 += v14;
      ++v10;
      if (a2) {
        goto LABEL_4;
      }
LABEL_6:
      int v13 = (char *)(a1 + v11);
      uint64_t v12 = -1LL;
    }

    uint64_t v10 = 0LL;
    if (!a5) {
      return v10;
    }
    int v16 = 92;
    goto LABEL_29;
  }

LABEL_25:
  if (a5)
  {
    int v16 = 0;
LABEL_29:
    *a5 = v16;
  }

  return v10;
}

  sub_10003B238(a1, a5);
  return 0LL;
}

  sub_10002FDA8(a1, a2, 0);
  return v14;
}

        uint64_t v21 = *a3;
        if (*a3 == 1)
        {
          int v118 = (uint64_t (*)(uint64_t, void *, int, void *, int, int *))0xAAAAAAAAAAAAAAAALL;
          *(void *)&v109[0] = 0xAAAAAAAAAAAAAAAALL;
          sub_1000442BC(v11, (unint64_t *)&v118, (unint64_t *)v109, 0LL, 0LL);
          uint64_t v22 = sub_10003F31C(v11, (uint64_t)a1, 0LL, 0LL, (uint64_t *)v106);
          if ((_DWORD)v22)
          {
            int v13 = v22;
            else {
              int v23 = (const char *)(*(void *)(v11 + 384) + 208LL);
            }
            sub_100013D94("%s:%d: %s failed to get omap tree for reaping: %d\n", "omap_reap", 322, v23, v13);
            return v13;
          }

          size_t v25 = v12;
          uint64_t v26 = 0LL;
          __int128 v27 = 1024LL;
          if (*(void *)&v109[0] < 0x7D1uLL) {
            __int128 v27 = 102LL;
          }
          if (*(void *)&v109[0] >= 0x3E9uLL) {
            char v28 = v27;
          }
          else {
            char v28 = 51LL;
          }
          uint64_t v104 = 16;
          uint64_t v105 = 16;
          uint64_t v99 = v25;
          uint64_t v93 = v25 - 1;
          uint64_t v95 = v28;
          int v97 = (const char *)(v11 + 3992);
          while (1)
          {
            unint64_t v29 = sub_100026464( (uint64_t)v106[0],  0LL,  (unint64_t *)a3 + 1,  &v105,  0x10u,  &v106[1],  &v104,  4u,  0,  0LL);
            if ((_DWORD)v29) {
              break;
            }
            if (((uint64_t)v106[1] & 1) != 0)
            {
              uint64_t v104 = 16;
              uint64_t v105 = 16;
            }

            else
            {
              uint64_t v89 = v8;
              uint64_t v30 = (v93 + HIDWORD(v106[1])) / v99;
              uint64_t v31 = sub_10004BD08((const char *)v11, 0LL, (unint64_t)v106[2], v30, v5);
              if (v31)
              {
                uint64_t v32 = v31;
                unsigned int v33 = sub_100037DC8(v11);
                int v34 = (const char *)(v11 + 3992);
                if (v33 != 13) {
                  int v34 = (const char *)(*(void *)(v11 + 384) + 208LL);
                }
                sub_100013D94( "%s:%d: %s spaceman_free(%lld, %lld) failed: %d\n",  "omap_reap",  349,  v34,  v106[2],  v30,  v32);
              }

              sub_1000390A0(*(pthread_mutex_t **)(v10 + 392), (uint64_t)v9, *((void *)a3 + 1), *((void *)a3 + 2));
              v26 += v30;
              if (v26 >= v95)
              {
                int v13 = 36LL;
                __int128 v8 = v89;
                goto LABEL_59;
              }

              uint64_t v104 = 16;
              uint64_t v105 = 16;
              __int128 v8 = v89;
            }
          }

          int v13 = v29;
          if ((_DWORD)v29 != 36)
          {
            int v13 = sub_100029238((size_t)v106[0], v5, 0LL);
            if ((_DWORD)v13)
            {
              sub_100013D94("%s:%d: %s tree_delete() failed: %d\n", "omap_reap", 373, v97, v13);
            }

            *a3 = 2;
          }

    if (v9)
    {
LABEL_26:
      unint64_t v11 = 0LL;
      goto LABEL_27;
    }

uint64_t sub_10001A45C(char *a1, uint64_t a2, int *a3)
{
  *a3 = -1;
  if (!a2) {
    return 0LL;
  }
  if (a2 > 4 || a2 == -1) {
    uint64_t v4 = 4LL;
  }
  else {
    uint64_t v4 = a2;
  }
  int v5 = *a1;
  if ((*a1 & 0x80000000) == 0)
  {
    uint64_t v6 = 1LL;
LABEL_10:
    *a3 = v5;
    return v6;
  }

  if ((v5 + 62) <= 0x1Du)
  {
    if (v4 != 1)
    {
      unsigned __int8 v7 = a1[1];
      if ((v7 & 0xC0) == 0x80)
      {
        int v8 = v7 & 0x3F | ((v5 & 0x1F) << 6);
        uint64_t v6 = 2LL;
        int v5 = v8;
        goto LABEL_10;
      }
    }

    return 0LL;
  }

  if ((v5 & 0xF0) == 0xE0)
  {
    if (v4 < 3) {
      return 0LL;
    }
    if (v5 == 224)
    {
      goto LABEL_40;
    }

    if ((v5 + 31) > 0xBu)
    {
      if (v5 == 237)
      {
        if (a1[1] > -97) {
          return 0LL;
        }
        goto LABEL_40;
      }
    }

    else if ((a1[1] & 0xC0) != 0x80)
    {
      return 0LL;
    }

    if ((v5 & 0xFE) == 0xEE && (a1[1] & 0xC0) != 0x80) {
      return 0LL;
    }
LABEL_40:
    unsigned __int8 v12 = a1[2];
    if ((v12 & 0xC0) == 0x80)
    {
      int v5 = ((v5 & 0xF) << 12) | ((a1[1] & 0x3F) << 6) | v12 & 0x3F;
      uint64_t v6 = 3LL;
      goto LABEL_10;
    }

    return 0LL;
  }

  uint64_t v6 = 0LL;
  if (v4 >= 4 && (v5 + 11) >= 0xFBu)
  {
    if (v5 == 240)
    {
      LOBYTE(v9) = a1[1];
    }

    else
    {
      int v9 = a1[1];
      if ((v5 + 15) > 2u)
      {
        if (v9 > -113) {
          return 0LL;
        }
      }

      else if ((v9 & 0xFFFFFFC0) != 0xFFFFFF80)
      {
        return 0LL;
      }
    }

    unsigned __int8 v10 = a1[2];
    if ((v10 & 0xC0) == 0x80)
    {
      unsigned __int8 v11 = a1[3];
      if ((v11 & 0xC0) == 0x80)
      {
        int v5 = ((v5 & 7) << 18) | ((v9 & 0x3F) << 12) | ((v10 & 0x3F) << 6) | v11 & 0x3F;
        uint64_t v6 = 4LL;
        goto LABEL_10;
      }
    }

    return 0LL;
  }

  return v6;
}

uint64_t sub_10001A630(uint64_t a1, uint64_t a2, const char *a3, size_t a4, uint64_t *a5, int *a6, void *a7)
{
  uint64_t v36 = 0LL;
  size_t v37 = a4;
  unint64_t v13 = *(void *)(*(void *)(a1 + 376) + 56LL);
  if ((v13 & 9) == 0)
  {
    v30[0] = (unsigned __int8 *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v15 = sub_100019FE8(a1, 0, a3, a4, -1, a2, 0LL, v30);
    if (!(_DWORD)v15)
    {
      uint64_t v15 = sub_100019060(a1, 1, a5, v30[0], *(void *)(a1 + 432), &v36);
      sub_100014300(v15, v30[0]);
    }

    goto LABEL_12;
  }

  uint64_t v14 = sub_10001A19C(a3, &v37);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
LABEL_12:
    int v19 = 0;
    goto LABEL_13;
  }

  uint64_t v34 = 0LL;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  v30[0] = (unsigned __int8 *)4718601;
  __int128 v31 = 0u;
  v30[1] = (unsigned __int8 *)a2;
  int v35 = -1;
  size_t v16 = v37 - 1;
  DWORD2(v33) = 0;
  uint64_t v17 = sub_100003FEC( (unint64_t)a3,  v37 - 1,  (v13 >> 3) & 1,  (void (*)(_OWORD *, uint64_t, uint64_t))sub_10001A204,  (uint64_t)&v35);
  if ((_DWORD)v17)
  {
    uint64_t v15 = v17;
    if ((_DWORD)v17 != 92) {
      goto LABEL_12;
    }
    int v24 = a3;
    __int128 v25 = v16;
    unsigned int v18 = sub_10001935C( a1,  1,  0LL,  *(void *)(a1 + 432),  (unsigned __int8 *)v30,  (uint64_t (*)(__int128 *, uint64_t))sub_10001A8C4,  (uint64_t)&v24,  a5,  4u);
    if (v18 == -1)
    {
      uint64_t v15 = 0LL;
      if (*((void *)&v25 + 1)) {
        uint64_t v36 = (unsigned __int16 *)*((void *)&v25 + 1);
      }
    }

    else if (v18)
    {
      uint64_t v15 = v18;
    }

    else
    {
      uint64_t v15 = 2LL;
    }

    int v19 = -1;
  }

  else
  {
    int v19 = v35 & 0x3FFFFF;
    DWORD1(v25) = -1431655766;
    uint64_t v27 = a1;
    int v29 = -1431655766;
    int v24 = a3;
    LODWORD(v25) = v35 & 0x3FFFFF;
    *((void *)&v25 + 1) = v16;
    uint64_t v26 = 0LL;
    BOOL v28 = a7 != 0LL;
    unint64_t v22 = a2 & 0xFFFFFFFFFFFFFFFLL | 0x9000000000000000LL;
    int v23 = v35 << 10;
    unsigned int v21 = sub_100019618( a1,  1,  0LL,  (unsigned __int8 *)&v22,  0xCuLL,  (uint64_t)sub_10001A9D0,  (uint64_t)&v24,  0LL,  a5,  516);
    if (v21 == -1)
    {
      uint64_t v15 = 0LL;
      if (v26) {
        uint64_t v36 = v26;
      }
    }

    else if (v21)
    {
      uint64_t v15 = v21;
    }

    else
    {
      uint64_t v15 = 2LL;
    }
  }

uint64_t sub_10001A8C4(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a2 + 8);
  unsigned __int8 v7 = sub_100013EEC(1uLL, 0x48uLL);
  *(void *)(a2 + 16) = v7;
  if (!v7) {
    return 12LL;
  }
  int v8 = sub_100014044(*(unsigned __int16 *)(a1 + 62));
  int v9 = *(_OWORD **)(a2 + 16);
  *((void *)v9 + 8) = v8;
  if (!v8)
  {
    sub_100014004(v9, 72LL);
    return 12LL;
  }

  *int v9 = *(_OWORD *)a1;
  __int128 v10 = *(_OWORD *)(a1 + 16);
  __int128 v11 = *(_OWORD *)(a1 + 32);
  __int128 v12 = *(_OWORD *)(a1 + 48);
  *((void *)v9 + 8) = *(void *)(a1 + 64);
  unint64_t v9[2] = v11;
  unint64_t v9[3] = v12;
  v9[1] = v10;
  memcpy(*(void **)(*(void *)(a2 + 16) + 64LL), *(const void **)(a1 + 64), *(unsigned __int16 *)(a1 + 62));
  uint64_t v13 = sub_1000514A4(*(void *)(a2 + 16) + 32LL, (unsigned __int16 *)(a1 + 32));
  if (!(_DWORD)v13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v13;
  sub_100014004(*(void **)(*(void *)(a2 + 16) + 64LL), *(unsigned __int16 *)(a1 + 62));
  sub_100014004(*(void **)(a2 + 16), 72LL);
  *(void *)(a2 + 16) = 0LL;
  return v5;
}

uint64_t sub_10001A9D0( uint64_t a1, unint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  uint64_t result = 0LL;
  char v18 = 0;
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  unsigned int v8 = *(_DWORD *)(a5 + 8);
  if (v7 >> 10 >= v8)
  {
    if (v7 >> 10 != v8) {
      return 2LL;
    }
    int v13 = *(_DWORD *)(a1 + 8) & 0x3FF;
    uint64_t v14 = *(void *)(a5 + 16);
    uint64_t v15 = *(const char **)a5;
    if (v14 == (v7 & 0x3FF) && !strncmp((const char *)(a1 + 12), *(const char **)a5, v7 & 0x3FF))
    {
      char v18 = 1;
    }

    else
    {
      if (sub_100004980( a1 + 12,  (v13 - 1),  (unint64_t)v15,  v14,  (*(void *)(*(void *)(*(void *)(a5 + 32) + 376LL) + 56LL) >> 3) & 1,  (BOOL *)&v18)) {
        BOOL v16 = 1;
      }
      else {
        BOOL v16 = v18 == 0;
      }
      if (v16) {
        return 0LL;
      }
    }

    if (*(_DWORD *)(a5 + 40)
      && (uint64_t v17 = sub_100018580(*(void *)(a5 + 32), a1, a2, a3, a4), (*(void *)(a5 + 24) = v17) == 0LL))
    {
      return 12LL;
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t sub_10001AAE8()
{
  return 0LL;
}

void sub_10001AAF0(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 476) & 4) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 376);
    if ((*(_BYTE *)(v4 + 264) & 4) == 0)
    {
      uint64_t v5 = (unint64_t *)(v4 + 264);
      do
        unint64_t v6 = __ldxr(v5);
      while (__stxr(v6 | 4, v5));
    }

    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1272));
    *(void *)(a1 + 472) &= ~0x400000000uLL;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1272));
  }

  *(void *)(*(void *)(a1 + 376) + 1056LL) = a2;
  sub_10003E644(a1, a2, 0LL);
}

uint64_t sub_10001AB90(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 96) & 0xF000) != 0x8000
    || sub_10002F2C4(a1) != 3
    || (*(_BYTE *)(a2 + 64) & 8) != 0)
  {
    return 0LL;
  }

  int v4 = *(_DWORD *)(a2 + 76) & 0x1F;
  if (v4 == 3) {
    return 1LL;
  }
  else {
    return (v4 == 4) & ~sub_100030198(a1, 4u);
  }
}

uint64_t sub_10001AC0C(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, int *a6)
{
  int v6 = *a2 > *a4;
  if (*a2 < *a4) {
    int v6 = -1;
  }
  *a6 = v6;
  return 0LL;
}

uint64_t sub_10001AC2C(uint64_t a1)
{
  v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v7.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v7);
  __darwin_time_t v2 = 1000000 * v7.tv_sec + SLODWORD(v7.tv_nsec) / 1000;
  size_t v3 = (unsigned int *)(a1 + 3768);
  do
    unsigned int v4 = __ldxr(v3);
  while (__stxr(v4 + 1, v3));
  unint64_t v5 = v2 - *(void *)(a1 + 3760);
  if (*(int *)(a1 + 3768) >= 17)
  {
    if (v5 < 0xF4240)
    {
      uint64_t result = 0LL;
      *(void *)(a1 + 3760) = v2;
      return result;
    }

    goto LABEL_7;
  }

  if (v5 > 0xF423F)
  {
LABEL_7:
    *(void *)(a1 + 3760) = v2;
    uint64_t result = 1LL;
    *(_DWORD *)(a1 + 3768) = 1;
    return result;
  }

  return 1LL;
}

uint64_t sub_10001ACF4(uint64_t a1, int a2, uint64_t a3, unint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v8 = a3;
  int v9 = a2;
  __int128 v11 = (unint64_t *)(*(void *)(a1 + 392) + 488LL);
  uint64_t v12 = *(void *)(a1 + 376);
  uint64_t v13 = *(void *)(v12 + 72);
  if (v13 && v13 == *(void *)(v12 + 80)) {
    __int128 v11 = (unint64_t *)(a1 + 416);
  }
  memset(v52, 170, sizeof(v52));
  unint64_t v51 = 0xAAAAAAAAAAAAAAAALL;
  char v50 = -86;
  uint64_t v14 = 10LL;
  uint64_t v15 = 1LL;
  char v49 = -86;
  if (a2 != 2 && a2 != 4)
  {
    if (a2 == 5)
    {
      unint64_t v16 = a4 + 6 * a3 + 25;
      sub_1000442BC(a1, &v52[3], 0LL, 0LL, 0LL);
      goto LABEL_13;
    }

    uint64_t v14 = 80LL;
    uint64_t v15 = 3LL;
  }

  unint64_t v16 = 3 * a3 * v15 + a4 + v14;
  sub_1000442BC(a1, &v52[3], 0LL, 0LL, 0LL);
  uint64_t v47 = 0LL;
  if (v9 != 2 && v9 != 4)
  {
LABEL_13:
    LODWORD(v17) = LODWORD(v52[3]) / 0x64;
    if (LODWORD(v52[3]) / 0x64 <= 0x64) {
      uint64_t v17 = 100LL;
    }
    else {
      uint64_t v17 = v17;
    }
    if (v52[3] <= 0x61AE3uLL) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = 4000LL;
    }
    uint64_t v47 = v18;
  }

  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
  uint64_t v19 = sub_10004447C(a1, v16, v47, 0LL, v11, &v52[2], &v52[1], (BOOL *)&v50, v52, &v51, (BOOL *)&v49);
  if ((_DWORD)v19 != 28)
  {
    uint64_t v23 = v19;
    int v44 = a5;
    BOOL v45 = 0;
    int v22 = 0;
    int v21 = 0;
    if (!(_DWORD)v19) {
      goto LABEL_61;
    }
    goto LABEL_25;
  }

  uint64_t v20 = *a6;
  if (*a6 && !v49)
  {
    BOOL v45 = 0;
    int v21 = 0;
    int v22 = 0;
    uint64_t v23 = 28LL;
LABEL_25:
    *a6 = 0LL;
    if (sub_10001AC2C(a1) || v9 == 2 && v16 <= 0x31 && *(int *)(a1 + 3772) <= 9)
    {
      if ((_DWORD)v23 == 28)
      {
        v24.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v24.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        v53[0] = v24;
        v53[1] = v24;
        __strlcpy_chk(v53, "curproc", 32LL, 32LL);
        else {
          __int128 v25 = off_10006C580[v9 - 1];
        }
        sub_100013CBC( "%s:%d: %s %s: ENOSPC: ttype %s (r %lld d %lld tx %d) blocks %lld free %lld txn %lld # %d th %lld rr %lld sh %l ld fq %lld lim %d %d freeup %d wait %d\n",  "fs_tx_enter_internal",  27901,  (const char *)(a1 + 3992),  (const char *)v53,  v25,  v8,  a4,  v45,  v16,  v52[1],  *v11,  *(_DWORD *)(a1 + 1116),  v47,  *(void *)(a1 + 3752),  v52[2],  v52[0],  v50,  v49,  v22,  v21);
        if (v9 == 2 && v16 <= 0x31) {
          ++*(_DWORD *)(a1 + 3772);
        }
      }

      else
      {
        sub_100013D94( "%s:%d: %s failed to compare currently available space: error %d\n",  "fs_tx_enter_internal",  27888,  (const char *)(a1 + 3992),  v23);
      }
    }

    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
    return v23;
  }

  int v44 = a5;
  BOOL v45 = *a6 != 0;
  uint64_t v41 = v8;
  int v42 = v9;
  __int128 v43 = a6;
  unint64_t v26 = 0LL;
  unsigned __int8 v27 = 0;
  int v21 = 0;
  int v22 = 0;
  uint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  if (v20) {
    uint64_t v28 = 10000000LL;
  }
  else {
    uint64_t v28 = 250000000LL;
  }
  while (1)
  {
    if (!v50 || v20 || v52[0] < v52[2]) {
      goto LABEL_48;
    }
    if (v26) {
      break;
    }
    if (v22 <= 31) {
      goto LABEL_43;
    }
LABEL_48:
    if (!v49)
    {
      uint64_t v23 = 28LL;
      goto LABEL_60;
    }

    uint64_t v23 = 28LL;
    v53[0].tv_sec = 0LL;
    v53[0].uint64_t tv_nsec = v28;
    ++v21;
    uint64_t v30 = *(void *)(a1 + 392);
    *(void *)(v30 + 496) += v16;
    int v31 = sub_1000139E8( (pthread_cond_t *)(v30 + 568),  (pthread_mutex_t *)(v30 + 504),  8LL,  (uint64_t)"blocks_in_txn",  v53);
    *(void *)(*(void *)(a1 + 392) + 496LL) -= v16;
    v27 |= v31 == 35;
LABEL_52:
    uint64_t v32 = sub_10004447C(a1, v16, v47, 0LL, v11, &v52[2], &v52[1], (BOOL *)&v50, v52, &v51, (BOOL *)&v49);
    if ((_DWORD)v32 != 28)
    {
      uint64_t v23 = v32;
      goto LABEL_60;
    }
  }

  if (v51 > v26 || v22 >= 32) {
    goto LABEL_48;
  }
LABEL_43:
  ++v22;
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
  uint64_t v48 = 0LL;
  uint64_t v29 = sub_10004FD18(*(void *)(a1 + 392), &v48);
  if (!(_DWORD)v29)
  {
    if (!v26) {
      unint64_t v26 = v48;
    }
    sub_1000445EC(*(void **)(a1 + 392), v52, v48);
    sub_10004FD28(*(void *)(a1 + 392), v48, 4);
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
    goto LABEL_52;
  }

  uint64_t v23 = v29;
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
LABEL_60:
  a6 = v43;
  int v9 = v42;
  uint64_t v8 = v41;
  if ((_DWORD)v23) {
    goto LABEL_25;
  }
LABEL_61:
  __int128 v33 = (unsigned int *)(a1 + 1116);
  do
    unsigned int v34 = __ldxr(v33);
  while (__stxr(v34 + 1, v33));
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
  uint64_t v35 = *(void *)(a1 + 392);
  if (!v44)
  {
    uint64_t v37 = sub_10004FD18(v35, a6);
    if ((_DWORD)v37)
    {
      uint64_t v23 = v37;
      sub_100013D94("%s:%d: %s tx_enter() failed: %d\n");
      goto LABEL_72;
    }

    goto LABEL_68;
  }

  uint64_t v36 = sub_10004FD20(v35, a6);
  if (!(_DWORD)v36)
  {
LABEL_68:
    if (*(_DWORD *)(a1 + 3772)) {
      *(_DWORD *)(a1 + 3772) = 0;
    }
    uint64_t v23 = sub_10003CF9C((void *)a1, 0, *a6);
    if ((_DWORD)v23)
    {
      sub_10004FD28(*(void *)(a1 + 392), *a6, 0);
      goto LABEL_72;
    }

    return v23;
  }

  uint64_t v23 = v36;
  sub_100013D94("%s:%d: %s tx_enter_frozen() failed: %d\n");
LABEL_72:
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
  do
    unint64_t v38 = __ldxr(v11);
  while (__stxr(v38 - v16, v11));
  do
    unsigned int v39 = __ldxr(v33);
  while (__stxr(v39 - 1, v33));
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504LL));
  *a6 = 0LL;
  return v23;
}

uint64_t sub_10001B360(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, int a6)
{
  uint64_t v12 = *(void *)(a1 + 392);
  uint64_t v13 = (unint64_t *)(v12 + 488);
  uint64_t v14 = *(void *)(a1 + 376);
  uint64_t v15 = *(void *)(v14 + 72);
  if (v15 && v15 == *(void *)(v14 + 80)) {
    uint64_t v13 = (unint64_t *)(a1 + 416);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v12 + 504));
  unint64_t v16 = (unsigned int *)(a1 + 1116);
  do
    unsigned int v17 = __ldxr(v16);
  while (__stxr(v17 - 1, v16));
  uint64_t v18 = 10LL;
  uint64_t v19 = 1LL;
  if (a2 != 2 && a2 != 4)
  {
    if (a2 == 5)
    {
      uint64_t v18 = 25LL;
      uint64_t v19 = 2LL;
    }

    else
    {
      uint64_t v18 = 100LL;
      uint64_t v19 = 3LL;
    }
  }

  uint64_t v20 = 3 * a3 * v19 + a4 + v18;
  do
    unint64_t v21 = __ldxr(v13);
  while (__stxr(v21 - v20, v13));
  if ((uint64_t)(v21 - v20) < 0) {
    sub_100013D94( "%s:%d: %s old reserve was %lld, num_blocks %lld. blocks_in_txn_counter %lld num_active_txns=%d\n",  "fs_tx_leave_ext",  28032,  (const char *)(a1 + 3992),  v21,  v20,  *v13,  *(_DWORD *)(a1 + 1116));
  }
  *(void *)(*(void *)(a1 + 376) + 256LL) = sub_100032B28();
  sub_10001AAF0(a1, a5);
  uint64_t v22 = *(void *)(a1 + 392);
  if (*(void *)(v22 + 496))
  {
    j__pthread_cond_broadcast((pthread_cond_t *)(v22 + 568));
    uint64_t v22 = *(void *)(a1 + 392);
  }

  pthread_mutex_unlock((pthread_mutex_t *)(v22 + 504));
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  sub_1000442BC(a1, &v32, &v31, 0LL, 0LL);
  if (v21 && (*(void *)(*(void *)(a1 + 376) + 48LL) & 2) != 0 && v32 >= 0xA01 && v21 + 4000 >= v31) {
    a6 |= 4u;
  }
  if (v32 <= 0x61AE3)
  {
    LODWORD(v23) = v32 / 0x64;
    else {
      uint64_t v23 = v23;
    }
  }

  else
  {
    uint64_t v23 = 4000LL;
  }

  unint64_t v24 = v23 + v21 - v20;
  unint64_t v25 = v31;
  int v26 = *(_DWORD *)(a1 + 3776);
  if (v24 >= v31)
  {
    *(_DWORD *)(a1 + 3776) = v26 + 1;
    if (v26 <= 99)
    {
      else {
        unsigned __int8 v27 = off_10006C580[a2 - 1];
      }
      sub_100013D04( "%s:%d: %s gettin' low on space: ttype %s num_blocks %lld blocks_in_txn %lld free_blocks %lld xid %lld\n",  "fs_tx_leave_ext",  28063,  (const char *)(a1 + 3992),  v27,  v20,  v21 - v20,  v25,  a5);
    }
  }

  else if (v26 >= 100)
  {
    *(_DWORD *)(a1 + 3776) = 0;
  }

  if (!a5) {
    return 0LL;
  }
  ++*(void *)(a1 + 424);
  uint64_t v28 = sub_10004FD28(*(void *)(a1 + 392), a5, a6);
  uint64_t v29 = v28;
  if ((_DWORD)v28) {
    sub_100013D94("%s:%d: %s tx_leave failed: %d\n", "fs_tx_leave_ext", 28078, (const char *)(a1 + 3992), v28);
  }
  return v29;
}

uint64_t sub_10001B640(int a1, int a2)
{
  uint64_t v2 = 0LL;
  if (a2 != -1 && a2 <= 1)
  {
    uint64_t v2 = 0LL;
    if (a1 == 1)
    {
      if (a2)
      {
        uint64_t v2 = 1LL;
        sub_100013D94( "%s:%d: Volume role %d is not allowed at fs index %d\n",  "apfs_is_volume_fsindex_allowed",  30474,  1,  a2);
      }
    }
  }

  return v2;
}

uint64_t sub_10001B6AC(void *a1, int a2, int a3, int a4, int a5)
{
  if (a3 == 576 && (a5 & 1) == 0)
  {
    sub_100013D94("%s:%d: Volume role 0x%x is not allowed for an unencrypted volume\n");
    return 1LL;
  }

  if (a2 == a3) {
    goto LABEL_5;
  }
  if (a2 <= 255)
  {
    if (a2 > 127)
    {
      if (a2 != 128 && a2 != 192) {
        goto LABEL_5;
      }
    }

    else if (a2 != 4 && a2 != 16)
    {
      goto LABEL_5;
    }

    goto LABEL_82;
  }

  if (a2 > 383)
  {
    if (a2 == 384)
    {
      sub_100013D94("%s:%d: cannot change role of Backup volume\n");
      return 1LL;
    }

    if (a2 == 448)
    {
      sub_100013D94("%s:%d: cannot change role of SideCar volume\n");
      return 1LL;
    }

    if (a2 != 704) {
      goto LABEL_5;
    }
LABEL_82:
    sub_100013D94("%s:%d: cannot change role of system-unique volume\n");
    return 1LL;
  }

  if (a2 == 256)
  {
    sub_100013D94("%s:%d: cannot change role of xART volume\n");
    return 1LL;
  }

  if (a2 == 320) {
    goto LABEL_82;
  }
LABEL_5:
  if (a3)
  {
    BOOL v8 = a3 == 704;
    if (a3 <= 191)
    {
      if (((a3 - 1) > 0x3F || ((1LL << (a3 - 1)) & 0x800000008000800BLL) == 0)
        && a3 != 128)
      {
        goto LABEL_101;
      }

      goto LABEL_23;
    }

    if (a3 <= 511)
    {
      if (a3 != 192 && a3 != 256 && a3 != 320) {
        goto LABEL_101;
      }
    }

    else if (a3 > 639)
    {
      if (a3 != 640 && a3 != 704) {
        goto LABEL_101;
      }
    }

    else if (a3 != 512 && a3 != 576)
    {
LABEL_101:
      sub_100013D94("%s:%d: Volume role 0x%x is not supported in container\n", "apfs_is_volume_role_allowed", 30646, a3);
      return 45LL;
    }
  }

  else
  {
    BOOL v8 = 0;
  }

LABEL_23:
  uint64_t v9 = a1[47];
  if (!*(_DWORD *)(v9 + 180)) {
    return 0LL;
  }
  BOOL v22 = v8;
  unint64_t v10 = 0LL;
  *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uuid_string_t out = v11;
  *(_OWORD *)&out[16] = v11;
  while (1)
  {
    uint64_t v23 = 0LL;
    unint64_t v12 = *(void *)(v9 + 8 * v10 + 184);
    if (v12) {
      break;
    }
LABEL_72:
    ++v10;
    uint64_t v9 = a1[47];
  }

  uint64_t v13 = sub_10003B574(a1[49], 0, v12, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, &v23);
  uint64_t v14 = v13;
  if ((_DWORD)v13)
  {
    uint64_t v20 = (const char *)(a1[48] + 208LL);
    unint64_t v21 = strerror(v13);
    sub_100013D94("%s:%d: %s Failed to get fsys oid %lld - %s\n", "apfs_is_volume_role_allowed", 30660, v20, v12, v21);
    return v14;
  }

  char v15 = 1;
  if (a3 > 191)
  {
    if (a3 <= 511)
    {
      if (a3 == 192)
      {
        unint64_t v16 = (uint64_t *)v23;
        if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) == 192) {
          goto LABEL_62;
        }
        goto LABEL_74;
      }

      if (a3 != 256)
      {
        unint64_t v16 = (uint64_t *)v23;
        if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) == 320) {
          goto LABEL_62;
        }
LABEL_74:
        sub_100038824(v16);
        goto LABEL_72;
      }

      if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) != 256) {
        goto LABEL_60;
      }
      goto LABEL_62;
    }

    switch(a3)
    {
      case 512:
        unint64_t v16 = (uint64_t *)v23;
        int v17 = *(unsigned __int16 *)(*(void *)(v23 + 376) + 964LL);
        if (v17 == 512) {
          goto LABEL_62;
        }
        if (v22) {
          goto LABEL_57;
        }
        goto LABEL_74;
      case 640:
        if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) == 640) {
          goto LABEL_62;
        }
        goto LABEL_60;
      case 704:
        int v17 = *(unsigned __int16 *)(*(void *)(v23 + 376) + 964LL);
LABEL_57:
        if (v17 != 704)
        {
          uint64_t v14 = 0LL;
          goto LABEL_63;
        }

  sub_100014004(v26, v22);
  return v21;
}

      sub_100038824(v25);
    }
  }

  return v13;
}

LABEL_62:
        uuid_unparse((const unsigned __int8 *)(a1[47] + 72LL), out);
        sub_100013D94( "%s:%d: %s Volume role 0x%x already exists in container uuid %s\n",  "apfs_is_volume_role_allowed",  30683,  (const char *)(v23 + 3992),  a3,  out);
        char v15 = 0;
        uint64_t v14 = 17LL;
        goto LABEL_63;
    }

    goto LABEL_63;
  }

  if (a3 > 15)
  {
    switch(a3)
    {
      case 16:
        if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) != 16) {
          goto LABEL_60;
        }
        break;
      case 32:
        if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) != 32) {
          goto LABEL_60;
        }
        break;
      case 128:
        unint64_t v16 = (uint64_t *)v23;
        if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) == 128) {
          goto LABEL_62;
        }
        goto LABEL_74;
      default:
        goto LABEL_63;
    }

    goto LABEL_62;
  }

  if (a3 == 1)
  {
    unint64_t v16 = (uint64_t *)v23;
    if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) == 1) {
      goto LABEL_62;
    }
    goto LABEL_74;
  }

  if (a3 != 4)
  {
LABEL_63:
    if (a3 > 255)
    {
      if (a3 == 256 || a3 == 640 || a3 == 704) {
        goto LABEL_70;
      }
    }

    else if (a3 <= 0x20 && ((1LL << a3) & 0x100010110LL) != 0)
    {
      goto LABEL_70;
    }

    uint64_t v18 = (uint64_t *)v23;
LABEL_71:
    sub_100038824(v18);
    if ((v15 & 1) == 0) {
      return v14;
    }
    goto LABEL_72;
  }

  if (*(_WORD *)(*(void *)(v23 + 376) + 964LL) == 4) {
    goto LABEL_62;
  }
LABEL_60:
  uint64_t v14 = 0LL;
LABEL_70:
  uint64_t v18 = (uint64_t *)v23;
  if (!a5) {
    goto LABEL_71;
  }
  sub_100013D94("%s:%d: %s Encrypted volume is not allowed with special role = 0X%x\n");
  return 1LL;
}

uint64_t sub_10001BC2C(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, void *a5)
{
  uint64_t v134 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  *(void *)int v135 = 0LL;
  uint64_t v132 = 0LL;
  unint64_t v133 = 0xAAAAAAAAAAAAAAAALL;
  memset(uu, 170, sizeof(uu));
  uint64_t v130 = 0LL;
  unint64_t v131 = 0LL;
  unint64_t v128 = 0LL;
  uint64_t v129 = 0LL;
  uuid_clear(uu);
  *a5 = 0LL;
  if (a2)
  {
    unint64_t v10 = *(int *)(*(void *)(a1 + 376) + 36LL);
    if (!sub_10001A2F0(a2 + 56, 0LL, 0, 0LL, 0LL)) {
      return 92LL;
    }
    int v31 = *(_DWORD *)(a2 + 36);
    int v32 = *(_DWORD *)(a2 + 40);
    unint64_t v33 = *(void *)(a2 + 16);
    unint64_t v34 = *(void *)(a2 + 24);
    if (v33 % v10) {
      uint64_t v35 = v33 / v10 + 1;
    }
    else {
      uint64_t v35 = v33 / v10;
    }
    if (v34 % v10) {
      uint64_t v36 = v34 / v10 + 1;
    }
    else {
      uint64_t v36 = v34 / v10;
    }
    int v37 = *(_DWORD *)(a2 + 48);
    unsigned int v38 = *(unsigned __int16 *)(a2 + 52);
    int v39 = (v37 == 1) << 6;
    if (!v37) {
      int v39 = 1;
    }
    if (*(_WORD *)(a2 + 54)) {
      BOOL v40 = 1;
    }
    else {
      BOOL v40 = v37 == -1;
    }
    if (v40) {
      int v18 = *(unsigned __int16 *)(a2 + 54);
    }
    else {
      int v18 = v39;
    }
    BOOL v41 = v18 == 64 || v18 == 1;
    int v111 = *(_DWORD *)(a2 + 44);
    int v114 = *(_DWORD *)(a2 + 444);
    uint64_t v127 = a4;
    uint64_t v121 = v36;
    uint64_t v123 = v35;
    int v115 = *(_DWORD *)(a2 + 448);
    int v117 = *(_DWORD *)(a2 + 32);
    int v119 = *(_DWORD *)(a2 + 492);
    uint64_t v11 = sub_10001B6AC((void *)a1, 0, v18, v37, v38 & 1 | (v38 >> 9) & 1);
    if ((_DWORD)v11) {
      return v11;
    }
    int v109 = (v38 >> 9) & 1;
    int v104 = v38 & 1;
    if (v31 != 2) {
      sub_100013D4C( "%s:%d: %s fs tree type 0x%x invalid, using virtual btree instead\n",  "apfs_newfs",  31236,  (const char *)(*(void *)(a1 + 384) + 208LL),  v31);
    }
    if (v32 != 1073741826) {
      sub_100013D4C( "%s:%d: %s extentref tree type 0x%x invalid, using physical btree instead\n",  "apfs_newfs",  31240,  (const char *)(*(void *)(a1 + 384) + 208LL),  v32);
    }
    int v26 = (v38 >> 2) & 3;
    int v16 = (v38 >> 4) & 3;
    int v21 = (v38 >> 8) & 1;
    int v23 = (a3 >> 5) & 1;
    int v24 = (a3 >> 7) & 1;
    int v25 = (a3 >> 8) & 1;
    int v22 = (v38 >> 10) & 1;
    int v107 = v26;
    if (v111 != 1073741826)
    {
      sub_100013D4C( "%s:%d: %s snapmeta tree type 0x%x invalid, using physical btree instead\n",  "apfs_newfs",  31244,  (const char *)(*(void *)(a1 + 384) + 208LL),  v111);
      int v26 = (v38 >> 2) & 3;
      int v22 = (v38 >> 10) & 1;
      int v23 = (a3 >> 5) & 1;
      int v24 = (a3 >> 7) & 1;
      int v25 = (a3 >> 8) & 1;
    }

    int v12 = (v38 >> 7) & 1;
    unint64_t v14 = v121;
    unint64_t v13 = v123;
    if ((v38 & 0x80) != 0)
    {
      int v29 = v119;
      if (v119 != 1073741826)
      {
        int v44 = v25;
        int v45 = v23;
        int v46 = v22;
        sub_100013D4C( "%s:%d: %s fext tree type 0x%x invalid, using physical btree instead\n",  "apfs_newfs",  31249,  (const char *)(*(void *)(a1 + 384) + 208LL),  v119);
        int v26 = v107;
        int v22 = v46;
        unint64_t v14 = v121;
        unint64_t v13 = v123;
        int v23 = v45;
        int v24 = (a3 >> 7) & 1;
        int v25 = v44;
        int v12 = 1;
        int v29 = 1073741826;
      }
    }

    else
    {
      int v29 = v119;
    }

    unsigned int v27 = v37;
    uint64_t v30 = (const char *)(a2 + 56);
    int v19 = v114;
    int v20 = v115;
    int v28 = v117;
    int v15 = v104;
    int v17 = v109;
  }

  else
  {
    uint64_t v127 = a4;
    int v12 = 0;
    unint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    int v15 = 0;
    int v16 = 0;
    int v17 = 0;
    int v18 = 0;
    int v19 = 0;
    int v20 = 0;
    int v21 = 0;
    int v22 = 0;
    int v23 = 0;
    int v24 = 0;
    int v25 = 0;
    int v26 = 8;
    unsigned int v27 = -1;
    int v28 = 1073741826;
    int v29 = 1073741826;
    uint64_t v30 = "untitled";
  }

  if (*(_BYTE *)(a1 + 629) && v15 | v17) {
    return 1LL;
  }
  if (v16) {
    return 22LL;
  }
  if (v18 == 704 && (!v13 || v13 != v14))
  {
    sub_100013D94( "%s:%d: %s bad overprovisioning volume configuration: reserve %lld quota %lld\n",  "apfs_newfs",  31279,  (const char *)(*(void *)(a1 + 384) + 208LL),  v13,  v14);
    return 22LL;
  }

  uint64_t v42 = *(void *)(a1 + 376);
  if (v27 == -1)
  {
    if (v18 == 64) {
      int v47 = 1;
    }
    else {
      int v47 = -1;
    }
    BOOL v48 = v18 == 64 || v18 == 1;
    uint64_t v43 = *(unsigned int *)(v42 + 180);
    if (v18 == 1) {
      unsigned int v27 = 0;
    }
    else {
      unsigned int v27 = v47;
    }
    unsigned int v49 = v27;
    if (v18 != 1)
    {
      unsigned int v49 = v27;
      if (v18 != 64)
      {
        if (v43 < 3)
        {
          unsigned int v49 = 2;
        }

        else
        {
          uint64_t v50 = 0LL;
          while (*(void *)(v42 + 200 + 8 * v50))
          {
            if (v43 - 2 == ++v50)
            {
              unsigned int v49 = *(_DWORD *)(v42 + 180);
              goto LABEL_77;
            }
          }

          unsigned int v49 = v50 + 2;
LABEL_77:
          if ((v49 & 0x80000000) != 0) {
            goto LABEL_83;
          }
        }
      }
    }

    if (v49 < v43)
    {
      if (!*(void *)(v42 + 8LL * v49 + 184))
      {
        BOOL v48 = 1;
        unsigned int v27 = v49;
      }

      if (v48) {
        goto LABEL_39;
      }
      goto LABEL_85;
    }

LABEL_83:
    if (v18 == 1 || v18 == 64) {
      goto LABEL_39;
    }
LABEL_85:
    if (!(_DWORD)v43)
    {
      unsigned int v27 = 0;
      goto LABEL_91;
    }

    uint64_t v56 = 0LL;
    while (*(void *)(v42 + 184 + 8 * v56))
    {
      if (v43 == ++v56)
      {
        unsigned int v27 = *(_DWORD *)(v42 + 180);
        goto LABEL_37;
      }
    }

    unsigned int v27 = v56;
  }

      int v46 = 0;
      goto LABEL_8;
    }

uint64_t sub_10001CDE8(void *a1, const unsigned __int8 *a2)
{
  uint64_t v2 = a1[47];
  if (*(_DWORD *)(v2 + 180))
  {
    for (unint64_t i = 0LL; i < *(unsigned int *)(v2 + 180); ++i)
    {
      unint64_t v13 = 0LL;
      unint64_t v6 = *(void *)(v2 + 8 * i + 184);
      if (v6)
      {
        uint64_t v7 = sub_10003B574(a1[49], 0, v6, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, (uint64_t *)&v13);
        if ((_DWORD)v7)
        {
          uint64_t v9 = v7;
          unint64_t v10 = (const char *)(a1[48] + 208LL);
          uint64_t v11 = strerror(v7);
          sub_100013D94( "%s:%d: %s Failed to get fsys oid %lld - %s\n",  "apfs_is_volume_uuid_allowed",  30744,  v10,  v6,  v11);
          return v9;
        }

        int v8 = uuid_compare(a2, (const unsigned __int8 *)(v13[47] + 240));
        sub_100038824(v13);
        if (!v8) {
          return 17LL;
        }
        uint64_t v2 = a1[47];
      }
    }
  }

  return 0LL;
}

uint64_t sub_10001CF00(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (*(void *)(a1 + 496)) {
    uint64_t v7 = *(void *)(a1 + 496);
  }
  else {
    uint64_t v7 = a1;
  }
  uint64_t v8 = sub_10004BD08((const char *)v7, 0LL, a3, a4, a2);
  uint64_t v9 = v8;
  if ((_DWORD)v8)
  {
    unint64_t v10 = strerror(v8);
    sub_100013D94( "%s:%d: %s spaceman_free failed for LBA %llx, size %llu : %d %s\n",  "apfs_free_data_blocks",  31970,  (const char *)(v7 + 3992),  a3,  a4,  v9,  v10);
  }

  else
  {
    uint64_t v11 = (unint64_t *)(*(void *)(v7 + 376) + 232LL);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + a4, v11));
    sub_10001AAF0(v7, a2);
  }

  return v9;
}

BOOL sub_10001CFC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 496);
  if (!v1) {
    uint64_t v1 = a1;
  }
  return (*(_BYTE *)(*(void *)(v1 + 376) + 264LL) & 1) != 0 && *(void *)(*(void *)(a1 + 376) + 976LL) == 0LL;
}

uint64_t sub_10001CFF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 496);
  if (!v6) {
    uint64_t v6 = a1;
  }
  if ((*(_BYTE *)(*(void *)(v6 + 376) + 264LL) & 9) != 0) {
    panic("assertion failed: %s", "fs_is_content_protected(apfs)");
  }
  uint64_t v12 = 0LL;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  LODWORD(v10) = 2622471;
  *((void *)&v10 + 1) = a2;
  LODWORD(v11) = -1;
  uint64_t v7 = sub_10001811C(a1, 1, (unsigned __int8 *)&v10, a3);
  if (!(_DWORD)v7)
  {
    if ((_DWORD)v11 == 1)
    {
LABEL_12:
      BYTE1(v10) = 3;
      return sub_100018458(a1, 1, (unsigned __int8 *)&v10, a3);
    }

    if (!(_DWORD)v11)
    {
      sub_100013CBC( "%s:%d: %s danger - crypto id %lld had refcnt %d\n",  "icp_dec_ref",  34217,  (const char *)(a1 + 3992),  *((void *)&v10 + 1),  0);
      LODWORD(v11) = 1;
      goto LABEL_12;
    }

    return 0LL;
  }

  uint64_t v8 = v7;
  sub_100013CBC( "%s:%d: %s was NOT able to update/decrement crypto state %lld, err = %d\n",  "icp_dec_ref",  34211,  (const char *)(a1 + 3992),  a2,  v7);
  return v8;
}

BOOL sub_10001D154(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> ((v3 & 0xC0u) - a2);
  if (a3 >= 64)
  {
    while (((-1LL << v5) & ~((-1LL << v5) & *(void *)(a1 + 8 * v4))) == 0
         && (!v5 || (v6 & ~*(void *)(a1 + 8 * v4 + 8)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64LL;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1LL;
      }
    }

    return 0LL;
  }

  uint64_t v7 = a3;
  if (!a3) {
    return 1LL;
  }
LABEL_13:
  unint64_t v9 = ~(-1LL << v7);
  unint64_t v10 = v9 << v5;
  unint64_t v11 = v9 >> (64 - v5);
  if (!v5) {
    unint64_t v11 = 0LL;
  }
  return (v10 & ~((-1LL << v5) & *(void *)(a1 + 8 * v4))) == 0
      && (v7 <= (uint64_t)(64 - v5) || !v11 || (v11 & ~(v6 & *(void *)(a1 + 8 * v4 + 8))) == 0);
}

uint64_t sub_10001D234(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v6 = 64 - v5;
  if (a3 >= 64)
  {
    while (((-1LL << v5) & *(void *)(a1 + 8 * v4)) == 0
         && (!v5 || (*(void *)(a1 + 8 * v4 + 8) & (0xFFFFFFFFFFFFFFFFLL >> v6)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64LL;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1LL;
      }
    }

    return 0LL;
  }

  uint64_t v7 = a3;
  if (a3)
  {
LABEL_13:
    unint64_t v9 = ~(-1LL << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0LL;
    }
    if ((v10 & (-1LL << v5) & *(void *)(a1 + 8 * v4)) != 0
      || v7 > v6 && v11 && ((0xFFFFFFFFFFFFFFFFLL >> v6) & v11 & *(void *)(a1 + 8 * v4 + 8)) != 0)
    {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_10001D318(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }

  do
  {
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~(-1LL << v5) | (-1LL << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) |= 0xFFFFFFFFFFFFFFFFLL >> v6;
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64LL;
  }

  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1LL << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0LL;
    }
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~v10 | v10 & (-1LL << v5);
    if (v7 > v6)
    {
      if (v11) {
        *(void *)(result + 8 * v4 + 8) = *(void *)(result + 8 * v4 + 8) & ~v11 | v11 & (0xFFFFFFFFFFFFFFFFLL >> v6);
      }
    }
  }

  return result;
}

uint64_t sub_10001D400(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0LL);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }

  do
  {
    *(void *)(result + 8 * v4) &= ~(-1LL << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) &= ~(0xFFFFFFFFFFFFFFFFLL >> v6);
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64LL;
  }

  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1LL << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (v5) {
      unint64_t v12 = v11;
    }
    else {
      unint64_t v12 = 0LL;
    }
    *(void *)(result + 8 * v4) &= ~v10;
    if (v7 > v6)
    {
      if (v12) {
        *(void *)(result + 8 * v4 + 8) &= ~v12;
      }
    }
  }

  return result;
}

uint64_t sub_10001D4C8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a4 < 1) {
    return 0LL;
  }
  if (a1) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = -1LL;
  }
  uint64_t v6 = (unint64_t *)(a2 + 8 * (a3 / 64));
  while (1)
  {
    uint64_t v7 = a3 & 0x3F;
    if (a3 <= 0) {
      uint64_t v7 = -(-a3 & 0x3F);
    }
    unint64_t v8 = 64 - v7;
    unint64_t v10 = *v6++;
    unint64_t v9 = v10;
    unint64_t v11 = __clz(__rbit64((v9 >> v7) ^ v5));
    if (v8 > v11) {
      break;
    }
    a3 += v8;
    BOOL v12 = a4 <= (uint64_t)v8;
    a4 -= v8;
    if (v12) {
      return 0LL;
    }
  }

  *a5 = v11 + a3;
  return 1LL;
}

uint64_t sub_10001D54C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v4 = a3 + a2;
  uint64_t v5 = a3 + a2 - 1;
  if (a3 + a2 < 1) {
    uint64_t v5 = a3 + a2 + 62;
  }
  uint64_t v6 = (uint64_t *)(a1 + 8 * (v5 >> 6));
  while (1)
  {
    if (v4 <= 0) {
      uint64_t v7 = -(-v4 & 0x3F);
    }
    else {
      uint64_t v7 = v4 & 0x3F;
    }
    char v8 = 64 - v7;
    if (!v7)
    {
      uint64_t v7 = 64LL;
      char v8 = 0;
    }

    if (v7 >= a3) {
      uint64_t v7 = a3;
    }
    uint64_t v9 = *v6--;
    int64_t v10 = __clz(v9 << v8);
    if (v7 > v10) {
      break;
    }
    v4 -= v7;
    BOOL v11 = a3 <= v7;
    a3 -= v7;
    if (v11) {
      return 0LL;
    }
  }

  *a4 = v4 + ~v10;
  return 1LL;
}

BOOL sub_10001D5D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, int a7)
{
  uint64_t v12 = 0LL;
  unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v34 = a4 - 1;
  uint64_t v13 = -1LL;
  while (1)
  {
    if (v12 >= a2) {
      goto LABEL_40;
    }
    unint64_t v14 = a4 - a3;
    if (a4 - a3 < 1) {
      goto LABEL_40;
    }
    uint64_t v15 = 8 * (a3 / 64);
    while (1)
    {
      uint64_t v16 = a3 & 0x3F;
      if (a3 <= 0) {
        uint64_t v16 = -(-a3 & 0x3F);
      }
      unint64_t v17 = 64 - v16;
      if (64 - v16 >= v14) {
        unint64_t v17 = v14;
      }
      unint64_t v18 = __clz(__rbit64(~(*(void *)(a1 + v15) >> v16)));
      if (v17 > v18) {
        break;
      }
      a3 += v17;
      v15 += 8LL;
      BOOL v19 = (uint64_t)v14 <= (uint64_t)v17;
      v14 -= v17;
      if (v19) {
        goto LABEL_40;
      }
    }

    uint64_t v20 = v18 + a3;
    if ((uint64_t)(v18 + a3) >= a4 - v12)
    {
LABEL_40:
      uint64_t v20 = v13;
      goto LABEL_41;
    }

    if (!v12)
    {
      uint64_t v13 = v18 + a3;
      uint64_t v12 = 1LL;
      if (v20 >= v34)
      {
        uint64_t v12 = 1LL;
        goto LABEL_41;
      }
    }

    uint64_t v35 = a5;
    uint64_t v21 = v12 + 1;
    uint64_t v22 = v12 + 1 < a4 - v20 ? v12 + 1 : a4 - v20;
    a5 = v35;
    unint64_t v23 = v36;
    uint64_t v20 = v13;
LABEL_38:
    a3 = v23 + 1;
    if (a7) {
      goto LABEL_41;
    }
  }

  uint64_t v24 = a2 - v21;
  if (a2 != v21)
  {
    uint64_t v25 = v21 + v20;
    if (v24 >= a4 - (v21 + v20)) {
      uint64_t v24 = a4 - (v21 + v20);
    }
    if (v24 < 1)
    {
LABEL_35:
      uint64_t v12 = v24 + v21;
    }

    else
    {
      uint64_t v26 = v25 + 63;
      if (v25 >= 0) {
        uint64_t v26 = v21 + v20;
      }
      unsigned int v27 = (unint64_t *)(a1 + 8 * (v26 >> 6));
      unint64_t v28 = v24;
      while (1)
      {
        uint64_t v29 = v25 & 0x3F;
        if (v25 <= 0) {
          uint64_t v29 = -(-v25 & 0x3F);
        }
        unint64_t v30 = 64 - v29;
        if (64 - v29 >= v28) {
          unint64_t v30 = v28;
        }
        unint64_t v31 = *v27++;
        unint64_t v32 = __clz(__rbit64(v31 >> v29));
        if (v30 > v32) {
          break;
        }
        v25 += v30;
        BOOL v19 = (uint64_t)v28 <= (uint64_t)v30;
        v28 -= v30;
        if (v19) {
          goto LABEL_35;
        }
      }

      uint64_t v12 = v32 + v25 - v20;
    }

    a5 = v35;
    unint64_t v23 = v12 + v20;
    unint64_t v36 = v12 + v20;
    uint64_t v13 = v20;
    goto LABEL_38;
  }

  uint64_t v12 = a2;
  a5 = v35;
LABEL_41:
  *a5 = v20;
  *a6 = v12;
  return v12 == a2;
}

BOOL sub_10001D7E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  return sub_10001D5D4(a1, a2, a3, a4, a5, a6, 0);
}

BOOL sub_10001D7E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  return sub_10001D5D4(a1, a2, a3, a4, a5, a6, 1);
}

unint64_t sub_10001D7F0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= a4) {
    return 0LL;
  }
  unint64_t result = 0LL;
  if (a2) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = -1LL;
  }
  if (a2) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = 0LL;
  }
  do
  {
    unint64_t v8 = a4 - a3;
    if (a4 - a3 < 1) {
      break;
    }
    uint64_t v9 = (unint64_t *)(a1 + 8 * (a3 / 64));
    while (1)
    {
      uint64_t v10 = a3 & 0x3F;
      if (a3 <= 0) {
        uint64_t v10 = -(-a3 & 0x3F);
      }
      unint64_t v11 = 64 - v10;
      unint64_t v13 = *v9++;
      unint64_t v12 = v13;
      if (64 - v10 >= v8) {
        unint64_t v11 = v8;
      }
      unint64_t v14 = __clz(__rbit64((v12 >> v10) ^ v6));
      if (v11 > v14) {
        break;
      }
      a3 += v11;
      BOOL v15 = (uint64_t)v8 <= (uint64_t)v11;
      v8 -= v11;
      if (v15) {
        return result;
      }
    }

    uint64_t v16 = v14 + a3;
    uint64_t v17 = a4 - (v14 + a3);
    if (v17 < 1) {
      return result - v16 + a4;
    }
    uint64_t v18 = v16 + 63;
    if (v16 >= 0) {
      uint64_t v18 = v14 + a3;
    }
    BOOL v19 = (unint64_t *)(a1 + 8 * (v18 >> 6));
    uint64_t v20 = v14 + a3;
    while (1)
    {
      uint64_t v21 = v20 & 0x3F;
      if (v20 <= 0) {
        uint64_t v21 = -(-v20 & 0x3F);
      }
      unint64_t v22 = 64 - v21;
      unint64_t v24 = *v19++;
      unint64_t v23 = v24;
      unint64_t v25 = __clz(__rbit64((v23 >> v21) ^ v7));
      if (v22 > v25) {
        break;
      }
      v20 += v22;
      BOOL v15 = v17 <= (uint64_t)v22;
      v17 -= v22;
      if (v15) {
        return result - v16 + a4;
      }
    }

    a3 = v25 + v20;
    unint64_t result = result - v16 + v25 + v20;
  }

  while ((uint64_t)(v25 + v20) < a4);
  return result;
}

unint64_t sub_10001D914( unint64_t *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t result = sub_100035A40(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(result)
      + result
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(result) + result) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  *a1 = v8 | ((unint64_t)~((_DWORD)v8
                                + (_DWORD)result
  return result;
}

unint64_t sub_10001D980( void *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t v7 = sub_100035A40(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(v7)
      + v7
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(v7) + v7) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  return (v8 | ((unint64_t)~((_DWORD)v8
                                  + (_DWORD)v7
}

uint64_t sub_10001D9F0(char a1, __int16 a2, int a3, int a4)
{
  if (a3 && a4)
  {
    __int16 v4 = (a3 + 7) & 0xFFF8;
    if ((a1 & 0x40) != 0) {
      __int16 v4 = a3;
    }
    __int16 v5 = (a4 + 7) & 0xFFF8;
    if ((a1 & 0x40) != 0) {
      __int16 v5 = a4;
    }
    return (unsigned __int16)(v5 + v4);
  }

  else
  {
    unsigned __int16 v6 = a2 - 160;
    if (a4)
    {
      unsigned __int16 v7 = (v6 >> 2) - 72;
      if ((a1 & 0x40) == 0) {
        unsigned __int16 v7 = (v7 + 7) & 0xFFF8;
      }
      __int16 v8 = (a4 + 7) & 0xFFF8;
      if ((a1 & 0x40) != 0) {
        __int16 v8 = a4;
      }
      return (unsigned __int16)(v7 + v8);
    }
  }

  return v6;
}

uint64_t sub_10001DA64(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unint64_t v4 = *(void *)(a1 + 400);
  unsigned int v5 = (v4 >> 9) & 0x3FFF;
  if (v5) {
    BOOL v6 = v5 == a2;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    return 22LL;
  }
  BOOL v8 = !(unsigned __int16)(v4 >> 23) || (unsigned __int16)(v4 >> 23) == a3;
  if (!v8 && (a3 != 65534 && a3 || (v4 & 4) == 0)) {
    return 22LL;
  }
  uint64_t v9 = (v4 >> 27) & 0x1F000;
  if (a3 == 65534) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = a3;
  }
  unsigned int v12 = sub_10001D9F0(v4, v9, v5, (unsigned __int16)(v4 >> 23));
  unsigned int v13 = (a2 + 7) & 0xFFFFFFF8;
  if ((v4 & 0x40) != 0) {
    unsigned int v13 = a2;
  }
  unsigned int v14 = (v11 + 7) & 0xFFFFFFF8;
  if ((v4 & 0x40) != 0) {
    unsigned int v14 = v11;
  }
  if (v13 + v14 <= v12) {
    return 0LL;
  }
  else {
    return 34LL;
  }
}

uint64_t sub_10001DB34(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  unsigned int v5 = sub_1000398C8((uint64_t)a1);
  unsigned int v6 = v5;
  unsigned int v7 = *(unsigned __int16 *)(v4 + 32);
  if ((v7 & 4) != 0) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = 8;
  }
  if (a2)
  {
    unint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = (v9 >> 27) & 0x1F000;
    BOOL v11 = v5 != (_DWORD)v10;
    int v12 = *(unsigned __int16 *)(a2 + 6);
    if (v12 == 61455)
    {
      unsigned __int8 v13 = v5 != (_DWORD)v10;
    }

    else
    {
      if (v5 == (_DWORD)v10) {
        char v15 = 1;
      }
      else {
        char v15 = 2;
      }
      else {
        unsigned __int8 v13 = v15;
      }
    }

    else {
      unsigned __int8 v14 = v13 + 1;
    }
  }

  else
  {
    unsigned __int8 v14 = 0;
  }

  if (v5 % *(_DWORD *)(*(void *)(*(void *)(*a1 + 392LL) + 376LL) + 36LL)) {
    unsigned __int8 v16 = v14 + 1;
  }
  else {
    unsigned __int8 v16 = v14;
  }
  int v17 = sub_100037DC8((uint64_t)a1);
  unsigned int v18 = *(unsigned __int16 *)(v4 + 32);
  if (v17 != 2)
  {
    if ((v18 & 0x10) == 0 && *(_WORD *)(v4 + 24) != 3) {
      ++v16;
    }
    if ((v18 & 1) != 0) {
      unsigned __int8 v19 = v16 + 1;
    }
    else {
      unsigned __int8 v19 = v16;
    }
    if ((v18 & 2) == 0) {
      goto LABEL_38;
    }
LABEL_36:
    if (*(_WORD *)(v4 + 34)) {
      ++v19;
    }
    goto LABEL_38;
  }

  if ((v18 & 0x10) == 0 && *(_WORD *)(v4 + 24) != 2) {
    ++v16;
  }
  if ((v18 & 1) == 0)
  {
    unsigned __int8 v19 = v16 + 1;
    if ((v18 & 2) == 0) {
      goto LABEL_38;
    }
    goto LABEL_36;
  }

  uint64_t v38 = v4 + v6;
  unsigned int v39 = *(_DWORD *)(v38 - 40);
  if (v6 <= 0x10000 && *(_DWORD *)(v38 - 36) == v6) {
    unsigned __int8 v41 = v16;
  }
  else {
    unsigned __int8 v41 = v16 + 1;
  }
  uint64_t v43 = *(unsigned int *)(v38 - 32);
  unint64_t v42 = *(unsigned int *)(v38 - 28);
  else {
    unsigned __int8 v44 = v41 + 1;
  }
  if (((v39 >> 7) & 1) == ((v18 >> 3) & 1)) {
    unsigned __int8 v45 = v44;
  }
  else {
    unsigned __int8 v45 = v44 + 1;
  }
  if (((v39 >> 8) & 1) == ((v18 >> 4) & 1)) {
    unsigned __int8 v19 = v45;
  }
  else {
    unsigned __int8 v19 = v45 + 1;
  }
  if ((v18 & 2) != 0) {
    goto LABEL_36;
  }
LABEL_38:
  if ((v18 & 1) != 0) {
    __int16 v20 = -96;
  }
  else {
    __int16 v20 = -56;
  }
  unsigned __int16 v21 = v20 + v6;
  if (*(_WORD *)(v4 + 40)) {
    ++v19;
  }
  unsigned int v22 = *(unsigned __int16 *)(v4 + 42);
  if (v21 < v22) {
    ++v19;
  }
  if (((v8 - 1) & v22) != 0) {
    ++v19;
  }
  if ((v7 & 4) != 0) {
    char v23 = 2;
  }
  else {
    char v23 = 3;
  }
  if (*(_DWORD *)(v4 + 36) > v22 >> v23) {
    ++v19;
  }
  unsigned int v24 = *(unsigned __int16 *)(v4 + 44);
  unsigned int v25 = (unsigned __int16)(v21 - v22);
  BOOL v26 = v25 >= v24;
  int v27 = v25 - v24;
  if (!v26) {
    ++v19;
  }
  else {
    int v28 = 255;
  }
  if (v28 == v19) {
    return 0LL;
  }
  uint64_t v30 = *(void *)(*a1 + 392LL);
  if (v30)
  {
    BOOL v31 = sub_100010058(v30);
    sub_100037DC8((uint64_t)a1);
    sub_1000398B8((uint64_t)a1);
    sub_10003965C((uint64_t)a1);
    sub_100013DDC( v31,  "%s:%d: %s BT node sanity check failed for node type %u subtype %u oid %llu with mask 0x%x!\n",  v32,  v33,  v34,  v35,  v36,  v37,  (char)"btree_node_sanity_check");
    uint64_t v30 = *(void *)(*a1 + 392LL);
  }

  return sub_100005194(v30);
}

uint64_t sub_10001DEB4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a3) {
    return 22LL;
  }
  __int16 v3 = *(_WORD *)(a3 + 4);
  __int16 v4 = v3 & 0x1B;
  *(_WORD *)(a1 + 32) = v4;
  *(_WORD *)(a1 + 34) = *(_WORD *)(a3 + 6);
  unint64_t v5 = *(void *)(a3 + 8);
  if (((v5 >> 27) & 0x1F000) != a2) {
    return 22LL;
  }
  unint64_t v6 = a2 - 56LL;
  unsigned int v7 = (v5 >> 9) & 0x3FFF;
  uint64_t v8 = (HIWORD(v5) & 0x7F) + 8;
  int v9 = (unsigned __int16)(v5 >> 23);
  if ((v3 & 2) != 0) {
    int v10 = v9;
  }
  else {
    int v10 = v8;
  }
  LOWORD(v11) = 64;
  if (v7 && v10)
  {
    v4 |= 4u;
    *(_WORD *)(a1 + 32) = v4;
    int v11 = (4 * (v6 / (v7 + v10 + 4))) & 0xFFFFFFF8;
  }

  uint64_t v12 = 0LL;
  if ((v4 & 1) != 0) {
    LOWORD(v6) = a2 - 96;
  }
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 42) = v11;
  *(_WORD *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 46) = v6 - v11;
  *(void *)(a1 + 48) = 0xFFFF0000FFFFLL;
  if ((v4 & 1) != 0)
  {
    uint64_t v12 = 0LL;
    unsigned __int8 v13 = (_DWORD *)(a1 + (unsigned __int16)(a2 - 96));
    v13[14] = *(_DWORD *)(a3 + 8) & 0x1FF;
    v13[15] = a2;
    v13[16] = (*(_DWORD *)(a3 + 8) >> 9) & 0x3FFF;
    v13[17] = (unsigned __int16)(*(void *)(a3 + 8) >> 23);
  }

  return v12;
}

uint64_t sub_10001DF9C(uint64_t a1, uint64_t a2)
{
  return sub_100029588(a1, a2, 1);
}

uint64_t sub_10001DFA4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int16 v5 = *(_WORD *)(a1[7] + 32);
  if ((v5 & 8) != 0) {
    return 45LL;
  }
  uint64_t v8 = a1[1];
  if (v8)
  {
    int v9 = sub_10003CF9C((void *)a1[1], 0, a5);
    if (v9)
    {
      int v10 = v9;
      uint64_t v11 = a1[1];
      if (v11) {
        uint64_t v12 = (const char *)(v11 + 3992);
      }
      else {
        uint64_t v12 = (const char *)(*(void *)(*(void *)(*a1 + 392) + 384LL) + 208LL);
      }
      uint64_t v15 = sub_10003965C(v8);
      sub_100013D94("%s:%d: %s obj_modify(fs %lld) failed: %d\n", "btree_node_reap", 399, v12, v15, v10);
    }

    if ((*(_WORD *)(a1[7] + 32) & 2) != 0) {
      goto LABEL_25;
    }
    uint64_t v14 = sub_10003965C(v8);
    goto LABEL_13;
  }

  if ((v5 & 2) == 0)
  {
    uint64_t v14 = 0LL;
LABEL_13:
    int v16 = sub_100037DC0((uint64_t)a1);
    if (((*(_WORD *)(a1[7] + 36) - 1) & 0x8000) == 0)
    {
      unsigned int v17 = v16 & 0xFFFF0000 | 3;
      int v18 = (unsigned __int16)(*(_WORD *)(a1[7] + 36) - 1);
      do
      {
        unint64_t v24 = 0LL;
        if (sub_10001EA14((uint64_t)a1, (unsigned __int16)v18, &v24))
        {
          sub_10003965C((uint64_t)a1);
          sub_100013D94("%s:%d: %s error getting oid for child %d of 0x%llx: %d\n");
        }

        else
        {
          uint64_t v19 = *a1;
          if (*(unsigned __int16 *)(a1[7] + 34) < 2u)
          {
            int v23 = sub_1000398C8((uint64_t)a1);
          }

          else
          {
            __int16 v20 = *(void **)(v19 + 392);
            int v21 = sub_1000398C8((uint64_t)a1);
          }
        }
      }

      while (v18-- > 0);
    }
  }

uint64_t sub_10001E24C(void *a1, void *a2, uint64_t a3, int a4, __int16 a5, uint64_t a6, void *a7)
{
  unint64_t v14 = a1[50];
  if ((v14 & 0x40000000000000LL) != 0) {
    size_t v15 = 96LL;
  }
  else {
    size_t v15 = (HIWORD(v14) & 0x7F) + 32;
  }
  __chkstk_darwin();
  unsigned int v17 = (char *)&v30 - v16;
  bzero((char *)&v30 - v16, v15);
  uint64_t v31 = 0LL;
  __int128 v30 = xmmword_10005B940;
  int v18 = sub_1000398C0((uint64_t)a1) & 0xFC00;
  *(_WORD *)unsigned int v17 = 25987;
  *((_WORD *)v17 + 1) = v15;
  *(_OWORD *)(v17 + 8) = *((_OWORD *)a1 + 25);
  *((void *)v17 + 3) = a1[52];
  unint64_t v19 = a1[50];
  if ((v19 & 0x80) != 0)
  {
    if ((v19 & 0x40000000000000LL) != 0) {
      size_t v20 = 64LL;
    }
    else {
      size_t v20 = HIWORD(v19) & 0x7F;
    }
    memcpy(v17 + 32, a2 + 1, v20);
  }

  *((_WORD *)v17 + 2) = 0;
  *((_WORD *)v17 + 3) = a5;
  DWORD2(v30) = sub_1000398C8((uint64_t)a1);
  int v21 = sub_100037DC0((uint64_t)a1);
  LODWORD(v30) = v21 & 0xFFFF0000 | 3;
  DWORD1(v30) = sub_1000398B8((uint64_t)a1);
  if ((v21 & 0x40000000) != 0) {
    int v22 = 3;
  }
  else {
    int v22 = 1;
  }
  if ((a4 & 0x40) != 0) {
    int v23 = 0LL;
  }
  else {
    int v23 = &v30;
  }
  uint64_t v24 = sub_10003B574( *a1,  v18 | (a4 << 31 >> 31) & v22 | (2 * (a4 & 2)) | (8 * a4) & 0x20 | a4 & 0x180 | v21 & 0xFFFF0000,  *a2,  v23,  v17,  a1[1],  a3,  a6,  &v31);
  if ((_DWORD)v24)
  {
    uint64_t v25 = v24;
    uint64_t v26 = 0LL;
  }

  else
  {
    uint64_t v26 = v31;
    if ((a4 & 0x104) == 4 && (*(_BYTE *)(v31 + 16) & 0x10) != 0)
    {
      if ((a4 & 1) != 0) {
        unsigned int v27 = 2;
      }
      else {
        unsigned int v27 = 1;
      }
      if ((a4 & 2) != 0) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = 0LL;
      }
      sub_10001E478(v31, v28);
      uint64_t v26 = 0LL;
      uint64_t v25 = 2LL;
    }

    else
    {
      uint64_t v25 = 0LL;
    }
  }

  *a7 = v26;
  return v25;
}

void sub_10001E478(uint64_t *a1, char a2)
{
  int v3 = a2 & 3;
  if (v3) {
    sub_10003D514((uint64_t)a1, v3);
  }
  sub_100038824(a1);
}

uint64_t sub_10001E4A8(uint64_t a1)
{
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 4) != 0) {
    return 4LL;
  }
  else {
    return 8LL;
  }
}

uint64_t sub_10001E4C4(uint64_t a1, int a2)
{
  uint64_t v2 = *(_WORD **)(a1 + 56);
  __int16 v3 = v2[16];
  if ((v3 & 4) != 0)
  {
    unint64_t v5 = *(void *)(a1 + 400);
    if ((v5 & 4) != 0)
    {
      if ((v3 & 2) != 0) {
        unint64_t v9 = v5 >> 23;
      }
      else {
        LODWORD(v9) = (HIWORD(v5) & 0x7F) + 8;
      }
      unint64_t v10 = (((v5 >> 27) & 0x1F000) - 56) / (((v5 >> 9) & 0x3FFF) + (unsigned __int16)v9 + 4);
      unsigned __int16 v11 = v2[18] + a2;
      if ((v10 & 0xFFFE) >= v11) {
        LOWORD(v4) = v10 & 0xFFFE;
      }
      else {
        LOWORD(v4) = (v11 + 7) & 0xFFF8;
      }
    }

    else
    {
      unsigned int v6 = (unsigned __int16)v2[21];
      BOOL v7 = (v3 & 4) == 0;
      char v8 = 2;
      if (v7) {
        char v8 = 3;
      }
      return (unsigned __int16)(v6 >> v8);
    }
  }

  else
  {
    unsigned int v4 = (a2 + *((_DWORD *)v2 + 9) + 7) & 0xFFFFFFF8;
    if (!v4) {
      LOWORD(v4) = 8;
    }
  }

  return (unsigned __int16)v4;
}

uint64_t sub_10001E564(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  __int16 v3 = (unsigned __int16 *)(v2 + 4LL * a2);
  unsigned int v4 = (unsigned __int16 *)(v2 + 8LL * a2);
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 4) != 0) {
    unint64_t v5 = v3;
  }
  else {
    unint64_t v5 = v4;
  }
  return *v5;
}

uint64_t sub_10001E588(uint64_t a1, unsigned int a2)
{
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 4) != 0) {
    return (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    return *(unsigned __int16 *)(*(void *)(a1 + 376) + 8LL * a2 + 2);
  }
}

uint64_t sub_10001E5B0(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  uint64_t v3 = v2 + 4LL * a2 + 2;
  uint64_t v4 = v2 + 8LL * a2 + 4;
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 4) != 0) {
    unint64_t v5 = (unsigned __int16 *)v3;
  }
  else {
    unint64_t v5 = (unsigned __int16 *)v4;
  }
  return *v5;
}

uint64_t sub_10001E5DC(uint64_t a1, unsigned int a2)
{
  __int16 v2 = *(_WORD *)(*(void *)(a1 + 56) + 32LL);
  uint64_t v3 = *(void *)(a1 + 376);
  if ((v2 & 4) != 0)
  {
    uint64_t v4 = (unsigned __int16 *)(v3 + 4LL * a2 + 2);
    uint64_t v5 = *(void *)(a1 + 400) >> 23;
  }

  else
  {
    uint64_t v5 = v3 + 8LL * a2;
    uint64_t v4 = (unsigned __int16 *)(v5 + 4);
    LOWORD(v5) = *(_WORD *)(v5 + 6);
  }

  int v6 = *v4;
  if (v6 == 0xFFFF)
  {
    LOWORD(v5) = 0;
  }

  else if (v6 == 65534)
  {
    LOWORD(v5) = -2;
  }

  else if ((v2 & 2) == 0)
  {
    LOWORD(v5) = (*(_WORD *)(a1 + 406) & 0x7F) + 8;
  }

  return (unsigned __int16)v5;
}

uint64_t sub_10001E654(uint64_t a1, unsigned int a2, void *a3, _WORD *a4)
{
  if (!a1) {
    return 22LL;
  }
  uint64_t v5 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v5 + 36) <= a2) {
    return 22LL;
  }
  __int16 v8 = *(_WORD *)(v5 + 32);
  uint64_t v9 = *(void *)(a1 + 376);
  unint64_t v10 = (unsigned __int16 *)(v9 + 4LL * a2);
  if ((v8 & 4) == 0) {
    unint64_t v10 = (unsigned __int16 *)(v9 + 8LL * a2);
  }
  uint64_t v11 = *v10;
  if ((v8 & 4) != 0) {
    int v12 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    int v12 = *(unsigned __int16 *)(v9 + 8LL * a2 + 2);
  }
  uint64_t result = sub_10001E710(a1, *v10, v12);
  if (!(_DWORD)result)
  {
    *a3 = *(void *)(a1 + 384) + v11;
    uint64_t result = 0LL;
    if (a4) {
      *a4 = v12;
    }
  }

  return result;
}

uint64_t sub_10001E710(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v3 = *(unsigned __int16 *)(*(void *)(a1 + 56) + 44LL);
  BOOL v4 = v3 >= a2;
  int v5 = v3 - a2;
  if (v5 == 0 || !v4) {
    return sub_100005194(*(void *)(*(void *)a1 + 392LL));
  }
  int v6 = (a3 + 7) & 0x1FFF8;
  if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
    int v6 = a3;
  }
  if (v6 <= v5) {
    return 0LL;
  }
  else {
    return sub_100005194(*(void *)(*(void *)a1 + 392LL));
  }
}

uint64_t sub_10001E764(void *a1, unsigned int a2, void *a3, __int16 *a4)
{
  uint64_t v4 = a1[7];
  uint64_t v8 = a1[47];
  uint64_t v9 = v8 + 4LL * a2 + 2;
  uint64_t v10 = v8 + 8LL * a2 + 4;
  if ((*(_WORD *)(v4 + 32) & 4) != 0) {
    uint64_t v11 = (unsigned __int16 *)v9;
  }
  else {
    uint64_t v11 = (unsigned __int16 *)v10;
  }
  uint64_t v12 = *v11;
  unsigned int v13 = sub_10001E5DC((uint64_t)a1, a2);
  __int16 v14 = v13;
  uint64_t result = sub_10001E838((uint64_t)a1, v12, v13);
  if (!(_DWORD)result)
  {
    if (v12 >= 0xFFFE)
    {
      *a3 = 0LL;
      if (!a4) {
        return 0LL;
      }
      if ((_DWORD)v12 == 0xFFFF) {
        __int16 v14 = 0;
      }
      else {
        __int16 v14 = -2;
      }
    }

    else
    {
      *a3 = a1[49] - v12;
      if (!a4) {
        return 0LL;
      }
    }

    uint64_t result = 0LL;
    *a4 = v14;
  }

  return result;
}

uint64_t sub_10001E838(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 >= 0xFFFE)
  {
    if ((*(_BYTE *)(a1 + 400) & 4) == 0 || a3 && a3 != 65534) {
      return sub_100005194(*(void *)(*(void *)a1 + 392LL));
    }
  }

  else
  {
    if (!a3 || a3 == 65534) {
      return sub_100005194(*(void *)(*(void *)a1 + 392LL));
    }
    __int16 v6 = sub_1000398C8(a1);
    uint64_t v7 = *(void *)(a1 + 56);
    __int16 v8 = (*(_BYTE *)(v7 + 32) & 1) != 0 ? -96 : -56;
    unsigned int v9 = (a3 + 7) & 0x1FFF8;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      unsigned int v9 = a3;
    }
    if (v9 > a2) {
      return sub_100005194(*(void *)(*(void *)a1 + 392LL));
    }
  }

  return 0LL;
}

uint64_t sub_10001E938(uint64_t a1, unsigned int a2, void *a3)
{
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 2) != 0) {
    return 22LL;
  }
  unsigned int v9 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v8 = -21846;
  uint64_t result = sub_10001E764((void *)a1, a2, &v9, (__int16 *)&v8);
  if ((_DWORD)result) {
    return result;
  }
  if ((*(_WORD *)(a1 + 406) & 0x7F) + 8LL == v8)
  {
    uint64_t result = 0LL;
    if (!a3) {
      return result;
    }
  }

  else
  {
    uint64_t result = sub_100005194(*(void *)(*(void *)a1 + 392LL));
    if (!a3) {
      return result;
    }
  }

  if (!(_DWORD)result)
  {
    __int16 v6 = v9;
    uint64_t v7 = *v9;
    *a3 = *v9;
    if ((*(_BYTE *)(*(void *)(a1 + 56) + 32LL) & 8) != 0)
    {
      *a3 = *(void *)(a1 + 408) + v7;
      memcpy(a3 + 1, v6 + 1, v8 - 8LL);
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_10001EA14(uint64_t a1, size_t a2, void *a3)
{
  unsigned int v4 = a2;
  __int16 v6 = (uint64_t *)((char *)&v8 - (HIWORD(*(void *)(a1 + 400)) & 0x7FLL) - 8);
  bzero(v6, a2);
  uint64_t result = sub_10001E938(a1, v4, v6);
  if (!(_DWORD)result) {
    *a3 = *v6;
  }
  return result;
}

uint64_t sub_10001EADC( void *a1, uint64_t a2, unint64_t *a3, int a4, void *a5, unsigned int a6, uint64_t a7)
{
  LODWORD(v10) = a4;
  unint64_t v14 = a1[50];
  __chkstk_darwin();
  uint64_t v16 = (BOOL **)((char *)&v200 - v15);
  bzero((char *)&v200 - v15, v17);
  __int128 v238 = 0u;
  __int128 v239 = 0u;
  __int128 v237 = 0u;
  uint64_t v235 = 0LL;
  uint64_t v236 = 0LL;
  unint64_t v234 = 0xAAAAAAAAAAAAAAAALL;
  int v233 = 0;
  int v229 = -1431655766;
  int v228 = -1431655766;
  if (!a1[52]) {
    return 22LL;
  }
  uint64_t v223 = a2;
  unsigned __int16 v232 = -21846;
  unsigned __int16 v231 = v10;
  if (a6 == 65534) {
    unsigned __int16 v18 = 0;
  }
  else {
    unsigned __int16 v18 = a6;
  }
  unsigned __int16 v230 = v18;
  uint64_t v19 = sub_10001DA64((uint64_t)a1, v10, a6);
  if ((_DWORD)v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = a1[1];
    if (v21)
    {
      int v22 = (const char *)(v21 + 3992);
      if ((v14 & 0x40) != 0) {
        int v23 = v10;
      }
      else {
        int v23 = (v10 + 7) & 0xFFFFFFF8;
      }
      if ((v14 & 0x40) != 0) {
        int v24 = v18;
      }
      else {
        int v24 = (v18 + 7) & 0x1FFF8;
      }
      char v25 = v14;
      uint64_t v26 = (v14 >> 27) & 0x1F000;
      int v27 = (unsigned __int16)(v14 >> 23);
      unsigned int v28 = (v14 >> 9) & 0x3FFF;
      if (v28) {
        unsigned int v29 = (v14 >> 9) & 0x3FFF;
      }
      else {
        unsigned int v29 = ((unsigned __int16)((v26 - 160) & 0xFFE0) >> 2) - 72;
      }
    }

    else
    {
      int v22 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
      if ((v14 & 0x40) != 0) {
        int v23 = v10;
      }
      else {
        int v23 = (v10 + 7) & 0xFFFFFFF8;
      }
      if ((v14 & 0x40) != 0) {
        int v24 = v18;
      }
      else {
        int v24 = (v18 + 7) & 0x1FFF8;
      }
      char v25 = v14;
      uint64_t v26 = (v14 >> 27) & 0x1F000;
      int v27 = (unsigned __int16)(v14 >> 23);
      unsigned int v28 = (v14 >> 9) & 0x3FFF;
      if (v28) {
        unsigned int v29 = (v14 >> 9) & 0x3FFF;
      }
      else {
        unsigned int v29 = ((unsigned __int16)((v26 - 160) & 0xFFE0) >> 2) - 72;
      }
    }

    int v31 = sub_10001D9F0(v25, v26, v28, v27);
    sub_100013D94( "%s:%d: %s request to insert entry %d (%d) %d (%d) = (%d), max size is %d key %d, error %d\n",  "bt_insert",  3389,  v22,  v10,  v23,  v18,  v24,  v23 + v24,  v31,  v29,  v20);
    return v20;
  }

  sub_10003CF10((uint64_t)a1, 2);
  uint64_t v30 = sub_10003CF9C(a1, (*((_DWORD *)a1 + 100) >> 3) & 2, a7);
  if ((_DWORD)v30)
  {
    uint64_t v20 = v30;
    sub_10003D514((uint64_t)a1, 2);
    return v20;
  }

  *(void *)&__int128 v237 = a1;
  sub_10003DC28((char *)a1);
  uint64_t v33 = a1[49];
  int v34 = *(_DWORD *)(v33 + 16);
  unsigned int v35 = (unsigned __int16)v34;
  BOOL v36 = *(_DWORD *)(v33 + 20) >= v18;
  int v210 = v34;
  BOOL v220 = v36;
  if (a1[54])
  {
    uint64_t v37 = (unsigned int (*)(uint64_t, unint64_t *, void))a1[53];
    if (v37)
    {
      uint64_t v38 = a1[1];
      if (!v38) {
        uint64_t v38 = *(void *)(*a1 + 392LL);
      }
      if (v37(v38, a3, (unsigned __int16)v10))
      {
        __int128 v238 = v237;
        *(void *)&__int128 v237 = 0LL;
        uint64_t v39 = a1[54];
        void *v16 = v39;
        if (v39 != sub_10003965C((uint64_t)a1)
          && !sub_10001E24C( a1,  v16,  v223,  (a7 != 0) | (((*(unsigned __int16 *)(a1[7] + 32LL) >> 3) & 1) << 6) | 6u,  61455,  a7,  &v237))
        {
          uint64_t v40 = v237;
          if ((*(_WORD *)(*(void *)(v237 + 56) + 32LL) & 2) != 0 && a1[54] == *(void *)(v237 + 112))
          {
            int v41 = sub_10002080C( v237,  a3,  (unsigned __int16)v10,  (_WORD *)&v237 + 4,  (BOOL *)((unint64_t)&v237 | 0xA));
            uint64_t v40 = v237;
            if (!v41)
            {
              if (WORD4(v237))
              {
                if (BYTE10(v237)) {
                  int v42 = ((uint64_t (*)(void))sub_1000209D8)(v237);
                }
                else {
                  int v42 = ((uint64_t (*)(void))sub_1000212D0)(v237);
                }
                if (!v42)
                {
                  uint64_t v214 = 0LL;
                  unsigned __int8 v45 = 0LL;
                  uint64_t v20 = 0LL;
                  int v215 = 0;
                  BOOL v221 = 0;
                  goto LABEL_341;
                }

                uint64_t v40 = v237;
              }
            }
          }

          sub_10003D514(v40, 2);
          sub_100038824(v40);
        }

        __int128 v237 = v238;
        *(void *)&__int128 v238 = 0LL;
      }
    }
  }

  uint64_t v43 = (BOOL *)((unint64_t)&v237 | 0xA);
  if ((*(_WORD *)(*(void *)(v237 + 56) + 32LL) & 2) != 0) {
    uint64_t v44 = sub_10002080C(v237, a3, (unsigned __int16)v10, (_WORD *)&v237 + 4, v43);
  }
  else {
    uint64_t v44 = sub_100021744(v237, a3, (unsigned __int16)v10, (_WORD *)&v237 + 4, v43);
  }
  uint64_t v20 = v44;
  if ((_DWORD)v44) {
    goto LABEL_56;
  }
  v218 = (BOOL *)((unint64_t)&v237 | 0xA);
  uint64_t v219 = (_WORD *)&v237 + 4;
  uint64_t v46 = *(void *)(v237 + 56);
  unsigned int v47 = *(_DWORD *)(v46 + 36);
  __int16 v48 = *(_WORD *)(v46 + 32);
  BOOL v49 = (__PAIR64__(v47, v48 & 2) - 1) >> 32 == WORD4(v237);
  int v50 = WORD4(v237) | BYTE10(v237) | v48 & 2;
  if (v50)
  {
    unsigned __int8 v45 = 0LL;
    if ((v48 & 2) == 0)
    {
      uint64_t v51 = 0LL;
      goto LABEL_61;
    }

    int v215 = 0;
    BOOL v221 = 0;
    uint64_t v214 = 0LL;
LABEL_295:
    uint64_t v133 = v239;
    if ((void)v239)
    {
      int v134 = v220;
      if ((void *)v239 != a1) {
        int v134 = 1;
      }
      if (v134 == 1 && (void *)v239 != v45 && (void)v239 != v214)
      {
        sub_10003D514(v239, 2);
        sub_100038824(v133);
      }

      *(void *)&__int128 v239 = 0LL;
    }

    uint64_t v135 = v223;
    if (v49)
    {
      uint64_t v136 = a1[54];
      uint64_t v137 = *(void *)(v237 + 112);
      if (v136 != v137)
      {
        uint64_t v138 = a1[50];
        if (v136)
        {
          if ((v138 & 0x10) == 0) {
            panic("btree rightmost leaf mismatch! (expected %lld found %lld)\n", *(void *)(v237 + 112), v136);
          }
          panic("btree rightmost leaf field is set for physical tree!\n");
        }

        if ((v138 & 0x10) == 0) {
          a1[54] = v137;
        }
      }
    }

    size_t v10 = v231;
    if (BYTE10(v237)) {
      uint64_t v139 = sub_1000209D8(v237, WORD4(v237), a3, v231, a5, (unsigned __int16)a6, a7);
    }
    else {
      uint64_t v139 = sub_1000212D0(v237, WORD4(v237), a3, v231, a5, (unsigned __int16)a6, a7);
    }
    uint64_t v20 = v139;
    if ((_DWORD)v139 != 28) {
      goto LABEL_336;
    }
    uint64_t v140 = sub_100021A68( a1,  (void *)v238,  WORD4(v238),  (void *)v237,  WORD4(v237),  a3,  v10,  1LL,  (__int16 *)&v231,  (__int16 *)&v230,  0,  v135,  a7,  (uint64_t *)&v236);
    if ((_DWORD)v140)
    {
      uint64_t v20 = v140;
      uint64_t v141 = a1[1];
      if (v141) {
        uint64_t v142 = (const char *)(v141 + 3992);
      }
      else {
        uint64_t v142 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s bt_shift_or_split failed with error: %d\n", "bt_insert", 3875, v142, v140);
      goto LABEL_336;
    }

    uint64_t v143 = v236;
    if (!v236)
    {
      uint64_t v143 = (void *)v237;
      goto LABEL_331;
    }

    if ((void)v238)
    {
      ++WORD4(v238);
      uint64_t v144 = v237;
      int v145 = v220;
      if ((void *)v237 != a1) {
        int v145 = 1;
      }
      if ((void)v237 && v145 && (void *)v237 != v45 && (void)v237 != v214)
      {
        uint64_t v146 = (uint64_t)v236;
        sub_10003D514(v237, 2);
        sub_100038824(v144);
        uint64_t v143 = (void *)v146;
      }

      uint64_t v236 = 0LL;
      *(void *)&__int128 v237 = v143;
LABEL_331:
      uint64_t v20 = sub_100023A70(v143, a3, v10, a5, (unsigned __int16)a6, a7, v219, v218);
      if (!(_DWORD)v20) {
        goto LABEL_336;
      }
      goto LABEL_332;
    }

    int v167 = (_WORD *)&v238 + 4;
    uint64_t v168 = v237;
    *(void *)&__int128 v238 = v237;
    if (*(_DWORD *)(v236[7] + 36LL))
    {
      uint64_t v222 = (char *)&v238 + 8;
      uint64_t v169 = (uint64_t)v236;
      uint64_t v170 = sub_10001E654((uint64_t)v236, 0, &v234, &v232);
      if ((_DWORD)v170)
      {
        uint64_t v20 = v170;
        uint64_t v236 = 0LL;
        *(void *)&__int128 v237 = v169;
        goto LABEL_332;
      }

      uint64_t v168 = v238;
      uint64_t v188 = (unint64_t *)v234;
      uint64_t v189 = v232;
      int v167 = v222;
    }

    else
    {
      uint64_t v169 = (uint64_t)v236;
      uint64_t v188 = a3;
      uint64_t v189 = v10;
    }

    uint64_t v20 = sub_100021744(v168, v188, v189, v167, (BOOL *)&v238 + 10);
    uint64_t v143 = (void *)v169;
    uint64_t v236 = 0LL;
    *(void *)&__int128 v237 = v169;
    if (!(_DWORD)v20) {
      goto LABEL_331;
    }
LABEL_332:
    uint64_t v147 = a1[1];
    if (v147) {
      unsigned __int16 v148 = (const char *)(v147 + 3992);
    }
    else {
      unsigned __int16 v148 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94("%s:%d: %s bt_shift_or_split failed with error: %d\n", "bt_insert", 3912, v148, v20);
LABEL_336:
    if (!(_DWORD)v20 && !WORD4(v237) && (void)v238)
    {
      uint64_t v149 = sub_10001E654(v238, WORD4(v238), &v234, &v232);
      if ((_DWORD)v149)
      {
        uint64_t v20 = v149;
      }

      else
      {
        uint64_t v158 = a1[1];
        if (!v158) {
          uint64_t v158 = *(void *)(*a1 + 392LL);
        }
        uint64_t v20 = ((uint64_t (*)(uint64_t, unint64_t *, size_t, unint64_t, void, int *))a1[52])( v158,  a3,  v10,  v234,  v232,  &v233);
        if (!(_DWORD)v20)
        {
          if (v233)
          {
            uint64_t v159 = sub_1000209D8(v238, WORD4(v238), a3, v10, 0LL, 0, a7);
            uint64_t v20 = v159;
            if ((_DWORD)v159)
            {
              uint64_t v160 = a1[1];
              if (v160) {
                uint64_t v161 = (const char *)(v160 + 3992);
              }
              else {
                uint64_t v161 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
              }
              sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_insert", 3926, v161, v159);
            }
          }
        }
      }
    }

LABEL_341:
    uint64_t v150 = v238;
    if ((void)v238)
    {
      int v151 = v220;
      if ((void *)v238 != a1) {
        int v151 = 1;
      }
      if (v151 == 1 && (void *)v238 != v45 && (void)v238 != v214)
      {
        sub_10003D514(v238, 2);
        sub_100038824(v150);
      }

      *(void *)&__int128 v238 = 0LL;
    }

    uint64_t v152 = v237;
    if ((void)v237)
    {
      int v153 = v220;
      if ((void *)v237 != a1) {
        int v153 = 1;
      }
      if (v153 == 1 && (void *)v237 != v45 && (void)v237 != v214)
      {
        sub_10003D514(v237, 2);
        sub_100038824(v152);
      }

      *(void *)&__int128 v237 = 0LL;
    }

    if ((_DWORD)v20) {
      goto LABEL_445;
    }
    uint64_t v154 = a1[49];
    unsigned int v155 = *(_DWORD *)(v154 + 16);
    BOOL v156 = v155 >= (unsigned __int16)v10;
    int v157 = v155 < (unsigned __int16)v10;
    if (!v156) {
      *(_DWORD *)(v154 + 16) = (unsigned __int16)v10;
    }
    if (*(_DWORD *)(v154 + 20) < v230)
    {
      *(_DWORD *)(v154 + 20) = v230;
      int v157 = 1;
    }

    if (BYTE10(v237))
    {
      if ((((a1[50] & 0x80) == 0) & ~v157) != 0) {
        goto LABEL_375;
      }
    }

    else
    {
      int v162 = (unint64_t *)(v154 + 24);
      do
        unint64_t v163 = __ldxr(v162);
      while (__stxr(v163 + 1, v162));
    }

    sub_10003E644((uint64_t)a1, a7, 0LL);
LABEL_375:
    if (!v221 || WORD4(v237) != 0)
    {
      uint64_t v20 = 0LL;
      goto LABEL_445;
    }

    if (v45)
    {
      uint64_t v164 = sub_1000209D8((uint64_t)v45, (unsigned __int16)v215, a3, (unsigned __int16)v10, 0LL, 0, a7);
      uint64_t v20 = v164;
      if ((_DWORD)v164)
      {
        uint64_t v165 = a1[1];
        if (v165) {
          unsigned int v166 = (const char *)(v165 + 3992);
        }
        else {
          unsigned int v166 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_insert", 3966, v166, v164);
      }

      int v171 = v220;
      if (v45 != a1) {
        int v171 = 1;
      }
      if (v45 != (void *)v239 && v45 != (void *)v238 && v171)
      {
        sub_10003D514((uint64_t)v45, 2);
        sub_100038824(v45);
      }
    }

    else
    {
      uint64_t v20 = 0LL;
    }

    uint64_t v172 = v235;
    uint64_t v173 = v235 + 56;
    if (*(unsigned __int16 *)(*(void *)(v235 + 56) + 34LL) < 2u)
    {
LABEL_438:
      int v192 = v220;
      if ((void *)v172 != a1) {
        int v192 = 1;
      }
      if (v172 != (void)v239 && v172 != (void)v238 && v192)
      {
        sub_10003D514(v172, 2);
        sub_100038824(v172);
      }

      unsigned __int8 v45 = 0LL;
      uint64_t v235 = 0LL;
      goto LABEL_445;
    }

    size_t v174 = v231;
    while (1)
    {
      unsigned __int16 v226 = -21846;
      LOBYTE(v224) = -86;
      uint64_t v175 = sub_100021744(v172, a3, v174, &v226, (BOOL *)&v224);
      if ((_DWORD)v175)
      {
        uint64_t v20 = v175;
        goto LABEL_56;
      }

      int v176 = v224;
      int v177 = v226;
      if ((_BYTE)v224) {
        BOOL v178 = 0;
      }
      else {
        BOOL v178 = v226 == 0;
      }
      if (!v178)
      {
        uint64_t v186 = a1[1];
        if (v186) {
          uint64_t v187 = (const char *)(v186 + 3992);
        }
        else {
          uint64_t v187 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
        }
        uint64_t v190 = sub_10003965C(v172);
        int v191 = sub_1000398B8(v172);
        sub_100013D94( "%s:%d: %s minkey update traversal unexpectedly found the key (%d) or a non-zero index (%d); oid %llu subtype 0x%x level %d\n",
          "bt_insert",
          3984,
          v187,
          v176,
          v177,
          v190,
          v191,
          *(unsigned __int16 *)(*(void *)v173 + 34LL));
LABEL_437:
        uint64_t v20 = 0LL;
        goto LABEL_438;
      }

      uint64_t v179 = sub_1000209D8(v172, 0, a3, v174, 0LL, 0, a7);
      uint64_t v20 = v179;
      if ((_DWORD)v179)
      {
        uint64_t v180 = a1[1];
        if (v180) {
          unint64_t v181 = (const char *)(v180 + 3992);
        }
        else {
          unint64_t v181 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_insert", 3989, v181, v179);
      }

      int v182 = *(unsigned __int16 *)(*(void *)v173 + 34LL);
      if (v182 == 2) {
        goto LABEL_438;
      }
      uint64_t v20 = sub_10001E938(v172, 0, v16);
      uint64_t v235 = 0LL;
      if (!(_DWORD)v20) {
        uint64_t v20 = sub_10001E24C(a1, v16, v223, 3, (unsigned __int16)v182 - 1, a7, &v235);
      }
      int v183 = v220;
      if ((void *)v172 != a1) {
        int v183 = 1;
      }
      if (v172 != (void)v239 && v172 != (void)v238 && v183)
      {
        sub_10003D514(v172, 2);
        sub_100038824(v172);
      }

      uint64_t v172 = v235;
      if ((_DWORD)v20) {
        break;
      }
      uint64_t v173 = v235 + 56;
    }

    if (v235) {
      goto LABEL_438;
    }
LABEL_56:
    unsigned __int8 v45 = 0LL;
    goto LABEL_445;
  }

  uint64_t v235 = v237;
  uint64_t v51 = v237;
LABEL_61:
  int v215 = 0;
  unsigned __int8 v45 = 0LL;
  BOOL v221 = v50 == 0;
  __int16 v209 = &v239;
  uint64_t v208 = &v238;
  uint64_t v203 = (_WORD *)&v238 + 4;
  uint64_t v201 = (_WORD *)&v239 + 4;
  uint64_t v202 = (BOOL *)&v238 + 10;
  unint64_t v200 = (BOOL *)&v239 + 10;
  int v211 = (void *)v51;
  uint64_t v212 = v51;
  uint64_t v213 = (void *)v51;
  uint64_t v217 = (void *)v51;
  uint64_t v214 = v51;
  uint64_t v52 = v51;
  while (2)
  {
    uint64_t v53 = v239;
    int v54 = v220;
    if ((void *)v239 != a1) {
      int v54 = 1;
    }
    if ((void)v239) {
      BOOL v55 = v54 == 0;
    }
    else {
      BOOL v55 = 1;
    }
    BOOL v56 = v55 || (void)v239 == (void)v45;
    uint64_t v216 = v52;
    if (!v56 && (void)v239 != v52)
    {
      sub_10003D514(v239, 2);
      sub_100038824(v53);
    }

    BOOL v58 = v208;
    *__int16 v209 = *v208;
    *BOOL v58 = v237;
    *(void *)&__int128 v237 = 0LL;
    uint64_t v59 = sub_10001E938(v238, WORD4(v238), v16);
    if ((_DWORD)v59)
    {
LABEL_293:
      uint64_t v20 = v59;
      goto LABEL_445;
    }

    __int16 v60 = *(_WORD *)(*(void *)(v238 + 56) + 34LL) - 1;
    uint64_t v61 = a1;
    uint64_t v62 = v16;
    for (uint64_t i = v223; ; uint64_t i = v74)
    {
      uint64_t v59 = sub_10001E24C(v61, v62, i, 3, v60, a7, &v237);
      if ((_DWORD)v59) {
        goto LABEL_293;
      }
      uint64_t v64 = v237;
      if ((a1[50] & 0x10) != 0 && *(void *)(v237 + 112) != *v16)
      {
        sub_100021784(v238, WORD4(v238), (unint64_t *)(v237 + 112), a7);
        uint64_t v64 = v237;
      }

      if ((*(_WORD *)(*(void *)(v64 + 56) + 32LL) & 2) != 0) {
        uint64_t v65 = sub_10002080C(v64, a3, v231, v219, v218);
      }
      else {
        uint64_t v65 = sub_100021744(v64, a3, v231, v219, v218);
      }
      uint64_t v20 = v65;
      if ((_DWORD)v65) {
        goto LABEL_445;
      }
      uint64_t v66 = v237;
      if (!v49)
      {
        LODWORD(v222) = 0;
        uint64_t v68 = *(void *)(v237 + 56);
        int v67 = WORD4(v237);
        if ((*(_WORD *)(v68 + 32) & 2) == 0) {
          goto LABEL_120;
        }
        goto LABEL_94;
      }

      int v67 = WORD4(v237);
      uint64_t v68 = *(void *)(v237 + 56);
      unsigned int v69 = *(unsigned __int16 *)(v68 + 32);
      if (((v69 >> 1) & 1) + *(_DWORD *)(v68 + 36) - 1 == WORD4(v237)) {
        break;
      }
      LODWORD(v222) = 0;
      if ((v69 & 2) == 0) {
        goto LABEL_120;
      }
LABEL_94:
      if (*(_DWORD *)(v68 + 36) != v67
        || (v70 = WORD4(v238), uint64_t v71 = v238, *(_DWORD *)(*(void *)(v238 + 56) + 36LL) - 1 <= WORD4(v238))
        || sub_100021854(v66, 1u, (__int16 *)&v231, (__int16 *)&v230, 0, 0, 0LL))
      {
        BOOL v77 = v67 != 0;
        if (v221 || v77 || BYTE10(v237)) {
          goto LABEL_123;
        }
LABEL_140:
        BOOL v221 = 0;
        goto LABEL_141;
      }

      uint64_t v59 = sub_10001E938(v71, (unsigned __int16)(v70 + 1), v16);
      if ((_DWORD)v59) {
        goto LABEL_293;
      }
      uint64_t v72 = v237;
      sub_10003D514(v237, 2);
      sub_100038824(v72);
      *(void *)&__int128 v237 = 0LL;
      int v73 = WORD4(v238);
      ++WORD4(v238);
      if (v221 && v73 == 0)
      {
        uint64_t v74 = v223;
        LOBYTE(v49) = (_BYTE)v222;
        if (v45)
        {
          int v75 = v220;
          if (v45 != a1) {
            int v75 = 1;
          }
          if (v45 != (void *)v239 && v45 != (void *)v238 && v75)
          {
            sub_10003D514((uint64_t)v45, 2);
            sub_100038824(v45);
            int v211 = (void *)v235;
            uint64_t v212 = v235;
            uint64_t v213 = (void *)v235;
            uint64_t v214 = v235;
            uint64_t v217 = (void *)v235;
          }
        }

        unsigned __int8 v45 = v217;
        if (v217)
        {
          int v76 = v220;
          if (v217 != a1) {
            int v76 = 1;
          }
          if (v217 != (void *)v239 && v217 != (void *)v238 && v76)
          {
            sub_10003D514((uint64_t)v217, 2);
            sub_100038824(v45);
          }

          uint64_t v214 = 0LL;
          int v211 = 0LL;
          uint64_t v212 = 0LL;
          uint64_t v213 = 0LL;
          uint64_t v216 = 0LL;
          uint64_t v217 = 0LL;
          unsigned __int8 v45 = 0LL;
          int v215 = 0;
          BOOL v221 = 0;
          uint64_t v235 = 0LL;
        }

        else
        {
          uint64_t v216 = 0LL;
          uint64_t v217 = 0LL;
          int v215 = 0;
          BOOL v221 = 0;
        }
      }

      else
      {
        uint64_t v74 = v223;
        LOBYTE(v49) = (_BYTE)v222;
      }

      __int16 v60 = *(_WORD *)(*(void *)(v238 + 56) + 34LL) - 1;
      uint64_t v61 = a1;
      uint64_t v62 = v16;
    }

    if (a1[54] == *(void *)(v238 + 112)) {
      a1[54] = *(void *)(v237 + 112);
    }
    LODWORD(v222) = 1;
    if ((v69 & 2) != 0) {
      goto LABEL_94;
    }
LABEL_120:
    BOOL v77 = v67 != 0;
    if (!v221 && !v77 && !BYTE10(v237))
    {
      unsigned __int8 v45 = (void *)v238;
      BOOL v221 = 1;
      uint64_t v214 = v66;
      int v211 = (void *)v66;
      int v215 = WORD4(v238);
      uint64_t v212 = v66;
      uint64_t v213 = (void *)v66;
      uint64_t v235 = v66;
      uint64_t v216 = v66;
      uint64_t v217 = (void *)v66;
      goto LABEL_141;
    }

LABEL_123:
    if (!v221 || !v77) {
      goto LABEL_141;
    }
    if (v45)
    {
      int v78 = v220;
      if (v45 != a1) {
        int v78 = 1;
      }
      if (v45 != (void *)v239 && v45 != (void *)v238 && v78)
      {
        sub_10003D514((uint64_t)v45, 2);
        sub_100038824(v45);
        int v211 = (void *)v235;
        uint64_t v212 = v235;
        uint64_t v214 = v235;
        uint64_t v213 = (void *)v235;
      }
    }

    uint64_t v79 = (uint64_t)v213;
    if (!v213)
    {
      uint64_t v213 = 0LL;
      uint64_t v216 = 0LL;
      uint64_t v217 = 0LL;
      unsigned __int8 v45 = 0LL;
      int v215 = 0;
      goto LABEL_140;
    }

    int v80 = v220;
    if (v213 != a1) {
      int v80 = 1;
    }
    if (v213 != (void *)v239 && v213 != (void *)v238 && v80)
    {
      sub_10003D514((uint64_t)v213, 2);
      sub_100038824(v79);
    }

    uint64_t v214 = 0LL;
    int v211 = 0LL;
    uint64_t v212 = 0LL;
    uint64_t v213 = 0LL;
    uint64_t v216 = 0LL;
    uint64_t v217 = 0LL;
    unsigned __int8 v45 = 0LL;
    int v215 = 0;
    BOOL v221 = 0;
    uint64_t v235 = 0LL;
LABEL_141:
    unsigned int v81 = sub_1000219F0(v237);
    int v82 = 0;
    if (WORD4(v237))
    {
      char v83 = 0;
    }

    else
    {
      char v83 = 0;
      if (!BYTE10(v237))
      {
        uint64_t v59 = sub_10001E654(v238, WORD4(v238), &v234, &v232);
        if ((_DWORD)v59) {
          goto LABEL_293;
        }
        uint64_t v84 = a1[1];
        if (!v84) {
          uint64_t v84 = *(void *)(*a1 + 392LL);
        }
        unsigned int v85 = v231;
        uint64_t v59 = ((uint64_t (*)(uint64_t, unint64_t *, void, unint64_t, void, int *))a1[52])( v84,  a3,  v231,  v234,  v232,  &v233);
        if ((_DWORD)v59) {
          goto LABEL_293;
        }
        if (v233 < 0)
        {
          uint64_t v86 = *(void *)(v237 + 400);
          if ((v86 & 0x40) != 0) {
            unsigned int v87 = v85;
          }
          else {
            unsigned int v87 = (v85 + 7) & 0x1FFF8;
          }
          if ((v86 & 0x40) != 0) {
            unsigned int v88 = v232;
          }
          else {
            unsigned int v88 = (v232 + 7) & 0x1FFF8;
          }
          if (v87 <= v88)
          {
            int v82 = 0;
          }

          else
          {
            if ((v86 & 0x40) != 0) {
              int v89 = v85;
            }
            else {
              int v89 = (v85 + 7) & 0x1FFF8;
            }
            if ((*(void *)(v237 + 400) & 0x40LL) != 0) {
              int v90 = v232;
            }
            else {
              int v90 = (v232 + 7) & 0x1FFF8;
            }
            int v82 = v89 - v90;
          }

          char v83 = 1;
        }

        else
        {
          int v82 = 0;
          char v83 = 0;
        }
      }
    }

    unsigned int v91 = *(unsigned __int16 *)(*(void *)(v238 + 56) + 34LL);
    if (v91 < 2)
    {
      LOWORD(v229) = v81;
      unint64_t v93 = *(void *)(v238 + 400);
      LOWORD(v94) = (BYTE6(v93) & 0x7F) + 8;
      LOWORD(v228) = v94;
      if ((v83 & 1) == 0)
      {
        unsigned __int16 v92 = v231;
        goto LABEL_174;
      }

      goto LABEL_172;
    }

    unsigned __int16 v92 = v231;
    if (v81 > v231) {
      unsigned __int16 v92 = v81;
    }
    LOWORD(v229) = v92;
    unint64_t v93 = *(void *)(v238 + 400);
    int v94 = (HIWORD(v93) & 0x7F) + 8;
    LOWORD(v228) = (BYTE6(v93) & 0x7F) + 8;
    if ((v83 & 1) != 0)
    {
LABEL_172:
      unsigned int v95 = 1;
      goto LABEL_175;
    }

LABEL_174:
    HIWORD(v229) = v92;
    HIWORD(v228) = v94;
    unsigned int v95 = 2;
LABEL_175:
    unsigned int v207 = v82;
    int v206 = (void *)v238;
    LODWORD(v204) = v95;
    LODWORD(v205) = (__int16)v82;
    if (sub_100021854(v238, v95, (__int16 *)&v229, (__int16 *)&v228, v82, 0, 0LL))
    {
LABEL_176:
      BOOL v49 = (int)v222;
      uint64_t v52 = v216;
      goto LABEL_177;
    }

    if (v91 < 2)
    {
      uint64_t v97 = v237;
      if (BYTE10(v237))
      {
        if ((*(_WORD *)(*(void *)(v237 + 56) + 32LL) & 4) != 0)
        {
          uint64_t v99 = *(void *)(v237 + 400);
          unsigned int v98 = (v99 >> 9) & 0x3FFF;
        }

        else
        {
          unsigned int v98 = *(unsigned __int16 *)(*(void *)(v237 + 376) + 8LL * WORD4(v237) + 2);
          uint64_t v99 = *(void *)(v237 + 400);
        }

        unsigned __int16 v232 = v98;
        unsigned int v103 = sub_10001E5DC(v237, WORD4(v237));
        if (v103 == 65534) {
          unsigned int v104 = 0;
        }
        else {
          unsigned int v104 = v103;
        }
        unsigned int v105 = v231;
        if ((v99 & 0x40) == 0) {
          unsigned int v105 = (v231 + 7) & 0x1FFF8;
        }
        unsigned int v106 = (v98 + 7) & 0x1FFF8;
        if ((v99 & 0x40) != 0) {
          unsigned int v106 = v98;
        }
        unsigned int v107 = v230;
        if ((v99 & 0x40) == 0) {
          unsigned int v107 = (v230 + 7) & 0x1FFF8;
        }
        unsigned int v108 = (v104 + 7) & 0x1FFF8;
        if ((v99 & 0x40) != 0) {
          unsigned int v108 = v104;
        }
        __int16 v109 = v105 - v106;
        if (v105 < v106) {
          __int16 v109 = 0;
        }
        __int16 v110 = v107 - v108;
        if (v107 < v108) {
          __int16 v110 = 0;
        }
        uint64_t v101 = v223;
      }

      else
      {
        BOOL v102 = sub_100021854(v237, 1u, (__int16 *)&v231, (__int16 *)&v230, 0, 0, 0LL);
        uint64_t v101 = v223;
        if (!v102) {
          goto LABEL_210;
        }
      }
    }

    else
    {
      __int16 v227 = -21846;
      __int16 v225 = -21846;
      unsigned __int16 v226 = v210;
      __int16 v224 = (BYTE6(v93) & 0x7F) + 8;
      if ((v83 & 1) != 0)
      {
        unsigned int v96 = 1;
      }

      else
      {
        __int16 v227 = v210;
        __int16 v225 = (BYTE6(v93) & 0x7F) + 8;
        unsigned int v96 = 2;
      }

      BOOL v100 = sub_100021854(v237, v96, (__int16 *)&v226, &v224, v205, 0, 0LL);
      uint64_t v101 = v223;
      if (v100) {
        goto LABEL_176;
      }
    }

LABEL_210:
    unsigned __int16 v111 = WORD4(v238);
    if (!BYTE10(v238)) {
      unsigned __int16 v111 = WORD4(v238) + 1;
    }
    unsigned __int16 v199 = v207;
    unsigned int v207 = v231;
    uint64_t v112 = sub_100021A68( a1,  (void *)v239,  WORD4(v239),  v206,  v111,  a3,  v231,  v204,  (__int16 *)&v229,  (__int16 *)&v228,  v199,  v101,  a7,  (uint64_t *)&v236);
    if ((_DWORD)v112)
    {
      uint64_t v20 = v112;
      uint64_t v184 = a1[1];
      if (v184) {
        unint64_t v185 = (const char *)(v184 + 3992);
      }
      else {
        unint64_t v185 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s bt_shift_or_split failed with error: %d\n", "bt_insert", 3676, v185, v112);
      goto LABEL_445;
    }

    uint64_t v113 = (uint64_t)v236;
    BOOL v49 = (int)v222;
    uint64_t v52 = v216;
    if (!v236) {
      goto LABEL_177;
    }
    uint64_t v114 = v238;
    int v206 = (void *)v238;
    if ((void)v239)
    {
      ++WORD4(v239);
      if ((void)v238)
      {
        int v115 = v220;
        if ((void *)v238 != a1) {
          int v115 = 1;
        }
        if (v115 == 1)
        {
          if (v45 == (void *)v238)
          {
            uint64_t v116 = v212;
          }

          else
          {
            uint64_t v116 = v212;
            if ((void)v238 != v212)
            {
              uint64_t v204 = (uint64_t)v236;
              uint64_t v117 = v212;
              sub_10003D514(v238, 2);
              sub_100038824(v114);
              uint64_t v205 = 0LL;
              uint64_t v213 = (void *)v117;
              uint64_t v216 = v117;
              uint64_t v217 = (void *)v117;
              uint64_t v113 = v204;
              goto LABEL_231;
            }
          }

          uint64_t v213 = (void *)v116;
          uint64_t v216 = v116;
          uint64_t v217 = (void *)v116;
        }

        uint64_t v205 = v238;
LABEL_231:
        BOOL v121 = v45 != (void *)v239 || v45 == 0LL;
        int v122 = v215;
        if (!v121) {
          int v122 = WORD4(v239);
        }
        int v215 = v122;
        *(void *)&__int128 v238 = v113;
        uint64_t v236 = 0LL;
        uint64_t v59 = sub_100021744(v113, a3, v207, v203, v202);
        if ((_DWORD)v59) {
          goto LABEL_293;
        }
        uint64_t v123 = v237;
        sub_10003D514(v237, 2);
        sub_100038824(v123);
        *(void *)&__int128 v237 = 0LL;
        uint64_t v59 = sub_10001E938(v238, WORD4(v238), v16);
        if ((_DWORD)v59) {
          goto LABEL_293;
        }
        uint64_t v59 = sub_10001E24C(a1, v16, v223, 3, *(_WORD *)(*(void *)(v238 + 56) + 34LL) - 1, a7, &v237);
        if ((_DWORD)v59) {
          goto LABEL_293;
        }
        uint64_t v124 = v237;
        if ((a1[50] & 0x10) != 0 && *(void *)(v237 + 112) != *v16)
        {
          sub_100021784(v238, WORD4(v238), (unint64_t *)(v237 + 112), a7);
          uint64_t v124 = v237;
        }

        if ((*(_WORD *)(*(void *)(v124 + 56) + 32LL) & 2) != 0) {
          uint64_t v125 = sub_10002080C(v124, a3, v207, v219, v218);
        }
        else {
          uint64_t v125 = sub_100021744(v124, a3, v207, v219, v218);
        }
        uint64_t v20 = v125;
        uint64_t v52 = v216;
        if ((_DWORD)v125) {
          goto LABEL_445;
        }
        if (v45 != v206)
        {
          uint64_t v126 = v205;
          if (!v221)
          {
            LODWORD(v128) = v215;
            goto LABEL_268;
          }

          if (WORD4(v238) | WORD4(v237))
          {
            if (v45)
            {
              int v127 = v220;
              if (v45 != a1) {
                int v127 = 1;
              }
              if (v45 != (void *)v239 && v45 != (void *)v238 && v127)
              {
                sub_10003D514((uint64_t)v45, 2);
                sub_100038824(v45);
                uint64_t v214 = v235;
                int v211 = (void *)v235;
              }
            }

            uint64_t v128 = (uint64_t)v211;
            if (v211)
            {
              int v129 = v220;
              if (v211 != a1) {
                int v129 = 1;
              }
              if (v211 != (void *)v239 && v211 != (void *)v238 && v129)
              {
                sub_10003D514((uint64_t)v211, 2);
                sub_100038824(v128);
              }

              uint64_t v214 = 0LL;
              int v211 = 0LL;
              uint64_t v212 = 0LL;
              uint64_t v213 = 0LL;
              uint64_t v217 = 0LL;
              uint64_t v52 = 0LL;
              unsigned __int8 v45 = 0LL;
              LODWORD(v128) = 0;
              uint64_t v235 = 0LL;
            }

            else
            {
              int v211 = 0LL;
              uint64_t v212 = 0LL;
              uint64_t v213 = 0LL;
              uint64_t v217 = 0LL;
              uint64_t v52 = 0LL;
              unsigned __int8 v45 = 0LL;
            }

  int v78 = v35;
  uint64_t v113 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
  uint64_t v79 = v121;
  sub_100037014((pthread_mutex_t *)a1, v121);
  BOOL v121 = 0;
  int v80 = a6;
  if (!a6) {
    int v80 = *(void *)(a1 + 392);
  }
  uint64_t v19 = sub_100041760(v80, a3, v11, 0LL, 0LL, 0LL, &v124);
  if (!(_DWORD)v19)
  {
    sub_100036FD4((pthread_mutex_t *)a1, v79);
    BOOL v121 = v79;
LABEL_214:
    uint64_t v33 = v113;
    goto LABEL_188;
  }

  unsigned int v87 = v126;
  if (v126)
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    unsigned int v107 = 0LL;
    BOOL v121 = 2;
    LOBYTE(v33) = v113;
    int v34 = v78;
LABEL_252:
    --*(_DWORD *)(a1 + 684);
    unsigned int v88 = v87;
    int v89 = v33;
    sub_10003CCD4(v88, 1);
    LOBYTE(v33) = v89;
  }

  else
  {
    unsigned int v107 = 0LL;
    LOBYTE(v33) = v113;
    int v34 = v78;
  }

LABEL_268:
            if (WORD4(v237))
            {
LABEL_269:
              BOOL v221 = 0;
              goto LABEL_282;
            }

            if (!WORD4(v238) && !BYTE10(v238))
            {
              unsigned __int8 v45 = (void *)v239;
              uint64_t v130 = v238;
              BOOL v221 = 1;
              goto LABEL_280;
            }

            if (BYTE10(v237) || (*(_WORD *)(*(void *)(v237 + 56) + 32LL) & 2) != 0) {
              goto LABEL_269;
            }
            unsigned __int8 v45 = (void *)v238;
            BOOL v221 = 1;
            uint64_t v214 = v237;
            int v211 = (void *)v237;
            uint64_t v212 = v237;
            uint64_t v235 = v237;
            uint64_t v213 = (void *)v237;
            uint64_t v217 = (void *)v237;
            uint64_t v52 = v237;
            LODWORD(v128) = WORD4(v238);
          }

          else
          {
            BOOL v221 = 1;
            LODWORD(v128) = v215;
          }

          goto LABEL_282;
        }

        LODWORD(v128) = WORD4(v238);
        uint64_t v126 = v205;
        if (v45 == a1 && !WORD4(v238))
        {
          int v211 = (void *)v238;
          uint64_t v212 = v238;
          uint64_t v235 = v238;
          uint64_t v213 = (void *)v238;
          uint64_t v217 = (void *)v238;
          uint64_t v214 = v238;
          uint64_t v52 = v238;
          unsigned __int8 v45 = a1;
          goto LABEL_177;
        }

        if (WORD4(v238))
        {
          unsigned __int8 v45 = (void *)v238;
          uint64_t v130 = v237;
          int v211 = (void *)v237;
        }

        else
        {
          unsigned __int8 v45 = (void *)v239;
          uint64_t v130 = v238;
LABEL_280:
          int v211 = (void *)v130;
          LODWORD(v128) = WORD4(v239);
        }

        uint64_t v235 = v130;
        uint64_t v212 = v130;
        uint64_t v213 = (void *)v130;
        uint64_t v217 = (void *)v130;
        uint64_t v214 = v130;
        uint64_t v52 = v130;
LABEL_282:
        if (v126)
        {
          int v131 = v220;
          if ((void *)v126 != a1) {
            int v131 = 1;
          }
          if (v131 == 1 && (void *)v126 != v45)
          {
            uint64_t v132 = v214;
            if (v126 != v214)
            {
              sub_10003D514(v126, 2);
              sub_100038824(v126);
            }

            int v211 = (void *)v132;
            uint64_t v212 = v132;
            uint64_t v213 = (void *)v132;
            uint64_t v217 = (void *)v132;
            uint64_t v52 = v132;
            int v215 = v128;
            BOOL v49 = (int)v222;
LABEL_177:
            if ((*(_WORD *)(*(void *)(v237 + 56) + 32LL) & 2) == 0) {
              continue;
            }
            goto LABEL_295;
          }

          int v211 = (void *)v214;
          uint64_t v212 = v214;
          uint64_t v213 = (void *)v214;
          uint64_t v217 = (void *)v214;
          uint64_t v52 = v214;
        }

        int v215 = v128;
        goto LABEL_177;
      }

LABEL_227:
      uint64_t v205 = 0LL;
      goto LABEL_231;
    }

    break;
  }

  *(void *)&__int128 v239 = v238;
  if (*(_DWORD *)(v236[7] + 36LL))
  {
    uint64_t v59 = sub_10001E654((uint64_t)v236, 0, &v234, &v232);
    if ((_DWORD)v59) {
      goto LABEL_293;
    }
    uint64_t v118 = v239;
    int v119 = (unint64_t *)v234;
    uint64_t v120 = v232;
  }

  else
  {
    uint64_t v118 = v238;
    int v119 = a3;
    uint64_t v120 = v207;
  }

  uint64_t v20 = sub_100021744(v118, v119, v120, v201, v200);
  if (!(_DWORD)v20) {
    goto LABEL_227;
  }
LABEL_445:
  uint64_t v193 = v239;
  uint64_t v194 = v235;
  if ((void)v239 && (void *)v239 != v45 && (void)v239 != v235)
  {
    sub_10003D514(v239, 2);
    sub_100038824(v193);
  }

  uint64_t v195 = v238;
  if ((void)v238 && (void *)v238 != v45 && (void)v238 != v194)
  {
    sub_10003D514(v238, 2);
    sub_100038824(v195);
  }

  uint64_t v196 = v237;
  if ((void)v237 && (void *)v237 != v45 && (void)v237 != v194)
  {
    sub_10003D514(v237, 2);
    sub_100038824(v196);
  }

  if (v45)
  {
    sub_10003D514((uint64_t)v45, 2);
    sub_100038824(v45);
    uint64_t v194 = v235;
  }

  if (v194)
  {
    sub_10003D514(v194, 2);
    sub_100038824(v194);
  }

  uint64_t v197 = (uint64_t)v236;
  if (v236)
  {
    sub_10003D514((uint64_t)v236, 2);
    sub_100038824(v197);
  }

  char v198 = v220;
  if ((void *)v239 == a1) {
    char v198 = 1;
  }
  if ((void *)v194 != a1 && (v198 & 1) == 0 && (void *)v238 != a1 && (void *)v237 != a1 && v45 != a1)
  {
    sub_10003D514((uint64_t)a1, 2);
    sub_100038824(a1);
  }

  return v20;
}

  unsigned int v105 = v141;
  if (v141)
  {
    if (v141 != (void)v144 && v141 != (void)v143 && v141 != (void)v142)
    {
      sub_10003D514(v141, 2);
      sub_100038824(v105);
    }

    uint64_t v141 = 0LL;
  }

  if (!v80)
  {
    unsigned int v106 = 0LL;
    unsigned int v108 = 0;
    goto LABEL_240;
  }

  if (WORD4(v142) || !*(_DWORD *)(*(void *)(v142 + 56) + 36LL))
  {
    unsigned int v106 = 0LL;
    unsigned int v107 = 0;
    goto LABEL_236;
  }

  uint64_t v26 = sub_10001E654(v142, 0, &v140[2], &v136);
  if ((_DWORD)v26) {
    goto LABEL_10;
  }
  unsigned int v107 = v136;
  __int16 v110 = (unint64_t *)sub_100014044(v136);
  unsigned int v106 = v110;
  if (v110) {
    memcpy(v110, v140[2], v136);
  }
  int v24 = 0LL;
LABEL_236:
  if (v106)
  {
    unsigned int v108 = v107;
  }

  else
  {
    unsigned int v106 = v127;
    unsigned int v108 = v139;
  }

uint64_t sub_10002080C(uint64_t a1, unint64_t *a2, uint64_t a3, _WORD *a4, BOOL *a5)
{
  int v23 = -1431655766;
  int v10 = *(_DWORD *)(*(void *)(a1 + 56) + 36LL) - 1;
  unsigned __int16 v22 = -21846;
  if ((*(_BYTE *)(a1 + 400) & 1) == 0)
  {
    if ((v10 & 0x80000000) == 0)
    {
      int v11 = 0;
      char v25 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
      while (1)
      {
        int v12 = v10 + v11;
        if (v10 + v11 < 0 != __OFADD__(v10, v11)) {
          ++v12;
        }
        int v13 = v12 >> 1;
        uint64_t result = sub_10001E654(a1, (unsigned __int16)(v12 >> 1), &v25, &v22);
        if ((_DWORD)result) {
          return result;
        }
        uint64_t v15 = *(void *)(a1 + 8);
        if (!v15) {
          uint64_t v15 = *(void *)(*(void *)a1 + 392LL);
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, unint64_t *, void, int *))(a1 + 416))( v15,  a2,  a3,  v25,  v22,  &v23);
        if ((_DWORD)result) {
          return result;
        }
        BOOL v16 = v23 == 0;
        if (!v23)
        {
          LOWORD(v11) = v13;
          goto LABEL_38;
        }

        if (v23 < 0) {
          int v10 = v13 - 1;
        }
        else {
          int v11 = v13 + 1;
        }
        if (v11 > v10) {
          goto LABEL_38;
        }
      }
    }

    BOOL v16 = 0;
    LOWORD(v11) = 0;
LABEL_38:
    uint64_t result = 0LL;
    *a4 = v11;
LABEL_41:
    *a5 = v16;
    return result;
  }

  if ((_DWORD)a3 != 8) {
    return 22LL;
  }
  if (v10 < 0)
  {
    BOOL v16 = 0;
    LOWORD(v17) = 0;
LABEL_40:
    uint64_t result = 0LL;
    *a4 = v17;
    goto LABEL_41;
  }

  int v17 = 0;
  unint64_t v18 = *a2;
  char v25 = (unint64_t *)0xAAAAAAAAAAAAAAAALL;
  __int16 v24 = -21846;
  while (1)
  {
    int v19 = v17 + v10;
    if (v17 + v10 < 0 != __OFADD__(v17, v10)) {
      ++v19;
    }
    int v20 = v19 >> 1;
    LODWORD(va_start(va, result) = sub_10001E654(a1, (unsigned __int16)(v19 >> 1), &v25, &v24);
    BOOL v21 = v24 != 8 && (_DWORD)result == 0;
    uint64_t result = v21 ? 22LL : result;
    if ((_DWORD)result) {
      return result;
    }
    BOOL v16 = *v25 == v18;
    if (*v25 == v18)
    {
      LOWORD(v17) = v20;
      goto LABEL_40;
    }

    if (*v25 > v18) {
      int v10 = v20 - 1;
    }
    else {
      int v17 = v20 + 1;
    }
    if (v17 > v10) {
      goto LABEL_40;
    }
  }

uint64_t sub_1000209D8( uint64_t a1, unsigned int a2, void *__src, size_t __n, void *a5, unsigned int a6, uint64_t a7)
{
  unsigned int v8 = __n;
  __int16 v85 = -21846;
  __int16 v84 = -21846;
  unsigned __int16 v83 = -21846;
  unsigned __int16 v82 = -21846;
  uint64_t v12 = *(void *)(a1 + 56);
  __int16 v13 = *(_WORD *)(v12 + 32);
  if (a6 == 65534) {
    size_t v14 = 0LL;
  }
  else {
    size_t v14 = a6;
  }
  int v80 = a5;
  size_t v81 = v14;
  uint64_t v79 = __src;
  __int16 v77 = *(_WORD *)(v12 + 32);
  if (*(_DWORD *)(v12 + 36) <= a2)
  {
    int v21 = 0;
    __int16 v22 = 0;
    unsigned int v20 = 0;
    LOWORD(v23) = 0;
    __int16 v24 = 0;
    BOOL v75 = 0;
    unsigned int v17 = 0xFFFF;
    unsigned int v19 = 0xFFFF;
  }

  else
  {
    uint64_t v15 = *(void *)(a1 + 376);
    if ((v13 & 4) != 0) {
      BOOL v16 = (unsigned __int16 *)(v15 + 4LL * a2);
    }
    else {
      BOOL v16 = (unsigned __int16 *)(v15 + 8LL * a2);
    }
    unsigned int v17 = *v16;
    unint64_t v18 = (unsigned __int16 *)(v15 + 4LL * a2 + 2);
    if ((v13 & 4) == 0) {
      unint64_t v18 = (unsigned __int16 *)(v15 + 8LL * a2 + 4);
    }
    unsigned int v19 = *v18;
    if (v17 == 0xFFFF)
    {
      unsigned int v20 = 0;
    }

    else if ((v13 & 4) != 0)
    {
      unsigned int v20 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
    }

    else
    {
      unsigned int v20 = *(unsigned __int16 *)(v15 + 8LL * a2 + 2);
    }

    if (v19 > 0xFFFD) {
      unsigned int v23 = 0;
    }
    else {
      unsigned int v23 = sub_10001E5DC(a1, a2);
    }
    BOOL v75 = v20 != 0;
    if (v20)
    {
      uint64_t v25 = sub_10001E710(a1, v17, v20);
      if ((_DWORD)v25) {
        return v25;
      }
      __int16 v24 = v20;
    }

    else
    {
      __int16 v24 = 0;
    }

    a5 = v80;
    size_t v14 = v81;
    if (v23)
    {
      uint64_t v25 = sub_10001E838(a1, v19, v23);
      if ((_DWORD)v25) {
        return v25;
      }
      int v21 = 1;
      __int16 v22 = v23;
      a5 = v80;
      size_t v14 = v81;
    }

    else
    {
      int v21 = 0;
      __int16 v22 = 0;
    }

    __src = v79;
  }

  __int16 v85 = v17;
  __int16 v84 = v19;
  unsigned __int16 v26 = v8 - v20;
  if (!__src) {
    unsigned __int16 v26 = 0;
  }
  int v27 = (__int16)v26;
  unsigned __int16 v28 = v14 - v23;
  if (!a5) {
    unsigned __int16 v28 = 0;
  }
  int v29 = (__int16)v28;
  if (!(v26 | v28)) {
    goto LABEL_148;
  }
  if (__src)
  {
    if ((*(void *)(a1 + 400) & 0x40) != 0) {
      __int16 v30 = v8;
    }
    else {
      __int16 v30 = (v8 + 7) & 0xFFF8;
    }
    __int16 v31 = (v24 + 7) & 0xFFF8;
    if ((*(void *)(a1 + 400) & 0x40LL) != 0) {
      __int16 v31 = v24;
    }
    __int16 v32 = v30 - v31;
  }

  else
  {
    __int16 v32 = 0;
  }

  int v73 = v29;
  int v74 = v27;
  if (a5)
  {
    if ((*(void *)(a1 + 400) & 0x40) != 0) {
      __int16 v33 = v14;
    }
    else {
      __int16 v33 = (v14 + 7) & 0xFFF8;
    }
    if ((*(void *)(a1 + 400) & 0x40LL) == 0) {
      __int16 v22 = (v22 + 7) & 0xFFF8;
    }
    __int16 v34 = v33 - v22;
  }

  else
  {
    __int16 v34 = 0;
  }

  unsigned __int16 v35 = 0;
  unsigned __int16 v82 = -1;
  unsigned __int16 v83 = -1;
  if (!v8) {
    goto LABEL_55;
  }
  int v27 = v74;
  if (!v74) {
    goto LABEL_56;
  }
  sub_1000296EC(a1, 1, v8, (__int16 *)&v83, (unsigned __int16 *)&v85);
  if (v85 != -1)
  {
    unsigned __int16 v35 = 0;
LABEL_55:
    int v27 = v74;
    goto LABEL_56;
  }

  int v27 = v74;
  if (v74 < 0)
  {
    unsigned __int16 v35 = 0;
    __int16 v85 = v17;
    unsigned __int16 v83 = -1;
  }

  else if ((*(_BYTE *)(a1 + 400) & 0x40) != 0)
  {
    unsigned __int16 v35 = v8;
  }

  else
  {
    unsigned __int16 v35 = (v8 + 7) & 0xFFF8;
  }

LABEL_56:
  size_t v14 = v81;
  if (!(_DWORD)v81)
  {
    __src = v79;
    a5 = v80;
    int v29 = v73;
    goto LABEL_72;
  }

  int v29 = v73;
  if (!v73)
  {
    __src = v79;
    a5 = v80;
    goto LABEL_72;
  }

  unsigned __int16 v36 = v35;
  sub_1000296EC(a1, 2, v81, (__int16 *)&v82, (unsigned __int16 *)&v84);
  if (v84 == -1)
  {
    int v29 = v73;
    if (v73 < 0)
    {
      __int16 v84 = v19;
      unsigned __int16 v82 = -1;
      a5 = v80;
      size_t v14 = v81;
      __src = v79;
      goto LABEL_60;
    }

    a5 = v80;
    size_t v14 = v81;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      __int16 v38 = v81;
    }
    else {
      __int16 v38 = (v81 + 7) & 0xFFF8;
    }
    unsigned __int16 v35 = v38 + v36;
    __src = v79;
    int v27 = v74;
LABEL_72:
    BOOL v37 = v75;
    goto LABEL_73;
  }

  a5 = v80;
  size_t v14 = v81;
  __src = v79;
  int v29 = v73;
LABEL_60:
  int v27 = v74;
  BOOL v37 = v75;
  unsigned __int16 v35 = v36;
LABEL_73:
  uint64_t v39 = *(void *)(a1 + 56);
  unsigned int v40 = *(unsigned __int16 *)(v39 + 46);
  if (v27) {
    BOOL v41 = v37;
  }
  else {
    BOOL v41 = 0;
  }
  if (v41)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      __int16 v42 = v20;
    }
    else {
      __int16 v42 = (v20 + 7) & 0xFFF8;
    }
    unsigned __int16 v43 = (v42 + 7) & 0xFFF8;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v43 = v20;
    }
    if (v43 >= 4u)
    {
      uint64_t v44 = (_WORD *)(*(void *)(a1 + 384) + v17);
      v44[1] = v43;
      *uint64_t v44 = *(_WORD *)(v39 + 48);
      *(_WORD *)(v39 + 48) = v17;
    }

    *(_WORD *)(v39 + 50) += v43;
    if ((unsigned __int16)v85 != 0xFFFF
      && v83 == 0xFFFF
      && (unsigned __int16)v85 != v17
      && *(unsigned __int16 *)(v39 + 48) == v17)
    {
      unsigned __int16 v83 = v17;
    }
  }

  if (v29) {
    int v45 = v21;
  }
  else {
    int v45 = 0;
  }
  if (v45 == 1)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      __int16 v46 = v23;
    }
    else {
      __int16 v46 = (v23 + 7) & 0xFFF8;
    }
    unsigned __int16 v47 = (v46 + 7) & 0xFFF8;
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v47 = v23;
    }
    if (v47 >= 4u)
    {
      __int16 v48 = (_WORD *)(*(void *)(a1 + 392) - v19);
      v48[1] = v47;
      *__int16 v48 = *(_WORD *)(v39 + 52);
      *(_WORD *)(v39 + 52) = v19;
    }

    *(_WORD *)(v39 + 54) += v47;
    if ((unsigned __int16)v84 != 0xFFFF
      && v82 == 0xFFFF
      && (unsigned __int16)v84 != v19
      && *(unsigned __int16 *)(v39 + 52) == v19)
    {
      unsigned __int16 v82 = v19;
    }
  }

  if (v40 < v35)
  {
    if ((v77 & 0x8000) == 0) {
      *(_WORD *)(v39 + 32) |= 0x8000u;
    }
    if (*(_DWORD *)(v39 + 36) > a2)
    {
      __int16 v49 = *(_WORD *)(v39 + 32);
      uint64_t v50 = *(void *)(a1 + 376);
      if ((v49 & 4) != 0)
      {
        if (v41) {
          *(_WORD *)(v50 + 4LL * a2) = -1;
        }
        if (v45) {
          *(_WORD *)(v50 + 4LL * a2 + 2) = -1;
        }
      }

      else
      {
        if (v41) {
          *(_DWORD *)(v50 + 8LL * a2) = 0xFFFF;
        }
        if (v45) {
          *(_DWORD *)(v50 + 8LL * a2 + 4) = 0xFFFF;
        }
      }
    }

    int v76 = v45;
    uint64_t v51 = sub_100029908(a1, 0, a7);
    if ((_DWORD)v51)
    {
      uint64_t v25 = v51;
      if (v41)
      {
        unsigned __int16 v52 = (*(void *)(a1 + 400) & 0x40LL) != 0 ? v8 : (v8 + 7) & 0xFFF8;
        int v53 = sub_100029CFC(a1, 1, v52, 0xFFFF, v17);
        if (v53)
        {
          uint64_t v54 = *(void *)(a1 + 8);
          if (v54) {
            BOOL v55 = (const char *)(v54 + 3992);
          }
          else {
            BOOL v55 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
          }
          sub_100013D94( "%s:%d: %s unable to reclaim just-freed key space on error path: %d\n",  "btree_node_entry_update",  1769,  v55,  v53);
        }
      }

      if (v76)
      {
        if ((*(void *)(a1 + 400) & 0x40LL) != 0) {
          unsigned __int16 v72 = v23;
        }
        else {
          unsigned __int16 v72 = (v23 + 7) & 0xFFF8;
        }
      }

      return v25;
    }

    unsigned __int16 v82 = -1;
    unsigned __int16 v83 = -1;
    __int16 v85 = -1;
    __int16 v84 = -1;
    a5 = v80;
    size_t v14 = v81;
    __src = v79;
    int v29 = v73;
    int v27 = v74;
  }

  if (v27)
  {
    else {
      uint64_t v56 = sub_100029CFC(a1, 1, v8, v83, (unsigned __int16)v85);
    }
    uint64_t v25 = v56;
    a5 = v80;
    size_t v14 = v81;
    __src = v79;
    int v29 = v73;
    int v27 = v74;
    if ((_DWORD)v56) {
      goto LABEL_189;
    }
  }

  else
  {
    uint64_t v57 = *(void *)(a1 + 376);
    BOOL v58 = (unsigned __int16 *)(v57 + 4LL * a2);
    uint64_t v59 = (unsigned __int16 *)(v57 + 8LL * a2);
    if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 4) != 0) {
      __int16 v60 = v58;
    }
    else {
      __int16 v60 = v59;
    }
    __int16 v85 = *v60;
  }

  if (v29)
  {
    if ((_DWORD)v14)
    {
      else {
        uint64_t v61 = sub_100029CFC(a1, 2, v14, v82, (unsigned __int16)v84);
      }
      uint64_t v25 = v61;
      __src = v79;
      a5 = v80;
      int v29 = v73;
      int v27 = v74;
      if (!(_DWORD)v61)
      {
        LOWORD(v19) = v84;
        size_t v14 = v81;
        goto LABEL_148;
      }

LABEL_189:
      sub_100013D94("%s:%d: %s unable allocate space that should be there: %d\n");
      return v25;
    }

    if (a6 == 65534) {
      LOWORD(v19) = -2;
    }
    else {
      LOWORD(v19) = -1;
    }
  }

  else
  {
    uint64_t v62 = *(void *)(a1 + 376);
    uint64_t v63 = v62 + 4LL * a2 + 2;
    uint64_t v64 = v62 + 8LL * a2 + 4;
    if ((*(_WORD *)(*(void *)(a1 + 56) + 32LL) & 4) != 0) {
      uint64_t v65 = (_WORD *)v63;
    }
    else {
      uint64_t v65 = (_WORD *)v64;
    }
    LOWORD(v19) = *v65;
  }

  __int16 v84 = v19;
LABEL_148:
  if (a6 == 65534 && (unsigned __int16)v19 != 65534)
  {
    LOWORD(v19) = -2;
    __int16 v84 = -2;
    int v29 = 1;
  }

  uint64_t v66 = *(void *)(a1 + 56);
  uint64_t v67 = *(void *)(a1 + 376);
  if ((*(_WORD *)(v66 + 32) & 4) != 0)
  {
    if (v27) {
      *(_WORD *)(v67 + 4LL * a2) = v85;
    }
    if (v29) {
      *(_WORD *)(v67 + 4LL * a2 + 2) = v19;
    }
  }

  else
  {
    uint64_t v68 = (__int16 *)(v67 + 8LL * a2);
    if (v27)
    {
      *uint64_t v68 = v85;
      v68[1] = v8;
    }

    if (v29)
    {
      v68[2] = v19;
      v68[3] = a6;
    }
  }

  if ((v77 & 0x8000) == 0) {
    *(_WORD *)(v66 + 32) &= ~0x8000u;
  }
  unsigned int v69 = *(unsigned __int16 *)(a1 + 440);
  if (!*(_WORD *)(a1 + 440) || (__int16 v70 = v8, v69 >= v8))
  {
    if (v8 >= v20 || v69 > v20) {
      goto LABEL_168;
    }
    __int16 v70 = 0;
  }

  *(_WORD *)(a1 + 440) = v70;
LABEL_168:
  if (__src && v8)
  {
    memcpy((void *)(*(void *)(a1 + 384) + (unsigned __int16)v85), __src, v8);
    a5 = v80;
    size_t v14 = v81;
  }

  if (a5 && (_DWORD)v14) {
    memcpy((void *)(*(void *)(a1 + 392) - (unsigned __int16)v84), a5, v14);
  }
  sub_10003E644(a1, a7, 0LL);
  return 0LL;
}

uint64_t sub_1000212D0( uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, const void *a5, unsigned int a6, uint64_t a7)
{
  __int16 v48 = a4;
  if (a6 == 65534) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = a6;
  }
  __int16 v42 = v11;
  if (a3)
  {
    unsigned int v12 = a4;
    if (a4) {
      __int16 v13 = a3;
    }
    else {
      __int16 v13 = 0LL;
    }
    if (a5) {
      goto LABEL_9;
    }
LABEL_13:
    unsigned int v11 = 0;
    size_t v14 = 0LL;
    __int16 v42 = 0;
    goto LABEL_14;
  }

  unsigned int v12 = 0;
  __int16 v13 = 0LL;
  __int16 v48 = 0;
  if (!a5) {
    goto LABEL_13;
  }
LABEL_9:
  if (v11) {
    size_t v14 = a5;
  }
  else {
    size_t v14 = 0LL;
  }
LABEL_14:
  unsigned __int16 v47 = -21846;
  unsigned __int16 v46 = -21846;
  __int16 v45 = -21846;
  unsigned __int16 v44 = -21846;
  __int16 v43 = -21846;
  if (!sub_100021854(a1, 1u, &v48, &v42, 0, 0, &v47)) {
    return 28LL;
  }
  __int16 v43 = -1;
  unsigned __int16 v44 = -1;
  __int16 v45 = -1;
  unsigned __int16 v46 = -1;
  if (v13) {
    sub_1000296EC(a1, 1, v12, (__int16 *)&v46, (unsigned __int16 *)&v45);
  }
  if (v14) {
    sub_1000296EC(a1, 2, v11, (__int16 *)&v44, (unsigned __int16 *)&v43);
  }
  if (v45 == -1)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v15 = v12;
    }
    else {
      unsigned __int16 v15 = (v12 + 7) & 0xFFF8;
    }
  }

  else
  {
    unsigned __int16 v15 = 0;
  }

  if (v43 == -1)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      __int16 v17 = v11;
    }
    else {
      __int16 v17 = (v11 + 7) & 0xFFF8;
    }
    v15 += v17;
  }

  unsigned int v18 = v47 + v15;
  uint64_t v19 = *(void *)(a1 + 56);
  if (v18 <= *(unsigned __int16 *)(v19 + 46))
  {
    if (v47)
    {
      memmove((void *)(*(void *)(a1 + 384) + v47), *(const void **)(a1 + 384), *(unsigned __int16 *)(v19 + 44));
      bzero(*(void **)(a1 + 384), v47);
      unsigned __int16 v20 = v47;
      *(void *)(a1 + 384) += v47;
      uint64_t v21 = *(void *)(a1 + 56);
      *(_WORD *)(v21 + 46) -= v20;
      *(_WORD *)(v21 + 42) += v20;
    }
  }

  else
  {
    uint64_t v16 = sub_100029908(a1, 1LL, a7);
    if ((_DWORD)v16) {
      return v16;
    }
    __int16 v43 = -1;
    __int16 v45 = -1;
    unsigned __int16 v47 = 0;
  }

  if (!v13)
  {
LABEL_38:
    if (!v14) {
      goto LABEL_62;
    }
    goto LABEL_39;
  }

  if ((unsigned __int16)v45 != 0xFFFF)
  {
    uint64_t v16 = sub_100029CFC(a1, 1, v12, v46, (unsigned __int16)v45);
    if (!(_DWORD)v16) {
      goto LABEL_38;
    }
LABEL_47:
    uint64_t v25 = *(void *)(a1 + 8);
    if (v25) {
      unsigned __int16 v26 = (const char *)(v25 + 3992);
    }
    else {
      unsigned __int16 v26 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94( "%s:%d: %s unable allocate space that should be there: %d\n",  "btree_node_insert_internal",  2190,  v26,  v16);
    return v16;
  }

  if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
    unsigned __int16 v22 = v12;
  }
  else {
    unsigned __int16 v22 = (v12 + 7) & 0xFFF8;
  }
  uint64_t v23 = *(void *)(a1 + 56);
  unsigned int v24 = *(unsigned __int16 *)(v23 + 46);
  if (v24 < v22)
  {
    uint64_t v16 = 28LL;
    goto LABEL_47;
  }

  __int16 v32 = *(_WORD *)(v23 + 44);
  *(_WORD *)(v23 + 44) = v32 + v22;
  *(_WORD *)(v23 + 46) = v24 - v22;
  __int16 v45 = v32;
  if (!v14) {
    goto LABEL_62;
  }
LABEL_39:
  if ((unsigned __int16)v43 != 0xFFFF)
  {
    uint64_t v16 = sub_100029CFC(a1, 2, v11, v44, (unsigned __int16)v43);
    if (!(_DWORD)v16) {
      goto LABEL_62;
    }
LABEL_53:
    uint64_t v30 = *(void *)(a1 + 8);
    if (v30) {
      __int16 v31 = (const char *)(v30 + 3992);
    }
    else {
      __int16 v31 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94( "%s:%d: %s unable allocate space that should be there: %d\n",  "btree_node_insert_internal",  2202,  v31,  v16);
    return v16;
  }

  unsigned __int16 v27 = (v11 + 7) & 0xFFF8;
  if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
    unsigned __int16 v27 = v11;
  }
  uint64_t v28 = *(void *)(a1 + 56);
  unsigned int v29 = *(unsigned __int16 *)(v28 + 46);
  if (v29 < v27)
  {
    uint64_t v16 = 28LL;
    goto LABEL_53;
  }

  __int16 v33 = v29 - v27;
  *(_WORD *)(v28 + 46) = v33;
  __int16 v43 = *(_WORD *)(a1 + 392) - (v33 + *(_WORD *)(a1 + 384) + *(_WORD *)(v28 + 44));
LABEL_62:
  if (!v11)
  {
    if (a6 == 65534) {
      __int16 v34 = -2;
    }
    else {
      __int16 v34 = -1;
    }
    __int16 v43 = v34;
  }

  uint64_t v35 = *(void *)(a1 + 56);
  unsigned int v36 = *(_DWORD *)(v35 + 36);
  if (v36 > a2)
  {
    sub_100029FB8(a1, a2, 1);
    uint64_t v35 = *(void *)(a1 + 56);
    unsigned int v36 = *(_DWORD *)(v35 + 36);
  }

  *(_DWORD *)(v35 + 36) = v36 + 1;
  __int16 v37 = v43;
  uint64_t v38 = *(void *)(a1 + 376);
  if ((*(_WORD *)(v35 + 32) & 4) != 0)
  {
    unsigned int v40 = (__int16 *)(v38 + 4LL * a2);
    *unsigned int v40 = v45;
    v40[1] = v37;
  }

  else
  {
    uint64_t v39 = (__int16 *)(v38 + 8LL * a2);
    *uint64_t v39 = v45;
    v39[1] = v12;
    v39[2] = v37;
    void v39[3] = a6;
  }

  if (v13) {
    memcpy((void *)(*(void *)(a1 + 384) + (unsigned __int16)v45), v13, v12);
  }
  if (v14) {
    memcpy((void *)(*(void *)(a1 + 392) - (unsigned __int16)v43), v14, v11);
  }
  sub_10003E644(a1, a7, 0LL);
  return 0LL;
}

uint64_t sub_100021744(uint64_t a1, unint64_t *a2, uint64_t a3, _WORD *a4, BOOL *a5)
{
  uint64_t result = sub_10002080C(a1, a2, a3, a4, a5);
  if (!(_DWORD)result && !*a5)
  {
    if (*a4) {
      --*a4;
    }
  }

  return result;
}

uint64_t sub_100021784(uint64_t a1, unsigned int a2, unint64_t *a3, uint64_t a4)
{
  int v5 = a3;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  __int16 v6 = *(_WORD *)(*(void *)(a1 + 56) + 32LL);
  if ((v6 & 8) == 0)
  {
LABEL_4:
    if ((v6 & 4) != 0) {
      uint64_t v8 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
    }
    else {
      uint64_t v8 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 8LL * a2 + 2);
    }
    return sub_10002446C( a1,  a2,  0LL,  v8,  (uint64_t)v5,  8LL,  0,  a4,  (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10002A028,  0LL);
  }

  unint64_t v7 = *(void *)(a1 + 408);
  if (*a3 > v7)
  {
    unint64_t v12 = *a3 - v7;
    int v5 = &v12;
    goto LABEL_4;
  }

  uint64_t v10 = *(void *)(a1 + 8);
  if (v10) {
    unsigned int v11 = (const char *)(v10 + 3992);
  }
  else {
    unsigned int v11 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
  }
  sub_100013D94( "%s:%d: %s invalid relative OID: %llu < root OID: %llu\n",  "btree_node_child_id_update",  1958,  v11,  *a3,  v7);
  return 22LL;
}

BOOL sub_100021854(uint64_t a1, unsigned int a2, __int16 *a3, __int16 *a4, __int16 a5, __int16 a6, _WORD *a7)
{
  unint64_t v12 = *(_WORD **)(a1 + 56);
  __int16 v13 = v12[16];
  int v14 = (unsigned __int16)v12[18];
  unsigned int v15 = (unsigned __int16)v12[21];
  if ((v13 & 4) != 0) {
    char v16 = 2;
  }
  else {
    char v16 = 3;
  }
  char v43 = v16;
  if ((v13 & 4) != 0) {
    char v17 = 2;
  }
  else {
    char v17 = 3;
  }
  unsigned int v18 = sub_10001E4C4(a1, 0);
  if ((v13 & 4) == 0 || (*(_BYTE *)(a1 + 400) & 4) != 0 || v14 + a2 <= v18)
  {
    unsigned int v20 = v18;
    unsigned int v21 = sub_10001E4C4(a1, (__int16)a2);
    if (a7)
    {
      if ((v13 & 4) != 0) {
        char v22 = 2;
      }
      else {
        char v22 = 3;
      }
      unsigned int v23 = v21 << v22;
      BOOL v24 = v23 >= v15;
      unsigned int v25 = v23 - v15;
      if (v25 == 0 || !v24) {
        LOWORD(v25) = 0;
      }
      *a7 = v25;
    }

    unsigned int v26 = v15 >> v17;
    __int16 v27 = 0;
    if (a2)
    {
      uint64_t v28 = a2;
      char v29 = v43;
      __int16 v31 = a5;
      __int16 v30 = a6;
      unsigned int v32 = v20;
      do
      {
        __int16 v34 = *a3++;
        __int16 v33 = v34;
        if ((*(void *)(a1 + 400) & 0x40) != 0)
        {
          __int16 v35 = *a4;
        }

        else
        {
          __int16 v33 = (v33 + 7) & 0xFFF8;
          __int16 v35 = (*a4 + 7) & 0xFFF8;
        }

        v27 += v33 + v35;
        ++a4;
        --v28;
      }

      while (v28);
    }

    else
    {
      char v29 = v43;
      __int16 v31 = a5;
      __int16 v30 = a6;
      unsigned int v32 = v20;
    }

    unsigned __int16 v36 = v30 + v31 + v27;
    if ((v13 & 4) != 0) {
      char v37 = 2;
    }
    else {
      char v37 = 3;
    }
    int v38 = ((v21 - v32) << v37) & 0xFFFC;
    if (v21 <= v32) {
      int v38 = 0;
    }
    BOOL v39 = v26 > v32;
    int v40 = (v26 - v32) << v29;
    if (!v39) {
      LOWORD(v40) = 0;
    }
    return v38 + v36 <= (unsigned __int16)(v12[23] + v40 + v12[25] + v12[27]);
  }

  else
  {
    BOOL result = 0LL;
    if (a7) {
      *a7 = -1;
    }
  }

  return result;
}

uint64_t sub_1000219F0(uint64_t a1)
{
  int v1 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  if (!v1)
  {
    LOWORD(v1) = *(_WORD *)(a1 + 440);
    if (!(_WORD)v1)
    {
      uint64_t v2 = *(void *)(a1 + 56);
      int v3 = *(_DWORD *)(v2 + 36);
      if (v3)
      {
        int v4 = 0;
        LOWORD(v1) = 0;
        __int16 v5 = *(_WORD *)(v2 + 32);
        do
        {
          if ((v5 & 4) != 0) {
            unsigned int v6 = 0;
          }
          else {
            unsigned int v6 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 8LL * (unsigned __int16)v4 + 2);
          }
          ++v4;
        }

        while (v3 != v4);
      }

      else
      {
        LOWORD(v1) = 0;
      }

      *(_WORD *)(a1 + 440) = v1;
    }
  }

  return (unsigned __int16)v1;
}

uint64_t sub_100021A68( void *a1, void *a2, unsigned int a3, void *a4, uint64_t a5, void *a6, unsigned int a7, uint64_t a8, __int16 *a9, __int16 *a10, unsigned __int16 a11, uint64_t a12, uint64_t a13, uint64_t *a14)
{
  unsigned int v255 = a7;
  uint64_t v254 = a6;
  uint64_t v19 = a13;
  v279 = a1;
  __chkstk_darwin();
  unsigned int v21 = &v246[-v20];
  bzero(&v246[-v20], v22);
  memset(v286, 0, sizeof(v286));
  unsigned __int16 v284 = 0LL;
  unsigned __int16 v285 = 0LL;
  int v283 = 0LL;
  memset(v282, 170, sizeof(v282));
  unsigned __int16 v281 = -21846;
  unsigned __int16 v280 = -21846;
  HIDWORD(v276) = (*(_WORD *)(a4[7] + 32LL) & 4) != 0 && (a4[50] & 4) == 0;
  uint64_t v270 = v279 + 50;
  *a14 = 0LL;
  unsigned int v253 = a3;
  unint64_t v248 = a14;
  if (a2 && *(_DWORD *)(a2[7] + 36LL) - 1 > a3)
  {
    unsigned __int16 v23 = a3 + 1;
    if (sub_10001E938((uint64_t)a2, v23, v21)
      || sub_10001E24C(v279, v21, a12, 3, *(_WORD *)(a2[7] + 34LL) - 1, a13, &v285)
      || (uint64_t v24 = (uint64_t)v285) == 0)
    {
      uint64_t v24 = 0LL;
      unsigned __int16 v285 = 0LL;
    }

    else if ((*v270 & 0x10) != 0 && v285[14] != *v21)
    {
      sub_100021784((uint64_t)a2, v23, (unint64_t *)v285 + 14, a13);
    }
  }

  else
  {
    uint64_t v24 = 0LL;
  }

  *(_OWORD *)((char *)v286 + 8) = *(_OWORD *)v270;
  *((void *)&v286[1] + 1) = a4[52];
  LODWORD(v286[0]) = 2123139;
  uint64_t v25 = a4[7];
  WORD2(v286[0]) = *(_WORD *)(v25 + 32) & 0x1A;
  WORD3(v286[0]) = *(_WORD *)(v25 + 34);
  unsigned __int16 v26 = 0;
  if ((_DWORD)a8)
  {
    uint64_t v29 = a8;
    do
    {
      __int16 v31 = *a9++;
      __int16 v30 = v31;
      if ((a4[50] & 0x40) != 0)
      {
        __int16 v32 = *a10;
      }

      else
      {
        __int16 v30 = (v30 + 7) & 0xFFF8;
        __int16 v32 = (*a10 + 7) & 0xFFF8;
      }

      v26 += v30 + v32;
      ++a10;
      --v29;
    }

    while (v29);
  }

  uint64_t v249 = v21;
  unsigned int v33 = *(_DWORD *)(v25 + 36);
  uint64_t v260 = a2;
  if (v33 > a5)
  {
    uint64_t v34 = sub_10001E654((uint64_t)a4, a5, &v282[3], &v281);
    if ((_DWORD)v34) {
      return v34;
    }
    uint64_t v35 = v279[1];
    if (!v35) {
      uint64_t v35 = *(void *)(*v279 + 392LL);
    }
    uint64_t v34 = ((uint64_t (*)(uint64_t, void *, void, void, void, _DWORD *))v279[52])( v35,  v254,  v255,  *(void *)&v282[3],  v281,  v282);
    if ((_DWORD)v34) {
      return v34;
    }
    if (v282[0])
    {
      unsigned int v266 = 0;
      int v263 = 0;
      int v36 = 0;
      a2 = v260;
    }

    else
    {
      a2 = v260;
      if ((*(_WORD *)(a4[7] + 32LL) & 2) != 0)
      {
        int v171 = sub_10001E5DC((uint64_t)a4, a5);
        if (v171 == 65534) {
          int v172 = 0;
        }
        else {
          int v172 = v171;
        }
        unsigned __int16 v280 = v172;
        if ((a4[50] & 0x40) != 0) {
          unsigned int v173 = v281;
        }
        else {
          unsigned int v173 = (v281 + 7) & 0xFFFFFFF8;
        }
        if ((a4[50] & 0x40) == 0) {
          int v172 = (v172 + 7) & 0x1FFF8;
        }
        unsigned int v266 = v173 + v172;
        int v263 = 1;
      }

      else
      {
        unsigned int v266 = 0;
        int v263 = 0;
      }

      int v36 = 1;
    }
  }

  else
  {
    unsigned int v266 = 0;
    int v263 = 0;
    int v36 = 0;
  }

  BOOL v274 = v24 == 0;
  uint64_t v267 = a13;
  unsigned int v275 = a4;
  if (!v24)
  {
    uint64_t v106 = sub_1000398C0((uint64_t)a4) & 0xFFFFFC00LL;
    uint64_t v107 = v279[1];
    if (!v107) {
      uint64_t v107 = *(void *)(*v279 + 392LL);
    }
    uint64_t v108 = sub_1000398B8((uint64_t)a4);
    uint64_t v34 = sub_100027B58(v107, v106, v108, v286, a13, &v285);
    if ((_DWORD)v34) {
      return v34;
    }
    __int16 v109 = (unint64_t *)(v279[49] + 32LL);
    a2 = v260;
    do
      unint64_t v110 = __ldxr(v109);
    while (__stxr(v110 + 1, v109));
    unsigned __int16 v111 = v279;
    sub_10003E644((uint64_t)v279, a13, 0LL);
    if ((v111[50] & 2) != 0 || v279[54] == a4[14])
    {
      uint64_t v112 = a4[7];
      if (*(_DWORD *)(v112 + 36) == (_DWORD)a5)
      {
        int v113 = 0;
        LODWORD(a8) = 0;
        int v40 = a5 + ((*(unsigned __int16 *)(v112 + 32) >> 1) & 1) - 1;
        BOOL v274 = 1;
        goto LABEL_147;
      }
    }
  }

  uint64_t v37 = a4[7];
  __int16 v38 = *(_WORD *)(v37 + 32);
  int v261 = sub_10001E4C4((uint64_t)a4, 0);
  if ((v38 & 4) != 0) {
    uint64_t v39 = 2LL;
  }
  else {
    uint64_t v39 = 3LL;
  }
  int v40 = *(_DWORD *)(v37 + 36);
  if (((v40 - 1) & 0x8000) != 0)
  {
    int v113 = 0;
    goto LABEL_147;
  }

  int v250 = v26;
  int v41 = a11 + v26;
  unsigned int v247 = v36 + a5;
  uint64_t v42 = a8;
  int v43 = (__int16)(v40 - 1);
  uint64_t v44 = (uint64_t)v285;
  int v268 = sub_100029670((uint64_t)v285);
  size_t v278 = v44;
  unsigned int v269 = sub_10001E4C4(v44, 0) << v39;
  int v258 = sub_100029670((uint64_t)a4);
  LOWORD(v44) = 0;
  int v272 = 0;
  LODWORD(v277) = 0;
  int v256 = v263 ^ 1;
  int v262 = v42;
  int v45 = v263;
  int v252 = v41;
  LODWORD(v276) = v41;
  uint64_t v19 = v267;
  uint64_t v271 = v39;
  while (1)
  {
    int v265 = v40;
    __int16 v46 = v42 - v45;
    int v47 = sub_10001E4C4((uint64_t)a4, (__int16)(v42 - v45));
    int v48 = v258 + (unsigned __int16)v266 + (__int16)((v261 - v47) << v39);
    int v49 = (__int16)(v258 + v266 + ((v261 - v47) << v39) - v276);
    int v50 = HIDWORD(v276);
    int v273 = v45;
    if (v50 == 1)
    {
      unsigned int v51 = *(_DWORD *)(a4[7] + 36LL) - (__int16)v45 + (__int16)v42;
    }

    else if (v48 < (unsigned __int16)v276)
    {
LABEL_33:
      int v52 = v272;
      goto LABEL_42;
    }

    if (!v274) {
      goto LABEL_144;
    }
    if ((*v270 & 2) != 0 || v279[54] == a4[14])
    {
      if ((*(_WORD *)(a4[7] + 32LL) & 2) != 0) {
        goto LABEL_144;
      }
      if (!(_WORD)v43) {
        goto LABEL_144;
      }
      int v52 = v272;
      int v53 = sub_10001E4C4(v278, (__int16)v272);
      __int16 v54 = v268 + v269 + v44 - (v53 << v39);
    }

    else if (HIDWORD(v276))
    {
      if (!(_WORD)v43) {
        goto LABEL_144;
      }
      unsigned __int16 v84 = v46 + *(_WORD *)(a4[7] + 36LL);
      int v52 = v272;
    }

    else
    {
      int v52 = v272;
      int v105 = sub_10001E4C4(v278, (__int16)v272);
    }

LABEL_129:
        BOOL v274 = 1;
LABEL_143:
        a4 = v275;
LABEL_144:
        int v113 = 0;
        LOWORD(v40) = v43 + 1;
LABEL_145:
        LODWORD(a8) = v42;
LABEL_146:
        a2 = v260;
        goto LABEL_147;
      }
    }

    uint64_t v42 = (v42 - v262);
    a5 = v60;
    if (!v274)
    {
      BOOL v274 = 0;
      if (v263) {
        LOWORD(v43) = v265 - 2;
      }
      goto LABEL_143;
    }

    int v83 = v61;
    uint64_t v58 = v257;
    if ((*v270 & 2) != 0 || v279[54] == v275[14])
    {
LABEL_127:
      if (v263) {
        LOWORD(v43) = v265 - 2;
      }
      goto LABEL_129;
    }

    int v79 = v276 - v252;
    LODWORD(v277) = (_DWORD)v277 + v252;
    if (HIDWORD(v276))
    {
      if (!(_WORD)v43
        || (unsigned __int16)(v42 - v273 + *(_WORD *)(v257 + 36)) <= (unsigned __int16)(v64 + *(_WORD *)(*(void *)(v278 + 56) + 36LL)))
      {
        goto LABEL_127;
      }
    }

    else if (!(_WORD)v43 || v83 >= (__int16)(v66 - (_WORD)v277 - v67))
    {
      goto LABEL_127;
    }

    uint64_t v55 = v42;
    uint64_t v56 = a5;
    int v52 = v64;
    unsigned int v57 = v251;
    if ((v259 & 4) == 0)
    {
LABEL_57:
      int v80 = v275;
      unsigned int v81 = *(unsigned __int16 *)(v275[47] + 8LL * (unsigned __int16)v43 + 2);
      uint64_t v82 = v275[50];
      goto LABEL_74;
    }

LABEL_73:
    int v80 = v275;
    uint64_t v82 = v275[50];
    unsigned int v81 = (v82 >> 9) & 0x3FFF;
LABEL_74:
    unsigned __int16 v281 = v81;
    int v85 = sub_10001E5DC((uint64_t)v80, (unsigned __int16)v43);
    if (v85 == 65534) {
      int v86 = 0;
    }
    else {
      int v86 = v85;
    }
    unsigned __int16 v280 = v86;
    int v87 = (v81 + 7) & 0x1FFF8;
    if ((v82 & 0x40) != 0) {
      int v87 = v81;
    }
    else {
      int v86 = (v86 + 7) & 0x1FFF8;
    }
    char v88 = v263;
    int v272 = v52;
    if ((v88 & 1) == 0) {
      break;
    }
    LODWORD(v276) = v79;
    int v40 = v43;
    uint64_t v19 = v267;
    a4 = v275;
    LOBYTE(v39) = v271;
    int v45 = v273;
    a5 = v56;
    uint64_t v42 = v55;
LABEL_107:
    LODWORD(v44) = -(int)v277;
    int v43 = (__int16)(v40 - 1);
    if (((v40 - 1) & 0x8000) != 0)
    {
      int v113 = 0;
      goto LABEL_145;
    }
  }

  uint64_t v257 = v58;
  int v89 = v87 + v86;
  else {
    int v90 = 0;
  }
  else {
    int v91 = 0;
  }
  LODWORD(v39) = v52 + v90 + 1;
  int v92 = sub_10001E4C4(v278, (__int16)(v52 + v90 + 1));
  int v93 = (unsigned __int16)v91 + (unsigned __int16)v277 + (unsigned __int16)v89 + (__int16)((v92 << v271) - v269);
  int v94 = HIDWORD(v276);
  if (v94 == 1)
  {
    unsigned int v95 = v90 + (__int16)v52 + *(_DWORD *)(*(void *)(v278 + 56) + 36LL) + 1;
    BOOL v71 = v95 >= sub_10001E4C4(v278, 0);
    a5 = v56;
    uint64_t v42 = v55;
    if (!v71) {
      goto LABEL_103;
    }
  }

  else
  {
    a5 = v56;
    uint64_t v42 = v55;
    if (v93 <= (unsigned __int16)v268)
    {
LABEL_103:
      LODWORD(v277) = (_DWORD)v277 + v91 + v89;
      uint64_t v42 = (v42 - v90);
      if (v90) {
        int v104 = v91;
      }
      else {
        int v104 = 0;
      }
      LODWORD(v276) = v79 - v104;
      int v45 = v273 + 1;
      v266 += v89;
      int v40 = v43;
      int v272 = v39;
      uint64_t v19 = v267;
      a4 = v275;
      LOBYTE(v39) = v271;
      goto LABEL_107;
    }
  }

  if (!v274)
  {
    LODWORD(v276) = v79;
    a4 = v275;
    int v96 = sub_1000398C0((uint64_t)v275);
    uint64_t v97 = v278;
    sub_10003D514(v278, 2);
    sub_100038824(v97);
    unsigned __int16 v285 = 0LL;
    uint64_t v98 = v279[1];
    uint64_t v19 = v267;
    if (!v98) {
      uint64_t v98 = *(void *)(*v279 + 392LL);
    }
    uint64_t v99 = sub_1000398B8((uint64_t)a4);
    uint64_t v76 = sub_100027B58(v98, v96 & 0xFFFFFC00, v99, v286, v19, &v285);
    int v40 = v265;
    int v45 = v273;
    if ((_DWORD)v76) {
      return v76;
    }
    BOOL v100 = (unint64_t *)(v279[49] + 32LL);
    do
      unint64_t v101 = __ldxr(v100);
    while (__stxr(v101 + 1, v100));
LABEL_101:
    sub_10003E644((uint64_t)v279, v19, 0LL);
    uint64_t v102 = (uint64_t)v285;
    int v103 = sub_10001E4C4((uint64_t)v285, 0);
    LOBYTE(v39) = v271;
    unsigned int v269 = v103 << v271;
    size_t v278 = v102;
    int v268 = sub_100029670(v102);
    BOOL v274 = 1;
    goto LABEL_107;
  }

  uint64_t v19 = v267;
  if ((v264 & 0x80000000) == 0) {
    goto LABEL_240;
  }
  int v113 = 2914;
  if ((__int16)v265 > 1)
  {
    LOWORD(v40) = v265;
    goto LABEL_137;
  }

  uint64_t v114 = v257;
  if ((v259 & 2) == 0)
  {
LABEL_240:
    int v113 = 0;
    BOOL v274 = 1;
    LODWORD(a8) = v42;
    a4 = v275;
    a2 = v260;
    LOWORD(v40) = v265;
    goto LABEL_147;
  }

  LOWORD(v40) = v265;
LABEL_138:
  if (*(unsigned __int16 *)(v114 + 36) == (unsigned __int16)v40 && v278)
  {
    BOOL v274 = 0;
    int v283 = (uint64_t *)v278;
    unsigned __int16 v285 = 0LL;
    LODWORD(a8) = v42;
    a4 = v275;
    goto LABEL_146;
  }

  LODWORD(a8) = v42;
  __int16 v234 = v40;
  a4 = v275;
  uint64_t v235 = sub_1000398C0((uint64_t)v275) & 0xFFFFFC00LL;
  uint64_t v236 = v279[1];
  if (!v236) {
    uint64_t v236 = *(void *)(*v279 + 392LL);
  }
  uint64_t v237 = sub_1000398B8((uint64_t)a4);
  uint64_t v238 = sub_100027B58(v236, v235, v237, v286, v19, &v283);
  if ((_DWORD)v238)
  {
    uint64_t v34 = v238;
    unsigned int v277 = 0LL;
    size_t v278 = 0LL;
    LOWORD(v120) = 0;
    int v121 = 0;
    LOWORD(v122) = 0;
    int v123 = 0;
    uint64_t v276 = 0LL;
    int v124 = 0;
    int v125 = 0;
    int v273 = 0;
    BOOL v274 = 1;
    goto LABEL_265;
  }

  uint64_t v244 = (unint64_t *)(v279[49] + 32LL);
  do
    unint64_t v245 = __ldxr(v244);
  while (__stxr(v245 + 1, v244));
  sub_10003E644((uint64_t)v279, v19, 0LL);
  BOOL v274 = 1;
  a2 = v260;
  LOWORD(v40) = v234;
LABEL_147:
  if (!a2 && (v113 != 0 || v274))
  {
    __int16 v115 = v40;
    uint64_t v116 = sub_1000398C0((uint64_t)a4) & 0xFFFFFC00LL;
    uint64_t v117 = v279[1];
    if (!v117) {
      uint64_t v117 = *(void *)(*v279 + 392LL);
    }
    uint64_t v118 = sub_1000398B8((uint64_t)a4);
    uint64_t v119 = sub_100027B58(v117, v116, v118, v286, v19, &v284);
    if ((_DWORD)v119)
    {
      uint64_t v34 = v119;
      unsigned int v277 = 0LL;
      size_t v278 = 0LL;
      LOWORD(v120) = 0;
      int v121 = 0;
      LOWORD(v122) = 0;
      int v123 = 0;
      uint64_t v276 = 0LL;
      int v124 = 0;
      int v273 = 0;
      int v125 = 0;
      uint64_t v260 = 0LL;
      goto LABEL_265;
    }

    uint64_t v126 = (unint64_t *)(v279[49] + 32LL);
    a2 = v260;
    do
      unint64_t v127 = __ldxr(v126);
    while (__stxr(v127 + 1, v126));
    sub_10003E644((uint64_t)v279, v19, 0LL);
    LOWORD(v40) = v115;
  }

  __int16 v128 = v40;
  else {
    int v129 = 0;
  }
  uint64_t v130 = a4[7];
  if (v129 == 1)
  {
    int v120 = *(_DWORD *)(v130 + 36) + ~(_DWORD)a5;
    if (v120 << 16 < 1) {
      goto LABEL_182;
    }
    uint64_t v131 = (uint64_t)v285;
    uint64_t v132 = sub_10002A048((uint64_t)a4, (uint64_t)v285, (__int16)v120, v19);
    if ((_DWORD)v132)
    {
      uint64_t v34 = v132;
      uint64_t v133 = v279[1];
      if (v133) {
        int v134 = (const char *)(v133 + 3992);
      }
      else {
        int v134 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3020, v134, 0, v132);
      unsigned int v277 = 0LL;
      size_t v278 = 0LL;
      LOWORD(v120) = 0;
LABEL_264:
      int v121 = 0;
      LOWORD(v122) = 0;
      int v123 = 0;
      uint64_t v276 = 0LL;
      int v124 = 0;
      int v273 = 0;
      int v125 = 0;
      goto LABEL_265;
    }

    if (v274)
    {
LABEL_182:
      unsigned int v150 = a5;
      LODWORD(v271) = 1;
      int v272 = v120;
      uint64_t v135 = v19;
      int v136 = 0;
    }

    else
    {
      uint64_t v34 = sub_10001E654(v131, 0, &v282[3], &v281);
      if ((_DWORD)v34
        || (uint64_t v34 = sub_1000209D8((int)v260, (unsigned __int16)(v253 + 1), *(void **)&v282[3], v281, 0LL), (_DWORD)v34))
      {
        uint64_t v169 = v279[1];
        if (v169) {
          uint64_t v170 = (const char *)(v169 + 3992);
        }
        else {
          uint64_t v170 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_shift_or_split", 3028, v170, v34);
        BOOL v274 = 0;
        unsigned int v277 = 0LL;
        size_t v278 = 0LL;
        goto LABEL_264;
      }

      unsigned int v150 = a5;
      LODWORD(v271) = 1;
      int v272 = v120;
      uint64_t v135 = v19;
      int v136 = 1;
    }

    uint64_t v151 = sub_10001E764(a4, v150, &v282[1], (__int16 *)&v280);
    if ((_DWORD)v151)
    {
      uint64_t v34 = v151;
      LODWORD(v276) = 0;
      HIDWORD(v276) = v136;
      unsigned int v277 = 0LL;
      size_t v278 = 0LL;
      int v121 = 0;
      LOWORD(v122) = 0;
      int v123 = 0;
      int v124 = 0;
      int v273 = 0;
      int v125 = 0;
LABEL_185:
      LOWORD(v120) = v272;
      goto LABEL_265;
    }

    unsigned int v277 = 0LL;
    size_t v278 = v280;
    if (v280)
    {
      a2 = v260;
      if (v280 != 65534)
      {
        int v157 = sub_100014044(v278);
        if (!v157)
        {
          LODWORD(v276) = 0;
          HIDWORD(v276) = v136;
          unsigned int v277 = 0LL;
          size_t v278 = 0LL;
          int v121 = 0;
          LOWORD(v122) = 0;
          int v123 = 0;
          int v124 = 0;
          int v273 = 0;
          int v125 = 0;
          uint64_t v34 = 12LL;
          goto LABEL_185;
        }

        unsigned int v277 = v157;
        memcpy(v157, *(const void **)&v282[1], v280);
        size_t v278 = v280;
      }
    }

    else
    {
      a2 = v260;
    }

    int v262 = a8;
    sub_1000257A4((uint64_t)a4, v150, v135);
    int v182 = (unint64_t *)(v279[49] + 24LL);
    do
      unint64_t v183 = __ldxr(v182);
    while (__stxr(v183 - 1, v182));
    sub_10003E644((uint64_t)v279, v135, 0LL);
    uint64_t v130 = a4[7];
  }

  else
  {
    LODWORD(v271) = v129;
    uint64_t v135 = v19;
    int v262 = a8;
    unsigned int v277 = 0LL;
    size_t v278 = 0LL;
    int v272 = 0;
    int v136 = 0;
  }

  __int16 v137 = *(_WORD *)(v130 + 36) - v128;
  int v121 = v137;
  HIDWORD(v276) = v136;
  if (v137 < 1)
  {
    LODWORD(v276) = 0;
LABEL_170:
    int v273 = 0;
    goto LABEL_171;
  }

  uint64_t v138 = (uint64_t)v285;
  uint64_t v139 = sub_10002A048((uint64_t)a4, (uint64_t)v285, v137, v135);
  if ((_DWORD)v139)
  {
    uint64_t v34 = v139;
    uint64_t v140 = v279[1];
    if (v140) {
      uint64_t v141 = (const char *)(v140 + 3992);
    }
    else {
      uint64_t v141 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3065, v141, v121, v139);
    int v121 = 0;
    goto LABEL_255;
  }

  if (!v274)
  {
    uint64_t v34 = sub_10001E654(v138, 0, &v282[3], &v281);
    if ((_DWORD)v34
      || (uint64_t v34 = sub_1000209D8((int)v260, (unsigned __int16)(v253 + 1), *(void **)&v282[3], v281, 0LL), (_DWORD)v34))
    {
      uint64_t v165 = v279[1];
      if (v165) {
        unsigned int v166 = (const char *)(v165 + 3992);
      }
      else {
        unsigned int v166 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_shift_or_split", 3073, v166, v34);
      BOOL v274 = 0;
LABEL_255:
      LOWORD(v122) = 0;
      int v123 = 0;
      LODWORD(v276) = 0;
LABEL_256:
      int v273 = 0;
LABEL_260:
      int v125 = 0;
LABEL_261:
      LOWORD(v120) = v272;
      int v124 = v271;
      goto LABEL_265;
    }
  }

  LODWORD(v276) = !v274;
  a2 = v260;
  if (!v260 || *(_DWORD *)(a4[7] + 36LL)) {
    goto LABEL_170;
  }
  uint64_t v147 = sub_1000209D8((int)v260, v253, v254, v255, 0LL);
  if ((_DWORD)v147)
  {
    uint64_t v34 = v147;
    uint64_t v148 = v279[1];
    if (v148) {
      uint64_t v149 = (const char *)(v148 + 3992);
    }
    else {
      uint64_t v149 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_shift_or_split", 3084, v149, v147);
    LOWORD(v122) = 0;
    int v123 = 0;
    goto LABEL_256;
  }

  int v273 = 1;
  a2 = v260;
LABEL_171:
  uint64_t v142 = (uint64_t)v284;
  if (v284)
  {
    uint64_t v143 = a4[7];
    int v122 = *(_DWORD *)(v143 + 36);
    uint64_t v144 = sub_10002A048((uint64_t)v284, (uint64_t)a4, (__int16)-*(_WORD *)(v143 + 36), v135);
    if ((_DWORD)v144)
    {
      uint64_t v34 = v144;
      uint64_t v145 = v279[1];
      if (v145) {
        uint64_t v146 = (const char *)(v145 + 3992);
      }
      else {
        uint64_t v146 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3100, v146, -(__int16)v122, v144);
      LOWORD(v122) = 0;
LABEL_259:
      int v123 = 0;
      goto LABEL_260;
    }

    sub_10002A5AC((uint64_t)a4, (unsigned __int16)(*(_WORD *)(a4[7] + 34LL) + 1), v135);
    if (*(_DWORD *)(*(void *)(v142 + 56) + 36LL))
    {
      uint64_t v34 = sub_10001E654(v142, 0, &v282[3], &v281);
      if (!(_DWORD)v34)
      {
        int v167 = *(unint64_t **)&v282[3];
        size_t v168 = v281;
        goto LABEL_250;
      }

      goto LABEL_251;
    }

    int v167 = (unint64_t *)v254;
    *(void *)&v282[3] = v254;
    size_t v168 = v255;
    unsigned __int16 v281 = v255;
LABEL_250:
    uint64_t v184 = v249;
    *uint64_t v249 = *(void *)(v142 + 112);
    uint64_t v34 = sub_100023A70(a4, v167, v168, v184, (*((_WORD *)a4 + 203) & 0x7Fu) + 8, v135, 0LL, 0LL);
    if ((_DWORD)v34)
    {
LABEL_251:
      uint64_t v185 = v279[1];
      if (v185) {
        uint64_t v186 = (const char *)(v185 + 3992);
      }
      else {
        uint64_t v186 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s btree_node_insert failed: %d\n", "bt_shift_or_split", 3123, v186, v34);
      goto LABEL_259;
    }

    a2 = a4;
  }

  else
  {
    LOWORD(v122) = 0;
  }

  if (v274 && (uint64_t v152 = v285) != 0LL)
  {
    uint64_t v153 = v285[7];
    if (*(_DWORD *)(v153 + 36))
    {
      uint64_t v260 = a2;
      uint64_t v34 = sub_10001E654((uint64_t)v285, 0, &v282[3], &v281);
      if ((_DWORD)v34
        || (uint64_t v154 = v249,
            *uint64_t v249 = v152[14],
            uint64_t v34 = sub_100023A70( v260,  *(unint64_t **)&v282[3],  v281,  v154,  (*((_WORD *)v260 + 203) & 0x7Fu) + 8,  v135,  0LL,  0LL),  (_DWORD)v34))
      {
        uint64_t v155 = v279[1];
        if (v155) {
          BOOL v156 = (const char *)(v155 + 3992);
        }
        else {
          BOOL v156 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s btree_node_insert failed: %d\n", "bt_shift_or_split", 3139, v156, v34);
        int v123 = 0;
        int v125 = 0;
        BOOL v274 = 1;
        goto LABEL_261;
      }

      int v125 = 1;
      a2 = v260;
    }

    else
    {
      if ((*(_WORD *)(v153 + 32) & 2) != 0)
      {
        int v283 = v285;
        int v113 = 1;
      }

      else
      {
        unsigned __int16 v232 = (unint64_t *)(v279[49] + 32LL);
        do
          unint64_t v233 = __ldxr(v232);
        while (__stxr(v233 - 1, v232));
        sub_10003B238(v152, v135);
        sub_10003D514((uint64_t)v152, 2);
        sub_100038824(v152);
      }

      int v125 = 0;
      unsigned __int16 v285 = 0LL;
    }
  }

  else
  {
    int v125 = 0;
  }

  if (!v113)
  {
    if ((_WORD)v262)
    {
      uint64_t v174 = (uint64_t)v285;
      uint64_t v175 = v279;
      int v176 = v277;
      if (v142) {
        unsigned __int16 v285 = (uint64_t *)v142;
      }
      else {
        unsigned __int16 v285 = 0LL;
      }
    }

    else
    {
      uint64_t v174 = 0LL;
      uint64_t v175 = v279;
      int v176 = v277;
    }

    if (!v274) {
      goto LABEL_357;
    }
    goto LABEL_356;
  }

  if (v142) {
    uint64_t v158 = v142;
  }
  else {
    uint64_t v158 = (uint64_t)a4;
  }
  __int16 v159 = *(_WORD *)(*(void *)(v158 + 56) + 32LL);
  uint64_t v260 = a2;
  if ((v159 & 2) != 0)
  {
    int v123 = 0;
    int v177 = (unint64_t *)v254;
    *(void *)&v282[3] = v254;
    size_t v178 = v255;
    unsigned __int16 v281 = v255;
    uint64_t v160 = (uint64_t)v283;
    int v162 = v249;
    LOWORD(v120) = v272;
    int v124 = v271;
LABEL_242:
    *int v162 = *(void *)(v160 + 112);
    uint64_t v179 = sub_100023A70(a2, v177, v178, v162, (*((_WORD *)a2 + 203) & 0x7Fu) + 8, v267, 0LL, 0LL);
    if ((_DWORD)v179)
    {
      uint64_t v34 = v179;
      uint64_t v180 = v279[1];
      if (v180) {
        unint64_t v181 = (const char *)(v180 + 3992);
      }
      else {
        unint64_t v181 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s btree_node_insert failed: %d\n", "bt_shift_or_split", 3183, v181, v179);
      goto LABEL_265;
    }

    uint64_t v174 = (uint64_t)v285;
    unsigned __int16 v285 = (uint64_t *)v160;
    uint64_t v175 = v279;
    a4 = v275;
    a2 = v260;
    int v176 = v277;
LABEL_356:
    sub_10002A66C((uint64_t)v175, (uint64_t)a2, (uint64_t)a4);
LABEL_357:
    if (v176) {
      sub_100014004(v176, v278);
    }
    if (v174)
    {
      sub_10003D514(v174, 2);
      sub_100038824(v174);
    }

    uint64_t v242 = (uint64_t)v284;
    uint64_t v243 = (uint64_t)v285;
    if (v284 && v285 != v284)
    {
      sub_10003D514((uint64_t)v284, 2);
      sub_100038824(v242);
    }

    uint64_t v34 = 0LL;
    *unint64_t v248 = v243;
    return v34;
  }

  uint64_t v160 = (uint64_t)v283;
  uint64_t v161 = sub_10002A048(v158, (uint64_t)v283, 1, v267);
  int v162 = v249;
  LOWORD(v120) = v272;
  int v124 = v271;
  if ((_DWORD)v161)
  {
    uint64_t v34 = v161;
    uint64_t v163 = v279[1];
    if (v163) {
      uint64_t v164 = (const char *)(v163 + 3992);
    }
    else {
      uint64_t v164 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3166, v164, 1, v161);
    goto LABEL_386;
  }

  uint64_t v239 = sub_10001E654(v160, 0, &v282[3], &v281);
  if (!(_DWORD)v239)
  {
    int v177 = *(unint64_t **)&v282[3];
    int v123 = 1;
    size_t v178 = v281;
    a2 = v260;
    goto LABEL_242;
  }

  uint64_t v34 = v239;
  uint64_t v240 = v279[1];
  if (v240) {
    uint64_t v241 = (const char *)(v240 + 3992);
  }
  else {
    uint64_t v241 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
  }
  sub_100013D94("%s:%d: %s failed to get newnode minkey: %d\n", "bt_shift_or_split", 3171, v241, v239);
LABEL_386:
  int v123 = 0;
LABEL_265:
  uint64_t v187 = v279[1];
  if (v187) {
    uint64_t v188 = (const char *)(v187 + 3992);
  }
  else {
    uint64_t v188 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
  }
  sub_100013D94("%s:%d: %s reverting on error: %d\n", "bt_shift_or_split", 3219, v188, v34);
  if (v125) {
    sub_1000257A4((uint64_t)v260, (unsigned __int16)(v253 + 1), v267);
  }
  uint64_t v189 = v267;
  if (v123)
  {
    uint64_t v190 = sub_10002A048((uint64_t)v275, (uint64_t)v283, -1, v267);
    uint64_t v34 = v190;
    if ((_DWORD)v190)
    {
      uint64_t v191 = v279[1];
      if (v191) {
        int v192 = (const char *)(v191 + 3992);
      }
      else {
        int v192 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s bt_move_entries %d failed: %d\n", "bt_shift_or_split", 3226, v192, -1, v190);
    }
  }

  int v193 = (__int16)v122;
  uint64_t v194 = v275;
  uint64_t v195 = v277;
  unsigned int v196 = v278;
  if (v193 >= 1)
  {
    sub_10002A5AC((uint64_t)v275, (unsigned __int16)(*(_WORD *)(v275[7] + 34LL) - 1), v189);
    int v197 = sub_10002A048((uint64_t)v284, (uint64_t)v194, v193, v189);
    if (v197)
    {
      uint64_t v198 = v279[1];
      if (v198) {
        unsigned __int16 v199 = (const char *)(v198 + 3992);
      }
      else {
        unsigned __int16 v199 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94( "%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3236,  v199,  v197,  v34);
    }

    uint64_t v260 = 0LL;
  }

  if (v121 >= 1)
  {
    uint64_t v200 = (uint64_t)v285;
    int v201 = sub_10002A048((uint64_t)v194, (uint64_t)v285, (__int16)-(__int16)v121, v189);
    if (v201)
    {
      uint64_t v202 = v279[1];
      if (v202) {
        uint64_t v203 = (const char *)(v202 + 3992);
      }
      else {
        uint64_t v203 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94( "%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3243,  v203,  v201,  v34);
    }

    if (!v274 && (v276 & 1) != 0)
    {
      int v204 = sub_10001E654(v200, 0, &v282[3], &v281);
      if (v204 || (int v204 = sub_1000209D8((int)v260, (unsigned __int16)(v253 + 1), *(void **)&v282[3], v281, 0LL)) != 0)
      {
        uint64_t v205 = v279[1];
        if (v205) {
          int v206 = (const char *)(v205 + 3992);
        }
        else {
          int v206 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94( "%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3251,  v206,  v204,  v34);
      }
    }

    if (v273)
    {
      int v207 = sub_10001E654((uint64_t)v194, 0, &v282[3], &v281);
      if (v207 || (int v207 = sub_1000209D8((int)v260, v253, *(void **)&v282[3], v281, 0LL)) != 0)
      {
        uint64_t v208 = v279[1];
        if (v208) {
          __int16 v209 = (const char *)(v208 + 3992);
        }
        else {
          __int16 v209 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94( "%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3260,  v209,  v207,  v34);
      }
    }
  }

  if (v124)
  {
    int v210 = sub_100023A70(v194, (unint64_t *)v254, v255, v195, v196, v189, 0LL, 0LL);
    if (v210)
    {
      uint64_t v211 = v279[1];
      if (v211) {
        uint64_t v212 = (const char *)(v211 + 3992);
      }
      else {
        uint64_t v212 = (const char *)(*(void *)(*(void *)(*v279 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94( "%s:%d: %s btree_node_insert() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3267,  v212,  v210,  v34);
    }

    if (v195) {
      sub_100014004(v195, v196);
    }
  }

  uint64_t v213 = v279;
  if ((__int16)v120 >= 1)
  {
    uint64_t v214 = (uint64_t)v285;
    int v215 = sub_10002A048((uint64_t)v194, (uint64_t)v285, (__int16)-(__int16)v120, v189);
    char v216 = BYTE4(v276);
    if (v215)
    {
      uint64_t v217 = v213[1];
      if (v217) {
        v218 = (const char *)(v217 + 3992);
      }
      else {
        v218 = (const char *)(*(void *)(*(void *)(*v213 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94( "%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3276,  v218,  v215,  v34);
    }

    if (!v274 && (v216 & 1) != 0)
    {
      int v219 = sub_10001E654(v214, 0, &v282[3], &v281);
      if (v219 || (int v219 = sub_1000209D8((int)v260, (unsigned __int16)(v253 + 1), *(void **)&v282[3], v281, 0LL)) != 0)
      {
        uint64_t v220 = v213[1];
        if (v220) {
          BOOL v221 = (const char *)(v220 + 3992);
        }
        else {
          BOOL v221 = (const char *)(*(void *)(*(void *)(*v213 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94( "%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n",  "bt_shift_or_split",  3284,  v221,  v219,  v34);
      }
    }
  }

  uint64_t v222 = v285;
  if (v285)
  {
    if (!*(_DWORD *)(v285[7] + 36))
    {
      uint64_t v223 = (unint64_t *)(v213[49] + 32LL);
      do
        unint64_t v224 = __ldxr(v223);
      while (__stxr(v224 - 1, v223));
      sub_10003B238(v222, v189);
    }

    sub_10003D514((uint64_t)v222, 2);
    sub_100038824(v222);
  }

  __int16 v225 = v283;
  if (v283)
  {
    unsigned __int16 v226 = (unint64_t *)(v213[49] + 32LL);
    do
      unint64_t v227 = __ldxr(v226);
    while (__stxr(v227 - 1, v226));
    sub_10003B238(v225, v189);
    sub_10003D514((uint64_t)v225, 2);
    sub_100038824(v225);
  }

  int v228 = v284;
  if (v284)
  {
    int v229 = (unint64_t *)(v213[49] + 32LL);
    do
      unint64_t v230 = __ldxr(v229);
    while (__stxr(v230 - 1, v229));
    sub_10003B238(v228, v189);
    sub_10003D514((uint64_t)v228, 2);
    sub_100038824(v228);
  }

  return v34;
}

  if ((_DWORD)v19) {
    sub_100013CBC( "%s:%d: %s %lld:%lld error: %d\n",  "spaceman_check_allocation_status_internal",  8423,  (const char *)(a1[48] + 208LL),  v9,  v8,  v19);
  }
LABEL_75:
  if (v69) {
    sub_100038824(v69);
  }
  if (v68) {
    sub_100038824(v68);
  }
  if (v67) {
    sub_100038824(v67);
  }
  *unint64_t v7 = v20;
  return v19;
}

uint64_t sub_100023A70( void *a1, unint64_t *a2, size_t a3, void *a4, unsigned int a5, uint64_t a6, _WORD *a7, _BYTE *a8)
{
  char v16 = (uint64_t *)((char *)&v21 - (HIWORD(a1[50]) & 0x7FLL) - 8);
  bzero(v16, (size_t)a2);
  HIWORD(v21) = -21846;
  BYTE5(v21) = -86;
  uint64_t result = sub_10002080C((uint64_t)a1, a2, a3, (_WORD *)&v21 + 3, (BOOL *)&v21 + 5);
  if (!(_DWORD)result)
  {
    if (a8) {
      *a8 = BYTE5(v21);
    }
    if (a7) {
      *a7 = HIWORD(v21);
    }
    if ((*(_WORD *)(a1[7] + 32LL) & 0xA) != 8) {
      goto LABEL_9;
    }
    unint64_t v18 = a1[51];
    if (*a4 > v18)
    {
      void *v16 = *a4 - v18;
      a4 = v16;
LABEL_9:
      if (BYTE5(v21)) {
        return sub_1000209D8((int)a1, HIWORD(v21), a2, a3, a4);
      }
      else {
        return sub_1000212D0((uint64_t)a1, HIWORD(v21), a2, a3, a4, a5, a6);
      }
    }

    uint64_t v19 = a1[1];
    if (v19) {
      uint64_t v20 = (const char *)(v19 + 3992);
    }
    else {
      uint64_t v20 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94("%s:%d: %s invalid relative OID: %llu < root OID: %llu\n", "btree_node_insert", 2270, v20, *a4, v18);
    return 22LL;
  }

  return result;
}

uint64_t sub_100023C40( uint64_t *a1, uint64_t a2, unint64_t *a3, uint64_t a4, void *a5, unsigned int a6, uint64_t a7, uint64_t *a8)
{
  int v43 = a3;
  uint64_t v15 = a1[50];
  __chkstk_darwin();
  char v17 = (void **)((char *)&v40 - v16);
  bzero((char *)&v40 - v16, v18);
  int v49 = 0LL;
  unsigned __int16 v48 = 0;
  if (!a1[52]) {
    return 22LL;
  }
  uint64_t v19 = sub_10001DA64((uint64_t)a1, a4, a6);
  if (!(_DWORD)v19)
  {
    uint64_t v19 = sub_10003CF9C(a1, (v15 >> 3) & 2, a7);
    if (!(_DWORD)v19)
    {
      uint64_t v20 = a1[49];
      BOOL v21 = *(_DWORD *)(v20 + 16) < a4 || *(_DWORD *)(v20 + 20) < a6;
      BOOL v42 = v21;
      int v50 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      char v47 = -86;
      int v40 = a5;
      int v41 = a8;
      if (a8)
      {
        uint64_t v23 = *a8;
        if (*a8)
        {
          if ((uint64_t *)a8[1] == a1 && ((v42 | ((a1[50] & 0x10) >> 4)) & 1) == 0)
          {
            *char v17 = v23;
            if (v23 != sub_10003965C((uint64_t)a1)
              && !sub_10001E24C( a1,  v17,  a2,  (a7 != 0) | (((*(unsigned __int16 *)(a1[7] + 32) >> 3) & 1) << 6) | 6u,  0,  a7,  &v50))
            {
              uint64_t v24 = v50;
              if ((*(_WORD *)(v50[7] + 32) & 2) != 0
                && !sub_100021744((uint64_t)v50, v43, (unsigned __int16)a4, &v48, (BOOL *)&v47)
                && v47)
              {
                if ((*(_WORD *)(v24[7] + 32) & 2) == 0) {
                  goto LABEL_53;
                }
                goto LABEL_39;
              }

              sub_10003D514((uint64_t)v24, 2);
              sub_100038824(v24);
            }
          }
        }
      }

      uint64_t v19 = 2LL;
      sub_10003CF10((uint64_t)a1, 2);
      sub_10003DC28((char *)a1);
      unsigned __int16 v26 = a1 + 7;
      uint64_t v25 = a1[7];
      if ((*(_WORD *)(v25 + 32) & 2) == 0)
      {
        char v27 = 0;
        uint64_t v28 = 2LL;
        uint64_t v24 = a1;
        while (1)
        {
          if (!*(_DWORD *)(v25 + 36))
          {
            uint64_t v19 = v28;
            goto LABEL_34;
          }

          uint64_t v29 = sub_100021744((uint64_t)v24, v43, (unsigned __int16)a4, &v48, (BOOL *)&v47);
          if ((_DWORD)v29
            || (v30 = v48, uint64_t v29 = sub_10001E938((uint64_t)v24, v48, v17), (_DWORD)v29)
            || (uint64_t v29 = sub_10001E24C(a1, v17, a2, 3, *(_WORD *)(*v26 + 34LL) - 1, a7, &v49), (_DWORD)v29))
          {
            uint64_t v19 = v29;
            int v50 = v24;
            goto LABEL_55;
          }

          if ((a1[50] & 0x10) != 0 && v49[14] != *v17) {
            sub_100021784((uint64_t)v24, v30, v49 + 14, a7);
          }
          BOOL v31 = v42;
          if (v24 != a1) {
            BOOL v31 = 0;
          }
          if (!v31)
          {
            sub_10003D514((uint64_t)v24, 2);
            sub_100038824(v24);
          }

          uint64_t v24 = v49;
          if (!v49) {
            break;
          }
          uint64_t v28 = 0LL;
          uint64_t v19 = 0LL;
          unsigned __int16 v26 = v49 + 7;
          uint64_t v25 = v49[7];
          char v27 = 1;
          if ((*(_WORD *)(v25 + 32) & 2) != 0) {
            goto LABEL_34;
          }
        }

        int v50 = 0LL;
        goto LABEL_53;
      }

      char v27 = 0;
      uint64_t v24 = a1;
LABEL_34:
      int v50 = v24;
      if ((*(_WORD *)(v24[7] + 32) & 2) == 0)
      {
        if ((v27 & 1) == 0) {
          goto LABEL_54;
        }
        goto LABEL_53;
      }

      uint64_t v19 = sub_100021744((uint64_t)v24, v43, (unsigned __int16)a4, &v48, (BOOL *)&v47);
      if ((_DWORD)v19)
      {
LABEL_54:
        uint64_t v24 = v50;
        if (v50)
        {
LABEL_55:
          sub_10003D514((uint64_t)v24, 2);
          sub_100038824(v24);
        }

        char v39 = !v42;
        if (v24 == a1) {
          char v39 = 1;
        }
        if ((v39 & 1) == 0)
        {
          sub_10003D514((uint64_t)a1, 2);
          sub_100038824(a1);
        }

        return v19;
      }

      if (!v47)
      {
LABEL_53:
        uint64_t v19 = 2LL;
        goto LABEL_54;
      }

LABEL_39:
      unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
      int v45 = 0;
      unsigned __int16 v44 = -21846;
      unsigned int v32 = v48;
      int v33 = sub_10001E654((uint64_t)v24, v48, &v46, &v44);
      uint64_t v34 = v41;
      if (!v33)
      {
        uint64_t v35 = (const void *)v46;
        uint64_t v36 = a1[1];
        if (!v36) {
          uint64_t v36 = *(void *)(*a1 + 392);
        }
        if (!((unsigned int (*)(uint64_t, unint64_t, void, unint64_t *, uint64_t, int *))a1[52])( v36,  v46,  v44,  v43,  a4,  &v45)
          && v45)
        {
          panic( "you can't change a key here!  (ekey %p eklen %d; key %p klen %d; n %p bt %p)\n",
            v35,
            v44,
            v43,
            a4,
            v24,
            a1);
        }
      }

      uint64_t v19 = sub_1000209D8((uint64_t)v24, v32, v43, (unsigned __int16)a4, v40, (unsigned __int16)a6, a7);
      if ((_DWORD)v19) {
        goto LABEL_54;
      }
      uint64_t v37 = a1[49];
      unsigned int v38 = *(_DWORD *)(v37 + 16);
      if (*(_DWORD *)(v37 + 20) >= a6)
      {
        if (v38 >= a4 && (a1[50] & 0x80) == 0)
        {
LABEL_63:
          if (v34)
          {
            *uint64_t v34 = sub_10003965C((uint64_t)v24);
            v34[1] = (uint64_t)a1;
          }

          goto LABEL_54;
        }
      }

      else
      {
        *(_DWORD *)(v37 + 20) = a6;
      }

      sub_10003E644((uint64_t)a1, a7, 0LL);
      goto LABEL_63;
    }
  }

  return v19;
}

  if (!(_DWORD)v9)
  {
    __int16 v13 = v22;
    if (v22)
    {
      if ((_DWORD)a4 != 1) {
        goto LABEL_48;
      }
LABEL_42:
      uint64_t v19 = *(void *)(v13[49] + 32);
      if (v19 <= v8[152])
      {
        uint64_t v20 = 0;
      }

      else if (*(_BYTE *)(a3 + 970))
      {
        uint64_t v20 = 1;
      }

      else
      {
        sub_100013D94( "%s:%d: %s tier2 free queue tree is too large: %lld nodes (limit %d) xid %lld\n",  "spaceman_checkpoint_traverse",  3137,  (const char *)(*(void *)(a1 + 384) + 208LL),  v19,  v8[152],  *(void *)(a2 + 16));
        uint64_t v20 = 1;
        __int16 v13 = v22;
      }

      *(_BYTE *)(a3 + 970) = v20;
      goto LABEL_48;
    }
  }

uint64_t sub_100024154( uint64_t *a1, uint64_t a2, unint64_t *a3, uint64_t a4, void *a5, unsigned int a6, uint64_t a7)
{
  return sub_100023C40(a1, a2, a3, a4, a5, a6, a7, 0LL);
}

uint64_t sub_10002415C( uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int a4, uint64_t a5, unsigned int a6, int a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a10)
{
  uint64_t v34 = a3;
  __chkstk_darwin();
  size_t v18 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((char *)&v30 - v17);
  bzero((char *)&v30 - v17, v19);
  uint64_t v37 = 0LL;
  if (!*(void *)(a1 + 416)) {
    return 22LL;
  }
  uint64_t v32 = a5;
  int v33 = a7;
  uint64_t v20 = sub_10001DA64(a1, a4, a6);
  if (!(_DWORD)v20)
  {
    sub_10003CF10(a1, 2);
    uint64_t v21 = sub_10003CF9C((void *)a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a8);
    if ((_DWORD)v21)
    {
      uint64_t v20 = v21;
      sub_10003D514(a1, 2);
    }

    else
    {
      unsigned int v30 = a9;
      uint64_t v31 = a10;
      unsigned __int16 v36 = -21846;
      char v35 = -86;
      sub_10003DC28((char *)a1);
      char v23 = 0;
      uint64_t v24 = 2LL;
      uint64_t v25 = (uint64_t *)a1;
      while (1)
      {
        unsigned __int16 v26 = v25;
        uint64_t v27 = v25[7];
        if ((*(_WORD *)(v27 + 32) & 2) != 0)
        {
          uint64_t v24 = sub_100021744((uint64_t)v25, v34, (unsigned __int16)a4, &v36, (BOOL *)&v35);
          if ((_DWORD)v24) {
            goto LABEL_24;
          }
          if (v35)
          {
            uint64_t v24 = sub_10002446C( (uint64_t)v25,  v36,  (uint64_t)v34,  (unsigned __int16)a4,  v32,  (unsigned __int16)a6,  v33,  a8,  v30,  v31);
            goto LABEL_24;
          }

          goto LABEL_23;
        }

        if (!*(_DWORD *)(v27 + 36)) {
          break;
        }
        uint64_t v28 = sub_100021744((uint64_t)v25, v34, (unsigned __int16)a4, &v36, (BOOL *)&v35);
        if ((_DWORD)v28
          || (v29 = v36, uint64_t v28 = sub_10001E938((uint64_t)v25, v36, v18), (_DWORD)v28)
          || (uint64_t v28 = sub_10001E24C((void *)a1, v18, a2, 3, *(_WORD *)(v25[7] + 34) - 1, a8, &v37), (_DWORD)v28))
        {
          uint64_t v20 = v28;
          sub_10003D514((uint64_t)v25, 2);
          sub_100038824(v25);
          return v20;
        }

        uint64_t v25 = (uint64_t *)v37;
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && *(void *)(v37 + 112) != *v18) {
          sub_100021784((uint64_t)v26, v29, (unint64_t *)(v37 + 112), a8);
        }
        uint64_t v20 = 2LL;
        sub_10003D514((uint64_t)v26, 2);
        sub_100038824(v26);
        uint64_t v24 = 0LL;
        char v23 = 1;
        if (!v25) {
          return v20;
        }
      }

      if ((v23 & 1) == 0) {
        goto LABEL_24;
      }
LABEL_23:
      uint64_t v24 = 2LL;
LABEL_24:
      sub_10003D514((uint64_t)v25, 2);
      sub_100038824(v25);
      uint64_t v20 = v24;
      if (!(_DWORD)v24)
      {
        if ((*(_BYTE *)(a1 + 400) & 0x80) != 0) {
          sub_10003E644(a1, a8, 0LL);
        }
        return 0LL;
      }
    }
  }

  return v20;
}

uint64_t sub_10002446C( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a10)
{
  uint64_t v10 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v10 + 36) <= a2) {
    return 22LL;
  }
  __int16 v17 = *(_WORD *)(v10 + 32);
  uint64_t v18 = *(void *)(a1 + 376);
  if ((v17 & 4) != 0) {
    size_t v19 = (unsigned __int16 *)(v18 + 4LL * a2);
  }
  else {
    size_t v19 = (unsigned __int16 *)(v18 + 8LL * a2);
  }
  uint64_t v20 = *v19;
  uint64_t v21 = (unsigned __int16 *)(v18 + 4LL * a2 + 2);
  if ((v17 & 4) == 0) {
    uint64_t v21 = (unsigned __int16 *)(v18 + 8LL * a2 + 4);
  }
  uint64_t v22 = *v21;
  if (v20 == 0xFFFF)
  {
    uint64_t v23 = 0LL;
  }

  else if ((v17 & 4) != 0)
  {
    uint64_t v23 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }

  else
  {
    uint64_t v23 = *(unsigned __int16 *)(v18 + 8LL * a2 + 2);
  }

  if (v22 > 0xFFFD)
  {
    uint64_t v24 = 0LL;
    if (!(_DWORD)v23) {
      goto LABEL_17;
    }
  }

  else
  {
    uint64_t v24 = sub_10001E5DC(a1, a2);
    if (!(_DWORD)v23) {
      goto LABEL_17;
    }
  }

  uint64_t result = sub_10001E710(a1, v20, v23);
  if ((_DWORD)result) {
    return result;
  }
LABEL_17:
  if (!(_DWORD)v24)
  {
    if ((_DWORD)v20 != 0xFFFF)
    {
LABEL_27:
      else {
        int v28 = a7;
      }
      uint64_t result = 22LL;
      if ((_DWORD)v23 == (_DWORD)a4 && v28)
      {
        uint64_t result = a9(*(void *)(a1 + 384) + v20, v23, a3, a4, *(void *)(a1 + 392) - v22, v24, a5, a6, a10);
        if (!(_DWORD)result)
        {
          sub_10003E644(a1, a8, 0LL);
          return 0LL;
        }
      }

      return result;
    }

    return 22LL;
  }

  LODWORD(va_start(va, result) = sub_10001E838(a1, v22, v24);
  int v26 = result;
  if ((_DWORD)result) {
    uint64_t result = result;
  }
  else {
    uint64_t result = 22LL;
  }
  if ((_DWORD)v20 != 0xFFFF && v26 == 0) {
    goto LABEL_27;
  }
  return result;
}

uint64_t sub_10002461C( uint64_t a1, uint64_t a2, int a3, unint64_t *a4, unsigned int a5, void *a6, unsigned int *a7, void *a8, unsigned int *a9, uint64_t a10)
{
  __int128 v143 = 0u;
  __int128 v144 = 0u;
  __int128 v142 = 0u;
  uint64_t v141 = 0LL;
  __chkstk_darwin();
  size_t v19 = (uint64_t *)((char *)&v111 - v18);
  bzero((char *)&v111 - v18, v20);
  memset(v140, 170, sizeof(v140));
  unsigned __int16 v139 = a5;
  unsigned __int16 v138 = -21846;
  unsigned __int16 v137 = -21846;
  unsigned __int16 v136 = -21846;
  if (!*(void *)(a1 + 416)) {
    return 22LL;
  }
  unint64_t v21 = *(void *)(a1 + 400);
  uint64_t v22 = (v21 >> 9) & 0x3FFF;
  if (!v22)
  {
    return 22LL;
  }

  if ((_DWORD)v22 != a5) {
    return 22LL;
  }
LABEL_4:
  int v128 = *(unsigned __int16 *)(*(void *)(a1 + 392) + 16LL);
  int v124 = a8;
  uint64_t v131 = a2;
  sub_10003CF10(a1, 2);
  uint64_t v23 = sub_10003CF9C(a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a10);
  if ((_DWORD)v23)
  {
    uint64_t v24 = v23;
    sub_10003D514(a1, 2);
    return v24;
  }

  int v121 = a6;
  uint64_t v123 = a10;
  int v122 = &v111;
  *(void *)&__int128 v142 = a1;
  sub_10003DC28((char *)a1);
  uint64_t v26 = sub_1000256D8( v142,  a3,  1,  a4,  &v139,  (unsigned __int16)a5,  (_WORD *)&v142 + 4,  (BOOL *)((unint64_t)&v142 | 0xA));
  if ((_DWORD)v26)
  {
LABEL_10:
    uint64_t v24 = v26;
    goto LABEL_11;
  }

  uint64_t v132 = (BOOL *)((unint64_t)&v142 | 0xA);
  uint64_t v126 = (_WORD *)&v142 + 4;
  uint64_t v27 = 0LL;
  uint64_t v129 = 0LL;
  int v120 = 0;
  char v29 = 0;
  int v113 = a9;
  uint64_t v118 = (_WORD *)&v143 + 4;
  int v119 = (v128 + 7) & 0x1FFF8;
  int v125 = &v144;
  uint64_t v116 = (_WORD *)&v144 + 4;
  uint64_t v117 = (BOOL *)&v143 + 10;
  __int16 v115 = (BOOL *)&v144 + 10;
  unint64_t v127 = a4;
  uint64_t v30 = v123;
  uint64_t v114 = a7;
  uint64_t v31 = v121;
  while (1)
  {
    if ((v29 & 1) != 0)
    {
      int v130 = 1;
      uint64_t v32 = v143;
    }

    else
    {
      uint64_t v32 = v143;
      if (BYTE10(v142)) {
        BOOL v33 = WORD4(v142) == 0;
      }
      else {
        BOOL v33 = 0;
      }
      if (v33)
      {
        int v120 = WORD4(v143);
        int v130 = 1;
        uint64_t v27 = v142;
        uint64_t v129 = v143;
      }

      else
      {
        int v130 = 0;
      }
    }

    uint64_t v34 = v132;
    if (!v32 || (*(_DWORD *)(a1 + 400) & 0x7FFE00) != 0) {
      goto LABEL_94;
    }
    uint64_t v135 = 0LL;
    if (BYTE10(v142))
    {
      uint64_t v35 = sub_10001E654(v32, WORD4(v143), &v140[2], &v136);
      if ((_DWORD)v35) {
        goto LABEL_106;
      }
      __int16 v36 = v128;
      if ((*(void *)(v143 + 400) & 0x40LL) == 0) {
        __int16 v36 = v119;
      }
      __int16 v37 = v136;
      if ((*(void *)(v143 + 400) & 0x40LL) == 0) {
        __int16 v37 = (v136 + 7) & 0xFFF8;
      }
      __int16 v38 = v36 - v37;
      if (v38 < 0) {
        __int16 v39 = 0;
      }
      else {
        __int16 v39 = v38;
      }
    }

    else
    {
      __int16 v39 = 0;
    }

    __int16 v134 = sub_1000219F0(v142);
    int v40 = (void *)v143;
    __int16 v133 = (*(_WORD *)(v142 + 406) & 0x7F) + 8;
    if (sub_100021854(v143, 1u, &v134, &v133, v39, 0, 0LL))
    {
      uint64_t v30 = v123;
LABEL_36:
      uint64_t v34 = v132;
      goto LABEL_94;
    }

    unsigned __int16 v41 = WORD4(v143);
    if (!BYTE10(v143)) {
      unsigned __int16 v41 = WORD4(v143) + 1;
    }
    BOOL v42 = a4;
    uint64_t v43 = v139;
    uint64_t v35 = sub_100021A68( (void *)a1,  (void *)v144,  WORD4(v144),  v40,  v41,  v42,  v139,  1LL,  &v134,  &v133,  v39,  v131,  v123,  &v135);
    if ((_DWORD)v35)
    {
LABEL_106:
      uint64_t v24 = v35;
      goto LABEL_107;
    }

    uint64_t v44 = v135;
    uint64_t v34 = v132;
    if (!v135)
    {
      a4 = v127;
      uint64_t v30 = v123;
      goto LABEL_94;
    }

    uint64_t v45 = v143;
    uint64_t v30 = v123;
    uint64_t v112 = v143;
    if ((void)v144)
    {
      ++WORD4(v144);
      if ((void)v143)
      {
        if (v129 == (void)v143 || (void)v143 == v27)
        {
          uint64_t v49 = v143;
        }

        else
        {
          uint64_t v46 = v135;
          uint64_t v47 = v143;
          sub_10003D514(v143, 2);
          uint64_t v48 = v47;
          uint64_t v44 = v46;
          sub_100038824(v48);
          uint64_t v49 = 0LL;
        }
      }

      else
      {
        uint64_t v49 = 0LL;
      }

      goto LABEL_58;
    }

    *(void *)&__int128 v144 = v143;
    if (*(_DWORD *)(*(void *)(v135 + 56) + 36LL))
    {
      uint64_t v111 = v135;
      uint64_t v35 = sub_10001E654(v135, 0, &v140[2], &v136);
      if ((_DWORD)v35) {
        goto LABEL_106;
      }
      uint64_t v45 = v144;
      int v50 = (unint64_t *)v140[2];
      uint64_t v51 = v136;
    }

    else
    {
      if ((a3 & 1) != 0)
      {
        if (!*(_DWORD *)(*(void *)(v143 + 56) + 36LL)) {
          goto LABEL_149;
        }
        uint64_t v49 = 0LL;
        WORD4(v144) = 0;
        BYTE10(v144) = 1;
        goto LABEL_58;
      }

      uint64_t v111 = v135;
      int v50 = v127;
      uint64_t v51 = v43;
    }

    uint64_t v24 = sub_100021744(v45, v50, v51, v116, v115);
    if ((_DWORD)v24) {
      goto LABEL_107;
    }
    uint64_t v49 = 0LL;
    uint64_t v44 = v111;
LABEL_58:
    BOOL v52 = v129 != (void)v144 || v129 == 0;
    int v53 = v120;
    if (!v52) {
      int v53 = WORD4(v144);
    }
    int v120 = v53;
    *(void *)&__int128 v143 = v44;
    if (a3)
    {
      if (!*(_DWORD *)(*(void *)(v44 + 56) + 36LL))
      {
LABEL_149:
        uint64_t v24 = 2LL;
LABEL_107:
        uint64_t v141 = v27;
LABEL_108:
        uint64_t v28 = v129;
        goto LABEL_109;
      }

      WORD4(v143) = 0;
      BYTE10(v143) = 1;
    }

    else
    {
      uint64_t v35 = sub_100021744(v44, v127, v43, v118, v117);
      if ((_DWORD)v35) {
        goto LABEL_106;
      }
    }

    uint64_t v54 = v142;
    sub_10003D514(v142, 2);
    sub_100038824(v54);
    *(void *)&__int128 v142 = 0LL;
    uint64_t v35 = sub_10001E938(v143, WORD4(v143), v19);
    if ((_DWORD)v35) {
      goto LABEL_106;
    }
    uint64_t v35 = sub_10001E24C((void *)a1, v19, v131, 3, *(_WORD *)(*(void *)(v143 + 56) + 34LL) - 1, v30, &v142);
    if ((_DWORD)v35) {
      goto LABEL_106;
    }
    uint64_t v55 = v142;
    if ((*(_BYTE *)(a1 + 400) & 0x10) != 0)
    {
      a4 = v127;
      if (*(void *)(v142 + 112) != *v19)
      {
        sub_100021784(v143, WORD4(v143), (unint64_t *)(v142 + 112), v30);
        uint64_t v55 = v142;
      }
    }

    else
    {
      a4 = v127;
    }

    uint64_t v35 = sub_1000256D8(v55, a3, 1, a4, &v139, (unsigned __int16)a5, v126, v132);
    if ((_DWORD)v35) {
      goto LABEL_106;
    }
    if (v129 == v112)
    {
      int v58 = WORD4(v143);
      uint64_t v56 = v49;
      if (v129 == a1 && !WORD4(v143))
      {
        uint64_t v27 = v143;
        uint64_t v129 = a1;
        uint64_t v34 = v132;
        uint64_t v31 = v121;
        goto LABEL_94;
      }

      int v57 = v130;
      uint64_t v31 = v121;
      if (!WORD4(v143))
      {
        int v120 = WORD4(v144);
        goto LABEL_85;
      }

      goto LABEL_89;
    }

    uint64_t v56 = v49;
    if ((v130 & 1) != 0)
    {
      int v57 = 1;
      uint64_t v31 = v121;
      goto LABEL_90;
    }

    int v58 = WORD4(v143);
    uint64_t v31 = v121;
    if (BYTE10(v143) && !WORD4(v143))
    {
      int v120 = WORD4(v144);
      int v57 = 1;
LABEL_85:
      uint64_t v129 = v144;
      uint64_t v27 = v143;
      goto LABEL_90;
    }

    int v57 = 0;
    if (BYTE10(v142) && !WORD4(v142))
    {
      int v57 = 1;
LABEL_89:
      uint64_t v129 = v143;
      uint64_t v27 = v142;
      int v120 = v58;
    }

LABEL_90:
    int v130 = v57;
    if (!v56) {
      goto LABEL_36;
    }
    uint64_t v34 = v132;
    if (v56 != v129 && v56 != v27)
    {
      sub_10003D514(v56, 2);
      sub_100038824(v56);
      goto LABEL_36;
    }

    uint64_t v54 = *(void *)(v9 + 56);
    if ((*(_WORD *)(v54 + 32) & 4) != 0)
    {
      if ((*(_BYTE *)(v9 + 400) & 4) == 0)
      {
LABEL_96:
        *(_WORD *)(v9 + 440) = 0;
        sub_10003E644(a1, a4, 0LL);
        sub_10003E644(a2, a4, 0LL);
        return v15;
      }

      uint64_t v55 = 4;
    }

    else
    {
      uint64_t v55 = 8;
    }

    uint64_t v56 = sub_10001E4C4(v9, 8);
    goto LABEL_96;
  }

  return v15;
}

LABEL_94:
    if ((*(_WORD *)(*(void *)(v142 + 56) + 32LL) & 2) != 0) {
      break;
    }
    uint64_t v59 = v144;
    if ((void)v144 && (void)v144 != v129 && (void)v144 != v27)
    {
      sub_10003D514(v144, 2);
      sub_100038824(v59);
    }

    *int v125 = v143;
    __int128 v143 = v142;
    *(void *)&__int128 v142 = 0LL;
    uint64_t v35 = sub_10001E938(v143, WORD4(v143), v19);
    if (!(_DWORD)v35)
    {
      uint64_t v35 = sub_10001E24C((void *)a1, v19, v131, 3, *(_WORD *)(*(void *)(v143 + 56) + 34LL) - 1, v30, &v142);
      if (!(_DWORD)v35)
      {
        uint64_t v60 = v142;
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0)
        {
          a4 = v127;
          if (*(void *)(v142 + 112) != *v19)
          {
            sub_100021784(v143, WORD4(v143), (unint64_t *)(v142 + 112), v30);
            uint64_t v60 = v142;
          }
        }

        else
        {
          a4 = v127;
        }

        uint64_t v35 = sub_1000256D8(v60, a3, 1, a4, &v139, (unsigned __int16)a5, v126, v132);
        char v29 = v130;
        if (!(_DWORD)v35) {
          continue;
        }
      }
    }

    goto LABEL_106;
  }

  uint64_t v141 = v27;
  uint64_t v65 = sub_1000256D8(v142, a3, 1, a4, &v139, (unsigned __int16)a5, v126, v34);
  if ((_DWORD)v65) {
    goto LABEL_136;
  }
  if (!BYTE10(v142))
  {
    uint64_t v24 = 2LL;
    goto LABEL_108;
  }

  if (!v31) {
    goto LABEL_146;
  }
  uint64_t v65 = sub_10001E654(v142, 0, &v140[1], &v138);
  if ((_DWORD)v65)
  {
LABEL_136:
    uint64_t v24 = v65;
    goto LABEL_108;
  }

  unsigned int v66 = v138;
  unsigned int v67 = v114;
  unsigned int v68 = *v114;
  if (*v114 >= v138) {
    size_t v69 = v138;
  }
  else {
    size_t v69 = v68;
  }
  memcpy(v31, v140[1], v69);
  *unsigned int v67 = v66;
  BOOL v70 = v68 >= v66;
  uint64_t v30 = v123;
  if (!v70)
  {
    uint64_t v24 = 34LL;
    goto LABEL_108;
  }

LABEL_146:
  uint64_t v28 = v129;
  if (v124)
  {
    uint64_t v71 = sub_10001E764((void *)v142, 0, v140, (__int16 *)&v137);
    if ((_DWORD)v71) {
      goto LABEL_148;
    }
    unsigned int v72 = v137;
    unsigned int v73 = v137 == 65534 ? 0 : v137;
    uint64_t v74 = v113;
    unsigned int v75 = *v113;
    size_t v76 = *v113 >= v73 ? v73 : v75;
    memcpy(v124, v140[0], v76);
    *uint64_t v74 = v72;
    uint64_t v30 = v123;
    if (v75 < v73)
    {
      uint64_t v24 = 34LL;
      goto LABEL_109;
    }
  }

  sub_1000257A4(v142, WORD4(v142), v30);
  __int16 v77 = (unint64_t *)(*(void *)(a1 + 392) + 24LL);
  do
    unint64_t v78 = __ldxr(v77);
  while (__stxr(v78 - 1, v77));
  sub_10003E644(a1, v30, 0LL);
  if (WORD4(v142) || (*(_DWORD *)(*(void *)(v142 + 56) + 36LL) ? (BOOL v79 = (void)v143 == 0LL) : (BOOL v79 = 1), v79))
  {
    uint64_t v24 = 0LL;
  }

  else
  {
    uint64_t v87 = sub_10001E654(v142, 0, &v140[2], &v136);
    uint64_t v24 = v87;
    if ((_DWORD)v87 || (uint64_t v24 = sub_1000209D8(v143, WORD4(v143), (void *)v140[2], v136, 0LL), (_DWORD)v24))
    {
      uint64_t v88 = *(void *)(a1 + 8);
      if (v88) {
        int v89 = (const char *)(v88 + 3992);
      }
      else {
        int v89 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
      }
      sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_remove_internal", 5065, v89, v24);
    }

    uint64_t v28 = v129;
  }

  int v80 = sub_100025A70(a1, v142);
  uint64_t v81 = v144;
  int v82 = v130;
  if ((void)v144)
  {
    if ((void)v144 != v28 && (void)v144 != v27)
    {
      sub_10003D514(v144, 2);
      sub_100038824(v81);
      int v82 = v130;
    }

    *(void *)&__int128 v144 = 0LL;
  }

  uint64_t v83 = v143;
  if ((void)v143)
  {
    if ((void)v143 != v28 && (void)v143 != v27)
    {
      sub_10003D514(v143, 2);
      sub_100038824(v83);
      int v82 = v130;
    }

    *(void *)&__int128 v143 = 0LL;
  }

  if (v82 && *(_DWORD *)(*(void *)(v142 + 56) + 36LL))
  {
    uint64_t v71 = sub_10001E654(v142, 0, &v140[2], &v136);
    if ((_DWORD)v71)
    {
LABEL_148:
      uint64_t v24 = v71;
      goto LABEL_109;
    }

    if (v28)
    {
      uint64_t v84 = sub_1000209D8(v129, (unsigned __int16)v120, (void *)v140[2], v136, 0LL);
      uint64_t v24 = v84;
      if ((_DWORD)v84)
      {
        uint64_t v85 = *(void *)(a1 + 8);
        if (v85) {
          int v86 = (const char *)(v85 + 3992);
        }
        else {
          int v86 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_remove_internal", 5091, v86, v84);
      }

      if (v129 != (void)v144 && v129 != (void)v143 && v129 != (void)v142)
      {
        uint64_t v90 = v129;
        sub_10003D514(v129, 2);
        sub_100038824(v90);
      }
    }

    else
    {
      uint64_t v24 = 0LL;
    }

    uint64_t v91 = v141;
    uint64_t v92 = v141 + 56;
    if ((*(_WORD *)(*(void *)(v141 + 56) + 32LL) & 2) == 0)
    {
      uint64_t v93 = v139;
      int v94 = (void *)v140[2];
      while (1)
      {
        LOWORD(v135) = -21846;
        LOBYTE(v134) = -86;
        uint64_t v27 = v91;
        uint64_t v95 = sub_100021744(v91, v127, v93, &v135, (BOOL *)&v134);
        if ((_DWORD)v95)
        {
          uint64_t v24 = v95;
          goto LABEL_12;
        }

        if (!(_BYTE)v134) {
          break;
        }
        if (*(_WORD *)(*(void *)v92 + 34LL) == 1)
        {
          uint64_t v101 = *(void *)(a1 + 8);
          if (v101) {
            uint64_t v102 = (const char *)(v101 + 3992);
          }
          else {
            uint64_t v102 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
          }
          uint64_t v103 = sub_10003965C(v27);
          int v104 = sub_1000398B8(v27);
          sub_100013D94( "%s:%d: %s minkey update traversal unexpectedly found the removed key in level 1 node; oid %llu subtype 0x%x level %d\n",
            "bt_remove_internal",
            5114,
            v102,
            v103,
            v104,
            *(unsigned __int16 *)(*(void *)v92 + 34LL));
          break;
        }

        unsigned int v96 = (unsigned __int16)v135;
        int v97 = sub_1000209D8(v27, (unsigned __int16)v135, v94, v136, 0LL);
        if (v97)
        {
          uint64_t v98 = *(void *)(a1 + 8);
          if (v98) {
            uint64_t v99 = (const char *)(v98 + 3992);
          }
          else {
            uint64_t v99 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
          }
          sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_remove_internal", 5120, v99, v97);
        }

        uint64_t v24 = sub_10001E938(v27, v96, v19);
        __int16 v100 = *(_WORD *)(*(void *)v92 + 34LL);
        uint64_t v141 = 0LL;
        if (!(_DWORD)v24) {
          uint64_t v24 = sub_10001E24C((void *)a1, v19, v131, 3, v100 - 1, v123, &v141);
        }
        if (v27 != (void)v144 && v27 != (void)v143 && v27 != (void)v142)
        {
          sub_10003D514(v27, 2);
          sub_100038824(v27);
        }

        if (!(_DWORD)v24)
        {
          uint64_t v91 = v141;
          uint64_t v92 = v141 + 56;
          if ((*(_WORD *)(*(void *)(v141 + 56) + 32LL) & 2) == 0) {
            continue;
          }
        }

        goto LABEL_227;
      }

      uint64_t v24 = 0LL;
    }
  }

  else if (v28 && v28 != (void)v144 && v28 != (void)v142)
  {
    sub_10003D514(v28, 2);
    sub_100038824(v28);
  }

LABEL_240:
  uint64_t v109 = v142;
  sub_10003D514(v142, 2);
  sub_100038824(v109);
  *(void *)&__int128 v142 = 0LL;
  if (v80)
  {
    sub_100025B1C(a1, v131, v106, v108, v123);
    if (v106 != v127) {
      sub_100014004(v106, v108);
    }
  }

uint64_t sub_1000256D8( uint64_t a1, char a2, int a3, unint64_t *a4, _WORD *a5, unsigned int a6, _WORD *a7, BOOL *a8)
{
  if ((a2 & 1) == 0) {
    return sub_100021744(a1, a4, (unsigned __int16)*a5, a7, a8);
  }
  if (!*(_DWORD *)(*(void *)(a1 + 56) + 36LL)) {
    return 2LL;
  }
  uint64_t v10 = 0LL;
  *a7 = 0;
  *a8 = 1;
  if (a3)
  {
    __src = (void *)0xAAAAAAAAAAAAAAAALL;
    unsigned __int16 v14 = -21846;
    uint64_t v10 = sub_10001E654(a1, 0, &__src, &v14);
    if (!(_DWORD)v10)
    {
      if (v14 >= a6) {
        size_t v12 = a6;
      }
      else {
        size_t v12 = v14;
      }
      *a5 = v12;
      memcpy(a4, __src, v12);
    }
  }

  return v10;
}

void sub_1000257A4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  int v7 = *(_WORD *)(v6 + 32) & 4;
  if (v7) {
    unsigned int v8 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    unsigned int v8 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 8LL * a2 + 2);
  }
  if (*(unsigned __int16 *)(a1 + 440) <= v8)
  {
    *(_WORD *)(a1 + 440) = 0;
    int v7 = *(_WORD *)(v6 + 32) & 4;
  }

  uint64_t v9 = *(void *)(a1 + 376);
  uint64_t v10 = (unsigned __int16 *)(v9 + 4LL * a2);
  unsigned int v11 = (unsigned __int16 *)(v9 + 8LL * a2);
  if (v7) {
    size_t v12 = v10;
  }
  else {
    size_t v12 = v11;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = *(void *)(a1 + 400);
  if ((v14 & 0x40) != 0) {
    unsigned __int16 v15 = v8;
  }
  else {
    unsigned __int16 v15 = (v8 + 7) & 0xFFF8;
  }
  if (v13 != 0xFFFF)
  {
    int v16 = sub_10001E710(a1, v13, v15);
    uint64_t v6 = *(void *)(a1 + 56);
    uint64_t v14 = *(void *)(a1 + 400);
    if (!v16)
    {
      unsigned __int16 v17 = (v15 + 7) & 0xFFF8;
      if ((v14 & 0x40) != 0) {
        unsigned __int16 v17 = v15;
      }
      if (v17 >= 4u)
      {
        uint64_t v18 = (_WORD *)(*(void *)(a1 + 384) + v13);
        v18[1] = v17;
        *uint64_t v18 = *(_WORD *)(v6 + 48);
        *(_WORD *)(v6 + 48) = v13;
      }

      *(_WORD *)(v6 + 50) += v17;
      uint64_t v14 = *(void *)(a1 + 400);
    }
  }

  uint64_t v19 = *(void *)(a1 + 376);
  uint64_t v20 = v19 + 4LL * a2 + 2;
  uint64_t v21 = v19 + 8LL * a2 + 4;
  if ((*(_WORD *)(v6 + 32) & 4) != 0) {
    uint64_t v22 = (unsigned __int16 *)v20;
  }
  else {
    uint64_t v22 = (unsigned __int16 *)v21;
  }
  unint64_t v23 = *v22;
  unsigned __int16 v24 = sub_10001E5DC(a1, a2);
  if ((v14 & 0x40) != 0) {
    unsigned __int16 v25 = v24;
  }
  else {
    unsigned __int16 v25 = (v24 + 7) & 0xFFF8;
  }
  if (v23 <= 0xFFFD)
  {
    int v26 = sub_10001E838(a1, v23, v25);
    uint64_t v6 = *(void *)(a1 + 56);
    if (!v26)
    {
      if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
        unsigned __int16 v27 = v25;
      }
      else {
        unsigned __int16 v27 = (v25 + 7) & 0xFFF8;
      }
      if (v27 >= 4u)
      {
        uint64_t v28 = (_WORD *)(*(void *)(a1 + 392) - v23);
        v28[1] = v27;
        *uint64_t v28 = *(_WORD *)(v6 + 52);
        *(_WORD *)(v6 + 52) = v23;
      }

      *(_WORD *)(v6 + 54) += v27;
    }
  }

  unsigned int v29 = *(_DWORD *)(v6 + 36) - 1;
  if (v29 > a2)
  {
    sub_100029FB8(a1, a2, -1);
    uint64_t v6 = *(void *)(a1 + 56);
    unsigned int v29 = *(_DWORD *)(v6 + 36) - 1;
  }

  *(_DWORD *)(v6 + 36) = v29;
  __int16 v30 = *(_WORD *)(v6 + 32);
  if ((v30 & 4) != 0)
  {
    if ((*(_BYTE *)(a1 + 400) & 4) == 0) {
      goto LABEL_50;
    }
    unsigned int v31 = 4;
  }

  else
  {
    unsigned int v31 = 8;
  }

  unsigned int v32 = *(unsigned __int16 *)(v6 + 42) / v31;
  if (v32 - v29 >= 0x10)
  {
    if ((v30 & 4) == 0)
    {
      __int16 v33 = 8;
LABEL_49:
      unsigned __int16 v40 = v33 * v31;
      memmove( (void *)(*(void *)(a1 + 384) - (unsigned __int16)(v33 * v31)),  *(const void **)(a1 + 384),  *(unsigned __int16 *)(v6 + 44));
      *(void *)(a1 + 384) -= v40;
      uint64_t v41 = *(void *)(a1 + 56);
      *(_WORD *)(v41 + 42) -= v40;
      *(_WORD *)(v41 + 46) += v40;
      goto LABEL_50;
    }

    unint64_t v34 = *(void *)(a1 + 400);
    if ((v30 & 2) != 0) {
      unint64_t v35 = v34 >> 23;
    }
    else {
      LODWORD(v35) = (HIWORD(v34) & 0x7F) + 8;
    }
    unint64_t v36 = (((v34 >> 27) & 0x1F000) - 56) / (((v34 >> 9) & 0x3FFF) + (unsigned __int16)v35 + 4);
    if (v32 > (v36 & 0xFFFE))
    {
      unsigned __int16 v37 = v36 & 0xFFFE;
      int v38 = v32 - 8;
      __int16 v39 = v32 - v37;
      if (v38 >= v37) {
        __int16 v33 = 8;
      }
      else {
        __int16 v33 = v39;
      }
      goto LABEL_49;
    }
  }

uint64_t sub_100025A70(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  int v3 = *(unsigned __int16 *)(v2 + 32);
  if ((~v3 & 3) == 0) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD *)(v2 + 36);
  if (!v4) {
    return 1LL;
  }
  if (*(void *)(a1 + 432) == *(void *)(a2 + 112)) {
    return 0LL;
  }
  if ((v3 & 4) != 0 && (*(_BYTE *)(a2 + 400) & 4) == 0) {
    return v4 < *(unsigned __int16 *)(v2 + 42) >> 3;
  }
  __int16 v7 = sub_1000398C8(a2);
  if ((*(_WORD *)(*(void *)(a2 + 56) + 32LL) & 1) != 0) {
    __int16 v8 = -96;
  }
  else {
    __int16 v8 = -56;
  }
  return sub_100029670(a2) > (unsigned __int16)((v8 + v7) & 0xFFFE) >> 1;
}

void sub_100025B1C(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v11 = (uint64_t *)((char *)&v44 - v10);
  bzero((char *)&v44 - v10, v12);
  v54[0] = 0xAAAAAAAAAAAAAAAALL;
  v54[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = *(void *)(a1 + 56);
  if (v13)
  {
    *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v55[2] = v14;
    v55[3] = v14;
    v55[0] = v14;
    v55[1] = v14;
    int v51 = -1431655766;
    unsigned __int16 v50 = -21846;
    unsigned __int16 v49 = -21846;
    unsigned int v15 = *(unsigned __int16 *)(v13 + 34);
    if (v15 >= 6)
    {
      uint64_t v16 = v15 + 11;
      uint64_t v18 = (unsigned __int16)(v15 + 11);
      unsigned __int16 v17 = (uint64_t *)sub_100014044(8 * v18);
      uint64_t v47 = sub_100014044(2 * v18);
    }

    else
    {
      uint64_t v16 = 8LL;
      uint64_t v47 = v54;
      unsigned __int16 v17 = (uint64_t *)v55;
    }

    sub_10003CF10(a1, 2);
    if (sub_10003CF9C(a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a5))
    {
      sub_10003D514(a1, 2);
      return;
    }

    *unsigned __int16 v17 = a1;
    sub_10003DC28((char *)a1);
    uint64_t v19 = *v17;
    if ((*(_WORD *)(*(void *)(*v17 + 56) + 32LL) & 2) != 0)
    {
      LOWORD(v21) = 0;
    }

    else
    {
      uint64_t v45 = v16;
      uint64_t v46 = a2;
      uint64_t v20 = 0LL;
      uint64_t v21 = 0LL;
      unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
      char v48 = -86;
      __int16 v22 = v16;
      if ((v16 & 0xFFFE) == 0) {
        __int16 v22 = 1;
      }
      uint64_t v23 = (unsigned __int16)(v22 - 1);
      unsigned __int16 v24 = v17 + 1;
      do
      {
        if (v23 == v21)
        {
          LOWORD(v16) = v45;
          LOWORD(v21) = v45 - 1;
          goto LABEL_66;
        }

        *unsigned int v11 = 0LL;
        if (sub_10001E938(*(v24 - 1), (unsigned __int16)v47[v21], v11)
          || sub_10001E24C( (void *)a1,  v11,  v46,  3,  *(_WORD *)(*(void *)(*(v24 - 1) + 56) + 34LL) - 1,  a5,  v24))
        {
          goto LABEL_65;
        }

        uint64_t v19 = *v24;
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && *(void *)(v19 + 112) != *v11)
        {
          sub_100021784(*(v24 - 1), (unsigned __int16)v47[v21], (unint64_t *)(v19 + 112), a5);
          uint64_t v19 = *v24;
        }

        ++v20;
        ++v24;
        ++v21;
      }

      while ((*(_WORD *)(*(void *)(v19 + 56) + 32LL) & 2) == 0);
      if ((_WORD)v21)
      {
        unsigned __int16 v25 = v21;
        LOWORD(v16) = v45;
        while (1)
        {
          uint64_t v26 = ((__int16)v25 - 1);
          else {
            uint64_t v27 = v17[(__int16)v25 + 1];
          }
          sub_10002A7C4( a1,  v17[v26],  (unsigned __int16)v47[v26],  v17[v25],  (unsigned __int16)v47[v25],  v27,  v46,  a5);
          int v28 = *(_DWORD *)(*(void *)(v17[v25] + 56) + 36LL);
          if ((__int16)v25 < 2 || v28)
          {
            if (v28)
            {
              int v51 = 0;
              uint64_t v37 = *(void *)(a1 + 8);
              if (!v37) {
                uint64_t v37 = *(void *)(*(void *)a1 + 392LL);
              }
              int v38 = (void *)v53;
              int v39 = (*(uint64_t (**)(uint64_t, unint64_t, void, unint64_t, void, int *))(a1 + 416))( v37,  v53,  v50,  v52,  v49,  &v51);
              if (!v39 && v51) {
                int v39 = sub_1000209D8(v17[v26], (unsigned __int16)v47[v26], v38, v50, 0LL);
              }
              if (v39) {
                goto LABEL_66;
              }
            }
          }

          else if (!v47[v26])
          {
            uint64_t v29 = (unsigned __int16)(v25 - 1);
            if (v25 != 1)
            {
              uint64_t v30 = v17[(unsigned __int16)(v25 - 1)];
              if (*(_DWORD *)(*(void *)(v30 + 56) + 36LL))
              {
                unsigned int v31 = &v47[v29];
                int v32 = v29 - 1;
                --v25;
                while (1)
                {
                  if (*v31--) {
                    goto LABEL_25;
                  }
                  int v34 = sub_10001E654(v30, 0, &v53, &v50);
                  if (v34) {
                    goto LABEL_61;
                  }
                  int v51 = 0;
                  int v34 = sub_10001E654(v17[v32], (unsigned __int16)v47[v32], &v52, &v49);
                  if (v34) {
                    goto LABEL_61;
                  }
                  uint64_t v35 = *(void *)(a1 + 8);
                  if (!v35) {
                    uint64_t v35 = *(void *)(*(void *)a1 + 392LL);
                  }
                  unint64_t v36 = (void *)v53;
                  int v34 = (*(uint64_t (**)(uint64_t, unint64_t, void, unint64_t, void, int *))(a1 + 416))( v35,  v53,  v50,  v52,  v49,  &v51);
                  if (!v34 && v51) {
                    int v34 = sub_1000209D8(v17[v32], (unsigned __int16)v47[v32], v36, v50, 0LL);
                  }
                  if (v34)
                  {
LABEL_61:
                    uint64_t v40 = *(void *)(a1 + 8);
                    if (v40) {
                      uint64_t v41 = (const char *)(v40 + 3992);
                    }
                    else {
                      uint64_t v41 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
                    }
                    sub_100013D94("%s:%d: %s updating grandparent failed w/%d\n", "bt_merge_up", 4628, v41, v34);
                    goto LABEL_65;
                  }

                  LOWORD(v26) = v26 - 1;
                  if ((_WORD)v26)
                  {
                    uint64_t v30 = v17[(unsigned __int16)v26];
                    --v32;
                    if (*(_DWORD *)(*(void *)(v30 + 56) + 36LL)) {
                      continue;
                    }
                  }

                  goto LABEL_25;
                }
              }
            }
          }

          --v25;
LABEL_56:
          if ((sub_100025A70(a1, v17[v25]) & 1) == 0) {
            goto LABEL_66;
          }
        }

        --v25;
        sub_10002A7C4(a1, 0LL, 0, *v17, (unsigned __int16)*v47, v17[1], v46, a5);
LABEL_25:
        if ((v25 & 0x8000) != 0) {
          goto LABEL_65;
        }
        LOWORD(v16) = v45;
        goto LABEL_56;
      }

      LOWORD(v21) = 0;
LABEL_65:
      LOWORD(v16) = v45;
    }

LABEL_66:
    int v42 = 0;
    do
    {
      uint64_t v43 = v17[(__int16)v42];
      sub_10003D514(v43, 2);
      sub_100038824(v43);
      ++v42;
    }

    while ((unsigned __int16)v21 >= (__int16)v42);
    if ((unsigned __int16)v16 >= 9u)
    {
      sub_100014004(v17, 8LL * (unsigned __int16)v16);
      sub_100014004(v47, 2LL * (unsigned __int16)v16);
    }
  }

    if ((v47 & 0x80000000) == 0)
    {
      uint64_t v61 = v47;
      uint64_t v62 = (const void *)v44;
      goto LABEL_75;
    }

    uint64_t v64 = (const void *)v44;
    uint64_t v65 = sub_1000332E0((uint64_t)v126, v44, v121, (uint64_t)v20, &v123);
    uint64_t v21 = v65;
    if ((_DWORD)v65 == 35)
    {
      if ((*(_BYTE *)(v50 + 1264) & 2) == 0) {
        goto LABEL_124;
      }
      sub_100013D94( "%s:%d: %s Couldn't load checkpoint from cleanly-unmounted state.  Falling back to descriptor scan.\n",  "nx_mount",  1626,  (const char *)(v126[48] + 208));
      *(void *)(v50 + 1264) &= ~2uLL;
      *(void *)(v44 + 1264) &= ~2uLL;
    }

    else
    {
      if ((_DWORD)v65)
      {
LABEL_124:
        sub_100013D94( "%s:%d: %s failed to find valid checkpoint: %d\n",  "nx_mount",  1631,  (const char *)(v126[48] + 208),  v65);
        goto LABEL_146;
      }

      unint64_t v110 = v20[2];
      sub_100013CBC( "%s:%d: %s checkpoint search: largest xid %lld, best xid %lld @ %d\n",  "nx_mount",  1635,  (const char *)(v126[48] + 208),  v122,  v110,  v123);
      unsigned int v66 = *(void *)(v44 + 16);
      unsigned int v67 = v126;
      if (v66 != v20[2])
      {
        sub_100013D94( "%s:%d: %s reloading after unclean unmount, checkpoint xid %lld, superblock xid %lld\n",  "nx_mount",  1637,  (const char *)(v126[48] + 208),  v20[2],  v66);
        unsigned int v67 = v126;
        if (!*((_BYTE *)v126 + 633))
        {
          uint64_t v109 = 1;
          *((_BYTE *)v126 + 645) = 1;
        }
      }

uint64_t sub_1000260EC(uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int a4, uint64_t a5)
{
  return sub_10002461C(a1, a2, 0, a3, a4, 0LL, 0LL, 0LL, 0LL, a5);
}

uint64_t sub_100026128( uint64_t a1, uint64_t a2, void *a3, unsigned int *a4, void *a5, unsigned int *a6, uint64_t a7)
{
  size_t v14 = *(unsigned int *)(*(void *)(a1 + 392) + 16LL);
  unsigned int v15 = (unint64_t *)sub_100014044(v14);
  if (!v15) {
    return 12LL;
  }
  uint64_t v16 = v15;
  uint64_t v17 = sub_10002461C(a1, a2, 1, v15, v14, a3, a4, a5, a6, a7);
  sub_100014004(v16, v14);
  return v17;
}

uint64_t sub_1000261E0(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6)
{
  unint64_t v12 = *(void *)(a1 + 400);
  __chkstk_darwin();
  size_t v14 = &v28[-v13];
  bzero(&v28[-v13], v15);
  __int16 v33 = 0LL;
  if (!*(void *)(a1 + 416)) {
    return 22LL;
  }
  unsigned int v16 = (v12 >> 9) & 0x3FFF;
  if (v16)
  {
    if (*a4 != v16) {
      return 22LL;
    }
  }

  unsigned __int16 v30 = -21846;
  unsigned __int16 v29 = -21846;
  sub_10003CF10(a1, 1);
  sub_10003DC28((char *)a1);
  uint64_t v18 = a1 + 56;
  uint64_t v17 = *(void *)(a1 + 56);
  if ((*(_WORD *)(v17 + 32) & 2) != 0)
  {
    uint64_t v19 = (void *)a1;
LABEL_15:
    if (*(_DWORD *)(v17 + 36))
    {
      int v32 = (const void *)0xAAAAAAAAAAAAAAAALL;
      uint64_t v20 = sub_10001E654((uint64_t)v19, 0, &v32, &v30);
      if (!(_DWORD)v20)
      {
        unsigned int v31 = (const void *)0xAAAAAAAAAAAAAAAALL;
        uint64_t v20 = sub_10001E764(v19, 0, &v31, (__int16 *)&v29);
        if (!(_DWORD)v20)
        {
          unsigned int v21 = v29;
          if (v29 == 65534) {
            unsigned int v22 = 0;
          }
          else {
            unsigned int v22 = v29;
          }
          int v23 = v30;
          else {
            size_t v24 = *a4;
          }
          else {
            uint64_t v20 = 34LL;
          }
          memcpy(a3, v32, v24);
          if (*a6 >= v22) {
            size_t v26 = v22;
          }
          else {
            size_t v26 = *a6;
          }
          memcpy(a5, v31, v26);
          *a4 = v23;
          *a6 = v21;
        }
      }
    }

    else
    {
      uint64_t v20 = 2LL;
    }

    sub_10003D514((uint64_t)v19, 1);
    sub_100038824(v19);
  }

  else
  {
    uint64_t v19 = (void *)a1;
    while (1)
    {
      *size_t v14 = 0LL;
      uint64_t v20 = sub_10001E938((uint64_t)v19, 0, v14);
      if (!(_DWORD)v20) {
        uint64_t v20 = sub_10001E24C((void *)a1, v14, a2, 2, *(_WORD *)(*(void *)v18 + 34LL) - 1, 0LL, &v33);
      }
      sub_10003D514((uint64_t)v19, 1);
      sub_100038824(v19);
      if ((_DWORD)v20) {
        break;
      }
      uint64_t v19 = v33;
      uint64_t v18 = (uint64_t)(v33 + 7);
      uint64_t v17 = v33[7];
      if ((*(_WORD *)(v17 + 32) & 2) != 0) {
        goto LABEL_15;
      }
    }
  }

  return v20;
}

uint64_t sub_100026464( uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int *a4, unsigned int a5, void *a6, unsigned int *a7, unsigned int a8, int a9, uint64_t *a10)
{
  if (!*(void *)(a1 + 416)) {
    return 22LL;
  }
  unint64_t v17 = *(void *)(a1 + 400);
  unsigned int v18 = (v17 >> 9) & 0x3FFF;
  if (v18)
  {
    if (*a4 != v18) {
      return 22LL;
    }
  }

  unsigned int v19 = *a4;
  unsigned __int16 v25 = (char *)0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v24 = -21846;
  uint64_t v20 = sub_1000265CC((char *)a1, a2, a3, (unsigned __int16)v19, a8, a9, 0, a10, &v25, &v24);
  if (!(_DWORD)v20)
  {
    unsigned int v22 = v25;
    uint64_t v23 = sub_100026BB0(a1, v25, v24, a3, a4, a5, a6, a7, a8);
    uint64_t v20 = v23;
    if (a10 && !(_DWORD)v23)
    {
      *a10 = sub_10003965C((uint64_t)v22);
      a10[1] = a1;
    }

    sub_10003D514((uint64_t)v22, 1);
    sub_100038824(v22);
  }

  return v20;
}

uint64_t sub_1000265CC( char *a1, uint64_t a2, unint64_t *a3, unsigned int a4, unsigned int a5, int a6, unsigned int a7, uint64_t *a8, char **a9, unsigned __int16 *a10)
{
  int v41 = a6;
  unsigned int v42 = a7;
  unsigned int v45 = a4;
  uint64_t v43 = a2;
  uint64_t v44 = a3;
  int v39 = a9;
  uint64_t v13 = *((void *)a1 + 50);
  __chkstk_darwin();
  size_t v15 = &v37[-v14];
  bzero(&v37[-v14], v16);
  char v48 = 0LL;
  unsigned __int16 v49 = (char *)0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v47 = -21846;
  char v46 = -86;
  if (!a8) {
    goto LABEL_9;
  }
  uint64_t v17 = *a8;
  if (!*a8) {
    goto LABEL_9;
  }
  if ((v13 & 0x10) != 0) {
    goto LABEL_9;
  }
  *size_t v15 = v17;
  if (v17 == sub_10003965C((uint64_t)a1)
    || sub_10001E24C( a1,  v15,  v43,  (((*(unsigned __int16 *)(*((void *)a1 + 7) + 32LL) >> 3) & 1) << 6) | 6u,  0,  0LL,  &v49))
  {
    goto LABEL_9;
  }

  unsigned int v18 = v49;
  if ((*(_WORD *)(*((void *)v49 + 7) + 32LL) & 2) == 0) {
    goto LABEL_8;
  }
  int v35 = sub_10002080C((uint64_t)v49, v44, v45, &v47, (BOOL *)&v46);
  if (!v35 && v46)
  {
    if (a5 != 4)
    {
      if (a5 != 2) {
        goto LABEL_80;
      }
      if (v47)
      {
        --v47;
        goto LABEL_80;
      }

LABEL_80:
    int v34 = v39;
LABEL_81:
    uint64_t v33 = 0LL;
    *int v34 = v18;
    *a10 = v47;
    return v33;
  }

  if (!(v35 | a5))
  {
    if (v47 && *(_DWORD *)(*((void *)v18 + 7) + 36LL) > v47)
    {
      unsigned __int16 v25 = 0LL;
      uint64_t v33 = 2LL;
      int v34 = v39;
      goto LABEL_53;
    }

    goto LABEL_8;
  }

      if (v6 && *(_BYTE *)(v6 + 62))
      {
        uint64_t v44 = *(void *)(v6 + 48) + v23;
        ++*(void *)(v6 + 40);
        *(void *)(v6 + 48) = v44;
      }

      unsigned int v45 = sub_100026128((uint64_t)v70, 0LL, 0LL, 0LL, 0LL, 0LL, v20);
      if (v45) {
        sub_100013D94( "%s:%d: %s sfq %d error removing entry %lld %lld from free queue: %d\n",  "spaceman_free_completed",  6166,  (const char *)(*(void *)(a1 + 384) + 208LL),  a3,  v69[1],  v69[2],  v45);
      }
      char v46 = v69[2] - v23;
      if (v69[2] != v23)
      {
        v69[1] += v23;
        v69[2] -= v23;
        unsigned int v68 = 8 * (v46 != 1);
        unsigned __int16 v47 = sub_10001EADC(v70, 0LL, v69, 16, &v69[2], v68, v20);
        if (v47) {
          sub_100013D94( "%s:%d: %s sfq %d error inserting shortened entry %lld %lld into free queue: %d\n",  "spaceman_free_completed",  6176,  (const char *)(*(void *)(a1 + 384) + 208LL),  a3,  v69[1],  v69[2],  v47);
        }
      }

      v14 += v23;
      LODWORD(__rqtp.tv_sec) = 16;
      unsigned int v68 = 8;
      char v48 = sub_1000261E0((uint64_t)v70, 0LL, v69, &__rqtp, &v69[2], &v68);
      unsigned int v22 = 1;
      if (v48) {
        goto LABEL_29;
      }
    }
  }

LABEL_8:
  sub_10003D514((uint64_t)v18, 1);
  sub_100038824(v18);
LABEL_9:
  BOOL v19 = a5 == 2;
  unsigned int v38 = a5 - 3;
  BOOL v20 = a5 - 3 < 2;
  sub_10003CF10((uint64_t)a1, 1);
  unsigned __int16 v49 = a1;
  sub_10003DC28(a1);
  unsigned __int16 v21 = 0;
  unsigned int v22 = a1;
  unsigned int v40 = a5;
  while (1)
  {
    char v46 = 0;
    unsigned __int16 v24 = v22 + 56;
    uint64_t v23 = *((void *)v22 + 7);
    if ((*(_WORD *)(v23 + 32) & 2) != 0)
    {
      unsigned __int16 v25 = 0LL;
    }

    else
    {
      unsigned __int16 v25 = 0LL;
      while (*(unsigned __int16 *)(v23 + 34) > v42)
      {
        uint64_t v26 = sub_100021744((uint64_t)v22, v44, v45, &v47, (BOOL *)&v46);
        if ((_DWORD)v26) {
          goto LABEL_48;
        }
        unsigned int v27 = v47;
        if (v19 && v47 != 0 || v20 && *(_DWORD *)(*(void *)v24 + 36LL) - 1 > v47)
        {
          if (v25)
          {
            sub_10003D514((uint64_t)v25, 1);
            sub_100038824(v25);
            unsigned int v27 = v47;
          }

          unsigned __int16 v25 = v49;
          sub_10003DC28(v49);
          unsigned __int16 v21 = v20 - v19 + v27;
        }

        int v28 = v49;
        if ((v41 & 0x100) != 0)
        {
          uint64_t v29 = *((void *)v49 + 7);
          if (*(_WORD *)(v29 + 34) == 1
            && *(_DWORD *)(v29 + 36) - 1 > v27
            && !sub_10001E938((uint64_t)v49, (unsigned __int16)(v27 + 1), v15))
          {
            sub_10001E24C(a1, v15, v43, 256, *(_WORD *)(*((void *)v28 + 7) + 34LL) - 1, 0LL, &v48);
          }
        }

        uint64_t v26 = sub_10001E938((uint64_t)v28, v27, v15);
        if ((_DWORD)v26) {
          goto LABEL_48;
        }
        uint64_t v26 = sub_10001E24C(a1, v15, v43, 2, *(_WORD *)(*((void *)v28 + 7) + 34LL) - 1, 0LL, &v48);
        if ((_DWORD)v26) {
          goto LABEL_48;
        }
        sub_10001E478(v28, v28 != v25);
        unsigned int v22 = v48;
        unsigned __int16 v49 = v48;
        unsigned __int16 v24 = v48 + 56;
        uint64_t v23 = *((void *)v48 + 7);
        if ((*(_BYTE *)(v23 + 32) & 2) != 0) {
          break;
        }
      }
    }

    uint64_t v26 = sub_10002080C((uint64_t)v22, v44, v45, &v47, (BOOL *)&v46);
    if ((_DWORD)v26)
    {
LABEL_48:
      uint64_t v33 = v26;
      goto LABEL_49;
    }

    if (v46) {
      break;
    }
    if (!v40)
    {
      uint64_t v33 = 2LL;
      goto LABEL_49;
    }

    unsigned int v30 = v47;
    if (v40 <= 2 && v47)
    {
      uint64_t v33 = 0LL;
      char v46 = 1;
      goto LABEL_69;
    }

    if (v38 <= 1)
    {
      unsigned int v31 = *(_DWORD *)(*(void *)v24 + 36LL);
      goto LABEL_43;
    }

  if (v4 <= a1 || *(v4 - 1) == 47) {
    return 0xFFFFFFFFLL;
  }
  return strtoul(v4 + 1, 0LL, 10) - 1;
}

    ++v11;
    __int16 v5 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
    --v10;
    if (v11 >= v5) {
      return 2 * (*a5 == -1);
    }
  }

  size_t v15 = *(_DWORD *)(a4 + 140);
  size_t v16 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (v12 != (*(_DWORD *)(a4 + 136) + v15 - 1) % v16)
  {
    sub_100013D94("%s:%d: %s xid %lld checkpoint superblock index %d doesn't match index block was found at: %d\n");
    goto LABEL_8;
  }

  if (v15 > v10 + v16)
  {
    sub_100013D94("%s:%d: %s xid %lld checkpoint superblock index %d doesn't fit in blocks remaining: %d > %d\n");
    goto LABEL_8;
  }

  if (sub_100012E9C((void *)a1, 0LL, 1, 0, 1)
    || (*(_BYTE *)(a4 + 65) & 1) != 0
    && (sub_100012E9C( (void *)a1,  0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36LL))),  1,  0,  1)
     || (*(_BYTE *)(a4 + 65) & 1) != 0
     && sub_100012E9C( (void *)a1,  *(void *)(*(void *)(a1 + 376) + 1368LL),  *(void *)(*(void *)(a1 + 376) + 1376LL) & 0x7FFFFFFF,  (*(void *)(*(void *)(a1 + 376) + 1376LL) & 0x80000000LL) != 0,  0))
    || sub_100012E9C( (void *)a1,  *(void *)(a4 + 112),  *(_DWORD *)(a4 + 104) & 0x7FFFFFFF,  *(int *)(a4 + 104) < 0,  0)
    || sub_100012E9C( (void *)a1,  *(void *)(a4 + 120),  *(_DWORD *)(a4 + 108) & 0x7FFFFFFF,  *(int *)(a4 + 108) < 0,  0))
  {
    sub_100013D94("%s:%d: %s xid %lld at index %d failed to load checkpoint metadata ranges (overlap?): %d\n");
LABEL_21:
    sub_100037058(*(pthread_mutex_t **)(a1 + 392), 0);
    *(void *)(a1 + 408) = 0LL;
    *(void *)(a1 + 720) = 0LL;
    *(void *)(a1 + 920) = 0LL;
    *(void *)(a1 + 1128) = 0LL;
    *(void *)(a1 + 1336) = 0LL;
    *(_BYTE *)(a1 + 635) = 0;
    *unsigned __int16 v21 = 0u;
    v21[1] = 0u;
    v21[2] = 0u;
    goto LABEL_8;
  }

  if (sub_1000339B8(a1, (unsigned int *)a4))
  {
    sub_100013D94("%s:%d: %s xid %lld validation failed for checkpoint at index %d: %d\n");
    goto LABEL_21;
  }

  uint64_t v17 = sub_100033ABC(a1, a4, &v25, &v24);
  if (v17)
  {
    sub_100013D94( "%s:%d: %s xid %lld data for checkpoint at index %d couldn't be loaded: %d\n",  "nx_checkpoint_find_valid_checkpoint",  572,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a4 + 16),  *(_DWORD *)(a4 + 136),  v17);
    sub_100032BF8(a1);
    goto LABEL_8;
  }

  memcpy(*(void **)(a1 + 376), (const void *)a4, *(unsigned int *)(a2 + 36));
  *(void *)(*(void *)(a1 + 392) + 400LL) = *(void *)(*(void *)(a1 + 376) + 88LL);
  if (sub_100010860(a1, 0LL, 2LL))
  {
    sub_100013D94("%s:%d: %s xid %lld failed to fix up checkpoint data: %d\n");
LABEL_46:
    sub_100032BF8(a1);
    memcpy(*(void **)(a1 + 376), (const void *)a2, *(unsigned int *)(a2 + 36));
    *(void *)(*(void *)(a1 + 392) + 400LL) = *(void *)(*(void *)(a1 + 376) + 88LL);
    goto LABEL_8;
  }

  if (*(_BYTE *)(a1 + 628))
  {
    if (*(_BYTE *)(a1 + 631))
    {
      sub_100013D04( "%s:%d: %s probe of external device... skipping recent sanity checks.\n",  "nx_checkpoint_find_valid_checkpoint",  599,  (const char *)(*(void *)(a1 + 384) + 208LL));
    }

    else
    {
      sub_100013D04( "%s:%d: %s sanity checking all recently-changed container state... please be patient.\n",  "nx_checkpoint_find_valid_checkpoint",  608,  (const char *)(*(void *)(a1 + 384) + 208LL));
      if (sub_10000B4A8((void *)a1))
      {
        sub_100013D94("%s:%d: %s xid %lld sanity check of recently-changed structures failed: %d\n");
        goto LABEL_46;
      }
    }
  }

  if (sub_100044238((void *)a1, (uint64_t *)&v23))
  {
    sub_100013D94("%s:%d: %s xid %lld failed to get spaceman: %d\n");
    goto LABEL_46;
  }

  if (sub_100012E9C( (void *)a1,  *(void *)(v23[47] + 168),  *(_DWORD *)(v23[47] + 164) & 0x7FFFFFFF,  *(int *)(v23[47] + 164) < 0,  0))
  {
    sub_100038824(v23);
LABEL_45:
    sub_100013D94("%s:%d: %s xid %lld failed to load spaceman metadata ranges (overlap?): %d\n");
    goto LABEL_46;
  }

  BOOL v20 = sub_100012E9C( (void *)a1,  *(void *)(v23[47] + 176),  *(void *)(v23[47] + 152),  *(uint64_t *)(v23[47] + 152) < 0,  0);
  sub_100038824(v23);
  if (v20) {
    goto LABEL_45;
  }
  BOOL v19 = *(void *)(*(void *)(a1 + 376) + 16LL);
  if (v19 < v25) {
    sub_100013D94( "%s:%d: %s warning: best valid checkpoint xid %lld is less than max free queue oldest xid %lld seen in checkpoint %lld\n",  "nx_checkpoint_find_valid_checkpoint",  646,  (const char *)(*(void *)(a1 + 384) + 208LL),  v19,  v25,  v24);
  }
  uint64_t result = 0LL;
  *a5 = v12;
  return result;
}

      if (v9 >= v8) {
        uint64_t v9 = v8;
      }
      unsigned int v11 = *(void *)(v6 + 184);
      unint64_t v12 = v11 >= v8;
      uint64_t v13 = v11 - v8;
      if (!v12)
      {
        uint64_t v14 = sub_10003965C(a2);
        sub_100013D94( "%s:%d: %s file system %lld fs reserve block count %lld larger than global fs reserve block count %lld\n",  "spaceman_fs_bounds_clear",  8862,  (const char *)(a2 + 3992),  v14,  v8,  *(void *)(v6 + 184));
        uint64_t v13 = 0LL;
      }

      *(void *)(v6 + 184) = v13;
      size_t v15 = *(void *)(v6 + 192);
      unint64_t v12 = v15 >= v9;
      size_t v16 = v15 - v9;
      if (!v12)
      {
        uint64_t v17 = sub_10003965C(a2);
        sub_100013D94( "%s:%d: %s file system %lld fs reserve alloc count %lld larger than global fs reserve alloc count %lld\n",  "spaceman_fs_bounds_clear",  8870,  (const char *)(a2 + 3992),  v17,  v9,  *(void *)(v6 + 192));
        size_t v16 = 0LL;
      }

      *(void *)(v6 + 192) = v16;
      unsigned int v18 = *(void *)(a2 + 376);
      *(void *)(v18 + 72) = 0LL;
      *(void *)(v18 + 80) = 0LL;
      sub_10003E644((uint64_t)v19, a3, 0LL);
      sub_10001AAF0(a2, a3);
      goto LABEL_15;
    }
  }

  return result;
}

LABEL_44:
    if (!v25)
    {
      uint64_t v33 = 2LL;
      unsigned int v18 = v49;
      int v34 = v39;
      if (v49) {
        goto LABEL_53;
      }
      goto LABEL_54;
    }

    sub_10001E478(v22, v22 != v25);
    uint64_t v32 = sub_10001E938((uint64_t)v25, v21, v15);
    if ((_DWORD)v32
      || (uint64_t v32 = sub_10001E24C(a1, v15, v43, 2, *(_WORD *)(*((void *)v25 + 7) + 34LL) - 1, 0LL, &v49), (_DWORD)v32))
    {
      uint64_t v33 = v32;
      unsigned __int16 v49 = 0LL;
      int v34 = v39;
      goto LABEL_50;
    }

    sub_10003D514((uint64_t)v25, 1);
    sub_100038824(v25);
    BOOL v19 = 0;
    BOOL v20 = 0;
    unsigned int v22 = v49;
  }

  if (v40 != 2)
  {
    if (v40 != 4 || (++v47, unsigned int v31 = *(_DWORD *)(*(void *)v24 + 36LL), v31 > v47))
    {
      uint64_t v33 = 0LL;
      goto LABEL_49;
    }

    unsigned int v30 = v47;
    char v46 = 0;
LABEL_43:
    if (v31 > v30)
    {
      uint64_t v33 = 0LL;
      char v46 = 1;
      goto LABEL_49;
    }

    goto LABEL_44;
  }

  LOWORD(v30) = v47;
  if (!v47)
  {
    char v46 = 0;
    goto LABEL_44;
  }

  uint64_t v33 = 0LL;
LABEL_69:
  unsigned __int16 v47 = v30 - 1;
LABEL_49:
  int v34 = v39;
  if (!v25) {
    goto LABEL_51;
  }
LABEL_50:
  sub_10003D514((uint64_t)v25, 1);
  sub_100038824(v25);
LABEL_51:
  unsigned int v18 = v49;
  if (!(_DWORD)v33) {
    goto LABEL_81;
  }
  if (!v49) {
    goto LABEL_54;
  }
LABEL_53:
  sub_10001E478(v18, v18 != v25);
LABEL_54:
  *int v34 = 0LL;
  return v33;
}

      size_t v15 = sub_10002E75C(v22, v21, v43);
      ++v25;
    }

    while ((v15 & 0xFFFFFFFD) == 0);
  }

  return v15;
}

uint64_t sub_100026BB0( uint64_t a1, void *a2, unsigned __int16 a3, void *a4, _DWORD *a5, unsigned int a6, void *a7, unsigned int *a8, int a9)
{
  __src = (void *)0xAAAAAAAAAAAAAAAALL;
  int v30 = 0;
  unsigned __int16 v29 = -21846;
  unsigned __int16 v28 = -21846;
  if (!(a9 | a6))
  {
    __src = 0LL;
    unsigned __int16 v29 = 0;
    goto LABEL_22;
  }

  uint64_t v17 = sub_10001E654((uint64_t)a2, a3, &__src, &v29);
  uint64_t v18 = v17;
  if (a9) {
    BOOL v19 = (_DWORD)v17 == 0;
  }
  else {
    BOOL v19 = 0;
  }
  if (!v19)
  {
LABEL_19:
    if ((_DWORD)v18) {
      return v18;
    }
    goto LABEL_22;
  }

  uint64_t v20 = *(void *)(a1 + 8);
  if (!v20) {
    uint64_t v20 = *(void *)(*(void *)a1 + 392LL);
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, void *, void, void *, void, int *))(a1 + 416))( v20,  __src,  v29,  a4,  *a5,  &v30);
  if (!(_DWORD)v18)
  {
    if (a9 == 2 && (v30 & 0x80000000) == 0 || a9 == 1 && v30 > 0 || a9 == 3 && v30 < 0 || a9 == 4 && v30 <= 0)
    {
      uint64_t v18 = sub_100005194(*(void *)(*(void *)a1 + 392LL));
      goto LABEL_19;
    }

LABEL_22:
    unsigned int v31 = (void *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v18 = sub_10001E764(a2, a3, &v31, (__int16 *)&v28);
    if (!(_DWORD)v18)
    {
      unsigned int v21 = v28;
      if (v28 == 65534) {
        unsigned int v22 = 0;
      }
      else {
        unsigned int v22 = v28;
      }
      unsigned int v23 = *a8;
      if (*a8 < v22 || (uint64_t v18 = 0LL, a6) && v29 > a6) {
        uint64_t v18 = 34LL;
      }
      if (a6)
      {
        int v24 = v29;
        if (v29 >= a6) {
          size_t v25 = a6;
        }
        else {
          size_t v25 = v29;
        }
        memcpy(a4, __src, v25);
        *a5 = v24;
        unsigned int v23 = *a8;
      }

      if (v23 >= v22) {
        size_t v26 = v22;
      }
      else {
        size_t v26 = v23;
      }
      memcpy(a7, v31, v26);
      *a8 = v21;
    }
  }

  return v18;
}

  uint64_t result = 0LL;
  ++*(void *)(a1 + 440);
  unsigned __int16 v29 = (void *)(a1 + 432);
LABEL_54:
  ++*v29;
  return result;
}

        if ((~a3 & 5) != 0)
        {
          if ((a3 & 0x10) != 0)
          {
LABEL_24:
            *(_DWORD *)(v8 + 24) |= 0x40000u;
            if ((a3 & 0x20) == 0) {
              goto LABEL_29;
            }
            goto LABEL_28;
          }
        }

        else
        {
          *(_DWORD *)(v8 + 24) |= 0x20000u;
          if ((a3 & 0x10) != 0) {
            goto LABEL_24;
          }
        }

        if ((a3 & 0x20) == 0)
        {
LABEL_29:
          unint64_t v12 = *(_DWORD *)(v8 + 28) - 1;
          *(_DWORD *)(v8 + 28) = v12;
          if (!v12 && (uint64_t v13 = *(_DWORD *)(v8 + 24), (v13 & 2) != 0))
          {
            if ((v13 & 4) != 0) {
              panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v13, 4, 2);
            }
            *(_DWORD *)(v8 + 24) = v13 & 0xFFFFFFF9 | 4;
            __tp.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            __tp.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
            size_t v16 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
            uint64_t v17 = v16 - *(void *)(v8 + 72);
            *(void *)(v8 + 72) = v16;
            if (v17 > 0xF4240) {
              sub_100013D4C( "%s:%d: %s tx xid %lld took %lld us to close\n",  "tx_leave",  2545,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v8 + 16),  v17);
            }
            *(void *)(v7 + 248) = (*(void *)(v7 + 248) + v17) >> 1;
            int v3 = sub_10004FC2C(a1);
            if ((a3 & 1) == 0) {
              goto LABEL_41;
            }
          }

          else
          {
            int v3 = 0LL;
            if ((a3 & 1) == 0)
            {
LABEL_41:
              pthread_mutex_unlock((pthread_mutex_t *)v7);
              return v3;
            }
          }

          if ((a3 & 4) != 0) {
            uint64_t v14 = 127;
          }
          else {
            uint64_t v14 = 63;
          }
          do
          {
            if (*(void *)(v8 + 16) != a2 || (*(_DWORD *)(v8 + 24) & v14) == 0) {
              break;
            }
            if (!(_DWORD)v3) {
              sub_1000139E8((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8LL, (uint64_t)"nx_tx_finish_wait", 0LL);
            }
          }

          while (!*(_DWORD *)(v7 + 76));
          int v3 = *(unsigned int *)(v8 + 52);
          goto LABEL_41;
        }

__n128 sub_100026D8C( uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t *a5, int a6, unsigned int a7, void *a8, unsigned int a9, _OWORD *a10)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  int v16 = a4 & 0x180;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a7;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a8;
  *(void *)(a1 + 24) = a9;
  uint64_t v17 = (uint64_t *)(a1 + 56);
  if (a10)
  {
    *(_OWORD *)uint64_t v17 = *a10;
  }

  else
  {
    *uint64_t v17 = 0LL;
    *(void *)(a1 + 64) = 0LL;
  }

  *(_DWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 52) = a9;
  if ((a4 & 4) != 0)
  {
    unsigned int v18 = 4;
  }

  else if ((a4 & 2) != 0)
  {
    int v21 = a4 & 0x180;
    int v19 = sub_100026464( a2,  a3,  a5,  (unsigned int *)(a1 + 48),  a7,  a8,  (unsigned int *)(a1 + 52),  1u,  v16,  (uint64_t *)(a1 + 56));
    if (v19 != 2) {
      goto LABEL_11;
    }
    unsigned int v18 = 3;
    int v16 = v21;
  }

  else
  {
    unsigned int v18 = 3;
  }

  int v19 = sub_100026464(a2, a3, a5, (unsigned int *)(a1 + 48), a7, a8, (unsigned int *)(a1 + 52), v18, v16, v17);
LABEL_11:
  if (v19)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    if (v19 != 2) {
      *(_DWORD *)(a1 + 28) = v19;
    }
  }

  else if (a10)
  {
    __n128 result = *(__n128 *)v17;
    *a10 = *(_OWORD *)v17;
  }

  return result;
}

double sub_100026ED4( uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t *a5, int a6, unsigned int a7, void *a8, unsigned int a9)
{
  *(void *)&double result = sub_100026D8C(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0LL).n128_u64[0];
  return result;
}

uint64_t sub_100026EFC(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 28);
  if (!(_DWORD)result) {
    return *(_DWORD *)(a1 + 16) & 1;
  }
  return result;
}

uint64_t sub_100026F18(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 28);
  if (!(_DWORD)result)
  {
    int v3 = *(_DWORD *)(a1 + 16);
    uint64_t result = 2LL;
    if ((v3 & 1) == 0)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 24);
      if ((v3 & 0x1000) != 0) {
        unsigned int v5 = 2;
      }
      else {
        unsigned int v5 = 4;
      }
      uint64_t result = sub_100026464( *(void *)a1,  *(void *)(a1 + 8),  *(unint64_t **)(a1 + 32),  (unsigned int *)(a1 + 48),  v4,  *(void **)(a1 + 40),  (unsigned int *)(a1 + 52),  v5,  v3 & 0x180,  (uint64_t *)(a1 + 56));
      if ((_DWORD)result == 2)
      {
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 16) |= 1u;
      }

      *(_DWORD *)(a1 + 28) = result;
    }
  }

  return result;
}

uint64_t sub_100026FA4( uint64_t a1, uint64_t a2, int a3, void *__src, size_t __n, _OWORD *a6, uint64_t (*a7)(void, void, void, void, uint64_t, __n128), uint64_t a8, void *a9, void *a10)
{
  unsigned int v10 = __n;
  unint64_t v12 = *(void *)(a1 + 400);
  unint64_t v13 = v12 >> 27;
  uint64_t v14 = (v12 >> 27) & 0x1F000;
  unsigned int v15 = (v12 >> 9) & 0x3FFF;
  if (v15)
  {
    unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v44 = v16;
    __int128 v45 = v16;
    __int128 v42 = v16;
    __int128 v43 = v16;
    unsigned int v17 = __n;
    if (v15 == (_DWORD)__n) {
      goto LABEL_3;
    }
    return 34LL;
  }

  unsigned int v17 = (unsigned __int16)(((unsigned __int16)(v14 - 160) >> 2) - 72);
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v31 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v44 = v31;
  __int128 v45 = v31;
  __int128 v42 = v31;
  __int128 v43 = v31;
LABEL_3:
  unsigned int v18 = a9;
  if (!a9)
  {
    int v19 = __src;
    uint64_t v20 = sub_100013EEC(1uLL, v17);
    __src = v19;
    unsigned int v18 = v20;
  }

  int v21 = a10;
  if (!a10)
  {
    unsigned int v22 = __src;
    unsigned int v23 = sub_100013EEC(1uLL, v13 & 0x1F000);
    __src = v22;
    int v21 = v23;
  }

  unsigned int v24 = 0;
  unsigned int v25 = 12;
  if (v18 && v21)
  {
    size_t v26 = v21;
    memcpy(v18, __src, v10);
    uint64_t v27 = a1;
    unsigned __int16 v28 = v26;
    __n128 v30 = sub_100026D8C((uint64_t)&v42, v27, a2, a3, (unint64_t *)v18, v10, v17, v26, v14, a6);
    if (v29)
    {
LABEL_10:
      unsigned int v25 = v29;
      unsigned int v24 = 0;
    }

    else
    {
      while (1)
      {
        if (HIDWORD(v43) || (v43 & 1) != 0)
        {
          unsigned int v24 = 0;
          goto LABEL_23;
        }

        unsigned int v34 = a7(v44, v45, *((void *)&v44 + 1), DWORD1(v45), a8, v30);
        if (v34) {
          break;
        }
        unsigned int v29 = sub_100026F18((uint64_t)&v42);
        if (v29) {
          goto LABEL_10;
        }
      }

      unsigned int v24 = v34;
LABEL_23:
      unsigned int v25 = 0;
    }

    int v21 = v28;
  }

  if (a9)
  {
    if (a10) {
      goto LABEL_27;
    }
  }

  else
  {
    uint64_t v35 = v17;
    unint64_t v36 = v21;
    sub_100014004(v18, v35);
    int v21 = v36;
    if (a10) {
      goto LABEL_27;
    }
  }

  sub_100014004(v21, v13 & 0x1F000);
LABEL_27:
  if (v25) {
    return v25;
  }
  else {
    return v24;
  }
}

uint64_t sub_100027194( uint64_t a1, uint64_t a2, __int16 a3, unint64_t *a4, unsigned int a5, uint64_t *a6, uint64_t (*a7)(void, uint64_t, void, void, uint64_t), uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 400);
  __int128 v49 = 0uLL;
  unsigned int v48 = 4;
  unsigned int v9 = (v8 >> 9) & 0x3FFF;
  if (v9) {
    BOOL v10 = v9 == a5;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    return 34LL;
  }
  unsigned __int16 v14 = a5;
  unint64_t v19 = v8 >> 27;
  uint64_t v20 = (v8 >> 27) & 0x1F000;
  uint64_t v22 = v19 & 0x1F000;
  unsigned int v23 = (char *)sub_100013EEC(1uLL, v19 & 0x1F000);
  if (!v23) {
    return 12LL;
  }
  *(void *)&__int128 v24 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[6] = v24;
  v53[7] = v24;
  v53[4] = v24;
  v53[5] = v24;
  timespec v53[2] = v24;
  v53[3] = v24;
  v53[0] = v24;
  v53[1] = v24;
  v52[1] = v24;
  v52[2] = v24;
  v52[3] = v24;
  void v52[4] = v24;
  v52[5] = v24;
  v52[6] = v24;
  v52[7] = v24;
  v51[0] = v24;
  v51[1] = v24;
  v51[2] = v24;
  v51[3] = v24;
  v52[0] = v24;
  v50[2] = v24;
  v50[3] = v24;
  v50[0] = v24;
  v50[1] = v24;
  unsigned int v25 = a4;
  size_t v26 = v23;
  uint64_t v21 = sub_100027424( (char *)a1,  a2,  v25,  v14,  a3,  a6,  v23,  v20,  (int *)&v48,  (uint64_t)v53,  (uint64_t)v51,  (uint64_t)v52,  (uint64_t)v50);
  if (!(_DWORD)v21)
  {
    unint64_t v46 = v26;
    if (a6) {
      __int128 v49 = *(_OWORD *)a6;
    }
    __int16 v42 = a3 & 0xFFF9 | 4;
    unsigned int v43 = v20;
    int v27 = 4;
    uint64_t v44 = a2;
    uint64_t v45 = v22;
    while (1)
    {
      int v47 = v48;
LABEL_18:
      uint64_t v37 = v47 - 1LL;
      unsigned int v38 = (unint64_t *)*((void *)v53 + v37);
      unsigned int v39 = *((unsigned __int16 *)v51 + 2 * v37);
      unsigned int v48 = v27;
      uint64_t v40 = sub_100027424( (char *)a1,  v44,  v38,  v39,  v42,  (uint64_t *)&v49,  v46,  v43,  (int *)&v48,  (uint64_t)v53,  (uint64_t)v51,  (uint64_t)v52,  (uint64_t)v50);
      v27 <<= v27 < 16;
      uint64_t v22 = v45;
      if ((_DWORD)v40)
      {
        uint64_t v21 = v40;
        size_t v26 = v46;
        if ((_DWORD)v40 == 2) {
          uint64_t v21 = 0LL;
        }
        goto LABEL_23;
      }
    }

    unsigned __int16 v28 = (unsigned int *)v50;
    unsigned int v29 = v52;
    __n128 v30 = (unsigned int *)v51;
    __int128 v31 = v53;
    uint64_t v32 = v48;
    while (1)
    {
      unsigned int v34 = *v30++;
      uint64_t v33 = v34;
      unsigned int v35 = *v28++;
      uint64_t v36 = a7(*v31, v33, *v29, v35, a8);
      if ((_DWORD)v36) {
        break;
      }
      ++v29;
      ++v31;
      if (!--v32) {
        goto LABEL_18;
      }
    }

    uint64_t v21 = v36;
    uint64_t v22 = v45;
    size_t v26 = v46;
  }

uint64_t sub_100027424( char *a1, uint64_t a2, unint64_t *a3, unsigned int a4, __int16 a5, uint64_t *a6, char *a7, unsigned int a8, int *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  int v15 = *a9;
  unsigned int v34 = 0LL;
  unsigned __int16 v33 = -21846;
  uint64_t v16 = sub_10002784C(a1, a2, a3, a4, a5, a6, &v34, &v33);
  unsigned int v17 = v34;
  if (!(_DWORD)v16)
  {
    int v18 = 0;
    unsigned int v19 = v33;
    *a9 = 0;
    if (*(_DWORD *)(*((void *)v17 + 7) + 36LL) <= v19 || v15 < 1)
    {
LABEL_17:
      if (v18) {
        uint64_t v16 = 0LL;
      }
      else {
        uint64_t v16 = 34LL;
      }
    }

    else
    {
      while (1)
      {
        memset(__n, 170, 18);
        unsigned __int16 v31 = -21846;
        uint64_t v21 = sub_10001E654((uint64_t)v17, (unsigned __int16)v19, (size_t *)((char *)&__n[1] + 2), __n);
        if ((_DWORD)v21) {
          break;
        }
        uint64_t v21 = sub_10001E764(v17, (unsigned __int16)v19, (size_t *)((char *)__n + 2), (__int16 *)&v31);
        if ((_DWORD)v21) {
          break;
        }
        int v22 = v31;
        if (v31 == 65534) {
          size_t v23 = 0LL;
        }
        else {
          size_t v23 = v31;
        }
        int v24 = LOWORD(__n[0]);
        unsigned int v25 = v23 + LOWORD(__n[0]);
        BOOL v26 = a8 >= v25;
        a8 -= v25;
        if (!v26)
        {
          int v18 = *a9;
          goto LABEL_17;
        }

        memcpy(a7, *(const void **)((char *)&__n[1] + 2), LOWORD(__n[0]));
        uint64_t v27 = *a9;
        *(void *)(a10 + 8 * v27) = a7;
        *(_DWORD *)(a11 + 4 * v27) = v24;
        unsigned __int16 v28 = &a7[v24];
        memcpy(v28, *(const void **)((char *)__n + 2), v23);
        uint64_t v29 = *a9;
        *(void *)(a12 + 8 * v29) = v28;
        *(_DWORD *)(a13 + 4 * v29) = v22;
        LOWORD(v19) = v19 + 1;
        int v18 = *a9 + 1;
        *a9 = v18;
        if (*(_DWORD *)(*((void *)v17 + 7) + 36LL) > (unsigned __int16)v19)
        {
          a7 = &v28[v23];
          if (v18 < v15) {
            continue;
          }
        }

        goto LABEL_17;
      }

      uint64_t v16 = v21;
    }
  }

  if (v17)
  {
    sub_10003D514((uint64_t)v17, 1);
    sub_100038824((uint64_t *)v17);
  }

  return v16;
}

uint64_t sub_1000275E8( uint64_t a1, uint64_t a2, __int16 a3, unint64_t *a4, unsigned int a5, uint64_t *a6, uint64_t (*a7)(unint64_t, void, unint64_t, void, uint64_t), uint64_t a8)
{
  unsigned __int16 v11 = a5;
  unint64_t v16 = *(void *)(a1 + 400);
  unsigned int v17 = (v16 >> 9) & 0x3FFF;
  if (v17)
  {
    __int16 v42 = 0LL;
    unsigned __int16 v41 = -21846;
    unsigned int v18 = a5;
    if (v17 == a5) {
      goto LABEL_3;
    }
    return 34LL;
  }

  unsigned int v18 = ((unsigned __int16)((((v16 >> 27) & 0xF000) - 160) & 0xFFE0) >> 2) - 72;
  __int16 v42 = 0LL;
  unsigned __int16 v41 = -21846;
  if ((v16 & 0x7FFE00) == 0 && v18 < a5) {
    return 34LL;
  }
LABEL_3:
  uint64_t v19 = v18;
  uint64_t v20 = sub_100013EEC(1uLL, v18);
  if (!v20) {
    return 12LL;
  }
  uint64_t v21 = v20;
  unsigned int v22 = sub_10002784C((char *)a1, a2, a4, v11, a3, a6, &v42, &v41);
  if (!v22)
  {
    __int16 v28 = a3 & 0xFFF9 | 4;
    __int16 v36 = v28;
    while (1)
    {
      uint64_t v29 = (const void *)0xAAAAAAAAAAAAAAAALL;
      unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
      unsigned __int16 v38 = 0;
      unsigned __int16 v37 = -21846;
      __n128 v30 = (uint64_t *)v42;
      unsigned __int16 v31 = v41;
      unsigned int v33 = 0;
LABEL_26:
      unsigned __int16 v41 = v31;
      else {
        size_t v34 = v19;
      }
      memcpy(v21, v29, v34);
      sub_10003D514((uint64_t)v30, 1);
      sub_100038824(v30);
      __int16 v42 = 0LL;
      unsigned int v35 = sub_10002784C((char *)a1, a2, (unint64_t *)v21, v38, v28, 0LL, &v42, &v41);
      if (v35)
      {
        unsigned int v24 = 0;
        if (v35 == 2) {
          unsigned int v23 = 0;
        }
        else {
          unsigned int v23 = v35;
        }
        goto LABEL_6;
      }
    }

    while (1)
    {
      unsigned int v22 = sub_10001E654((uint64_t)v30, v31, &v40, &v38);
      if (v22) {
        break;
      }
      unsigned int v22 = sub_10001E764(v30, v31, &v39, (__int16 *)&v37);
      if (v22) {
        break;
      }
      uint64_t v29 = (const void *)v40;
      unsigned int v32 = a7(v40, v38, v39, v37, a8);
      if (v32)
      {
        unsigned int v24 = v32;
        unsigned int v23 = 0;
        goto LABEL_6;
      }

      if (*(_DWORD *)(v30[7] + 36) <= ++v31)
      {
        unsigned int v33 = v38;
        __int16 v28 = v36;
        goto LABEL_26;
      }
    }
  }

  unsigned int v23 = v22;
  unsigned int v24 = 0;
LABEL_6:
  unsigned int v25 = (uint64_t *)v42;
  if (v42)
  {
    sub_10003D514((uint64_t)v42, 1);
    sub_100038824(v25);
  }

  sub_100014004(v21, v19);
  if (v23) {
    return v23;
  }
  else {
    return v24;
  }
}

uint64_t sub_10002784C( char *a1, uint64_t a2, unint64_t *a3, unsigned int a4, __int16 a5, uint64_t *a6, char **a7, unsigned __int16 *a8)
{
  int v15 = a5 & 0x180;
  if ((a5 & 4) != 0)
  {
    unsigned int v17 = 4;
    goto LABEL_6;
  }

  if ((a5 & 2) == 0 || (uint64_t v16 = sub_1000265CC(a1, a2, a3, a4, 1u, v15, 0, a6, a7, a8), (_DWORD)v16 == 2))
  {
    unsigned int v17 = 3;
LABEL_6:
    uint64_t v16 = sub_1000265CC(a1, a2, a3, a4, v17, v15, 0, a6, a7, a8);
  }

  if (a6 && !(_DWORD)v16)
  {
    *a6 = sub_10003965C((uint64_t)*a7);
    a6[1] = (uint64_t)a1;
  }

  return v16;
}

uint64_t sub_100027934( uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, uint64_t *a6, uint64_t a7, uint64_t *a8)
{
  unsigned __int16 v11 = a5;
  __int16 v12 = a4;
  unsigned int v13 = a3;
  uint64_t v33 = 0LL;
  unsigned int v15 = *((_DWORD *)a6 + 5);
  unsigned int v16 = a2 >> 30;
  unsigned int v17 = (v15 << 26) & 0x40000000 | ((v15 >> 3) << 31) | (((v15 >> 5) & 1) << 27) | a2;
  if ((v15 & 0x18) == 0) {
    unsigned int v17 = a2;
  }
  int v18 = v15 | (a2 >> 26) & 0x10;
  if ((a2 & 0x80000000) != 0) {
    v18 |= 8u;
  }
  int v19 = v18 | (a2 >> 22) & 0x20;
  if (v16) {
    uint64_t v20 = a2;
  }
  else {
    uint64_t v20 = v17;
  }
  if (v16) {
    unsigned int v21 = v19;
  }
  else {
    unsigned int v21 = *((_DWORD *)a6 + 5);
  }
  if (!a3) {
    unsigned int v13 = *(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 376LL) + 36LL);
  }
  if (v13 - 65537 < 0xFFFF0060
    || a4 != 8 && (v21 & 1) != 0
    || a4 > (unsigned __int16)(((unsigned __int16)(v13 - 160) >> 2) - 72)
    || a5 + a4 > sub_10001D9F0(v21, v13, (unsigned __int16)a4, (unsigned __int16)a5)
    || v21 > 0x1FF)
  {
    return 22LL;
  }

  unint64_t v22 = ((unsigned __int16)(v12 & 0x3FFF) << 9) | ((unint64_t)v11 << 23) | v21 & 0x1FF | ((unint64_t)(v13 >> 12) << 39);
  uint64_t v23 = *a6;
  unint64_t v32 = v22;
  uint64_t v34 = v23;
  uint64_t v31 = 0x300086583LL;
  if ((v21 & 0x80) == 0)
  {
    __int16 v24 = 19;
    if ((v21 & 0x100) == 0) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }

  unsigned int v29 = *((_DWORD *)a6 + 6);
  if (v29 > 0xF) {
    return 22LL;
  }
  unsigned int v30 = *((_DWORD *)a6 + 7);
  unint64_t v32 = v22 & 0xFF800FFFFFFFFFFFLL | ((unint64_t)(v29 & 0xF) << 44) | ((unint64_t)(v30 & 0x7F) << 48);
  if (v30 > 0x7F) {
    return 22LL;
  }
  WORD2(v31) = 11;
  __int16 v24 = 27;
  if ((v21 & 0x100) != 0) {
LABEL_21:
  }
    WORD2(v31) = v24;
LABEL_22:
  uint64_t result = sub_100027B58(a1, v20, *((unsigned int *)a6 + 4), &v31, a7, a8);
  if (!(_DWORD)result)
  {
    BOOL v26 = (unint64_t *)(*(void *)(*a8 + 392) + 32LL);
    do
      unint64_t v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
    uint64_t v28 = a6[1];
    if (v28) {
      *(void *)(*a8 + 424) = v28;
    }
    sub_10003D514(*a8, 2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100027B58(pthread_mutex_t **a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6)
{
  __int128 v18 = xmmword_10005B940;
  DWORD2(v18) = (*(void *)(a4 + 8) >> 27) & 0x1F000;
  __int16 v10 = *(_WORD *)(a4 + 4);
  if ((v10 & 1) != 0) {
    LODWORD(v18) = 2;
  }
  uint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  DWORD1(v18) = a3;
  if ((v10 & 0x10) != 0) {
    int v11 = 536870916;
  }
  else {
    int v11 = 4;
  }
  int v12 = v11 | a2;
  unsigned int v13 = *a1;
  else {
    uint64_t v14 = 0LL;
  }
  uint64_t v15 = sub_10003A068(v13, v12, 0LL, (uint64_t)&v18, a4, v14, a5, &v19);
  if (!(_DWORD)v15)
  {
    uint64_t v16 = v19;
    *a6 = v19;
    sub_10003E644(v16, a5, 0LL);
  }

  return v15;
}

uint64_t sub_100027C40( uint64_t a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  v11[1] = 0LL;
  __int128 v14 = 0u;
  uint64_t v18 = 0LL;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v15 = 0u;
  v11[0] = a8;
  int v12 = a4;
  int v13 = a3;
  return sub_100027934(a1, a2, a5, a6, a7, v11, a9, a10);
}

uint64_t sub_100027CC4( uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t **a8)
{
  unsigned __int16 v38 = a8;
  uint64_t v39 = a7;
  __int128 v15 = (_WORD *)((char *)&v38 - *(unsigned int *)(a6 + 28));
  bzero(v15, v8);
  unsigned __int16 v41 = 0LL;
  __int128 v40 = xmmword_10005B940;
  unsigned int v16 = *(_DWORD *)(a6 + 20);
  unsigned int v17 = a2 >> 30;
  int v18 = (v16 << 26) & 0x40000000 | ((v16 >> 3) << 31) | (((v16 >> 5) & 1) << 27) | a2;
  if ((v16 & 0x18) == 0) {
    int v18 = a2;
  }
  int v19 = v16 | (a2 >> 26) & 0x10;
  if ((a2 & 0x80000000) != 0) {
    v19 |= 8u;
  }
  int v20 = v19 | (a2 >> 22) & 0x20;
  if (v17) {
    unsigned int v21 = a2;
  }
  else {
    unsigned int v21 = v18;
  }
  if (v17) {
    unsigned int v22 = v20;
  }
  else {
    unsigned int v22 = *(_DWORD *)(a6 + 20);
  }
  *__int128 v15 = 25987;
  v15[1] = v8;
  if (v22 > 0x1FF) {
    return 22LL;
  }
  uint64_t v23 = *(void *)a1;
  *((void *)v15 + 1) = *((void *)v15 + 1) & 0xFFFFF07FFFFFFE00LL | v22 & 0x1FF | ((unint64_t)((*(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 376LL) + 36LL) >> 12) & 0x1F) << 39);
  *((void *)v15 + 3) = *(void *)a6;
  *((_DWORD *)v15 + 1) = -267452416;
  if ((v22 & 0x80) == 0) {
    goto LABEL_13;
  }
  unsigned int v30 = *(_DWORD *)(a6 + 24);
  if (v30 > 0xF) {
    return 22LL;
  }
  unint64_t v31 = *((void *)v15 + 1) & 0xFF800FFFFFFFFFFFLL | ((unint64_t)(v30 & 0xF) << 44);
  unsigned int v32 = *(_DWORD *)(a6 + 28);
  *((void *)v15 + 1) = v31 | ((unint64_t)(v32 & 0x7F) << 48);
  if (v32 > 0x7F) {
    return 22LL;
  }
  if (v32 >= 0x40) {
    size_t v33 = 64LL;
  }
  else {
    size_t v33 = v32;
  }
  memcpy(v15 + 16, (const void *)(a6 + 32), v33);
  uint64_t v23 = *(void *)a1;
LABEL_13:
  int v24 = *(_DWORD *)(a6 + 16);
  LODWORD(v40) = (v22 << 21) & 0x20000000 | v21 & 0xFFFF0000 | 2;
  DWORD1(v40) = v24;
  if ((v21 & 0x40000000) != 0) {
    int v25 = 3;
  }
  else {
    int v25 = 1;
  }
  unsigned int v26 = (2 * (a5 & 2)) & 0xDF | (32 * (((a5 & 4) >> 2) & 1)) | (a5 << 31 >> 31) & v25 | (v22 << 21) & 0x20000000 | v21;
  else {
    uint64_t v27 = 0LL;
  }
  uint64_t result = sub_10003B574(v23, v26, a3, (int *)&v40, v15, v27, a4, v39, (uint64_t *)&v41);
  if ((a5 & 4) == 0 || (_DWORD)result)
  {
    unsigned int v29 = v41;
    if ((_DWORD)result) {
      uint64_t v34 = 0LL;
    }
    else {
      uint64_t v34 = v41;
    }
    *unsigned __int16 v38 = v34;
    if (!(_DWORD)result) {
      goto LABEL_36;
    }
  }

  else
  {
    unsigned int v29 = v41;
    if ((v41[2] & 0x10) == 0)
    {
      *unsigned __int16 v38 = v41;
LABEL_36:
      uint64_t v35 = *(void *)(a6 + 8);
      uint64_t result = 0LL;
      if (v35) {
        v29[53] = v35;
      }
      return result;
    }

    if ((a5 & 1) != 0) {
      char v36 = 2;
    }
    else {
      char v36 = 1;
    }
    if ((a5 & 2) != 0) {
      char v37 = v36;
    }
    else {
      char v37 = 0;
    }
    sub_10001E478(v41, v37);
    *unsigned __int16 v38 = 0LL;
    return 2LL;
  }

  return result;
}

uint64_t sub_100027FC4( uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9, uint64_t **a10)
{
  v11[1] = 0LL;
  __int128 v14 = 0u;
  uint64_t v18 = 0LL;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v15 = 0u;
  v11[0] = a8;
  int v12 = a7;
  int v13 = a5;
  return sub_100027CC4(a1, a2, a3, a4, a6, (uint64_t)v11, a9, a10);
}

uint64_t sub_100028040(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v98 = a6;
  __int16 v100 = a4;
  uint64_t v96 = a2;
  *(void *)&__int128 v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v108 = v9;
  __int128 v109 = v9;
  __int128 v106 = v9;
  __int128 v107 = v9;
  __int128 v104 = v9;
  __int128 v105 = v9;
  __int128 v102 = v9;
  __int128 v103 = v9;
  __chkstk_darwin();
  int v11 = (uint64_t *)((char *)&v79 - v10);
  bzero((char *)&v79 - v10, v12);
  int v95 = a3 & 0x180;
  int v13 = v95 != 0;
  if ((a3 & 1) != 0) {
    char v14 = 2;
  }
  else {
    char v14 = 1;
  }
  sub_10003CF10(a1, v14);
  uint64_t v15 = *(void *)(a1 + 56);
  if (!v15)
  {
    sub_10003D514(a1, v14);
    return 22LL;
  }

  uint64_t v16 = *(unsigned __int16 *)(v15 + 34);
  uint64_t v17 = v16 + 1;
  uint64_t v93 = v16;
  if (v16 < 8)
  {
    __int128 v108 = 0u;
    __int128 v109 = 0u;
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    uint64_t v18 = &v102;
    __int128 v102 = 0u;
    __int128 v103 = 0u;
  }

  else
  {
    uint64_t v18 = (__int128 *)sub_100013EEC(v16 + 1, 0x10uLL);
    if (!v18)
    {
      sub_10003D514(a1, v14);
      return 12LL;
    }
  }

  *(void *)uint64_t v18 = a1;
  *((_WORD *)v18 + 4) = 0;
  sub_10003DC28((char *)a1);
  uint64_t v19 = 0LL;
  if ((a3 & 1) != 0)
  {
    uint64_t v19 = sub_10003CF9C((void *)a1, 2, v98);
    if (!(_DWORD)v19)
    {
      if ((*(_BYTE *)(a1 + 400) & 0x80) != 0) {
        sub_10003E644(a1, v98, 0LL);
      }
      uint64_t v19 = 0LL;
    }
  }

  uint64_t v90 = v17;
  int v20 = a3 & 0x20;
  uint64_t v91 = &v79;
  if (!(_DWORD)v19)
  {
    unsigned __int16 v26 = 0;
    unsigned int v84 = a3 & 0xFFFFFE4F;
    unsigned int v27 = a3 & 0xFFFFFE4D | 2;
    unsigned int v86 = a3 & 0xFFFFFE4C;
    if (v95) {
      unsigned int v27 = a3 & 0xFFFFFE4C;
    }
    BOOL v28 = v20 != 0;
    if (!v100) {
      BOOL v28 = 0;
    }
    BOOL v99 = v28;
    int v83 = v13 << 7;
    uint64_t v92 = (v13 << 7) | v27;
    uint64_t v85 = v27 | 0x100;
    if (v100) {
      BOOL v29 = v20 == 0;
    }
    else {
      BOOL v29 = 0;
    }
    BOOL v88 = v29;
    uint64_t v89 = a5;
    while (1)
    {
      unsigned __int16 v30 = v26;
      unint64_t v31 = (uint64_t *)&v18[v26];
      unsigned int v32 = (uint64_t *)*v31;
      uint64_t v33 = *(void *)(*v31 + 56);
      if ((*(_WORD *)(v33 + 32) & 2) != 0
        || (uint64_t v34 = &v18[v26],
            unsigned int v37 = *((unsigned __int16 *)v34 + 4),
            char v36 = (_WORD *)v34 + 4,
            unsigned int v35 = v37,
            *(_DWORD *)(v33 + 36) <= v37)
        || (a3 & 0x10) != 0 && *(_WORD *)(v33 + 34) == 1)
      {
        if (v99)
        {
          uint64_t v19 = v100();
          unsigned int v32 = (uint64_t *)*v31;
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        sub_10001E478(v32, v14);
        *unint64_t v31 = 0LL;
        unsigned __int16 v26 = v30 - 1;
        goto LABEL_45;
      }

      *int v11 = 0LL;
      uint64_t v38 = sub_10001E938((uint64_t)v32, v35, v11);
      if ((_DWORD)v38)
      {
        uint64_t v19 = v38;
        sub_10003965C(*v31);
        sub_100013D94("%s:%d: %s level %d node 0x%llx: error getting index %d child oid: %d\n");
        goto LABEL_21;
      }

      ++*v36;
      unsigned __int16 v26 = v30 + 1;
      if (v93 < (__int16)(v30 + 1))
      {
        uint64_t v61 = *(void *)(a1 + 8);
        if (v61) {
          uint64_t v62 = (const char *)(v61 + 3992);
        }
        else {
          uint64_t v62 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
        }
        uint64_t v65 = &v18[(__int16)v26];
        uint64_t v66 = *((void *)v65 - 2);
        int v67 = *(unsigned __int16 *)(*(void *)(v66 + 56) + 34LL);
        uint64_t v68 = sub_10003965C(v66);
        sub_100013D94( "%s:%d: %s level %d node 0x%llx index %d: more levels than expected\n",  "btree_iterate_nodes",  6423,  v62,  v67,  v68,  *((unsigned __int16 *)v65 - 4) - 1);
        uint64_t v19 = 22LL;
        goto LABEL_21;
      }

      uint64_t v39 = &v18[(__int16)v26];
      *((_WORD *)v39 + 4) = 0;
      uint64_t v94 = (__int16)v26 - 1LL;
      int v97 = (uint64_t *)&v18[v94];
      uint64_t v19 = sub_10001E24C((void *)a1, v11, v96, v92, *(_WORD *)(*(void *)(*v97 + 56) + 34LL) - 1, v98, v39);
      if ((_DWORD)v19) {
        break;
      }
      if (v95) {
        goto LABEL_58;
      }
      if ((a3 & 1) != 0) {
        goto LABEL_77;
      }
LABEL_79:
      if (v88) {
        uint64_t v19 = ((uint64_t (*)(void, uint64_t))v100)(*(void *)v39, v89);
      }
      else {
        uint64_t v19 = 0LL;
      }
LABEL_45:
      if ((_DWORD)v19 || (v26 & 0x8000) != 0) {
        goto LABEL_21;
      }
    }

    uint64_t v40 = *(void *)(a1 + 8);
    if (v40) {
      unsigned __int16 v41 = (const char *)(v40 + 3992);
    }
    else {
      unsigned __int16 v41 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
    }
    int v42 = *(unsigned __int16 *)(*(void *)(*v97 + 56) + 34LL);
    uint64_t v43 = sub_10003965C(*v97);
    sub_100013D94( "%s:%d: %s level %d node 0x%llx: error getting index %d child 0x%llx flags 0x%x: %d\n",  "btree_iterate_nodes",  6438,  v41,  v42,  v43,  WORD4(v18[v94]) - 1,  *v11,  v92,  v19);
    if (!v95) {
      goto LABEL_96;
    }
LABEL_58:
    uint64_t v44 = &v18[v94];
    unsigned int v46 = *((unsigned __int16 *)v44 + 4);
    uint64_t v45 = (unsigned __int16 *)v44 + 4;
    if (*(_DWORD *)(*(void *)(*v97 + 56) + 36LL) > v46)
    {
      uint64_t v87 = &v79;
      __chkstk_darwin();
      unsigned int v48 = (uint64_t *)((char *)&v79 - v47);
      bzero((char *)&v79 - v47, v49);
      unsigned int v50 = *v45;
      if (*(_DWORD *)(*(void *)(*v97 + 56) + 36LL) > v50)
      {
        uint64_t v51 = sub_10001E938(*v97, v50, v48);
        if ((_DWORD)v51
          || (uint64_t v51 = sub_10001E24C( (void *)a1,  v48,  v96,  v85,  *(_WORD *)(*(void *)(*v97 + 56) + 34LL) - 1,  v98,  &v101),  (_DWORD)v51))
        {
          uint64_t v82 = v51;
          uint64_t v52 = *(void *)(a1 + 8);
          if (v52) {
            uint64_t v81 = (const char *)(v52 + 3992);
          }
          else {
            uint64_t v81 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
          }
          uint64_t v53 = *v97;
          uint64_t v80 = *(unsigned __int16 *)(*(void *)(*v97 + 56) + 34LL);
          uint64_t v54 = sub_10003965C(v53);
          sub_100013D94( "%s:%d: %s level %d node 0x%llx: error prefetching index %d child 0x%llx flags 0x%x: %d\n",  "btree_iterate_nodes",  6457,  v81,  v80,  v54,  *v45,  *v48,  v85,  v82);
        }
      }
    }

    if ((_DWORD)v19)
    {
      if ((_DWORD)v19 != 45 && (_DWORD)v19 != 16) {
        goto LABEL_96;
      }
      uint64_t v56 = sub_10001E24C( (void *)a1,  v11,  v96,  v86,  *(_WORD *)(*(void *)(*v97 + 56) + 34LL) - 1,  v98,  &v18[(__int16)v26]);
      if ((_DWORD)v56)
      {
        uint64_t v19 = v56;
LABEL_96:
        sub_10003965C(*v97);
        sub_100013D94( "%s:%d: %s level %d node 0x%llx: error getting index %d child flags 0x%x: %d\n",  "btree_iterate_nodes");
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v57 = sub_10003DB5C(*(void *)v39);
      if ((_DWORD)v57)
      {
        uint64_t v19 = v57;
        uint64_t v69 = *(void *)(a1 + 8);
        if (v69) {
          BOOL v70 = (const char *)(v69 + 3992);
        }
        else {
          BOOL v70 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
        }
        int v75 = *(unsigned __int16 *)(*(void *)(*(void *)v39 + 56LL) + 34LL);
        uint64_t v76 = sub_10003965C(*v97);
        int v77 = *v45 - 1;
        uint64_t v78 = sub_10003965C(*(void *)v39);
        sub_100013D94( "%s:%d: %s level %d node 0x%llx: error ON WAIT getting index %d child 0x%llx flags 0x%x: %d\n",  "btree_iterate_nodes",  6470,  v70,  v75,  v76,  v77,  v78,  v92,  v19);
        sub_100038824(*(uint64_t **)v39);
        goto LABEL_95;
      }
    }

    sub_10003CF10(*(void *)v39, v14);
    if ((a3 & 1) == 0) {
      goto LABEL_79;
    }
    int v58 = *(void **)v39;
    unsigned int v59 = sub_100037DC0(*(void *)v39);
    uint64_t v60 = sub_10003CF9C(v58, (v59 >> 29) & 2, v98);
    if ((_DWORD)v60)
    {
      uint64_t v19 = v60;
      uint64_t v63 = *(void *)(a1 + 8);
      if (v63) {
        uint64_t v64 = (const char *)(v63 + 3992);
      }
      else {
        uint64_t v64 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
      }
      int v71 = *(unsigned __int16 *)(*(void *)(*(void *)v39 + 56LL) + 34LL);
      uint64_t v72 = sub_10003965C(*v97);
      int v73 = *v45 - 1;
      uint64_t v74 = sub_10003965C(*(void *)v39);
      sub_100013D94( "%s:%d: %s level %d node 0x%llx: error MODIFYING index %d child 0x%llx flags 0x%x: %d\n",  "btree_iterate_nodes",  6484,  v64,  v71,  v72,  v73,  v74,  v92,  v19);
      sub_10001E478(*(uint64_t **)v39, 2);
LABEL_95:
      *(void *)uint64_t v39 = 0LL;
      goto LABEL_96;
    }

LABEL_77:
    if (sub_10003965C(*(void *)v39) != *v11) {
      sub_100021784(*v97, (unsigned __int16)(WORD4(v18[v94]) - 1), (unint64_t *)(*(void *)v39 + 112LL), v98);
    }
    goto LABEL_79;
  }

LABEL_21:
  int v21 = v90;
  if ((((_WORD)v90 - 1) & 0x8000) == 0)
  {
    unsigned __int16 v22 = v90 - 1;
    do
    {
      uint64_t v23 = *(uint64_t **)&v18[v22];
      if (v23) {
        sub_10001E478(v23, v14);
      }
      int v24 = (__int16)v22--;
    }

    while (v24 > 0);
  }

  if (v18 != &v102) {
    sub_100014004(v18, (16 * v21));
  }
  return v19;
}

uint64_t sub_100028B04(uint64_t a1, _DWORD *a2)
{
  if (!a1) {
    return 22LL;
  }
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return 22LL;
  }
  uint64_t result = 0LL;
  *a2 = *(unsigned __int16 *)(v2 + 34) + 1;
  return result;
}

uint64_t sub_100028B2C(uint64_t a1, size_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (unint64_t *)((char *)&v20 - (HIWORD(a3[50]) & 0x7FLL) - 8);
  bzero(v10, a2);
  if ((_DWORD)a5 == 2)
  {
    else {
      uint64_t v12 = 0LL;
    }
    *(void *)(a4 + 8) = v12;
    unsigned __int16 v13 = sub_1000398B8(a4);
    char v14 = sub_100014240(v13);
    if (!v14) {
      return 22LL;
    }
    *(void *)(a4 + 416) = v14;
    if ((void *)a4 != a3) {
      *(_OWORD *)(a4 + 400) = *((_OWORD *)a3 + 25);
    }
    uint64_t v11 = sub_10003E7D8(a4);
    goto LABEL_11;
  }

  if ((_DWORD)a5 == 1)
  {
    uint64_t v11 = sub_10003E754((unsigned int *)a4);
LABEL_11:
    uint64_t v15 = v11;
    goto LABEL_13;
  }

  uint64_t v15 = 0LL;
LABEL_13:
  if (!(*(_WORD *)(*(void *)(a4 + 56) + 32LL) & 2 | v15))
  {
    unsigned int v16 = 0;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    while (v16 < *(_DWORD *)(*(void *)(a4 + 56) + 36LL))
    {
      *uint64_t v10 = 0LL;
      uint64_t v17 = sub_10001E938(a4, (unsigned __int16)v16, v10);
      if ((_DWORD)v17) {
        return v17;
      }
      uint64_t v17 = sub_10001E24C(a3, v10, 0LL, 2, *(_WORD *)(*(void *)(a4 + 56) + 34LL) - 1, 0LL, &v20);
      if ((_DWORD)v17) {
        return v17;
      }
      uint64_t v18 = (uint64_t *)v20;
      uint64_t v15 = sub_100028B2C(a1, a2, a3, v20, a5);
      sub_10003D514((uint64_t)v18, 1);
      sub_100038824(v18);
      ++v16;
      if ((_DWORD)v15) {
        return v15;
      }
    }

    return 0LL;
  }

  return v15;
}

uint64_t sub_100028D34(uint64_t a1, size_t a2, void *a3, uint64_t a4)
{
  return sub_100028B2C(a1, a2, a3, (uint64_t)a3, a4);
}

uint64_t sub_100028D40(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v15 = (uint64_t *)((char *)&v36 - v14);
  bzero((char *)&v36 - v14, v16);
  uint64_t v42 = 0LL;
  memset(v41, 0, sizeof(v41));
  unsigned int v17 = (a3 >> 26) & 0x10 | a4;
  LODWORD(v41[0]) = 2123139;
  *(_OWORD *)((char *)v41 + 8) = *(_OWORD *)(a2 + 400);
  unsigned int v38 = v17 | (a3 >> 22) & 0x20;
  uint64_t v18 = *(void *)(a2 + 416);
  *((void *)&v41[0] + 1) = *((void *)&v41[0] + 1) & 0xFFFFFFFFFFFFFE00LL | BYTE8(v41[0]) & 0x47 | v17 & 0x1B8 | (a3 >> 22) & 0x20;
  *((void *)&v41[1] + 1) = v18;
  uint64_t v19 = *(void *)(a2 + 56);
  WORD2(v41[0]) = *(_WORD *)(v19 + 32) & 0x1B;
  WORD3(v41[0]) = *(_WORD *)(v19 + 34);
  unint64_t v20 = *(pthread_mutex_t ***)(a2 + 8);
  if (!v20) {
    unint64_t v20 = *(pthread_mutex_t ***)(*(void *)a2 + 392LL);
  }
  unsigned __int16 v39 = -21846;
  int v21 = sub_1000398B8(a2);
  uint64_t v22 = sub_100027B58(v20, a3, v21, (uint64_t)v41, a5, a7);
  uint64_t v23 = v22;
  if ((_DWORD)a6 && !(*(_WORD *)(*(void *)(a2 + 56) + 32LL) & 2 | v22))
  {
    unsigned int v37 = a7;
    unsigned int v29 = 0;
    unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v40 = (const void *)0xAAAAAAAAAAAAAAAALL;
    while (1)
    {
      if (v29 >= *(_DWORD *)(*(void *)(a2 + 56) + 36LL))
      {
        uint64_t v23 = 0LL;
        goto LABEL_28;
      }

      *uint64_t v15 = 0LL;
      uint64_t v30 = sub_10001E938(a2, (unsigned __int16)v29, v15);
      if ((_DWORD)v30
        || (uint64_t v30 = sub_10001E24C(a1, v15, 0LL, 2, *(_WORD *)(*(void *)(a2 + 56) + 34LL) - 1, 0LL, &v43), (_DWORD)v30))
      {
        uint64_t v23 = v30;
        goto LABEL_28;
      }

      uint64_t v31 = v43;
      uint64_t v32 = sub_100028D40(a1, v43, a3, v38, a5, a6, &v42);
      if ((_DWORD)v32) {
        break;
      }
      uint64_t v23 = sub_10001E654(a2, (unsigned __int16)v29, &v40, &v39);
      if ((_DWORD)v23
        || (*uint64_t v15 = *(void *)(v42 + 112),
            uint64_t v23 = sub_1000212D0(*v37, (unsigned __int16)v29, v40, v39, v15, (*(_WORD *)(*v37 + 406) & 0x7Fu) + 8, a5),
            (_DWORD)v23))
      {
        uint64_t v33 = a1[1];
        if (v33) {
          uint64_t v34 = (const char *)(v33 + 3992);
        }
        else {
          uint64_t v34 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s btree_node_insert_internal failed: %d\n", "btree_node_copy", 6675, v34, v23);
      }

      sub_100038824(v42);
      sub_10003D514(v31, 1);
      sub_100038824(v31);
      uint64_t v42 = 0LL;
      ++v29;
      if ((_DWORD)v23) {
        goto LABEL_28;
      }
    }

    uint64_t v23 = v32;
    sub_10003D514(v31, 1);
    sub_100038824(v31);
    if (v42) {
      sub_100038824(v42);
    }
LABEL_28:
    a7 = v37;
    sub_10003E644(*v37, a5, 0LL);
    goto LABEL_29;
  }

  if (!(_DWORD)v22)
  {
    int v24 = (void *)(*(void *)(*a7 + 56) + 32LL);
    int v25 = (const void *)(*(void *)(a2 + 56) + 32LL);
    unsigned int v26 = sub_1000398C8(a2);
    memcpy(v24, v25, v26 - 32LL);
    uint64_t v27 = *a7;
    if ((*(_WORD *)(*(void *)(a2 + 56) + 32LL) & 1) != 0)
    {
      BOOL v28 = *(int **)(v27 + 392);
      *BOOL v28 = WORD4(v41[0]) & 0x1FF;
      v28[1] = (*((void *)&v41[0] + 1) >> 27) & 0x1F000;
      v28[2] = (DWORD2(v41[0]) >> 9) & 0x3FFF;
      v28[3] = (unsigned __int16)(*((void *)&v41[0] + 1) >> 23);
    }

    sub_100029588(v27, (uint64_t)v41, 0);
    uint64_t v23 = 0LL;
LABEL_29:
    sub_10003D514(*a7, 2);
  }

  return v23;
}

uint64_t sub_100029148(void *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t *a5)
{
  *a5 = 0LL;
  if ((a3 & 0x18) != 0) {
    uint64_t v9 = (a3 << 26) & 0x40000000 | ((a3 >> 3) << 31) | (((a3 >> 5) & 1) << 27) | a2;
  }
  else {
    uint64_t v9 = a2;
  }
  sub_10003CF10((uint64_t)a1, 1);
  uint64_t v10 = sub_100028D40(a1, (uint64_t)a1, v9, a3, a4, 1LL, a5);
  if ((_DWORD)v10)
  {
    size_t v11 = *a5;
    if (*a5)
    {
      unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
      sub_100029238(v11, a4, &v16);
      sub_100038824((uint64_t *)*a5);
      *a5 = 0LL;
    }
  }

  else
  {
    uint64_t v12 = a1[49];
    uint64_t v13 = *(void *)(*a5 + 392);
    __int128 v14 = *(_OWORD *)(v12 + 16);
    *(void *)(v13 + 32) = *(void *)(v12 + 32);
    *(_OWORD *)(v13 + 16) = v14;
  }

  sub_10003D514((uint64_t)a1, 1);
  return v10;
}

uint64_t sub_100029238(size_t a1, uint64_t a2, void *a3)
{
  if ((*(_BYTE *)(a1 + 19) & 0x80) != 0 || (*(_BYTE *)(a1 + 400) & 0x80) != 0)
  {
    uint64_t v8 = sub_1000293AC((void *)a1, a1, a2);
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6) {
      uint64_t v7 = sub_10003965C(v6);
    }
    else {
      uint64_t v7 = 0LL;
    }
    uint64_t v10 = *(void **)(*(void *)a1 + 392LL);
    int v11 = sub_100037DC0(a1);
    int v12 = sub_1000398C8(a1);
    uint64_t v13 = sub_10003965C(a1);
    if (a3) {
      uint64_t v14 = sub_100011884(v10, v11, v12, v7, v13, a2, 0, a3);
    }
    else {
      uint64_t v14 = sub_100011D2C(v10, v11, v12, v7, v13, a2, 0);
    }
    uint64_t v8 = v14;
    if ((_DWORD)v14)
    {
      uint64_t v15 = *(void *)(a1 + 8);
      if (v15) {
        unint64_t v16 = (const char *)(v15 + 3992);
      }
      else {
        unint64_t v16 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v17 = sub_10003965C(a1);
      int v18 = sub_100037DC0(a1);
      sub_100013D94( "%s:%d: %s error adding btree 0x%llx type 0x%x to reap list: %d\n",  "btree_delete",  6801,  v16,  v17,  v18,  v8);
    }
  }

  sub_10003D514(a1, 2);
  return v8;
}

uint64_t sub_1000293AC(void *a1, size_t a2, uint64_t a3)
{
  uint64_t v6 = (uint64_t *)((char *)&v12 - (HIWORD(a1[50]) & 0x7FLL) - 8);
  bzero(v6, a2);
  if ((*(_WORD *)(*(void *)(a2 + 56) + 32LL) & 2) == 0)
  {
    unsigned int v7 = 0;
    uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
    while (v7 < *(_DWORD *)(*(void *)(a2 + 56) + 36LL))
    {
      *uint64_t v6 = 0LL;
      uint64_t v8 = sub_10001E938(a2, (unsigned __int16)v7, v6);
      if ((_DWORD)v8
        || (uint64_t v8 = sub_10001E24C(a1, v6, 0LL, 0, *(_WORD *)(*(void *)(a2 + 56) + 34LL) - 1, 0LL, &v12), (_DWORD)v8))
      {
        uint64_t v10 = v8;
        goto LABEL_10;
      }

      uint64_t v9 = v12;
      sub_10003CF10(v12, 2);
      uint64_t v10 = sub_1000293AC(a1, v9, a3);
      sub_10003D514(v9, 2);
      sub_100038824(v9);
      ++v7;
      if ((_DWORD)v10) {
        goto LABEL_10;
      }
    }
  }

  uint64_t v10 = 0LL;
LABEL_10:
  sub_10003B238(a2, a3);
  return v10;
}

uint64_t sub_100029538(uint64_t a1, void *a2)
{
  if (!a1) {
    return 22LL;
  }
  uint64_t result = 0LL;
  *a2 = *(void *)(*(void *)(a1 + 392) + 32LL);
  return result;
}

uint64_t sub_100029588(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = sub_10001DB34((void *)a1, a2);
  if (!(_DWORD)result)
  {
    if (a2)
    {
      *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 8);
      *(void *)(a1 + 416) = *(void *)(a2 + 24);
    }

    uint64_t v8 = v6 + 56 + *(unsigned __int16 *)(v6 + 42);
    *(void *)(a1 + 376) = v6 + 56;
    *(void *)(a1 + 384) = v8;
    unsigned int v9 = sub_1000398C8(a1);
    __int16 v10 = *(_WORD *)(v6 + 32);
    uint64_t v11 = -40LL;
    if ((v10 & 1) == 0) {
      uint64_t v11 = 0LL;
    }
    uint64_t v12 = v6 + v9 + v11;
    *(void *)(a1 + 392) = v12;
    if ((v10 & 1) != 0)
    {
      unint64_t v13 = *(void *)(a1 + 400) & 0xFFFFFFFFFFFFFE00LL | *(_DWORD *)v12 & 0x1FF;
      *(void *)(a1 + 400) = v13;
      unint64_t v14 = v13 & 0xFFFFF07FFFFFFFFFLL | ((unint64_t)((*(_DWORD *)(v12 + 4) >> 12) & 0x1F) << 39);
      *(void *)(a1 + 400) = v14;
      unint64_t v15 = v14 & 0xFFFFFFFFFF8001FFLL | ((*(_DWORD *)(v12 + 8) & 0x3FFFLL) << 9);
      *(void *)(a1 + 400) = v15;
      *(void *)(a1 + 400) = v15 & 0xFFFFFF80007FFFFFLL | ((unint64_t)*(unsigned __int16 *)(v12 + 12) << 23);
      *(void *)(a1 + 408) = sub_10003965C(a1);
    }

    if (a3) {
      return sub_100002D08((void *)a1, a2);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100029670(uint64_t a1)
{
  int v1 = *(_WORD **)(a1 + 56);
  if ((v1[16] & 4) != 0)
  {
    if ((*(_BYTE *)(a1 + 400) & 4) == 0)
    {
      __int16 v3 = 0;
      return (unsigned __int16)(v1[23] + v3 + v1[25] + v1[27]);
    }

    __int16 v2 = 4;
  }

  else
  {
    __int16 v2 = 8;
  }

  unsigned int v4 = (unsigned __int16)v1[21];
  __int16 v5 = sub_10001E4C4(a1, 0);
  __int16 v3 = v4 - v5 * v2;
  return (unsigned __int16)(v1[23] + v3 + v1[25] + v1[27]);
}

uint64_t sub_1000296EC(uint64_t result, int a2, unsigned __int16 a3, __int16 *a4, unsigned __int16 *a5)
{
  if ((*(_BYTE *)(result + 400) & 0x40) != 0) {
    unsigned __int16 v5 = a3;
  }
  else {
    unsigned __int16 v5 = (a3 + 7) & 0xFFF8;
  }
  uint64_t v6 = 48LL;
  if (a2 != 1) {
    uint64_t v6 = 52LL;
  }
  uint64_t v7 = 392LL;
  if (a2 == 1) {
    uint64_t v7 = 384LL;
  }
  int v8 = *(unsigned __int16 *)(*(void *)(result + 56) + v6);
  unsigned __int16 v9 = -1;
  if (v8 == 0xFFFF)
  {
    __int16 v13 = -1;
    if (a4) {
      goto LABEL_40;
    }
    goto LABEL_41;
  }

  uint64_t v11 = result;
  int v24 = a4;
  int v25 = a5;
  uint64_t v12 = *(void *)(result + v7);
  __int16 v13 = -1;
  do
  {
    unsigned __int16 v9 = v8;
    uint64_t v14 = (unsigned __int16)v8;
    if (a2 == 1)
    {
      unsigned int v15 = *(unsigned __int16 *)(*(void *)(v11 + 56) + 44LL);
      BOOL v16 = v15 >= v9;
      unsigned int v17 = v15 - v9;
      if (v17 != 0 && v16 && v17 >= 4)
      {
        int v20 = *(unsigned __int16 *)(*(void *)(v11 + 384) + v14 + 2);
        if (v20 >= 4)
        {
          if ((*(_BYTE *)(v11 + 400) & 0x40) == 0) {
            int v20 = (v20 + 7) & 0x1FFF8;
          }
        }
      }
    }

    else
    {
      uint64_t result = sub_1000398C8(v11);
      uint64_t v18 = *(void *)(v11 + 56);
      if ((*(_BYTE *)(v18 + 32) & 1) != 0) {
        __int16 v19 = -96;
      }
      else {
        __int16 v19 = -56;
      }
      if (v9 <= (unsigned __int16)(result
                                                - *(_WORD *)(v18 + 42)
                                                + v19
                                                - (*(_WORD *)(v18 + 46)
                                                 + *(_WORD *)(v18 + 44)))
        && v9 >= 4u)
      {
        unsigned int v21 = *(unsigned __int16 *)(*(void *)(v11 + 392) - v14 + 2);
        if (v21 >= 4)
        {
          if ((*(_BYTE *)(v11 + 400) & 0x40) == 0) {
            unsigned int v21 = (v21 + 7) & 0x1FFF8;
          }
          if (v21 <= v9) {
            goto LABEL_33;
          }
        }
      }
    }

    uint64_t result = sub_100005194(*(void *)(*(void *)v11 + 392LL));
    if ((_DWORD)result) {
      break;
    }
LABEL_33:
    if (a2 == 1) {
      uint64_t v22 = v14;
    }
    else {
      uint64_t v22 = -v14;
    }
    uint64_t v23 = (unsigned __int16 *)(v12 + v22);
    int v8 = *v23;
    __int16 v13 = v9;
  }

  while (v8 != 0xFFFF);
  unsigned __int16 v9 = -1;
  __int16 v13 = -1;
LABEL_39:
  a4 = v24;
  a5 = v25;
  if (v24) {
LABEL_40:
  }
    *a4 = v13;
LABEL_41:
  if (a5) {
    *a5 = v9;
  }
  return result;
}

uint64_t sub_100029908(uint64_t a1, __int16 a2, uint64_t a3)
{
  uint64_t v51 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = *(void *)(a1 + 56);
  __int16 v7 = *(_WORD *)(v6 + 32);
  if ((v7 & 1) != 0)
  {
    uint64_t v10 = sub_100028D40(0LL, a1, 2281701376LL, (16 * v7) & 0x180, a3, 0LL, (uint64_t *)&v51);
    if ((_DWORD)v10) {
      return v10;
    }
    uint64_t v11 = *(void *)(a1 + 56);
    *(_DWORD *)(v11 + 36) = 0;
    *(_WORD *)(v11 + 44) = 0;
    uint64_t v12 = *(void *)(a1 + 392) - *(void *)(a1 + 384);
    *(_WORD *)(v11 + 46) = v12;
    *(void *)(v11 + 48) = 0xFFFF0000FFFFLL;
    bzero(*(void **)(a1 + 376), *(unsigned __int16 *)(v11 + 42) + (unint64_t)(unsigned __int16)v12);
    __int16 v13 = v51;
    uint64_t v14 = v51[7];
    goto LABEL_11;
  }

  __int128 v45 = xmmword_10005B940;
  int v46 = 2123139;
  __int128 v49 = *(_OWORD *)(a1 + 400);
  uint64_t v50 = *(void *)(a1 + 416);
  __int16 v47 = v7;
  __int16 v48 = *(_WORD *)(v6 + 34);
  int v8 = *(_DWORD *)(a1 + 40);
  LODWORD(v45) = *(unsigned __int16 *)(a1 + 36);
  DWORD1(v45) = v8;
  DWORD2(v45) = (*(void *)(a1 + 400) >> 27) & 0x1F000;
  uint64_t v9 = sub_10003A068( *(pthread_mutex_t **)a1,  -2013265920,  0LL,  (uint64_t)&v45,  (uint64_t)&v46,  *(void *)(a1 + 8),  a3,  (uint64_t *)&v51);
  if (!(_DWORD)v9)
  {
    unsigned int v15 = v51;
    BOOL v16 = (_OWORD *)v51[7];
    unsigned int v17 = *(_OWORD **)(a1 + 56);
    __int128 v18 = v17[1];
    _OWORD *v16 = *v17;
    v16[1] = v18;
    uint64_t v19 = sub_10003E6C0(a1, (uint64_t)v15);
    if ((_DWORD)v19)
    {
      uint64_t v10 = v19;
      uint64_t v20 = *(void *)(a1 + 8);
      if (v20) {
        unsigned int v21 = (const char *)(v20 + 3992);
      }
      else {
        unsigned int v21 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
      }
      uint64_t v22 = sub_10003965C(a1);
      uint64_t v23 = sub_10003965C((uint64_t)v51);
      sub_100013D94( "%s:%d: %s obj_exchange_phys (%llx, %llx) with xid %llu failed: %d\n",  "btree_node_compact",  1569,  v21,  v22,  v23,  a3,  v10);
LABEL_36:
      sub_10003B240((uint64_t)v51);
      sub_100038824(v51);
      sub_10003E644(a1, a3, 0LL);
      return v10;
    }

    sub_100029588(a1, (uint64_t)&v46, 0);
    sub_100029588((uint64_t)v51, (uint64_t)&v46, 0);
    __int16 v13 = v51;
    uint64_t v14 = v51[7];
    *(_WORD *)(*(void *)(a1 + 56) + 32LL) |= *(_WORD *)(v14 + 32) & 0x8000;
LABEL_11:
    int v24 = sub_10001E4C4((uint64_t)v13, a2);
    char v25 = 2;
    if ((*(_WORD *)(v14 + 32) & 4) == 0) {
      char v25 = 3;
    }
    sub_100029EFC(a1, (v24 << v25) & 0xFFFC);
    unsigned int v26 = v51;
    uint64_t v27 = v51[7];
    if (*(_DWORD *)(v27 + 36))
    {
      unsigned __int16 v28 = 0;
      while (1)
      {
        __int16 v29 = *(_WORD *)(v27 + 32);
        uint64_t v30 = v26[47];
        uint64_t v31 = v28;
        uint64_t v32 = (unsigned __int16 *)(v30 + 4LL * v28);
        uint64_t v33 = (unsigned __int16 *)(v30 + 8LL * v28);
        if ((v29 & 4) != 0)
        {
          uint64_t v33 = v32;
          int v34 = (*((_DWORD *)v26 + 100) >> 9) & 0x3FFF;
        }

        else
        {
          int v34 = *(unsigned __int16 *)(v30 + 8 * v31 + 2);
        }

        uint64_t v35 = *v33;
        uint64_t v36 = (unsigned __int16 *)(v30 + 4 * v31 + 2);
        uint64_t v37 = v30 + 8 * v31 + 4;
        if ((v29 & 4) == 0) {
          uint64_t v36 = (unsigned __int16 *)v37;
        }
        uint64_t v38 = *v36;
        unsigned int v39 = sub_10001E5DC((uint64_t)v26, v31);
        if ((_DWORD)v35 == 0xFFFF)
        {
          unsigned __int16 v41 = 0LL;
        }

        else
        {
          uint64_t v40 = sub_10001E710((uint64_t)v26, v35, v34);
          if ((_DWORD)v40) {
            break;
          }
          unsigned int v26 = v51;
          unsigned __int16 v41 = (const void *)(v51[48] + v35);
        }

        if (v38 > 0xFFFD)
        {
          uint64_t v42 = 0LL;
        }

        else
        {
          uint64_t v40 = sub_10001E838((uint64_t)v26, v38, v39);
          if ((_DWORD)v40) {
            break;
          }
          uint64_t v42 = (const void *)(v51[49] - v38);
        }

        uint64_t v40 = sub_1000212D0(a1, v31, v41, v34, v42, v39, a3);
        if ((_DWORD)v40) {
          break;
        }
        unsigned __int16 v28 = v31 + 1;
        unsigned int v26 = v51;
        uint64_t v27 = v51[7];
      }

      uint64_t v10 = v40;
      if ((v7 & 1) != 0)
      {
        memcpy((void *)(*(void *)(a1 + 56) + 32LL), (const void *)(v51[7] + 32LL), v51[49] - v51[7] - 32LL);
        unint64_t v43 = (void *)a1;
      }

      else
      {
        sub_10003E6C0(a1, (uint64_t)v51);
        sub_100029588(a1, 0LL, 0);
        unint64_t v43 = v51;
      }

      sub_100029588((uint64_t)v43, 0LL, 0);
    }

    else
    {
LABEL_30:
      uint64_t v10 = 0LL;
    }

    goto LABEL_36;
  }

  return v9;
}

uint64_t sub_100029CFC(uint64_t a1, int a2, unsigned __int16 a3, int a4, int a5)
{
  if (a5 == 0xFFFF) {
    return 22LL;
  }
  if ((*(void *)(a1 + 400) & 0x40LL) != 0) {
    unsigned __int16 v5 = a3;
  }
  else {
    unsigned __int16 v5 = (a3 + 7) & 0xFFF8;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  __int16 v7 = (_WORD *)(v6 + 48);
  uint64_t v8 = 48LL;
  if (a2 != 1)
  {
    uint64_t v8 = 52LL;
    __int16 v7 = (_WORD *)(v6 + 52);
  }

  uint64_t v9 = 392LL;
  if (a2 == 1)
  {
    uint64_t v9 = 384LL;
    int v10 = 1;
  }

  else
  {
    int v10 = -1;
  }

  uint64_t v11 = *(void *)(a1 + v9);
  v7[1] -= v5;
  if (a4 != 0xFFFF || (uint64_t result = 0LL, *(unsigned __int16 *)(v6 + v8) == a5))
  {
    int v13 = v5;
    int v14 = v10;
    unsigned int v15 = (_WORD *)(v11 + a5 * (uint64_t)v10);
    unsigned __int16 v16 = v15[1] - v13;
    if (v16 < 5u)
    {
      __int128 v18 = (_WORD *)(v11 + v10 * (uint64_t)a4);
      if (a4 != 0xFFFF) {
        __int16 v7 = v18;
      }
    }

    else
    {
      if (a4 != 0xFFFF) {
        __int16 v7 = (_WORD *)(v11 + v10 * (uint64_t)a4);
      }
      int v17 = v10 * v13 + a5;
      *__int16 v7 = v17;
      __int16 v7 = (_WORD *)(v11 + v14 * (uint64_t)v17);
      v7[1] = v16;
    }

    uint64_t result = 0LL;
    *__int16 v7 = *v15;
  }

  return result;
}

uint64_t sub_100029DF4(uint64_t a1, int a2, unsigned __int16 a3, _WORD *a4)
{
  unsigned __int16 v14 = -1;
  unsigned __int16 v13 = -1;
  sub_1000296EC(a1, a2, a3, (__int16 *)&v13, &v14);
  if (v14 == 0xFFFF)
  {
    if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v10 = a3;
    }
    else {
      unsigned __int16 v10 = (a3 + 7) & 0xFFF8;
    }
    uint64_t v11 = *(void *)(a1 + 56);
    unsigned int v12 = *(unsigned __int16 *)(v11 + 46);
    if (v12 < v10) {
      return 28LL;
    }
    if (a2 == 1)
    {
      LOWORD(v9) = *(_WORD *)(v11 + 44);
      *(_WORD *)(v11 + 44) = v9 + v10;
      *(_WORD *)(v11 + 46) = v12 - v10;
    }

    else
    {
      *(_WORD *)(v11 + 46) = v12 - v10;
      if (a2 == 2) {
        int v9 = *(_DWORD *)(a1 + 392)
      }
           - *(unsigned __int16 *)(v11 + 44)
           - (*(_DWORD *)(a1 + 384)
            + (unsigned __int16)(v12 - v10));
      else {
        LOWORD(v9) = -1;
      }
    }
  }

  else
  {
    uint64_t result = sub_100029CFC(a1, a2, a3, v13, v14);
    if ((_DWORD)result) {
      return result;
    }
    LOWORD(v9) = v14;
  }

  uint64_t result = 0LL;
  *a4 = v9;
  return result;
}

void sub_100029EFC(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  unsigned int v4 = *(unsigned __int16 *)(v3 + 42);
  unsigned __int16 v5 = v4 - a2;
  if (v4 >= a2)
  {
    if (v4 <= a2) {
      return;
    }
    memmove((void *)(*(void *)(a1 + 384) - v5), *(const void **)(a1 + 384), *(unsigned __int16 *)(v3 + 44));
    *(void *)(a1 + 384) -= v5;
    uint64_t v7 = *(void *)(a1 + 56);
    *(_WORD *)(v7 + 46) += v5;
    __int16 v8 = *(_WORD *)(v7 + 42) - v5;
  }

  else
  {
    unsigned __int16 v6 = a2 - v4;
    memmove( (void *)(*(void *)(a1 + 384) + (unsigned __int16)(a2 - v4)),  *(const void **)(a1 + 384),  *(unsigned __int16 *)(v3 + 44));
    bzero(*(void **)(a1 + 384), v6);
    *(void *)(a1 + 384) += v6;
    uint64_t v7 = *(void *)(a1 + 56);
    *(_WORD *)(v7 + 46) -= v6;
    __int16 v8 = *(_WORD *)(v7 + 42) + v6;
  }

  *(_WORD *)(v7 + 42) = v8;
}

void *sub_100029FB8(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  __int16 v4 = *(_WORD *)(v3 + 32);
  if ((v4 & 4) != 0) {
    char v5 = 2;
  }
  else {
    char v5 = 3;
  }
  unsigned int v6 = (a2 + (unsigned __int16)a3) << v5;
  int v7 = a2 + (__int16)-(__int16)a3;
  if ((v4 & 4) != 0) {
    char v8 = 2;
  }
  else {
    char v8 = 3;
  }
  uint64_t v9 = v7 << v8;
  if (a3 >= 0) {
    int v7 = a2;
  }
  else {
    unsigned int v6 = a2 << v8;
  }
  if (a3 >= 0)
  {
    char v8 = v5;
    uint64_t v9 = (a2 << v5);
  }

  return memmove( (void *)(*(void *)(a1 + 376) + v6),  (const void *)(*(void *)(a1 + 376) + v9),  ((*(_DWORD *)(v3 + 36) - v7) << v8) & 0xFFFC);
}

uint64_t sub_10002A028( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, void *a7, int a8)
{
  if (a8 != 8) {
    return 22LL;
  }
  uint64_t result = 0LL;
  *a5 = *a7;
  return result;
}

uint64_t sub_10002A048(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3 >= 0) {
    LOWORD(v7) = a3;
  }
  else {
    int v7 = -a3;
  }
  int v8 = (__int16)v7;
  if (a3 >= 0) {
    uint64_t v9 = a1;
  }
  else {
    uint64_t v9 = a2;
  }
  if (a3 >= 0) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = a1;
  }
  uint64_t v11 = *(_WORD **)(v10 + 56);
  if ((v11[16] & 4) != 0)
  {
    if ((*(_BYTE *)(v10 + 400) & 4) == 0) {
      goto LABEL_19;
    }
    __int16 v12 = 4;
  }

  else
  {
    __int16 v12 = 8;
  }

  unsigned __int16 v13 = sub_10001E4C4(v10, (__int16)v7) * v12;
  unsigned int v14 = (unsigned __int16)v11[21];
  if (v14 >= v13) {
    goto LABEL_19;
  }
  if (v13 - v14 <= (unsigned __int16)v11[23])
  {
    sub_100029EFC(v10, v13);
    goto LABEL_19;
  }

  uint64_t v15 = sub_100029908(v10, (unsigned __int16)v8, a4);
  if (!(_DWORD)v15)
  {
LABEL_19:
    memset(__n, 170, sizeof(__n));
    unsigned __int16 v58 = -21846;
    if (v9 == a2)
    {
      if (v8 < 1)
      {
        __int16 v37 = 0;
        int v38 = 0;
LABEL_60:
        uint64_t v15 = 0LL;
      }

      else
      {
        uint64_t v36 = sub_10001E654(a2, 0, &__n[10], __n);
        if ((_DWORD)v36)
        {
          uint64_t v15 = v36;
          __int16 v37 = 0;
          int v38 = 0;
        }

        else
        {
          int v38 = 0;
          do
          {
            uint64_t v39 = sub_10001E764((void *)a2, (unsigned __int16)v38, &__n[2], (__int16 *)&v58);
            if ((_DWORD)v39) {
              break;
            }
            uint64_t v39 = sub_1000212D0( a1,  *(unsigned __int16 *)(*(void *)(a1 + 56) + 36LL),  *(const void **)&__n[10],  *(unsigned __int16 *)__n,  *(const void **)&__n[2],  v58,  a4);
            if ((_DWORD)v39) {
              break;
            }
            uint64_t v40 = *(_WORD **)(a2 + 56);
            uint64_t v41 = *(void *)(a2 + 376);
            if ((*(_BYTE *)(a2 + 400) & 0x40) != 0) {
              __int16 v42 = *(_WORD *)__n;
            }
            else {
              __int16 v42 = (*(_WORD *)__n + 7) & 0xFFF8;
            }
            unsigned __int16 v43 = (v42 + 7) & 0xFFF8;
            if ((*(_BYTE *)(a2 + 400) & 0x40) != 0) {
              unsigned __int16 v43 = *(_WORD *)__n;
            }
            if (v43 >= 4u)
            {
              if ((v40[16] & 4) != 0) {
                uint64_t v44 = (unsigned __int16 *)(v41 + 4LL * (unsigned __int16)v38);
              }
              else {
                uint64_t v44 = (unsigned __int16 *)(v41 + 8LL * (unsigned __int16)v38);
              }
              uint64_t v45 = *v44;
              int v46 = (_WORD *)(*(void *)(a2 + 384) + v45);
              v46[1] = v43;
              *int v46 = v40[24];
              v40[24] = v45;
            }

            v40[25] += v43;
            unsigned __int16 v47 = v58;
            if (v58 && v58 != 65534)
            {
              if ((*(_BYTE *)(a2 + 400) & 0x40) != 0) {
                unsigned __int16 v48 = v58;
              }
              else {
                unsigned __int16 v48 = (v58 + 7) & 0xFFF8;
              }
              unsigned __int16 v49 = (v48 + 7) & 0xFFF8;
              if ((*(_BYTE *)(a2 + 400) & 0x40) == 0) {
                unsigned __int16 v47 = v49;
              }
              if (v47 >= 4u)
              {
                uint64_t v50 = v41 + 8LL * (unsigned __int16)v38 + 4;
                uint64_t v51 = (unsigned __int16 *)(v41 + 4LL * (unsigned __int16)v38 + 2);
                if ((v40[16] & 4) == 0) {
                  uint64_t v51 = (unsigned __int16 *)v50;
                }
                uint64_t v52 = *v51;
                uint64_t v53 = (_WORD *)(*(void *)(a2 + 392) - v52);
                v53[1] = v47;
                *uint64_t v53 = v40[26];
                v40[26] = v52;
              }

              v40[27] += v47;
            }

            __int16 v37 = ++v38;
            uint64_t v39 = sub_10001E654(a2, (unsigned __int16)v38, &__n[10], __n);
          }

          while (!(_DWORD)v39);
          uint64_t v15 = v39;
          __int16 v37 = v38;
        }
      }

      sub_100029FB8(a2, 0, (__int16)-v37);
      *(_DWORD *)(*(void *)(a2 + 56) + 36LL) -= v38;
    }

    else if (v8 < 1)
    {
      uint64_t v15 = 0LL;
    }

    else
    {
      sub_100029FB8(a2, 0, v8);
      uint64_t v16 = 0LL;
      uint64_t v17 = *(void *)(a2 + 56);
      *(_DWORD *)(v17 + 36) += (unsigned __int16)v8;
      *(_WORD *)(v17 + 32) |= 0x8000u;
      uint64_t v18 = *(void *)(a2 + 376);
      do
      {
        if ((*(_WORD *)(v17 + 32) & 4) != 0) {
          *(_DWORD *)(v18 + 4 * v16) = -1;
        }
        else {
          *(void *)(v18 + 8 * v16) = 0xFFFF0000FFFFLL;
        }
        ++v16;
      }

      while (v8 > (__int16)v16);
      LOWORD(v19) = 0;
      int v20 = *(_DWORD *)(*(void *)(a1 + 56) + 36LL);
      while (1)
      {
        uint64_t v21 = sub_10001E654(a1, (unsigned __int16)(v20 - 1), &__n[10], __n);
        if ((_DWORD)v21) {
          break;
        }
        uint64_t v21 = sub_10001E764( (void *)a1,  (unsigned __int16)(*(_WORD *)(*(void *)(a1 + 56) + 36LL) - 1),  &__n[2],  (__int16 *)&v58);
        if ((_DWORD)v21) {
          break;
        }
        uint64_t v21 = sub_1000209D8( a2,  (unsigned __int16)(v8 + ~(_WORD)v19),  *(void **)&__n[10],  *(unsigned __int16 *)__n,  *(void **)&__n[2]);
        if ((_DWORD)v21) {
          break;
        }
        uint64_t v22 = *(void *)(a1 + 56);
        int v20 = *(_DWORD *)(v22 + 36) - 1;
        *(_DWORD *)(v22 + 36) = v20;
        uint64_t v23 = *(void *)(a1 + 376);
        if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
          __int16 v24 = *(_WORD *)__n;
        }
        else {
          __int16 v24 = (*(_WORD *)__n + 7) & 0xFFF8;
        }
        unsigned __int16 v25 = (v24 + 7) & 0xFFF8;
        if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
          unsigned __int16 v25 = *(_WORD *)__n;
        }
        if (v25 >= 4u)
        {
          if ((*(_WORD *)(v22 + 32) & 4) != 0) {
            unsigned int v26 = (unsigned __int16 *)(v23 + 4LL * (unsigned __int16)v20);
          }
          else {
            unsigned int v26 = (unsigned __int16 *)(v23 + 8LL * (unsigned __int16)v20);
          }
          uint64_t v27 = *v26;
          unsigned __int16 v28 = (_WORD *)(*(void *)(a1 + 384) + v27);
          v28[1] = v25;
          *unsigned __int16 v28 = *(_WORD *)(v22 + 48);
          *(_WORD *)(v22 + 48) = v27;
        }

        *(_WORD *)(v22 + 50) += v25;
        unsigned __int16 v29 = v58;
        if (v58 && v58 != 65534)
        {
          if ((*(_BYTE *)(a1 + 400) & 0x40) != 0) {
            unsigned __int16 v30 = v58;
          }
          else {
            unsigned __int16 v30 = (v58 + 7) & 0xFFF8;
          }
          unsigned __int16 v31 = (v30 + 7) & 0xFFF8;
          if ((*(_BYTE *)(a1 + 400) & 0x40) == 0) {
            unsigned __int16 v29 = v31;
          }
          if (v29 >= 4u)
          {
            uint64_t v32 = v23 + 8LL * (unsigned __int16)v20 + 4;
            uint64_t v33 = (unsigned __int16 *)(v23 + 4LL * (unsigned __int16)v20 + 2);
            if ((*(_WORD *)(v22 + 32) & 4) == 0) {
              uint64_t v33 = (unsigned __int16 *)v32;
            }
            uint64_t v34 = *v33;
            uint64_t v35 = (_WORD *)(*(void *)(a1 + 392) - v34);
            v35[1] = v29;
            *uint64_t v35 = *(_WORD *)(v22 + 52);
            *(_WORD *)(v22 + 52) = v34;
          }

          *(_WORD *)(v22 + 54) += v29;
        }

        int v19 = (__int16)(v19 + 1);
        if (v19 >= v8)
        {
          uint64_t v15 = 0LL;
          *(_WORD *)(*(void *)(a2 + 56) + 32LL) &= ~0x8000u;
          goto LABEL_90;
        }
      }

      uint64_t v15 = v21;
      *(_WORD *)(*(void *)(a2 + 56) + 32LL) &= ~0x8000u;
      sub_100029FB8(a2, 0, (__int16)(v19 - v8));
    }

void sub_10002A5AC(uint64_t a1, int a2, uint64_t a3)
{
  int v9 = 2123139;
  if (a2) {
    __int16 v5 = 1;
  }
  else {
    __int16 v5 = 3;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  __int16 v10 = *(_WORD *)(v6 + 32) & 0x18 | v5;
  __int16 v11 = a2;
  __int128 v12 = *(_OWORD *)(a1 + 400);
  uint64_t v13 = *(void *)(a1 + 416);
  bzero((void *)(v6 + 32), ((*(void *)(a1 + 400) >> 27) & 0x1F000LL) - 72);
  uint64_t v7 = *(void *)(a1 + 56);
  unsigned int v8 = sub_1000398C8(a1);
  sub_10001DEB4(v7, v8, (uint64_t)&v9);
  sub_100029588(a1, (uint64_t)&v9, 0);
  sub_10003E644(a1, a3, 0LL);
}

uint64_t sub_10002A66C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(result + 432) == *(void *)(a3 + 112))
  {
    __int16 v4 = (void *)result;
    uint64_t v5 = *(void *)(a2 + 56);
    if ((*(_WORD *)(v5 + 32) & 2) != 0 || !*(_DWORD *)(v5 + 36))
    {
      *(void *)(result + 432) = *(void *)(a2 + 112);
    }

    else
    {
      __chkstk_darwin();
      uint64_t v7 = (uint64_t *)((char *)&v12 - v6);
      bzero((char *)&v12 - v6, v8);
      uint64_t result = sub_10001E938(a2, (unsigned __int16)(*(_WORD *)(*(void *)(a2 + 56) + 36LL) - 1), v7);
      if ((_DWORD)result)
      {
        uint64_t v9 = v4[1];
        if (v9) {
          __int16 v10 = (const char *)(v9 + 3992);
        }
        else {
          __int16 v10 = (const char *)(*(void *)(*(void *)(*v4 + 392LL) + 384LL) + 208LL);
        }
        uint64_t result = (uint64_t)sub_100013D94( "%s:%d: %s failed to update rightmost leaf field: %d\n",  "bt_update_last_leaf",  2518,  v10,  result);
        uint64_t v11 = 0LL;
      }

      else
      {
        uint64_t v11 = *v7;
      }

      v4[54] = v11;
    }
  }

  return result;
}

void sub_10002A7C4( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a6;
  uint64_t v77 = a6;
  __chkstk_darwin();
  uint64_t v17 = (uint64_t *)((char *)&v68 - v16);
  bzero((char *)&v68 - v16, v18);
  int v75 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v74 = -21846;
  uint64_t v19 = *(void *)(a4 + 56);
  if (!a2)
  {
    if ((*(_WORD *)(v19 + 32) & 2) != 0 || *(_DWORD *)(v19 + 36) != 1) {
      return;
    }
    if (a5 || v10 && (*(_BYTE *)(v10 + 16) & 0x10) != 0)
    {
      if (sub_10001E938(a4, 0, v17)
        || sub_10001E24C((void *)a1, v17, a7, 3, *(_WORD *)(*(void *)(a4 + 56) + 34LL) - 1, a8, &v77))
      {
        return;
      }

      uint64_t v10 = v77;
      if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && *(void *)(v77 + 112) != *v17) {
        sub_100021784(a4, 0, (unint64_t *)(v77 + 112), a8);
      }
      int v44 = 1;
    }

    else
    {
      int v44 = 0;
    }

    if (sub_100029670(v10) > 0x27)
    {
      uint64_t v48 = *(void *)(v10 + 56);
      if (*(unsigned __int16 *)(v48 + 46) > 0x27u
        || ((*(_WORD *)(v48 + 32) & 4) == 0 || (*(_BYTE *)(v10 + 400) & 4) != 0)
        && (sub_100029908(v10, 0LL, a8), *(unsigned __int16 *)(*(void *)(v10 + 56) + 46LL) > 0x27u))
      {
        sub_1000257A4(a4, 0, a8);
        sub_10002A5AC(a4, (unsigned __int16)(*(_WORD *)(*(void *)(a4 + 56) + 34LL) - 1), a8);
        int v49 = sub_10002A048(a4, v10, (__int16)-*(_WORD *)(*(void *)(v10 + 56) + 36LL), a8);
        if (!v49)
        {
          sub_10002A66C(a1, a4, v10);
          sub_10003B238((uint64_t *)v10, a8);
          if (v44)
          {
            sub_10003D514(v10, 2);
            sub_100038824(v10);
          }

          uint64_t v63 = (unint64_t *)(*(void *)(a1 + 392) + 32LL);
          do
            unint64_t v64 = __ldxr(v63);
          while (__stxr(v64 - 1, v63));
          goto LABEL_51;
        }

        uint64_t v50 = *(void *)(a1 + 8);
        if (v50) {
          uint64_t v51 = (const char *)(v50 + 3992);
        }
        else {
          uint64_t v51 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94("%s:%d: %s failed to move all entries: %d\n", "bt_merge_nodes", 4371, v51, v49);
        sub_10002A048(a4, v10, *(__int16 *)(*(void *)(a4 + 56) + 36LL), a8);
        sub_10002A5AC(a4, (unsigned __int16)(*(_WORD *)(*(void *)(a4 + 56) + 34LL) + 1), a8);
        if (!sub_10001E654(v10, 0, &v75, &v74))
        {
          *uint64_t v17 = *(void *)(v10 + 112);
          sub_1000212D0(a4, 0, v75, v74, v17, (*(_WORD *)(a4 + 406) & 0x7F) + 8, a8);
        }
      }
    }

    if (!v44) {
      return;
    }
    sub_10003D514(v10, 2);
    uint64_t v65 = v10;
    goto LABEL_110;
  }

  if (!*(_DWORD *)(v19 + 36))
  {
    sub_1000257A4(a2, a3, a8);
    uint64_t v45 = *(void *)(a2 + 56);
    if ((*(_WORD *)(v45 + 32) & 1) != 0 && !*(_DWORD *)(v45 + 36)) {
      sub_10002A5AC(a2, 0, a8);
    }
    sub_10002A66C(a1, a2, a4);
    sub_10003B238((uint64_t *)a4, a8);
    int v46 = (unint64_t *)(*(void *)(a1 + 392) + 32LL);
    do
      unint64_t v47 = __ldxr(v46);
    while (__stxr(v47 - 1, v46));
LABEL_51:
    sub_10003E644(a1, a8, 0LL);
    return;
  }

  if (*(_DWORD *)(*(void *)(a2 + 56) + 36LL) - 1 > a3)
  {
    uint64_t v20 = a3 + 1;
    if (!sub_10001E938(a2, (unsigned __int16)v20, v17))
    {
      uint64_t v76 = (void *)0xAAAAAAAAAAAAAAAALL;
      if (!sub_10001E24C((void *)a1, v17, a7, 3, *(_WORD *)(*(void *)(a2 + 56) + 34LL) - 1, a8, &v76))
      {
        if ((*(_BYTE *)(a1 + 400) & 0x10) != 0 && v76[14] != *v17) {
          sub_100021784(a2, (unsigned __int16)v20, v76 + 14, a8);
        }
        uint64_t v21 = *(void *)(a4 + 56);
        if ((*(_WORD *)(v21 + 32) & 4) != 0)
        {
          unsigned int v52 = *(_DWORD *)(v21 + 36);
          __int16 v24 = v76;
          uint64_t v72 = v76[7];
          int v43 = *(_DWORD *)(v72 + 36);
          unsigned int v53 = v43 + v52;
          if (v43 + v52 <= sub_10001E4C4(a4, 0))
          {
            uint64_t v73 = 0LL;
            LOWORD(v30) = v43;
          }

          else
          {
            else {
              uint64_t v30 = (v53 >> 1) - v52;
            }
            uint64_t v73 = v30;
          }
        }

        else
        {
          uint64_t v69 = v20;
          __int16 v22 = sub_10001E4C4(a4, 0);
          unsigned int v23 = sub_100029670(a4);
          __int16 v24 = v76;
          int v25 = sub_100029670((uint64_t)v76);
          unsigned int v26 = 0;
          int v27 = 0;
          uint64_t v72 = v24[7];
          uint64_t v73 = 0LL;
          unsigned int v28 = *(_DWORD *)(v72 + 36);
          unsigned int v29 = 8 * (v22 & 0x1FFF);
          int v70 = v23 - ((v25 + v23) >> 1);
          unsigned int v71 = v28;
          do
          {
            LODWORD(v30) = v26;
            if (!(_WORD)v73 && (_WORD)v26)
            {
              int v31 = sub_10001E4C4(a4, (__int16)v26);
              int v32 = (8 * (_WORD)v31 - (_WORD)v29) & 0xFFF8;
              if (((8 * v31) & 0xFFF8u) <= v29) {
                int v32 = 0;
              }
              else {
                uint64_t v33 = v26;
              }
              uint64_t v73 = v33;
            }

            uint64_t v34 = v24[50];
            __int16 v35 = *(_WORD *)(v72 + 32);
            if ((v34 & 0x40) != 0)
            {
              if ((v35 & 4) != 0) {
                unsigned int v37 = (v34 >> 9) & 0x3FFF;
              }
              else {
                unsigned int v37 = *(unsigned __int16 *)(v24[47] + 8LL * (unsigned __int16)v30 + 2);
              }
            }

            else
            {
              if ((v35 & 4) != 0) {
                unsigned int v36 = (v34 >> 9) & 0x3FFF;
              }
              else {
                unsigned int v36 = *(unsigned __int16 *)(v24[47] + 8LL * (unsigned __int16)v30 + 2);
              }
              unsigned int v37 = (v36 + 7) & 0x1FFF8;
            }

            int v38 = v37 + v27;
            int v39 = sub_10001E5DC((uint64_t)v24, (unsigned __int16)v30);
            if (v39 == 65534) {
              int v40 = 0;
            }
            else {
              int v40 = v39;
            }
            if ((v34 & 0x40) == 0) {
              int v40 = (v40 + 7) & 0x1FFF8;
            }
            int v27 = v38 + v40;
            unsigned int v26 = v30 + 1;
            int v41 = sub_10001E4C4(a4, (__int16)(v30 + 1));
            int v42 = (8 * (_WORD)v41 - (_WORD)v29) & 0xFFF8;
            if (((8 * v41) & 0xFFF8u) <= v29) {
              int v42 = 0;
            }
          }

          while (v42 + (unsigned __int16)v27 <= v23);
          LOWORD(v20) = v69;
          int v43 = v71;
        }

        if (v43 != (unsigned __int16)v30)
        {
          if ((*(_WORD *)(*(void *)(a2 + 56) + 32LL) & 4) != 0) {
            int v54 = (*(_DWORD *)(a2 + 400) >> 9) & 0x3FFF;
          }
          else {
            int v54 = *(unsigned __int16 *)(*(void *)(a2 + 376) + 8LL * (unsigned __int16)v20 + 2);
          }
          if ((*(_WORD *)(v72 + 32) & 4) != 0) {
            int v55 = (*((_DWORD *)v24 + 100) >> 9) & 0x3FFF;
          }
          else {
            int v55 = *(unsigned __int16 *)(v24[47] + 8LL * (unsigned __int16)v73 + 2);
          }
          unsigned __int16 v74 = v55;
          uint64_t v56 = *(void *)(a2 + 400);
          if ((v56 & 0x40) != 0) {
            unsigned int v57 = v54;
          }
          else {
            unsigned int v57 = (v54 + 7) & 0x1FFF8;
          }
          unsigned int v58 = (v55 + 7) & 0x1FFF8;
          if ((v56 & 0x40) != 0) {
            unsigned int v58 = v55;
          }
          if (v57 >= v58)
          {
            LOWORD(v30) = v73;
          }

          else
          {
            if ((v56 & 0x40) == 0)
            {
              LOWORD(v55) = (v55 + 7) & 0xFFF8;
              LOWORD(v54) = (v54 + 7) & 0xFFF8;
            }

            BOOL v59 = sub_100021854(a2, 0, 0LL, 0LL, v55 - v54, 0, 0LL);
            LOWORD(v30) = v73;
            if (!v59) {
              goto LABEL_109;
            }
          }
        }

        if ((_WORD)v30 && !sub_10002A048(a4, (uint64_t)v24, (__int16)-(__int16)v30, a8))
        {
          if (*(_DWORD *)(v24[7] + 36))
          {
            int v60 = sub_10001E654((uint64_t)v24, 0, &v75, &v74);
            if (v60 || (int v60 = sub_1000209D8(a2, (unsigned __int16)v20, v75, v74, 0LL)) != 0)
            {
              uint64_t v61 = *(void *)(a1 + 8);
              if (v61) {
                uint64_t v62 = (const char *)(v61 + 3992);
              }
              else {
                uint64_t v62 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
              }
              sub_100013D94("%s:%d: %s btree_node_key_update failed: %d\n", "bt_merge_nodes", 4512, v62, v60);
            }
          }

          else
          {
            sub_1000257A4(a2, (unsigned __int16)v20, a8);
            sub_10002A66C(a1, a2, (uint64_t)v24);
            sub_10003B238(v24, a8);
            uint64_t v66 = (unint64_t *)(*(void *)(a1 + 392) + 32LL);
            do
              unint64_t v67 = __ldxr(v66);
            while (__stxr(v67 - 1, v66));
            sub_10003E644(a1, a8, 0LL);
          }
        }

LABEL_109:
        sub_10003D514((uint64_t)v24, 2);
        uint64_t v65 = (uint64_t)v24;
LABEL_110:
        sub_100038824(v65);
      }
    }
  }

uint64_t sub_10002B01C(uint64_t a1, uint64_t a2, unsigned __int8 a3, unsigned int a4, char *a5)
{
  if (a4) {
    size_t v5 = a4;
  }
  else {
    size_t v5 = 0x10000LL;
  }
  bzero(a5, 0x558uLL);
  if (!a1 || (uint64_t result = sub_1000139BC((pthread_mutex_t *)(a5 + 16)), !(_DWORD)result))
  {
    *(void *)a5 = a1;
    *((void *)a5 + 1) = a2;
    *((_DWORD *)a5 + 22) = a3 | ((_DWORD)v5 << 8);
    uint64_t v11 = sub_100013EEC(v5, 0x18uLL);
    *((void *)a5 + 10) = v11;
    if (v11)
    {
      sub_10002B0E0((uint64_t)a5);
      return 0LL;
    }

    else
    {
      if (a1) {
        j__pthread_mutex_destroy((pthread_mutex_t *)(a5 + 16));
      }
      return 12LL;
    }
  }

  return result;
}

uint64_t sub_10002B0E0(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 88);
  if (v1 <= 0x2FF)
  {
    int v5 = (v1 >> 8) - 1;
    uint64_t v2 = *(void *)(result + 80);
  }

  else
  {
    uint64_t v2 = *(void *)(result + 80);
    int v3 = 1;
    int v4 = 1;
    do
    {
      *(void *)(v2 + 24LL * (unsigned __int16)v4++) = (v3 + 1);
      int v3 = (unsigned __int16)v4;
      int v5 = (*(_DWORD *)(result + 88) >> 8) - 1;
    }

    while (v5 > (unsigned __int16)v4);
  }

  *(void *)(v2 + 24LL * v5) = 0LL;
  *(_WORD *)(result + 92) = 1;
  return result;
}

void sub_10002B150(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 80);
    if (v2)
    {
      sub_100014004(v2, 24 * ((unint64_t)*(unsigned int *)(a1 + 88) >> 8));
      *(void *)(a1 + 80) = 0LL;
    }

    if (*(void *)a1)
    {
      j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
      *(void *)a1 = 0LL;
    }
  }

uint64_t sub_10002B1A8(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 88);
  if (HIBYTE(v2))
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v4 = *(void *)(a1 + 8);
    sub_10002B150(a1);
    uint64_t result = sub_10002B01C(v5, v4, v2, (unsigned __int16)(v2 >> 8), (char *)a1);
    if ((_DWORD)result)
    {
      int v6 = *(unsigned __int8 *)(a1 + 88);
      uint64_t v7 = "main";
      if (v6 == 1) {
        uint64_t v7 = "tier2";
      }
      uint64_t result = (uint64_t)sub_100013D94( "%s:%d: %s dev %d Error reinitializing %s free extent cache: %d\n",  "spaceman_free_extent_cache_reset",  262,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  v6,  v7,  result);
      *(void *)(a1 + 280) |= 2uLL;
    }
  }

  else
  {
    bzero((void *)(a1 + 92), 0x4FCuLL);
    bzero(*(void **)(a1 + 80), 24LL * (unsigned __int16)(v2 >> 8));
    return sub_10002B0E0(a1);
  }

  return result;
}

uint64_t sub_10002B2B0(uint64_t a1, unint64_t a2)
{
  if (a2 <= 1) {
    unint64_t v2 = 1LL;
  }
  else {
    unint64_t v2 = a2;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  unint64_t v5 = *(void *)(a1 + 176);
  if (v5 <= *(void *)(a1 + 224)) {
    unint64_t v5 = *(void *)(a1 + 224);
  }
  if (v5 < *(void *)(a1 + 248) || (uint64_t v6 = *(void *)(a1 + 128), (unint64_t)(v6 - *(void *)(a1 + 120)) > 3))
  {
LABEL_15:
    uint64_t v3 = 0LL;
  }

  else
  {
    *(void *)(a1 + 328) = v6;
    uint64_t v3 = 1LL;
  }

  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return v3;
}

void sub_10002B380(void *a1)
{
  uint64_t v30 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  if (!sub_100044238(a1, (uint64_t *)&v30))
  {
    uint64_t v1 = 0LL;
    for (char i = 1; ; char i = 0)
    {
      char v3 = i;
      uint64_t v4 = v30[47];
      unint64_t v5 = *(void *)(v4 + 48 * v1 + 48);
      if (!v5) {
        goto LABEL_42;
      }
      uint64_t v6 = v30[v1 + 196];
      if (!v6) {
        goto LABEL_42;
      }
      char v29 = v3;
      unint64_t v7 = *(void *)(v4 + 48 * v1 + 72);
      unint64_t v8 = *(unsigned __int16 *)(v6 + 94);
      if (*(void *)v6) {
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
      }
      uint64_t v9 = v6 + 1264;
      else {
        uint64_t v28 = *(void *)(*(void *)(v6 + 80)
      }
      if (sub_10002E5C8(v6, v6 + 1264))
      {
        uint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
      }

      else
      {
        uint64_t v27 = *(void *)(*(void *)(v6 + 80) + 24LL
                                               * *(unsigned __int16 *)(v9 + 4LL * *(unsigned __int8 *)(v6 + 1361))) & 0xFFFFFFFFFFFFFLL;
        if (sub_10002D410(v6, v6 + 1264, 0))
        {
          uint64_t v11 = 0LL;
          uint64_t v10 = v27;
        }

        else
        {
          uint64_t v12 = (void *)(*(void *)(v6 + 80)
                         + 24LL * *(unsigned __int16 *)(v9 + 4LL * *(unsigned __int8 *)(v6 + 1361)));
          uint64_t v10 = v27;
          uint64_t v11 = (*v12 & 0xFFFFFFFFFFFFFLL) - v27 + (v12[1] & 0xFFFFFFFFFFFFFLL);
        }
      }

      unint64_t v13 = *(void *)(v6 + 96);
      if (v13 <= 1) {
        uint64_t v14 = 1LL;
      }
      else {
        uint64_t v14 = *(void *)(v6 + 96);
      }
      if (v7) {
        unint64_t v15 = v7;
      }
      else {
        unint64_t v15 = v14;
      }
      if ((_DWORD)v8) {
        unint64_t v16 = v13 / v8;
      }
      else {
        unint64_t v16 = 0LL;
      }
      sub_100013D04( "%s:%d: %s dev %d smfree %lld/%lld table %d/%d blocks %lld %lld:%lld:%lld %d.%02d%% range %lld:%lld %d.%02d%% scans %lld\n",  "spaceman_fxc_print_stats",  477,  (const char *)(*(void *)(*(void *)v6 + 384LL) + 208LL),  *(_DWORD *)(v6 + 88),  v7,  v5,  v8,  (*(_DWORD *)(v6 + 88) >> 8) - 1,  v13,  *(void *)(v6 + 120),  v16,  v28,  10000 * v13 / v15 / 0x64,  10000 * v13 / v15 % 0x64,  v10,  v11,  10000 * v11 / v5 / 0x64,  10000 * v11 / v5 % 0x64,  *(void *)(v6 + 336));
      uint64_t v17 = (void *)(v6 + 272);
      uint64_t v18 = 3LL;
      do
      {
        unint64_t v19 = *(v17 - 4);
        if (v19)
        {
          if (v7) {
            unint64_t v20 = v7;
          }
          else {
            unint64_t v20 = *(v17 - 4);
          }
          unint64_t v21 = *(v17 - 5);
          if (v21) {
            unint64_t v22 = v19 / v21;
          }
          else {
            unint64_t v22 = 0LL;
          }
          sub_100013D04( "%s:%d: %s dev %d scan_stats[%d]: foundmax %lld extents %lld blocks %lld long %lld avg %lld %d.%02d%% range % lld:%lld %d.%02d%%\n",  "spaceman_fxc_print_stats",  496,  (const char *)(*(void *)(*(void *)v6 + 384LL) + 208LL),  *(unsigned __int8 *)(v6 + 88),  v18 - 1,  *v17,  v21,  v19,  *(v17 - 3),  v22,  10000 * v19 / v20 / 0x64,  10000 * v19 / v20 % 0x64,  *(v17 - 2),  *(v17 - 1),  10000LL * *(v17 - 1) / v5 / 0x64,  10000LL * *(v17 - 1) / v5 % 0x64);
        }

        v17 -= 6;
        --v18;
      }

      while (v18);
      uint64_t v23 = *(void *)(v6 + 344);
      uint64_t v24 = *(void *)v6;
      if (v23)
      {
        sub_100013D04( "%s:%d: %s dev %d Searches: %lld success %lld fail %lld partial %lld, bm search yes:%lld (%lld/%lld/%lld) no:%lld/%lld\n",  "spaceman_fxc_print_stats",  509,  (const char *)(*(void *)(v24 + 384) + 208LL),  *(unsigned __int8 *)(v6 + 88),  v23,  *(void *)(v6 + 352),  *(void *)(v6 + 424),  *(void *)(v6 + 416),  *(void *)(v6 + 448),  *(void *)(v6 + 456),  *(void *)(v6 + 464),  *(void *)(v6 + 472),  *(void *)(v6 + 432),  *(void *)(v6 + 440));
        unint64_t v25 = *(void *)(v6 + 360);
        char v3 = v29;
        if (v25) {
          unint64_t v26 = *(void *)(v6 + 368) / v25;
        }
        else {
          unint64_t v26 = 0LL;
        }
        sub_100013D04( "%s:%d: %s dev %d Remainders: zero %lld one %lld tiny %lld small %lld good %lld, total %lld blocks %lld avg %lld\n",  "spaceman_fxc_print_stats",  515,  (const char *)(*(void *)(*(void *)v6 + 384LL) + 208LL),  *(unsigned __int8 *)(v6 + 88),  *(void *)(v6 + 408),  *(void *)(v6 + 400),  *(void *)(v6 + 392),  *(void *)(v6 + 384),  *(void *)(v6 + 376),  v25,  *(void *)(v6 + 368),  v26);
        if (!*(void *)v6) {
          goto LABEL_42;
        }
      }

      else
      {
        char v3 = v29;
        if (!v24) {
          goto LABEL_42;
        }
      }

      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 16));
LABEL_42:
      uint64_t v1 = 1LL;
      if ((v3 & 1) == 0)
      {
        sub_100038824(v30);
        return;
      }
    }
  }

uint64_t sub_10002B770(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0LL;
  for (char i = 1; ; char i = 0)
  {
    char v6 = i;
    uint64_t v7 = a2 + 8 * v4;
    if (!*(void *)(v7 + 1568))
    {
      unint64_t v8 = *(void *)(*(void *)(a2 + 376) + 48 * v4 + 48);
      if (v8)
      {
        uint64_t v9 = v7 + 1568;
        uint64_t v10 = (char *)sub_100013EEC(1uLL, 0x558uLL);
        *(void *)uint64_t v9 = v10;
        if (!v10)
        {
          uint64_t v13 = 12LL;
          goto LABEL_13;
        }

        unint64_t v11 = v8 >> 18;
        if (v8 >> 18 >= 0xFF80) {
          LODWORD(v11) = 65408;
        }
        uint64_t v12 = sub_10002B01C(a1, a2, v4, (int)v11 + 128, v10);
        if ((_DWORD)v12) {
          break;
        }
      }
    }

    uint64_t v4 = 1LL;
    if ((v6 & 1) == 0) {
      return 0LL;
    }
  }

  uint64_t v13 = v12;
  if (*(void *)v9) {
    *(void *)(*(void *)v9 + 280LL) |= 2uLL;
  }
LABEL_13:
  sub_100013D94( "%s:%d: %s failed to initialize free extent cache for device %d, error %d\n",  "spaceman_free_extent_cache_setup",  1556,  (const char *)(*(void *)(a1 + 384) + 208LL),  v4,  v13);
  return v13;
}

uint64_t sub_10002B884(unint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  if (!a1) {
    return 22LL;
  }
  unint64_t v4 = a4;
  if ((a4 | a3) >> 52) {
    return 84LL;
  }
  if (!a4) {
    return 0LL;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  uint64_t v8 = *(void *)(a1 + 280);
  if ((v8 & 2) == 0)
  {
    unint64_t v9 = a1 + 48LL * ((v8 & 4) == 0);
    unint64_t v11 = *(void *)(v9 + 176);
    uint64_t v10 = (unint64_t *)(v9 + 176);
    if (v11 < v4) {
      *uint64_t v10 = v4;
    }
    unsigned __int16 v74 = -21846;
    int v12 = sub_10002BFD4(a1, v4, a3);
    if (v12 == 55)
    {
      unint64_t v13 = a1 + 16LL * (a2 ^ 1u);
      uint64_t v14 = *(void *)(v13 + 296);
      if (v14)
      {
        if (v14 < a3 && v4 + a3 < *(void *)(v13 + 304))
        {
          unint64_t v15 = (uint64_t *)(v13 + 296);
          sub_10002C1F4(a1, a3, v4);
          uint64_t v16 = 0LL;
          *unint64_t v15 = a3;
          goto LABEL_28;
        }
      }
    }

    uint64_t v17 = *(void **)a1;
    unint64_t v18 = a3;
    if (*(_BYTE *)(a1 + 88) == 1) {
      unint64_t v18 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v17[47] + 36LL)))) | a3;
    }
    int v19 = sub_10004419C(v17, *(void *)(a1 + 8), v18, v4);
    if (v19)
    {
      int v20 = v19;
      if (sub_100013538(*(void *)a1)) {
        sub_100013D94( "%s:%d: %s dev %d free extent %lld:%lld appears to span container metadata and should not be free: %d\n",  "spaceman_free_extent_cache_insert",  1648,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  a3,  v4,  v20);
      }
      goto LABEL_25;
    }

    unint64_t v21 = (_OWORD *)(a1 + 1068);
    uint64_t v16 = sub_10002C238(a1, 0, a3, v4, a1 + 1068);
    if ((_DWORD)v16) {
      goto LABEL_27;
    }
    int v23 = *((unsigned __int16 *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165));
    uint64_t v24 = (_OWORD *)(a1 + 1166);
    __int128 v25 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v25;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    __int128 v26 = *(_OWORD *)(a1 + 1084);
    *(_OWORD *)(a1 + 1166) = *v21;
    *(_OWORD *)(a1 + 1182) = v26;
    __int128 v27 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v27;
    if (v23)
    {
      uint64_t v16 = 0LL;
    }

    else
    {
      uint64_t v48 = sub_10002E75C(a1, a1 + 1166, -1);
      uint64_t v16 = v48;
      if ((v48 & 0xFFFFFFFD) != 0) {
        goto LABEL_27;
      }
      if ((_DWORD)v48 == 2)
      {
        uint64_t v16 = 2LL;
        goto LABEL_34;
      }
    }

    unsigned int v28 = *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263));
    char v29 = (void *)(*(void *)(a1 + 80) + 24LL * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263)));
    uint64_t v30 = *v29 & 0xFFFFFFFFFFFFFLL;
    unint64_t v31 = v29[1] & 0xFFFFFFFFFFFFFLL;
    if (v31 + v30 >= a3)
    {
      unint64_t v4 = v4 + a3 - v30;
      __int128 v49 = *(_OWORD *)(a1 + 1246);
      *(_OWORD *)(a1 + 1132) = *(_OWORD *)(a1 + 1230);
      *(_OWORD *)(a1 + 1148) = v49;
      *(_WORD *)(a1 + 1164) = *(_WORD *)(a1 + 1262);
      __int128 v50 = *(_OWORD *)(a1 + 1182);
      *unint64_t v21 = *v24;
      *(_OWORD *)(a1 + 1084) = v50;
      __int128 v51 = *(_OWORD *)(a1 + 1214);
      *(_OWORD *)(a1 + 1100) = *(_OWORD *)(a1 + 1198);
      *(_OWORD *)(a1 + 1116) = v51;
      if (v4 <= v31)
      {
        if ((_DWORD)v16)
        {
          uint64_t v16 = 1LL;
          goto LABEL_27;
        }

        goto LABEL_28;
      }

      uint64_t v16 = sub_10002C368(a1, v30, v31, v4, v28);
      if ((_DWORD)v16) {
        goto LABEL_27;
      }
      unint64_t v52 = a1 + 48LL * ((*(_DWORD *)(a1 + 280) & 4) == 0);
      unint64_t v54 = *(void *)(v52 + 176);
      unsigned int v53 = (unint64_t *)(v52 + 176);
      if (v54 < v4) {
        *unsigned int v53 = v4;
      }
      sub_10002C668(a1, v30, v4);
      uint64_t v16 = 0LL;
LABEL_35:
      int v32 = *(char *)(a1 + 1165);
      if (v32 < 0 || *((_WORD *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165)))
      {
        if (!(_DWORD)v16)
        {
LABEL_38:
          unsigned int v72 = *((unsigned __int16 *)v21 + 2 * v32);
          unint64_t v73 = v4 + v30;
          unint64_t v33 = v4;
          while (1)
          {
            __int128 v34 = *(_OWORD *)(a1 + 1148);
            *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
            *(_OWORD *)(a1 + 1246) = v34;
            *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
            __int128 v35 = *(_OWORD *)(a1 + 1084);
            *uint64_t v24 = *v21;
            *(_OWORD *)(a1 + 1182) = v35;
            __int128 v36 = *(_OWORD *)(a1 + 1116);
            *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
            *(_OWORD *)(a1 + 1214) = v36;
            uint64_t v37 = sub_10002E75C(a1, a1 + 1166, 1);
            if ((_DWORD)v37) {
              break;
            }
            unsigned int v38 = *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263));
            uint64_t v39 = *(void *)(a1 + 80);
            unint64_t v40 = *(void *)(v39 + 24LL * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263))) & 0xFFFFFFFFFFFFFLL;
            if (v73 < v40) {
              goto LABEL_68;
            }
            uint64_t v41 = v30;
            unint64_t v42 = *(void *)(v39 + 24LL * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 1263)) + 8) & 0xFFFFFFFFFFFFFLL;
            if (v42 + v40 >= v73) {
              unint64_t v43 = v42 + v40 - v73;
            }
            else {
              unint64_t v43 = 0LL;
            }
            sub_10002CAE0(a1, a1 + 1166);
            uint64_t v44 = sub_10002C238(a1, 1u, v40, v42, a1 + 1068);
            if ((_DWORD)v44)
            {
              uint64_t v61 = v44;
LABEL_74:
              sub_100013D94( "%s:%d: %s dev %d Failed to find successor node in length tree: %d\n",  "spaceman_free_extent_cache_insert",  1852,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v61);
              uint64_t v16 = v61;
              goto LABEL_27;
            }

            if (!*((_WORD *)v21 + 2 * *(unsigned __int8 *)(a1 + 1165)))
            {
              uint64_t v61 = 2LL;
              goto LABEL_74;
            }

            if (v40 == *(void *)(a1 + 112))
            {
              __int128 v45 = *(_OWORD *)(a1 + 1148);
              *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
              *(_OWORD *)(a1 + 1246) = v45;
              *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
              __int128 v46 = *(_OWORD *)(a1 + 1084);
              *uint64_t v24 = *v21;
              *(_OWORD *)(a1 + 1182) = v46;
              __int128 v47 = *(_OWORD *)(a1 + 1116);
              *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
              *(_OWORD *)(a1 + 1214) = v47;
              sub_10002CE40(a1, a1 + 1166);
            }

            v33 += v43;
            sub_10002CAE0(a1, a1 + 1068);
            sub_10002CA98(a1, v38);
            uint64_t v30 = v41;
            uint64_t v16 = sub_10002C238(a1, 0, v41, v4, a1 + 1068);
            if ((_DWORD)v16) {
              goto LABEL_27;
            }
          }

          uint64_t v16 = v37;
          if ((_DWORD)v37 != 2) {
            goto LABEL_27;
          }
LABEL_68:
          if (v33 <= v4) {
            goto LABEL_25;
          }
          uint64_t v16 = sub_10002C368(a1, v30, v4, v33, v72);
          if (!(_DWORD)v16)
          {
            unint64_t v58 = a1 + 48LL * ((*(_DWORD *)(a1 + 280) & 4) == 0);
            unint64_t v60 = *(void *)(v58 + 176);
            BOOL v59 = (unint64_t *)(v58 + 176);
            if (v60 >= v33) {
              goto LABEL_25;
            }
            uint64_t v16 = 0LL;
            unint64_t *v59 = v33;
            goto LABEL_28;
          }

          goto LABEL_27;
        }

        goto LABEL_27;
      }

      if (v12 != 55)
      {
        unsigned __int16 v74 = 0;
        uint64_t v16 = sub_10002C6E4(a1, v30, v4, &v74, a1 + 1068);
        if (!(_DWORD)v16)
        {
          uint64_t v57 = sub_10002C95C(a1, 1u, v30, v4, &v74);
          if ((_DWORD)v57)
          {
            uint64_t v16 = v57;
          }

          else
          {
            uint64_t v71 = *(void *)(a1 + 120);
            if (v71 - 1 >= v4 || v4 == v71 && v30 > *(void *)(a1 + 112))
            {
              *(void *)(a1 + 112) = v30;
              *(void *)(a1 + 120) = v4;
            }

            if (v4 > *(void *)(a1 + 128)) {
              *(void *)(a1 + 128) = v4;
            }
            uint64_t v16 = sub_10002C238(a1, 0, v30, v4, a1 + 1068);
            sub_10002C668(a1, v30, v4);
            LOBYTE(v32) = *(_BYTE *)(a1 + 1165);
            if (!(_DWORD)v16) {
              goto LABEL_38;
            }
          }
        }

LABEL_34:
    uint64_t v30 = a3;
    goto LABEL_35;
  }

  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return 45LL;
}

    unint64_t v13 = sub_100028D34(a1, a2, v18, a4);
    unint64_t v18 = (uint64_t *)*((void *)&v21 + 1);
    goto LABEL_35;
  }

  int v12 = sub_10003F31C(a1, a3, 0LL, 0LL, (uint64_t *)&v21 + 1);
  if (!(_DWORD)v12)
  {
    unint64_t v11 = *(void *)(a3 + 376);
    goto LABEL_12;
  }

  unint64_t v13 = v12;
  sub_10003D514(a3, 1);
  return v13;
}

    ++v22;
    --v21;
  }

  while (v21);
  LODWORD(v12) = *(_DWORD *)(v8 + 36);
  int v19 = v24;
  LODWORD(v14) = v23;
LABEL_36:
  int v12 = v12;
  unint64_t v5 = a5;
LABEL_37:
  __int128 v35 = v19 * v12;
  else {
    uint64_t v14 = v11;
  }
  *(void *)unint64_t v5 = v35;
  *(void *)(v5 + 8) = v14;
  __int128 v36 = *(_BYTE *)(a4 + 16);
  if (v36)
  {
    uint64_t v37 = *(void *)(v7 + 376);
    unsigned int v38 = v37 + 48LL * v9;
    uint64_t v39 = *(void *)(v38 + 56);
    if (v39 > v19 && (unint64_t v40 = *(void *)(a4 + 32)) != 0)
    {
      uint64_t v41 = *(unsigned int *)(v37 + 36);
      unint64_t v42 = v19 * v41;
      if (v39 - 1 == v19) {
        uint64_t v41 = *(void *)(v38 + 48) % v41;
      }
      unint64_t v43 = *(void *)(a4 + 24);
      uint64_t v44 = v8;
      __int128 v45 = v11;
      uint64_t result = sub_100013C78(v42, v41, v43, v40, 0LL);
      unint64_t v11 = v45;
      uint64_t v8 = v44;
      __int128 v36 = result == 0;
    }

    else
    {
      __int128 v36 = 1;
    }
  }

  *(_BYTE *)(v5 + 16) = v36;
  if (v19 != v13)
  {
    __int128 v46 = v15;
    if (v11 < v15) {
      __int128 v46 = v11;
    }
    *(void *)(v5 + 24) = v13 * *(unsigned int *)(v8 + 36);
    *(void *)(v5 + 32) = v46;
    *(_BYTE *)(v5 + 40) = 0;
  }

  return result;
}

uint64_t sub_10002BFD4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(_WORD *)(a1 + 92)) {
    return 0LL;
  }
  unint64_t v5 = *(void *)(a1 + 120);
  if (v5 > a2) {
    return 55LL;
  }
  uint64_t v7 = (void *)(a1 + 112);
  uint64_t v8 = *(void *)(a1 + 112);
  if (v5 == a2 && v8 < a3) {
    return 55LL;
  }
  if (!v8) {
    return 0LL;
  }
  uint64_t v10 = (_OWORD *)(a1 + 480);
  if (sub_10002C238(a1, 0, v8, v5, a1 + 480)
    || (uint64_t v11 = 4LL * *(unsigned __int8 *)(a1 + 577),
        unsigned int v12 = *(unsigned __int16 *)((char *)v10 + v11),
        !*(_WORD *)((char *)v10 + v11)))
  {
    sub_100013D94("%s:%d: %s dev %d Failed to find smallest extent in paddr tree: %d\n");
  }

  else
  {
    sub_10002CAE0(a1, a1 + 480);
    if (sub_10002C238(a1, 1u, *(void *)(a1 + 112), *(void *)(a1 + 120), a1 + 480)
      || !*((_WORD *)v10 + 2 * *(unsigned __int8 *)(a1 + 577)))
    {
      sub_100013D94("%s:%d: %s dev %d Failed to find smallest extent %d in length tree: %d\n");
    }

    else
    {
      sub_10002C1F4(a1, *(void *)(a1 + 112), *(void *)(a1 + 120));
      __int128 v13 = *(_OWORD *)(a1 + 560);
      *(_OWORD *)(a1 + 642) = *(_OWORD *)(a1 + 544);
      *(_OWORD *)(a1 + 658) = v13;
      *(_WORD *)(a1 + 674) = *(_WORD *)(a1 + 576);
      __int128 v14 = *(_OWORD *)(a1 + 496);
      *(_OWORD *)(a1 + 578) = *v10;
      *(_OWORD *)(a1 + 594) = v14;
      __int128 v15 = *(_OWORD *)(a1 + 528);
      *(_OWORD *)(a1 + 610) = *(_OWORD *)(a1 + 512);
      *(_OWORD *)(a1 + 626) = v15;
      int v16 = sub_10002E75C(a1, a1 + 578, 1);
      if (!v16)
      {
        *(int8x16_t *)(a1 + 112) = vandq_s8( *(int8x16_t *)(*(void *)(a1 + 80)
                                                  + 24LL
                                                  * *(unsigned __int16 *)(a1 + 578 + 4LL
                                                                                   * *(unsigned __int8 *)(a1 + 675))),
                                     (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
        goto LABEL_23;
      }

      if (v16 == 2)
      {
        *uint64_t v7 = 0LL;
        *(void *)(a1 + 120) = 0LL;
        *(void *)(a1 + 128) = 0LL;
LABEL_23:
        sub_10002CAE0(a1, a1 + 480);
        sub_10002CA98(a1, v12);
        return 0LL;
      }

      sub_100013D94("%s:%d: %s dev %d Failed to find next smallest extent in length tree: %d\n");
    }
  }

  return 3LL;
}

uint64_t sub_10002C1F4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  BOOL v3 = (*(_DWORD *)(a1 + 280) & 4) == 0;
  uint64_t v4 = a1 + 48LL * ((*(_DWORD *)(a1 + 280) & 4) == 0);
  unint64_t v6 = *(void *)(v4 + 152);
  unint64_t v5 = (unint64_t *)(v4 + 152);
  if (v6 < a3) {
    *unint64_t v5 = a3;
  }
  uint64_t v7 = (void *)(a1 + 48LL * v3);
  uint64_t v8 = v7[17];
  uint64_t v9 = v7[18];
  v7 += 17;
  *uint64_t v7 = v8 + 1;
  v7[1] = v9 + a3;
  return sub_10002D70C((uint64_t)v7, a2, a3);
}

uint64_t sub_10002C238(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  *(_WORD *)(a5 + 96) = 0;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_BYTE *)(a5 + 96) = a2;
  uint64_t v10 = *(unsigned __int16 *)(a1 + 2LL * a2 + 104);
  *(_WORD *)a5 = v10;
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 80) + 24LL * v10;
    if (a2) {
      char v12 = *(_BYTE *)(v11 + 15);
    }
    else {
      char v12 = *(_BYTE *)(v11 + 7);
    }
    *(_BYTE *)(a5 + 2) = v12;
  }

  uint64_t v13 = 4LL * *(unsigned __int8 *)(a5 + 97);
  unsigned int v14 = *(unsigned __int16 *)(a5 + v13);
  if (*(_WORD *)(a5 + v13))
  {
    do
    {
      uint64_t v15 = *(void *)(a1 + 80);
      int v16 = (void *)(v15 + 24LL * v14);
      if (a2)
      {
        unint64_t v17 = *(void *)(v15 + 24LL * v14 + 8) & 0xFFFFFFFFFFFFFLL;
        BOOL v18 = v17 > a4;
        int v19 = v17 < a4;
        if (v18) {
          int v19 = -1;
        }
        if (!v19)
        {
          uint64_t v20 = *v16 & 0xFFFFFFFFFFFFFLL;
          int v19 = v20 > a3;
          if (v20 < a3) {
            goto LABEL_18;
          }
        }
      }

      else
      {
        uint64_t v21 = *v16 & 0xFFFFFFFFFFFFFLL;
        int v19 = v21 < a3;
        if (v21 > a3) {
          goto LABEL_18;
        }
      }

      if (!v19) {
        return 0LL;
      }
      if (v19 < 0)
      {
LABEL_18:
        uint64_t v22 = a1;
        uint64_t v23 = a5;
        __int16 v24 = -1;
        goto LABEL_19;
      }

      uint64_t v22 = a1;
      uint64_t v23 = a5;
      __int16 v24 = 1;
LABEL_19:
      uint64_t result = sub_10002E658(v22, v23, v24);
      if ((_DWORD)result) {
        return result;
      }
      uint64_t v26 = 4LL * *(unsigned __int8 *)(a5 + 97);
      unsigned int v14 = *(unsigned __int16 *)(a5 + v26);
    }

    while (*(_WORD *)(a5 + v26));
  }

  return 0LL;
}

uint64_t sub_10002C368(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unsigned int a5)
{
  __int16 v29 = a5;
  uint64_t v10 = a1 + 676;
  uint64_t v11 = *(void *)(a1 + 112);
  uint64_t v12 = sub_10002C238(a1, 1u, a2, a3, a1 + 676);
  if ((_DWORD)v12) {
    return v12;
  }
  if (*(unsigned __int16 *)(v10 + 4LL * *(unsigned __int8 *)(a1 + 773)) != a5)
  {
    sub_100013D94( "%s:%d: %s dev %d length tree search for 0x%llx 0x%llx returned node %d instead of %d\n",  "spaceman_fxc_update_length",  1400,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  a2,  a3,  *(unsigned __int16 *)(v10 + 4LL * *(unsigned __int8 *)(a1 + 773)),  a5);
    return 22LL;
  }

  unsigned int v14 = (_OWORD *)(a1 + 774);
  uint64_t v15 = *(void *)(a1 + 96);
  uint64_t v16 = *(void *)(a1 + 80) + 24LL * a5;
  *(void *)(v16 + 8) = *(void *)(v16 + 8) & 0xFFF0000000000000LL | a4 & 0xFFFFFFFFFFFFFLL;
  *(void *)(a1 + 96) = a4 - a3 + v15;
  if (a4 <= a3)
  {
    if (v11 != a2)
    {
      __int128 v21 = *(_OWORD *)(v10 + 80);
      *(_OWORD *)(a1 + 838) = *(_OWORD *)(v10 + 64);
      *(_OWORD *)(a1 + 854) = v21;
      *(_WORD *)(a1 + 870) = *(_WORD *)(v10 + 96);
      __int128 v22 = *(_OWORD *)(v10 + 16);
      *unsigned int v14 = *(_OWORD *)v10;
      *(_OWORD *)(a1 + 790) = v22;
      __int128 v23 = *(_OWORD *)(v10 + 48);
      *(_OWORD *)(a1 + 806) = *(_OWORD *)(v10 + 32);
      *(_OWORD *)(a1 + 822) = v23;
      uint64_t v24 = sub_10002E75C(a1, a1 + 774, -1);
      if ((_DWORD)v24)
      {
        uint64_t v12 = v24;
        if ((_DWORD)v24 == 2) {
          sub_100013D94( "%s:%d: %s dev %d Failed to find length tree predecessor for node that wasn't the smallest\n",  "spaceman_fxc_update_length",  1463,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88));
        }
        return v12;
      }

      if ((*(void *)(*(void *)(a1 + 80) + 24LL * *((unsigned __int16 *)v14 + 2 * *(unsigned __int8 *)(a1 + 871)) + 8) & 0xFFFFFFFFFFFFFuLL) >= a4)
      {
        unint64_t v27 = *(void *)(a1 + 120);
        if (v27 > a4 || v27 == a4 && *(void *)(a1 + 112) < a2)
        {
          *(void *)(a1 + 112) = a2;
          *(void *)(a1 + 120) = a4;
        }

        goto LABEL_36;
      }

      goto LABEL_31;
    }
  }

  else
  {
    __int128 v17 = *(_OWORD *)(v10 + 80);
    *(_OWORD *)(a1 + 838) = *(_OWORD *)(v10 + 64);
    *(_OWORD *)(a1 + 854) = v17;
    *(_WORD *)(a1 + 870) = *(_WORD *)(v10 + 96);
    __int128 v18 = *(_OWORD *)(v10 + 16);
    *unsigned int v14 = *(_OWORD *)v10;
    *(_OWORD *)(a1 + 790) = v18;
    __int128 v19 = *(_OWORD *)(v10 + 48);
    *(_OWORD *)(a1 + 806) = *(_OWORD *)(v10 + 32);
    *(_OWORD *)(a1 + 822) = v19;
    uint64_t v20 = sub_10002E75C(a1, a1 + 774, 1);
    if ((_DWORD)v20)
    {
      uint64_t v12 = v20;
      if ((_DWORD)v20 != 2) {
        return v12;
      }
      if (v11 == a2) {
        *(void *)(a1 + 120) = a4;
      }
      if (*(void *)(a1 + 128) >= a4) {
        return 0LL;
      }
      uint64_t v12 = 0LL;
LABEL_38:
      *(void *)(a1 + 128) = a4;
      return v12;
    }

    int8x16_t v25 = vandq_s8( *(int8x16_t *)(*(void *)(a1 + 80) + 24LL * *((unsigned __int16 *)v14 + 2 * *(unsigned __int8 *)(a1 + 871))),  (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
    if (v25.i64[1] < a4 || (v25.i64[1] == a4 ? (BOOL v26 = v25.i64[0] <= a2) : (BOOL v26 = 1), !v26))
    {
      if (v11 == a2) {
        *(int8x16_t *)(a1 + 112) = v25;
      }
LABEL_36:
      sub_10002CAE0(a1, v10);
      uint64_t v12 = sub_10002C95C(a1, 1u, a2, a4, &v29);
      goto LABEL_37;
    }

    if (v11 != a2)
    {
LABEL_31:
      uint64_t v12 = 0LL;
      goto LABEL_37;
    }
  }

  uint64_t v12 = 0LL;
  *(void *)(a1 + 120) = a4;
LABEL_37:
  unint64_t v28 = *(void *)(a1 + 128);
  if (v28 < a4) {
    goto LABEL_38;
  }
  if (v28 == a3) {
    sub_10002D3AC(a1);
  }
  return v12;
}

unint64_t sub_10002C668(unint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  uint64_t v4 = 0LL;
  unint64_t v5 = a2 - 1;
  uint64_t v6 = a3 + 2;
  char v7 = 1;
  do
  {
    char v8 = v7;
    unint64_t v9 = v3 + 16 * v4;
    unint64_t v10 = *(void *)(v9 + 296);
    if (v10)
    {
      uint64_t result = sub_100013C78(v5, v6, v10, *(void *)(v9 + 304) - v10, 0LL);
      if (result) {
        *(void *)(v9 + 296) = 0LL;
      }
    }

    char v7 = 0;
    uint64_t v4 = 1LL;
  }

  while ((v8 & 1) != 0);
  return result;
}

uint64_t sub_10002C6E4(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6 = *(unsigned __int8 *)(a5 + 96);
  if (a4 && (LOWORD(v7) = *a4) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 80);
    unint64_t v9 = (void *)(v8 + 24LL * (unsigned __int16)*a4);
    *((_DWORD *)v9 + v6 + 4) = 0;
    if ((_DWORD)v6) {
      ++v9;
    }
    *v9 &= 0xFFFFFFFFFFFFFFuLL;
  }

  else
  {
    unsigned int v7 = *(unsigned __int16 *)(a1 + 92);
    if (v7 > *(_DWORD *)(a1 + 88) >> 8) {
      return 22LL;
    }
    if (!*(_WORD *)(a1 + 92)) {
      return 12LL;
    }
    uint64_t v11 = (void *)(*(void *)(a1 + 80) + 24LL * *(unsigned __int16 *)(a1 + 92));
    *(_WORD *)(a1 + 92) = *v11;
    ++*(_WORD *)(a1 + 94);
    *(void *)(a1 + 96) += a3;
    v11[1] = 0LL;
    void v11[2] = 0LL;
    *uint64_t v11 = 0LL;
    if (a4) {
      *a4 = v7;
    }
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v12 = (void *)(v8 + 24LL * v7);
    void *v12 = a2;
    v12[1] = a3;
  }

  uint64_t v10 = *(unsigned __int8 *)(a5 + 97);
  uint64_t v13 = (_WORD *)(a5 + 4 * v10);
  _WORD *v13 = v7;
  v13[1] = 0;
  if (!v10)
  {
    *(_WORD *)(a1 + 2 * v6 + 104) = v7;
    return v10;
  }

  int v14 = (char)v10;
  *(_WORD *)(v8
           + 24LL * *(unsigned __int16 *)(a5 + 4LL * (v10 - 1))
           + 4 * v6
           + 2LL
           * ((*(char *)(a5 + 4LL * (v10 - 1) + 3)
                              + 1
  unsigned __int8 v15 = v10;
  if (((char)v10 & 0x80000000) == 0)
  {
    while (!*(_BYTE *)(a5 + 4LL * v15 + 2))
    {
      int v16 = (char)v15--;
      if (v16 <= 0)
      {
        unsigned __int8 v15 = -1;
        break;
      }
    }
  }

  int v17 = (char)(v15 + 1);
  if (v17 < v14)
  {
    LOBYTE(v18) = v15 + 1;
    do
    {
      __int128 v19 = (unsigned __int16 *)(a5 + 4LL * v18);
      uint64_t v20 = v8 + 24LL * *v19;
      if ((_DWORD)v6) {
        v20 += 8LL;
      }
      char v21 = *((_BYTE *)v19 + 3);
      *(_BYTE *)(v20 + 7) = v21;
      *((_BYTE *)v19 + 2) = v21;
      int v18 = (char)(v18 + 1);
    }

    while (v18 < v14);
  }

  if ((v15 & 0x80) != 0) {
    return 0LL;
  }
  __int128 v22 = (unsigned __int16 *)(a5 + 4LL * v15);
  int v23 = *((char *)v22 + 3);
  if (*((char *)v22 + 2) + v23)
  {
    if (*((unsigned __int8 *)v22 + 2) == *((unsigned __int8 *)v22 + 3))
    {
      if (v15) {
        int8x16_t v25 = (unsigned __int16 *)(v8
      }
                                 + 24LL * *(unsigned __int16 *)(a5 + 4LL * (v15 - 1))
                                 + 4 * v6
                                 + 2LL
                                 * ((*(char *)(a5 + 4LL * (v15 - 1) + 3)
                                                    + 1
      else {
        int8x16_t v25 = (unsigned __int16 *)(a1 + 2 * v6 + 104);
      }
      int v26 = -v23;
      unint64_t v27 = (unsigned __int16 *)(a5 + 4LL * v17);
      int v28 = *((unsigned __int8 *)v27 + 2);
      if (v28 == *((unsigned __int8 *)v22 + 3))
      {
        sub_10002E83C(a1, v6, (char)v26, *v22, v25);
      }

      else if ((char)v28 == v26)
      {
        sub_10002E930(a1, v6, (char)v23, *v22, *v27, v25);
      }
    }

    return 0LL;
  }

  uint64_t v10 = 0LL;
  uint64_t v24 = (void *)(v8 + 24LL * *v22);
  if ((_DWORD)v6) {
    ++v24;
  }
  *v24 &= 0xFFFFFFFFFFFFFFuLL;
  return v10;
}

uint64_t sub_10002C95C(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _WORD *a5)
{
  if ((a4 | a3) >> 52) {
    return 84LL;
  }
  uint64_t v10 = a1 + 872;
  if (!a5 || !*a5) {
    sub_10002BFD4(a1, a4, a3);
  }
  uint64_t result = sub_10002C238(a1, a2, a3, a4, v10);
  if (!(_DWORD)result)
  {
    else {
      return sub_10002C6E4(a1, a3, a4, a5, v10);
    }
  }

  return result;
}

uint64_t sub_10002CA24(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if ((a3 | a2) >> 52) {
    return 84LL;
  }
  uint64_t v4 = a1 + 970;
  uint64_t result = sub_10002C238(a1, 0, a2, a3, a1 + 970);
  if (!(_DWORD)result)
  {
    if (*(_WORD *)(v4 + 4LL * *(unsigned __int8 *)(a1 + 1067)))
    {
      sub_10002CAE0(a1, v4);
      return 0LL;
    }

    else
    {
      return 2LL;
    }
  }

  return result;
}

uint64_t sub_10002CA98(uint64_t result, unsigned int a2)
{
  if (a2 <= *(_DWORD *)(result + 88) >> 8)
  {
    unint64_t v2 = (void *)(*(void *)(result + 80) + 24LL * a2);
    uint64_t v3 = v2[1] & 0xFFFFFFFFFFFFFLL;
    --*(_WORD *)(result + 94);
    *(void *)(result + 96) -= v3;
    *unint64_t v2 = *(unsigned __int16 *)(result + 92);
    *(_WORD *)(result + 92) = a2;
  }

  return result;
}

uint64_t sub_10002CAE0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned __int8 *)(a2 + 96);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 97);
  int v6 = (char)v5;
  unsigned int v7 = (_WORD *)(a2 + 4 * v5);
  uint64_t v8 = *(void *)(result + 80);
  uint64_t v9 = v8 + 24LL * (unsigned __int16)*v7;
  if (*(_BYTE *)(a2 + 96)) {
    char v10 = *(_BYTE *)(v9 + 15);
  }
  else {
    char v10 = *(_BYTE *)(v9 + 7);
  }
  uint64_t v11 = v8 + 24LL * (unsigned __int16)*v7 + 4 * v4;
  unsigned int v12 = *(unsigned __int16 *)(v11 + 18);
  unsigned __int8 v13 = v5 - 1;
  if ((char)v5 < 1)
  {
    uint64_t v16 = 0LL;
    unsigned int v15 = 0;
  }

  else
  {
    int v14 = (unsigned __int16 *)(a2 + 4LL * v13);
    unsigned int v15 = *v14;
    LODWORD(v14) = *((char *)v14 + 3) + 1;
    uint64_t result = (unsigned __int16)v14 & 0x8000;
    uint64_t v16 = ((v14 + (result >> 15)) >> 1);
  }

  __int16 v17 = *(_WORD *)(v11 + 16);
  if (!v12)
  {
    if ((_BYTE)v5) {
      uint64_t v37 = (_WORD *)(v8 + 24LL * v15 + 4 * v4 + 2 * v16 + 16);
    }
    else {
      uint64_t v37 = (_WORD *)(v3 + 2 * v4 + 104);
    }
    *uint64_t v37 = v17;
    *(_BYTE *)(a2 + 97) = v13;
    if ((((_BYTE)v5 - 1) & 0x80) != 0) {
      return result;
    }
    goto LABEL_28;
  }

  uint64_t result = 24LL;
  uint64_t v18 = v8 + 24LL * v12 + 4 * v4;
  unsigned int v21 = *(unsigned __int16 *)(v18 + 16);
  uint64_t v20 = (_WORD *)(v18 + 16);
  unsigned int v19 = v21;
  if (v21)
  {
    uint64_t v22 = a2 + 4 * v5;
    *(_BYTE *)(v22 + 3) = 1;
    int v23 = (_BYTE *)(v22 + 3);
    int v24 = v6 + 1;
    *(_BYTE *)(a2 + 97) = v6 + 1;
    uint64_t v25 = a2 + 4LL * (v6 + 1);
    *(_WORD *)uint64_t v25 = v12;
    *(_BYTE *)(v25 + 3) = 0;
    unsigned int v26 = v12;
    do
    {
      unsigned __int8 v13 = v24;
      unsigned int v27 = v26;
      unsigned int v26 = v19;
      *(_BYTE *)(a2 + 4LL * v24++ + 3) = -1;
      uint64_t v28 = a2 + 4LL * v24;
      *(_WORD *)uint64_t v28 = v26;
      *(_BYTE *)(v28 + 3) = 0;
      uint64_t v29 = v8 + 24LL * v26 + 4 * v4;
      unsigned int v31 = *(unsigned __int16 *)(v29 + 16);
      uint64_t v30 = (_WORD *)(v29 + 16);
      unsigned int v19 = v31;
    }

    while (v31);
    uint64_t result = v26;
    uint64_t v32 = v8 + 24LL * v26;
    uint64_t v33 = v32 + 4 * v4;
    *(_WORD *)(v8 + 24LL * v27 + 4 * v4 + 16) = *(_WORD *)(v33 + 18);
    *(_WORD *)(v33 + 18) = v12;
    *uint64_t v30 = v17;
    uint64_t v34 = v32 + 8;
    if (!(_DWORD)v4) {
      uint64_t v34 = v32;
    }
    *(_BYTE *)(v34 + 7) = v10;
    uint64_t v35 = v8 + 24LL * v15 + 4 * v4 + 2 * v16 + 16;
    if (v6) {
      __int128 v36 = (_WORD *)v35;
    }
    else {
      __int128 v36 = (_WORD *)(v3 + 2 * v4 + 104);
    }
    _WORD *v36 = result;
    *int v23 = 1;
    *unsigned int v7 = result;
    *(_BYTE *)(a2 + 97) = v13;
    if ((v13 & 0x80) != 0) {
      return result;
    }
LABEL_28:
    uint64_t v40 = v13 + 255LL;
    uint64_t v41 = (unsigned __int16 *)(a2 + 4LL * v13);
    unint64_t v42 = v41;
    while (1)
    {
      unsigned int v44 = *v42;
      v42 -= 2;
      unsigned int v43 = v44;
      uint64_t v45 = *(void *)(v3 + 80);
      uint64_t v46 = v45 + 24LL * v44;
      if ((_DWORD)v4) {
        char v47 = *(_BYTE *)(v45 + 24LL * v43 + 15);
      }
      else {
        char v47 = *(_BYTE *)(v46 + 7);
      }
      int v48 = *((unsigned __int8 *)v41 + 3);
      int v49 = (char)(v47 - v48);
      if (v49 < 0) {
        int v49 = -v49;
      }
      if (v49 << 24 > 0x1FFFFFF)
      {
        __int128 v51 = (unsigned __int16 *)(v3 + 2 * v4 + 104);
        if (v40 != 255) {
          __int128 v51 = (unsigned __int16 *)(v45
        }
                                   + 24LL * *(unsigned __int16 *)(a2 + 4LL * v40)
                                   + 4 * v4
                                   + 2LL
                                   * ((*(char *)(a2 + 4LL * v40 + 3)
                                                      + 1
        uint64_t v52 = (char)-(char)v48;
        uint64_t v53 = *(unsigned __int16 *)(v45
                                  + 24LL * v43
                                  + 4 * v4
                                  + 2LL
        uint64_t v54 = v45 + 24 * v53;
        if ((_DWORD)v4) {
          unsigned __int8 v55 = *(_BYTE *)(v54 + 15);
        }
        else {
          unsigned __int8 v55 = *(_BYTE *)(v54 + 7);
        }
        if (v48 == v55)
        {
          uint64_t result = sub_10002E930(v3, v4, v52, v43, v53, v51);
        }

        else
        {
          uint64_t result = sub_10002E83C(v3, v4, (char)v48, v43, v51);
          if (!v55) {
            return result;
          }
        }
      }

      else
      {
        uint64_t v50 = v45 + 24LL * v43 + 8;
        if (!(_DWORD)v4) {
          uint64_t v50 = v46;
        }
        *(_BYTE *)(v50 + 7) = v47 - v48;
        if (!v47) {
          return result;
        }
      }

      uint64_t v56 = v40 - 255;
      --v40;
      uint64_t v41 = v42;
      if (v56 <= 0) {
        return result;
      }
    }
  }

  *uint64_t v20 = v17;
  unsigned int v38 = (_WORD *)(v8 + 24LL * v15 + 4 * v4 + 2 * v16 + 16);
  if (!(_BYTE)v5) {
    unsigned int v38 = (_WORD *)(v3 + 2 * v4 + 104);
  }
  *unsigned int v38 = v12;
  uint64_t v39 = v8 + 24LL * v12;
  if ((_DWORD)v4) {
    v39 += 8LL;
  }
  *(_BYTE *)(v39 + 7) = v10;
  *(_BYTE *)(a2 + 4 * v5 + 3) = 1;
  *unsigned int v7 = v12;
  unsigned __int8 v13 = v5;
  if ((v5 & 0x80) == 0) {
    goto LABEL_28;
  }
  return result;
}

const char *sub_10002CE40(uint64_t a1, uint64_t a2)
{
  uint64_t result = (const char *)sub_10002E75C(a1, a2, 1);
  if ((_DWORD)result == 2)
  {
    *(void *)(a1 + 112) = 0LL;
    *(void *)(a1 + 120) = 0LL;
  }

  else if ((_DWORD)result)
  {
    return sub_100013D94( "%s:%d: %s dev %d Failed to find successor node from length tree while updating smallest: %d\n",  "spaceman_fxc_update_smallest_with_successor",  1520,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  (_DWORD)result);
  }

  else
  {
    *(int8x16_t *)(a1 + 112) = vandq_s8( *(int8x16_t *)(*(void *)(a1 + 80)
                                              + 24LL * *(unsigned __int16 *)(a2 + 4LL * *(unsigned __int8 *)(a2 + 97))),
                                 (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
  }

  return result;
}

uint64_t sub_10002CEE8(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a1) {
    return 22LL;
  }
  if ((a3 | a2) >> 52) {
    return 84LL;
  }
  if (!a3) {
    return 0LL;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  if ((*(_BYTE *)(a1 + 280) & 2) == 0)
  {
    int v6 = (_OWORD *)(a1 + 1068);
    unsigned __int16 v34 = -21846;
    uint64_t v7 = sub_10002C238(a1, 0, a2, a3, a1 + 1068);
    if ((_DWORD)v7)
    {
LABEL_8:
      sub_100013D94( "%s:%d: %s dev %d Error %d, reinitializing\n",  "spaceman_free_extent_cache_remove",  2076,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v7);
      sub_10002B1A8(a1);
      goto LABEL_9;
    }

    uint64_t v9 = (_OWORD *)(a1 + 1166);
    uint64_t v10 = a3 + a2;
    uint64_t v11 = 4LL * *(unsigned __int8 *)(a1 + 1165);
    unsigned int v12 = *(unsigned __int16 *)((char *)v6 + v11);
    __int128 v19 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v19;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    __int128 v20 = *(_OWORD *)(a1 + 1084);
    *uint64_t v9 = *v6;
    *(_OWORD *)(a1 + 1182) = v20;
    __int128 v21 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v21;
    uint64_t v22 = sub_10002E75C(a1, a1 + 1166, -1);
    if ((_DWORD)v22 == 2) {
      goto LABEL_42;
    }
    uint64_t v7 = v22;
    if ((_DWORD)v22) {
      goto LABEL_8;
    }
    int v23 = (void *)(*(void *)(a1 + 80) + 24LL * *((unsigned __int16 *)v9 + 2 * *(unsigned __int8 *)(a1 + 1263)));
    unint64_t v24 = v23[1] & 0xFFFFFFFFFFFFFLL;
    unint64_t v25 = v24 + (*v23 & 0xFFFFFFFFFFFFFLL);
    if (v25 <= a2) {
      goto LABEL_42;
    }
    uint64_t v7 = sub_10002C368( a1,  *v23 & 0xFFFFFFFFFFFFFLL,  v24,  a2 - (*v23 & 0xFFFFFFFFFFFFFLL),  *((unsigned __int16 *)v9 + 2 * *(unsigned __int8 *)(a1 + 1263)));
    if ((_DWORD)v7) {
      goto LABEL_8;
    }
    unint64_t v26 = v25 - v10;
    if (v25 <= v10)
    {
LABEL_42:
      uint64_t v31 = sub_10002E75C(a1, a1 + 1068, 1);
      if ((_DWORD)v31 != 2)
      {
        uint64_t v7 = v31;
        if ((_DWORD)v31) {
          goto LABEL_8;
        }
        unsigned int v12 = *((unsigned __int16 *)v6 + 2 * *(unsigned __int8 *)(a1 + 1165));
LABEL_19:
        unsigned __int8 v13 = (unint64_t *)(*(void *)(a1 + 80) + 24LL * v12);
        unint64_t v14 = *v13;
        uint64_t v15 = *v13 & 0xFFFFFFFFFFFFFLL;
        unint64_t v16 = v13[1] & 0xFFFFFFFFFFFFFLL;
        unint64_t v17 = v16 + v15;
        if (v10 >= v16 + v15)
        {
          while (1)
          {
            sub_10002CAE0(a1, a1 + 1068);
            uint64_t v27 = sub_10002C238(a1, 1u, v15, v16, a1 + 1068);
            if ((_DWORD)v27)
            {
              uint64_t v32 = v27;
              sub_100013D94( "%s:%d: %s dev %d Failed to delete covered node from length tree: %d\n",  "spaceman_free_extent_cache_remove",  2016,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v27);
              uint64_t v7 = v32;
              goto LABEL_8;
            }

            if (v15 == *(void *)(a1 + 112))
            {
              __int128 v28 = *(_OWORD *)(a1 + 1148);
              *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
              *(_OWORD *)(a1 + 1246) = v28;
              *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
              __int128 v29 = *(_OWORD *)(a1 + 1084);
              *uint64_t v9 = *v6;
              *(_OWORD *)(a1 + 1182) = v29;
              __int128 v30 = *(_OWORD *)(a1 + 1116);
              *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
              *(_OWORD *)(a1 + 1214) = v30;
              sub_10002CE40(a1, a1 + 1166);
            }

            sub_10002CAE0(a1, a1 + 1068);
            sub_10002CA98(a1, (unsigned __int16)v12);
            if (v16 == *(void *)(a1 + 128)) {
              sub_10002D3AC(a1);
            }
            uint64_t v7 = sub_10002C238(a1, 0, v15, v16, a1 + 1068);
            if (!(_DWORD)v7) {
              uint64_t v7 = sub_10002E75C(a1, a1 + 1068, 1);
            }
            if ((_DWORD)v7) {
              break;
            }
            unsigned int v12 = *((unsigned __int16 *)v6 + 2 * *(unsigned __int8 *)(a1 + 1165));
            unint64_t v14 = *v13;
            uint64_t v15 = *v13 & 0xFFFFFFFFFFFFFLL;
            unint64_t v16 = v13[1] & 0xFFFFFFFFFFFFFLL;
            unint64_t v17 = v16 + v15;
          }

          if ((_DWORD)v7 == 2) {
            goto LABEL_46;
          }
          sub_100013D94( "%s:%d: %s dev %d Failed to get next extent: %d\n",  "spaceman_free_extent_cache_remove",  2047,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v7);
          goto LABEL_8;
        }

LABEL_46:
    uint64_t v7 = 0LL;
    goto LABEL_9;
  }

  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return 45LL;
}

  uint64_t v35 = v32;
  if (a8)
  {
    uint64_t v35 = a8;
    if (a8 > v32) {
      return 22LL;
    }
  }

  if (a3) {
    __int128 v36 = 1;
  }
  else {
    __int128 v36 = a10;
  }
  unsigned int v84 = 0xAAAAAAAAAAAAAAAALL;
  if ((v20 & 0x40000000) != 0) {
    uint64_t v37 = v36;
  }
  else {
    uint64_t v37 = 1;
  }
  int v75 = v27;
  uint64_t v80 = v22;
  unint64_t v70 = v35;
  if ((v37 & 1) != 0)
  {
    if (v22)
    {
      LODWORD(v71) = 0;
      unint64_t v73 = v32;
      uint64_t v78 = (const char *)v12;
      goto LABEL_65;
    }

    uint64_t v69 = v37;
    unsigned int v38 = (const char *)v12;
    uint64_t v39 = v32;
    uint64_t v40 = sub_10004CBEC(v12, 72, v71, v32, (int *)&v82);
    if ((_DWORD)v40)
    {
      unint64_t v25 = v40;
      sub_100013D94( "%s:%d: %s flags 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n",  "obj_create_internal");
      return v25;
    }

    uint64_t v78 = v38;
    unint64_t v73 = v39;
  }

  else
  {
    uint64_t v69 = v37;
    uint64_t v41 = (const char *)v12;
    unint64_t v42 = v32;
    unsigned int v43 = sub_100048020(v12, 72LL);
    if ((_DWORD)v43)
    {
      unint64_t v25 = v43;
      sub_100013D94("%s:%d: %s flags 0x%x type 0x%x/0x%x error allocating new physical location %d\n");
      return v25;
    }

    unint64_t v73 = v42;
    uint64_t v78 = v41;
    if (a7) {
      sub_10001AAE8();
    }
  }

  uint64_t v37 = v69;
LABEL_65:
  pthread_mutex_lock(a1);
  unsigned int v44 = sub_10003A4E8((uint64_t)a1, *(_DWORD *)(a4 + 12), *(_DWORD *)a4, v16, v75, 0LL, &v84);
  if ((_DWORD)v44)
  {
    unint64_t v25 = v44;
    sub_100036F84((uint64_t)a1);
    if ((v37 & 1) != 0)
    {
      if (v80) {
        return v25;
      }
      uint64_t v45 = v82;
      uint64_t v46 = v71;
LABEL_117:
      sub_10004CFD4(v78, v45, v46);
      return v25;
    }

    goto LABEL_118;
  }

  char v47 = v84;
  int v48 = *(void *)(v84 + 16) | v75 & 0xFFFFFC00;
  *(void *)(v84 + 16) = v48 | 0x42;
  int v49 = *(_DWORD *)a4 | v75 & 0xFFFF0000;
  *(_DWORD *)(v47 + 36) = v49;
  uint64_t v50 = *(unsigned int *)(a4 + 4);
  __int128 v51 = v47;
  *(_DWORD *)(v47 + 40) = v50;
  if (!a7 || (uint64_t v52 = *(void *)(a7 + 496)) == 0) {
    uint64_t v52 = a7;
  }
  *(void *)(v51 + 8) = v52;
  *(void *)(v51 + 120) = v70;
  *(void *)(v51 + 144) = 0LL;
  uint64_t v53 = v80;
  if ((v20 & 0x80000000) == 0)
  {
    if ((v20 & 0x40000000) != 0)
    {
      if (a3) {
        uint64_t v81 = a3;
      }
      else {
        a3 = v81;
      }
      *(void *)(v51 + 128) = a3;
    }

    else
    {
      if (v80) {
        goto LABEL_92;
      }
      uint64_t v54 = 0x800000162LL;
      if ((v82 & 0x10) == 0) {
        uint64_t v54 = 0x400000162LL;
      }
      *(void *)(v51 + 16) = v48 | v54;
      if (!a3)
      {
        unsigned __int8 v55 = *(void *)&a1[6].__opaque[8];
        *(void *)(v51 + 112) = v55;
        *(void *)&a1[6].__opaque[8] = v55 + 1;
        if (byte_100070560 && (qword_100070568 != v49 || qword_100070570 != v50))
        {
          uint64_t v56 = "virtual";
LABEL_86:
          sub_10003EA80(v51, v56);
          uint64_t v53 = v80;
          goto LABEL_92;
        }

        goto LABEL_92;
      }
    }

uint64_t sub_10002D3AC(uint64_t a1)
{
  uint64_t v2 = a1 + 676;
  uint64_t result = sub_10002D410(a1, a1 + 676, 1u);
  if ((_DWORD)result == 2)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 24LL * *(unsigned __int16 *)(v2 + 4LL * *(unsigned __int8 *)(a1 + 773)) + 8) & 0xFFFFFFFFFFFFFLL;
  }

  *(void *)(a1 + 128) = v4;
  return result;
}

uint64_t sub_10002D410(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *(_WORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_BYTE *)(a2 + 96) = a3;
  uint64_t v5 = *(unsigned __int16 *)(a1 + 2LL * a3 + 104);
  *(_WORD *)a2 = v5;
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 80) + 24LL * v5;
    if (a3) {
      char v7 = *(_BYTE *)(v6 + 15);
    }
    else {
      char v7 = *(_BYTE *)(v6 + 7);
    }
    *(_BYTE *)(a2 + 2) = v7;
  }

  while (1)
  {
    uint64_t v8 = *(unsigned __int8 *)(a2 + 97);
    if (!*(_WORD *)(a2 + 4 * v8)) {
      break;
    }
    uint64_t result = sub_10002E658(a1, a2, 1);
    if ((_DWORD)result) {
      return result;
    }
  }

  unsigned int v10 = v8 - 1;
  *(_BYTE *)(a2 + 97) = v10;
  return (v10 >> 6) & 2;
}

uint64_t sub_10002D4B0(uint64_t a1, uint64_t *a2)
{
  if (!a1) {
    return 0LL;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  uint64_t v4 = *(void *)(a1 + 280);
  BOOL v5 = (v4 & 6) == 0;
  if ((v4 & 6) == 0)
  {
    *(void *)(a1 + 280) = v4 | 4;
    uint64_t v6 = *(void *)(a1 + 288);
    if (v6)
    {
      if (a2)
      {
LABEL_9:
        *a2 = v6;
        goto LABEL_12;
      }
    }

    else
    {
      uint64_t v6 = 1LL;
      *(void *)(a1 + 288) = 1LL;
      if (a2) {
        goto LABEL_9;
      }
    }

    *(void *)(a1 + 280) = v4 | 0xC;
LABEL_12:
    if (!*(void *)a1) {
      return 1LL;
    }
    goto LABEL_13;
  }

  if (*(void *)a1)
  {
LABEL_13:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return v5;
  }

  return 0LL;
}

uint64_t sub_10002D558(uint64_t result, unint64_t a2, char a3)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(result + 8);
    if (*(void *)result) {
      uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(result + 16));
    }
    uint64_t v7 = *(void *)(v5 + 280);
    if ((v7 & 6) == 0) {
      goto LABEL_21;
    }
    if ((a3 & 1) != 0)
    {
      *(_OWORD *)(v5 + 184) = *(_OWORD *)(v5 + 136);
      *(_OWORD *)(v5 + 200) = *(_OWORD *)(v5 + 152);
      *(_OWORD *)(v5 + 216) = *(_OWORD *)(v5 + 168);
      *(void *)(v5 + 280) = v7 & 0xFFFFFFFFFFFFFFF3LL;
      *(_OWORD *)(v5 + 136) = 0u;
      *(_OWORD *)(v5 + 152) = 0u;
      *(_OWORD *)(v5 + 168) = 0u;
    }

    else
    {
      if (*(void *)(*(void *)(v6 + 376) + 48LL * *(unsigned __int8 *)(v5 + 88) + 48) > a2
        && ((unint64_t v8 = *(void *)(v5 + 288), (v7 & 8) != 0) || v8 <= a2))
      {
        int v9 = 0;
        if (v8 < a2) {
          *(void *)(v5 + 288) = a2;
        }
      }

      else
      {
        int v9 = 1;
      }

      unint64_t v10 = v7 & 0xFFFFFFFFFFFFFFF3LL;
      unsigned int v12 = (_OWORD *)(v5 + 136);
      uint64_t v11 = *(void *)(v5 + 136);
      *(void *)(v5 + 280) = v10;
      if (v11)
      {
        uint64_t v13 = *(void *)(v5 + 184) + v11;
        unint64_t v14 = *(void *)(v5 + 200);
        unint64_t v15 = *(void *)(v5 + 152);
        uint64_t v16 = *(void *)(v5 + 192) + *(void *)(v5 + 144);
        *(void *)(v5 + 184) = v13;
        *(void *)(v5 + 192) = v16;
        if (v14 < v15) {
          *(void *)(v5 + 200) = v15;
        }
        unint64_t v17 = *(void *)(v5 + 176);
        if (*(void *)(v5 + 224) < v17) {
          *(void *)(v5 + 224) = v17;
        }
        uint64_t result = sub_10002D70C(v5 + 184, *(void *)(v5 + 160), *(void *)(v5 + 168));
        *(_OWORD *)(v5 + 152) = 0u;
        *(_OWORD *)(v5 + 168) = 0u;
        _OWORD *v12 = 0u;
        if ((v9 & 1) == 0) {
          goto LABEL_21;
        }
      }

      else
      {
        *(_OWORD *)(v5 + 152) = 0u;
        *(_OWORD *)(v5 + 168) = 0u;
        _OWORD *v12 = 0u;
        if (!v9)
        {
LABEL_21:
          if (*(void *)v5) {
            return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 16));
          }
          return result;
        }
      }
    }

    uint64_t v18 = *(void *)(v5 + 336) + 1LL;
    *(void *)(v5 + 328) = 0LL;
    *(void *)(v5 + 336) = v18;
    *(_OWORD *)(v5 + 232) = *(_OWORD *)(v5 + 184);
    *(_OWORD *)(v5 + 248) = *(_OWORD *)(v5 + 200);
    *(_OWORD *)(v5 + 264) = *(_OWORD *)(v5 + 216);
    *(_OWORD *)(v5 + 184) = 0u;
    *(_OWORD *)(v5 + 200) = 0u;
    *(_OWORD *)(v5 + 216) = 0u;
    *(void *)(v5 + 288) = 0LL;
    uint64_t v19 = *(void *)(v5 + 280);
    if ((v19 & 1) == 0) {
      *(void *)(v5 + 280) = v19 | 1;
    }
    goto LABEL_21;
  }

  return result;
}

uint64_t sub_10002D70C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 24);
  if (v3)
  {
    if (v3 <= a2)
    {
      uint64_t v4 = *(void *)(result + 32);
    }

    else
    {
      uint64_t v4 = v3 - a2 + *(void *)(result + 32);
      *(void *)(result + 24) = a2;
      *(void *)(result + 32) = v4;
      uint64_t v3 = a2;
    }

    uint64_t v5 = v4 + v3;
    if (a3 + a2 > v5) {
      *(void *)(result + 32) = v4 + a3 + a2 - v5;
    }
  }

  else
  {
    *(void *)(result + 24) = a2;
    *(void *)(result + 32) = a3;
  }

  return result;
}

unint64_t sub_10002D75C(__int16 a1, unint64_t a2, unint64_t a3)
{
  if ((a1 & 0x1000) == 0) {
    return a2;
  }
  if (a3 <= 1) {
    return a3 + 1;
  }
  if (a3 + (a3 >> 1) >= a2) {
    return a2;
  }
  else {
    return a3 + (a3 >> 1);
  }
}

uint64_t sub_10002D784(uint64_t a1, __int16 a2, int64_t *a3, unint64_t *a4)
{
  int64_t v4 = *a3;
  unint64_t v5 = *a4;
  *a3 = 0LL;
  *a4 = 0LL;
  if (!a1) {
    return 6LL;
  }
  ++*(void *)(a1 + 344);
  if (!v5)
  {
    ++*(void *)(a1 + 352);
    return 22LL;
  }

  uint64_t v10 = *(void *)(*(void *)a1 + 376LL);
  uint64_t v11 = *(void *)(v10 + 1248);
  if (v11
    && (uint64_t v12 = *(void *)(v10 + 1240),
        char v13 = __clz(__rbit64(*(unsigned int *)(v10 + 36))),
        *(_BYTE *)(a1 + 88) == (((v12 << v13) & 0x4000000000000000LL) != 0)))
  {
    uint64_t v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & v12;
    int v15 = 1;
  }

  else
  {
    int v15 = 0;
    uint64_t v14 = 0LL;
  }

  uint64_t v71 = 0LL;
  v72[0] = 0LL;
  unint64_t v67 = 0LL;
  unint64_t v68 = 0LL;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if ((*(_BYTE *)(a1 + 280) & 2) != 0)
  {
    if (*(void *)a1) {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    }
    return 6LL;
  }

  unint64_t v63 = v14;
  int v64 = v15;
  unint64_t v69 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v70 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v16 = (_OWORD *)(a1 + 1068);
  unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v66 = 0xAAAAAAAAAAAAAAAALL;
  int v17 = sub_10002C238(a1, 1u, v4, v5, a1 + 1068);
  if (!v17)
  {
    if (*((_WORD *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)))
    {
      uint64_t v18 = (void *)(*(void *)(a1 + 80) + 24LL * *((unsigned __int16 *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)));
      unint64_t v19 = *v18 & 0xFFFFFFFFFFFFFLL;
      uint64_t v70 = v19;
      uint64_t v20 = v18[1] & 0xFFFFFFFFFFFFFLL;
      uint64_t v66 = v20;
      if (v15)
      {
        sub_1000322C8(v19, v20, v63, v11, a2, v4, (unint64_t *)&v70, (unint64_t *)&v66);
        uint64_t v20 = v66;
        unint64_t v19 = v70;
      }

      if (v20)
      {
        int v21 = sub_1000323A4( *(void *)a1,  *(void *)(a1 + 8),  *(unsigned __int8 *)(a1 + 88),  v19,  v20,  a2,  v4,  &v69,  &v65);
        unint64_t v19 = v70;
        unint64_t v22 = v66;
        if (v21)
        {
          uint64_t v71 = v70;
          unint64_t v67 = v66;
          unint64_t v19 = v69;
          uint64_t v70 = v69;
          unint64_t v22 = v65;
          uint64_t v66 = v65;
        }
      }

      else
      {
        unint64_t v22 = 0LL;
      }

      v72[0] = v19;
      unint64_t v68 = v22;
      if (v22 == v5) {
        goto LABEL_21;
      }
    }

    __int128 v28 = (_OWORD *)(a1 + 1166);
    __int128 v29 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v29;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    __int128 v30 = *(_OWORD *)(a1 + 1084);
    *(_OWORD *)(a1 + 1166) = *v16;
    *(_OWORD *)(a1 + 1182) = v30;
    __int128 v31 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v31;
    int v17 = sub_10002DEAC(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, 0xFFFFFFFFFFFFFFFFLL, v72, &v68, &v71, &v67, 0x301u);
    if (!v17)
    {
      __int128 v32 = *(_OWORD *)(a1 + 1148);
      *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
      *(_OWORD *)(a1 + 1246) = v32;
      *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
      __int128 v33 = *(_OWORD *)(a1 + 1084);
      *__int128 v28 = *v16;
      *(_OWORD *)(a1 + 1182) = v33;
      __int128 v34 = *(_OWORD *)(a1 + 1116);
      *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
      *(_OWORD *)(a1 + 1214) = v34;
      int v17 = sub_10002DEAC(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, 0xFFFFFFFFFFFFFFFFLL, v72, &v68, &v71, &v67, 0x502u);
      if (!v17)
      {
        unint64_t v38 = v67;
        if (v68 >= v5 || v67 <= v68)
        {
          unint64_t v39 = v67;
          unint64_t v38 = v68;
        }

        else
        {
          unint64_t v39 = 0LL;
          uint64_t v40 = v71;
          uint64_t v71 = 0LL;
          v72[0] = v40;
          unint64_t v67 = 0LL;
          unint64_t v68 = v38;
          a2 &= ~0x2000u;
        }

        if (v38 < v5 && (a2 & 0x1000) == 0) {
          goto LABEL_21;
        }
        if (v4 <= v72[0])
        {
          unint64_t v41 = v72[0] - v4;
        }

        else
        {
          if (v4 - v72[0] < v38) {
            goto LABEL_21;
          }
          unint64_t v41 = v4 - (v38 + v72[0]);
        }

        if (!v41) {
          goto LABEL_21;
        }
        unint64_t v57 = v39;
        uint64_t v60 = v72[0];
        unint64_t v61 = v38;
        unint64_t v62 = v41;
        int v17 = sub_10002C238(a1, 0, v4, v5, a1 + 1068);
        if (!v17)
        {
          if (*((_WORD *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)))
          {
            unsigned int v43 = (void *)(*(void *)(a1 + 80)
                           + 24LL * *((unsigned __int16 *)v16 + 2 * *(unsigned __int8 *)(a1 + 1165)));
            uint64_t v44 = *v43 & 0xFFFFFFFFFFFFFLL;
            uint64_t v70 = v44;
            uint64_t v45 = v43[1] & 0xFFFFFFFFFFFFFLL;
            uint64_t v66 = v45;
            if (v64)
            {
              sub_1000322C8(v44, v45, v63, v11, a2, v4, (unint64_t *)&v70, (unint64_t *)&v66);
              uint64_t v45 = v66;
              uint64_t v44 = v70;
            }

            if (v45)
            {
              int v46 = sub_1000323A4( *(void *)a1,  *(void *)(a1 + 8),  *(unsigned __int8 *)(a1 + 88),  v44,  v45,  a2,  v4,  &v69,  &v65);
              uint64_t v44 = v70;
              unint64_t v47 = v66;
              if (v46)
              {
                unint64_t v48 = v57;
                uint64_t v55 = v70;
                unint64_t v58 = v66;
                if (sub_10002E198(v4, v5, v71, v48, v70, v66, a2))
                {
                  uint64_t v71 = v55;
                  unint64_t v67 = v58;
                }

                uint64_t v44 = v69;
                uint64_t v70 = v69;
                unint64_t v47 = v65;
                uint64_t v66 = v65;
              }
            }

            else
            {
              unint64_t v47 = 0LL;
            }

            uint64_t v56 = v44;
            unint64_t v59 = v47;
            if (sub_10002E198(v4, v5, v60, v61, v44, v47, a2))
            {
              v72[0] = v56;
              unint64_t v68 = v59;
              goto LABEL_21;
            }
          }

          __int128 v49 = *(_OWORD *)(a1 + 1148);
          *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
          *(_OWORD *)(a1 + 1246) = v49;
          *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
          __int128 v50 = *(_OWORD *)(a1 + 1084);
          *__int128 v28 = *v16;
          *(_OWORD *)(a1 + 1182) = v50;
          __int128 v51 = *(_OWORD *)(a1 + 1116);
          *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
          *(_OWORD *)(a1 + 1214) = v51;
          int v17 = sub_10002DEAC(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, v62, v72, &v68, &v71, &v67, 0x1802u);
          if (!v17)
          {
            __int128 v52 = *(_OWORD *)(a1 + 1148);
            *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
            *(_OWORD *)(a1 + 1246) = v52;
            *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
            __int128 v53 = *(_OWORD *)(a1 + 1084);
            *__int128 v28 = *v16;
            *(_OWORD *)(a1 + 1182) = v53;
            __int128 v54 = *(_OWORD *)(a1 + 1116);
            *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
            *(_OWORD *)(a1 + 1214) = v54;
            int v17 = sub_10002DEAC(a1, a1 + 1166, v64, v63, v11, a2, v4, v5, v62, v72, &v68, &v71, &v67, 0x1801u);
            if (!v17)
            {
LABEL_21:
              if (*(void *)a1) {
                pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
              }
              unint64_t v24 = v68;
              if (!v68 && v67)
              {
                v72[0] = v71;
                unint64_t v24 = v67;
              }

              unint64_t v25 = v24 - v5;
              if (v24 > v5)
              {
                unint64_t v26 = *(void *)(a1 + 368) + v25;
                ++*(void *)(a1 + 360);
                *(void *)(a1 + 368) = v26;
                if (v25 == 1)
                {
                  uint64_t result = 0LL;
                  uint64_t v27 = (void *)(a1 + 400);
                }

                else if (v25 > 7)
                {
                  uint64_t result = 0LL;
                  if (v25 > 0xF) {
                    uint64_t v27 = (void *)(a1 + 376);
                  }
                  else {
                    uint64_t v27 = (void *)(a1 + 384);
                  }
                }

                else
                {
                  uint64_t result = 0LL;
                  uint64_t v27 = (void *)(a1 + 392);
                }

                goto LABEL_63;
              }

              if (v24 >= v5)
              {
                uint64_t result = 0LL;
                ++*(void *)(a1 + 408);
                if (v24)
                {
LABEL_64:
                  unint64_t v42 = (void *)(a1 + 352);
LABEL_80:
                  ++*v42;
                  *a3 = v72[0];
                  *a4 = v24;
                  return result;
                }
              }

              else
              {
                if ((a2 & 0x1000) != 0) {
                  unsigned int v37 = 0;
                }
                else {
                  unsigned int v37 = 28;
                }
                else {
                  uint64_t result = v37;
                }
                if ((a2 & 0x1000) != 0)
                {
                  if (v24)
                  {
                    uint64_t v27 = (void *)(a1 + 416);
                    unint64_t v5 = v24;
LABEL_63:
                    ++*v27;
                    unint64_t v24 = v5;
                    goto LABEL_64;
                  }

                  if ((_DWORD)result) {
                    uint64_t result = result;
                  }
                  else {
                    uint64_t result = 28LL;
                  }
                }

                else
                {
                  v72[0] = 0LL;
                }
              }

              unint64_t v24 = 0LL;
              unint64_t v42 = (void *)(a1 + 424);
              goto LABEL_80;
            }
          }
        }
      }
    }
  }

  int v35 = *(unsigned __int8 *)(a1 + 88);
  __int128 v36 = "main";
  if (v35 == 1) {
    __int128 v36 = "tier2";
  }
  sub_100013D94( "%s:%d: %s dev %d Error searching %s free extent cache: %d; Reinitializing.\n",
    "spaceman_free_extent_cache_search",
    3031,
    (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),
    v35,
    v36,
    v17);
  sub_10002B1A8(a1);
  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return 3LL;
}

uint64_t sub_10002DEAC( uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, __int16 a6, unint64_t a7, unint64_t a8, unint64_t a9, uint64_t *a10, unint64_t *a11, uint64_t *a12, unint64_t *a13, unsigned int a14)
{
  if ((a14 & 3) == 0 || (a14 & 0x1F00) == 0) {
    return 22LL;
  }
  uint64_t v21 = a2;
  uint64_t v22 = a1;
  memset(v47, 170, 32);
  if ((a14 & 1) != 0) {
    int v23 = 1;
  }
  else {
    int v23 = -1;
  }
  uint64_t v15 = sub_10002E75C(a1, a2, v23);
  if ((v15 & 0xFFFFFFFD) == 0)
  {
    int v44 = a3;
    uint64_t v39 = a5;
    __int16 v46 = a6;
    unsigned int v25 = 0;
    int v43 = (char)v23;
    uint64_t v45 = a7;
    uint64_t v40 = v22;
    uint64_t v41 = v21;
    do
    {
      if ((_DWORD)v15 == 2) {
        return 0LL;
      }
      unint64_t v26 = (void *)(*(void *)(v22 + 80) + 24LL * *(unsigned __int16 *)(v21 + 4LL * *(unsigned __int8 *)(v21 + 97)));
      unint64_t v27 = *v26 & 0xFFFFFFFFFFFFFLL;
      v47[3] = v27;
      unint64_t v28 = v26[1] & 0xFFFFFFFFFFFFFLL;
      v47[1] = v28;
      if (v44)
      {
        __int16 v29 = v46;
        sub_1000322C8(v27, v28, a4, v39, v46, a7, &v47[3], &v47[1]);
        uint64_t v30 = v47[1];
        if (!v47[1]) {
          goto LABEL_39;
        }
      }

      else
      {
        uint64_t v30 = v28;
        __int16 v29 = v46;
        if (!v28)
        {
LABEL_39:
          if ((a14 & 0x1000) != 0 && v25 > 0x7E) {
            return v15;
          }
          goto LABEL_44;
        }
      }

      int v31 = sub_1000323A4( *(void *)v22,  *(void *)(v22 + 8),  *(unsigned __int8 *)(v22 + 88),  v47[3],  v30,  v29,  a7,  &v47[2],  v47);
      __int16 v32 = v29;
      uint64_t v33 = v47[3];
      unint64_t v34 = v47[1];
      if (v31)
      {
        if (sub_10002E198(a7, a8, *a12, *a13, v47[3], v47[1], v32))
        {
          *a12 = v33;
          *a13 = v34;
        }

        uint64_t v33 = v47[2];
        v47[3] = v47[2];
        unint64_t v34 = v47[0];
        v47[1] = v47[0];
      }

      unint64_t v35 = *a11;
      if (sub_10002E198(v45, a8, *a10, *a11, v33, v34, v46))
      {
        *a10 = v33;
        *a11 = v34;
        unint64_t v35 = v34;
        if ((a14 & 0x800) != 0) {
          return v15;
        }
      }

      BOOL v36 = v34 == v28 && (v28 == a8) & BYTE1(a14);
      if (v36 || ((v35 > a8) & (a14 >> 9)) != 0) {
        return v15;
      }
      if ((a14 & 0x400) != 0 && v28 < a8 && v28 <= v35) {
        return v15;
      }
      a7 = v45;
      uint64_t v22 = v40;
      uint64_t v21 = v41;
      if ((a14 & 0x1000) != 0)
      {
        if (v25 > 0x7E) {
          return v15;
        }
        unint64_t v38 = v33 - v45;
        if (v33 < v45)
        {
          if (v45 - v33 >= v34) {
            unint64_t v38 = v45 - v33 - v34;
          }
          else {
            unint64_t v38 = 0LL;
          }
        }

        if (v38 >= a9) {
          return v15;
        }
      }

BOOL sub_10002E198( uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, __int16 a7)
{
  if (!a6) {
    return 0LL;
  }
  if (!a4) {
    return 1LL;
  }
  if (a4 < a2)
  {
    if (a6 <= a4)
    {
      if (a6 != a4 || (a7 & 0x4000) == 0) {
        return 0LL;
      }
      if (a1 <= a3) {
        unint64_t v9 = a3 - a1;
      }
      else {
        unint64_t v9 = a1 - a3 >= a6 ? a1 - (a3 + a6) : 0LL;
      }
      if (a1 <= a5) {
        unint64_t v12 = a5 - a1;
      }
      else {
        unint64_t v12 = a1 - a5 >= a6 ? a1 - (a5 + a6) : 0LL;
      }
      if (v12 >= v9) {
        return 0LL;
      }
    }

    return 1LL;
  }

  if (a4 != a2)
  {
    unint64_t v10 = a4 - a2;
    if (a4 > a2)
    {
      unint64_t v11 = a6 - a2;
      if (a6 >= a2)
      {
        if (a6 == a2 || v10 <= 0xF && v11 > v10) {
          return 1LL;
        }
        if ((a7 & 0x4000) != 0)
        {
          if (a1 <= a3)
          {
            unint64_t v14 = a3 - a1;
          }

          else if (a1 - a3 >= a4)
          {
            unint64_t v14 = a1 - (a3 + a4);
          }

          else
          {
            unint64_t v14 = 0LL;
          }

          if (a1 <= a5)
          {
            unint64_t v15 = a5 - a1;
          }

          else if (a1 - a5 >= a6)
          {
            unint64_t v15 = a1 - (a5 + a6);
          }

          else
          {
            unint64_t v15 = 0LL;
          }

          return v11 >= 0x10 && v15 < v14;
        }

        if (v11 < v10 && v11 > 0xF) {
          return 1LL;
        }
      }
    }

    return 0LL;
  }

  if (a6 < a4 || a6 != a4 && (a7 & 0x4000) == 0) {
    return 0LL;
  }
  if (a1 <= a3) {
    unint64_t v8 = a3 - a1;
  }
  else {
    unint64_t v8 = a1 - a3 >= a4 ? a1 - (a3 + a4) : 0LL;
  }
  if (a1 <= a5) {
    unint64_t v13 = a5 - a1;
  }
  else {
    unint64_t v13 = a1 - a5 >= a6 ? a1 - (a5 + a6) : 0LL;
  }
  if (v13 >= v8) {
    return 0LL;
  }
  BOOL result = 1LL;
  if (a6 != a4 && a6 - a4 <= 0xF) {
    return 0LL;
  }
  return result;
}

uint64_t sub_10002E344(uint64_t a1, __int16 a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8 = a3;
  if ((a2 & 0x1000) != 0)
  {
    if (a4 > 1)
    {
      if (a4 + (a4 >> 1) >= a3) {
        unint64_t v8 = a3;
      }
      else {
        unint64_t v8 = a4 + (a4 >> 1);
      }
    }

    else
    {
      unint64_t v8 = a4 + 1;
    }
  }

  unint64_t v9 = *(void *)(a1 + 200);
  uint64_t v10 = *(void *)(a1 + 208);
  int64_t v11 = *(void *)(a1 + 160);
  if (*(void *)(a1 + 152) > v9) {
    unint64_t v9 = *(void *)(a1 + 152);
  }
  uint64_t v12 = *(void *)(a1 + 168);
  unint64_t v42 = v8;
  if (v10)
  {
    uint64_t v14 = v10 - v11;
    BOOL v13 = v10 <= v11;
    uint64_t v15 = v12 + v11;
    if (v10 < v11) {
      int64_t v11 = *(void *)(a1 + 208);
    }
    if (v13) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = v14;
    }
    uint64_t v17 = *(void *)(a1 + 216) + v16;
    if (v15 > v17 + v11) {
      uint64_t v12 = v15 - v11;
    }
    else {
      uint64_t v12 = v17;
    }
  }

  uint64_t v18 = *(void *)(a1 + 136);
  uint64_t v19 = *(void *)(a1 + 144);
  uint64_t v21 = *(void *)(a1 + 184);
  uint64_t v20 = *(void *)(a1 + 192);
  unint64_t v23 = *(void *)(a1 + 248);
  unint64_t v22 = *(void *)(a1 + 256);
  if (v9 <= v23) {
    unint64_t v24 = *(void *)(a1 + 248);
  }
  else {
    unint64_t v24 = v9;
  }
  unint64_t v25 = sub_100013C78(v22, *(void *)(a1 + 264), v11, v12, 0LL);
  uint64_t v26 = *(void *)(a1 + 96);
  uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 8) + 376LL) + 48LL * *(_DWORD *)(a1 + 88) + 72);
  if (v26 == v27) {
    goto LABEL_22;
  }
  if ((*(_BYTE *)(a1 + 280) & 1) == 0)
  {
LABEL_53:
    *(void *)(a1 + 440) = 0LL;
    __int16 v29 = (void *)(a1 + 448);
    uint64_t result = 1LL;
    goto LABEL_54;
  }

  unint64_t v30 = v20 + v19;
  if (!v26 && v27 && v30 + *(void *)(a1 + 240))
  {
    uint64_t v41 = (void *)(a1 + 456);
    goto LABEL_52;
  }

  if ((a2 & 0x1000) == 0 || a4 <= (3 * a3) >> 2)
  {
    if (v24 >= v42)
    {
      uint64_t v41 = (void *)(a1 + 464);
      goto LABEL_52;
    }

    if (v24 <= a4) {
      unint64_t v31 = a4;
    }
    else {
      unint64_t v31 = v24;
    }
    if (v42 <= *(void *)(a1 + 240) + v30 + v31 + v31 * (v18 + v21 + *(void *)(a1 + 232)))
    {
      unsigned int v32 = *(unsigned __int16 *)(a1 + 94);
      int v33 = *(_DWORD *)(a1 + 88) >> 8;
      signed int v34 = v33 - 1;
      int v35 = v33 - v32;
      if (v35 <= 4) {
        LODWORD(v36) = v35 + 4;
      }
      else {
        LODWORD(v36) = 8;
      }
      uint64_t v36 = (int)v36;
      unint64_t v37 = (64 - v42) >> 4;
      if (v42 >= 0x40) {
        unint64_t v37 = 0LL;
      }
      unint64_t v38 = v36 + v37 + (*(void *)(a1 + 440) >> 14);
      if (v34 / 10 <= v32)
      {
        unint64_t v39 = *(void *)(a1 + 128);
        if (v39 < *(void *)(a1 + 328))
        {
          unint64_t v40 = *(void *)(a1 + 176);
          if (v40 <= *(void *)(a1 + 224)) {
            unint64_t v40 = *(void *)(a1 + 224);
          }
          if (v40 >= *(void *)(a1 + 248) && v39 - *(void *)(a1 + 120) < 4) {
            unint64_t v38 = 1LL;
          }
        }
      }

      if (v30 > (v12 - v25 + *(void *)(a1 + 264)) / v38)
      {
        uint64_t v41 = (void *)(a1 + 472);
LABEL_52:
        ++*v41;
        goto LABEL_53;
      }
    }
  }

uint64_t sub_10002E5C8(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_BYTE *)(a2 + 96) = 0;
  uint64_t v4 = *(unsigned __int16 *)(a1 + 104);
  *(_WORD *)a2 = v4;
  if (v4) {
    *(_BYTE *)(a2 + 2) = *(_BYTE *)(*(void *)(a1 + 80) + 24LL * v4 + 7);
  }
  while (1)
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 97);
    if (!*(_WORD *)(a2 + 4 * v5)) {
      break;
    }
    uint64_t result = sub_10002E658(a1, a2, -1);
    if ((_DWORD)result) {
      return result;
    }
  }

  unsigned int v7 = v5 - 1;
  *(_BYTE *)(a2 + 97) = v7;
  return (v7 >> 6) & 2;
}

uint64_t sub_10002E658(uint64_t a1, uint64_t a2, __int16 a3)
{
  int v3 = *(char *)(a2 + 97);
  uint64_t v4 = *(unsigned __int8 *)(a2 + 97);
  *(_BYTE *)(a2 + 4 * v4 + 3) = a3;
  if (v3 < 23)
  {
    unsigned __int8 v7 = v4 + 1;
    *(_BYTE *)(a2 + 97) = v4 + 1;
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v9 = *(unsigned __int8 *)(a2 + 96);
    uint64_t v10 = *(unsigned __int16 *)(v8 + 24LL * *(unsigned __int16 *)(a2 + 4 * v4) + 4 * v9 + ((a3 + 1) & 0x1FE) + 16);
    uint64_t v11 = (v4 + 1);
    uint64_t v12 = a2 + 4LL * v7;
    *(_WORD *)uint64_t v12 = v10;
    *(_BYTE *)(v12 + 3) = 0;
    if (v10)
    {
      if ((_DWORD)v9) {
        char v13 = *(_BYTE *)(v8 + 24LL * v10 + 15);
      }
      else {
        char v13 = *(_BYTE *)(v8 + 24LL * v10 + 7);
      }
    }

    else
    {
      char v13 = 0;
    }

    uint64_t result = 0LL;
    *(_BYTE *)(a2 + 4 * v11 + 2) = v13;
  }

  else
  {
    uint64_t v5 = "length";
    if (!*(_BYTE *)(a2 + 96)) {
      uint64_t v5 = "paddr";
    }
    sub_100013D94( "%s:%d: %s dev %d %s tree: PATH TOO LONG: %d\n",  "spaceman_fxtp_add_child",  752,  (const char *)(*(void *)(*(void *)a1 + 384LL) + 208LL),  *(unsigned __int8 *)(a1 + 88),  v5,  v4);
    return 84LL;
  }

  return result;
}

uint64_t sub_10002E75C(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = -a3;
  uint64_t v5 = *(unsigned __int8 *)(a2 + 97);
  if (*(_WORD *)(*(void *)(a1 + 80)
                + 24LL * *(unsigned __int16 *)(a2 + 4 * v5)
                + 4LL * *(unsigned __int8 *)(a2 + 96)
                + (((_WORD)a3 + 1) & 0x1FE)
                + 16))
  {
    uint64_t result = sub_10002E658(a1, a2, a3);
    if (!(_DWORD)result)
    {
      while (1)
      {
        uint64_t v8 = *(unsigned __int8 *)(a2 + 97);
        if (!*(_WORD *)(a2 + 4 * v8)) {
          break;
        }
        uint64_t result = sub_10002E658(a1, a2, (char)v4);
        if ((_DWORD)result) {
          return result;
        }
      }

      unsigned __int8 v13 = v8 - 1;
      *(_BYTE *)(a2 + 97) = v13;
      uint64_t v11 = (_BYTE *)(a2 + 4LL * v13 + 3);
LABEL_12:
      uint64_t result = 0LL;
      *uint64_t v11 = 0;
    }
  }

  else
  {
    LODWORD(v5) = (char)v5;
    while (1)
    {
      BOOL v9 = __OFSUB__((_DWORD)v5, 1);
      LODWORD(v5) = v5 - 1;
      uint64_t v10 = a2 + 4LL * v5;
      int v12 = *(unsigned __int8 *)(v10 + 3);
      uint64_t v11 = (_BYTE *)(v10 + 3);
      if (v12 == v4)
      {
        *(_BYTE *)(a2 + 97) = v5;
        goto LABEL_12;
      }
    }
  }

  return result;
}

uint64_t sub_10002E83C(uint64_t result, unsigned int a2, int a3, unsigned int a4, unsigned __int16 *a5)
{
  uint64_t v5 = *(void *)(result + 80);
  uint64_t v6 = v5
     + 24LL * a4
     + 4LL * a2
     + 2LL * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1);
  unsigned __int16 v7 = *(_WORD *)(v6 + 16);
  uint64_t v8 = v5 + 24LL * v7;
  uint64_t v9 = v8 + 4LL * a2 + 2LL * ((a3 + 1 + (((a3 + 1) & 0x8000u) >> 15)) >> 1);
  *(_WORD *)(v6 + 16) = *(_WORD *)(v9 + 16);
  *(_WORD *)(v9 + 16) = a4;
  *a5 = v7;
  uint64_t v10 = v8 + 8;
  if (!a2) {
    uint64_t v10 = v5 + 24LL * v7;
  }
  if (*(_BYTE *)(v10 + 7))
  {
    uint64_t v14 = (void *)(v5 + 24LL * a4);
    if (a2) {
      ++v14;
    }
    *v14 &= 0xFFFFFFFFFFFFFFuLL;
    unint64_t v13 = *(void *)v10 & 0xFFFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v11 = (uint64_t *)(v5 + 24LL * a4);
    if (a2) {
      ++v11;
    }
    uint64_t v12 = *v11;
    if (a3 == -1)
    {
      *uint64_t v11 = v12 & 0xFFFFFFFFFFFFFFLL | 0x100000000000000LL;
      unint64_t v13 = *(void *)v10 | 0xFF00000000000000LL;
    }

    else
    {
      *uint64_t v11 = v12 | 0xFF00000000000000LL;
      unint64_t v13 = *(void *)v10 & 0xFFFFFFFFFFFFFFLL | 0x100000000000000LL;
    }
  }

  *(void *)uint64_t v10 = v13;
  return result;
}

uint64_t sub_10002E930(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int a5, _WORD *a6)
{
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v7 = v6
     + 24LL * a5
     + 4LL * a2
     + 2LL * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1);
  unsigned int v8 = *(unsigned __int16 *)(v7 + 16);
  uint64_t v9 = v6 + 24LL * *(unsigned __int16 *)(v7 + 16);
  uint64_t v10 = v9 + 4LL * a2 + 16;
  uint64_t result = *(unsigned __int16 *)(v10
                               + 2LL * (((_DWORD)a3 + 1 + ((((_DWORD)a3 + 1) & 0x8000u) >> 15)) >> 1));
  *(_WORD *)(v7 + 16) = result;
  *(_WORD *)(v10 + 2LL * (((_DWORD)a3 + 1 + ((((_DWORD)a3 + 1) & 0x8000u) >> 15)) >> 1)) = a5;
  *(_WORD *)(v6
           + 24LL * a4
           + 4LL * a2
           + 2LL * (((_DWORD)a3 + 1 + ((((_DWORD)a3 + 1) & 0x8000u) >> 15)) >> 1)
           + 16) = *(_WORD *)(v10
                            + 2LL
                            * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1));
  *(_WORD *)(v10 + 2LL * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1)) = a4;
  *a6 = v8;
  if (a2) {
    unsigned __int8 v12 = *(_BYTE *)(v6 + 24LL * v8 + 15);
  }
  else {
    unsigned __int8 v12 = *(_BYTE *)(v9 + 7);
  }
  if (v12 == a3)
  {
    uint64_t v13 = v6 + 24LL * a4;
    if (a2) {
      v13 += 8LL;
    }
    *(_BYTE *)(v13 + 7) = -(char)a3;
    uint64_t v14 = (uint64_t *)(v6 + 24LL * a5);
    if (a2) {
      ++v14;
    }
    uint64_t v15 = *v14 & 0xFFFFFFFFFFFFFFLL;
  }

  else
  {
    uint64_t v16 = (void *)(v6 + 24LL * a4);
    if (a2) {
      ++v16;
    }
    *v16 &= 0xFFFFFFFFFFFFFFuLL;
    uint64_t v14 = (uint64_t *)(v6 + 24LL * a5);
    if (a2) {
      ++v14;
    }
    uint64_t v15 = *v14 & 0xFFFFFFFFFFFFFFLL;
    if (v12) {
      v15 |= a3 << 56;
    }
  }

  *uint64_t v14 = v15;
  uint64_t v17 = (void *)(v6 + 24LL * v8 + 8);
  if (!a2) {
    uint64_t v17 = (void *)v9;
  }
  *v17 &= 0xFFFFFFFFFFFFFFuLL;
  return result;
}

uint64_t sub_10002EA64(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 496);
    uint64_t v2 = (char *)(result + 3992);
    if (v1) {
      return snprintf(v2, 0x20uLL, "%ss%d:%lld");
    }
    else {
      return snprintf(v2, 0x20uLL, "%ss%d");
    }
  }

  return result;
}

uint64_t sub_10002EAD4(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1112756289;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 116) = 0x4000000200000002LL;
  *(_DWORD *)(a1 + 124) = 1073741826;
  *(int32x2_t *)(a1 + 1040) = vdup_n_s32(0x40000002u);
  *(_DWORD *)(a1 + 1068) = 2;
  *(_DWORD *)(a1 + 1104) = 2;
  return 0LL;
}

uint64_t sub_10002EB1C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = sub_10002F740(a1, *(_DWORD *)(v2 + 116));
  if (!(_DWORD)v3)
  {
    uint64_t v3 = sub_10002F740(a1, *(_DWORD *)(v2 + 120));
    if (!(_DWORD)v3)
    {
      uint64_t v3 = sub_10002F740(a1, *(_DWORD *)(v2 + 124));
      if (!(_DWORD)v3)
      {
        uint64_t v5 = *(void *)(v2 + 56);
        if ((v5 & 0x20) != 0)
        {
          uint64_t v3 = sub_10002F740(a1, *(_DWORD *)(v2 + 1040));
          if ((_DWORD)v3) {
            return v3;
          }
          uint64_t v5 = *(void *)(v2 + 56);
        }

        if ((v5 & 0x40) == 0 || (uint64_t v3 = sub_10002F740(a1, *(_DWORD *)(v2 + 1044)), !(_DWORD)v3))
        {
          uint64_t v3 = sub_10002F6B0(a1 + 3288, (uint64_t)"apfs-stream-id-lock", 0x100u);
          if (!(_DWORD)v3)
          {
            uint64_t v6 = sub_10002F6B0(a1 + 3416, (uint64_t)"apfs-dir-stats-id-lock", 0x10u);
            if ((_DWORD)v6)
            {
              uint64_t v3 = v6;
LABEL_15:
              sub_10002F708(a1 + 3288);
              return v3;
            }

            uint64_t v7 = sub_1000191C0(a1 + 3624, 0x20u);
            if ((_DWORD)v7)
            {
              uint64_t v3 = v7;
              sub_10002F708(a1 + 3416);
              goto LABEL_15;
            }

            *(void *)(a1 + 376) = v2;
            *(void *)(a1 + 392) = *(void *)(*(void *)a1 + 392LL);
            sub_1000139BC((pthread_mutex_t *)(a1 + 1208));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1272));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1336));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1400));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1464));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1656));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1528));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1592));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1144));
            sub_1000139BC((pthread_mutex_t *)(a1 + 3224));
            sub_1000139BC((pthread_mutex_t *)(a1 + 1720));
            sub_1000139BC((pthread_mutex_t *)(a1 + 3904));
            sub_1000139C8((pthread_rwlock_t *)(a1 + 1784));
            sub_1000139C8((pthread_rwlock_t *)(a1 + 3000));
            sub_1000139C8((pthread_rwlock_t *)(a1 + 1984));
            sub_1000325C0(a1 + 3784, 0xE10u, 0x18u);
            sub_10002EA64(a1);
            *(void *)(a1 + 592) = 0LL;
            if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 1) != 0 && !sub_10001CFC0(a1))
            {
              uint64_t v3 = 0LL;
              *(void *)(a1 + 688) = 1LL;
            }

            else
            {
              return 0LL;
            }
          }
        }
      }
    }
  }

  return v3;
}

uint64_t sub_10002ED78(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 3608);
  if (v2 && !*(_DWORD *)(*(void *)a1 + 912LL)) {
    sub_100038824(v2);
  }
  sub_10002F708(a1 + 3416);
  sub_10002F708(a1 + 3288);
  sub_10003265C(a1 + 3784);
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 2800));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 2592));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 2392));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 2184));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 1984));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 3000));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 1784));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3224));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1144));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1208));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1528));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1592));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1400));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1464));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1656));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1272));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1336));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1720));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 3904));
  sub_10001928C(a1 + 3624);
  return 0LL;
}

uint64_t sub_10002EE68(uint64_t a1, char a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unint64_t v21 = 0LL;
  if (a4 < 0x14) {
    return 28LL;
  }
  unsigned int v8 = *(_DWORD *)(a3 + 16);
  if (v8 < 5)
  {
    uint64_t v11 = sub_10003CF9C((void *)a1, 0, a5);
    if ((_DWORD)v11)
    {
      uint64_t v5 = v11;
      sub_100013D94( "%s:%d: %s failed to modify the apfs_t before reaping (error %d).\n",  "apfs_reap",  619,  (const char *)(a1 + 3992),  v11);
    }

    else if ((a2 & 1) != 0)
    {
      sub_10004D4EC(*(void **)(a1 + 392), a1, a5);
      sub_10003B238((uint64_t *)a1, a5);
      return 0LL;
    }

    else
    {
      switch(*(_DWORD *)(a3 + 16))
      {
        case 0:
          *(_DWORD *)(a3 + 16) = 1;
          goto LABEL_10;
        case 1:
LABEL_10:
          uint64_t v5 = sub_10002F778(a1, a5, &v21, (uint64_t *)a3);
          if ((_DWORD)v5) {
            return v5;
          }
          *(void *)a3 = 0LL;
          *(_DWORD *)(a3 + 16) = 2;
LABEL_12:
          uint64_t v5 = sub_10002F948(a1, a5, *(void *)(*(void *)(a1 + 376) + 144LL), &v21, (uint64_t *)a3);
          if ((_DWORD)v5) {
            return v5;
          }
          uint64_t v12 = *(void *)(a1 + 376);
          uint64_t v13 = *(void *)(v12 + 224);
          if (*(void *)(v12 + 232) != v13)
          {
            sub_100013D94( "%s:%d: %s freed != alloced (%llu freed, %llu alloced)\n",  "apfs_reap",  655,  (const char *)(a1 + 3992),  *(void *)(v12 + 232),  v13);
            uint64_t v12 = *(void *)(a1 + 376);
          }

          uint64_t v14 = *(void *)(v12 + 56);
          if ((v14 & 0x20) == 0) {
            goto LABEL_22;
          }
          uint64_t v15 = sub_100003864(a1, *(_DWORD *)(v12 + 1040), 5, a5, 0LL, 0LL);
          if ((_DWORD)v15)
          {
            uint64_t v5 = v15;
            strerror(v15);
            sub_100013D94("%s:%d: %s supplemental_tree_destroy(fext_tree) failed: %d (%s)\n");
          }

          else
          {
            uint64_t v12 = *(void *)(a1 + 376);
            uint64_t v14 = *(void *)(v12 + 56);
LABEL_22:
            if ((v14 & 0x40) != 0 && (uint64_t v17 = sub_100003864(a1, *(_DWORD *)(v12 + 1044), 6, a5, 0LL, 0LL), (_DWORD)v17))
            {
              uint64_t v5 = v17;
              strerror(v17);
              sub_100013D94("%s:%d: %s supplemental_tree_destroy(pfkur_tree) failed: %d (%s)\n");
            }

            else
            {
              *(_DWORD *)(a3 + 16) = 3;
LABEL_26:
              sub_100039678(*(void *)(*(void *)(a1 + 392) + 392LL), a1);
              uint64_t v18 = *(uint64_t **)(a1 + 3544);
              if (v18)
              {
                sub_100038824(v18);
                *(void *)(a1 + 3544) = 0LL;
              }

              uint64_t v19 = *(uint64_t **)(a1 + 3592);
              if (v19)
              {
                sub_100038824(v19);
                *(void *)(a1 + 3592) = 0LL;
              }

              uint64_t v5 = sub_100040C2C(a1, *(void *)(*(void *)(a1 + 376) + 128LL), a5, 0LL);
              if ((_DWORD)v5)
              {
                sub_100013D94("%s:%d: %s omap_destroy returned %d!\n");
              }

              else
              {
                uint64_t v20 = *(void *)(a1 + 376);
                *(void *)(v20 + 976) = 0LL;
                *(void *)(v20 + 1032) = 0LL;
                *(void *)(v20 + 1048) = 0LL;
                *(_OWORD *)(v20 + 128) = 0u;
                *(_OWORD *)(v20 + 144) = 0u;
                *(_OWORD *)(v20 + 1072) = 0u;
                sub_10001AAF0(a1, a5);
                *(_DWORD *)(a3 + 16) = 4;
              }
            }
          }

          break;
        case 2:
          goto LABEL_12;
        case 3:
          goto LABEL_26;
        default:
          return 0LL;
      }
    }
  }

  else
  {
    sub_100013D94("%s:%d: %s bogus phase, %u\n", "apfs_reap", 613, (const char *)(a1 + 3992), v8);
    return 5LL;
  }

  return v5;
}

uint64_t sub_10002F178(uint64_t a1, size_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(_BYTE *)(a3 + 20) & 0x40) != 0) {
    return 0LL;
  }
  uint64_t v15 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v5 = *(void *)(*(void *)(a3 + 376) + 128LL);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v9 = sub_10003B574( *(void *)(a1 + 392),  0x40000000u,  v5,  (int *)&xmmword_10005B9F8,  0LL,  a3,  0LL,  0LL,  (uint64_t *)&v15);
  if ((_DWORD)v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)(a1 + 400);
    if (!v11 || !*(_DWORD *)(v11 + 76)) {
      sub_100013D94("%s:%d: %s failed to get omap %lld: %d\n");
    }
    return v10;
  }

  uint64_t v10 = sub_100040FB0(a3, a2, (uint64_t)v15, a4);
  uint64_t v12 = v15[2];
  sub_100038824(v15);
  if (!(_DWORD)v10)
  {
    if ((v12 & 0x4000000000LL) == 0) {
      return 0LL;
    }
LABEL_13:
    sub_10003E20C(a3, 1);
    return 0LL;
  }

  uint64_t v13 = *(void *)(a1 + 400);
  if (!v13 || !*(_DWORD *)(v13 + 76)) {
    sub_100013D94("%s:%d: %s omap checkpoint traverse (op %d) failed: %d\n");
  }
  return v10;
}

uint64_t sub_10002F2C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 496);
  if (!v1) {
    uint64_t v1 = a1;
  }
  uint64_t v2 = *(void *)(*(void *)(v1 + 376) + 264LL) & 0x109LL;
  uint64_t result = 2863311530LL;
  if (v2 > 7)
  {
    if (v2 == 8)
    {
      return 2LL;
    }

    else if (v2 == 256)
    {
      return 3LL;
    }
  }

  else if (v2)
  {
    if (v2 == 1) {
      return 0LL;
    }
  }

  else
  {
    return 1LL;
  }

  return result;
}

uint64_t sub_10002F328(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t **a5)
{
  if (a2) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = a1;
  }
  uint64_t v10 = *(void *)(v9 + 376);
  int v11 = *(_DWORD *)(v10 + 116);
  unint64_t v12 = *(void *)(v10 + 136);
  memset(&v14[2], 0, 64);
  v14[0] = *(_OWORD *)off_10006C5E8;
  v14[1] = unk_10006C5F8;
  if ((*(_BYTE *)(v10 + 56) & 0x20) == 0 || (uint64_t result = sub_100003158(a1, v14), !(_DWORD)result))
  {
    else {
      return 22LL;
    }
  }

  return result;
}

BOOL sub_10002F41C(uint64_t a1, void *a2, unsigned int a3)
{
  return a3 >= 8 && (*a2 & 0xFFFFFFFFFFFFFFFLL) == *(void *)(*(void *)(a1 + 376) + 176LL) - 1LL;
}

BOOL sub_10002F44C(uint64_t a1)
{
  return (*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 1) != 0 && !sub_10001CFC0(a1);
}

uint64_t sub_10002F478(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t **a5)
{
  if (a2) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = a1;
  }
  if ((*(_BYTE *)(*(void *)(a1 + 376) + 57LL) & 1) == 0) {
    return 45LL;
  }
  uint64_t v10 = *(void *)(v5 + 376);
  int v11 = *(_DWORD *)(v10 + 1104);
  unint64_t v12 = *(void *)(v10 + 1096);
  if (sub_10001CFC0(a1)) {
    return 45LL;
  }
  return 22LL;
}

uint64_t sub_10002F52C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  return sub_10002F328(a1, 0LL, a2, a3, a4);
}

uint64_t sub_10002F540(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  return sub_10002F478(a1, 0LL, a2, a3, a4);
}

uint64_t sub_10002F554(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  if ((unsigned __int16)*(_DWORD *)(*(void *)(a1 + 376) + 120LL) == 2) {
    return sub_100027CC4( a1,  *(_DWORD *)(*(void *)(a1 + 376) + 120LL) & 0xFFFF0000,  a2,  0LL,  a3 != 0,  (uint64_t)&off_10006C6A8,  a3,  a4);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_10002F598(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v3 = *(void *)(a1 + 376);
  if ((unsigned __int16)*(_DWORD *)(v3 + 124) == 2) {
    return sub_100027CC4( a1,  *(_DWORD *)(v3 + 124) & 0xFFFF0000,  *(void *)(v3 + 152),  0LL,  a2 != 0,  (uint64_t)&off_10006C708,  a2,  a3);
  }
  else {
    return 22LL;
  }
}

uint64_t sub_10002F5DC(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t **a6)
{
  if (a3) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = a1;
  }
  uint64_t v7 = *(void *)(v6 + 376);
  uint64_t v8 = 1072LL;
  if (a2) {
    uint64_t v8 = 1080LL;
  }
  return sub_100027CC4( a1,  *(_DWORD *)(v7 + 1068) & 0xFFFF0000,  *(void *)(v7 + v8),  a4,  a5 != 0,  (uint64_t)off_10006C768,  a5,  a6);
}

BOOL sub_10002F634(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  return a3 >= 4 && *a2 == *(_DWORD *)(*(void *)(a1 + 376) + 960LL) - 1;
}

uint64_t sub_10002F660(uint64_t a1, int a2, unint64_t a3, uint64_t a4, uint64_t **a5)
{
  return sub_10002F5DC(a1, a2, 0LL, a3, a4, a5);
}

uint64_t sub_10002F674(uint64_t a1)
{
  int v1 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 964LL);
  uint64_t result = 1LL;
  if (v1 > 63)
  {
    if (v1 != 64 && v1 != 576) {
      return 0LL;
    }
  }

  else
  {
    if (v1) {
      BOOL v3 = v1 == 2;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10002F6B0(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *(_DWORD *)(a1 + 120) = a3;
  int v4 = sub_100013EEC(a3, 0x10uLL);
  *(void *)(a1 + 112) = v4;
  if (!v4) {
    return 12LL;
  }
  sub_1000139BC((pthread_mutex_t *)a1);
  sub_1000139D4((pthread_cond_t *)(a1 + 64));
  return 0LL;
}

void sub_10002F708(uint64_t a1)
{
}

uint64_t sub_10002F740(uint64_t a1, int a2)
{
  else {
    return sub_100005194(*(void *)(*(void *)a1 + 392LL));
  }
}

uint64_t sub_10002F778(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v8 = a4[1];
  if (!v8)
  {
    uint64_t v16 = sub_100041BD8(a1, 0LL, &v18);
    if ((_DWORD)v16)
    {
      uint64_t v9 = v16;
      if ((_DWORD)v16 == 2)
      {
LABEL_13:
        sub_100003614(a1, a2, 0LL);
        return 0LL;
      }

      else
      {
        sub_100013D94("%s:%d: %s Hit %d looking up first snapshot\n");
      }

      return v9;
    }

    uint64_t v8 = v18;
    a4[1] = v18;
  }

  uint64_t v9 = sub_100003418(a1, v8, &v19);
  if ((_DWORD)v9)
  {
LABEL_3:
    sub_100013D94("%s:%d: %s Couldn't find snapshot metadata for xid %llu\n");
  }

  else
  {
    while (1)
    {
      unint64_t v12 = v19;
      unint64_t v13 = *((void *)v19 + 2);
      if (v13)
      {
        uint64_t v14 = sub_10002F948(a1, a2, v13, a3, a4);
        if ((_DWORD)v14) {
          return v14;
        }
        unint64_t v12 = v19;
      }

      sub_100003530(a1, 5, *((void *)v12 + 3), a2, 0LL);
      sub_100003530(a1, 6, *((void *)v19 + 3), a2, 0LL);
      sub_1000034B4(a1, *((void *)v19 + 3), a2);
      uint64_t v15 = sub_100041BD8(a1, a4[1], &v18);
      if ((_DWORD)v15) {
        break;
      }
      uint64_t v10 = v18;
      *a4 = 0LL;
      a4[1] = v10;
      uint64_t v11 = sub_100003418(a1, v10, &v19);
      if ((_DWORD)v11)
      {
        uint64_t v9 = v11;
        goto LABEL_3;
      }
    }

    uint64_t v9 = v15;
    if ((_DWORD)v15 == 2) {
      goto LABEL_13;
    }
    sub_100013D94( "%s:%d: %s lookup_next_snapshot() returned %d\n",  "apfs_reap_snapshots",  591,  (const char *)(a1 + 3992),  v15);
  }

  return v9;
}

uint64_t sub_10002F948(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t *a5)
{
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v24[2] = v10;
  v24[3] = v10;
  v24[0] = v10;
  v24[1] = v10;
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v23 = 0LL;
  memset(v21, 170, 20);
  uint64_t v11 = sub_10002F554(a1, a3, 0LL, &v23);
  if ((_DWORD)v11)
  {
    uint64_t v12 = v11;
    sub_100013D94("%s:%d: apfs_get_extentref_tree(oid=%llu) returned %d\n", "apfs_reap_extentref_blocks", 486, a3, v11);
  }

  else
  {
    uint64_t v22 = *a5 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000LL;
    sub_100026D8C((uint64_t)v24, (uint64_t)v23, 0LL, 4, (unint64_t *)&v22, 8, 8u, v21, 0x14u, 0LL);
    if ((v13 & 0xFFFFFFFD) != 0)
    {
      uint64_t v12 = v13;
      sub_100013D94( "%s:%d: %s tree_iter_init() returned %d\n",  "apfs_reap_extentref_blocks",  496,  (const char *)(a1 + 3992),  v13);
    }

    else
    {
      while (1)
      {
        if (sub_100026EFC((uint64_t)v24))
        {
          sub_100029238((size_t)v23, a2, 0LL);
          uint64_t v12 = 0LL;
          goto LABEL_5;
        }

        unint64_t v15 = v22 & 0xFFFFFFFFFFFFFFFLL;
        *a5 = v22 & 0xFFFFFFFFFFFFFFFLL;
        if (v21[0] >> 60 == 1LL && v21[1] <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v17 = v21[0] & 0xFFFFFFFFFFFFFFFLL;
          if ((v21[0] & 0xFFFFFFFFFFFFFFFLL) != 0)
          {
          }

          else
          {
            sub_100013D94("%s:%d: %s found bogus 0-length extent at lba %llu, ignoring\n");
          }

          unint64_t v18 = *a4 + v17;
          *a4 = v18;
          if (v18 > 0x4000) {
            break;
          }
        }

        uint64_t v19 = sub_100026F18((uint64_t)v24);
        if ((v19 & 0xFFFFFFFD) != 0)
        {
          uint64_t v20 = v19;
          sub_100013D94( "%s:%d: %s iter_next returned %d\n",  "apfs_reap_extentref_blocks",  528,  (const char *)(a1 + 3992),  v19);
          uint64_t v12 = v20;
          goto LABEL_5;
        }
      }

      uint64_t v12 = 36LL;
    }
  }

LABEL_5:
  if (v23) {
    sub_100038824(v23);
  }
  return v12;
}

void sub_10002FB6C(uint64_t a1, int a2, void *a3)
{
  if (a2 == 1)
  {
    if (a3) {
      sub_100014004(a3, 96LL);
    }
  }

  else
  {
    sub_100013D94("%s:%d: %s invalid crypto object type %u\n", "crypto_obj_free", 309, (const char *)(a1 + 3992), a2);
  }

void sub_10002FBC4(uint64_t a1, void *a2)
{
  if (a2) {
    sub_100014004(a2, 96LL);
  }
}

uint64_t sub_10002FBD8(uint64_t a1, int a2)
{
  if (!a1) {
    panic("assertion failed: %s", "apfs");
  }
  if (*(void *)(a1 + 496)) {
    panic("assertion failed: %s", "!((apfs)->apfs_main_apfs != ((void *)0))");
  }
  if (a2 != 1) {
    return 22LL;
  }
  BOOL v3 = sub_100013EEC(1uLL, 0x58uLL);
  if (v3)
  {
    int v4 = v3;
    *(void *)BOOL v3 = a1;
    v3[72] = 1;
    *((void *)v3 + 10) = off_10006C7C8;
    *((_DWORD *)v3 + 5) = 2048;
    *((_DWORD *)v3 + 7) = 102;
    uint64_t v5 = sub_100013C00(2048, (_DWORD *)v3 + 3);
    v4[4] = v5;
    if (v5)
    {
      *((_DWORD *)v4 + 2) = *((_DWORD *)v4 + 3) + 1;
      v4[5] = 0LL;
      *((_DWORD *)v4 + 4) = 0;
      v4[6] = v4 + 5;
      v4[7] = 0LL;
      v4[8] = v4 + 7;
      sub_10002FD08(a1, 1, 0LL);
      *(void *)(a1 + 1008) = v4;
      sub_10002FDA8(a1, 1, 0);
      return 0LL;
    }

    sub_100014004(v4, 88LL);
  }

  return 12LL;
}

uint64_t sub_10002FD08(uint64_t a1, int a2, void *a3)
{
  if (!a1) {
    panic("assertion failed: %s", "apfs");
  }
  if (a2 != 1) {
    panic("assertion failed: %s", "0");
  }
  uint64_t v5 = *(void *)(a1 + 496);
  if (!v5) {
    uint64_t v5 = a1;
  }
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v5 + 1016));
  if (a3)
  {
    uint64_t v7 = *(void *)(a1 + 496);
    if (!v7) {
      uint64_t v7 = a1;
    }
    *a3 = *(void *)(v7 + 1008);
  }

  return result;
}

uint64_t sub_10002FDA8(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    panic("assertion failed: %s", "apfs");
  }
  if (a2 != 1) {
    panic("assertion failed: %s", "0");
  }
  uint64_t v3 = *(void *)(a1 + 496);
  if (a3)
  {
    if (v3) {
      uint64_t v4 = *(void *)(a1 + 496);
    }
    else {
      uint64_t v4 = a1;
    }
    *(void *)(v4 + 1008) = 0LL;
  }

  if (!v3) {
    uint64_t v3 = a1;
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 1016));
}

  ;
}

uint64_t sub_10002FE4C(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v23 = 0LL;
  sub_10002FD08(a1, a2, &v23);
  uint64_t v6 = v23;
  if (!v23)
  {
    uint64_t v14 = 22LL;
    goto LABEL_25;
  }

  uint64_t v7 = *a3;
  uint64_t v8 = *(void *)(v23 + 32);
  uint64_t v9 = *a3 & *(unsigned int *)(v23 + 12);
  uint64_t v10 = *(void *)(v8 + 8 * v9);
  if (v10)
  {
    uint64_t v11 = *(void **)(v8 + 8 * v9);
    while (*v11 != v7)
    {
      uint64_t v11 = (void *)v11[2];
      if (!v11) {
        goto LABEL_6;
      }
    }

    uint64_t v14 = 17LL;
  }

  else
  {
LABEL_6:
    unsigned int v12 = *(_DWORD *)(v23 + 16);
    if (v12 >= *(_DWORD *)(v23 + 20))
    {
      uint64_t v13 = *(void **)(v23 + 40);
      if (*(_BYTE *)(v23 + 72) == 2)
      {
        if (v13) {
          panic("assertion failed: %s", "((&crypto_cache->free_list)->tqh_first == ((void *)0))");
        }
        sub_100013D94( "%s:%d: %s cannot insert new ep %llu because the policy cache is full\n",  "crypto_hash_insert",  950,  (const char *)(*(void *)v23 + 3992LL),  v7);
        uint64_t v14 = 16LL;
        goto LABEL_25;
      }

      if (v13)
      {
        uint64_t v15 = v13[4];
        uint64_t v16 = (void *)v13[5];
        if (v15)
        {
          *(void *)(v15 + 40) = v16;
          uint64_t v16 = (void *)v13[5];
        }

        else
        {
          *(void *)(v23 + 48) = v16;
        }

        void *v16 = v15;
        uint64_t v17 = v13[2];
        if (v17) {
          *(void *)(v17 + 24) = v13[3];
        }
        *(void *)v13[3] = v17;
        (**(void (***)(uint64_t))(v6 + 80))(v6);
        unsigned int v12 = *(_DWORD *)(v6 + 16) - 1;
        uint64_t v8 = *(void *)(v6 + 32);
        uint64_t v9 = *a3 & *(unsigned int *)(v6 + 12);
        uint64_t v10 = *(void *)(v8 + 8 * v9);
      }
    }

    a3[2] = v10;
    *((_DWORD *)a3 + 2) = 1;
    unint64_t v18 = (uint64_t **)(v8 + 8 * v9);
    if (v10) {
      *(void *)(v10 + 24) = a3 + 2;
    }
    uint64_t v14 = 0LL;
    *unint64_t v18 = a3;
    a3[3] = (uint64_t)v18;
    uint64_t v20 = *(void *)(v6 + 56);
    uint64_t v19 = (uint64_t **)(v6 + 56);
    a3[4] = v20;
    unint64_t v21 = (void *)(v20 + 40);
    if (!v20) {
      unint64_t v21 = v19 + 1;
    }
    *unint64_t v21 = a3 + 4;
    *uint64_t v19 = a3;
    a3[5] = (uint64_t)v19;
    *((_DWORD *)v19 - 10) = v12 + 1;
  }

uint64_t sub_100030014(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 8) - 1;
  *(_DWORD *)(a2 + 8) = v2;
  if (v2 < 0) {
    panic( "crypto object retain count %d is not valid (crypto-id %lld, type %u apfs %p)\n",  v2,  *(void *)a2,  *(unsigned __int8 *)(result + 72),  *(const void **)result);
  }
  if (!v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(result + 80) + 8LL))(result, a2);
  }
  return result;
}

uint64_t sub_100030098(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v9 = 0LL;
  sub_10002FD08(a1, a2, &v9);
  if (a3 && v9)
  {
    if (*((_BYTE *)v9 + 72) != 1) {
      goto LABEL_9;
    }
    if (a3 != 5)
    {
      uint64_t v6 = *v9;
      if (*(void *)(*v9 + 496)) {
        uint64_t v6 = *(void *)(*v9 + 496);
      }
      if (a3 != 4 || (*(void *)(*(void *)(v6 + 376) + 264LL) & 0x100) == 0)
      {
LABEL_9:
        uint64_t v7 = *(void **)(v9[4] + 8LL * (*((_DWORD *)v9 + 3) & a3));
        if (v7)
        {
          while (*v7 != a3)
          {
            uint64_t v7 = (void *)v7[2];
            if (!v7) {
              return sub_10002FDA8(a1, a2, 0);
            }
          }

          sub_100030014((uint64_t)v9, (uint64_t)v7);
        }
      }
    }
  }

  return sub_10002FDA8(a1, a2, 0);
}

uint64_t sub_10003015C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 20) = *(void *)(a2 + 48);
  int v3 = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 32) = v3;
  *(_WORD *)(a3 + 36) = *(_WORD *)(a2 + 60);
  return 0LL;
}

uint64_t sub_100030180()
{
  return 45LL;
}

uint64_t sub_100030188(uint64_t result)
{
  *(_DWORD *)(result + 52) |= 1u;
  return result;
}

uint64_t sub_100030198(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x40) {
    return 0LL;
  }
  char v3 = a2;
  int v5 = sub_10002F2C4(a1);
  if (v5 == 1)
  {
    int v9 = sub_10002F2C4(a1);
    unint64_t v7 = 255LL;
    if (v9 != 1)
    {
      uint64_t v8 = "get_vol_crypto(apfs) == VOL_CPROTECTED";
LABEL_9:
      panic("assertion failed: %s", v8);
    }

    return (v7 >> v3) & 1;
  }

  if (v5 == 3)
  {
    int v6 = sub_10002F2C4(a1);
    unint64_t v7 = 223LL;
    if (v6 != 3)
    {
      uint64_t v8 = "get_vol_crypto(apfs) == VOL_PFKEY";
      goto LABEL_9;
    }

    return (v7 >> v3) & 1;
  }

  return 0LL;
}

void sub_100030244(uint64_t a1, _DWORD *a2)
{
  int v3 = a2[22];
  if (v3) {
    panic("cst %llu hit zero retain count but still has ep related retain count (%u)\n", *(void *)a2, v3);
  }
  uint64_t v4 = *((void *)a2 + 4);
  int v5 = (void *)*((void *)a2 + 5);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    int v5 = (void *)*((void *)a2 + 5);
  }

  else
  {
    *(void *)(a1 + 64) = v5;
  }

  *int v5 = v4;
  if (*(_DWORD *)(a1 + 16) <= *(_DWORD *)(a1 + 20))
  {
    unint64_t v7 = *(void **)(a1 + 48);
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = v7;
    *unint64_t v7 = a2;
    *(void *)(a1 + 48) = a2 + 8;
  }

  else
  {
    uint64_t v6 = *((void *)a2 + 2);
    if (v6) {
      *(void *)(v6 + 24) = *((void *)a2 + 3);
    }
    **((void **)a2 + 3) = v6;
    sub_100014004(a2, 96LL);
    --*(_DWORD *)(a1 + 16);
  }

uint64_t sub_1000302F8(int a1, dev_t *a2, _DWORD *a3, int *a4, dev_t *a5)
{
  if (a2)
  {
    v42.dev_t st_dev = -1431655766;
    if (ioctl(a1, 0x4004644CuLL, &v42))
    {
      if (*__error() != 25)
      {
        uint64_t v10 = __error();
        uint64_t v11 = strerror(*v10);
        sub_100013D94("%s:%d: can't get features for device (%s)\n", "io_get_device_features", 182, v11);
      }

      dev_t st_dev = 0;
    }

    else
    {
      dev_t st_dev = v42.st_dev;
    }

    *a2 = st_dev;
  }

  if (a3) {
    *a3 = (fcntl(a1, 3) & 3) != 0;
  }
  if (!a4) {
    goto LABEL_14;
  }
  v13.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v13.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v42.st_blksize = v13;
  *(timespec *)v42.st_qspare = v13;
  v42.st_birthtimespec = v13;
  *(timespec *)&v42.st_size = v13;
  v42.st_mtimespec = v13;
  v42.st_ctimespec = v13;
  *(timespec *)&v42.st_uid = v13;
  v42.st_atimespec = v13;
  *(timespec *)&v42.dev_t st_dev = v13;
  if (fstat(a1, &v42) || (v42.st_mode & 0xB000 | 0x4000) != 0x6000 || (CFMutableDictionaryRef v18 = IOServiceMatching("IOMedia")) == 0LL)
  {
LABEL_12:
    int v14 = 0;
    goto LABEL_13;
  }

  uint64_t v19 = v18;
  int v40 = v42.st_rdev & 0xFFFFFF;
  unsigned int valuePtr = HIBYTE(v42.st_rdev);
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFDictionarySetValue(v19, @"BSD Major", v20);
    CFRelease(v21);
  }

  CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v40);
  if (v22)
  {
    CFNumberRef v23 = v22;
    CFDictionarySetValue(v19, @"BSD Minor", v22);
    CFRelease(v23);
  }

  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v19);
  if (!MatchingService)
  {
    sub_100013CBC( "%s:%d: fd %d is type %o rdev %d (%d, %d): I/O registry entry not found\n",  "io_get_device_features",  230,  a1,  v42.st_mode & 0xF000,  v42.st_rdev,  HIBYTE(v42.st_rdev),  v42.st_rdev & 0xFFFFFF);
    goto LABEL_12;
  }

  io_object_t v25 = MatchingService;
  IOObjectRetain(MatchingService);
  iterator[0] = -1431655766;
  io_object_t v26 = v25;
  while (1)
  {
    io_registry_entry_t parent = -1431655766;
    if (IOObjectConformsTo(v26, "AppleAPFSContainerScheme")) {
      break;
    }
    if (IOObjectConformsTo(v26, "IOBlockStorageDevice")) {
      goto LABEL_43;
    }
    if (IORegistryEntryGetParentEntry(v26, "IOService", &parent)) {
      io_registry_entry_t parent = 0;
    }
    IOObjectRelease(v26);
    io_object_t v26 = parent;
    if (!parent)
    {
      int v14 = 0;
      goto LABEL_45;
    }
  }

  unint64_t v28 = (const __CFDictionary *)IORegistryEntrySearchCFProperty( v26,  "IOService",  @"Device Characteristics",  kCFAllocatorDefault,  3u);
  if (v28)
  {
    __int16 v29 = v28;
    Value = (const __CFBoolean *)CFDictionaryGetValue(v28, @"Target Disk Mode");
    if (Value)
    {
      int v31 = CFBooleanGetValue(Value);
      CFRelease(v29);
      if (v31)
      {
LABEL_43:
        int v14 = 0;
        goto LABEL_44;
      }
    }

    else
    {
      CFRelease(v29);
    }
  }

  if (IORegistryEntryGetParentIterator(v26, "IOService", iterator)) {
    goto LABEL_43;
  }
  while (1)
  {
    io_object_t v32 = IOIteratorNext(iterator[0]);
    if (!v32) {
      break;
    }
    io_registry_entry_t v33 = v32;
    if (sub_100030B50(v32, @"image-format-read-only"))
    {
      BOOL v34 = 0;
    }

    else
    {
      if (!sub_100030B50(v33, @"Removable"))
      {
        CFTypeRef v35 = IORegistryEntrySearchCFProperty( v33,  "IOService",  @"Protocol Characteristics",  kCFAllocatorDefault,  3u);
        if (v35)
        {
          uint64_t v36 = v35;
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(v36)) {
            goto LABEL_56;
          }
          unint64_t v38 = CFDictionaryGetValue((CFDictionaryRef)v36, @"Physical Interconnect Location");
          if (!v38) {
            goto LABEL_57;
          }
          CFTypeID v39 = CFStringGetTypeID();
          if (v39 == CFGetTypeID(v38)) {
            LODWORD(v38) = CFEqual(v38, @"Internal") == 0;
          }
          else {
LABEL_56:
          }
            LODWORD(v38) = 0;
LABEL_57:
          CFRelease(v36);
        }

        else
        {
          LODWORD(v38) = 0;
        }

        BOOL v34 = (_DWORD)v38 != 0;
        goto LABEL_60;
      }

      BOOL v34 = 1;
    }

LABEL_60:
    IOObjectRelease(v33);
    if (v34)
    {
      int v14 = 1;
      goto LABEL_63;
    }
  }

  int v14 = 0;
LABEL_63:
  IOObjectRelease(iterator[0]);
LABEL_44:
  IOObjectRelease(v26);
LABEL_45:
  IOObjectRelease(v25);
LABEL_13:
  *a4 = v14;
LABEL_14:
  if (a5)
  {
    v42.dev_t st_dev = -1431655766;
    if (ioctl(a1, 0x4004644FuLL, &v42))
    {
      if (*__error() != 25)
      {
        uint64_t v15 = __error();
        uint64_t v16 = strerror(*v15);
        sub_100013D94("%s:%d: can't get solidstate for device (%s)\n", "io_get_device_features", 246, v16);
      }

      dev_t v17 = 1;
    }

    else
    {
      dev_t v17 = v42.st_dev;
    }

    *a5 = v17;
  }

  return 0LL;
}

                  LODWORD(v8) = v73;
                  goto LABEL_8;
                }

                dev_t v17 = 45LL;
                strerror(45);
                sub_100013D94("%s:%d: Fusion creation failed: %d - %s\n");
              }
            }
          }

    BOOL v34 = a2 == 0;
    CFTypeRef v35 = a1[2];
    uint64_t v36 = (v35 & 0xC00000000LL) != 0;
    if ((v35 & 0x800000000LL) != 0) {
      unint64_t v37 = 113;
    }
    else {
      unint64_t v37 = 105;
    }
    uint64_t v19 = v34 && v36;
    if (v34 && v36) {
      unint64_t v38 = v37;
    }
    else {
      unint64_t v38 = 72;
    }
    if ((v35 & 0x10000000) != 0)
    {
      __int128 v49 = 0LL;
    }

    else
    {
      if (*((_WORD *)a1 + 18) == 11 || *((_WORD *)a1 + 20) == 11) {
        CFTypeID v39 = 2LL;
      }
      else {
        CFTypeID v39 = 1LL;
      }
      __int128 v49 = v39;
    }

    int v40 = sub_100048020((void *)v6, v38, v12, a3, (unint64_t *)&v49, 0LL);
    if ((_DWORD)v40)
    {
      unint64_t v7 = v40;
      if (sub_100013538(*(void *)(*(void *)v6 + 392LL)))
      {
        if (*(_WORD *)(v6 + 36) == 13) {
          uint64_t v41 = (const char *)(v6 + 3992);
        }
        else {
          uint64_t v41 = (const char *)(*(void *)(v6 + 384) + 208LL);
        }
        sub_100013D94( "%s:%d: %s oid %lld flags 0x%llx 0x%x type 0x%x/0x%x xid %lld (cur xid %lld) error allocating space to write %d ; blkcount %d (o_size_phys %d) paddr %lld\n",
          "obj_write_prepare",
          6460,
          v41,
          a1[14],
          a1[2],
          *((_DWORD *)a1 + 8),
          *((_DWORD *)a1 + 9),
          *((_DWORD *)a1 + 10),
          a1[18],
          a3,
          v7,
          v47,
          *((_DWORD *)a1 + 12),
          v49);
      }

      CFMutableDictionaryRef v18 = 0LL;
      uint64_t v19 = 0;
      goto LABEL_100;
    }

    if (a1[1]) {
      sub_10001AAE8();
    }
    uint64_t v16 = v48;
    CFMutableDictionaryRef v18 = v49;
    io_registry_entry_t v33 = v49;
    if (v49)
    {
LABEL_81:
      __int128 v49 = v33;
      stat v42 = a1[2];
      int v43 = (v42 >> 2) & 0x700 | (v42 >> 8) & 0xE0 | 4;
      if ((v42 & 0x10000000) == 0) {
        int v43 = 0;
      }
      if (v13) {
        int v44 = v13;
      }
      else {
        int v44 = v16;
      }
      uint64_t v45 = sub_100041220(v6, a1[14], v44, v33, *((_DWORD *)a1 + 12), v43 | (v42 >> 26) & 8, a3);
      if (!(_DWORD)v45)
      {
        uint64_t v16 = v48;
        goto LABEL_12;
      }

      unint64_t v7 = v45;
      if (sub_100013538(*(void *)(*(void *)v6 + 392LL)))
      {
        if (*(_WORD *)(v6 + 36) == 13) {
          __int16 v46 = (const char *)(v6 + 3992);
        }
        else {
          __int16 v46 = (const char *)(*(void *)(v6 + 384) + 208LL);
        }
        sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error setting mapping for write %d\n",  "obj_write_prepare",  6491,  v46,  a1[14],  a1[2],  *((_DWORD *)a1 + 8),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 10),  v7);
      }

      if (!a2)
      {
LABEL_20:
        pthread_mutex_lock((pthread_mutex_t *)*a1);
        if (v18) {
          a1[19] = v18;
        }
        if (!v19) {
          goto LABEL_24;
        }
LABEL_23:
        a1[2] &= 0xFFFFFFF3FFFFFFFFLL;
LABEL_24:
        if (!(_DWORD)v7)
        {
          io_object_t v25 = a1[2];
          if ((v25 & 0x40) != 0) {
            a1[2] = v25 & 0xFFFFFFFFFFFFFFBFLL;
          }
          if (v13) {
            a1[15] = v13;
          }
          io_object_t v26 = a1[19];
          if (v26) {
            a1[16] = v26;
          }
          uint64_t v27 = (unsigned int *)(a1 + 4);
          do
            unint64_t v28 = __ldxr(v27);
          while (__stxr(v28, v27));
          if ((v28 & 1) == 0)
          {
            *int v14 = 0LL;
            v14[1] = 0LL;
          }
        }

        sub_100036F84(*a1);
        if (v17)
        {
          if (v13)
          {
            if (sub_10004144C(v6, a1[14], v48, v17, *((_DWORD *)a1 + 12), 0, a3)
              && sub_100013538(*(void *)(*(void *)v6 + 392LL)))
            {
              sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error deleting old mapping %d\n",  "obj_write_prepare");
            }
          }

          else if (sub_10004BD08((const char *)v6, 0LL, v17, v47, a3) {
                 && sub_100013538(*(void *)(*(void *)v6 + 392LL)))
          }
          {
            sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old location %d\n",  "obj_write_prepare");
          }
        }

        return v7;
      }

uint64_t sub_1000307C0(char *__s2, char *a2, char *a3, size_t a4, char **a5)
{
  if (!strncmp("/dev/", __s2, 5uLL)) {
    uint64_t v10 = 5LL;
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = &__s2[v10];
  if (!strncmp(&__s2[v10], "disk", 4uLL))
  {
    uint64_t result = snprintf(a2, a4, "%s%s", "/dev/", v11);
    if (a3) {
      uint64_t result = snprintf(a3, a4, "%sr%s");
    }
    goto LABEL_14;
  }

  if (!strncmp(v11, "rdisk", 5uLL))
  {
    uint64_t result = snprintf(a2, a4, "%s%s", "/dev/", v11 + 1);
    if (a3) {
      uint64_t result = snprintf(a3, a4, "%s%s");
    }
LABEL_14:
    if (!a5) {
      return result;
    }
    a2 += 5;
    goto LABEL_16;
  }

  uint64_t result = strlcpy(a2, __s2, a4);
  if (a3) {
    uint64_t result = strlcpy(a3, __s2, a4);
  }
  if (a5) {
LABEL_16:
  }
    *a5 = a2;
  return result;
}

unint64_t sub_100030900(const char *a1, _DWORD *a2)
{
  if (!sub_100030980(a1)) {
    return 0LL;
  }
  unint64_t result = (unint64_t)strrchr(a1, 115);
  if (result)
  {
    unint64_t v5 = result;
    unint64_t result = strtoul((const char *)(result + 1), 0LL, 10);
    if (result)
    {
      int v6 = result;
      unint64_t result = (unint64_t)strndup(a1, v5 - (void)a1);
      if (result)
      {
        if (a2) {
          *a2 = v6 - 1;
        }
      }
    }
  }

  return result;
}

BOOL sub_100030980(const char *a1)
{
  int v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114) {
      ++v1;
    }
  }

  int v3 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v3);
  if (!MatchingService) {
    return 0LL;
  }
  io_object_t v5 = MatchingService;
  BOOL v6 = IOObjectConformsTo(MatchingService, "AppleAPFSVolume") != 0;
  IOObjectRelease(v5);
  return v6;
}

uint64_t sub_100030A14(io_registry_entry_t *a1, const char *a2)
{
  io_iterator_t iterator = -1431655766;
  if (IORegistryEntryGetChildIterator(*a1, "IOService", &iterator)) {
    return 0LL;
  }
  io_object_t v4 = IOIteratorNext(iterator);
  if (!v4)
  {
LABEL_6:
    IOObjectRelease(iterator);
    return 0LL;
  }

  io_object_t v5 = v4;
  while (!IOObjectConformsTo(v5, a2))
  {
    IOObjectRelease(v5);
    io_object_t v5 = IOIteratorNext(iterator);
    if (!v5) {
      goto LABEL_6;
    }
  }

  IOObjectRelease(iterator);
  IOObjectRelease(*a1);
  *a1 = v5;
  return 1LL;
}

uint64_t sub_100030AC4(const char *a1, int a2)
{
  io_object_t v4 = strrchr(a1, 115);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    io_object_t v5 = v4 - 1;
    while (v5 > a1)
    {
      int v7 = *v5--;
      char v6 = v7;
      if ((v7 - 48) >= 0xA)
      {
        if (v6 != 115) {
          return 0xFFFFFFFFLL;
        }
        io_object_t v4 = (char *)(v5 + 1);
        goto LABEL_8;
      }
    }

    return 0xFFFFFFFFLL;
  }

BOOL sub_100030B50(io_registry_entry_t a1, CFStringRef key)
{
  CFBooleanRef v2 = (CFBooleanRef)IORegistryEntrySearchCFProperty(a1, "IOService", key, kCFAllocatorDefault, 3u);
  if (!v2) {
    return 0LL;
  }
  BOOL v3 = v2 == kCFBooleanTrue;
  CFRelease(v2);
  return v3;
}

uint64_t sub_100030BB0(uint64_t a1, unint64_t a2)
{
  uint64_t v25 = 0LL;
  if (*(_BYTE *)(a1 + 639))
  {
    sub_100013CBC( "%s:%d: %s Skipping metazone_init() as backing store is sparse\n",  "spaceman_metazone_init",  72,  (const char *)(*(void *)(a1 + 384) + 208LL));
    return 0LL;
  }

  memset(v26, 170, sizeof(v26));
  uint64_t v2 = sub_100044238((void *)a1, &v25);
  if ((_DWORD)v2) {
    return v2;
  }
  io_object_t v4 = (uint64_t *)v25;
  if (!v25) {
    return 19LL;
  }
  if (!*(void *)(v25 + 376))
  {
    uint64_t v2 = 19LL;
    goto LABEL_11;
  }

  if (*(_BYTE *)(v25 + 1104) || *(_BYTE *)(v25 + 1208))
  {
    uint64_t v2 = 0LL;
LABEL_11:
    sub_100038824(v4);
    return v2;
  }

  uint64_t v6 = 0LL;
  char v7 = 1;
  do
  {
    char v8 = v7;
    uint64_t v9 = v25;
    uint64_t v10 = v25 + 104 * v6;
    *(_OWORD *)(v10 + 1008) = 0u;
    *(_OWORD *)(v10 + 1024) = 0u;
    *(_OWORD *)(v10 + 1040) = 0u;
    *(_OWORD *)(v10 + 1056) = 0u;
    *(_OWORD *)(v10 + 1072) = 0u;
    *(_OWORD *)(v10 + 1088) = 0u;
    *(void *)(v10 + 1104) = 0LL;
    uint64_t v11 = *(void *)(v9 + 376);
    unint64_t v12 = *(unsigned int *)(v11 + 32);
    unint64_t v13 = *(void *)(v11 + 48 * v6 + 48);
    if (is_mul_ok(v13, v12)) {
      unint64_t v14 = v13 * v12;
    }
    else {
      unint64_t v14 = 0x40000000000LL;
    }
    if (!sub_1000140FC(a2, v12, v13, v14, &v26[2], &v26[1]))
    {
      uint64_t v15 = v9 + 104 * v6;
      unint64_t v16 = v26[1] + v26[2] / v12;
      sub_100014204(v12, v26[2], v26[1], v16, v26, 0LL);
      *(void *)(v15 + 1008) = v26[1];
      *(void *)(v15 + 1024) = v26[1];
      *(void *)(v15 + 1016) = v26[0];
      *(_BYTE *)(v15 + 1034) = 1;
      *(void *)(v15 + 1040) = v26[0];
      *(void *)(v15 + 1056) = v26[0];
      *(void *)(v15 + 1048) = v16;
      *(_BYTE *)(v15 + 1066) = 1;
      *(_BYTE *)(v15 + 1105) = 1;
      uint64_t v17 = v25;
      uint64_t v18 = v25 + 8 * v6;
      unint64_t v19 = *(void *)(v18 + 992);
      if (v19 < v16 && v19 >= v26[1])
      {
        if (v16 == v13) {
          unint64_t v21 = 0LL;
        }
        else {
          unint64_t v21 = v16;
        }
        *(void *)(v18 + 992) = v21;
      }

      if (*(void *)(v18 + 1488))
      {
        unint64_t v22 = *(unsigned int *)(*(void *)(v17 + 376) + 36LL);
        unint64_t v23 = v26[1] / v22;
        unint64_t v24 = (v16 - 1) / v22;
        if (v23 <= v24)
        {
          do
            *(_DWORD *)(*(void *)(v25 + 8 * v6 + 1488) + 4 * v23++) |= 0x4000000u;
          while (v23 <= v24);
          uint64_t v17 = v25;
        }
      }

      *(_BYTE *)(v17 + 104 * v6 + 1104) = 1;
    }

    char v7 = 0;
    uint64_t v6 = 1LL;
  }

  while ((v8 & 1) != 0);
  uint64_t v2 = 0LL;
  io_object_t v4 = (uint64_t *)v25;
  if (v25) {
    goto LABEL_11;
  }
  return v2;
}

uint64_t sub_100030E0C(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = (a3 << __clz(__rbit64(*(unsigned int *)(*(void *)(result + 376) + 36LL))) >> 62) & 1;
  uint64_t v4 = a2 + 104LL * v3;
  if (*(_BYTE *)(v4 + 1104) && *(_BYTE *)(a2 + 104LL * v3 + 1105))
  {
    io_object_t v5 = (unint64_t *)(v4 + 1008);
    if (*v5 <= a3 && v5[1] > a3)
    {
      unint64_t v7 = v5[2];
      uint64_t v6 = v5 + 2;
      if (v7 <= a3) {
        return result;
      }
LABEL_15:
      *uint64_t v6 = a3;
      return result;
    }

    if (*(void *)(a2 + 104LL * v3 + 1040) > a3
      || *(void *)(a2 + 104LL * v3 + 1048) <= a3)
    {
      if (*(void *)(a2 + 104LL * v3 + 1072) <= a3
        && *(void *)(a2 + 104LL * v3 + 1080) > a3)
      {
        uint64_t v9 = a2 + 104LL * v3;
        if (*(void *)(v9 + 1088) > a3)
        {
          uint64_t v6 = (unint64_t *)(v9 + 1088);
          goto LABEL_15;
        }
      }
    }

    else
    {
      uint64_t v8 = a2 + 104LL * v3;
      if (*(void *)(v8 + 1056) > a3)
      {
        uint64_t v6 = (unint64_t *)(v8 + 1056);
        goto LABEL_15;
      }
    }
  }

  return result;
}

uint64_t sub_100030EFC(uint64_t result, unsigned int a2, int a3, unint64_t a4)
{
  if (a3 == 2)
  {
    uint64_t v9 = result + 104LL * a2;
    io_object_t v5 = (unint64_t *)(v9 + 1072);
    uint64_t v6 = (unint64_t *)(v9 + 1080);
    unint64_t v7 = (unint64_t *)(v9 + 1088);
    uint64_t v8 = (__int16 *)(v9 + 1096);
  }

  else if (a3 == 1)
  {
    uint64_t v10 = result + 104LL * a2;
    io_object_t v5 = (unint64_t *)(v10 + 1040);
    uint64_t v6 = (unint64_t *)(v10 + 1048);
    unint64_t v7 = (unint64_t *)(v10 + 1056);
    uint64_t v8 = (__int16 *)(v10 + 1064);
  }

  else
  {
    if (a3) {
      return result;
    }
    uint64_t v4 = result + 104LL * a2;
    io_object_t v5 = (unint64_t *)(v4 + 1008);
    uint64_t v6 = (unint64_t *)(v4 + 1016);
    unint64_t v7 = (unint64_t *)(v4 + 1024);
    uint64_t v8 = (__int16 *)(v4 + 1032);
  }

  unint64_t v11 = *v5;
  if (v11 <= a4 && *v6 > a4)
  {
    *unint64_t v7 = a4;
LABEL_18:
    __int16 *v8 = 0;
    return result;
  }

  if (*v7 == v11)
  {
    *unint64_t v7 = a4;
    __int16 v12 = 1;
  }

  else
  {
    if (*v8 < 0)
    {
      *unint64_t v7 = v11;
      goto LABEL_18;
    }

    __int16 v13 = *v8;
    if (!*v8)
    {
      *unint64_t v7 = v11;
      return result;
    }

    *unint64_t v7 = a4;
    __int16 v12 = v13 + 1;
  }

  __int16 *v8 = v12;
  return result;
}

uint64_t sub_100030FD0(void *a1, unsigned int a2, int a3)
{
  uint64_t v4 = a2;
  if (a3 == 2)
  {
    if (BYTE2(a1[13 * a2 + 137])) {
      uint64_t v5 = (uint64_t)&a1[13 * a2 + 136];
    }
    else {
      uint64_t v5 = (uint64_t)&a1[13 * a2 + 132];
    }
  }

  else if (a3 == 1)
  {
    uint64_t v5 = (uint64_t)&a1[13 * a2 + 132];
  }

  else if (a3)
  {
    uint64_t v6 = a1[1];
    if (v6) {
      unint64_t v7 = (const char *)(v6 + 3992);
    }
    else {
      unint64_t v7 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94( "%s:%d: %s tried to get metazone alloc index for unknown type: %d\n",  "spaceman_get_metazone_alloc_index",  348,  v7,  a3);
    uint64_t v5 = (uint64_t)&a1[v4 + 124];
  }

  else
  {
    uint64_t v5 = (uint64_t)&a1[13 * a2 + 128];
  }

  return *(void *)v5;
}

uint64_t sub_1000310A8(void *a1)
{
  uint64_t v18 = 0LL;
  uint64_t v2 = sub_100044238(a1, (uint64_t *)&v18);
  if (!(_DWORD)v2)
  {
    pthread_mutex_lock(v18 + 6);
    uint64_t v3 = v18;
    uint64_t v4 = *(_DWORD **)&v18[5].__opaque[48];
    if ((v4[36] & 1) == 0 || !v4[84])
    {
      int v5 = v4[29];
      if (!v5) {
        int v5 = v4[28];
      }
      uint64_t v6 = (v4[32] + 8 * v5);
      unsigned int v7 = v4[8];
      if ((int)v6 + 2184 <= (v6 + v7 - 1) / v7 * v7)
      {
        memmove(v4 + 630, v4 + 84, v6 - 336);
        uint64_t v10 = (v4[81] + 2184);
        v4[81] = v10;
        uint64_t v11 = (v4[82] + 2184);
        v4[82] = v11;
        uint64_t v12 = (v4[83] + 2184);
        v4[83] = v12;
        uint64_t v13 = (v4[20] + 2184);
        v4[20] = v13;
        uint64_t v14 = (v4[32] + 2184);
        v4[32] = v14;
        *(void *)&v3[13].__opaque[24] = (char *)v4 + v10;
        *(void *)&v3[13].__opaque[32] = (char *)v4 + v11;
        *(void *)&v3[13].__opaque[40] = (char *)v4 + v12;
        *(void *)&v3[13].__opaque[48] = (char *)v4 + v13;
        v3[14].__sig = (uint64_t)v4 + v14;
        *((void *)v4 + 42) = 0x9D800000001LL;
        bzero(v4 + 86, 0x880uLL);
        v4[36] |= 1u;
      }

      else
      {
        uint64_t v8 = *(void *)v18->__opaque;
        if (v8) {
          uint64_t v9 = (const char *)(v8 + 3992);
        }
        else {
          uint64_t v9 = (const char *)(*(void *)(*(void *)(v18->__sig + 392) + 384LL) + 208LL);
        }
        sub_100013CBC( "%s:%d: %s refusing to upgrade spaceman! new_smp_size %u old_smp_size %u block_size %u\n",  "spaceman_upgrade_sm_version_0_to_1",  398,  v9,  v6 + 2184,  v6,  v7);
        sub_100013D4C( "%s:%d: %s failed to upgrade spaceman from version 0 to 1: %d\n",  "spaceman_allocation_init",  456,  (const char *)(a1[48] + 208LL),  27);
      }
    }

    sub_100047FDC((uint64_t)a1, (uint64_t)v18);
    uint64_t v2 = sub_100030BB0((uint64_t)a1, 0LL);
    if (!(_DWORD)v2)
    {
      sub_1000312F4((const char *)v18);
      uint64_t v15 = 1LL;
      while (1)
      {
        uint64_t v16 = sub_100031554(a1, v15);
        if ((_DWORD)v16) {
          break;
        }
        if (++v15 == 5)
        {
          uint64_t v2 = sub_10002B770((uint64_t)a1, (uint64_t)v18);
          goto LABEL_18;
        }
      }

      uint64_t v2 = v16;
      sub_100013D94( "%s:%d: %s failed to initialize data zone for allocations of size %llu, error %d\n",  "spaceman_allocation_init",  491,  (const char *)(a1[48] + 208LL),  v15,  v16);
    }
  }

LABEL_18:
  if (v18)
  {
    pthread_mutex_unlock(v18 + 6);
    sub_100038824(&v18->__sig);
  }

  return v2;
}

    unint64_t v22 = v27;
    if ((v27 & 1) == 0)
    {
      if (a4) {
        *a4 = v28;
      }
      if (a5) {
        *a5 = HIDWORD(v27);
      }
      if (a6)
      {
        *a6 = v22 & 0xFFFFFFEF;
        if (((*(_DWORD *)(*((void *)v32 + 47) + 32LL) ^ v22) & 0x10) != 0) {
          *a6 = v22 | 0x10;
        }
      }

      if (a7) {
        *a7 = v30;
      }
      if (*((void *)v32 + 53))
      {
        sub_1000419D8((uint64_t)v32, a2, v11, &v24);
        uint64_t v14 = 0LL;
        uint64_t v16 = v24 == 0;
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      goto LABEL_31;
    }

    goto LABEL_30;
  }

  return v14;
}

const char *sub_1000312F4(const char *result)
{
  if (result)
  {
    int v1 = result;
    uint64_t v24 = *((void *)result + 47);
    if ((*(_BYTE *)(v24 + 144) & 1) != 0)
    {
      if (*(_DWORD *)(v24 + 336))
      {
        uint64_t v2 = 0LL;
        uint64_t v3 = v24 + 344;
        char v4 = 1;
        do
        {
          char v25 = v4;
          unint64_t v5 = *(void *)(v24 + 48 * v2 + 48);
          if (v5)
          {
            uint64_t v6 = 0LL;
            uint64_t v7 = v24 + 368 + 1088 * v2;
            do
            {
              uint64_t v8 = v3 + 1088 * v2 + 136 * v6;
              if (*(void *)v8 >= v5
                || ((unint64_t v9 = *(void *)(v8 + 8), v9 <= v5) ? (v10 = *(void *)v8 > v9) : (v10 = 1), v10))
              {
                uint64_t v11 = *((void *)v1 + 1);
                if (v11) {
                  uint64_t v12 = (const char *)(v11 + 3992);
                }
                else {
                  uint64_t v12 = (const char *)(*(void *)(*(void *)(*(void *)v1 + 392LL) + 384LL) + 208LL);
                }
                unint64_t result = sub_100013D4C( "%s:%d: %s Persistent allocation zone at slot %llu has invalid current boundaries\n",  "spaceman_sanitize_datazone",  676,  v12,  v6);
                char v13 = 1;
              }

              else
              {
                char v13 = 0;
              }

              uint64_t v14 = 0LL;
              uint64_t v15 = (unint64_t *)v7;
              while (1)
              {
                unint64_t v16 = *(v15 - 1);
                if (v16 >= v5) {
                  break;
                }
                if (*v15 > v5 || v16 > *v15) {
                  break;
                }
                ++v14;
                v15 += 2;
                if (v14 == 7)
                {
                  if (*(unsigned __int16 *)(v3 + 1088 * v2 + 136 * v6 + 130) <= 6u)
                  {
                    if ((v13 & 1) == 0) {
                      goto LABEL_39;
                    }
                    goto LABEL_35;
                  }

LABEL_31:
                  uint64_t v20 = *((void *)v1 + 1);
                  if (v20) {
                    unint64_t v21 = (const char *)(v20 + 3992);
                  }
                  else {
                    unint64_t v21 = (const char *)(*(void *)(*(void *)(*(void *)v1 + 392LL) + 384LL) + 208LL);
                  }
                  sub_100013D4C( "%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary index\n",  "spaceman_sanitize_datazone",  695,  v21,  v6);
                  goto LABEL_35;
                }
              }

              uint64_t v18 = *((void *)v1 + 1);
              if (v18) {
                unint64_t v19 = (const char *)(v18 + 3992);
              }
              else {
                unint64_t v19 = (const char *)(*(void *)(*(void *)(*(void *)v1 + 392LL) + 384LL) + 208LL);
              }
              sub_100013D4C( "%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary %llu\n",  "spaceman_sanitize_datazone",  686,  v19,  v6,  v14);
LABEL_35:
              uint64_t v22 = *((void *)v1 + 1);
              if (v22) {
                unint64_t v23 = (const char *)(v22 + 3992);
              }
              else {
                unint64_t v23 = (const char *)(*(void *)(*(void *)(*(void *)v1 + 392LL) + 384LL) + 208LL);
              }
              unint64_t result = sub_100013D4C( "%s:%d: %s Clearing persistent allocation zone at slot %llu\n",  "spaceman_sanitize_datazone",  701,  v23,  v6);
              *(void *)(v8 + 128) = 0LL;
              *(_OWORD *)(v8 + 96) = 0u;
              *(_OWORD *)(v8 + 112) = 0u;
              *(_OWORD *)(v8 + 64) = 0u;
              *(_OWORD *)(v8 + 80) = 0u;
              *(_OWORD *)(v8 + 32) = 0u;
              *(_OWORD *)(v8 + 48) = 0u;
              *(_OWORD *)uint64_t v8 = 0u;
              *(_OWORD *)(v8 + 16) = 0u;
LABEL_39:
              ++v6;
              v7 += 136LL;
            }

            while (v6 != 8);
          }

          char v4 = 0;
          uint64_t v2 = 1LL;
        }

        while ((v25 & 1) != 0);
      }
    }
  }

  return result;
}

  if ((*(void *)(v23 + 16) & 0x80020000000LL) == 0)
  {
    int v43 = *(void *)(v23 + 56);
    if (*(_DWORD *)(v43 + 24) != *(_DWORD *)(v23 + 36)
      || *(_DWORD *)(v43 + 28) != *(_DWORD *)(v23 + 40)
      || *(void *)(v43 + 8) != a3
      || *(void *)(v43 + 16) != a8)
    {
      char v13 = sub_100005194(*(void *)a1[6].__opaque);
      if ((_DWORD)v13) {
        goto LABEL_53;
      }
    }
  }

  unint64_t v37 = (uint64_t *)(a1[11].__sig + 8 * (*(void *)(v23 + 112) & *(unsigned int *)&a1[10].__opaque[52]));
  unint64_t v38 = *v37;
  *(void *)(v23 + 72) = *v37;
  if (v38) {
    *(void *)(v38 + 80) = v23 + 72;
  }
  *unint64_t v37 = v23;
  *(void *)(v23 + 80) = v37;
  CFTypeID v39 = *(void *)(v23 + 16) | 1LL;
  *(void *)(v23 + 88) = 0LL;
  *(void *)(v23 + 16) = v39;
  int v40 = *(uint64_t **)&a1[11].__opaque[32];
  *(void *)(v23 + 96) = v40;
  *int v40 = v23;
  *(void *)&a1[11].__opaque[32] = v23 + 88;
  uint64_t v41 = sub_10003AE68(*(_DWORD *)(v23 + 36), &v49);
  if ((_DWORD)v41)
  {
    char v13 = v41;
LABEL_36:
    sub_100036F1C((uint64_t)a1, v39, *(_DWORD *)(v23 + 48), -1);
    do
      stat v42 = __ldxr(v24);
    while (__stxr(v42 - 1, v24));
LABEL_55:
    sub_10003CCD4(v23, 0);
LABEL_56:
    sub_100036F84((uint64_t)a1);
  }

  else
  {
    int v44 = *(uint64_t (**)(uint64_t, void))(v49 + 8);
    if (v44)
    {
      uint64_t v45 = v44(v23, 0LL);
      if ((_DWORD)v45)
      {
        char v13 = v45;
        CFTypeID v39 = *(void *)(v23 + 16);
        goto LABEL_36;
      }
    }

    sub_10003AE20(v23, v47);
    sub_100036F84((uint64_t)a1);
    char v13 = 0LL;
    *a9 = v23;
  }

  return v13;
}

    uint64_t v11 = 0LL;
    goto LABEL_32;
  }

  uint64_t v11 = sub_10003CF9C(a1, 0LL, a3);
  if (!(_DWORD)v11)
  {
    a2 = a2 | 2;
    goto LABEL_9;
  }

  return v11;
}

  if (v6 && *(_BYTE *)(v6 + 62))
  {
    unint64_t v21 = *(void *)(v6 + 48) + v14;
    *(void *)(v6 + 40) += v15;
    *(void *)(v6 + 48) = v21;
  }

  return v14;
}

uint64_t sub_100031554(void *a1, uint64_t a2)
{
  uint64_t v12 = 0LL;
  uint64_t v4 = sub_100044238(a1, (uint64_t *)&v12);
  if ((_DWORD)v4) {
    return v4;
  }
  if (!v12) {
    return 19LL;
  }
  uint64_t v6 = v12[47];
  if (!v6)
  {
    uint64_t v4 = 19LL;
    goto LABEL_15;
  }

  if ((unint64_t)(a2 - 5) < 0xFFFFFFFFFFFFFFFCLL)
  {
    uint64_t v4 = 22LL;
    goto LABEL_15;
  }

  uint64_t v7 = v12 + 152;
  uint64_t v8 = &v12[4 * a2 + 148];
  if (*((_BYTE *)v8 + 24)) {
    goto LABEL_14;
  }
  unint64_t v9 = *(void *)(v6 + 56);
  if (!*((_BYTE *)v12 + 1104) || v9 < 8) {
    goto LABEL_14;
  }
  *((_BYTE *)v12 + 1344) = 1;
  *(_OWORD *)uint64_t v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  uint64_t v11 = sub_1000316C4(v12, 0, a2);
  if ((_DWORD)v11)
  {
    uint64_t v4 = v11;
    sub_100013D94( "%s:%d: %s failed to initialize allocation zone for allocations of %llu blocks from disk: error %d\n",  "spaceman_datazone_init",  600,  (const char *)(a1[48] + 208LL),  a2,  v11);
  }

  else
  {
    if (BYTE1(v7[4 * a2 - 1]))
    {
LABEL_14:
      uint64_t v4 = 0LL;
      goto LABEL_15;
    }

    sub_100013CBC( "%s:%d: %s allocation zone on dev %d for allocations of %llu blocks starting at paddr %llu\n",  "spaceman_datazone_init",  611,  (const char *)(a1[48] + 208LL),  0,  a2,  *v8);
    uint64_t v4 = 0LL;
    *((_BYTE *)v8 + 24) = 1;
  }

LABEL_15:
  if (v12) {
    sub_100038824(v12);
  }
  return v4;
}

uint64_t sub_1000316C4(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = 22LL;
  if (a1)
  {
    unsigned __int16 v4 = a3;
    if ((unint64_t)(a3 - 5) >= 0xFFFFFFFFFFFFFFFCLL)
    {
      uint64_t v6 = a3 - 1;
      uint64_t v7 = (uint64_t)&a1[17 * a2 + 152];
      uint64_t v8 = a1[47];
      if ((*(_BYTE *)(v8 + 144) & 1) != 0 && *(_DWORD *)(v8 + 336))
      {
        uint64_t v9 = v8 + 344;
        int v10 = v4;
        uint64_t v11 = -1LL;
        char v12 = 1;
        uint64_t v13 = 8LL;
        char v14 = v6;
        do
        {
          uint64_t v15 = v14 & 7;
          int v16 = *(unsigned __int16 *)(v9 + 1088LL * a2 + 136LL * v15 + 128);
          if (v16 == v10)
          {
            uint64_t v20 = (void *)(v9 + 1088LL * a2 + 136LL * v15);
            *(void *)(v7 + 32 * v6 + 16) = v20;
            uint64_t v21 = sub_1000318E0((uint64_t)a1, a2, v6, *v20 / (unint64_t)*(unsigned int *)(v8 + 36));
            uint64_t v3 = v21;
            if ((_DWORD)v21)
            {
              uint64_t v22 = a1[1];
              if (v22) {
                unint64_t v23 = (const char *)(v22 + 3992);
              }
              else {
                unint64_t v23 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
              }
              sub_100013D94( "%s:%d: %s failed to update allocation zone boundaries: error %d\n",  "spaceman_initialize_allocation_zone_from_disk",  965,  v23,  v21);
            }

            return v3;
          }

          if (v11 == -1 && v16 == 0) {
            uint64_t v11 = v15;
          }
          char v14 = v15 + 1;
          --v13;
        }

        while (v13);
        if ((v12 & 1) != 0) {
          goto LABEL_17;
        }
        uint64_t v3 = 0LL;
        uint64_t v18 = v7 + 32 * v6;
        *(void *)(v18 + 16) = v9 + 1088LL * a2 + 136 * v11;
        *(_BYTE *)(v18 + 25) = 1;
      }

      else
      {
LABEL_17:
        uint64_t v3 = 0LL;
        *(_WORD *)(v7 + 32 * v6 + 25) = 257;
      }
    }
  }

  return v3;
}

void sub_100031844(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    char v3 = 1;
    do
    {
      char v4 = v3;
      if (*(_BYTE *)(a1 + 136 * v2 + 1344))
      {
        uint64_t v5 = 0LL;
        uint64_t v6 = a1 + 136 * v2;
        do
        {
          uint64_t v7 = v6 + v5;
          if (*(_BYTE *)(v6 + v5 + 1240) && *(_BYTE *)(v7 + 1242))
          {
            uint64_t v8 = *(void **)(v6 + v5 + 1232);
            if (v8)
            {
              *(_BYTE *)(v7 + 1240) = 0;
              sub_100014004(v8, 136LL);
              *(void *)(v6 + v5 + 1232) = 0LL;
            }
          }

          v5 += 32LL;
        }

        while (v5 != 128);
      }

      char v3 = 0;
      uint64_t v2 = 1LL;
    }

    while ((v4 & 1) != 0);
  }

uint64_t sub_1000318E0(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  if (!a1) {
    return 22LL;
  }
  uint64_t v6 = *(void *)(a1 + 376);
  unint64_t v7 = *(void *)(v6 + 48LL * a2 + 56);
  if (v7 <= a4) {
    return 22LL;
  }
  uint64_t v8 = a2;
  uint64_t v9 = v6 + 48LL * a2;
  uint64_t v10 = a1 + 136LL * a2;
  uint64_t v11 = v10 + 1216;
  uint64_t v12 = v10 + 1216 + 32 * a3;
  uint64_t v13 = *(unsigned __int16 **)(v12 + 16);
  unint64_t v14 = *(unsigned int *)(v6 + 36);
  unint64_t v15 = *(void *)(v9 + 48);
  unint64_t v16 = *(void *)v12;
  if (*(_BYTE *)(v12 + 26)) {
    BOOL v17 = v13 == 0LL;
  }
  else {
    BOOL v17 = 0;
  }
  if (v17)
  {
    uint64_t v30 = v10 + 1216;
    uint64_t v18 = a3;
    uint64_t v13 = (unsigned __int16 *)sub_100013EEC(1uLL, 0x88uLL);
    a3 = v18;
    uint64_t v11 = v30;
    *(void *)(v12 + 16) = v13;
    if (!v13) {
      return 12LL;
    }
  }

  if (*(_BYTE *)(v12 + 24))
  {
    uint64_t v19 = 0LL;
    uint64_t v20 = v13[65];
    while (1)
    {
      uint64_t v21 = ((unint64_t)(v20 + v19) * (unsigned __int128)0x2492492492492493uLL) >> 64;
      uint64_t v22 = v20 + v19 - 7 * ((v21 + ((unint64_t)(v20 + v19 - v21) >> 1)) >> 2);
      unint64_t v23 = &v13[8 * v22];
      if (*((void *)v23 + 3))
      {
      }

      if (++v19 == 7) {
        goto LABEL_19;
      }
    }

    if (v22 == v20)
    {
LABEL_19:
      *(_OWORD *)&v13[8 * v20 + 8] = *(_OWORD *)v12;
      v13[65] = v20
              + 1
              - 7
      goto LABEL_20;
    }

    do
    {
      if (v22 == 6) {
        uint64_t v27 = 0LL;
      }
      else {
        uint64_t v27 = v22 + 1;
      }
      *(_OWORD *)&v13[8 * v22 + 8] = *(_OWORD *)&v13[8 * v27 + 8];
      uint64_t v22 = v27;
    }

    while (v27 != v20);
    uint64_t v28 = v20 - 1;
    BOOL v17 = (_DWORD)v20 == 0;
    uint64_t v29 = 6LL;
    if (!v17) {
      uint64_t v29 = v28;
    }
    *(_OWORD *)&v13[8 * v29 + 8] = *(_OWORD *)v12;
  }

uint64_t sub_100031B20(uint64_t result, unsigned int a2)
{
  if (result)
  {
    if (*(_BYTE *)(result + 136LL * a2 + 1344))
    {
      uint64_t v2 = 0LL;
      uint64_t v3 = result + 136LL * a2;
      uint64_t result = 4LL;
      do
      {
        if (*(_BYTE *)(v3 + v2 + 1240) || !*(_BYTE *)(v3 + v2 + 1241)) {
          uint64_t result = (result - 1);
        }
        v2 += 32LL;
      }

      while (v2 != 128);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100031B7C(void *a1, unsigned int a2, unint64_t a3, _BYTE *a4)
{
  if (!a1 || !LOBYTE(a1[17 * a2 + 168]) || *(void *)(a1[47] + 48LL * a2 + 56) <= a3) {
    return 22LL;
  }
  unint64_t v8 = 0LL;
  for (char i = (char *)&a1[17 * a2 + 155] + 1; ; i += 32)
  {
    if (!*(i - 1) && *i)
    {
      int v10 = *(_DWORD *)(a1[a2 + 186] + 4 * a3);
      int v11 = v10 & 0xC000000;
      unint64_t v12 = *(void *)&v10 & 0xFFFFFFLL;
      if (!v11 && v8 < v12) {
        break;
      }
    }

    if (++v8 == 4) {
      return 0LL;
    }
  }

  uint64_t v16 = sub_1000318E0((uint64_t)a1, a2, v8, a3);
  uint64_t v17 = a1[1];
  if ((_DWORD)v16)
  {
    uint64_t v14 = v16;
    if (v17) {
      uint64_t v18 = (const char *)(v17 + 3992);
    }
    else {
      uint64_t v18 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94( "%s:%d: %s failed to assign chunk %llu to allocation zone %llu\n",  "spaceman_evaluate_chunk_for_disabled_allocation_zones",  1135,  v18,  a3,  v8);
  }

  else
  {
    if (v17) {
      uint64_t v19 = (const char *)(v17 + 3992);
    }
    else {
      uint64_t v19 = (const char *)(*(void *)(*(void *)(*a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013CBC( "%s:%d: %s allocation zone on dev %d for allocations of %llu blocks starting at paddr %llu\n",  "spaceman_evaluate_chunk_for_disabled_allocation_zones",  1140,  v19,  a2,  v8 + 1,  *(void *)(i - 25));
    uint64_t v14 = 0LL;
    *(i - 1) = 1;
    *a4 = 1;
  }

  return v14;
}

uint64_t sub_100031D18(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v4 = 22LL;
  if (a1)
  {
    uint64_t v5 = a2;
    if (a2)
    {
      if (a3 <= 1 && a4 <= 3)
      {
        unint64_t v7 = *(unsigned int **)(a2 + 376);
        memset(v75, 170, 32);
        uint64_t v73 = 0LL;
        uint64_t v74 = 0LL;
        uint64_t v8 = a3;
        uint64_t v9 = a2 + 136LL * a3 + 32 * a4;
        unint64_t v10 = *(void *)(v9 + 1216);
        unint64_t v11 = v7[9];
        uint64_t v12 = *(void *)(v9 + 1232);
        unint64_t v13 = *(void *)&v7[12 * a3 + 14];
        if (!v12) {
          goto LABEL_14;
        }
        uint64_t v14 = *(unsigned __int16 *)(v12 + 130);
        uint64_t v15 = 7LL;
        while (1)
        {
          unint64_t v16 = *(void *)(v12 + 16 * v14 + 24);
          if (v16 && v16 <= *(void *)&v7[12 * a3 + 12])
          {
            unint64_t v17 = *(void *)(v12 + 16 * v14 + 16) / v11;
            int v18 = *(_DWORD *)(*(void *)(a2 + 8LL * a3 + 1488) + 4 * v17);
            int v19 = v18 & 0xC000000;
            unint64_t v20 = *(void *)&v18 & 0xFFFFFFLL;
            if (!v19 && v20 > a4) {
              break;
            }
          }

          uint64_t v14 = ((unsigned __int16)v14
                             + 1
                             - 7 * ((613566757 * (unint64_t)((unsigned __int16)v14 + 1)) >> 32));
          if (!--v15) {
            goto LABEL_14;
          }
        }

        if (v17 < v13)
        {
          unint64_t v31 = 0LL;
LABEL_55:
          uint64_t v58 = sub_1000318E0(v5, a3, a4, v17);
          if ((_DWORD)v58)
          {
            uint64_t v4 = v58;
            sub_100013D94("%s:%d: %s failed to update allocate zone %llu: error %d\n");
          }

          else
          {
            uint64_t v60 = *(void *)(v5 + 1584);
            if (v60) {
              ++*(void *)(v60 + (v8 << 6) + 8 * a4 + 120);
            }
            if (*(_DWORD *)(v5 + 1592))
            {
              unint64_t v61 = (uint64_t *)(*(void *)(v5 + 1600) + 16LL * *(unsigned int *)(v5 + 1596));
              uint64_t v4 = 0LL;
              *unint64_t v61 = sub_100032B28();
              v61[1] = v8 & 1 | (2 * (a4 & 7)) & 0xF | (v31 << 44) | (16 * (v17 & 0xFFFFFFFFFFLL));
              int v62 = *(_DWORD *)(v5 + 1596);
              else {
                int v63 = 0;
              }
              *(_DWORD *)(v5 + 1596) = v63;
            }

            else
            {
              uint64_t v4 = 0LL;
            }
          }
        }

        else
        {
LABEL_14:
          unint64_t v22 = v10 / v11;
          unint64_t v23 = v7[10];
          unint64_t v24 = v13 - 1;
          unint64_t v26 = v22 + 1 == v23 || v22 == v24;
          uint64_t v27 = &v7[12 * a3];
          unsigned int v30 = v27[16];
          uint64_t v29 = v27 + 16;
          LODWORD(v28) = v30;
          if (v30 > v26)
          {
            unint64_t v31 = 0LL;
            uint64_t v70 = 0LL;
            unint64_t v65 = v22;
            unint64_t v67 = &v7[12 * a3 + 17];
            uint64_t v68 = (v22 / v23);
            uint64_t v32 = a2 + 8LL * a3;
            uint64_t v66 = (void *)(v32 + 888);
            io_registry_entry_t v33 = (void *)(v32 + 1488);
            int v69 = -1;
            unint64_t v17 = -1LL;
            BOOL v34 = v29;
            do
            {
              unint64_t v35 = (v68 + v26) % v28;
              if (*v67)
              {
                unsigned int v36 = v7[11];
                unsigned int v37 = v35 / v36;
                int v38 = v69;
                uint64_t v39 = v70;
                if (v35 / v36 != v69 || v70 == 0)
                {
                  uint64_t v41 = *(void *)(*v66 + 8LL * v37);
                  if (v74)
                  {
                    sub_100038824(v74);
                    uint64_t v74 = 0LL;
                  }

                  v75[2] = v7;
                  v75[3] = __PAIR64__(v37, a3);
                  uint64_t v42 = sub_10003B574( *(void *)(a1 + 392),  0x40000000LL,  v41,  &xmmword_10005BA54,  &v75[2],  0LL,  0LL,  0LL,  &v74);
                  if ((_DWORD)v42)
                  {
                    uint64_t v4 = v42;
                    sub_100013D94( "%s:%d: %s error getting cab %d: %d\n",  "spaceman_get_new_chunk_for_allocation_zone",  1248,  (const char *)(*(void *)(a1 + 384) + 208LL),  v37,  v42);
                    goto LABEL_58;
                  }

                  uint64_t v39 = *(void *)(v74 + 56);
                  unsigned int v36 = v7[11];
                  int v38 = v37;
                }

                int v69 = v38;
                uint64_t v70 = v39;
                int v43 = (uint64_t *)(v39 + 8LL * (v35 - v36 * v38) + 40);
              }

              else
              {
                int v43 = (uint64_t *)(*v66 + 8 * v35);
              }

              uint64_t v44 = *v43;
              v75[0] = v7;
              v75[1] = __PAIR64__(v35, a3);
              uint64_t v45 = sub_10003B574( *(void *)(a1 + 392),  0x40000000LL,  v44,  &xmmword_10005BA64,  v75,  0LL,  0LL,  0LL,  &v73);
              if ((_DWORD)v45)
              {
                uint64_t v4 = v45;
                sub_100013D94("%s:%d: %s error getting cib %d: %d\n");
                goto LABEL_58;
              }

              if (v26) {
                LODWORD(v46) = 0;
              }
              else {
                LODWORD(v46) = v65 % v7[10] + 1;
              }
              uint64_t v47 = *(void *)(v73 + 56);
              unsigned int v48 = *(_DWORD *)(v47 + 36);
              BOOL v49 = v48 >= v46;
              int v50 = v48 - v46;
              if (v50 != 0 && v49)
              {
                unint64_t v51 = v35 * v7[10];
                uint64_t v46 = v46;
                __int128 v52 = (int *)(v47 + 32LL * v46 + 60);
                unint64_t v53 = v17;
                do
                {
                  int v54 = *v52;
                  v52 += 8;
                  unint64_t v55 = v54 & 0xFFFFF;
                  if (v31 < v55)
                  {
                    unint64_t v17 = v51 + v46;
                    int v56 = *(_DWORD *)(*v33 + 4 * (v51 + v46));
                    if ((v56 & 0xC000000) == 0 && (*(void *)&v56 & 0xFFFFFFuLL) > a4)
                    {
                      unint64_t v31 = v55;
                      unint64_t v53 = v51 + v46;
                      if ((_DWORD)v55 == v7[9]) {
                        break;
                      }
                    }
                  }

                  ++v46;
                  unint64_t v17 = v53;
                  --v50;
                }

                while (v50);
              }

              if (v31 == v7[9]) {
                break;
              }
              sub_100038824(v73);
              uint64_t v73 = 0LL;
              ++v26;
              unint64_t v28 = *v34;
            }

            while (v26 < v28);
            uint64_t v8 = a3;
            uint64_t v5 = a2;
            if (v17 != -1LL) {
              goto LABEL_55;
            }
          }

          uint64_t v4 = 28LL;
        }

BOOL sub_100032204(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(a1 + 8LL * a2 + 1488);
  if (!v4) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 104LL * a2 + 1104))
  {
    uint64_t v5 = a1 + 104LL * a2;
    uint64_t v6 = (unint64_t *)(*(_BYTE *)(v5 + 1098) ? v5 + 1080 : v5 + 1048);
    if (*(void *)(v5 + 1008) <= a3 && *v6 > a3) {
      return 1LL;
    }
  }

  if (a4 <= 4
    && (v8 = a4 - 1, uint64_t v9 = a1 + 136LL * a2 + 1216, *(_BYTE *)(v9 + 32 * (a4 - 1) + 24))
    && *(void *)(v9 + 32 * v8) <= a3)
  {
    return *(void *)(v9 + 32 * v8 + 8) <= a3;
  }

  else
  {
    return 1LL;
  }

BOOL sub_1000322C8( unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, __int16 a5, unint64_t a6, unint64_t *a7, unint64_t *a8)
{
  unint64_t v19 = 0LL;
  unint64_t v14 = sub_100013C78(a1, a2, a3, a4, &v19);
  if (v14)
  {
    unint64_t v15 = a2 - v14;
    if (a2 == v14)
    {
      unint64_t v16 = 0LL;
LABEL_17:
      *a8 = v16;
      return v14 != 0;
    }

    unint64_t v16 = v19 - a1;
    if (v19 == a1)
    {
      unint64_t v17 = v14 + a1;
LABEL_9:
      *a7 = v17;
LABEL_10:
      unint64_t v16 = v15;
      goto LABEL_17;
    }

    unint64_t v15 = a2 - (v16 + v14);
    if ((a5 & 0x4000) != 0)
    {
      if (a6 > v19 && a2 != v16 + v14 && (v19 + v14 <= a6 || a6 - v19 > v19 + v14 - a6))
      {
        *a7 = v19 + v14;
        goto LABEL_10;
      }
    }

    else if (v15 > v16)
    {
      unint64_t v17 = v19 + v14;
      goto LABEL_9;
    }

    *a7 = a1;
    goto LABEL_17;
  }

  return v14 != 0;
}

uint64_t sub_1000323A4( uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, __int16 a6, unint64_t a7, unint64_t *a8, unint64_t *a9)
{
  uint64_t v12 = a5;
  unint64_t v13 = a4;
  uint64_t v16 = *(void *)(a1 + 1760);
  if (v16
    && !*(_BYTE *)(a1 + 636)
    && (uint64_t v17 = *(void *)(a1 + 1752),
        char v18 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36LL))),
        (((v17 << v18) & 0x4000000000000000LL) != 0) == a3))
  {
    uint64_t v19 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v18;
    unint64_t v20 = v19 & v17;
    if ((a6 & 0x200) != 0)
    {
      if (v20 && (v31 = v19 & v17, v32 = sub_1000322C8(a4, a5, 0LL, v19 & v17, a6, a7, a8, a9), unint64_t v20 = v31, v32))
      {
        unint64_t v13 = *a8;
        uint64_t v12 = *a9;
        char v21 = 1;
      }

      else
      {
        char v21 = 0;
      }

      v20 += v16;
      uint64_t v16 = *(void *)(*(void *)(a2 + 376) + 48LL * a3 + 48) - v20;
    }

    else
    {
      char v21 = 0;
    }

    if (sub_1000322C8(v13, v12, v20, v16, a6, a7, a8, a9))
    {
      unint64_t v13 = *a8;
      uint64_t v12 = *a9;
      char v21 = 1;
    }
  }

  else
  {
    char v21 = 0;
  }

  if ((a6 & 0x2000) != 0)
  {
    unsigned int v22 = a3;
    if (*(_BYTE *)(a2 + 104LL * a3 + 1104))
    {
      uint64_t v23 = a2 + 104LL * a3;
      unint64_t v24 = *(void *)(v23 + 1008);
      int v25 = *(unsigned __int8 *)(v23 + 1098);
      unint64_t v26 = (void *)(v23 + 1080);
      uint64_t v27 = (void *)(v23 + 1048);
      if (v25) {
        uint64_t v27 = v26;
      }
      if (sub_1000322C8(v13, v12, v24, *v27 - v24, a6, a7, a8, a9))
      {
        unint64_t v13 = *a8;
        uint64_t v12 = *a9;
        char v21 = 1;
      }
    }

    if (*(_BYTE *)(a2 + 136LL * a3 + 1344))
    {
      uint64_t v28 = 0LL;
      uint64_t v29 = a2 + 136LL * v22;
      do
      {
        if (*(_BYTE *)(v29 + v28 + 1240)
          && sub_1000322C8( v13,  v12,  *(void *)(v29 + v28 + 1216),  *(void *)(v29 + v28 + 1224) - *(void *)(v29 + v28 + 1216),  a6,  a7,  a8,  a9))
        {
          unint64_t v13 = *a8;
          uint64_t v12 = *a9;
          char v21 = 1;
        }

        v28 += 32LL;
      }

      while (v28 != 128);
    }
  }

  return v21 & 1;
}

uint64_t sub_1000325C0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t result = sub_1000139BC((pthread_mutex_t *)a1);
  if (!(_DWORD)result)
  {
    v8.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v8.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v8);
    *(void *)(a1 + 64) = v8.tv_sec / a2 * a2;
    *(_DWORD *)(a1 + 72) = a2;
    *(_DWORD *)(a1 + 76) = a3;
    unint64_t v7 = sub_100013EEC(a3, 8uLL);
    *(void *)(a1 + 80) = v7;
    if (v7)
    {
      uint64_t result = 0LL;
      *(void *)(a1 + 88) = 0LL;
    }

    else
    {
      j__pthread_mutex_destroy((pthread_mutex_t *)a1);
      return 12LL;
    }
  }

  return result;
}

uint64_t sub_10003265C(uint64_t a1)
{
  *(void *)(a1 + 80) = 0LL;
  return j__pthread_mutex_destroy((pthread_mutex_t *)a1);
}

const char *sub_100032690(const char *result, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v11 = a4;
  if ((*(_BYTE *)(a2 + 64) & 2) != 0)
  {
    uint64_t v6 = result;
    if (a4)
    {
      return sub_100032774(result, a2, a3, a4);
    }

    else
    {
      int v7 = sub_10001A2D8((uint64_t)result, 4, 2LL, 0LL, &v11);
      if (v7)
      {
        int v8 = v7;
        uint64_t v9 = *(void *)(a2 + 8);
        unint64_t v10 = strerror(v7);
        return sub_100013D94( "%s:%d: %s failed to enter tx to update size tracking for ino %llu: %s (%d); size tracking may go out of sync\n",
                 "update_size_tracking",
                 4962,
                 v6 + 3992,
                 v9,
                 v10,
                 v8);
      }

      else
      {
        sub_100032774(v6, a2, a3, v11);
        return (const char *)sub_10001A2E8((uint64_t)v6, 4, 2LL, 0LL, v11);
      }
    }
  }

  return result;
}

const char *sub_100032774(const char *result, uint64_t a2, void *a3, uint64_t a4)
{
  if ((*(_BYTE *)(a2 + 64) & 2) != 0)
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t __dst = 0xAAAAAAAAAAAAAAAALL;
    if (sub_1000518D4((unsigned __int16 *)(a2 + 408), 10, 0LL, (char *)&__dst, 8uLL) || !__dst)
    {
      uint64_t result = (const char *)sub_100013538(*(void *)(v7 + 392));
      if ((_DWORD)result) {
        return sub_100013D94( "%s:%d: %s ino %llu is flagged to maintain dir-stats but has no dir-stats key\n",  "update_dir_stats",  679,  (const char *)(v7 + 3992),  *(void *)(a2 + 8));
      }
    }

    else
    {
      return (const char *)sub_100032830(v7, __dst, a3, 0, 0LL, a4);
    }
  }

  return result;
}

uint64_t sub_100032830(uint64_t a1, uint64_t a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  if ((*(void *)(*(void *)(a1 + 376) + 56LL) & 0x200LL) != 0) {
    unsigned __int8 v9 = 18;
  }
  else {
    unsigned __int8 v9 = 10;
  }
  v34[1] = -1431655766;
  v34[0] = v9;
  uint64_t v35 = a2;
  uint64_t v36 = 0LL;
  __int128 v37 = *(_OWORD *)a3;
  uint64_t v38 = a3[4];
  __int128 v41 = 0u;
  __int128 v40 = 0u;
  __int128 v39 = 0u;
  sub_1000511D8((uint64_t)&v40, 0LL);
  if (a3[2])
  {
    HIDWORD(v41) |= 4u;
    sub_100051620((unsigned __int16 *)&v40, 1, 0, a3 + 2, 8uLL);
  }

  if (a3[3])
  {
    HIDWORD(v41) |= 8u;
    sub_100051620((unsigned __int16 *)&v40, 3, 0, a3 + 3, 8uLL);
  }

  int v10 = (a4 >> 5) & 1;
  unsigned int v11 = a4 & 0xFFFFFFDF;
  if (a3[5])
  {
    HIDWORD(v41) |= 0x800u;
    sub_100051620((unsigned __int16 *)&v40, 4, 0, a3 + 5, 8uLL);
  }

  uint64_t v12 = 0LL;
  LOBYTE(v13) = 0;
  unsigned int v14 = 0;
  BOOL v32 = (const char *)(a1 + 3992);
  int v15 = v10;
  while (1)
  {
    BYTE1(v34[0]) = 4;
    DWORD2(v41) = v11;
    *(void *)&__int128 v39 = a3[6];
    if ((v10 & 1) != 0) {
      int v16 = 32;
    }
    else {
      int v16 = 0;
    }
    int v17 = v11 | v16;
    if ((v13 & 1) != 0) {
      v17 |= 0x100000u;
    }
    if ((v10 & 1) != 0 || (v13 & 1) != 0) {
      DWORD2(v41) = v17;
    }
    if (v15 == 1)
    {
      int v18 = 0x4000;
      goto LABEL_24;
    }

    if (v15 == 2)
    {
      DWORD2(v41) = v17 | 0x40;
      if (v35 == v12)
      {
        int v18 = 16448;
LABEL_24:
        DWORD2(v41) = v17 | v18;
      }
    }

    int v19 = sub_10001811C(a1, 1, (unsigned __int8 *)v34, a6);
    if ((v19 & 0xFFFFFFFD) != 0)
    {
      int v20 = v19;
      uint64_t v21 = v35;
      unsigned int v22 = strerror(v19);
      sub_100013D94( "%s:%d: %s failed to update dir-stats %llu: %s (%d)\n",  "update_dir_stats_by_key_ext",  564,  v32,  v21,  v22,  v20);
    }

    if ((DWORD2(v41) & 0x400000) == 0) {
      break;
    }
    char v25 = 0;
    if (!v35) {
      goto LABEL_51;
    }
LABEL_48:
    if ((v25 & 1) != 0) {
      goto LABEL_51;
    }
    if (++v14 == 1025) {
      goto LABEL_52;
    }
  }

  if (v15)
  {
    uint64_t v23 = v35;
    int v24 = BYTE8(v41) & 0x20;
  }

  else
  {
    int v24 = BYTE8(v41) & 0x20;
    uint64_t v23 = v35;
    if ((BYTE8(v41) & 0x40) != 0) {
      uint64_t v26 = v35;
    }
    else {
      uint64_t v26 = v12;
    }
    if ((BYTE8(v41) & 0x20) != 0)
    {
      int v15 = 1;
    }

    else
    {
      int v24 = 0;
      uint64_t v12 = v26;
      int v15 = (BYTE8(v41) & 0x40) >> 5;
    }
  }

  LOBYTE(v10) = v24 != 0;
  int v13 = (DWORD2(v41) >> 20) & 1;
  if (a5) {
    BOOL v27 = v23 == a5;
  }
  else {
    BOOL v27 = 0;
  }
  uint64_t v28 = *((void *)&v39 + 1);
  char v25 = v27 || v23 == *((void *)&v39 + 1);
  uint64_t v35 = *((void *)&v39 + 1);
  *((void *)&v39 + 1) = 0LL;
  if (v28) {
    goto LABEL_48;
  }
LABEL_51:
  if (v14 < 0x400) {
    return sub_100051550((uint64_t)&v40);
  }
LABEL_52:
  if (sub_100013538(*(void *)(a1 + 392))) {
    sub_100013D94( "%s:%d: %s stopped updating dir-stats due to chain being too long\n",  "update_dir_stats_by_key_ext",  617,  v32);
  }
  return sub_100051550((uint64_t)&v40);
}

uint64_t sub_100032B28()
{
  v1.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v1.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_REALTIME, &v1);
  return sub_100032B5C(&v1.tv_sec);
}

uint64_t sub_100032B5C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v3 = v2 / 1000000000;
  uint64_t v4 = v2 % 1000000000;
  if (*a1 < 0 && v2 >= 1)
  {
    uint64_t v5 = v3 + 1;
    v4 -= 1000000000LL;
  }

  else
  {
    BOOL v6 = v2 >= 0;
    if (v2 < 0) {
      uint64_t v5 = v3 - 1;
    }
    else {
      uint64_t v5 = v2 / 1000000000;
    }
    if (v6) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = v4 + 1000000000;
    }
    if (v1 >= 1) {
      uint64_t v4 = v7;
    }
    else {
      uint64_t v5 = v3;
    }
  }

  uint64_t v8 = v1 + v5;
  if (__OFADD__(v1, v5)
    || (uint64_t v9 = 1000000000 * v8, (unsigned __int128)(v8 * (__int128)1000000000LL) >> 64 != (1000000000 * v8) >> 63)
    || (uint64_t result = v4 + v9, __OFADD__(v4, v9)))
  {
    if (v1 > 0) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      return 0x8000000000000000LL;
    }
  }

  return result;
}

double sub_100032BF8(uint64_t a1)
{
  *(void *)(a1 + 408) = 0LL;
  *(void *)(a1 + 720) = 0LL;
  *(void *)(a1 + 920) = 0LL;
  *(void *)(a1 + 1128) = 0LL;
  *(void *)(a1 + 1336) = 0LL;
  *(_BYTE *)(a1 + 635) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  return result;
}

uint64_t sub_100032C48(uint64_t a1, int *a2, unint64_t *a3)
{
  BOOL v6 = sub_100014044(*(unsigned int *)(*(void *)(a1 + 376) + 36LL));
  if (!v6) {
    return 12LL;
  }
  uint64_t v7 = v6;
  uint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = *(void *)(a1 + 376);
  if ((*(_DWORD *)(v8 + 104) & 0x7FFFFFFF) != 0)
  {
    unint64_t v9 = 0LL;
    BOOL v18 = 0;
    unint64_t v10 = 0LL;
    int v11 = -1;
    while (1)
    {
      v7[6] = 0;
      if (sub_1000132F4(a1, v9, &v19) || sub_100051DF4(*(void *)(a1 + 384), v19))
      {
        sub_100013D94("%s:%d: %s couldn't read checkpoint descriptor block %d @ 0x%llx: %d\n");
      }

      else
      {
        int v14 = v7[6];
        if (v14 == -2147483647) {
          goto LABEL_12;
        }
        if (v14)
        {
          if (v14 == 1073741836)
          {
LABEL_12:
            if (sub_100005224(v7, *(_DWORD *)(*(void *)(a1 + 376) + 36LL), v12, v13))
            {
              sub_100013D94("%s:%d: %s invalid checksum for object type 0x%x @ checkpoint descriptor block %d @ 0x%llx\n");
            }

            else if (v7[7])
            {
              sub_100013D94("%s:%d: %s found unexpected subtype 0x%x for object type 0x%x @ checkpoint descriptor block %d\n");
            }

            else
            {
              unint64_t v15 = *((void *)v7 + 2);
              if (v15)
              {
                if (v15 >= v10)
                {
                  int v16 = v7[6];
                  if (v15 == v10 && v18 && v16 != -2147483647)
                  {
                    BOOL v18 = 1;
                  }

                  else
                  {
                    BOOL v18 = v16 == -2147483647;
                    unint64_t v10 = *((void *)v7 + 2);
                    int v11 = v9;
                  }
                }
              }

              else
              {
                sub_100013D94("%s:%d: %s found unexpected xid %lld @ checkpoint descriptor block %d\n");
              }
            }

            goto LABEL_7;
          }

          sub_100013D94("%s:%d: %s found unexpected object type 0x%x @ checkpoint descriptor block %d\n");
        }
      }

LABEL_7:
      ++v9;
      uint64_t v8 = *(void *)(a1 + 376);
      if (v9 >= (*(_DWORD *)(v8 + 104) & 0x7FFFFFFFu)) {
        goto LABEL_27;
      }
    }
  }

  unint64_t v10 = 0LL;
  int v11 = -1;
LABEL_27:
  sub_100014004(v7, *(unsigned int *)(v8 + 36));
  *a2 = v11;
  *a3 = v10;
  return 2 * (v10 == 0);
}

uint64_t sub_100032EB8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x16_t a5, int8x16_t a6)
{
  int v10 = sub_100005224((void *)a2, *(_DWORD *)(a1 + 36), a5, a6);
  unint64_t v11 = *(unsigned int *)(a2 + 36);
  if (!(_DWORD)v11) {
    return sub_100005194(0LL);
  }
  if (v10) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  if (*(_DWORD *)(a2 + 24) == 1073741836) {
    int v13 = v10 != 0;
  }
  else {
    int v13 = v12;
  }
  if (*(_DWORD *)(a2 + 28)) {
    ++v13;
  }
  if (*(void *)(a2 + 16) != *(void *)(a1 + 16)) {
    ++v13;
  }
  int v14 = *(void *)(a2 + 8) == a3 ? v13 : v13 + 1;
  uint64_t v15 = *(unsigned int *)(a1 + 36);
  if (v11 > (v15 - 40) / 0x28uLL || v14 != -(*(_DWORD *)(a2 + 32) & 1 ^ (a4 != 0))) {
    return sub_100005194(0LL);
  }
  uint64_t v18 = 0LL;
  uint64_t v19 = *(unsigned int *)(a1 + 108);
  uint64_t v20 = a2 + 40;
  while (v11 != v18)
  {
    int v21 = *(_DWORD *)(v20 + 4);
    if ((*(_DWORD *)v20 & 0xC0000000) == 0x80000000) {
      int v22 = 1;
    }
    else {
      int v22 = 2;
    }
    else {
      int v24 = (*(_DWORD *)v20 & 0xC0000000) != 0x80000000;
    }
    if ((v21 & 0xC0000000) != 0) {
      ++v24;
    }
    if (((unsigned __int16)*(_DWORD *)(v20 + 4) > 0x24u || ((1LL << v21) & 0x100029CA01LL) == 0)
      && (unsigned __int16)*(_DWORD *)(v20 + 4) != 255)
    {
      ++v24;
    }

    if (!*(void *)(v20 + 24)) {
      ++v24;
    }
    if ((v19 & 0x80000000) != 0)
    {
      unsigned int v30 = v18;
    }

    else
    {
      unint64_t v25 = *(void *)(v20 + 32);
      unint64_t v26 = *(void *)(a1 + 120);
      if (v25 < v26) {
        ++v24;
      }
      if (v25 >= v26 + v19) {
        ++v24;
      }
      unsigned int v27 = v25 - v26;
      unsigned int v28 = *(_DWORD *)(a1 + 144);
      if (v28 <= v27) {
        int v29 = 0;
      }
      else {
        int v29 = *(_DWORD *)(a1 + 108);
      }
      unsigned int v30 = v29 - v28 + v27;
      if (v30 >= *(_DWORD *)(a1 + 148)) {
        ++v24;
      }
    }

    unsigned int v31 = *(_DWORD *)(v20 + 8);
    if (v31) {
      int v32 = v24;
    }
    else {
      int v32 = v24 + 1;
    }
    unsigned int v33 = v31 / v15;
    else {
      int v34 = 0;
    }
    if (v32 == v34)
    {
      ++v18;
      v20 += 40LL;
      if (v33 <= *(_DWORD *)(a1 + 148) - v30) {
        continue;
      }
    }

    return sub_100005194(0LL);
  }

  return 0LL;
}

BOOL sub_1000330B8(uint64_t a1, uint64_t a2, const char *a3, int a4)
{
  if (*(void *)(a1 + 72) == *(void *)(a2 + 72) && *(void *)(a1 + 80) == *(void *)(a2 + 80))
  {
    int v9 = 0;
  }

  else
  {
    sub_100013D94("%s:%d: %s<->superblock mismatch on uuid\n", "nx_superblock_agrees_with_main_superblock", 263, a3);
    int v9 = 1;
  }

  BOOL v10 = *(void *)(a1 + 1280) == *(void *)(a2 + 1280) && *(void *)(a1 + 1287) == *(void *)(a2 + 1287);
  if (!v10 || (*(unsigned __int8 *)(a2 + 1295) ^ *(unsigned __int8 *)(a1 + 1295)) != a4)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on fusion uuid, tier2=%d\n",  "nx_superblock_agrees_with_main_superblock",  268,  a3,  a4);
    ++v9;
  }

  unint64_t v11 = *(void *)(a1 + 16);
  if (v11 > *(void *)(a2 + 16)) {
    sub_100013D94( "%s:%d: the %s superblock has a lower XID %lld than the main superblock %lld\n",  "nx_superblock_agrees_with_main_superblock",  273,  a3,  *(void *)(a2 + 16),  v11);
  }
  int v12 = *(_DWORD *)(a2 + 36);
  if (*(_DWORD *)(a1 + 36) != v12)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on block size: %d %d\n",  "nx_superblock_agrees_with_main_superblock",  279,  a3,  *(_DWORD *)(a1 + 36),  v12);
    ++v9;
  }

  uint64_t v13 = *(void *)(a2 + 40);
  if (*(void *)(a1 + 40) != v13)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on block count: %lld %lld\n",  "nx_superblock_agrees_with_main_superblock",  284,  a3,  *(void *)(a1 + 40),  v13);
    ++v9;
  }

  int v14 = *(_DWORD *)(a2 + 104);
  if (*(_DWORD *)(a1 + 104) != v14)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on checkpoint descriptor block count: %d %d\n",  "nx_superblock_agrees_with_main_superblock",  289,  a3,  *(_DWORD *)(a1 + 104),  v14);
    ++v9;
  }

  int v15 = *(_DWORD *)(a2 + 108);
  if (*(_DWORD *)(a1 + 108) != v15)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on checkpoint data block count: %d %d\n",  "nx_superblock_agrees_with_main_superblock",  294,  a3,  *(_DWORD *)(a1 + 108),  v15);
    ++v9;
  }

  uint64_t v16 = *(void *)(a2 + 112);
  if (*(void *)(a1 + 112) != v16)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on checkpoint descriptor base address: %lld %lld\n",  "nx_superblock_agrees_with_main_superblock",  299,  a3,  *(void *)(a1 + 112),  v16);
    ++v9;
  }

  uint64_t v17 = *(void *)(a2 + 120);
  if (*(void *)(a1 + 120) != v17)
  {
    sub_100013D94( "%s:%d: %s<->superblock mismatch on checkpoint data base address: %lld %lld\n",  "nx_superblock_agrees_with_main_superblock",  304,  a3,  *(void *)(a1 + 120),  v17);
    int v9 = 1;
  }

  return v9 == 0;
}

uint64_t sub_1000332E0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v24 = 0LL;
  unint64_t v25 = 0LL;
  uint64_t v23 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  *a5 = -1;
  unsigned int v5 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (!v5) {
    return 2LL;
  }
  int v10 = 0;
  unsigned int v11 = 0;
  int v21 = (_OWORD *)(a1 + 424);
  while (1)
  {
    if (v10 && (*(_BYTE *)(a2 + 1264) & 2) != 0) {
      return 35LL;
    }
    unsigned int v12 = (a3 + v5 + v10) % v5;
    uint64_t v26 = -1LL;
    if (sub_1000132F4(a1, v12, &v26) || sub_100051DF4(*(void *)(a1 + 384), v26))
    {
      sub_100013D94("%s:%d: %s couldn't read checkpoint descriptor block %d @ %lld: %d\n");
      goto LABEL_8;
    }

    if (*(_DWORD *)(a4 + 24) == -2147483647)
    {
      if (sub_10000538C(a4, *(_DWORD *)(a2 + 36), 1, v13, v14))
      {
        sub_100013D94("%s:%d: %s checkpoint superblock %d @ %lld: failed sanity check: %d\n");
        goto LABEL_8;
      }

      if ((*(void *)(a2 + 64) & 0xFFFFFFFFFFFFFEFDLL) != 0)
      {
        sub_100013D94( "%s:%d: %s unsupported nx_incompatible_features (0x%llx): unable to mount\n",  "nx_checkpoint_find_valid_checkpoint",  505,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 64) & 0xFFFFFFFFFFFFFEFDLL);
        return 75LL;
      }
    }

uint64_t sub_1000339B8(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = sub_100014044(a2[9]);
  if (!v4) {
    return 12LL;
  }
  unsigned int v5 = v4;
  uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  if (a2[35] == 1)
  {
LABEL_3:
    uint64_t v6 = 0LL;
  }

  else
  {
    int v7 = 0;
    while (1)
    {
      uint64_t v8 = sub_1000132F4(a1, (v7 + a2[34]) % (a2[26] & 0x7FFFFFFF), &v12);
      if ((_DWORD)v8) {
        break;
      }
      uint64_t v8 = sub_100051DF4(*(void *)(a1 + 384), v12);
      if ((_DWORD)v8) {
        break;
      }
      uint64_t v8 = sub_100032EB8((uint64_t)a2, (uint64_t)v5, v12, v7 == a2[35] - 2, v9, v10);
      if ((_DWORD)v8) {
        break;
      }
      if (++v7 >= a2[35] - 1) {
        goto LABEL_3;
      }
    }

    uint64_t v6 = v8;
  }

  sub_100014004(v5, a2[9]);
  return v6;
}

uint64_t sub_100033ABC(uint64_t a1, uint64_t a2, unint64_t *a3, void *a4)
{
  size_t v6 = *(unsigned int *)(*(void *)(a1 + 376) + 36LL);
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v42 = 0LL;
  int v7 = sub_100014044(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    v45[0] = -1431655766;
    unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
    if (*(_DWORD *)(a2 + 140) - 1 < 1)
    {
LABEL_28:
      sub_100014004(v8, v6);
      return 0LL;
    }

    else
    {
      int v9 = 0;
      unsigned int v10 = *(_DWORD *)(a2 + 144);
      unsigned int v11 = *(_DWORD *)(a2 + 136);
      int v38 = v6 - 1;
      int v34 = (char *)(v7 + 10);
      int v33 = *(_DWORD *)(a2 + 140) - 1;
      while (1)
      {
        uint64_t v41 = 0LL;
        unint64_t v12 = sub_1000132F4(a1, v11, &v41);
        if ((_DWORD)v12
          || (unint64_t v12 = sub_100051DF4(*(void *)(a1 + 384), v41), (_DWORD)v12)
          || (unint64_t v12 = sub_100005224(v8, v6, v13, v14), (_DWORD)v12))
        {
          uint64_t v31 = v12;
          sub_100013D94("%s:%d: %s couldn't read checkpoint descriptor map block %d @ %lld: %d\n");
LABEL_39:
          sub_100014004(v8, v6);
LABEL_40:
          sub_100037058(*(pthread_mutex_t **)(a1 + 392), 0);
          *(void *)(a1 + 408) = 0LL;
          *(void *)(a1 + 720) = 0LL;
          *(void *)(a1 + 920) = 0LL;
          *(void *)(a1 + 1128) = 0LL;
          *(void *)(a1 + 1336) = 0LL;
          *(_BYTE *)(a1 + 635) = 0;
          *(_OWORD *)(a1 + 424) = 0u;
          *(_OWORD *)(a1 + 440) = 0u;
          *(_OWORD *)(a1 + 456) = 0u;
          return v31;
        }

        unsigned int v36 = v11;
        int v35 = v9;
        if (v8[9]) {
          break;
        }
LABEL_27:
        unsigned int v11 = (v36 + 1) % (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu);
        int v9 = v35 + 1;
        if (v35 + 1 == v33) {
          goto LABEL_28;
        }
      }

      unint64_t v15 = 0LL;
      unsigned int v16 = v34;
      while (1)
      {
        int v17 = *((_DWORD *)v16 + 2);
        uint64_t v41 = 0LL;
        uint64_t v18 = sub_100013338(a1, v10, &v41, &v40);
        if ((_DWORD)v18)
        {
          uint64_t v31 = v18;
          sub_100013D94( "%s:%d: %s couldn't read checkpoint data block %d @ %lld: %d\n",  "nx_checkpoint_load_data",  396,  (const char *)(*(void *)(a1 + 384) + 208LL),  v10,  v41,  v18);
          goto LABEL_39;
        }

        if (v41 != *((void *)v16 + 4)) {
          break;
        }
        unsigned int v19 = *(_DWORD *)(a2 + 144);
        unsigned int v20 = v10;
        if (v10 < v19) {
          unsigned int v20 = (*(_DWORD *)(a2 + 108) & 0x7FFFFFFF) + v10;
        }
        unsigned int v21 = v20 - v19;
        unsigned int v22 = *(_DWORD *)(a2 + 148);
        unsigned int v23 = (v38 + v17) / v6;
        if (v21 >= v22 || v21 + v23 > v22)
        {
          sub_100013D94( "%s:%d: %s checkpoint mapping (%d,%d) extends beyond checkpoint data range: %d,%d\n",  "nx_checkpoint_load_data",  412,  (const char *)(*(void *)(a1 + 384) + 208LL),  v21,  (v38 + v17) / v6,  *(_DWORD *)(a2 + 144),  v22);
          goto LABEL_34;
        }

        v45[0] = 0x80000000;
        uint64_t v24 = sub_10003A3CC(*(_DWORD *)v16, v45, (uint64_t)&v43);
        HIDWORD(v43) = *((_DWORD *)v16 + 1);
        LODWORD(v44) = v17;
        if ((_DWORD)v24)
        {
          uint64_t v31 = v24;
LABEL_38:
          sub_100013D94("%s:%d: %s failed to load checkpoint data of type 0x%x:0x%x @ %lld\n");
          goto LABEL_39;
        }

        uint64_t v25 = sub_10003D594( *(pthread_mutex_t **)(a1 + 392),  v45[0],  *((void *)v16 + 3),  (uint64_t)&v43,  v41,  v10,  v40,  *(void *)(a2 + 16),  (uint64_t *)&v42);
        if ((_DWORD)v25)
        {
          uint64_t v31 = v25;
          goto LABEL_38;
        }

        if (a3)
        {
          uint64_t v26 = v42;
          if (!*a4)
          {
            int v27 = sub_100037DC8((uint64_t)v42);
            uint64_t v26 = v42;
            if (v27 == 5)
            {
              unsigned int v28 = (void *)v42[7];
              unint64_t v29 = v28[32];
              if (v29 <= v28[27]) {
                unint64_t v29 = v28[27];
              }
              *a3 = v29;
              unint64_t v30 = v28[37];
              if (v30 <= v29) {
                unint64_t v30 = v29;
              }
              *a3 = v30;
              *a4 = *(void *)(a2 + 16);
            }
          }
        }

        else
        {
          uint64_t v26 = v42;
        }

        sub_100038824(v26);
        unsigned int v10 = (v23 + v10) % (*(_DWORD *)(a2 + 108) & 0x7FFFFFFFu);
        ++v15;
        v16 += 40;
      }

      sub_100013D94( "%s:%d: %s unexpected checkpoint map entry address: 0x%llx, expected 0x%llx\n",  "nx_checkpoint_load_data",  401,  (const char *)(*(void *)(a1 + 384) + 208LL),  *((void *)v16 + 4),  v41);
LABEL_34:
      uint64_t v31 = sub_100005194(0LL);
      sub_100014004(v8, v6);
      if ((_DWORD)v31) {
        goto LABEL_40;
      }
    }
  }

  else
  {
    sub_100013D94( "%s:%d: %s couldn't allocate memory for checkpoint map block\n",  "nx_checkpoint_load_data",  367,  (const char *)(*(void *)(a1 + 384) + 208LL));
    return 12LL;
  }

  return v31;
}

uint64_t sub_100033F18( int *a1, const char *a2, int a3, int a4, char a5, uint64_t a6, char a7, const char **a8, void *a9)
{
  int v32 = 0LL;
  int v33 = 0LL;
  if (a4)
  {
    uint64_t v31 = a8;
    uint64_t v11 = 0LL;
    unsigned int v12 = 0;
    int v33 = (const char *)a1;
    goto LABEL_3;
  }

  if ((a5 & 1) != 0) {
    return 45LL;
  }
  uint64_t v25 = sub_100052650((const char *)a1, a3, (int **)&v33);
  if ((_DWORD)v25)
  {
    uint64_t v21 = v25;
    sub_100013D94("%s:%d: device initialization failed: %d\n", "nx_dev_init", 727, v25);
LABEL_43:
    if (v33) {
      sub_100051D68((uint64_t)v33);
    }
    if (v32) {
      sub_100051D68((uint64_t)v32);
    }
    return v21;
  }

  if (a2)
  {
    uint64_t v26 = sub_100052650(a2, a3, &v32);
    if ((_DWORD)v26)
    {
      uint64_t v21 = v26;
      sub_100013D94("%s:%d: tier2 device initialization failed: %d\n", "nx_dev_init", 732, v26);
      goto LABEL_43;
    }
  }

  uint64_t v31 = a8;
  if (v32)
  {
    unsigned int v12 = sub_100051C28((uint64_t)v32);
    if (v32) {
      uint64_t v11 = sub_100051C34((uint64_t)v32);
    }
    else {
      uint64_t v11 = 0LL;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    unsigned int v12 = 0;
  }

uint64_t sub_100034464(int *a1, uint64_t a2, uint64_t **a3)
{
  unint64_t v127 = 0LL;
  int v128 = 0LL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v129[4] = v4;
  v129[5] = v4;
  v129[2] = v4;
  v129[3] = v4;
  v129[0] = v4;
  v129[1] = v4;
  int v125 = 0LL;
  uint64_t v126 = 0LL;
  int v124 = (pthread_cond_t **)0xAAAAAAAAAAAAAAAALL;
  uint64_t v120 = 0LL;
  *a3 = 0LL;
  if (a2)
  {
    unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
    uint64_t v6 = *(unsigned int *)(a2 + 4);
    int v7 = *(_DWORD *)a2 & 1;
    int16x4_t v8 = vdup_n_s16(v5);
    int16x4_t v9 = (int16x4_t)vand_s8((int8x8_t)v8, (int8x8_t)0x2000100001000004LL);
    if ((v5 & 8) != 0)
    {
      uint64_t v11 = *(const char **)(a2 + 16);
      int v10 = (v5 >> 6) & 1;
    }

    else
    {
      LOBYTE(v10) = 0;
      uint64_t v11 = 0LL;
    }

    BOOL v18 = (v5 & 0x4000 | v7) != 0;
    if ((vtst_s16(v9, v9).i8[6] & 1) != 0 && (v6 & 0x80000000) == 0)
    {
      sub_100013D94("%s:%d: conflicting mount options: load from temporary checkpoint AND checkpoint descriptor index %d\n");
LABEL_11:
      unsigned int v19 = 0;
      int8x16_t v20 = 0LL;
      uint64_t v21 = 22LL;
      goto LABEL_12;
    }

    if ((v5 & 0xC00) == 0x800)
    {
      sub_100013D94("%s:%d: conflicting mount options: is_system_graft but not is_graft\n");
      goto LABEL_11;
    }

    int v113 = a3;
    char v111 = v5 & 1;
    int v14 = (v5 >> 1) & 1;
    int8x8_t __n = (int8x8_t)vtst_s16(v8, (int16x4_t)0x2000100001000004LL);
    int v114 = (v5 >> 5) & 1;
    int v15 = (v5 >> 9) & 1;
    BOOL v23 = (v5 & 0xC00) != 0;
    int v116 = (v5 >> 11) & 1;
    sub_100003F54();
    BOOL v13 = v23;
    if (v18) {
      int v24 = 16;
    }
    else {
      int v24 = 32;
    }
    int v16 = (v24 | (2 * v7)) ^ 2;
    uint64_t v25 = v6;
    char v12 = v111;
    uint64_t v17 = v25;
  }

  else
  {
    int v113 = a3;
    sub_100003F54();
    int v7 = 0;
    char v12 = 0;
    int v114 = 0;
    BOOL v13 = 0;
    int v116 = 0;
    int v14 = 0;
    LOBYTE(v10) = 0;
    int v15 = 0;
    uint64_t v11 = 0LL;
    int8x8_t __n = 0LL;
    int v16 = 34;
    uint64_t v17 = 0xFFFFFFFFLL;
  }

  unsigned int v123 = -1431655766;
  unint64_t v122 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v121 = -1431655766;
  uint64_t v26 = a1;
  BOOL v27 = v13;
  uint64_t v28 = sub_100033F18(v26, v11, v16, v14, v13, 0LL, v10, &v128, &v125);
  if ((_DWORD)v28)
  {
    uint64_t v21 = v28;
    if ((_DWORD)v28 != 79) {
      sub_100013D94("%s:%d: device initialization failed: %d\n", "nx_mount", 1104, v28);
    }
    return v21;
  }

  BOOL v106 = v27;
  char v112 = v12;
  uint64_t v30 = v128;
  else {
    int v31 = 1;
  }
  int v108 = v31;
  int v32 = sub_100051DD8((uint64_t)v30);
  unsigned int v33 = sub_100051DB4((uint64_t)v30);
  int v34 = v125;
  size_t v35 = v125[9];
  BOOL v36 = v15 == 0;
  int v37 = 0x8000;
  if (v15) {
    unsigned int v38 = 128;
  }
  else {
    unsigned int v38 = 0x8000;
  }
  int v39 = 0x10000;
  if (v36) {
    int v40 = 0x10000;
  }
  else {
    int v40 = 128;
  }
  if (!v36)
  {
    int v39 = 128;
    int v37 = 128;
  }

  sub_100013CBC( "%s:%d: %s initializing cache w/hash_size %u and cache size %u\n",  "nx_mount",  1293,  v30 + 208,  v37,  v39);
  unsigned int v41 = v40;
  unsigned int v19 = v35;
  uint64_t v42 = sub_100036A8C(v38, v41, v35, &v127);
  if ((_DWORD)v42)
  {
    uint64_t v43 = v42;
    sub_100013D94("%s:%d: %s object cache initialization failed: %d\n", "nx_mount", 1297, v30 + 208, v42);
    int8x16_t v20 = 0LL;
    uint64_t v21 = v43;
    goto LABEL_12;
  }

  uint64_t v44 = (uint64_t)v34;
  uint64_t v45 = v127;
  if (v116) {
    *(void *)&v127[14].__opaque[16] = 1LL;
  }
  memset((char *)&v129[3] + 8, 0, 40);
  *(_OWORD *)((char *)&v129[2] + 8) = 0u;
  memset((char *)v129 + 8, 0, 32);
  *(void *)&v129[0] = __PAIR64__(v35, v33);
  *((void *)&v129[0] + 1) = v34[5];
  *((void *)&v129[1] + 1) = v30;
  *(void *)&v129[2] = 1LL;
  DWORD2(v129[2]) = v108;
  HIDWORD(v129[2]) = v32 != 0;
  v129[3] = vmovl_u16((uint16x4_t)vand_s8(__n, (int8x8_t)0x1000100010001LL));
  uint64_t v46 = sub_100039908(v45, 0x80000000, 1uLL, (uint64_t)&xmmword_10005B780, (uint64_t)v129, v35, 1LL, (uint64_t *)&v126);
  uint64_t v47 = v17;
  if ((_DWORD)v46)
  {
    uint64_t v21 = v46;
    sub_100013D94("%s:%d: %s object cache bootstrap failed: %d\n");
LABEL_47:
    int8x16_t v20 = 0LL;
    goto LABEL_12;
  }

  unsigned int v48 = v126;
  if (v114) {
    *((_BYTE *)v126 + 642) = 1;
  }
  memcpy((void *)v48[47], v34, v35);
  BOOL v49 = (int64x2_t *)v127;
  uint64_t v50 = v126[47];
  *(void *)v127[6].__opaque = v126;
  v49[25].i64[0] = *(void *)(v50 + 88);
  __strlcpy_chk(&v49[26], v30 + 208, 255LL, 255LL);
  sub_10003E9B4((int64x2_t *)v127, v106 & (v116 ^ 1));
  unint64_t v127 = 0LL;
  int v128 = 0LL;
  int v51 = *(_DWORD *)(v50 + 104);
  if (v51 < 0 && (uint64_t v21 = sub_100012AB4((uint64_t)v126, *(void *)(v50 + 112), v51 & 0x7FFFFFFF), (_DWORD)v21)
    || (int v52 = *(_DWORD *)(v50 + 108), v52 < 0)
    && (uint64_t v21 = sub_100012AB4((uint64_t)v126, *(void *)(v50 + 120), v52 & 0x7FFFFFFF), (_DWORD)v21))
  {
    sub_100013D94("%s:%d: %s fragmented checkpoint area failed sanity check: %d\n");
    goto LABEL_47;
  }

  int8x16_t v20 = sub_100014044(v35);
  if (!v20)
  {
    sub_100013D94( "%s:%d: %s failed to allocate buffer for checkpoint superblock\n",  "nx_mount",  1402,  (const char *)(v126[48] + 208));
    uint64_t v21 = 12LL;
    goto LABEL_12;
  }

  __int8 v53 = __n.i8[2];
  if ((*(_BYTE *)(v50 + 1264) & 2) == 0) {
    goto LABEL_57;
  }
  int v54 = v126;
  *((_BYTE *)v126 + 626) = 1;
  if (*((_BYTE *)v54 + 628))
  {
    sub_100013D94("%s:%d: %s storage is untrusted. Container cleanly-unmounted flag ignored\n", *(double *)&__n);
  }

  else if (*(_DWORD *)(v50 + 140))
  {
    if (*(_DWORD *)(v50 + 148)) {
      goto LABEL_57;
    }
    sub_100013D94( "%s:%d: %s checkpoint data length is bad.  Container cleanly-unmounted flag ignored\n",  *(double *)&__n);
  }

  else
  {
    sub_100013D94( "%s:%d: %s checkpoint descriptor length is bad.  Container cleanly-unmounted flag ignored\n",  *(double *)&__n);
  }

  *(void *)(v50 + 1264) &= ~2uLL;
  v34[158] &= ~2uLL;
  __int8 v53 = __n.i8[2];
LABEL_57:
  int v117 = 0;
  uint64_t __na = v35;
  char v55 = 0;
  int v115 = 0;
  __int8 v107 = v53;
  char v109 = 0;
  while (1)
  {
    int v56 = v126;
    if ((*(_BYTE *)(v50 + 1264) & 2) != 0) {
      break;
    }
    if (((*((_BYTE *)v126 + 633) != 0) & v55) != 0)
    {
      int v57 = 1;
      goto LABEL_62;
    }

    uint64_t v63 = sub_100032C48((uint64_t)v126, (int *)&v121, &v122);
    if ((_DWORD)v63)
    {
      uint64_t v21 = v63;
      sub_100013D94("%s:%d: %s failed to scan checkpoint descriptor area for largest xid: %d\n");
      goto LABEL_146;
    }

LABEL_169:
        int v95 = sub_1000310A8(v91);
        if (v95) {
          sub_100013D94( "%s:%d: %s failed to set up sm allocation metadata: %d\n",  "nx_mount",  1765,  (const char *)(v126[48] + 208),  v95);
        }
        uint64_t v98 = v126;
        if ((v109 & 1) != 0)
        {
          sub_10003E948((uint64_t)v126, v96, v97);
          uint64_t v99 = sub_100051F74(v126[48], 0LL);
          uint64_t v98 = v126;
          if ((_DWORD)v99)
          {
            uint64_t v21 = v99;
            sub_100013D94("%s:%d: %s failed to write superblock to block 0: %d\n");
            goto LABEL_146;
          }

          __int16 v100 = (_BYTE *)v126[47];
          if ((v100[65] & 1) != 0)
          {
            uint64_t v101 = sub_1000107A8((uint64_t)v126, v100);
            uint64_t v98 = v126;
            if ((_DWORD)v101)
            {
              uint64_t v21 = v101;
              sub_100013D94("%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n");
              goto LABEL_146;
            }
          }
        }

        uint64_t v102 = v98[47];
        unint64_t v103 = *(void *)(v102 + 1384);
        unint64_t v104 = sub_100003A54();
        if (v103 < v104) {
          *(void *)(v102 + 1384) = v104;
        }
        sub_1000358B0(v98);
        sub_1000121F8(v126);
        goto LABEL_180;
      }

      sub_100032BF8((uint64_t)v85);
      memcpy((void *)v126[47], v64, v35);
      char v55 = 1;
    }
  }

  sub_100013D04("%s:%d: %s container cleanly-unmounted flag set.\n", "nx_mount", 1436, (const char *)(v126[48] + 208));
  int v56 = v126;
  int v57 = *((unsigned __int8 *)v126 + 633);
LABEL_62:
  unsigned int v58 = *(_DWORD *)(v50 + 136) + *(_DWORD *)(v50 + 140) - 1;
  unsigned int v59 = *(_DWORD *)(v50 + 104) & 0x7FFFFFFF;
  uint64_t v60 = v58 % v59;
  unsigned int v121 = v58 % v59;
  unint64_t v122 = *(void *)(v50 + 16);
  if (v57 == 0 || (v55 & 1) == 0) {
    goto LABEL_66;
  }
  sub_100013D04( "%s:%d: %s Attempting to load from temporary checkpoint (start xid %lld).\n",  "nx_mount",  1441,  (const char *)(v56[48] + 208),  *(void *)(v50 + 1408));
  uint64_t v61 = v60;
  int v62 = (const void *)v44;
  if (!*(void *)(v50 + 1408))
  {
    sub_100013D94( "%s:%d: %s No temporary checkpoint start xid!  Aborting!\n",  "nx_mount",  1443,  (const char *)(v126[48] + 208));
    uint64_t v21 = 100LL;
LABEL_146:
    unsigned int v19 = __na;
    goto LABEL_12;
  }

LABEL_75:
  unsigned int v68 = *(_DWORD *)(v50 + 104) & 0x7FFFFFFF;
  if (v61 >= v68)
  {
    sub_100013D94( "%s:%d: %s checkpoint descriptor index %d out of range [0...%d]\n",  "nx_mount",  1461,  (const char *)(v126[48] + 208),  v61,  v68 - 1);
    uint64_t v87 = v126;
LABEL_145:
    uint64_t v21 = sub_100005194((uint64_t)v87);
    goto LABEL_146;
  }

  uint64_t v47 = v61;
  uint64_t v69 = sub_1000132F4((uint64_t)v126, v61, &v120);
  if ((_DWORD)v69)
  {
    uint64_t v21 = v69;
LABEL_140:
    sub_100013D94("%s:%d: %s couldn't read checkpoint descriptor block %d @ %lld: %d\n");
    goto LABEL_12;
  }

  uint64_t v70 = sub_100051DF4(v126[48], v120);
  uint64_t v21 = v70;
  if (*((_BYTE *)v126 + 633))
  {
    if (!(_DWORD)v70 && (_DWORD)v35)
    {
      uint64_t v73 = 0LL;
      while (!*((_BYTE *)v20 + v73))
      {
        if (v35 == ++v73)
        {
          uint64_t v21 = 0LL;
          goto LABEL_85;
        }
      }

      sub_100013D94( "%s:%d: %s Attempt to load temporary checkpoint found unexpected data (0x%02x @ %d), checkpoint descriptor block %d @ %lld\n",  "nx_mount",  1477,  (const char *)(v126[48] + 208),  *((char *)v20 + v73),  v73,  v47,  v120);
      uint64_t v21 = 22LL;
    }

LABEL_85:
    memcpy(v20, v62, v35);
    sub_10003E984((uint64_t)v126, (uint64_t)v20, v35, v74, v75);
  }

  if ((_DWORD)v21) {
    goto LABEL_140;
  }
  if (*((_DWORD *)v20 + 7) || *((_DWORD *)v20 + 6) != -2147483647)
  {
    sub_100013D94( "%s:%d: %s checkpoint descriptor block %d is not a valid superblock\n",  "nx_mount",  1494,  (const char *)(v126[48] + 208),  v47);
    uint64_t v87 = v126;
    goto LABEL_145;
  }

  unint64_t v76 = sub_10000538C((uint64_t)v20, *(_DWORD *)(v50 + 36), 1, v71, v72);
  if ((_DWORD)v76)
  {
    uint64_t v21 = v76;
    sub_100013D94("%s:%d: %s checkpoint descriptor block %d superblock failed sanity checks: %d\n");
    goto LABEL_146;
  }

  if ((*(void *)(v50 + 64) & 0xFFFFFFFFFFFFFEFDLL) != 0)
  {
    sub_100013D94( "%s:%d: %s unsupported nx_incompatible_features (0x%llx): unable to mount\n",  "nx_mount",  1504,  (const char *)(v126[48] + 208),  *(void *)(v50 + 64) & 0xFFFFFFFFFFFFFEFDLL);
    uint64_t v21 = 75LL;
    goto LABEL_146;
  }

  int v64 = (const void *)v44;
  if (!sub_1000330B8(v44, (uint64_t)v20, "checkpoint", 0))
  {
    sub_100013D94( "%s:%d: %s checkpoint descriptor block %d doesn't agree with main superblock\n",  "nx_mount",  1510,  (const char *)(v126[48] + 208),  v47);
    uint64_t v21 = 22LL;
    goto LABEL_146;
  }

  unsigned int v77 = (*((_DWORD *)v20 + 34) + *((_DWORD *)v20 + 35) - 1) % (*(_DWORD *)(v50 + 104) & 0x7FFFFFFFu);
  if ((_DWORD)v47 != v77)
  {
    sub_100013D94( "%s:%d: %s checkpoint superblock index %d doesn't match index block was found at: %d\n",  "nx_mount",  1517,  (const char *)(v126[48] + 208),  v77,  v47);
    uint64_t v87 = v126;
    goto LABEL_145;
  }

  uint64_t v78 = sub_100012E9C(v126, 0LL, 1, 0, 1);
  if ((_DWORD)v78
    || (*((_BYTE *)v20 + 65) & 1) != 0
    && ((uint64_t v78 = sub_100012E9C(v126, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v126[47] + 36))), 1, 0, 1),
         (_DWORD)v78)
     || (*((_BYTE *)v20 + 65) & 1) != 0
     && (uint64_t v78 = sub_100012E9C( v126,  *(void *)(v126[47] + 1368),  *(void *)(v126[47] + 1376) & 0x7FFFFFFF,  (*(void *)(v126[47] + 1376) & 0x80000000LL) != 0,  0),  (_DWORD)v78))
    || (uint64_t v78 = sub_100012E9C(v126, v20[14], v20[13] & 0x7FFFFFFF, *((int *)v20 + 26) < 0, 0), (_DWORD)v78)
    || (uint64_t v78 = sub_100012E9C(v126, v20[15], *((_DWORD *)v20 + 27) & 0x7FFFFFFF, *((int *)v20 + 27) < 0, 0), (_DWORD)v78))
  {
    uint64_t v21 = v78;
    sub_100013D94( "%s:%d: %s xid %lld at index %d failed to load checkpoint metadata ranges (overlap?): %d\n",  "nx_mount",  1542,  (const char *)(v126[48] + 208),  v20[2],  *((_DWORD *)v20 + 34),  v78);
    goto LABEL_12;
  }

  uint64_t v79 = sub_1000339B8((uint64_t)v126, (unsigned int *)v20);
  if ((_DWORD)v79)
  {
    uint64_t v21 = v79;
    sub_100013D94("%s:%d: %s validation failed for checkpoint at index %d: %d\n");
    goto LABEL_146;
  }

  unsigned int v123 = v47;
  uint64_t v110 = v20[2];
  sub_100013CBC( "%s:%d: %s checkpoint: largest xid %lld, given checkpoint xid %lld @ %d\n",  "nx_mount",  1553,  (const char *)(v126[48] + 208),  v122,  v110,  v47);
  uint64_t v80 = v126;
  if (*(void *)(v44 + 16) != v20[2])
  {
    sub_100013D94( "%s:%d: %s loading older checkpoint, checkpoint xid %lld, superblock xid %lld\n",  "nx_mount",  1555,  (const char *)(v126[48] + 208),  v20[2],  *(void *)(v50 + 16));
    uint64_t v80 = v126;
    char v109 = 1;
    *((_BYTE *)v126 + 645) = 1;
  }

  uint64_t v81 = sub_100033ABC((uint64_t)v80, (uint64_t)v20, 0LL, 0LL);
  if ((_DWORD)v81)
  {
    uint64_t v21 = v81;
    sub_100013D94("%s:%d: %s data for checkpoint at index %d couldn't be loaded: %d\n");
    goto LABEL_146;
  }

  memcpy((void *)v126[47], v20, v35);
  uint64_t v82 = v126;
  *(void *)(v126[49] + 400) = *(void *)(v126[47] + 88);
  uint64_t v21 = sub_100010860((uint64_t)v82, 0LL, 2LL);
  int v83 = v126;
  if ((_DWORD)v21)
  {
    sub_100013D94("%s:%d: %s failed to fix up checkpoint data: %d\n");
    goto LABEL_146;
  }

  if (*((_BYTE *)v126 + 628))
  {
    if ((v107 & 1) != 0)
    {
      sub_100013D04( "%s:%d: %s probe of external device... skipping recent sanity checks.\n",  "nx_mount",  1583,  (const char *)(v126[48] + 208));
      int v83 = v126;
    }

    else
    {
      sub_100013D04( "%s:%d: %s sanity checking all recently-changed container state... please be patient.\n",  "nx_mount",  1591,  (const char *)(v126[48] + 208));
      uint64_t v21 = sub_10000B4A8(v126);
      int v83 = v126;
      if ((_DWORD)v21)
      {
        sub_100013D94("%s:%d: %s sanity check of recently-changed structures failed: %d\n");
        goto LABEL_146;
      }
    }
  }

  uint64_t v21 = sub_100044238(v83, (uint64_t *)&v124);
  if ((_DWORD)v21)
  {
    sub_100013D94("%s:%d: %s checkpoint xid %lld failed to get spaceman: %d\n");
    goto LABEL_146;
  }

  uint64_t v21 = sub_100012E9C( v126,  *(void *)&v124[47][3].__opaque[16],  *(_DWORD *)&v124[47][3].__opaque[12] & 0x7FFFFFFF,  *(int *)&v124[47][3].__opaque[12] < 0,  0);
  if (!(_DWORD)v21)
  {
    uint64_t v21 = sub_100012E9C( v126,  *(void *)&v124[47][3].__opaque[24],  *(void *)v124[47][3].__opaque,  *(uint64_t *)v124[47][3].__opaque < 0,  0);
    sub_100038824((uint64_t *)v124);
    if ((_DWORD)v21) {
      goto LABEL_152;
    }
    unint64_t v67 = v126;
    goto LABEL_113;
  }

  sub_100038824((uint64_t *)v124);
LABEL_152:
  sub_100013D94("%s:%d: %s checkpoint xid %lld failed to load spaceman metadata ranges (overlap?): %d\n");
LABEL_12:
  if (v125) {
    sub_100014004(v125, v125[9]);
  }
  if (v20) {
    sub_100014004(v20, v19);
  }
  uint64_t v22 = v126;
  if (v126)
  {
    *((_BYTE *)v126 + 627) = 1;
    sub_100035914((uint64_t)v22);
  }

  if (v127) {
    sub_100037210((uint64_t)v127);
  }
  if (v128) {
    sub_100051D68((uint64_t)v128);
  }
  return v21;
}

  if (v116)
  {
    sub_100038824(v116);
    int v116 = 0LL;
  }

  uint64_t v98 = a3[1];
  int8x16_t v94 = *((void *)a3 + 1);
  uint64_t v87 = *((void *)a3 + 4);
  BOOL v88 = *((void *)a3 + 3);
  v114[0] = *(_OWORD *)(a3 + 10);
  v112[0] = 16;
  char v111 = 16;
  uint64_t v42 = sub_100026464((uint64_t)v115, 0LL, (unint64_t *)v114, v112, 0x10u, v113, &v111, 3u, 0, 0LL);
  if ((_DWORD)v42)
  {
    BOOL v13 = v42;
    if ((_DWORD)v42 != 2) {
      goto LABEL_75;
    }
    *(void *)&v114[0] = 0LL;
  }

  sub_10003D514((uint64_t)a1, 2);
  uint64_t v43 = *(void *)&v114[0];
  if (!*(void *)&v114[0])
  {
    sub_10003CF10((uint64_t)a1, 2);
    goto LABEL_167;
  }

  uint64_t v90 = v8;
  uint64_t v44 = 0LL;
  uint64_t v102 = 0LL;
  uint64_t v85 = a3 + 10;
  int v86 = (const char *)(v11 + 3992);
  do
  {
    uint64_t v45 = v44;
    if (v43 != v102)
    {
      if (v39 >= v96)
      {
        *uint64_t v85 = v114[0];
        goto LABEL_191;
      }

      uint64_t v45 = 0LL;
    }

    uint64_t v102 = v43;
    v113[1] = v114[0];
    v112[0] = 16;
    char v111 = 16;
    uint64_t v46 = sub_100026464((uint64_t)v115, 0LL, (unint64_t *)&v113[1], v112, 0x10u, &v112[1], &v111, 4u, 0, 0LL);
    if ((_DWORD)v46)
    {
      BOOL v13 = v46;
      if ((_DWORD)v46 != 2)
      {
        sub_100013D94( "%s:%d: %s lookup returned unexpected error while iterating: %d\n",  "omap_cleanup",  1665,  v86,  v13);
        *uint64_t v85 = v114[0];
        sub_10003CF10((uint64_t)a1, 2);
        goto LABEL_75;
      }

      *(void *)&v113[1] = 0LL;
    }

    uint64_t v44 = (v45 + 1);
    if (*((void *)&v114[0] + 1) <= v94 || *((void *)&v114[0] + 1) > v88)
    {
      if ((v98 & 2) == 0 || *(void *)&v113[1] != *(void *)&v114[0])
      {
        BOOL v13 = 0LL;
        unsigned int v48 = 0;
        goto LABEL_126;
      }

      BOOL v13 = 0LL;
      if (*((void *)&v113[1] + 1) > v94 && *((void *)&v113[1] + 1) <= v87)
      {
        BOOL v13 = 0LL;
        unsigned int v48 = v112[1] & 1;
        goto LABEL_126;
      }

void sub_1000358B0(void *a1)
{
  int v2 = sub_10004769C(a1, 0, 1);
  if (v2) {
    sub_100013D94( "%s:%d: %s *** trim'ing free blocks returned: %d\n",  "nx_mount_initiate_free_space_trims",  964,  (const char *)(a1[48] + 208LL),  v2);
  }
  sub_10002B380(a1);
}

void sub_100035914(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 400);
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 627))
    {
      sub_10004F01C(a1);
      uint64_t v2 = *(void *)(a1 + 400);
    }

    sub_10004E638(a1, v2, *(_DWORD *)(*(void *)(a1 + 376) + 36LL));
  }

  uint64_t v3 = *(uint64_t **)(a1 + 408);
  if (v3)
  {
    sub_100038824(v3);
    *(void *)(a1 + 408) = 0LL;
  }

  for (uint64_t i = 0LL; i != 32; i += 8LL)
  {
    unsigned int v5 = *(uint64_t **)(a1 + 432 + i);
    if (v5) {
      sub_100038824(v5);
    }
  }

  size_t v6 = *(void *)(a1 + 464);
  if (v6)
  {
    sub_100029238(v6, 0LL, 0LL);
    sub_100038824(*(uint64_t **)(a1 + 464));
  }

  size_t v7 = *(void *)(a1 + 1824);
  if (v7)
  {
    sub_100029238(v7, 0LL, 0LL);
    sub_100038824(*(uint64_t **)(a1 + 1824));
    *(void *)(a1 + 1824) = 0LL;
  }

  uint64_t v8 = *(void *)(a1 + 384);
  if (v8) {
    sub_100051D68(v8);
  }
  uint64_t v9 = *(void *)(a1 + 392);
  if (v9) {
    sub_100037210(v9);
  }
}

unint64_t sub_100035A40( uint32x4_t *a1, unint64_t a2, unint64_t a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5 = a3;
  unint64_t v6 = HIDWORD(a3);
  if ((a2 & 3) == 0)
  {
    for (i = a2 >> 2; i; unint64_t v6 = v34 + HIDWORD(v34))
    {
      if (i >= 0x16A00) {
        uint64_t v8 = 92672LL;
      }
      else {
        uint64_t v8 = i;
      }
      i -= v8;
      int64x2_t v9 = (int64x2_t)veorq_s8(a4, a4);
      int64x2_t v10 = (int64x2_t)veorq_s8(a5, a5);
      v9.i64[0] = v5;
      v10.i64[0] = v6;
      if (v8 >= 16)
      {
        uint32x4_t v11 = *a1;
        uint32x4_t v12 = a1[1];
        uint32x4_t v13 = a1[2];
        uint32x4_t v14 = a1[3];
        a1 += 4;
        int64x2_t v15 = vshlq_n_s64(v9, 4uLL);
        uint64x2_t v16 = vmull_u32(*(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
        uint64x2_t v17 = vmull_u32(*(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008LL);
        int64x2_t v18 = (int64x2_t)vmlal_u32( vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v11.i8, (uint32x2_t)0xF00000010LL),  *(uint32x2_t *)v14.i8,  (uint32x2_t)0x300000004LL);
        uint64x2_t v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v11), v12), v13);
        BOOL v20 = v8 < 32;
        for (v8 -= 32LL; !v20; v8 -= 16LL)
        {
          uint64x2_t v21 = vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_100035A00);
          uint32x4_t v22 = *a1;
          a1 += 4;
          uint32x4_t v11 = v22;
          uint64x2_t v23 = vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_100035A00[2]);
          uint32x4_t v12 = a1[-3];
          int64x2_t v24 = (int64x2_t)vpadalq_u32(v19, v14);
          uint64x2_t v25 = vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_100035A00[4]);
          uint32x4_t v13 = a1[-2];
          uint64x2_t v26 = vmlal_high_u32(v21, v14, *(uint32x4_t *)&qword_100035A00[6]);
          uint32x4_t v14 = a1[-1];
          int64x2_t v15 = vshlq_n_s64(v24, 4uLL);
          uint64x2_t v16 = vmlal_u32(v26, *(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
          uint64x2_t v17 = vmlal_u32(v23, *(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008LL);
          int64x2_t v18 = (int64x2_t)vmlal_u32( vmlal_u32(v25, *(uint32x2_t *)v22.i8, (uint32x2_t)0xF00000010LL),  *(uint32x2_t *)v14.i8,  (uint32x2_t)0x300000004LL);
          uint64x2_t v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v24, v22), v12), v13);
          BOOL v20 = v8 < 16;
        }

        int64x2_t v9 = (int64x2_t)vpadalq_u32(v19, v14);
        int64x2_t v10 = vaddq_s64( vaddq_s64( (int64x2_t)vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_100035A00[4]),  (int64x2_t)vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_100035A00[2])),  (int64x2_t)vmlal_high_u32( vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_100035A00),  v14,  *(uint32x4_t *)&qword_100035A00[6]));
      }

      if ((v8 & 8) != 0)
      {
        uint32x4_t v27 = *a1;
        a1 += 2;
        uint32x4_t v28 = a1[-1];
        int64x2_t v29 = vshlq_n_s64(v9, 3uLL);
        int64x2_t v9 = (int64x2_t)vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v27), v28);
        int64x2_t v10 = vaddq_s64( (int64x2_t)vmlal_high_u32( vmlal_high_u32( vmlal_u32( vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v27.i8, (uint32x2_t)0x700000008LL),  *(uint32x2_t *)v28.i8,  (uint32x2_t)0x300000004LL),  v27,  *(uint32x4_t *)&qword_100035A00[4]),  v28,  *(uint32x4_t *)&qword_100035A00[6]),  v29);
      }

      if ((v8 & 4) != 0)
      {
        uint32x4_t v30 = *a1++;
        int64x2_t v31 = vshlq_n_s64(v9, 2uLL);
        int64x2_t v9 = (int64x2_t)vpadalq_u32((uint64x2_t)v9, v30);
        int64x2_t v10 = vaddq_s64( (int64x2_t)vmlal_high_u32( vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v30.i8, (uint32x2_t)0x300000004LL),  v30,  *(uint32x4_t *)&qword_100035A00[6]),  v31);
      }

      uint64_t v32 = v8 & 3;
      a4 = (int8x16_t)vpaddq_s64(v9, v9);
      a5 = (int8x16_t)vpaddq_s64(v10, v10);
      unint64_t v33 = a4.i64[0];
      unint64_t v34 = a5.i64[0];
      if (v32)
      {
        do
        {
          unsigned __int32 v35 = a1->i32[0];
          a1 = (uint32x4_t *)((char *)a1 + 4);
          v33 += v35;
          v34 += v33;
          BOOL v20 = v32-- <= 1;
        }

        while (!v20);
      }

      unint64_t v5 = v33 + HIDWORD(v33);
    }
  }

  unint64_t v36 = v5 + HIDWORD(v5);
  unint64_t v37 = v6 + HIDWORD(v6);
  if (v36 == 0xFFFFFFFF) {
    unint64_t v36 = 0LL;
  }
  if (v37 == 0xFFFFFFFF) {
    unint64_t v37 = 0LL;
  }
  return v36 + (v37 << 32);
}

uint64_t sub_100035BE8(const char *a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v79 = 0LL;
  uint64_t v80 = 0LL;
  unsigned int v77 = 0LL;
  uint64_t v78 = 0LL;
  unint64_t v76 = 0LL;
  *a4 = 0LL;
  if (a2)
  {
    unint64_t v8 = *(unsigned int *)(a2 + 16);
    int v9 = *(_DWORD *)(a2 + 20);
    unsigned int v10 = *(unsigned __int8 *)(a2 + 34);
    __int16 v11 = *(_WORD *)(a2 + 32);
    int v12 = v11 & 3;
    if ((v11 & 3) == 0)
    {
      *(_WORD *)(a2 + 32) = v11 & 0xFFFC | 1;
      int v12 = 1;
    }

    uint64_t v13 = v12 == 2;
    unint64_t v14 = *(void *)(a2 + 40);
  }

  else
  {
    unsigned int v10 = 0;
    unint64_t v8 = 0LL;
    uint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    int v9 = 1073741826;
  }

  unint64_t v84 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v82[16] = v15;
  __int128 v83 = v15;
  v81[9] = v15;
  *(_OWORD *)uint64_t v82 = v15;
  v81[7] = v15;
  v81[8] = v15;
  v81[5] = v15;
  v81[6] = v15;
  v81[3] = v15;
  v81[4] = v15;
  v81[1] = v15;
  v81[2] = v15;
  v81[0] = v15;
  __int128 v85 = v15;
  __int128 v86 = v15;
  v87[0] = v15;
  v87[1] = v15;
  v87[2] = v15;
  v87[3] = v15;
  memset(v75, 170, sizeof(v75));
  sub_100003F54();
  uint64_t v16 = sub_100052650(a1, 2, &v79);
  if ((_DWORD)v16)
  {
    uint64_t v17 = v16;
    strerror(v16);
    sub_100013D94("%s:%d: device initialization failed: %d - %s\n");
    goto LABEL_8;
  }

  if (!sub_100051DCC((uint64_t)v79))
  {
    sub_100013D94("%s:%d: error: device is not writable!\n");
    goto LABEL_24;
  }

  int v74 = v9;
  unsigned int v20 = sub_100051C28((uint64_t)v79);
  unint64_t v21 = sub_100051C34((uint64_t)v79);
  if (a2)
  {
    uint64_t v22 = *(void *)(a2 + 24);
    if (v22)
    {
      uint64_t v23 = sub_100052650((const char *)v22, 2, &v78);
      if ((_DWORD)v23)
      {
        uint64_t v17 = v23;
        strerror(v23);
        sub_100013D94("%s:%d: tier2 device initialization failed: %d - %s\n");
        goto LABEL_8;
      }

      if (sub_100051DCC((uint64_t)v78))
      {
        unsigned int v24 = sub_100051C28((uint64_t)v78);
        uint64_t v22 = sub_100051C34((uint64_t)v78);
        if ((_DWORD)v8) {
          goto LABEL_41;
        }
        goto LABEL_27;
      }

      sub_100013D94("%s:%d: error: tier2 device is not writable!\n");
LABEL_24:
      uint64_t v17 = 30LL;
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v22 = 0LL;
  }

  unsigned int v24 = 4096;
  if ((_DWORD)v8) {
    goto LABEL_41;
  }
LABEL_27:
  unint64_t v25 = v21 * v20 + v22 * v24;
  if (v25 >> 50) {
    int v26 = 0x4000;
  }
  else {
    int v26 = 4096;
  }
  if (v25 >> 59) {
    unsigned int v27 = 0x10000;
  }
  else {
    unsigned int v27 = v26;
  }
  if (v20 > v27) {
    unsigned int v27 = v20;
  }
  if (v24 <= v27) {
    unsigned int v28 = v27;
  }
  else {
    unsigned int v28 = v24;
  }
  if (v22) {
    unint64_t v8 = v28;
  }
  else {
    unint64_t v8 = v27;
  }
LABEL_41:
  if ((int)v8 <= 4095)
  {
    sub_100013D4C("%s:%d: warning: fs block size too small (%d < %d)\n");
LABEL_45:
    uint64_t v17 = 22LL;
    goto LABEL_8;
  }

  if (v8 < v20)
  {
    sub_100013D4C("%s:%d: warning: fs block size too small for device block size (%d < %d)\n");
    goto LABEL_45;
  }

  unint64_t v29 = v8 / v20;
  if (v8 % v20)
  {
    sub_100013D94("%s:%d: error: block size %d is not an even multiple of device block size %d\n");
    goto LABEL_45;
  }

  uint64_t v73 = v8;
  if (v8 > v20)
  {
    uint64_t v71 = v22;
    sub_100051DC0((uint64_t)v79);
    uint64_t v22 = v71;
    unint64_t v29 = v8 / v20;
  }

  uint32x4_t v30 = v78;
  if (v78)
  {
    unsigned int v31 = v73;
    if (v73 < v24)
    {
      LODWORD(v8) = v73;
      sub_100013D4C("%s:%d: warning: fs block size too small for tier2 device block size (%d < %d)\n");
      goto LABEL_45;
    }

    if (v73 % v24)
    {
      LODWORD(v8) = v73;
      sub_100013D94("%s:%d: error: block size %d is not an even multiple of tier2 device block size %d\n");
      goto LABEL_45;
    }

    unint64_t v68 = v73 / v24;
    unint64_t v69 = v29;
    unint64_t v72 = v22;
    unint64_t v37 = v78;
    if (v73 > v24)
    {
      sub_100051DC0((uint64_t)v78);
      unsigned int v31 = v73;
      unint64_t v37 = v78;
    }

    uint64_t v38 = sub_100052A70((uint64_t)v79, (uint64_t)v37, 0x4000000000000000uLL >> __clz(__rbit64(v31)));
    if ((_DWORD)v38)
    {
      uint64_t v17 = v38;
      sub_100013D94("%s:%d: failed to set tier2 device\n", "nx_format", 180);
      goto LABEL_60;
    }

    uint64_t v78 = 0LL;
    unint64_t v39 = v21 * v20;
    unint64_t v40 = v72 * v24;
    if (v40 < v39 && v39 >> 36 && v40 > 0x500000000LL)
    {
      sub_100013D94( "%s:%d: It looks like you are trying to create an upside down Fusion: Main tier (%llu GB) is larger than Tier2 (%llu GB)\n",  "nx_format",  192,  v39 >> 30,  v40 >> 30);
      uint64_t v17 = 22LL;
      goto LABEL_60;
    }

    unint64_t v32 = v72 / v68;
    uint64_t v70 = v30;
    if (a2)
    {
      __int16 v41 = *(_WORD *)(a2 + 32);
      if ((v41 & 0xC) == 0)
      {
        if (v39 < 0x1000000001LL)
        {
          sub_100013D04("%s:%d: FusionLC autodetect: LC Fusion\n", "nx_format", 206);
          __int16 v42 = 8;
        }

        else
        {
          sub_100013D04("%s:%d: FusionLC autodetect: regular Fusion\n", "nx_format", 203);
          __int16 v42 = 4;
        }

        __int16 v41 = *(_WORD *)(a2 + 32) & 0xFFF3 | v42;
        *(_WORD *)(a2 + 32) = v41;
        unint64_t v32 = v72 / v68;
      }

      if ((v41 & 0xC) == 8) {
        v13 |= 2uLL;
      }
    }

    unint64_t v29 = v69;
  }

  else
  {
    uint64_t v70 = 0LL;
    unint64_t v32 = 0LL;
  }

  unint64_t v33 = v21 / v29;
  unint64_t v8 = v32;
  uint64_t v34 = sub_10001007C(v73, v21 / v29, v32, v10, (uint64_t)v81);
  if ((_DWORD)v34)
  {
    uint64_t v17 = v34;
    strerror(v34);
    sub_100013D94("%s:%d: metadata space calculation failed: %d - %s\n");
    goto LABEL_60;
  }

  unint64_t v35 = v8;
  LODWORD(v8) = v73;
  uint64_t v36 = sub_100036A8C(0xC800u, 0xC350u, v73, &v80);
  if (!(_DWORD)v36)
  {
    v75[2] = (uint64_t *)1;
    memset((char *)v87 + 8, 0, 56);
    *(void *)&__int128 v85 = __PAIR64__(v73, v20);
    *((void *)&v86 + 1) = v79;
    *(void *)&v87[0] = 1LL;
    *((void *)&v85 + 1) = v35 + v33;
    *(void *)&__int128 v86 = v13;
    else {
      uuid_generate((unsigned __int8 *)&v87[2]);
    }
    if (v70)
    {
      uuid_generate((unsigned __int8 *)&v87[3]);
      HIBYTE(v87[3]) &= ~1u;
    }

    uint64_t v43 = sub_100039908( v80,  0x80000000,  1uLL,  (uint64_t)&xmmword_10005B780,  (uint64_t)&v85,  v73,  (uint64_t)v75[2],  (uint64_t *)&v77);
    if ((_DWORD)v43)
    {
      uint64_t v17 = v43;
      strerror(v43);
      sub_100013D94("%s:%d: object cache bootstrap failed: %d - %s\n");
      goto LABEL_60;
    }

    uint64_t v44 = v77;
    *((_BYTE *)v77 + 624) = 1;
    uint64_t v45 = (int32x2_t *)v44[47];
    v45[22].i32[1] = *(_DWORD *)&v82[24];
    v45[13] = vmovn_s64(*(int64x2_t *)&v82[8]);
    v45[164] = (int32x2_t)(((_DWORD)v83 << 16) | (*((void *)&v83 + 1) << 32) | 1LL);
    *((_BYTE *)v44 + 625) = a3 != 0LL;
    uint64_t v46 = v80;
    *(void *)v80[6].__opaque = v44;
    *(int32x2_t *)&v46[6].__opaque[8] = v45[11];
    if (v70 && v14)
    {
      uint64_t v17 = 22LL;
      unint64_t v84 = v14 / v73;
    }

    uint64_t v47 = sub_1000429D4((uint64_t)v44, (int64_t)v81, a3, (uint64_t)v75[2], &v45[19]);
    if ((_DWORD)v47)
    {
      uint64_t v17 = v47;
      strerror(v47);
      sub_100013D94("%s:%d: spaceman initialization failed: %d - %s\n");
      goto LABEL_60;
    }

    uint64_t v48 = sub_100044238(v77, (uint64_t *)&v76);
    if ((_DWORD)v48)
    {
      uint64_t v17 = v48;
      sub_100013D94("%s:%d: failed to get spaceman: %d\n");
      goto LABEL_60;
    }

    int v49 = sub_1000310A8(v77);
    if (v49) {
      sub_100013D94("%s:%d: failed to set up sm allocation metadata: %d\n", "nx_format", 295, v49);
    }
    uint64_t v50 = sub_10004E2FC((uint64_t)v77, (uint64_t)v75[2], v77 + 50);
    if ((_DWORD)v50)
    {
      uint64_t v17 = v50;
      strerror(v50);
      sub_100013D94("%s:%d: tx manager initialization failed: %d - %s\n");
LABEL_105:
      sub_100038824(v76);
      goto LABEL_60;
    }

    v75[2] = 0LL;
    uint64_t v51 = sub_10004FD18((uint64_t)v77, (uint64_t *)&v75[2]);
    if ((_DWORD)v51)
    {
      uint64_t v17 = v51;
      strerror(v51);
      sub_100013D94("%s:%d: tx_enter for initialization failed: %d - %s\n");
      goto LABEL_105;
    }

    int v52 = v77;
    uint64_t v53 = v77[47];
    if ((*(_DWORD *)(v53 + 104) & 0x80000000) != 0)
    {
      uint64_t v17 = sub_100012860((uint64_t)v77, (uint64_t *)(v53 + 112), (uint64_t)v75[2]);
      if ((_DWORD)v17) {
        goto LABEL_130;
      }
      int v52 = v77;
      uint64_t v53 = v77[47];
    }

    if ((*(_DWORD *)(v53 + 108) & 0x80000000) != 0)
    {
      uint64_t v17 = sub_100012860((uint64_t)v52, (uint64_t *)(v53 + 120), (uint64_t)v75[2]);
      if ((_DWORD)v17) {
        goto LABEL_130;
      }
      int v52 = v77;
    }

    uint64_t v54 = v76[47];
    if ((*(_DWORD *)(v54 + 164) & 0x80000000) != 0)
    {
      uint64_t v17 = sub_100012860((uint64_t)v52, (uint64_t *)(v54 + 168), (uint64_t)v75[2]);
      if ((_DWORD)v17) {
        goto LABEL_130;
      }
      int v52 = v77;
      uint64_t v54 = v76[47];
    }

    if ((*(void *)(v54 + 152) & 0x8000000000000000LL) == 0)
    {
LABEL_110:
      uint64_t v55 = sub_100012E9C(v52, 0LL, 1, 0, 1);
      uint64_t v17 = v55;
      if (v70 && !(_DWORD)v55) {
        uint64_t v17 = sub_100012E9C(v77, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v77[47] + 36LL))), 1, 0, 1);
      }
      if (v70 && !(_DWORD)v17) {
        uint64_t v17 = sub_100012E9C( v77,  *(void *)(v77[47] + 1368LL),  *(void *)(v77[47] + 1376LL) & 0x7FFFFFFF,  (*(void *)(v77[47] + 1376LL) & 0x80000000LL) != 0,  0);
      }
      if ((_DWORD)v17
        || (uint64_t v17 = sub_100012E9C( v77,  *(void *)(v77[47] + 112LL),  *(_DWORD *)(v77[47] + 104LL) & 0x7FFFFFFF,  *(int *)(v77[47] + 104LL) < 0,  0),  (_DWORD)v17)
        || (uint64_t v17 = sub_100012E9C( v77,  *(void *)(v77[47] + 120LL),  *(_DWORD *)(v77[47] + 108LL) & 0x7FFFFFFF,  *(int *)(v77[47] + 108LL) < 0,  0),  (_DWORD)v17)
        || (uint64_t v17 = sub_100012E9C( v77,  *(void *)(v76[47] + 168),  *(_DWORD *)(v76[47] + 164) & 0x7FFFFFFF,  *(int *)(v76[47] + 164) < 0,  0),  (_DWORD)v17))
      {
        sub_100038824(v76);
      }

      else
      {
        uint64_t v17 = sub_100012E9C( v77,  *(void *)(v76[47] + 176),  *(void *)(v76[47] + 152),  *(uint64_t *)(v76[47] + 152) < 0,  0);
        sub_100038824(v76);
        if (!(_DWORD)v17)
        {
          sub_10001312C((const char *)v77);
          uint64_t v57 = sub_10004E6B0(v77, *(_DWORD *)(v77[47] + 104LL) & 0x7FFFFFFF);
          if ((_DWORD)v57)
          {
            uint64_t v17 = v57;
            strerror(v57);
            sub_100013D94("%s:%d: tx checkpoint descriptor area initialization failed: %d - %s\n");
          }

          else
          {
            uint64_t v58 = sub_10003A068( (pthread_mutex_t *)v77[49],  0x80000000,  0LL,  (uint64_t)&xmmword_10005B790,  0LL,  0LL,  (uint64_t)v75[2],  (uint64_t *)&v75[1]);
            if ((_DWORD)v58)
            {
              uint64_t v17 = v58;
              strerror(v58);
              sub_100013D94("%s:%d: reaper initialization failed: %d - %s\n");
            }

            else
            {
              uint64_t v59 = sub_10003965C((uint64_t)v75[1]);
              *(void *)(v77[47] + 168LL) = v59;
              sub_100038824(v75[1]);
              uint64_t v60 = sub_100040A44((uint64_t)v77, 0x40000000u, 1, v74, (uint64_t)v75[2], v75);
              if ((_DWORD)v60)
              {
                uint64_t v17 = v60;
                strerror(v60);
                sub_100013D94("%s:%d: omap initialization failed: %d - %s\n");
              }

              else
              {
                uint64_t v61 = sub_10003965C((uint64_t)v75[0]);
                *(void *)(v77[47] + 160LL) = v61;
                sub_100038824(v75[0]);
                if (!v70)
                {
                  uint64_t v62 = sub_10004FD28((uint64_t)v77, (uint64_t)v75[2], 0);
                  if ((_DWORD)v62)
                  {
                    uint64_t v17 = v62;
                    strerror(v62);
                    sub_100013D94("%s:%d: tx_leave for omap initialization failed: %d - %s\n");
                  }

                  else
                  {
                    uint64_t v63 = sub_10004F230((uint64_t)v77, 0);
                    if (!(_DWORD)v63)
                    {
                      uint64_t v66 = v77;
                      if (!*((_BYTE *)v77 + 625))
                      {
                        sub_10003E948((uint64_t)v77, v64, v65);
                        uint64_t v67 = sub_100051F74(v77[48], 0LL);
                        if ((_DWORD)v67)
                        {
                          uint64_t v17 = v67;
                          strerror(v67);
                          sub_100013D94("%s:%d: failed to write superblock to block 0: %d - %s\n");
                          goto LABEL_60;
                        }

                        uint64_t v66 = v77;
                      }

                      uint64_t v17 = 0LL;
                      *((_BYTE *)v66 + 624) = 0;
                      *a4 = v66;
                      return v17;
                    }

                    uint64_t v17 = v63;
                    strerror(v63);
                    sub_100013D94("%s:%d: failed to finish first transaction: %d - %s\n");
                  }

LABEL_122:
          sub_10004FD28((uint64_t)v77, (uint64_t)v75[2], 0);
          goto LABEL_60;
        }
      }

      sub_100013D94("%s:%d: failed load container metadata ranges (overlap?): %d\n");
      goto LABEL_122;
    }

    uint64_t v17 = sub_100012860((uint64_t)v52, (uint64_t *)(v54 + 176), (uint64_t)v75[2]);
    if (!(_DWORD)v17)
    {
      int v52 = v77;
      goto LABEL_110;
    }

LABEL_130:
    int v56 = strerror(v17);
    sub_100013D94( "%s:%d: creation of fragmented metadata physical extent list tree(s) failed: %d - %s\n",  "nx_format",  331,  v17,  v56);
    sub_100038824(v76);
    goto LABEL_60;
  }

  uint64_t v17 = v36;
  strerror(v36);
  sub_100013D94("%s:%d: object cache initialization failed: %d - %s\n");
LABEL_8:
  if (v77)
  {
    uint64_t v18 = v77[50];
    if (v18) {
      sub_10004E638((uint64_t)v77, v18, v8);
    }
  }

  if (v80) {
    sub_100037210((uint64_t)v80);
  }
  if (v78) {
    sub_100051D68((uint64_t)v78);
  }
  if (v79) {
    sub_100051D68((uint64_t)v79);
  }
  return v17;
}

unint64_t *sub_100036918(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  return sub_100036970((unint64_t *)(qword_100070558 + 136), a3, a2);
}

unint64_t *sub_100036970(unint64_t *result, int a2, uint64_t a3)
{
  unsigned int v4 = a2 & 0xC8000000;
  if (a2 < 0 != v3)
  {
    if (v4 == 0x80000000)
    {
      uint64_t v18 = result + 29;
      do
        unint64_t v19 = __ldxr(v18);
      while (__stxr(v19 - a3, v18));
      unsigned int v20 = result + 31;
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + a3, v20));
      uint64_t v22 = result + 33;
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    else
    {
      if (v4 != -2013265920) {
        goto LABEL_24;
      }
      unint64_t v5 = result + 35;
      do
        unint64_t v6 = __ldxr(v5);
      while (__stxr(v6 - a3, v5));
      size_t v7 = result + 37;
      do
        unint64_t v8 = __ldxr(v7);
      while (__stxr(v8 + a3, v7));
      int v9 = result + 39;
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
  }

  else
  {
    if (v4 != 0x40000000 && v4 != 0) {
LABEL_24:
    }
      panic("unexpected storagetype: 0x%x\n", a2 & 0xC8000000);
    int v12 = result + 23;
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 - a3, v12));
    unint64_t v14 = result + 25;
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + a3, v14));
    uint64_t v16 = result + 27;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  return result;
}

uint64_t sub_100036A8C(unsigned int a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v8 = sub_100036CE4();
  if (!(_DWORD)v8)
  {
    int v9 = (char *)sub_100013EEC(1uLL, 0x550uLL);
    if (v9)
    {
      unint64_t v10 = v9;
      bzero(v9, 0x550uLL);
      uint64_t v11 = sub_1000139BC((pthread_mutex_t *)v10);
      if ((_DWORD)v11)
      {
        uint64_t v8 = v11;
LABEL_13:
        sub_100014004(v10, 1360LL);
        return v8;
      }

      uint64_t v12 = sub_1000139C8((pthread_rwlock_t *)(v10 + 128));
      if ((_DWORD)v12)
      {
        uint64_t v8 = v12;
LABEL_12:
        j__pthread_mutex_destroy((pthread_mutex_t *)v10);
        goto LABEL_13;
      }

      uint64_t v13 = sub_1000139BC((pthread_mutex_t *)(v10 + 328));
      if ((_DWORD)v13)
      {
        uint64_t v8 = v13;
LABEL_11:
        j__pthread_rwlock_destroy((pthread_rwlock_t *)(v10 + 128));
        goto LABEL_12;
      }

      uint64_t v14 = sub_1000139D4((pthread_cond_t *)v10 + 27);
      if ((_DWORD)v14)
      {
        uint64_t v8 = v14;
        j__pthread_mutex_destroy((pthread_mutex_t *)(v10 + 328));
        goto LABEL_11;
      }

      if (!a1) {
        a1 = 4096;
      }
      unint64_t v15 = sub_100014044(8LL * a1);
      *((void *)v10 + 88) = v15;
      if (v15)
      {
        bzero(v15, 8LL * a1);
        *((_DWORD *)v10 + 174) = a1;
        *((_DWORD *)v10 + 175) = a1 - 1;
        if (a2) {
          unsigned int v16 = a2;
        }
        else {
          unsigned int v16 = 4096;
        }
        *((_DWORD *)v10 + 169) = 128;
        *((_DWORD *)v10 + 170) = v16;
        *((_DWORD *)v10 + 171) = 0;
        *((void *)v10 + 86) = 0LL;
        *((_DWORD *)v10 + 168) = a3;
        sub_100036E88((uint64_t)(v10 + 944), 0x80u, v16, a3);
        unint64_t v17 = sub_100013EEC(0x100uLL, 8uLL);
        *((void *)v10 + 109) = v17;
        if (v17)
        {
          uint64_t v8 = 0LL;
          *((void *)v10 + 93) = v10 + 736;
          *((void *)v10 + 95) = v10 + 752;
          *((void *)v10 + 97) = v10 + 768;
          *((void *)v10 + 99) = v10 + 784;
          *((void *)v10 + 101) = v10 + 800;
          *((void *)v10 + 103) = v10 + 816;
          *((void *)v10 + 169) = v10 + 1344;
          *((void *)v10 + 107) = v10 + 848;
          *((void *)v10 + 105) = v10 + 832;
          *(_OWORD *)(v10 + 712) = 0u;
          *((void *)v10 + 94) = 0LL;
          *((void *)v10 + 96) = 0LL;
          *((void *)v10 + 98) = 0LL;
          *((void *)v10 + 100) = 0LL;
          *((void *)v10 + 102) = 0LL;
          *((void *)v10 + 168) = 0LL;
          *((void *)v10 + 106) = 0LL;
          *((void *)v10 + 104) = 0LL;
          *((void *)v10 + 92) = 0LL;
          *((void *)v10 + 91) = 0LL;
          *((int64x2_t *)v10 + 25) = vdupq_n_s64(0x400uLL);
          *a4 = v10;
          return v8;
        }

        sub_100014004(*((void **)v10 + 88), 8LL * a1);
      }

      sub_1000139DC((pthread_cond_t *)v10 + 27);
      j__pthread_mutex_destroy((pthread_mutex_t *)(v10 + 328));
      j__pthread_rwlock_destroy((pthread_rwlock_t *)(v10 + 128));
      j__pthread_mutex_destroy((pthread_mutex_t *)v10);
      sub_100014004(v10, 1360LL);
    }

    return 12LL;
  }

  return v8;
}

uint64_t sub_100036CE4()
{
  if (!atomic_load((unint64_t *)&qword_100070558))
  {
    char v3 = (char *)sub_100013EEC(1uLL, 0x1E0uLL);
    if (!v3) {
      return 12LL;
    }
    unint64_t v4 = (unint64_t)v3;
    unint64_t v5 = (pthread_mutex_t *)(v3 + 8);
    *((_OWORD *)v3 + 28) = 0u;
    *((_OWORD *)v3 + 29) = 0u;
    *((_OWORD *)v3 + 26) = 0u;
    *((_OWORD *)v3 + 27) = 0u;
    *((_OWORD *)v3 + 24) = 0u;
    *((_OWORD *)v3 + 25) = 0u;
    *((_OWORD *)v3 + 22) = 0u;
    *((_OWORD *)v3 + 23) = 0u;
    *((_OWORD *)v3 + 20) = 0u;
    *((_OWORD *)v3 + 21) = 0u;
    *((_OWORD *)v3 + 18) = 0u;
    *((_OWORD *)v3 + 19) = 0u;
    *((_OWORD *)v3 + 16) = 0u;
    *((_OWORD *)v3 + 17) = 0u;
    *((_OWORD *)v3 + 14) = 0u;
    *((_OWORD *)v3 + 15) = 0u;
    *((_OWORD *)v3 + 12) = 0u;
    *((_OWORD *)v3 + 13) = 0u;
    *((_OWORD *)v3 + 10) = 0u;
    *((_OWORD *)v3 + 11) = 0u;
    *((_OWORD *)v3 + 8) = 0u;
    *((_OWORD *)v3 + 9) = 0u;
    *((_OWORD *)v3 + 6) = 0u;
    *((_OWORD *)v3 + 7) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *(_OWORD *)char v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    uint64_t v6 = sub_1000139BC((pthread_mutex_t *)(v3 + 8));
    if ((_DWORD)v6)
    {
      uint64_t v1 = v6;
      sub_100013D94("%s:%d: object memory manager failed to create lock, error: %d\n", "obj_mem_mgr_init", 7179, v6);
      sub_100014004((void *)v4, 480LL);
      return v1;
    }

    *(void *)(v4 + 72) = 0LL;
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    *(_OWORD *)(v4 + 136) = 0u;
    *(_OWORD *)(v4 + 440) = 0u;
    *(_OWORD *)(v4 + 456) = 0u;
    *(_OWORD *)(v4 + 408) = 0u;
    *(_OWORD *)(v4 + 424) = 0u;
    *(_OWORD *)(v4 + 376) = 0u;
    *(_OWORD *)(v4 + 392) = 0u;
    *(_OWORD *)(v4 + 344) = 0u;
    *(_OWORD *)(v4 + 360) = 0u;
    *(_OWORD *)(v4 + 312) = 0u;
    *(_OWORD *)(v4 + 328) = 0u;
    *(_OWORD *)(v4 + 280) = 0u;
    *(_OWORD *)(v4 + 296) = 0u;
    *(_OWORD *)(v4 + 248) = 0u;
    *(_OWORD *)(v4 + 264) = 0u;
    *(_OWORD *)(v4 + 216) = 0u;
    *(_OWORD *)(v4 + 232) = 0u;
    *(_OWORD *)(v4 + 184) = 0u;
    *(_OWORD *)(v4 + 200) = 0u;
    *(_OWORD *)(v4 + 152) = 0u;
    *(_OWORD *)(v4 + 168) = 0u;
    *(void *)(v4 + 464) = tv_sec;
    *(void *)(v4 + 472) = 0LL;
    do
    {
      if (__ldxr((unint64_t *)&qword_100070558))
      {
        __clrex();
        atomic_load((unint64_t *)&qword_100070558);
        j__pthread_mutex_destroy(v5);
        sub_100014004((void *)v4, 480LL);
        return 0LL;
      }
    }

    while (__stlxr(v4, (unint64_t *)&qword_100070558));
    if ((*(_DWORD *)qword_100070558 & 4) != 0) {
      sub_100013CBC( "%s:%d: object memory manager initialized with feature flags: 0x%x, apfs_mem_max: %lld\n",  "obj_mem_mgr_init",  7200,  *(_DWORD *)qword_100070558,  *(void *)(qword_100070558 + 96));
    }
  }

  return 0LL;
}

double sub_100036E88(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  v11.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v11.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v11);
  __darwin_time_t tv_sec = v11.tv_sec;
  double result = 0.0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v10 = a4 * (unint64_t)a3;
  *(void *)(a1 + 8) = a4 * (unint64_t)a2;
  *(void *)(a1 + 16) = v10;
  *(void *)a1 = v10;
  *(void *)(a1 + 328) = tv_sec;
  *(void *)(a1 + 336) = 0LL;
  return result;
}

uint64_t sub_100036F1C(uint64_t result, int a2, int a3, int a4)
{
  if ((a2 & 0x8000000) != 0)
  {
    *(_DWORD *)(result + 692) += a4;
  }

  else
  {
    *(_DWORD *)(result + 688) += a4;
    uint64_t v4 = *(void *)(result + 392);
    if (v4)
    {
      int v6 = *(_DWORD *)(result + 900);
      if (a4 < 0) {
        int v7 = v6 - v5;
      }
      else {
        int v7 = v6 + v5;
      }
    }

    else
    {
      int v7 = *(_DWORD *)(result + 900) + a4;
    }

    *(_DWORD *)(result + 900) = v7;
  }

  return result;
}

void sub_100036F84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 720);
  if (v1)
  {
    *(void *)(a1 + 720) = 0LL;
    *(void *)(a1 + 728) = 0LL;
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    do
    {
      uint64_t v2 = *(void *)(v1 + 72);
      sub_10003EE28(v1, 0);
      uint64_t v1 = v2;
    }

    while (v2);
  }

  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)a1);
  }

uint64_t sub_100036FD4(pthread_mutex_t *a1, int a2)
{
  if (a2 != 2 && a2 != 1) {
    panic("obj_cache_lock_by_state, invalid oc_lock_state %d\n", a2);
  }
  return pthread_mutex_lock(a1);
}

  ;
}

void sub_100037014(pthread_mutex_t *a1, int a2)
{
  if (a2 == 2)
  {
    sub_100036F84((uint64_t)a1);
  }

  else
  {
    if (a2 != 1) {
      panic("obj_cache_unlock_by_state, invalid oc_lock_state %d\n", a2);
    }
    pthread_mutex_unlock(a1);
  }

void sub_100037058(pthread_mutex_t *a1, int a2)
{
  if (!a2)
  {
    pthread_mutex_lock(a1);
    uint64_t v4 = (unsigned int *)&a1[14].__opaque[8];
    do
      unsigned int v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  int v6 = (unsigned int *)&a1[14].__opaque[12];
  do
    unsigned int v7 = __ldxr(v6);
  while (__stxr(v7, v6));
  if (v7)
  {
    do
    {
      char v23 = 1;
      uint64_t sig = a1[21].__sig;
      if (sig)
      {
        if ((*(_BYTE *)(*(void *)(sig + 136) + 20LL) & 0x80) == 0)
        {
          sub_10003DAB0(sig, &v23);
          if (!v23) {
            pthread_mutex_lock(a1);
          }
        }
      }

      do
        unsigned int v9 = __ldxr(v6);
      while (__stxr(v9, v6));
    }

    while (v9);
  }

  if (a1[11].__sig)
  {
    unint64_t v10 = *(unsigned int *)&a1[10].__opaque[48];
    if ((_DWORD)v10)
    {
      for (unint64_t i = 0LL; i < v10; ++i)
      {
        uint64_t v12 = *(void *)(a1[11].__sig + 8 * i);
        if (v12)
        {
          do
          {
            uint64_t v13 = *(void *)(v12 + 72);
            if (v12 != *(void *)a1[6].__opaque)
            {
              uint64_t v14 = *(void *)(v12 + 16);
              if ((v14 & 0x80000000) != 0) {
                sub_100036F1C((uint64_t)a1, v14, *(_DWORD *)(v12 + 48), -1);
              }
              else {
                --*(_DWORD *)&a1[10].__opaque[36];
              }
              sub_10003CCD4(v12, 0);
            }

            uint64_t v12 = v13;
          }

          while (v13);
          unint64_t v10 = *(unsigned int *)&a1[10].__opaque[48];
        }
      }
    }
  }

  uint64_t v15 = *(void *)a1[11].__opaque;
  if (v15)
  {
    do
    {
      uint64_t v16 = *(void *)(v15 + 72);
      --*(_DWORD *)&a1[10].__opaque[36];
      sub_10003CCD4(v15, 0);
      uint64_t v15 = v16;
    }

    while (v16);
  }

  uint64_t v17 = *(void *)&a1[11].__opaque[24];
  if (v17)
  {
    do
    {
      uint64_t v18 = *(void *)(v17 + 88);
      if (v17 != *(void *)a1[6].__opaque) {
        sub_10003CCD4(v17, 0);
      }
      uint64_t v17 = v18;
    }

    while (v18);
  }

  uint64_t v19 = *(void *)&a1[11].__opaque[40];
  if (v19)
  {
    do
    {
      uint64_t v20 = *(void *)(v19 + 88);
      sub_10003CCD4(v19, 0);
      uint64_t v19 = v20;
    }

    while (v20);
  }

  if (!a2)
  {
    sub_100036F84((uint64_t)a1);
    unint64_t v21 = (unsigned int *)&a1[14].__opaque[8];
    do
      unsigned int v22 = __ldxr(v21);
    while (__stxr(v22 - 1, v21));
  }

void sub_100037210(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 1288);
  if ((v2 & 1) == 0) {
    goto LABEL_7;
  }
  *(void *)(a1 + 1288) = v2 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v3 = *(void *)(a1 + 928);
  if (v3) {
    *(void *)(v3 + 936) = *(void *)(a1 + 936);
  }
  **(void **)(a1 + 936) = v3;
  if ((v2 & 2) != 0)
  {
    *(void *)(a1 + 1288) = v2 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_7:
    uint64_t v4 = qword_100070558;
    goto LABEL_8;
  }

  uint64_t v4 = qword_100070558;
  --*(void *)(qword_100070558 + 104);
  *(int64x2_t *)(v4 + 136) = vsubq_s64(*(int64x2_t *)(v4 + 136), *(int64x2_t *)(a1 + 944));
  *(void *)(v4 + 152) -= *(void *)(a1 + 960);
LABEL_8:
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  pthread_mutex_lock((pthread_mutex_t *)a1);
  unsigned int v5 = (unsigned int *)(a1 + 912);
  do
    unsigned int v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  sub_100037058((pthread_mutex_t *)a1, 1);
  uint64_t v7 = *(void *)(a1 + 392);
  if (v7)
  {
    sub_100036F1C(a1, *(void *)(v7 + 16), *(_DWORD *)(v7 + 48), -1);
    sub_10003CCD4(*(void *)(a1 + 392), 0);
  }

  uint64_t v8 = *(void **)(a1 + 704);
  if (v8) {
    sub_100014004(v8, 8LL * *(unsigned int *)(a1 + 696));
  }
  sub_100036F84(a1);
  unsigned int v9 = *(void **)(a1 + 872);
  if (v9) {
    sub_100014004(v9, 2048LL);
  }
  sub_1000139DC((pthread_cond_t *)(a1 + 1296));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 328));
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 128));
  j__pthread_mutex_destroy((pthread_mutex_t *)a1);
  sub_100014004((void *)a1, 1360LL);
}

uint64_t sub_100037354(uint64_t a1, unsigned int a2, char a3, uint64_t a4)
{
  unsigned int v94 = -1431655766;
  if ((a2 & 0x80000000) != 0) {
    return 22LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)a1);
  if (*(_DWORD *)(a1 + 908))
  {
    if (a2)
    {
      sub_100036F84(a1);
      return 0LL;
    }

    do
    {
      *(_DWORD *)(a1 + 908) = 2;
      sub_100013AD4((pthread_cond_t *)(a1 + 1296), (pthread_mutex_t *)a1, 2LL, 0LL);
    }

    while (*(_DWORD *)(a1 + 908));
  }

  *(_DWORD *)(a1 + 908) = 1;
  uint64_t v90 = (pthread_rwlock_t *)(a1 + 128);
  int v9 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v9) {
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c", 1097, v9);
  }
  uint64_t v89 = a4;
  if (!a2)
  {
    int v11 = 0;
    if ((a3 & 1) == 0)
    {
      int v10 = 0;
      goto LABEL_17;
    }

    uint64_t v13 = 0LL;
LABEL_95:
    uint64_t v38 = *(void **)(a1 + 816);
    if (a2) {
      BOOL v39 = v11 < 1;
    }
    else {
      BOOL v39 = 0;
    }
    char v40 = v39;
    if (v38 && (v40 & 1) == 0)
    {
      if (a2) {
        int v41 = -1;
      }
      else {
        int v41 = 0;
      }
      int v93 = v41;
      do
      {
        if (*((_DWORD *)v38 + 9) >> 30 != 1) {
          panic( "non-physical object on physical object dirty list: oid %lld flags 0x%llx 0x%x\n",  v38[14],  v38[2],  *((_DWORD *)v38 + 8));
        }
        uint64_t v43 = (unsigned int *)(v38 + 4);
        int v42 = *((_DWORD *)v38 + 8);
        if ((v42 & 1) == 0) {
          panic("physical object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\n", v38[14], v38[2], v42);
        }
        uint64_t v45 = v38 + 13;
        uint64_t v44 = (const void *)v38[13];
        unint64_t v46 = v38[2];
        if ((v44 == (const void *)3735928559LL) == ((v46 >> 41) & 1)) {
          panic( "dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\n",  v38[14],  v46,  *((_DWORD *)v38 + 8),  v44);
        }
        if ((v46 & 0x20000000000LL) == 0 || *v45 == 3735928559LL)
        {
          unsigned int v94 = 16000;
          if (sub_100037DD0(v38, (int *)&v94, 1, 2))
          {
            do
            {
              if (v94 > 0x773593FF)
              {
                uint64_t v47 = v38[1];
                if (!v47) {
                  uint64_t v47 = *(void *)(*v38 + 392LL);
                }
                if (sub_100013538(*(void *)(*(void *)v47 + 392LL)))
                {
                  if (*(_WORD *)(v47 + 36) == 13) {
                    uint64_t v48 = (const char *)(v47 + 3992);
                  }
                  else {
                    uint64_t v48 = (const char *)(*(void *)(v47 + 384) + 208LL);
                  }
                  sub_100013CBC( "%s:%d: %s oid %lld flags 0x%llx 0x%x refs 0x%llx taking too long to get reference!\n",  "obj_cache_flush_prepare",  1276,  v48,  v38[14],  v38[2],  *((_DWORD *)v38 + 8),  v38[3]);
                }
              }
            }

            while ((sub_100037DD0(v38, (int *)&v94, 1, 2) & 1) != 0);
          }
        }

        if (!*(_DWORD *)(a1 + 888)) {
          panic("physical object dirty count underflow\n");
        }
        uint64_t v49 = v38[11];
        uint64_t v50 = (void *)v38[12];
        if (v49)
        {
          *(void *)(v49 + 96) = v50;
          uint64_t v50 = (void *)v38[12];
        }

        else
        {
          *(void *)(a1 + 824) = v50;
        }

        *uint64_t v50 = v49;
        --*(_DWORD *)(a1 + 888);
        v38[11] = 3735928559LL;
        do
          unsigned int v51 = __ldxr(v43);
        while (__stxr(v51 & 0xFFFFFFFE, v43));
        v38[2] |= 0x20000000000uLL;
        if ((a3 & 2) != 0) {
          v38[8] = v38[7];
        }
        if (*v45 == 3735928559LL)
        {
          v38[13] = 0LL;
          **(void **)(a1 + 840) = v38;
          *(void *)(a1 + 840) = v45;
          ++*(_DWORD *)(a1 + 904);
        }

        v11 += v93;
        uint64_t v38 = *(void **)(a1 + 816);
        if (a2) {
          BOOL v52 = v11 < 1;
        }
        else {
          BOOL v52 = 0;
        }
        int v53 = v52;
      }

      while (v38 && !v53);
    }

    int v54 = pthread_rwlock_unlock(v90);
    if (v54) {
      panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  1305,  v54);
    }
    sub_100036F84(a1);
    uint64_t v57 = v13 + 13;
    if (!v13) {
      uint64_t v57 = (uint64_t **)(a1 + 832);
    }
    uint64_t v58 = *v57;
    if (*v57)
    {
      while (1)
      {
        uint64_t v59 = sub_100037FCC(v58, 0, v89, v55, v56);
        if ((_DWORD)v59) {
          break;
        }
        if ((a3 & 2) != 0)
        {
          uint64_t v60 = v58[19];
          if (!v60) {
            uint64_t v60 = v58[16];
          }
          v58[17] = v60;
        }

        uint64_t v58 = (uint64_t *)v58[13];
        if (!v58) {
          goto LABEL_155;
        }
      }

      uint64_t v8 = v59;
      if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 400LL) + 76LL))
      {
        uint64_t v88 = v58[1];
        if (!v88) {
          uint64_t v88 = *(void *)(*v58 + 392);
        }
      }

      return v8;
    }

LABEL_155:
    int v61 = *(_DWORD *)(a1 + 904);
    if (v61 >= 2)
    {
      uint64_t v62 = 0LL;
      uint64_t v63 = *(void **)(a1 + 832);
      for (int i = 1; i < v61; i *= 2)
      {
        if (v63)
        {
          int8x16_t v65 = 0LL;
          char v66 = 1;
          uint64_t v67 = v63;
          while (1)
          {
            int v68 = i;
            unint64_t v69 = v67;
            if (i >= 2) {
              break;
            }
            uint64_t v70 = (void *)v67[13];
            unint64_t v69 = v67;
            unint64_t v72 = v70;
            if (!v70) {
              goto LABEL_205;
            }
LABEL_167:
            uint64_t v74 = v67[19];
            if (!v74) {
              uint64_t v74 = v67[16];
            }
            uint64_t v75 = v70[19];
            if (!v75) {
              uint64_t v75 = v70[16];
            }
            unint64_t v76 = (void *)v72[13];
            BOOL v77 = v74 <= v75;
            if (v74 > v75) {
              uint64_t v78 = v70;
            }
            else {
              uint64_t v78 = (void *)v72[13];
            }
            if (v74 > v75) {
              uint64_t v79 = v67;
            }
            else {
              uint64_t v79 = v70;
            }
            if (v77) {
              uint64_t v62 = v72;
            }
            else {
              uint64_t v62 = v69;
            }
            if (!v77)
            {
              unint64_t v69 = v72;
              uint64_t v67 = v70;
            }

            if (v67 == v69 || v79 == v78)
            {
              uint64_t v81 = v67;
            }

            else
            {
              uint64_t v80 = v67;
              do
              {
                uint64_t v81 = (void *)v80[13];
                uint64_t v82 = v81[19];
                if (!v82) {
                  uint64_t v82 = v81[16];
                }
                uint64_t v83 = v79[19];
                if (!v83) {
                  uint64_t v83 = v79[16];
                }
                if (v82 > v83)
                {
                  unint64_t v84 = (void *)v79[13];
                  v79[13] = v81;
                  v80[13] = v79;
                  uint64_t v81 = v79;
                  uint64_t v79 = v84;
                }

                BOOL v85 = v81 == v69 || v79 == v78;
                uint64_t v80 = v81;
              }

              while (!v85);
            }

            if (v81 == v69) {
              v69[13] = v79;
            }
            else {
              uint64_t v62 = v69;
            }
            __int128 v86 = v65 + 13;
            if ((v66 & 1) != 0)
            {
              __int128 v86 = (void *)(a1 + 832);
              uint64_t v63 = v67;
            }

            *__int128 v86 = v67;
            int8x16_t v65 = v62;
            uint64_t v67 = v76;
            char v66 = 0;
            if (!v76)
            {
              int8x16_t v65 = v62;
              goto LABEL_205;
            }
          }

          while (1)
          {
            unint64_t v69 = (void *)v69[13];
            if (!v69) {
              break;
            }
            if (--v68 < 2)
            {
              uint64_t v70 = (void *)v69[13];
              int v71 = i;
              unint64_t v72 = v70;
              if (!v70) {
                break;
              }
              while (1)
              {
                uint64_t v73 = (void *)v72[13];
                if (!v73) {
                  goto LABEL_167;
                }
                --v71;
                unint64_t v72 = (void *)v72[13];
                if (v71 < 2)
                {
                  unint64_t v72 = v73;
                  goto LABEL_167;
                }
              }
            }
          }

LABEL_205:
          if (v65) {
            v65[13] = v67;
          }
        }
      }

      if (v62)
      {
        uint64_t v8 = 0LL;
        *(void *)(a1 + 840) = v62 + 13;
        return v8;
      }
    }

    return 0LL;
  }

  if ((a3 & 1) != 0)
  {
    uint64_t v13 = 0LL;
    int v11 = a2;
    goto LABEL_95;
  }

  if (*(_DWORD *)(a1 + 884) >= a2) {
    int v10 = a2;
  }
  else {
    int v10 = *(_DWORD *)(a1 + 884);
  }
  int v11 = a2 - v10;
LABEL_17:
  int v12 = 0;
  uint64_t v13 = 0LL;
  uint64_t v92 = 0LL;
  if (a2) {
    int v14 = -1;
  }
  else {
    int v14 = 0;
  }
  int v91 = v14;
  while (2)
  {
    uint64_t v15 = *(void *)(a1 + 800);
    if (!v15) {
      goto LABEL_73;
    }
    while (!a2 || v10 >= 1)
    {
      if (*(_DWORD *)(v15 + 36) >> 30) {
        panic( "non-virtual object on virtual object dirty list: oid %lld flags 0x%llx 0x%x\n",  *(void *)(v15 + 112),  *(void *)(v15 + 16),  *(_DWORD *)(v15 + 32));
      }
      uint64_t v17 = (unsigned int *)(v15 + 32);
      int v16 = *(_DWORD *)(v15 + 32);
      if ((v16 & 1) == 0) {
        panic( "virtual object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\n",  *(void *)(v15 + 112),  *(void *)(v15 + 16),  v16);
      }
      if (v12)
      {
        if (v12 > 1) {
          goto LABEL_36;
        }
      }

      else
      {
        uint64_t v18 = *(void *)(v15 + 8);
        if (!v18) {
          goto LABEL_53;
        }
        if (*(void *)(v18 + 496)) {
          uint64_t v18 = *(void *)(v18 + 496);
        }
        if ((*(_BYTE *)(*(void *)(v18 + 376) + 264LL) & 1) != 0) {
          goto LABEL_53;
        }
      }

      if (*(_WORD *)(v15 + 36) == 13)
      {
LABEL_53:
        uint64_t v15 = *(void *)(v15 + 88);
        *(void *)(a1 + 864) = v15;
        if (!v15) {
          goto LABEL_73;
        }
      }

      else
      {
LABEL_36:
        if (a2)
        {
          uint64_t v19 = (unint64_t *)(v15 + 24);
          do
            unint64_t v20 = __ldxr(v19);
          while (__stxr(v20, v19));
          if ((v20 & 0xFFFFFF) != ((v20 >> 24) & 0xFFFFF)) {
            goto LABEL_53;
          }
        }

        unsigned int v22 = (void *)(v15 + 104);
        unint64_t v21 = *(const void **)(v15 + 104);
        unint64_t v23 = *(void *)(v15 + 16);
        if ((v21 == (const void *)3735928559LL) == ((v23 >> 41) & 1)) {
          panic( "dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\n",  *(void *)(v15 + 112),  v23,  *(_DWORD *)(v15 + 32),  v21);
        }
        if ((v23 & 0x20000000000LL) != 0 && *v22 != 3735928559LL) {
          goto LABEL_55;
        }
        if (v15 != v92) {
          unsigned int v94 = 16000;
        }
        *(void *)(a1 + 864) = v15;
        uint64_t v92 = v15;
        if (sub_100037DD0((void *)v15, (int *)&v94, 1, 2))
        {
          if (v94 > 0x773593FF)
          {
            uint64_t v24 = *(void *)(v15 + 8);
            if (!v24) {
              uint64_t v24 = *(void *)(*(void *)v15 + 392LL);
            }
            if (sub_100013538(*(void *)(*(void *)v24 + 392LL)))
            {
              if (*(_WORD *)(v24 + 36) == 13) {
                unint64_t v25 = (const char *)(v24 + 3992);
              }
              else {
                unint64_t v25 = (const char *)(*(void *)(v24 + 384) + 208LL);
              }
              sub_100013CBC( "%s:%d: %s oid %lld flags 0x%llx 0x%x refs 0x%llx taking too long to get reference!\n",  "obj_cache_flush_prepare",  1187,  v25,  *(void *)(v15 + 112),  *(void *)(v15 + 16),  *(_DWORD *)(v15 + 32),  *(void *)(v15 + 24));
            }
          }

          uint64_t v92 = v15;
        }

        else
        {
LABEL_55:
          uint64_t v26 = *(void *)(v15 + 88);
          *(void *)(a1 + 864) = v26;
          if (!*(_DWORD *)(a1 + 884)) {
            panic("virtual object dirty count underflow\n");
          }
          unsigned int v27 = *(void **)(v15 + 96);
          if (v26)
          {
            *(void *)(v26 + 96) = v27;
            unsigned int v27 = *(void **)(v15 + 96);
          }

          else
          {
            *(void *)(a1 + 808) = v27;
          }

          *unsigned int v27 = v26;
          --*(_DWORD *)(a1 + 884);
          *(void *)(v15 + 88) = 3735928559LL;
          do
            unsigned int v28 = __ldxr(v17);
          while (__stxr(v28 & 0xFFFFFFFE, v17));
          *(void *)(v15 + 16) |= 0x20000000000uLL;
          if ((a3 & 2) != 0) {
            *(void *)(v15 + 64) = *(void *)(v15 + 56);
          }
          if (*v22 == 3735928559LL)
          {
            *(void *)(v15 + 104) = 0LL;
            **(void **)(a1 + 840) = v15;
            *(void *)(a1 + 840) = v22;
            ++*(_DWORD *)(a1 + 904);
          }

          v10 += v91;
        }

        uint64_t v15 = *(void *)(a1 + 864);
        if (!v15) {
          goto LABEL_73;
        }
      }
    }

    int v12 = 3;
LABEL_73:
    int v29 = pthread_rwlock_unlock(v90);
    if (v29) {
      panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  1217,  v29);
    }
    sub_100036F84(a1);
    unint64_t v32 = v13 + 13;
    if (!v13) {
      unint64_t v32 = (uint64_t **)(a1 + 832);
    }
    unint64_t v33 = *v32;
    if (!v33)
    {
LABEL_84:
      pthread_mutex_lock((pthread_mutex_t *)a1);
      int v36 = pthread_rwlock_wrlock(v90);
      if (v36) {
        panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  1244,  v36);
      }
      BOOL v39 = v12++ < 2;
      if (!v39) {
        goto LABEL_95;
      }
      continue;
    }

    break;
  }

  while (1)
  {
    uint64_t v13 = (uint64_t **)v33;
    uint64_t v34 = sub_100037FCC(v33, 0, v89, v30, v31);
    if ((_DWORD)v34) {
      break;
    }
    if ((a3 & 2) != 0)
    {
      unint64_t v35 = v13[19];
      if (!v35) {
        unint64_t v35 = v13[16];
      }
      v13[17] = v35;
    }

    unint64_t v33 = v13[13];
    if (!v33) {
      goto LABEL_84;
    }
  }

  uint64_t v8 = v34;
  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 400LL) + 76LL))
  {
    unint64_t v37 = v13[1];
    if (!v37) {
      unint64_t v37 = (uint64_t *)(*v13)[49];
    }
    if (sub_100013538(*(void *)(*v37 + 392))) {
LABEL_216:
    }
      sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error preparing for write: %d\n",  "obj_cache_flush_prepare");
  }

  return v8;
}

uint64_t sub_100037DC0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_100037DC8(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 36);
}

uint64_t sub_100037DD0(void *a1, int *a2, int a3, int a4)
{
  uint64_t v8 = a1 + 3;
  uint64_t v7 = *a1;
  do
    unint64_t v9 = __ldxr(v8);
  while (__stxr(v9 + 16777217, v8));
  if ((v9 & 0xFFFFFF) == 0xFFFFFF) {
    panic("Reference count overflowed for object %p!\n", a1);
  }
  uint64_t v10 = (v9 >> 24) & 0xFFFFF;
  if (v10 == 0xFFFFF) {
    panic("Get count overflowed for object %p!\n", a1);
  }
  if ((-(v9 >> 44) & 0xFFFFF) == 0 || (v9 & 0xFFFFFF) != v10) {
    goto LABEL_37;
  }
  do
    unint64_t v12 = __ldxr(v8);
  while (__stxr(v12, v8));
  if ((-(v12 >> 44) & 0xFFFFF) != 0)
  {
    uint64_t v13 = (unsigned int *)(a1 + 4);
    do
      unsigned int v14 = __ldxr(v13);
    while (__stxr(v14 | 2, v13));
    do
      unint64_t v15 = __ldxr(v8);
    while (__stxr(v15 - 16777217, v8));
    if (a3)
    {
      int v16 = pthread_rwlock_unlock((pthread_rwlock_t *)(v7 + 128));
      if (v16) {
        panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  3966,  v16);
      }
    }

    uint64_t v17 = *a2 % 0x3B9ACA00u;
    v23.__darwin_time_t tv_sec = *a2 / 0x3B9ACA00uLL;
    v23.uint64_t tv_nsec = v17;
    if (a4 == 1) {
      uint64_t v18 = 1LL;
    }
    else {
      uint64_t v18 = 2LL;
    }
    if (sub_100013AD4((pthread_cond_t *)(v7 + 1296), (pthread_mutex_t *)v7, v18, &v23) == 35
      && *a2 != 2000000000)
    {
      else {
        int v19 = 4 * *a2;
      }
      *a2 = v19;
    }

    if (a3)
    {
      int v20 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v7 + 128));
      if (v20) {
        panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  3983,  v20);
      }
    }

    return 1LL;
  }

  else
  {
LABEL_37:
    do
      unint64_t v22 = __ldxr(v8);
    while (__stxr(v22 - 0x1000000, v8));
    return 0LL;
  }

uint64_t sub_100037FCC(uint64_t *a1, int a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v5 = *(void *)(*a1 + 392);
  if (a1[1]) {
    uint64_t v6 = a1[1];
  }
  else {
    uint64_t v6 = *(void *)(*a1 + 392);
  }
  if (*(_BYTE *)(v5 + 627)) {
    return 30LL;
  }
  unsigned int v14 = a1 + 18;
  unint64_t v13 = a1[18];
  uint64_t v15 = a1[2];
  unint64_t v16 = a1[15];
  unint64_t v48 = v16;
  if (a1[19])
  {
    uint64_t v49 = a1[19];
    goto LABEL_10;
  }

  uint64_t v49 = a1[16];
  if (v49)
  {
LABEL_10:
    if ((v15 & 0xC0000000) != 0)
    {
      uint64_t v47 = v12;
      unint64_t v17 = 0LL;
      unint64_t v18 = 0LL;
      int v19 = 0;
      goto LABEL_12;
    }

LABEL_51:
    uint64_t v47 = v12;
    if (v13 == v16)
    {
      unint64_t v17 = v49;
    }

    else
    {
      unint64_t v17 = v49;
      if (a2 || v13) {
        goto LABEL_60;
      }
    }

    unint64_t v32 = v17;
    unint64_t v17 = 0LL;
    if (v32)
    {
      int v19 = 0;
      goto LABEL_57;
    }

LABEL_100:
      pthread_mutex_lock((pthread_mutex_t *)*a1);
      unint64_t v17 = v18;
      if (!v19) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }

LABEL_57:
    uint64_t v33 = a1[19];
    if (!v33)
    {
      unint64_t v18 = 0LL;
      goto LABEL_12;
    }

    unint64_t v18 = 0LL;
    if (v33 == a1[16])
    {
LABEL_12:
      if ((a1[2] & 0x80020000000LL) == 0)
      {
        uint64_t v20 = a1[7];
        a4.i64[0] = *(uint64_t *)((char *)a1 + 36);
        *(void *)(v20 + 24) = a4.i64[0];
        *(void *)(v20 + 8) = a1[14];
        if (v13) {
          unint64_t v21 = v13;
        }
        else {
          unint64_t v21 = v16;
        }
        *(void *)(v20 + 16) = v21;
        int v22 = *((_DWORD *)a1 + 12);
        timespec v23 = (unint64_t *)(*(void *)(*(void *)(*a1 + 392) + 376LL) + 984LL);
        do
          unint64_t v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
        sub_10001D914((unint64_t *)v20, (uint32x4_t *)(v20 + 8), (v22 - 8), 0LL, a4, a5);
      }

      uint64_t v7 = 0LL;
      goto LABEL_20;
    }

    goto LABEL_81;
  }

  if ((v15 & 0xC0000000) != 0)
  {
    if (sub_100013538(*(void *)(*(void *)v6 + 392LL)))
    {
      if (*(_WORD *)(v6 + 36) == 13) {
        int v29 = (const char *)(v6 + 3992);
      }
      else {
        int v29 = (const char *)(*(void *)(v6 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x non-virtual object missing paddr!\n",  "obj_write_prepare",  6413,  v29,  a1[14],  a1[2],  *((_DWORD *)a1 + 8),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 10));
    }

    return 22LL;
  }

  else
  {
    if ((v15 & 0x40) != 0) {
      goto LABEL_51;
    }
    uint64_t v30 = v12;
    uint64_t v31 = sub_100041760(v6, a1[14], v16, (unint64_t *)&v49, 0LL, 0LL, 0LL);
    unint64_t v16 = v48;
    uint64_t v12 = v30;
    if ((v31 & 0xFFFFFFFD) == 0) {
      goto LABEL_51;
    }
    uint64_t v7 = v31;
    if (sub_100013538(*(void *)(*(void *)v6 + 392LL))) {
      sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error getting mapping to write %d\n",  "obj_write_prepare");
    }
  }

  return v7;
}

void sub_100038618(uint64_t a1)
{
  int v2 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v2) {
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c", 1354, v2);
  }
  for (uint64_t i = *(void *)(a1 + 832); i; uint64_t i = *(void *)(i + 104))
  {
    uint64_t v4 = (unsigned int *)(i + 32);
    do
      unsigned int v5 = __ldxr(v4);
    while (__stxr(v5 | 1, v4));
    if ((v5 & 1) == 0)
    {
      int v6 = *(_DWORD *)(i + 36) >> 30;
      if (v6)
      {
        if (v6 != 1) {
          panic( "bad object type in flush list: oid %lld flags 0x%llx 0x%x\n",  *(void *)(i + 112),  *(void *)(i + 16),  *(_DWORD *)(i + 32));
        }
        *(void *)(i + 88) = 0LL;
        uint64_t v8 = *(void **)(a1 + 824);
        *(void *)(i + 96) = v8;
        void *v8 = i;
        *(void *)(a1 + 824) = i + 88;
        ++*(_DWORD *)(a1 + 888);
      }

      else
      {
        *(void *)(i + 88) = 0LL;
        uint64_t v7 = *(void **)(a1 + 808);
        *(void *)(i + 96) = v7;
        *uint64_t v7 = i;
        *(void *)(a1 + 808) = i + 88;
        ++*(_DWORD *)(a1 + 884);
      }
    }

    uint64_t v9 = *(void *)(i + 16);
    *(void *)(i + 16) = v9 & 0xFFFFFDFFFFFFFFFFLL;
    if ((v9 & 0x80) != 0)
    {
      *(void *)(i + 16) = v9 & 0xFFFFFDFFFFFFFF7FLL;
      j__pthread_cond_broadcast((pthread_cond_t *)(a1 + 1296));
    }
  }

  int v10 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v10) {
    panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  1374,  v10);
  }
  sub_100036F84(a1);
  uint64_t v11 = *(void *)(a1 + 832);
  if (v11)
  {
    uint64_t v12 = (uint64_t *)(a1 + 832);
    do
    {
      uint64_t v13 = *(void *)(v11 + 104);
      uint64_t *v12 = v13;
      if (!v13) {
        *(void *)(a1 + 840) = v12;
      }
      *(void *)(v11 + 104) = 3735928559LL;
      --*(_DWORD *)(a1 + 904);
      unsigned int v14 = *(void **)(v11 + 64);
      if (v14)
      {
        *(void *)(v11 + 64) = 0LL;
        *(void *)(v11 + 136) = 0LL;
      }

      sub_100038824((uint64_t *)v11);
      uint64_t v11 = *v12;
    }

    while (*v12);
  }

  pthread_mutex_lock((pthread_mutex_t *)a1);
  if (*(_DWORD *)(a1 + 908) >= 2u) {
    j__pthread_cond_broadcast((pthread_cond_t *)(a1 + 1296));
  }
  *(_DWORD *)(a1 + 908) = 0;
  sub_100036F84(a1);
}

void sub_100038824(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (!v2) {
    uint64_t v2 = *(void *)(v3 + 392);
  }
  uint64_t v4 = (unint64_t *)(a1 + 3);
  do
    unint64_t v5 = __ldxr(v4);
  while (__stxr(v5 - 0x100000000001LL, v4));
  unint64_t v6 = v5 & 0xFFFFFF;
  if ((v5 & 0xFFFFFF) == 0) {
    panic("Reference count underflowed for object %p!\n", a1);
  }
  uint64_t v7 = -(uint64_t)(v5 >> 44) & 0xFFFFF;
  if (v7 == 0x80000) {
    panic("Release count overflowed for object %p!\n", a1);
  }
  if (v6 >= 2)
  {
    do
      unint64_t v8 = __ldxr(v4);
    while (__stxr(v8 + 0x100000000000LL, v4));
    if ((v8 & 0xFFFFFF) == 0 && (-(v8 >> 44) & 0xFFFFF) == 1) {
      j__pthread_cond_broadcast((pthread_cond_t *)(v3 + 1296));
    }
    return;
  }

  uint64_t v9 = a1[2];
  if ((v9 & 0xC) != 0) {
    goto LABEL_15;
  }
  if ((v9 & 0xC00000000LL) == 0) {
    goto LABEL_27;
  }
  uint64_t v13 = (unsigned int *)(a1 + 4);
  do
    unsigned int v14 = __ldxr(v13);
  while (__stxr(v14, v13));
  if ((v14 & 1) == 0)
  {
LABEL_15:
    pthread_mutex_lock((pthread_mutex_t *)v3);
    char v10 = 0;
    uint64_t v9 = a1[2];
    if (v7 && (v9 & 8) != 0)
    {
      do
        unint64_t v11 = __ldxr(v4);
      while (__stxr(v11, v4));
      if ((-(v11 >> 44) & 0xFFFFE) != 0)
      {
        do
        {
          __int128 v36 = xmmword_10005B9E0;
          sub_100013AD4((pthread_cond_t *)(v3 + 1296), (pthread_mutex_t *)v3, 2LL, (timespec *)&v36);
          do
            unint64_t v12 = __ldxr(v4);
          while (__stxr(v12, v4));
        }

        while ((-(v12 >> 44) & 0xFFFFE) != 0);
        char v10 = 0;
        uint64_t v9 = a1[2];
      }

      else
      {
        char v10 = 0;
      }
    }
  }

  else
  {
LABEL_27:
    char v10 = 1;
  }

  if ((v9 & 0x80000008) == 0 && *((_WORD *)a1 + 18) != 13 && (a1[4] & 1) == 0)
  {
    int v15 = pthread_rwlock_rdlock((pthread_rwlock_t *)(v3 + 128));
    if (v15) {
      panic( "%s:%d: rdlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  5039,  v15);
    }
    sub_10003DD00(v3, (uint64_t)a1);
    int v16 = pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 128));
    if (v16) {
      panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  5041,  v16);
    }
  }

  uint64_t v17 = a1[14];
  int v18 = *((_DWORD *)a1 + 9);
  uint64_t v19 = a1[2];
  int v35 = *((_DWORD *)a1 + 10);
  if ((v10 & 1) != 0)
  {
    uint64_t v20 = 0LL;
    unsigned int v21 = 0;
    unsigned int v22 = 0;
LABEL_48:
    uint64_t v26 = (unsigned int *)(a1 + 4);
    do
      unsigned int v27 = __ldxr(v26);
    while (__stxr(v27 & 0xFFFFFFFD, v26));
    if ((v27 & 2) != 0) {
      uint64_t v20 = a1;
    }
    do
      unint64_t v28 = __ldxr(v4);
    while (__stxr(v28 + 0x100000000000LL, v4));
    if ((v28 & 0xFFFFFF) != 0) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }

  if ((v19 & 4) != 0)
  {
    unint64_t v23 = v19 & 0xFFFFFFFFFFFFFFFBLL;
    a1[2] = v19 & 0xFFFFFFFFFFFFFFFBLL;
    uint64_t v20 = a1;
  }

  else
  {
    uint64_t v20 = 0LL;
    unint64_t v23 = a1[2];
  }

  if ((v23 & 0xC00000000LL) == 0) {
    goto LABEL_46;
  }
  unint64_t v24 = (unsigned int *)(a1 + 4);
  do
    unsigned int v25 = __ldxr(v24);
  while (__stxr(v25, v24));
  if ((v23 & 8) != 0 || (v25 & 1) == 0)
  {
    unsigned int v29 = *(_DWORD *)(*(void *)(*(void *)(v3 + 392) + 376LL) + 36LL);
    unsigned int v22 = (v29 + *((_DWORD *)a1 + 12) - 1) / v29;
    if ((v23 & 0x800000000LL) != 0) {
      unsigned int v21 = 80;
    }
    else {
      unsigned int v21 = 72;
    }
    v23 &= 0xFFFFFFF3FFFFFFFFLL;
    a1[2] = v23;
    if ((v23 & 8) == 0) {
      goto LABEL_47;
    }
  }

  else
  {
LABEL_46:
    unsigned int v22 = 0;
    unsigned int v21 = 0;
    if ((v23 & 8) == 0)
    {
LABEL_47:
      sub_100036F84(v3);
      goto LABEL_48;
    }
  }

  if ((v23 & 0x80000000) != 0) {
    sub_100036F1C(v3, v23, *((_DWORD *)a1 + 12), -1);
  }
  else {
    --*(_DWORD *)(v3 + 684);
  }
  do
    unint64_t v30 = __ldxr(v4);
  while (__stxr(v30 + 0x100000000000LL, v4));
  uint64_t v31 = (unsigned int *)(a1 + 4);
  do
    unsigned int v32 = __ldxr(v31);
  while (__stxr(v32 & 0xFFFFFFFD, v31));
  sub_10003CCD4((uint64_t)a1, 0);
  sub_100036F84(v3);
  if ((v32 & 2) != 0) {
    goto LABEL_67;
  }
LABEL_66:
  if (v20) {
LABEL_67:
  }
    j__pthread_cond_broadcast((pthread_cond_t *)(v3 + 1296));
  if (v22)
  {
    int v33 = sub_10004CFD4(v2, v21, v22);
    if (v33)
    {
      if (*(_WORD *)(v2 + 36) == 13) {
        BOOL v34 = (const char *)(v2 + 3992);
      }
      else {
        BOOL v34 = (const char *)(*(void *)(v2 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error unreserving space on non-dirty release: %d\n",  "obj_release",  5136,  v34,  v17,  v19,  v18,  v35,  v33);
    }
  }

void sub_100038C20(uint64_t a1)
{
  uint64_t v2 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = (v3 & 0x80 ^ 0xFFFFFDFFFFFFFFFFLL) & v3;
  sub_100036F84((uint64_t)v2);
  if ((v3 & 0x80) != 0) {
    j__pthread_cond_broadcast((pthread_cond_t *)&v2[20].__opaque[8]);
  }
}

uint64_t sub_100038C84(pthread_mutex_t *a1, unsigned int a2)
{
  uint64_t sig = a1[13].__sig;
  if (!sig)
  {
LABEL_37:
    pthread_mutex_lock(a1);
    if (*(_DWORD *)&a1[14].__opaque[4] >= 2u) {
      j__pthread_cond_broadcast((pthread_cond_t *)&a1[20].__opaque[8]);
    }
    *(_DWORD *)&a1[14].__opaque[4] = 0;
    sub_100036F84((uint64_t)a1);
    return 0LL;
  }

  uint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  unsigned int v22 = a1 + 13;
  int v6 = (a2 >> 1) & 1;
  do
  {
    while (1)
    {
      uint64_t v7 = sig;
      uint64_t sig = *(void *)(sig + 104);
      pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 328));
      unint64_t v8 = (unsigned int *)(v7 + 32);
      do
        unsigned int v9 = __ldaxr(v8);
      while (__stxr(v9 | 8, v8));
      while ((v9 & 8) != 0)
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
        pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 328));
        do
          unsigned int v9 = __ldaxr(v8);
        while (__stxr(v9 | 8, v8));
      }

      unsigned int v10 = sub_100038ED0(v7, v6);
      if (v10) {
        break;
      }
      int v16 = *(void **)(v7 + 56);
      int v15 = *(void **)(v7 + 64);
      *(void *)(v7 + 64) = 0LL;
      *(void *)(v7 + 136) = 0LL;
      do
        unsigned int v17 = __ldxr(v8);
      while (__stlxr(v17 & 0xFFFFFFF7, v8));
      pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
      if (v15 && v15 != v16) {
        sub_100036918(v15, *(unsigned int *)(v7 + 48), *(void *)(v7 + 16), (uint64_t)a1);
      }
      if (!v4)
      {
        uint64_t v20 = *(void *)(v22->__sig + 104);
        v22->__uint64_t sig = v20;
        int v18 = v22;
        if (v20) {
          goto LABEL_25;
        }
LABEL_24:
        *(void *)a1[13].__opaque = v18;
        goto LABEL_25;
      }

      int v18 = (pthread_mutex_t *)(v4 + 104);
      uint64_t v19 = *(void *)(*(void *)(v4 + 104) + 104LL);
      *(void *)(v4 + 104) = v19;
      if (!v19) {
        goto LABEL_24;
      }
LABEL_25:
      *(void *)(v7 + 104) = 3735928559LL;
      --*(_DWORD *)a1[14].__opaque;
      sub_100038C20(v7);
      sub_100038824((uint64_t *)v7);
      if (!sig) {
        goto LABEL_36;
      }
    }

    unsigned int v11 = v10;
    do
      unsigned int v12 = __ldxr(v8);
    while (__stlxr(v12 & 0xFFFFFFF7, v8));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
    uint64_t v13 = *(void *)(v7 + 8);
    if (!v13) {
      uint64_t v13 = *(void *)(*(void *)v7 + 392LL);
    }
    if (sub_100013538(*(void *)(*(void *)v13 + 392LL)))
    {
      if (*(_WORD *)(v13 + 36) == 13) {
        unsigned int v14 = (const char *)(v13 + 3992);
      }
      else {
        unsigned int v14 = (const char *)(*(void *)(v13 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error writing: %d\n",  "obj_cache_flush_write",  1472,  v14,  *(void *)(v7 + 112),  *(void *)(v7 + 16),  *(_DWORD *)(v7 + 32),  *(_DWORD *)(v7 + 36),  *(_DWORD *)(v7 + 40),  v11);
    }

    if ((_DWORD)v5) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = v11;
    }
    uint64_t v4 = v7;
  }

  while (sig);
LABEL_36:
  if (!(_DWORD)v5) {
    goto LABEL_37;
  }
  return v5;
}

uint64_t sub_100038ED0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 392LL);
  int v3 = *(_DWORD *)(a1 + 48);
  if (!a2)
  {
    uint64_t v4 = *(void *)(a1 + 56);
LABEL_7:
    uint64_t v5 = *(void *)(a1 + 152);
    if (!v5)
    {
      uint64_t v5 = *(void *)(a1 + 128);
      if (!v5) {
        panic( "Object has no address: o %p oid %llu flags 0x%llx 0x%x paddr %llu naddr %llu\n",  (const void *)a1,  *(void *)(a1 + 112),  *(void *)(a1 + 16),  *(_DWORD *)(a1 + 32),  0LL,  0LL);
      }
    }

    goto LABEL_10;
  }

  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4) {
    uint64_t v4 = *(void *)(a1 + 56);
  }
  uint64_t v5 = *(void *)(a1 + 136);
  if (!v5) {
    goto LABEL_7;
  }
LABEL_10:
  if (*(_BYTE *)(v2 + 627)) {
    return 30LL;
  }
  unint64_t v7 = *(void *)(a1 + 16);
  if ((v7 & 0x10000000) != 0 && (v7 & 0x80000000000LL) == 0 && (uint64_t v12 = *(void *)(a1 + 8)) != 0)
  {
    if ((unsigned __int16)v7 >> 13 == 1)
    {
      uint64_t v9 = v12 + 624;
    }

    else
    {
      uint64_t v9 = v12 + 528;
    }

    uint64_t v10 = (v7 >> 10) & 7;
    if ((_DWORD)v10)
    {
      if ((_DWORD)v10 != 1) {
        panic("invalid tweak type %d\n");
      }
      uint64_t v8 = *(void *)(a1 + 112) ^ HIDWORD(*(void *)(a1 + 120)) | *(void *)(a1 + 112) & 0xFFFFFFFF00000000LL ^ (*(void *)(a1 + 120) << 32);
      LODWORD(v10) = 4;
    }

    else
    {
      uint64_t v8 = (v7 >> 10) & 7;
    }

    uint64_t v13 = *(void *)(v12 + 1136);
    if (v13) {
      uint64_t v11 = v13;
    }
    else {
      uint64_t v11 = *(void *)(v2 + 384);
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    LODWORD(v10) = 0;
    uint64_t v11 = *(void *)(v2 + 384);
  }

  return sub_100051FB8( v11,  v5,  (*(_DWORD *)(*(void *)(v2 + 376) + 36LL) + v3 - 1)
         / *(_DWORD *)(*(void *)(v2 + 376) + 36LL),
           v4,
           v9,
           v8,
           v10);
}

BOOL sub_100039058(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 888) + *(_DWORD *)(a1 + 884);
  if (sub_100051DE4(*(void *)(*(void *)(a1 + 392) + 384LL))) {
    unsigned int v2 = 1024;
  }
  else {
    unsigned int v2 = 256;
  }
  return v1 >= v2;
}

void sub_1000390A0(pthread_mutex_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a2;
  if (!a2) {
    uint64_t v8 = *(void *)a1[6].__opaque;
  }
  pthread_mutex_lock(a1);
  uint64_t v9 = *(void *)(a1[11].__sig + 8LL * (*(_DWORD *)&a1[10].__opaque[52] & a3));
  if (!v9)
  {
    sub_100036F84((uint64_t)a1);
    return;
  }

  unint64_t v10 = 0LL;
  unint64_t v11 = 0LL;
  opaque = (uint64_t *)a1[11].__opaque;
  do
  {
    while (1)
    {
      uint64_t v13 = v9;
      unsigned int v14 = (uint64_t *)(v9 + 72);
      uint64_t v9 = *(void *)(v9 + 72);
      if (v13 != a2 && *(void *)(v13 + 8) == a2)
      {
        uint64_t v15 = *(void *)(v13 + 16);
        if ((v15 & 0xC0000000) == 0 && *(void *)(v13 + 112) == a3 && *(void *)(v13 + 120) == a4) {
          break;
        }
      }

void sub_100039304(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8 = *(unsigned int *)(a1 + 696);
  if (!(_DWORD)v8)
  {
    sub_100036F84(a1);
    return;
  }

  unint64_t v9 = 0LL;
  unint64_t v30 = 0LL;
  unint64_t v31 = 0LL;
  unint64_t v10 = (uint64_t *)(a1 + 712);
  do
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 704) + 8 * v9);
    if (!v11) {
      goto LABEL_36;
    }
    do
    {
      while (1)
      {
        uint64_t v12 = v11;
        uint64_t v13 = (uint64_t *)(v11 + 72);
        uint64_t v11 = *(void *)(v11 + 72);
        if (v12 == a2) {
          goto LABEL_24;
        }
        if (*(void *)(v12 + 8) != a2) {
          goto LABEL_24;
        }
        uint64_t v14 = *(void *)(v12 + 16);
        if ((v14 & 0xC0000000) != 0) {
          goto LABEL_24;
        }
        unint64_t v15 = *(void *)(v12 + 120);
        if (v15 <= *(void *)(v12 + 144)) {
          unint64_t v15 = *(void *)(v12 + 144);
        }
        if (v15 < a3 || v15 > a4) {
          goto LABEL_24;
        }
        int v17 = *(_DWORD *)(v12 + 32);
        if ((v17 & 1) != 0) {
          sub_100013CBC( "%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - is dirty\n",  "obj_cache_remove_reverted_fs_objects",  1801,  (const char *)(a2 + 3992),  *(void *)(v12 + 112),  *(_DWORD *)(v12 + 36),  *(_DWORD *)(v12 + 40),  v14,  v17,  v15,  *(void *)(v12 + 24));
        }
        unsigned int v18 = (unint64_t *)(v12 + 24);
        do
          unint64_t v19 = __ldxr(v18);
        while (__stxr(v19, v18));
        if ((v19 & 0xFFFFFF) != ((v19 >> 24) & 0xFFFFF)) {
          break;
        }
        uint64_t v20 = *(void *)(v12 + 16);
        if ((v20 & 0xC00000000LL) != 0)
        {
          unsigned int v21 = *(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 376LL) + 36LL);
          uint64_t v22 = (v21 + *(_DWORD *)(v12 + 48) - 1) / v21;
          if ((v20 & 0x800000000LL) != 0) {
            uint64_t v23 = 0LL;
          }
          else {
            uint64_t v23 = v22;
          }
          v30 += v23;
          v31 += v22 & (v20 << 28 >> 63);
          *(void *)(v12 + 16) = v20 & 0xFFFFFFF3FFFFFFFFLL;
        }

        --*(_DWORD *)(a1 + 684);
        sub_10003CCD4(v12, 0);
LABEL_24:
        if (!v11) {
          goto LABEL_35;
        }
      }

      unint64_t v24 = *(void *)(v12 + 120);
      if (v24 <= *(void *)(v12 + 144)) {
        unint64_t v24 = *(void *)(v12 + 144);
      }
      sub_100013CBC( "%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - has refs\n",  "obj_cache_remove_reverted_fs_objects",  1805,  (const char *)(a2 + 3992),  *(void *)(v12 + 112),  *(_DWORD *)(v12 + 36),  *(_DWORD *)(v12 + 40),  *(void *)(v12 + 16),  *(_DWORD *)(v12 + 32),  v24,  *(void *)(v12 + 24));
      uint64_t v25 = *(void *)(v12 + 16);
      if ((v25 & 1) != 0)
      {
        uint64_t v26 = *v13;
        if (*v13) {
          *(void *)(v26 + 80) = *(void *)(v12 + 80);
        }
        **(void **)(v12 + 80) = v26;
      }

      uint64_t v27 = *v10;
      uint64_t *v13 = *v10;
      if (v27) {
        *(void *)(v27 + 80) = v13;
      }
      *unint64_t v10 = v12;
      *(void *)(v12 + 80) = v10;
      *(void *)(v12 + 16) = v25 | 9;
    }

    while (v11);
LABEL_35:
    unint64_t v8 = *(unsigned int *)(a1 + 696);
LABEL_36:
    ++v9;
  }

  while (v9 < v8);
  sub_100036F84(a1);
  if (v30)
  {
    sub_100013CBC( "%s:%d: %s unreserving %lld blocks for reverted fs objects\n",  "obj_cache_remove_reverted_fs_objects",  1833,  (const char *)(a2 + 3992),  v30);
    int v28 = sub_10004CFD4(a2, 0x48u, v30);
    if (v28) {
      sub_100013D94( "%s:%d: %s error unreserving space, %lld blocks: %d\n",  "obj_cache_remove_reverted_fs_objects",  1836,  (const char *)(a2 + 3992),  v30,  v28);
    }
  }

  if (v31)
  {
    sub_100013CBC( "%s:%d: %s unreserving %lld blocks for reverted fs objects\n",  "obj_cache_remove_reverted_fs_objects",  1840,  (const char *)(a2 + 3992),  v31);
    int v29 = sub_10004CFD4(a2, 0x50u, v31);
    if (v29) {
      sub_100013D94( "%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n",  "obj_cache_remove_reverted_fs_objects",  1843,  (const char *)(a2 + 3992),  v31,  v29);
    }
  }

uint64_t sub_10003965C(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t sub_100039664(uint64_t a1)
{
  if (*(void *)(a1 + 120) <= *(void *)(a1 + 144)) {
    return *(void *)(a1 + 144);
  }
  else {
    return *(void *)(a1 + 120);
  }
}

void sub_100039678(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = 0LL;
  uint64_t v23 = &v22;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  int v4 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v4) {
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c", 1973, v4);
  }
  for (i = *(void *)(a1 + 800); i; uint64_t v23 = v7)
  {
    while (1)
    {
      uint64_t v6 = i;
      unint64_t v7 = (uint64_t *)(i + 88);
      uint64_t i = *(void *)(i + 88);
      if (*(v7 - 10) == a2 && (*(_BYTE *)(v6 + 19) & 0xC0) == 0 && !*(void *)(v6 + 128)) {
        break;
      }
      if (!i) {
        goto LABEL_13;
      }
    }

    unint64_t v8 = *(void **)(v6 + 96);
    if (i)
    {
      *(void *)(i + 96) = v8;
      unint64_t v8 = *(void **)(v6 + 96);
    }

    else
    {
      *(void *)(a1 + 808) = v8;
    }

    void *v8 = i;
    --*(_DWORD *)(a1 + 884);
    unint64_t v9 = v23;
    *(void *)(v6 + 88) = 0LL;
    *(void *)(v6 + 96) = v9;
    *unint64_t v9 = v6;
  }

uint64_t sub_1000398B8(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t sub_1000398C0(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1000398C8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_1000398D0(int a1)
{
  if (a1 < 0) {
    return 1LL;
  }
  char v1 = a1;
  uint64_t result = 1LL;
  if (((1 << v1) & 0x2832) == 0) {
    return 0LL;
  }
  return result;
}

uint64_t sub_100039908( pthread_mutex_t *a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  else {
    return 22LL;
  }
}

uint64_t sub_10003994C( pthread_mutex_t *a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, char a10, uint64_t *a11)
{
  uint64_t v11 = *(void *)a1[6].__opaque;
  if (a7) {
    uint64_t v12 = a7;
  }
  else {
    uint64_t v12 = *(void *)a1[6].__opaque;
  }
  uint64_t v83 = 0LL;
  unsigned int v82 = 0;
  if (!a4) {
    return 22LL;
  }
  if (*(_DWORD *)(a4 + 12) < 0x178u) {
    return 22LL;
  }
  uint64_t v16 = a6;
  if (!(_DWORD)a6)
  {
    uint64_t v16 = *(unsigned int *)(a4 + 8);
    if (!(_DWORD)v16)
    {
      if (!v11) {
        return 22LL;
      }
      uint64_t v16 = *(unsigned int *)(*(void *)(v11 + 376) + 36LL);
      if (!(_DWORD)v16) {
        return 22LL;
      }
    }
  }

  unsigned int v20 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
  unsigned int v21 = v20 >> 31;
  unsigned int v22 = v20 >> 30;
  if (!(v20 >> 30)) {
    ++v21;
  }
  unsigned int v23 = v21 + ((v20 & 0x40000000) >> 30);
  if ((v20 & 0x88000000) == 0x8000000 || v23 != 1) {
    return 22LL;
  }
  unsigned int v27 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
  if (a7)
  {
    unsigned int v27 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
    if (!v22)
    {
      uint64_t v28 = *(void *)(a7 + 496);
      if (!v28) {
        uint64_t v28 = a7;
      }
      if ((*(_BYTE *)(*(void *)(v28 + 376) + 264LL) & 1) != 0)
      {
        unsigned int v27 = v20 & 0xEFFF03FF;
      }

      else
      {
        if (*(_DWORD *)(a4 + 4) == 36) {
          int v29 = 268443648;
        }
        else {
          int v29 = 0x10000000;
        }
        int v72 = v29;
        uint64_t v76 = v12;
        BOOL v30 = sub_10002F44C(a7);
        unsigned int v22 = 0;
        uint64_t v12 = v76;
        if (v30) {
          int v31 = 1024;
        }
        else {
          int v31 = 0;
        }
        unsigned int v27 = v72 | v31 | v20 & 0xEFFF03FF;
      }
    }
  }

  unint64_t v32 = a9;
  if ((v27 & 0x10000000) != 0)
  {
    unint64_t v81 = 0LL;
    if ((v27 & 0x8000000) != 0) {
      goto LABEL_46;
    }
  }

  else
  {
    if (*(_DWORD *)a4 == 11 || *(_DWORD *)(a4 + 4) == 11) {
      uint64_t v33 = 2LL;
    }
    else {
      uint64_t v33 = 1LL;
    }
    unint64_t v81 = v33;
    if ((v27 & 0x8000000) != 0) {
      goto LABEL_46;
    }
  }

  if ((a10 & 1) == 0)
  {
    if (*(_BYTE *)(v11 + 627)) {
      return 30LL;
    }
    unsigned int v74 = v27;
    uint64_t v77 = v12;
    unsigned int v79 = v22;
    BOOL v34 = sub_10004E670(v11, a9);
    unint64_t v32 = a9;
    unsigned int v27 = v74;
    unsigned int v22 = v79;
    uint64_t v12 = v77;
    if (!v34) {
      return 22LL;
    }
  }

LABEL_91:
    *(void *)(v51 + 112) = a3;
    goto LABEL_92;
  }

  if (a3) {
    goto LABEL_91;
  }
  if ((v75 & 0x8000000) == 0)
  {
    uint64_t v57 = *(void *)&a1[6].__opaque[8];
    *(void *)(v51 + 112) = v57;
    *(void *)&a1[6].__opaque[8] = v57 + 1;
    if (!byte_100070560) {
      goto LABEL_92;
    }
    int8x16_t v56 = "ephemeral";
    goto LABEL_86;
  }

  uint64_t v68 = *(void *)&a1[6].__opaque[16];
  *(void *)(v51 + 112) = v68;
  *(void *)&a1[6].__opaque[16] = v68 + 1;
LABEL_92:
  if ((*(_BYTE *)(v51 + 19) & 0x20) == 0)
  {
    uint64_t v58 = *(void *)(v51 + 56);
    *(void *)(v58 + 24) = *(void *)(v51 + 36);
    *(_OWORD *)(v58 + 8) = *(_OWORD *)(v51 + 112);
  }

  uint64_t v59 = (unint64_t *)(v51 + 24);
  do
    unint64_t v60 = __ldxr(v59);
  while (__stxr(v60 + 1, v59));
  unsigned int v61 = v53;
  if ((~(_DWORD)v60 & 0xFFFFFFLL) == 0) {
    panic("Reference count overflowed for object %p!\n", (const void *)v51);
  }
  uint64_t v25 = sub_10003AE68(*(_DWORD *)(v51 + 36), &v83);
  if ((_DWORD)v25
    || (uint64_t v62 = v83, *v83)
    && (uint64_t v25 = ((uint64_t (*)(void, uint64_t, uint64_t))*v83)(*(void *)(v51 + 56), v16, a5), (_DWORD)v25)
    || (v63 = (uint64_t (*)(uint64_t, uint64_t))v62[1]) != 0LL && (uint64_t v25 = v63(v51, a5), (_DWORD)v25))
  {
    if (v75 < 0) {
      sub_100036F1C((uint64_t)a1, v75, v16, -1);
    }
    else {
      --*(_DWORD *)&a1[10].__opaque[36];
    }
    sub_10003CCD4(v51, 0);
    sub_100036F84((uint64_t)a1);
    if ((v37 & 1) != 0)
    {
      unsigned int v46 = v71;
      if (v61) {
        return v25;
      }
      uint64_t v45 = v82;
      goto LABEL_117;
    }

LABEL_118:
    sub_10004BD08(v78, 0LL, v81, v71, v73);
    return v25;
  }

  sub_10003AE20(v51, v75);
  int8x16_t v64 = (uint64_t *)(a1[11].__sig + 8 * (*(void *)(v51 + 112) & *(unsigned int *)&a1[10].__opaque[52]));
  uint64_t v65 = *v64;
  *(void *)(v51 + 72) = *v64;
  if (v65) {
    *(void *)(v65 + 80) = v51 + 72;
  }
  *int8x16_t v64 = v51;
  *(void *)(v51 + 80) = v64;
  *(void *)(v51 + 16) |= 1uLL;
  if (v75 < 0)
  {
    *(void *)(v51 + 88) = 0LL;
    uint64_t v66 = 760LL;
    if ((v75 & 0x8000000) == 0) {
      uint64_t v66 = 744LL;
    }
    uint64_t v67 = *(uint64_t **)((char *)&a1->__sig + v66);
    *(void *)(v51 + 96) = v67;
    *uint64_t v67 = v51;
    *(uint64_t *)((char *)&a1->__sig + v66) = v51 + 88;
  }

  sub_100036F84((uint64_t)a1);
  if ((v75 & 4) != 0) {
    sub_10003CF10(v51, 2);
  }
  uint64_t v25 = 0LL;
  *a11 = v51;
  return v25;
}

uint64_t sub_10003A068( pthread_mutex_t *a1, int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  return sub_10003994C(a1, a2, a3, a4, a5, 0LL, a6, 0LL, a7, 0, a8);
}

uint64_t sub_10003A0A0(pthread_cond_t **a1, __int16 a2, uint64_t *a3, _BYTE *a4)
{
  unint64_t v8 = a1[7];
  unint64_t v9 = *a1;
  v33[0] = 0LL;
  v33[1] = 0LL;
  unsigned int v32 = 0;
  if (a4) {
    *a4 = 0;
  }
  int v10 = a2 & 0x210;
  if ((a2 & 0x210) != 0 || (uint64_t v26 = sub_10003A3CC(*((_DWORD *)a1 + 9), &v32, (uint64_t)v33), !(_DWORD)v26))
  {
    uint64_t v11 = a1[2];
    uint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v12 = (unint64_t)v11 | 2;
    a1[2] = (pthread_cond_t *)((unint64_t)v11 | 2);
    if (*a3)
    {
      uint64_t v34 = *a3;
    }

    else
    {
      uint64_t v26 = sub_10003A4E8( (uint64_t)v9,  *((_DWORD *)a1 + 11),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 12),  v11 & 0xC0000000,  a4,  &v34);
      if ((_DWORD)v26) {
        return v26;
      }
      uint64_t v12 = (uint64_t)a1[2];
    }

    LODWORD(v13) = v12 & 0xFFFFFFFB;
    a1[2] = (pthread_cond_t *)(v12 & 0xFFFFFE7FFFFFFFFBLL);
    if (!*((_DWORD *)a1 + 13))
    {
      LODWORD(v13) = v12 & 0xFFFFFFF9;
      a1[2] = (pthread_cond_t *)(v12 & 0xFFFFFE7FFFFFFFF9LL);
    }

    if ((v12 & 4) != 0)
    {
      j__pthread_cond_broadcast(*a1 + 27);
      unint64_t v13 = a1[2];
    }

    uint64_t v14 = v34;
    *(void *)(v34 + 36) = *(pthread_cond_t **)((char *)a1 + 36);
    *(void *)(v14 + 8) = a1[1];
    *(_OWORD *)(v14 + 112) = *((_OWORD *)a1 + 7);
    *(void *)(v14 + 128) = a1[16];
    uint64_t v15 = v13 & 0xFFFFFC00 | *(void *)(v14 + 16);
    uint64_t v16 = v15 | 0x40000000002LL;
    *(void *)(v14 + 16) = v15 | 0x40000000002LL;
    if ((a2 & 0x50) != 0)
    {
      uint64_t v16 = v15 | 0x4000000000ALL;
      *(void *)(v14 + 16) = v15 | 0x4000000000ALL;
      if ((a2 & 0x40) != 0)
      {
        uint64_t v16 = v15 | 0x4100000000ALL;
        *(void *)(v14 + 16) = v15 | 0x4100000000ALL;
      }
    }

    if ((a2 & 0x200) != 0) {
      *(void *)(v14 + 16) = v16 | 0x80000000000LL;
    }
    memcpy(*(void **)(v14 + 56), v8, *((unsigned int *)a1 + 12));
    if (v10) {
      goto LABEL_17;
    }
    uint64_t v31 = 0LL;
    memcpy((void *)(v14 + 376), a1 + 47, *((unsigned int *)a1 + 11) - 376LL);
    uint64_t v27 = sub_10003AE68(*((_DWORD *)a1 + 9), &v31);
    if ((_DWORD)v27)
    {
      uint64_t v26 = v27;
    }

    else
    {
      int v29 = *(uint64_t (**)(uint64_t, void))(v31 + 8);
      if (!v29 || (uint64_t v26 = v29(v14, 0LL), !(_DWORD)v26))
      {
LABEL_17:
        unsigned int v17 = (uint64_t *)(*(void *)&v9[14].__opaque[24]
                        + 8 * (*(void *)(v14 + 112) & *(unsigned int *)&v9[14].__opaque[20]));
        uint64_t v18 = *v17;
        *(void *)(v14 + 72) = *v17;
        if (v18) {
          *(void *)(v18 + 80) = v14 + 72;
        }
        *unsigned int v17 = v14;
        *(void *)(v14 + 80) = v17;
        uint64_t v19 = *(void *)(v14 + 16);
        *(void *)(v14 + 16) = v19 | 1;
        unsigned int v20 = a1[2];
        if ((v20 & 0x80000000) != 0)
        {
          *(void *)(v14 + 88) = 0LL;
          BOOL v21 = (v20 & 0x8000000) == 0LL;
          uint64_t v22 = 760LL;
          if (v21) {
            uint64_t v22 = 744LL;
          }
          unsigned int v23 = *(uint64_t **)((char *)&v9->__sig + v22);
          *(void *)(v14 + 96) = v23;
          *unsigned int v23 = v14;
          *(uint64_t *)((char *)&v9->__sig + v22) = v14 + 88;
        }

        *(void *)(v14 + 16) = v19 & 0xFFFFFA7FFFFFFFFALL | 1;
        if (!(*(_DWORD *)(v14 + 52) | a2 & 0x10)) {
          *(void *)(v14 + 16) = v19 & 0xFFFFFA7FFFFFFFF8LL | 1;
        }
        if ((v19 & 4) != 0) {
          j__pthread_cond_broadcast((pthread_cond_t *)(*(void *)v14 + 1296LL));
        }
        unint64_t v24 = (unint64_t *)(v14 + 24);
        do
          unint64_t v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
        if ((~(_DWORD)v25 & 0xFFFFFFLL) == 0) {
          panic("Reference count overflowed for object %p!\n", (const void *)v14);
        }
        uint64_t v26 = 0LL;
        *a3 = v14;
        return v26;
      }
    }

    uint64_t v28 = *(void *)(v14 + 16);
    if ((v28 & 0x80000000) != 0) {
      sub_100036F1C((uint64_t)v9, v28, *(_DWORD *)(v14 + 48), -1);
    }
    else {
      --*(_DWORD *)&v9[14].__opaque[4];
    }
    if (*a3) {
      *(void *)(v14 + 16) &= ~0x40000000000uLL;
    }
    else {
      sub_10003CCD4(v14, 0);
    }
  }

  return v26;
}

uint64_t sub_10003A3CC(int a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = 22LL;
  switch((__int16)a1)
  {
    case 1:
      int v4 = &xmmword_10005B780;
      goto LABEL_17;
    case 2:
      *(_OWORD *)a3 = xmmword_10005B940;
      *(_DWORD *)a3 = 2;
      goto LABEL_18;
    case 3:
      int v4 = &xmmword_10005B940;
      goto LABEL_17;
    case 5:
      int v4 = &xmmword_10005BA44;
      goto LABEL_17;
    case 6:
      int v4 = &xmmword_10005BA54;
      goto LABEL_17;
    case 7:
      int v4 = &xmmword_10005BA64;
      goto LABEL_17;
    case 8:
      int v4 = &xmmword_10005BA74;
      goto LABEL_17;
    case 11:
      int v4 = &xmmword_10005B9F8;
      goto LABEL_17;
    case 13:
      int v4 = &xmmword_10005B954;
      goto LABEL_17;
    case 17:
      int v4 = &xmmword_10005B790;
      goto LABEL_17;
    case 18:
      int v4 = &xmmword_10005B7A0;
      goto LABEL_17;
    case 25:
      int v4 = &xmmword_100053990;
      goto LABEL_17;
    case 27:
      int v4 = &xmmword_100053980;
      goto LABEL_17;
    case 29:
      int v4 = &xmmword_100053968;
      goto LABEL_17;
    case 30:
      int v4 = &xmmword_100053930;
LABEL_17:
      *(_OWORD *)a3 = *v4;
LABEL_18:
      uint64_t v3 = 0LL;
      unsigned int v5 = *a2 | a1 & 0xFFFF0000;
      *a2 = v5;
      *a2 = v5 | (*(unsigned __int16 *)(a3 + 2) << 16);
      break;
    default:
      return v3;
  }

  return v3;
}

uint64_t sub_10003A4E8(uint64_t a1, unsigned int a2, int a3, unsigned int a4, int a5, _BYTE *a6, uint64_t *a7)
{
  unint64_t v7 = a6;
  unsigned int v8 = a4;
  int v9 = a3;
  if (a6) {
    *a6 = 0;
  }
  if (a2) {
    size_t v11 = a2;
  }
  else {
    size_t v11 = 376LL;
  }
  if (a4)
  {
    uint64_t v12 = 0LL;
LABEL_10:
    LOBYTE(v13) = 1;
    goto LABEL_11;
  }

  uint64_t v13 = *(void *)(a1 + 392);
  if (v13)
  {
    uint64_t v12 = 0LL;
    unsigned int v8 = *(_DWORD *)(*(void *)(v13 + 376) + 36LL);
    goto LABEL_10;
  }

  unsigned int v8 = 0;
  uint64_t v12 = 22LL;
LABEL_11:
  uint64_t v14 = *(void *)(a1 + 392);
  if (v11 < 0x178)
  {
    uint64_t v12 = 22LL;
    if (!v14) {
      goto LABEL_23;
    }
LABEL_19:
    sub_100013D94("%s:%d: %s invalid object size: %d size_phys %d\n");
    return v12;
  }

  if (v14)
  {
    if (v8 % *(_DWORD *)(*(void *)(v14 + 376) + 36LL))
    {
      LOBYTE(v13) = 0;
      uint64_t v12 = 22LL;
    }

    else
    {
      uint64_t v12 = v12;
    }

    if ((v13 & 1) == 0) {
      goto LABEL_19;
    }
  }

  else if ((v13 & 1) == 0)
  {
LABEL_23:
    sub_100013D94("%s:%d: invalid object size: %d size_phys %d\n");
    return v12;
  }

  size_t v88 = v11;
  unsigned int v86 = v8;
  if (a5 < 0)
  {
    char v85 = 0;
    char v19 = 0;
    char v83 = 0;
LABEL_84:
    sub_100036F84(a1);
    if (v7) {
      *unint64_t v7 = 1;
    }
    char v36 = sub_100013E20(v8, *(void *)(a1 + 920));
    sub_10003F14C((unint64_t *)(a1 + 944), a5, (uint64_t)v36, v8);
    uint64_t v90 = v36;
    sub_10003F14C((unint64_t *)(qword_100070558 + 136), a5, (uint64_t)v36, v8);
    switch((__int16)v9)
    {
      case 1:
        size_t v38 = 1928LL;
        goto LABEL_97;
      case 2:
      case 3:
      case 6:
      case 7:
      case 8:
        char v37 = sub_100013E98(4u);
        goto LABEL_98;
      case 5:
        size_t v38 = 1608LL;
        goto LABEL_97;
      case 11:
        size_t v38 = 496LL;
        goto LABEL_97;
      case 13:
        size_t v38 = 4024LL;
        goto LABEL_97;
      case 17:
      case 30:
        size_t v38 = 400LL;
        goto LABEL_97;
      case 18:
        size_t v38 = 384LL;
        goto LABEL_97;
      case 25:
        size_t v38 = 416LL;
        goto LABEL_97;
      case 27:
      case 29:
        size_t v38 = 392LL;
        goto LABEL_97;
      default:
        size_t v38 = 376LL;
LABEL_97:
        char v37 = sub_100013EEC(1uLL, v38);
LABEL_98:
        uint64_t v20 = (uint64_t)v37;
        unint64_t v39 = v90;
        if (v90 && v20)
        {
          *(void *)(v20 + 24) = 0LL;
          uint64_t v40 = sub_1000139C8((pthread_rwlock_t *)(v20 + 176));
          if (!(_DWORD)v40)
          {
            pthread_mutex_lock((pthread_mutex_t *)a1);
            if (a5 < 0)
            {
              int v16 = 1;
              sub_100036F1C(a1, a5, v8, 1);
              goto LABEL_125;
            }

            unsigned int v17 = *(_DWORD *)(a1 + 684);
            int v16 = 1;
            if (*(_DWORD *)(a1 + 680) - 1 >= v17)
            {
              *(_DWORD *)(a1 + 684) = v17 + 1;
              goto LABEL_125;
            }

            uint64_t v15 = v20;
            goto LABEL_27;
          }

          uint64_t v12 = v40;
          unint64_t v39 = v90;
        }

        else
        {
          uint64_t v12 = 12LL;
          if (!v90) {
            goto LABEL_115;
          }
        }

        sub_100036918(v39, v8, a5, a1);
LABEL_115:
        if (v20) {
          sub_10003ED5C((void *)v20, v9, v11);
        }
        pthread_mutex_lock((pthread_mutex_t *)a1);
        return v12;
    }
  }

  uint64_t v90 = 0LL;
  uint64_t v15 = 0LL;
  char v85 = 0;
  int v16 = 0;
  char v83 = 0;
  unsigned int v17 = *(_DWORD *)(a1 + 684);
LABEL_27:
  if (v17 < *(_DWORD *)(a1 + 676))
  {
    uint64_t v20 = 0LL;
    goto LABEL_82;
  }

  if ((a5 & 0x40000000) != 0) {
    BOOL v21 = (uint64_t *)(a1 + 784);
  }
  else {
    BOOL v21 = (uint64_t *)(a1 + 768);
  }
  if ((a5 & 0x40000000) != 0) {
    uint64_t v22 = (uint64_t *)(a1 + 768);
  }
  else {
    uint64_t v22 = (uint64_t *)(a1 + 784);
  }
  while (1)
  {
    int v23 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
    if (v23) {
      panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  2172,  v23);
    }
    uint64_t v24 = *v21;
    if (!*v21)
    {
      uint64_t v25 = *v22;
      if (!*v22)
      {
        uint64_t v20 = 0LL;
        uint64_t v24 = 0LL;
        size_t v11 = v88;
        int v9 = a3;
        unsigned int v8 = v86;
        goto LABEL_78;
      }

      goto LABEL_42;
    }

    if ((*(_BYTE *)(v24 + 32) & 0x10) == 0) {
      break;
    }
LABEL_43:
    sub_10003EB94(a1);
    int v26 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
    if (v26) {
      panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  2209,  v26);
    }
    if (*(_DWORD *)(a1 + 684) < *(_DWORD *)(a1 + 676))
    {
      uint64_t v20 = 0LL;
      size_t v11 = v88;
      int v9 = a3;
      unsigned int v8 = v86;
      goto LABEL_82;
    }
  }

  uint64_t v25 = *v22;
  if (!*v22) {
    goto LABEL_47;
  }
LABEL_42:
  if ((*(_BYTE *)(v25 + 32) & 0x10) != 0) {
    goto LABEL_43;
  }
LABEL_47:
  __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  __tp.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  int v9 = a3;
  if (v24 && __tp.tv_sec - *(unsigned int *)(v24 + 160) > 599)
  {
    size_t v11 = v88;
    unsigned int v8 = v86;
    goto LABEL_64;
  }

  size_t v11 = v88;
  unsigned int v8 = v86;
  if (!v25)
  {
    BOOL v28 = *(_DWORD *)(a1 + 684) < *(_DWORD *)(a1 + 680);
LABEL_62:
    uint64_t v20 = 0LL;
    if (!v28 && v24) {
      goto LABEL_64;
    }
    goto LABEL_72;
  }

  uint64_t v27 = *(unsigned int *)(v25 + 160);
  if (__tp.tv_sec - v27 > 599)
  {
    uint64_t v24 = v25;
    goto LABEL_64;
  }

  unsigned int v29 = *(_DWORD *)(a1 + 684);
  unsigned int v30 = *(_DWORD *)(a1 + 680);
  BOOL v31 = v29 >= v30;
  BOOL v28 = v29 < v30;
  if (!v24 || !v31)
  {
    uint64_t v24 = v25;
    goto LABEL_62;
  }

LABEL_64:
  if (*(_DWORD *)(v24 + 44) != (_DWORD)v11 || *(_DWORD *)(v24 + 48) != v8)
  {
    unsigned int v33 = *(_DWORD *)(a1 + 684);
    char v85 = 1;
    if (v33 >= *(_DWORD *)(a1 + 680))
    {
      uint64_t v20 = 0LL;
      *(_DWORD *)(a1 + 684) = v33 - 1;
      char v85 = 1;
      goto LABEL_78;
    }

    uint64_t v20 = 0LL;
LABEL_72:
    uint64_t v24 = 0LL;
    goto LABEL_78;
  }

  sub_10003ECE4((uint64_t *)v24);
  if (v15)
  {
    sub_100036918(v90, v8, a5, a1);
    j__pthread_rwlock_destroy((pthread_rwlock_t *)(v15 + 176));
    sub_10003ED5C((void *)v15, a3, v11);
    uint64_t v90 = 0LL;
    char v83 = 1;
  }

  uint64_t v32 = *(void *)(v24 + 16);
  char v85 = 1;
  if ((v32 & 1) != 0)
  {
    uint64_t v34 = *(void *)(v24 + 72);
    if (v34) {
      *(void *)(v34 + 80) = *(void *)(v24 + 80);
    }
    uint64_t v15 = 0LL;
    **(void **)(v24 + 80) = v34;
    *(void *)(v24 + 16) = v32 & 0xFFFFFFFFFFFFFFFELL;
    char v85 = 1;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v20 = v24;
  uint64_t v24 = 0LL;
LABEL_78:
  int v35 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v35) {
    panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  2267,  v35);
  }
  if (v24) {
    sub_10003CCD4(v24, 0);
  }
LABEL_82:
  if (!(v20 | v15))
  {
    char v19 = v16;
    unint64_t v7 = a6;
    goto LABEL_84;
  }

  if (v20)
  {
    unint64_t v104 = 0xAAAAAAAAAAAAAAAALL;
    v41.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v41.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    timespec v102 = v41;
    timespec v103 = v41;
    timespec v100 = v41;
    timespec v101 = v41;
    timespec v98 = v41;
    timespec v99 = v41;
    timespec v96 = v41;
    timespec v97 = v41;
    timespec v94 = v41;
    timespec v95 = v41;
    timespec __tp = v41;
    timespec v93 = v41;
    uint64_t v42 = sub_10003EDDC(v20);
    if (v42)
    {
      uint64_t v43 = (uint64_t (*)(uint64_t))v42;
      sub_100036F84(a1);
      if (a6) {
        *a6 = 1;
      }
      int v44 = v43(v20);
      if (v44)
      {
        uint64_t v45 = *(void *)(v20 + 8);
        if (v45) {
          unsigned int v46 = (const char *)(v45 + 3992);
        }
        else {
          unsigned int v46 = (const char *)(*(void *)(*(void *)(*(void *)v20 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error destroying: %d\n",  "obj_alloc",  2363,  v46,  *(void *)(v20 + 112),  *(void *)(v20 + 16),  *(_DWORD *)(v20 + 32),  *(_DWORD *)(v20 + 36),  *(_DWORD *)(v20 + 40),  v44);
      }

      pthread_mutex_lock((pthread_mutex_t *)a1);
    }

    uint64_t v47 = *(void **)(v20 + 56);
    timespec v48 = *(timespec *)(v20 + 352);
    timespec v102 = *(timespec *)(v20 + 336);
    timespec v103 = v48;
    unint64_t v104 = *(void *)(v20 + 368);
    timespec v49 = *(timespec *)(v20 + 288);
    timespec v98 = *(timespec *)(v20 + 272);
    timespec v99 = v49;
    timespec v50 = *(timespec *)(v20 + 320);
    timespec v100 = *(timespec *)(v20 + 304);
    timespec v101 = v50;
    timespec v51 = *(timespec *)(v20 + 224);
    timespec v94 = *(timespec *)(v20 + 208);
    timespec v95 = v51;
    timespec v52 = *(timespec *)(v20 + 256);
    timespec v96 = *(timespec *)(v20 + 240);
    timespec v97 = v52;
    timespec v53 = *(timespec *)(v20 + 192);
    timespec __tp = *(timespec *)(v20 + 176);
    timespec v93 = v53;
    uint64_t v90 = v47;
    bzero(v47, v8);
    bzero((void *)v20, v11);
    timespec v54 = v103;
    *(timespec *)(v20 + 336) = v102;
    *(timespec *)(v20 + 352) = v54;
    *(void *)(v20 + 368) = v104;
    timespec v55 = v99;
    *(timespec *)(v20 + 272) = v98;
    *(timespec *)(v20 + 288) = v55;
    timespec v56 = v101;
    *(timespec *)(v20 + 304) = v100;
    *(timespec *)(v20 + 320) = v56;
    timespec v57 = v95;
    *(timespec *)(v20 + 208) = v94;
    *(timespec *)(v20 + 224) = v57;
    timespec v58 = v97;
    *(timespec *)(v20 + 240) = v96;
    *(timespec *)(v20 + 256) = v58;
    timespec v59 = v93;
    char v19 = v16;
    *(timespec *)(v20 + 176) = __tp;
    *(timespec *)(v20 + 192) = v59;
  }

  else
  {
    ++*(_DWORD *)(a1 + 684);
    uint64_t v20 = v15;
    char v19 = v16;
  }

LABEL_125:
  *(void *)uint64_t v20 = a1;
  *(_DWORD *)(v20 + 36) = v9;
  *(_DWORD *)(v20 + 44) = v11;
  *(_DWORD *)(v20 + 48) = v8;
  *(void *)(v20 + 56) = v90;
  *(void *)(v20 + 88) = 3735928559LL;
  *(void *)(v20 + 104) = 3735928559LL;
  *(_DWORD *)(v20 + 160) = -1;
  if ((a5 & 0x80000000) == 0)
  {
    unint64_t v60 = (unint64_t *)(a1 + 1024);
    do
      unint64_t v61 = __ldxr(v60);
    while (__stxr(v61 + 1, v60));
    if (v16)
    {
      uint64_t v62 = (unint64_t *)(a1 + 1032);
      do
        unint64_t v63 = __ldxr(v62);
      while (__stxr(v63 + 1, v62));
      if ((v19 & 1) != 0)
      {
        int8x16_t v64 = (unint64_t *)(a1 + 1040);
        do
          unint64_t v65 = __ldxr(v64);
        while (__stxr(v65 + 1, v64));
      }

      uint64_t v66 = 104LL;
      if ((v83 & 1) != 0) {
        uint64_t v66 = 112LL;
      }
      uint64_t v67 = (unint64_t *)(a1 + v66 + 944);
      do
        unint64_t v68 = __ldxr(v67);
      while (__stxr(v68 + 1, v67));
    }

    if ((v85 & 1) != 0)
    {
      char v69 = (unint64_t *)(a1 + 1064);
      do
        unint64_t v70 = __ldxr(v69);
      while (__stxr(v70 + 1, v69));
    }

    uint64_t v71 = qword_100070558;
    int v72 = (unint64_t *)(qword_100070558 + 216);
    do
      unint64_t v73 = __ldxr(v72);
    while (__stxr(v73 + 1, v72));
    if (v16)
    {
      unsigned int v74 = (unint64_t *)(v71 + 224);
      do
        unint64_t v75 = __ldxr(v74);
      while (__stxr(v75 + 1, v74));
      if ((v19 & 1) != 0)
      {
        uint64_t v76 = (unint64_t *)(v71 + 232);
        do
          unint64_t v77 = __ldxr(v76);
        while (__stxr(v77 + 1, v76));
      }

      uint64_t v78 = 104LL;
      if ((v83 & 1) != 0) {
        uint64_t v78 = 112LL;
      }
      unsigned int v79 = (unint64_t *)(v71 + v78 + 136);
      do
        unint64_t v80 = __ldxr(v79);
      while (__stxr(v80 + 1, v79));
    }

    if ((v85 & 1) != 0)
    {
      unint64_t v81 = (unint64_t *)(v71 + 256);
      do
        unint64_t v82 = __ldxr(v81);
      while (__stxr(v82 + 1, v81));
    }
  }

  uint64_t v12 = 0LL;
  *a7 = v20;
  return v12;
}

uint64_t sub_10003AE20(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = v2 & 0xFFFFFE7FFFFFFFFBLL;
  if (*(_DWORD *)(result + 52) | a2 & 0x10)
  {
    if ((v2 & 4) == 0) {
      return result;
    }
    return j__pthread_cond_broadcast((pthread_cond_t *)(*(void *)result + 1296LL));
  }

  *(void *)(result + 16) = v2 & 0xFFFFFE7FFFFFFFF9LL;
  if ((v2 & 4) != 0) {
    return j__pthread_cond_broadcast((pthread_cond_t *)(*(void *)result + 1296LL));
  }
  return result;
}

uint64_t sub_10003AE68(__int16 a1, void *a2)
{
  __int16 v2 = a1 - 1;
  uint64_t result = 0LL;
  *a2 = off_10006C7D8[v2];
  return result;
}

void sub_10003AEAC(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = *a1;
  if ((*((_BYTE *)a1 + 19) & 8) == 0 && !sub_10004E670(*(void *)(v6 + 392), a2)) {
    panic("can not delete an object w/a non-current xid %lld o == %p\n", a2, a1);
  }
  pthread_mutex_lock((pthread_mutex_t *)v6);
  for (uint64_t i = a1[2]; (i & 0x20000000000LL) != 0; uint64_t i = a1[2])
  {
    a1[2] = i | 0x80;
    sub_100013AD4((pthread_cond_t *)(v6 + 1296), (pthread_mutex_t *)v6, 2LL, 0LL);
  }

  a1[2] = i | 0x10;
  a1[18] = a2;
  if ((i & 0x80000000) != 0)
  {
    if (a3) {
      a1[2] = i & 0xFFFFFFEFFFFFFFE7LL | 0x18;
    }
    sub_100036F84(v6);
  }

  else
  {
    uint64_t v8 = a1[19];
    if (!v8) {
      uint64_t v8 = a1[16];
    }
    uint64_t v26 = v8;
    a1[16] = 0LL;
    int v9 = (unsigned int *)(a1 + 4);
    a1[19] = 0LL;
    do
      unsigned int v10 = __ldxr(v9);
    while (__stxr(v10 & 0xFFFFFFFE, v9));
    if ((v10 & 1) != 0)
    {
      int v11 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 128));
      if (v11) {
        panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  3014,  v11);
      }
      uint64_t v12 = a1[11];
      if (v12 != 3735928559LL)
      {
        uint64_t v13 = (uint64_t *)a1[12];
        if ((*((_BYTE *)a1 + 19) & 0x40) != 0)
        {
          if (v12)
          {
            *(void *)(v12 + 96) = v13;
            uint64_t v13 = (uint64_t *)a1[12];
          }

          else
          {
            *(void *)(v6 + 824) = v13;
          }

          uint64_t *v13 = v12;
          --*(_DWORD *)(v6 + 888);
        }

        else
        {
          if (v12)
          {
            *(void *)(v12 + 96) = v13;
            uint64_t v13 = (uint64_t *)a1[12];
          }

          else
          {
            *(void *)(v6 + 808) = v13;
          }

          uint64_t *v13 = v12;
          --*(_DWORD *)(v6 + 884);
        }

        a1[11] = 3735928559LL;
      }

      int v14 = pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 128));
      if (v14) {
        panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  3028,  v14);
      }
    }

    uint64_t v15 = a1[1];
    if (!v15) {
      uint64_t v15 = *(void *)(v6 + 392);
    }
    uint64_t v16 = a1[2];
    unint64_t v17 = a1[15];
    if (a3) {
      a1[2] = v16 & 0xFFFFFFEFFFFFFFF7LL | 8;
    }
    uint64_t v18 = a1[18];
    int v19 = *((_DWORD *)a1 + 12);
    unint64_t v20 = a1[14];
    int v22 = *((_DWORD *)a1 + 9);
    int v21 = *((_DWORD *)a1 + 10);
    sub_100036F84(v6);
    if (!(v8 | v16 & 0x40))
    {
      int v23 = sub_100041760(v15, v20, v17, (unint64_t *)&v26, 0LL, 0LL, 0LL);
      if (v23)
      {
        if (*(_WORD *)(v15 + 36) == 13) {
          uint64_t v24 = (const char *)(v15 + 3992);
        }
        else {
          uint64_t v24 = (const char *)(*(void *)(v15 + 384) + 208LL);
        }
        sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error getting mapping to free %d\n",  "obj_delete_internal",  3050,  v24,  v20,  v16,  v22,  v21,  v23);
      }

      uint64_t v8 = v26;
    }

    if (v8)
    {
      if ((v16 & 0x40000000) != 0)
      {
        unsigned int v25 = *(_DWORD *)(*(void *)(*(void *)(v6 + 392) + 376LL) + 36LL);
        if (sub_10004BD08(v15, 0LL, v8, (v19 + v25 - 1) / v25, v18)) {
          sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error freeing space %d\n",  "obj_delete_internal");
        }
      }

      else if (sub_10004144C(v15, v20, v17, v8, v19, 1, v18))
      {
        sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error deleting mapping %d\n",  "obj_delete_internal");
      }
    }
  }

void sub_10003B238(uint64_t *a1, uint64_t a2)
{
}

void sub_10003B240(uint64_t a1)
{
  __int16 v2 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFEFFFFFFFF7LL | 8;
  sub_100036F84((uint64_t)v2);
}

uint64_t sub_10003B27C(uint64_t a1, int a2, int a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a1 + 392);
  BOOL v28 = 0LL;
  unsigned int v29 = 0LL;
  unsigned int v27 = 0;
  v26[0] = 0LL;
  v26[1] = 0LL;
  uint64_t v13 = sub_10003A3CC(a2, &v27, (uint64_t)v26);
  if (!(_DWORD)v13)
  {
    uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    if (a4)
    {
      uint64_t v15 = sub_10003B574(a1, 0, a4, (int *)&xmmword_10005B954, 0LL, 0LL, 0LL, 0LL, (uint64_t *)&v29);
      if ((_DWORD)v15)
      {
        uint64_t v13 = v15;
        sub_100013D94( "%s:%d: %s unable to get fs object 0x%llx: %d\n",  "obj_delete_and_free_by_oid",  3138,  (const char *)(*(void *)(v12 + 384) + 208LL),  a4,  v15);
        return v13;
      }

      uint64_t v16 = v29;
    }

    else
    {
      uint64_t v16 = 0LL;
    }

    if (v16) {
      uint64_t v17 = (uint64_t)v16;
    }
    else {
      uint64_t v17 = v12;
    }
    unsigned int v18 = v27;
    uint64_t v19 = sub_10003B574(a1, v27, a5, 0LL, 0LL, (uint64_t)v16, 0LL, 0LL, (uint64_t *)&v28);
    if ((_DWORD)v19)
    {
      if ((v18 & 0x80000000) != 0)
      {
        uint64_t v13 = v19;
      }

      else if ((v18 & 0x40000000) != 0)
      {
        uint64_t v22 = sub_10004BD08( (const char *)v17,  0LL,  a5,  (a3 + *(_DWORD *)(*(void *)(v12 + 376) + 36LL) - 1)
              / *(_DWORD *)(*(void *)(v12 + 376) + 36LL),
                a6);
        uint64_t v13 = v22;
        if ((_DWORD)v22)
        {
          if (*(_WORD *)(v17 + 36) == 13) {
            sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error freeing space %d\n",  "obj_delete_and_free_by_oid",  3160,  (const char *)(v17 + 3992),  a5,  v18,  a2,  v22);
          }
          else {
            sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error freeing space %d\n",  "obj_delete_and_free_by_oid",  3160,  (const char *)(*(void *)(v17 + 384) + 208LL),  a5,  v18,  a2,  v22);
          }
        }
      }

      else
      {
        int v24 = -1431655766;
        unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v20 = sub_100041760(v17, a5, 0LL, (unint64_t *)&v25, &v24, 0LL, &v23);
        if ((_DWORD)v20)
        {
          uint64_t v13 = v20;
          sub_100013D94("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error getting mapping to free %d\n");
        }

        else
        {
          uint64_t v13 = sub_10004144C(v17, a5, v23, v25, a3, 1, a6);
          if ((_DWORD)v13) {
            sub_100013D94("%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error deleting mapping %d\n");
          }
        }

        uint64_t v16 = v29;
      }
    }

    else
    {
      int v21 = v28;
      sub_10003AEAC(v28, a6, 1);
      sub_100038824(v21);
      uint64_t v13 = 0LL;
    }

    if (v16) {
      sub_100038824(v16);
    }
  }

  return v13;
}

uint64_t sub_10003B574( uint64_t a1, unsigned int a2, unint64_t a3, int *a4, _WORD *a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t *a9)
{
  int v127 = a2;
  if ((a2 & 8) != 0) {
    unint64_t v9 = a7;
  }
  else {
    unint64_t v9 = 0LL;
  }
  unint64_t v124 = v9;
  unint64_t v125 = 0LL;
  unsigned int v122 = 0;
  int v123 = 16000;
  char v119 = -86;
  char v118 = -86;
  *a9 = 0LL;
  if (a2 >> 30 == 3) {
    return 22LL;
  }
  unint64_t v11 = a7;
  unsigned int v16 = a2;
  if ((a2 & 0x8000001) == 1)
  {
    BOOL v18 = sub_10004E670(*(void *)(a1 + 392), a8);
    uint64_t v19 = 22LL;
    if ((~v16 & 0x180) == 0 || !v18) {
      return v19;
    }
  }

  else if ((~a2 & 0x180) == 0)
  {
    return 22LL;
  }

  if ((~v16 & 0x81) == 0 || (v16 & 0x100) != 0 && (v16 & 0x15) != 0) {
    return 22LL;
  }
  uint64_t v19 = 22LL;
  if ((v16 & 0x210) == 0x200 || !a3) {
    return v19;
  }
  if (*(void *)(a1 + 1344))
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    unsigned __int8 v121 = 2;
    sub_10003C2B4(a1, &v118);
    if (v118) {
      sub_100036F84(a1);
    }
  }

  if (a4)
  {
    v16 |= *((unsigned __int16 *)a4 + 1) << 16;
    int v127 = v16;
  }

  unsigned int v21 = v16 >> 30;
  if ((v16 & 0x40000000) == 0 && v16 >> 30 < 2) {
    int v22 = 4;
  }
  else {
    int v22 = 0;
  }
  unsigned int v23 = (v16 & 0x40000000) >> 30;
  if (v21 > 1) {
    ++v23;
  }
  if (v23 + ((v16 & 0x40000000) == 0 && v16 >> 30 < 2) != 1
    || (((v16 & 0x40000000) != 0 || v16 >> 30 >= 2) & ((unsigned __int16)(v16 & 0x200) >> 9)) != 0)
  {
    return 22LL;
  }

  if ((v16 & 0x40000000) != 0 || v16 >> 30 >= 2)
  {
    unint64_t v11 = 0LL;
    unint64_t v124 = 0LL;
  }

  if ((v16 & 0x8000000) != 0)
  {
    if (v21 >= 2)
    {
      unint64_t v24 = *(void *)(a1 + 408);
      if (v24 <= *(void *)(a1 + 400)) {
        unint64_t v24 = *(void *)(a1 + 400);
      }
      goto LABEL_41;
    }

    return 22LL;
  }

  if ((v16 & 1) != 0 && *(_BYTE *)(*(void *)(a1 + 392) + 627LL)) {
    return 30LL;
  }
  if ((v16 & 0x48000000) != 0) {
    goto LABEL_42;
  }
  unint64_t v24 = *(void *)(a1 + 400);
LABEL_41:
  if (v24 <= a3) {
    return 22LL;
  }
LABEL_42:
  if (a4)
  {
    int v114 = *a4;
    int v117 = a4[1];
  }

  else
  {
    int v114 = 0;
    int v117 = 0;
  }

  uint64_t v110 = a5;
  int v25 = v16;
  int v26 = v117;
  if (a6 != 0 && (v16 & 0x40000000) == 0 && v16 >> 30 < 2)
  {
    sub_10003C330(a6, v117, (unsigned int *)&v127);
    int v25 = v127;
  }

  unsigned int v116 = v25 & 0xFFFF0000 | v114;
  uint64_t v126 = 0LL;
  int v27 = v22 | (v16 >> 30) | 0x20;
  unsigned int v28 = v25;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  unsigned int v29 = v27;
  unsigned int v30 = v28;
  uint64_t v19 = 0LL;
  unsigned __int8 v121 = 1;
  int v31 = (unsigned __int16)v114;
  int v108 = (pthread_cond_t *)(a1 + 1296);
  uint64_t v32 = 512LL;
  if (!v11) {
    uint64_t v32 = 288LL;
  }
  uint64_t v109 = v32;
  int v112 = (unsigned __int16)v114;
  while (1)
  {
    unsigned int v33 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
    char v120 = 0;
    uint64_t v34 = *(void *)(*(void *)(a1 + 704) + 8LL * (*(_DWORD *)(a1 + 700) & a3));
    if (!v34)
    {
      if ((v29 & 2) != 0) {
        goto LABEL_241;
      }
LABEL_107:
      if (a4)
      {
        uint64_t v43 = v126;
        if (!v126)
        {
          unsigned int v113 = v33;
          char v44 = v121;
          if (v121 == 1) {
            char v44 = 2;
          }
          unsigned __int8 v121 = v44;
          unsigned int v46 = a4[2];
          unsigned int v45 = a4[3];
LABEL_172:
          int v26 = v117;
          unsigned int v47 = v127;
          uint64_t v68 = sub_10003A4E8(a1, v45, v116, v46, v127, &v120, &v126);
          if ((_DWORD)v68)
          {
            uint64_t v19 = v68;
            uint64_t v34 = 0LL;
LABEL_249:
            uint64_t v107 = 0LL;
            goto LABEL_250;
          }

          unsigned int v33 = v113;
          uint64_t v19 = 0LL;
          if (v120) {
            goto LABEL_189;
          }
          uint64_t v43 = v126;
LABEL_115:
          uint64_t v126 = 0LL;
          uint64_t v48 = v47 & 0xFFFF0000;
          if (a4)
          {
            int v49 = a4[1];
            unsigned int v50 = *a4 | v48;
          }

          else
          {
            int v49 = 0;
            unsigned int v50 = v47 & 0xFFFF0000;
          }

          *(_DWORD *)(v43 + 36) = v50;
          *(_DWORD *)(v43 + 40) = v49;
          *(void *)(v43 + 112) = a3;
          if (!a6 || (uint64_t v52 = *(void *)(a6 + 496)) == 0) {
            uint64_t v52 = a6;
          }
          timespec v53 = (uint64_t *)(*(void *)(a1 + 704) + 8LL * (*(_DWORD *)(a1 + 700) & a3));
          uint64_t v54 = *v53;
          *(void *)(v43 + 72) = *v53;
          *(void *)(v43 + 8) = v52;
          unint64_t v55 = v124;
          if ((v33 & 8) == 0) {
            unint64_t v55 = v11;
          }
          *(void *)(v43 + 120) = v55;
          if ((v33 & 1) != 0) {
            unint64_t v56 = a3;
          }
          else {
            unint64_t v56 = 0LL;
          }
          *(void *)(v43 + 128) = v56;
          char v111 = (unint64_t *)(v43 + 128);
          uint64_t v57 = *(void *)(v43 + 16);
          uint64_t v58 = (unsigned __int16)v47 & 0xFC00;
          if ((v33 & 4) != 0) {
            uint64_t v58 = 0LL;
          }
          if (v54) {
            *(void *)(v54 + 80) = v43 + 72;
          }
          uint64_t v59 = v57 | v48 | v58;
          *timespec v53 = v43;
          *(void *)(v43 + 80) = v53;
          uint64_t v60 = v59 | 0x10000000003LL;
          *(void *)(v43 + 16) = v59 | 0x10000000003LL;
          if ((v47 & 0x50) != 0)
          {
            uint64_t v60 = v59 | 0x1000000000BLL;
            *(void *)(v43 + 16) = v59 | 0x1000000000BLL;
            if ((v47 & 0x40) != 0)
            {
              uint64_t v60 = v59 | 0x1100000000BLL;
              *(void *)(v43 + 16) = v59 | 0x1100000000BLL;
            }
          }

          if ((v47 & 0x180) != 0) {
            v60 |= 0x8000000000uLL;
          }
          unint64_t v61 = v60 | ((unint64_t)(v47 & 0x200) << 34);
          if ((v33 & 4) != 0) {
            v61 |= v109;
          }
          if ((v47 & 0x380) != 0 || (v33 & 4) != 0) {
            *(void *)(v43 + 16) = v61;
          }
          uint64_t v62 = (unint64_t *)(v43 + 24);
          do
            unint64_t v63 = __ldxr(v62);
          while (__stxr(v63 + 1, v62));
          uint64_t v115 = v43;
          if ((~(_DWORD)v63 & 0xFFFFFF) == 0) {
            panic("Reference count overflowed for object %p!\n", (const void *)v43);
          }
          if ((v47 & 0x180) != 0) {
            int v64 = v33;
          }
          else {
            int v64 = v33 | 0x10;
          }
          sub_100036F84(a1);
          unsigned __int8 v121 = 0;
          LOBYTE(v113) = v64 & 0x9F;
          if ((v64 & 4) != 0)
          {
            uint64_t v66 = *(void *)(v115 + 8);
            if (!v66) {
              uint64_t v66 = *(void *)(a1 + 392);
            }
            uint64_t v19 = sub_100041760(v66, a3, v11, v111, 0LL, &v122, &v125);
            if ((_DWORD)v19) {
              goto LABEL_179;
            }
            if ((v47 & 8) != 0 && v125 != v11)
            {
              uint64_t v19 = 2LL;
              goto LABEL_179;
            }
          }

          else if ((_DWORD)v19)
          {
            goto LABEL_179;
          }

          if ((v47 & 0x180) != 0)
          {
            unint64_t v65 = sub_10003C43C(a1, v47, a4, v110, a6, v115, v125, v122, &v119);
            uint64_t v19 = v65;
            if (v119)
            {
              if ((_DWORD)v65)
              {
                uint64_t v107 = v115;
                sub_10003B240(v115);
                uint64_t v34 = v115;
              }

              else
              {
                BOOL v106 = (v47 & 0x100) == 0;
                uint64_t v34 = v115;
                if (v106) {
                  uint64_t v107 = 0LL;
                }
                else {
                  uint64_t v107 = v115;
                }
              }

LABEL_250:
              LOBYTE(v33) = v113;
              goto LABEL_251;
            }
          }

          else
          {
            uint64_t v19 = sub_10003C6B0(v115, v125, v122, 0LL);
          }

LABEL_179:
          pthread_mutex_lock((pthread_mutex_t *)a1);
          unsigned __int8 v121 = 2;
          unint64_t v69 = v122;
          uint64_t v70 = v115;
          if ((v122 & 0xE0) != 0) {
            *(void *)(v115 + 16) = *(void *)(v115 + 16) & 0xFFFFFFFFFFFF1FFFLL | ((unint64_t)(v122 >> 5) << 13);
          }
          if ((v69 & 0x700) != 0) {
            *(void *)(v115 + 16) = *(void *)(v115 + 16) & 0xFFFFFFFFFFFFE3FFLL | (((v69 >> 8) & 7) << 10);
          }
          if ((_DWORD)v19) {
            goto LABEL_243;
          }
          uint64_t v71 = sub_10003C938((pthread_cond_t **)v115, v47, a3, a4, (uint64_t)v110, v11, v116, v117);
          if ((_DWORD)v71)
          {
            uint64_t v19 = v71;
            uint64_t v70 = v115;
LABEL_243:
            *(_DWORD *)(v70 + 52) = v19;
            sub_10003AE20(v115, v47);
            uint64_t v107 = v115;
            uint64_t v34 = 0LL;
            if ((v64 & 0x10) != 0) {
              LOBYTE(v33) = v64 & 0x8F;
            }
            else {
              LOBYTE(v33) = v64 & 0x9F;
            }
            *(void *)(v115 + 16) = *(void *)(v115 + 16) & 0xFFFFFFEFFFFFFFF7LL | 8;
LABEL_251:
            uint64_t v87 = v126;
            if (v126) {
              goto LABEL_252;
            }
            goto LABEL_253;
          }

          unsigned int v33 = v64 & 0xFFFFFF9F;
          uint64_t v35 = v115;
          goto LABEL_186;
        }
      }

      else
      {
        if ((v127 & 0x10) == 0)
        {
          uint64_t v34 = 0LL;
          uint64_t v107 = 0LL;
          goto LABEL_251;
        }

        uint64_t v43 = v126;
        if (!v126)
        {
          unsigned int v113 = v33;
          unsigned int v45 = 0;
          unsigned int v46 = 0;
          char v67 = v121;
          if (v121 == 1) {
            char v67 = 2;
          }
          unsigned __int8 v121 = v67;
          goto LABEL_172;
        }
      }

      unsigned int v47 = v127;
      goto LABEL_115;
    }

    uint64_t v35 = 0LL;
LABEL_52:
    uint64_t v36 = *(void *)(v34 + 8);
    if (v36 != a6 && (!a6 || v36 != *(void *)(a6 + 496))) {
      goto LABEL_97;
    }
    uint64_t v37 = *(void *)(v34 + 16);
    if ((v37 & 0xC8000000) != (v30 & 0xC8000000) || *(void *)(v34 + 112) != a3) {
      goto LABEL_97;
    }
    if ((v37 & 2) == 0) {
      break;
    }
    if ((v30 & 0x180) == 0)
    {
      char v81 = v121;
      if (v121 == 1) {
        char v81 = 2;
      }
      unsigned __int8 v121 = v81;
      *(void *)(v34 + 16) = v37 | 4;
      unsigned int v82 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
      sub_10003C3B8((uint64_t *)v34);
      int v31 = v112;
      unsigned int v33 = v82;
LABEL_231:
      int v26 = v117;
      goto LABEL_190;
    }

    if (*(_DWORD *)(v34 + 52))
    {
      uint64_t v107 = 0LL;
      uint64_t v19 = *(unsigned int *)(v34 + 52);
      goto LABEL_251;
    }

    if ((~(_BYTE)v37 & 0xA) == 0)
    {
      uint64_t v107 = 0LL;
      uint64_t v19 = 16LL;
      goto LABEL_251;
    }

    if ((v30 & 0x100) != 0)
    {
      uint64_t v107 = 0LL;
      uint64_t v19 = 0LL;
      goto LABEL_251;
    }

    unsigned int v113 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
    if ((v37 & 0x8000000000LL) != 0)
    {
      *(void *)(v34 + 16) = v37 | 4;
      sub_100013AD4(v108, (pthread_mutex_t *)a1, 2LL, 0LL);
    }

    else if ((sub_100037DD0((void *)v34, &v123, 0, v121) & 1) == 0)
    {
      uint64_t v107 = 0LL;
      uint64_t v19 = 0LL;
      goto LABEL_250;
    }

    unsigned int v33 = v113;
LABEL_189:
    int v31 = v112;
LABEL_190:
    unsigned int v30 = v127;
    unsigned int v29 = v33;
  }

  if (v31 && (unsigned __int16)*(_DWORD *)(v34 + 36) && ((*(_DWORD *)(v34 + 36) ^ v116) & 0xEFFFFFFF) != 0
    || v26 && *(_DWORD *)(v34 + 40) != v26)
  {
    goto LABEL_97;
  }

  if ((v29 & 3) != 0)
  {
    uint64_t v35 = v34;
    if ((v29 & 2) == 0) {
      goto LABEL_99;
    }
LABEL_176:
    if (v35) {
      goto LABEL_186;
    }
LABEL_241:
    uint64_t v34 = 0LL;
    uint64_t v107 = 0LL;
    uint64_t v19 = 2LL;
    goto LABEL_251;
  }

  if (v124)
  {
    unint64_t v38 = *(void *)(v34 + 120);
    if (v38 <= *(void *)(v34 + 144)) {
      unint64_t v38 = *(void *)(v34 + 144);
    }
    if (!v11)
    {
      if (v38 < v124) {
        goto LABEL_97;
      }
LABEL_76:
      char v39 = 1;
      goto LABEL_77;
    }

    if (v38 != v124) {
      goto LABEL_97;
    }
  }

  else
  {
    if (!v11) {
      goto LABEL_76;
    }
    unint64_t v38 = *(void *)(v34 + 120);
    if (v38 <= *(void *)(v34 + 144)) {
      unint64_t v38 = *(void *)(v34 + 144);
    }
  }

  if (v38 > v11) {
    goto LABEL_97;
  }
  char v39 = 0;
LABEL_77:
  if (!v35) {
    goto LABEL_96;
  }
  unint64_t v40 = *(void *)(v34 + 120);
  if (v40 <= *(void *)(v34 + 144)) {
    unint64_t v40 = *(void *)(v34 + 144);
  }
  unint64_t v41 = *(void *)(v35 + 120);
  if (v41 <= *(void *)(v35 + 144)) {
    unint64_t v41 = *(void *)(v35 + 144);
  }
  if (v40 >= v41)
  {
    if (v40 == v41)
    {
      if ((v39 & 1) != 0)
      {
        if ((v37 & 0x200) != 0 && (*(_BYTE *)(v35 + 17) & 2) == 0) {
          goto LABEL_97;
        }
      }

      else if ((v37 & 0x200) == 0 && (*(_BYTE *)(v35 + 17) & 2) != 0)
      {
        goto LABEL_97;
      }
    }

    if ((v30 & 0x200) != 0)
    {
      if ((v37 & 0x80000000000LL) != 0 || (*(_BYTE *)(v35 + 21) & 8) == 0) {
LABEL_96:
      }
        uint64_t v35 = v34;
    }

    else if ((v37 & 0x80000000000LL) == 0 || (*(_BYTE *)(v35 + 21) & 8) != 0)
    {
      goto LABEL_96;
    }
  }

LABEL_97:
  uint64_t v34 = *(void *)(v34 + 72);
  if (v34) {
    goto LABEL_52;
  }
  if ((v29 & 2) != 0) {
    goto LABEL_176;
  }
LABEL_99:
  if (!v35 || (v29 & 4) == 0)
  {
    if (!v35) {
      goto LABEL_107;
    }
    if ((v29 & 4) != 0) {
      goto LABEL_119;
    }
LABEL_186:
    unsigned int v72 = v33;
    uint64_t v34 = v35;
    uint64_t v19 = sub_10003CB54(v35, v127, v11, (v33 >> 6) & 1, &v123, &v121);
    if ((_DWORD)v19 != 35)
    {
      uint64_t v107 = 0LL;
      LOBYTE(v33) = v72;
      goto LABEL_251;
    }

    unsigned int v33 = v72;
LABEL_188:
    int v26 = v117;
    goto LABEL_189;
  }

  uint64_t v42 = *(void *)(v35 + 16);
  if ((v42 & 0x40) != 0)
  {
LABEL_119:
    uint64_t v42 = *(void *)(v35 + 16);
    if (v11) {
      goto LABEL_120;
    }
    goto LABEL_192;
  }

  if (!v11)
  {
    if (!(*(void *)(v35 + 16) & 0x20LL | v124)) {
      goto LABEL_210;
    }
LABEL_192:
    if ((v42 & 0x100) != 0) {
      goto LABEL_186;
    }
    char v51 = 1;
LABEL_194:
    char v73 = v121;
    if (v121 == 1) {
      char v73 = 2;
    }
    unsigned __int8 v121 = v73;
    unsigned int v74 = (unint64_t *)(v35 + 24);
    do
      unint64_t v75 = __ldxr(v74);
    while (__stxr(v75, v74));
    if ((v75 & 0xFFFFFF) == ((v75 >> 24) & 0xFFFFF))
    {
      if ((v51 & 1) != 0)
      {
        unint64_t v76 = v42 & 0xFFFFFFFFFFFFFCDFLL | 0x120;
LABEL_223:
        *(void *)(v35 + 16) = v76;
LABEL_227:
        if ((v33 & 8) == 0) {
          goto LABEL_186;
        }
        uint64_t v83 = *(void *)(v35 + 16);
        if ((v83 & 0x20000000000LL) == 0)
        {
          unint64_t v124 = *(void *)(v35 + 120);
          goto LABEL_107;
        }

        *(void *)(v35 + 16) = v83 | 0x80;
        unsigned int v84 = v33;
        sub_100013AD4(v108, (pthread_mutex_t *)a1, 2LL, 0LL);
        int v31 = v112;
        unsigned int v33 = v84 & 0xFFFFFFF7;
        goto LABEL_231;
      }

      if ((v30 & 0x200) == 0 || (v42 & 0x80000000000LL) != 0)
      {
        unint64_t v76 = v42 & 0xFFFFFFFFFFFFFCFFLL | 0x200;
        goto LABEL_223;
      }
    }

    else
    {
      if ((v51 & 1) != 0)
      {
        if ((v42 & 0x200) != 0)
        {
          unsigned int v113 = (v29 & 0xFFFFFFBF | (((v30 >> 8) & 1) << 6)) ^ 0x40;
          if (!v126)
          {
            uint64_t v34 = v35;
            uint64_t v19 = sub_10003A4E8( a1,  *(_DWORD *)(v35 + 44),  *(_DWORD *)(v35 + 36),  *(_DWORD *)(v35 + 48),  v30,  &v120,  &v126);
            if ((_DWORD)v19) {
              goto LABEL_249;
            }
            if (v126 == v34 || v120) {
              goto LABEL_214;
            }
            uint64_t v35 = v34;
            uint64_t v42 = *(void *)(v34 + 16);
          }

          *(void *)(v35 + 16) = v42 & 0xFFFFFFFFFFFFFFDFLL;
          uint64_t v77 = v35;
          if (sub_10003A0A0((pthread_cond_t **)v35, 0, &v126, &v120))
          {
            uint64_t v19 = 0LL;
            unsigned int v33 = v113 | 8;
            uint64_t v35 = v77;
          }

          else
          {
            uint64_t v35 = v126;
            uint64_t v126 = 0LL;
            *(void *)(v35 + 16) |= 0x120uLL;
            char v85 = (unint64_t *)(v35 + 24);
            do
              unint64_t v86 = __ldxr(v85);
            while (__stxr(v86 - 1, v85));
            uint64_t v19 = 0LL;
            unsigned int v33 = v113;
          }
        }

        goto LABEL_227;
      }

      if ((v42 & 0x100) == 0 || (v30 & 8) != 0)
      {
        if ((v30 & 0x200) != 0 && (v42 & 0x80000000000LL) == 0) {
          v33 |= 8u;
        }
        goto LABEL_227;
      }
    }

    v33 |= 8u;
    goto LABEL_227;
  }

  if (v11 <= *(void *)(v35 + 168) || v124)
  {
LABEL_120:
    if ((v42 & 0x200) != 0) {
      goto LABEL_186;
    }
    char v51 = 0;
    goto LABEL_194;
  }

LABEL_253:
  char v90 = v33;
  if (v121) {
    sub_100037014((pthread_mutex_t *)a1, v121);
  }
  if (v107) {
    sub_100038824(v107);
  }
  if (!(_DWORD)v19)
  {
    if (v34)
    {
      char v91 = v127;
      if ((v127 & 4) != 0)
      {
        if ((v127 & 1) != 0) {
          char v92 = 2;
        }
        else {
          char v92 = 1;
        }
        sub_10003CF10(v34, v92);
        char v91 = v127;
      }

      if ((v91 & 1) != 0 && (uint64_t v93 = sub_10003CF9C((void *)v34, v91 & 3, a8), (_DWORD)v93))
      {
        uint64_t v19 = v93;
        if ((v127 & 4) != 0)
        {
          if ((v127 & 1) != 0) {
            char v94 = 2;
          }
          else {
            char v94 = 1;
          }
          sub_10003D514(v34, v94);
        }

        sub_100038824(v34);
      }

      else
      {
        if ((v90 & 2) == 0)
        {
          timespec v95 = (unint64_t *)(a1 + 1072);
          do
            unint64_t v96 = __ldxr(v95);
          while (__stxr(v96 + 1, v95));
          timespec v97 = (unint64_t *)(a1 + 1088);
          if ((v90 & 0x20) != 0) {
            timespec v97 = (unint64_t *)(a1 + 1080);
          }
          do
            unint64_t v98 = __ldxr(v97);
          while (__stxr(v98 + 1, v97));
          uint64_t v99 = qword_100070558;
          timespec v100 = (unint64_t *)(qword_100070558 + 264);
          do
            unint64_t v101 = __ldxr(v100);
          while (__stxr(v101 + 1, v100));
          timespec v102 = (unint64_t *)(v99 + 280);
          timespec v103 = (unint64_t *)(v99 + 272);
          if ((v90 & 0x20) == 0) {
            timespec v103 = v102;
          }
          do
            unint64_t v104 = __ldxr(v103);
          while (__stxr(v104 + 1, v103));
        }

        uint64_t v19 = 0LL;
        if ((v127 & 0x100) != 0) {
          uint64_t v105 = 0LL;
        }
        else {
          uint64_t v105 = v34;
        }
        *a9 = v105;
      }
    }

    else
    {
      return 2LL;
    }
  }

  return v19;
}

uint64_t sub_10003C2B4(uint64_t result, _BYTE *a2)
{
  *a2 = 1;
  uint64_t v2 = *(void *)(result + 1344);
  if (v2)
  {
    uint64_t v4 = result;
    while (1)
    {
      if ((*(_BYTE *)(*(void *)(v2 + 136) + 20LL) & 0x80) == 0)
      {
        uint64_t result = sub_100051F5C(*(void *)(*(void *)(v4 + 392) + 384LL));
        if ((_DWORD)result != 36) {
          break;
        }
      }

      uint64_t v2 = *(void *)(v2 + 104);
      if (!v2) {
        return result;
      }
    }

    return sub_10003DAB0(v2, a2);
  }

  return result;
}

uint64_t sub_10003C330(uint64_t result, int a2, unsigned int *a3)
{
  uint64_t v4 = *(void *)(result + 496);
  if (!v4) {
    uint64_t v4 = result;
  }
  uint64_t v5 = *(void *)(v4 + 376);
  unsigned int v6 = *a3;
  if ((*(_BYTE *)(v5 + 264) & 1) != 0)
  {
    unsigned int v10 = v6 & 0xEFFF03FF;
  }

  else
  {
    unsigned int v7 = v6 & 0xFFFF1FFF;
    if (a2 == 36) {
      int v8 = 268443648;
    }
    else {
      int v8 = 0x10000000;
    }
    *a3 = v7 | v8;
    uint64_t result = sub_10002F44C(result);
    if ((_DWORD)result) {
      int v9 = 1024;
    }
    else {
      int v9 = 0;
    }
    unsigned int v10 = *a3 & 0xFFFFE3FF | v9;
  }

  *a3 = v10;
  return result;
}

uint64_t sub_10003C3B8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  __int128 v5 = xmmword_10005B9E0;
  uint64_t v2 = a1[2];
  uint64_t result = sub_100013AD4( (pthread_cond_t *)(v1 + 1296),  (pthread_mutex_t *)v1,  2LL,  (timespec *)((unint64_t)&v5 & (v2 << 23 >> 63)));
  if ((v2 & 0x10000000000LL) != 0 && *(void *)(v1 + 1344))
  {
    char v4 = -86;
    uint64_t result = sub_10003C2B4(v1, &v4);
    if (!v4) {
      return pthread_mutex_lock((pthread_mutex_t *)v1);
    }
  }

  return result;
}

unint64_t sub_10003C43C( uint64_t a1, int a2, _OWORD *a3, _WORD *a4, uint64_t a5, uint64_t a6, unint64_t a7, unsigned int a8, _BYTE *a9)
{
  *a9 = 0;
  uint64_t v17 = (void (**)(uint64_t, int8x16_t, int8x16_t))sub_100013EEC(1uLL, 0xA0uLL);
  if (!v17)
  {
    unint64_t v21 = 12LL;
LABEL_15:
    *a9 = 1;
    return v21;
  }

  BOOL v18 = v17;
  if (!a4) {
    goto LABEL_18;
  }
  if (*a4 != 25987)
  {
    if (!a5) {
      a5 = *(void *)(a1 + 392);
    }
    if (*(_WORD *)(a5 + 36) == 13) {
      int v22 = (const char *)(a5 + 3992);
    }
    else {
      int v22 = (const char *)(*(void *)(a5 + 384) + 208LL);
    }
    sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%x type 0x%x/0x%x: attempt to perform async fetch without proper init args\n",  "obj_get_async_read",  3588,  v22,  *(void *)(a6 + 112),  a2,  *(_DWORD *)(a6 + 36),  *(_DWORD *)(a6 + 40));
    unint64_t v21 = 22LL;
    goto LABEL_14;
  }

  if (!a4[1])
  {
    size_t v20 = 0LL;
    uint64_t v19 = v17[19];
    goto LABEL_17;
  }

  uint64_t v19 = (void (*)(uint64_t, int8x16_t, int8x16_t))sub_100014044((unsigned __int16)a4[1]);
  bzero(v19, (unsigned __int16)a4[1]);
  v18[19] = v19;
  if (!v19)
  {
    unint64_t v21 = 12LL;
LABEL_14:
    sub_100014004(v18, 160LL);
    goto LABEL_15;
  }

  size_t v20 = (unsigned __int16)a4[1];
LABEL_17:
  memcpy(v19, a4, v20);
  *((_BYTE *)v18 + 148) = 1;
LABEL_18:
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v18[13] = 0LL;
  unsigned int v23 = *(void (****)(uint64_t, int8x16_t, int8x16_t))(a1 + 1352);
  v18[14] = (void (*)(uint64_t, int8x16_t, int8x16_t))v23;
  *unsigned int v23 = v18;
  *(void *)(a1 + 1352) = v18 + 13;
  sub_100036F84(a1);
  *BOOL v18 = sub_10003EF30;
  v18[17] = (void (*)(uint64_t, int8x16_t, int8x16_t))a6;
  *(_OWORD *)(v18 + 15) = *a3;
  *((_DWORD *)v18 + 36) = a2;
  unint64_t v24 = (unint64_t *)(a6 + 24);
  do
    unint64_t v25 = __ldxr(v24);
  while (__stxr(v25 + 1, v24));
  if ((~(_DWORD)v25 & 0xFFFFFFLL) == 0) {
    panic("Reference count overflowed for object %p!\n", (const void *)a6);
  }
  int v26 = (unsigned int *)(a1 + 916);
  do
    unsigned int v27 = __ldxr(v26);
  while (__stxr(v27 + 1, v26));
  unint64_t v21 = sub_10003C6B0(a6, a7, a8, (uint64_t)v18);
  if (!(_DWORD)v21)
  {
    *a9 = 1;
    pthread_mutex_lock((pthread_mutex_t *)a1);
    uint64_t v28 = *(void *)(a6 + 16);
    unint64_t v29 = (v28 & 4 ^ 0xFFFFFF7FFFFFFFFFLL) & v28;
    if ((a8 & 0xE0) != 0) {
      unint64_t v29 = v29 & 0xFFFFFFFFFFFF1FFFLL | (a8 << 8) & 0xE000;
    }
    if ((a8 & 0x700) != 0) {
      unint64_t v29 = v29 & 0xFFFFFFFFFFFFE3FFLL | (4 * a8) & 0x1C00;
    }
    *(void *)(a6 + 16) = v29;
    sub_100036F84(a1);
    if ((v28 & 4) != 0) {
      j__pthread_cond_broadcast((pthread_cond_t *)(a1 + 1296));
    }
    return 0LL;
  }

  return v21;
}

unint64_t sub_10003C6B0(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 128);
  uint64_t v8 = *(void *)(a1 + 8);
  if (v7)
  {
    int v9 = *(_DWORD *)(a1 + 36);
    if ((a3 & 4) != 0 && v8)
    {
      *(_DWORD *)(a1 + 36) = v9 | 0x10000000;
      if ((*(_BYTE *)(a1 + 21) & 8) != 0)
      {
        int v13 = 0;
        uint64_t v14 = 0LL;
        uint64_t v15 = 0LL;
        if ((a3 & 8) != 0) {
          goto LABEL_27;
        }
      }

      else
      {
        if (a3 >> 5 == 1)
        {
          uint64_t v10 = v8 + 624;
          uint64_t v11 = v8 + 816;
        }

        else
        {
          uint64_t v10 = v8 + 528;
          uint64_t v11 = v8 + 720;
        }

        if ((a3 & 0x10) != 0) {
          uint64_t v14 = v11;
        }
        else {
          uint64_t v14 = v10;
        }
        int v13 = (a3 >> 8) & 7;
        if (v13)
        {
          if (v13 != 1) {
            panic("invalid tweak type %d\n");
          }
          uint64_t v15 = *(void *)(a1 + 112) ^ HIDWORD(a2) | *(void *)(a1 + 112) & 0xFFFFFFFF00000000LL ^ (a2 << 32);
          int v13 = 4;
          if ((a3 & 8) != 0) {
            goto LABEL_27;
          }
        }

        else
        {
          uint64_t v15 = (a3 >> 8) & 7;
          if ((a3 & 8) != 0) {
            goto LABEL_27;
          }
        }
      }
    }

    else
    {
      int v13 = 0;
      uint64_t v14 = 0LL;
      uint64_t v15 = 0LL;
      *(_DWORD *)(a1 + 36) = v9 & 0xEFFFFFFF;
      if ((a3 & 8) != 0) {
        goto LABEL_27;
      }
    }

    if ((*(_BYTE *)(a1 + 21) & 8) == 0)
    {
LABEL_28:
      if (v14 && (uint64_t v17 = *(void *)(v8 + 1136)) != 0)
      {
        uint64_t v18 = *(void *)(*(void *)a1 + 392LL);
      }

      else
      {
        uint64_t v18 = *(void *)(*(void *)a1 + 392LL);
        uint64_t v17 = *(void *)(v18 + 384);
      }

      uint64_t v19 = sub_100051ED0( v17,  v7,  (*(_DWORD *)(a1 + 48) + *(_DWORD *)(*(void *)(v18 + 376) + 36LL) - 1)
            / *(_DWORD *)(*(void *)(v18 + 376) + 36LL),
              *(void *)(a1 + 56),
              v14,
              a4 != 0,
              a4,
              v15,
              v13);
      unint64_t v16 = v19;
      if (!a4 && !(_DWORD)v19)
      {
        if ((*(void *)(a1 + 16) & 0x80020000000LL) != 0)
        {
          return 0LL;
        }

        else
        {
          unint64_t v16 = sub_10003D9B0(a1, v20, v21);
          if ((_DWORD)v16)
          {
            uint64_t v22 = *(void *)(a1 + 8);
            if (v22) {
              unsigned int v23 = (const char *)(v22 + 3992);
            }
            else {
              unsigned int v23 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
            }
            sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx error verifying checksum\n",  "obj_read",  6372,  v23,  *(void *)(a1 + 112),  *(void *)(a1 + 16),  *(_DWORD *)(a1 + 32),  *(_DWORD *)(a1 + 36),  *(_DWORD *)(a1 + 40),  *(void *)(a1 + 128));
          }
        }
      }

      return v16;
    }

uint64_t sub_10003C938( pthread_cond_t **a1, __int16 a2, uint64_t a3, _DWORD *a4, uint64_t a5, unint64_t a6, int a7, int a8)
{
  unint64_t v12 = (unint64_t)a1[2];
  if ((v12 & 0x80020000000LL) != 0)
  {
LABEL_2:
    uint64_t v13 = 0LL;
    if ((a2 & 0x210) == 0 && a4)
    {
      uint64_t v25 = 0LL;
      uint64_t v14 = sub_10003AE68(*((_DWORD *)a1 + 9), &v25);
      if ((_DWORD)v14)
      {
        uint64_t v13 = v14;
      }

      else
      {
        uint64_t v19 = *(uint64_t (**)(pthread_cond_t **, uint64_t))(v25 + 8);
        if (v19)
        {
          uint64_t v13 = v19(a1, a5);
          unint64_t v12 = (unint64_t)a1[2];
        }

        else
        {
          uint64_t v13 = 0LL;
        }
      }
    }

    goto LABEL_33;
  }

  uint64_t v15 = a1[7];
  unint64_t v16 = *(pthread_cond_t **)&v15->__opaque[8];
  a1[15] = v16;
  if (!a8) {
    *((_DWORD *)a1 + 10) = *(_DWORD *)&v15->__opaque[20];
  }
  if ((!(_WORD)a7 || ((*(_DWORD *)&v15->__opaque[16] ^ a7) & 0xEFFFFFFF) == 0)
    && (!a8 || *(_DWORD *)&v15->__opaque[20] == a8)
    && *(void *)v15->__opaque == a3)
  {
    uint64_t v13 = 0LL;
    if (!a6 || (unint64_t)v16 <= a6)
    {
LABEL_19:
      if (!a4) {
        goto LABEL_27;
      }
      goto LABEL_25;
    }
  }

  if ((a2 & 0x20) != 0)
  {
    uint64_t v13 = 2LL;
    goto LABEL_19;
  }

  uint64_t v17 = a1[1];
  if (v17) {
    opaque = v17[83].__opaque;
  }
  else {
    opaque = (const char *)(*(void *)(*(void *)(*a1)[8].__opaque + 384LL) + 208LL);
  }
  sub_100013D94( "%s:%d: %s wrong object at 0x%llx - wanted oid 0x%llx type 0x%x:0x%x xid %lld - got oid 0x%llx type 0x%x:0x%x xid %lld\n",  "obj_init",  3220,  opaque,  a1[16],  a3,  a7,  a8,  a6,  *(void *)v15->__opaque,  *(_DWORD *)&v15->__opaque[16],  *(_DWORD *)&v15->__opaque[20],  v16);
  uint64_t v13 = sub_100005194(*(void *)(*a1)[8].__opaque);
  if (!a4) {
    goto LABEL_27;
  }
LABEL_25:
  if (*a4)
  {
    int v20 = *((_DWORD *)a1 + 9);
    goto LABEL_28;
  }

uint64_t sub_10003CB54(uint64_t a1, int a2, unint64_t a3, int a4, int *a5, _BYTE *a6)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if ((v6 & 0x10) != 0) {
    return 2LL;
  }
  uint64_t v10 = *(void *)a1;
  if ((a2 & 0x40) == 0 && (v6 & 0x1000000008LL) == 0x1000000008LL)
  {
    if (*a6 == 1)
    {
      *a6 = 2;
      uint64_t v6 = *(void *)(a1 + 16);
    }

    *(void *)(a1 + 16) = v6 & 0xFFFFFFEFFFFFFFF7LL;
  }

  unsigned int v12 = a2 & 0xC8000000;
  uint64_t v13 = (unsigned int *)(a1 + 32);
  do
    unsigned int v14 = __ldxr(v13);
  while (__stxr(v14 & 0xFFFFFFFD, v13));
  if ((v14 & 2) != 0) {
    j__pthread_cond_broadcast((pthread_cond_t *)(v10 + 1296));
  }
  if ((*(_BYTE *)v13 & 1) == 0 && (*(_BYTE *)(a1 + 19) & 0x80) == 0)
  {
    int v15 = pthread_rwlock_rdlock((pthread_rwlock_t *)(v10 + 128));
    if (v15) {
      panic( "%s:%d: rdlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  3303,  v15);
    }
    if (*(void *)(a1 + 88) != 3735928559LL) {
      sub_10003DD00(v10, a1);
    }
    int v16 = pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 128));
    if (v16) {
      panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  3307,  v16);
    }
  }

  uint64_t result = 0LL;
  if (!v12 && a3)
  {
    uint64_t result = 0LL;
    unint64_t v17 = *(void *)(a1 + 168);
    if (v17 <= a3) {
      unint64_t v17 = a3;
    }
    *(void *)(a1 + 168) = v17;
  }

  return result;
}

void sub_10003CCD4(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(a1 + 16);
  if ((v5 & 1) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 72);
    if (v6) {
      *(void *)(v6 + 80) = *(void *)(a1 + 80);
    }
    **(void **)(a1 + 80) = v6;
    *(void *)(a1 + 16) = v5 & 0xFFFFFFFFFFFFFFFELL;
  }

  uint64_t v7 = (unsigned int *)(a1 + 32);
  char v8 = atomic_load((unsigned int *)(a1 + 32));
  int v9 = v8 & 0x10;
  if (*(void *)(a1 + 88) != 3735928559LL || v9 != 0)
  {
    int v11 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 128));
    if (v11) {
      panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  2908,  v11);
    }
    uint64_t v12 = *(void *)(a1 + 88);
    if (v12 == 3735928559LL) {
      goto LABEL_30;
    }
    uint64_t v13 = *(void *)(a1 + 16);
    if ((v13 & 0x80000000) == 0)
    {
      if ((*(_BYTE *)v7 & 1) == 0)
      {
        sub_10003ECE4((uint64_t *)a1);
        do
LABEL_30:
          unsigned int v16 = __ldxr(v7);
        while (__stxr(v16 & 0xFFFFEF, v7));
        if ((v16 & 0x10) != 0) {
          *(void *)(*(void *)(v4 + 872) + 8LL * HIBYTE(v16)) = 0LL;
        }
        int v17 = pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 128));
        if (v17) {
          panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  2936,  v17);
        }
        goto LABEL_35;
      }

      if (*(void *)(v4 + 864) == a1) {
        *(void *)(v4 + 864) = v12;
      }
      int v15 = *(void **)(a1 + 96);
      if ((v13 & 0x40000000) != 0)
      {
        if (v12)
        {
          *(void *)(v12 + 96) = v15;
          int v15 = *(void **)(a1 + 96);
        }

        else
        {
          *(void *)(v4 + 824) = v15;
        }

        *int v15 = v12;
        --*(_DWORD *)(v4 + 888);
      }

      else
      {
        if (v12)
        {
          *(void *)(v12 + 96) = v15;
          int v15 = *(void **)(a1 + 96);
        }

        else
        {
          *(void *)(v4 + 808) = v15;
        }

        *int v15 = v12;
        --*(_DWORD *)(v4 + 884);
      }

LABEL_29:
      *(void *)(a1 + 88) = 3735928559LL;
      goto LABEL_30;
    }

    unsigned int v14 = *(void **)(a1 + 96);
    if ((v13 & 0x8000000) != 0)
    {
      if (!v12)
      {
        *(void *)(v4 + 760) = v14;
        goto LABEL_28;
      }
    }

    else if (!v12)
    {
      *(void *)(v4 + 744) = v14;
LABEL_28:
      *unsigned int v14 = v12;
      goto LABEL_29;
    }

    *(void *)(v12 + 96) = v14;
    unsigned int v14 = *(void **)(a1 + 96);
    goto LABEL_28;
  }

    if (!v123) {
      pthread_mutex_unlock(v16);
    }
    uint64_t v35 = a6;
    if (v134)
    {
      sub_10003D514(v134, 2);
      uint64_t v109 = 0;
    }

    uint64_t v36 = v19 % v12[10];
    uint64_t v37 = v32 + 32 * v36;
    unint64_t v40 = *(void *)(v37 + 64);
    char v39 = (void *)(v37 + 64);
    unint64_t v38 = v40;
    if (a7 == 1)
    {
LABEL_34:
      if (v38) {
        goto LABEL_35;
      }
      if (((*(_DWORD *)(v32 + 32 * v36 + 56) ^ *(_DWORD *)(v32 + 32 * v36 + 60)) & 0xFFFFF) != 0) {
        unint64_t v96 = sub_100005194(v11);
      }
      else {
        unint64_t v96 = 22LL;
      }
      timespec v95 = 1;
      goto LABEL_128;
    }

    while (1)
    {
LABEL_35:
      if (v38)
      {
        unint64_t v41 = sub_10003B574(*(void *)(v11 + 392), 1073741825LL, v38, &xmmword_10005BA74, 0LL, 0LL, 0LL, v35, &v132);
        if ((_DWORD)v41)
        {
          unint64_t v96 = v41;
          sub_100013D94("%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n");
LABEL_117:
          timespec v95 = 1;
          goto LABEL_128;
        }

        uint64_t v42 = *(_DWORD **)(v132 + 56);
      }

      else
      {
        uint64_t v42 = 0LL;
      }

      uint64_t v43 = (uint64_t *)(v32 + 32 * v36 + 40);
      char v44 = v12[9];
      unsigned int v45 = v130 % v44;
      unsigned int v46 = v44 - v130 % v44;
      if (a5 >= v46) {
        unsigned int v47 = v46;
      }
      else {
        unsigned int v47 = a5;
      }
      if (v38 && *v43 == v35)
      {
        uint64_t v48 = v38;
        int v49 = a1;
      }

      else
      {
        unsigned int v50 = sub_1000439F4((uint64_t)a1, v10, v35, v131);
        if ((_DWORD)v50)
        {
          uint64_t v93 = v50;
          sub_100013D94("%s:%d: %s failed to allocate block from internal pool: %d\n");
          goto LABEL_115;
        }

        *uint64_t v43 = v35;
        uint64_t v48 = v131[0];
        *char v39 = v131[0];
        if (v38)
        {
          sub_10003E644(v132, v35, v48);
          int v49 = a1;
          char v51 = sub_10004E254((uint64_t)a1, (pthread_mutex_t *)v10, v38, v35);
          if ((_DWORD)v51)
          {
            uint64_t v93 = v51;
            sub_100013D94("%s:%d: %s failed to free internal pool block %lld: %d\n");
LABEL_115:
            timespec v95 = 1;
            unint64_t v96 = v93;
            goto LABEL_128;
          }
        }

        else
        {
          int v49 = a1;
          uint64_t v52 = sub_10003A068(a1[49], 0x40000000, v48, (int)&xmmword_10005BA74, 0, 0, v35, (uint64_t)&v132);
          if ((_DWORD)v52)
          {
            unint64_t v96 = v52;
            sub_100013D94("%s:%d: %s failed to create bitmap object %lld: %d\n");
            goto LABEL_117;
          }

          uint64_t v42 = *(_DWORD **)(v132 + 56);
        }
      }

      unsigned int v122 = v48;
      unint64_t v124 = v47;
      timespec v53 = *(void *)(v10 + 376);
      uint64_t v54 = __clz(__rbit64(*(unsigned int *)(v49[47] + 36LL)));
      unint64_t v55 = (0x4000000000000000uLL >> v54) & v128;
      if (a7 == 1)
      {
        int v117 = *(void *)(v10 + 376);
        char v119 = v55 != 0;
        unint64_t v56 = sub_10001D7F0((uint64_t)v42, 0, v45, v47 + v45);
        uint64_t v57 = v56;
        if (v56) {
          sub_100013D94( "%s:%d: %s freeing 0x%llx:%lld, but %lld bits are already clear.  Double free?\n",  "spaceman_clear_bits_in_bm",  5290,  (const char *)(a1[48] + 208LL),  v128,  a5,  v56);
        }
        uint64_t v58 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v54) & v128;
        uint64_t v59 = a1[47];
        uint64_t v60 = *(void *)(v59 + 1248);
        if (!v60
          || (unint64_t v61 = *(void *)(v59 + 1240),
              uint64_t v62 = __clz(__rbit64(*(unsigned int *)(v59 + 36))),
              (v55 != 0) == (((v61 << v62) & 0x4000000000000000LL) == 0)))
        {
          unint64_t v63 = a5;
          unint64_t v65 = 0LL;
          uint64_t v66 = v57;
        }

        else
        {
          unint64_t v63 = a5;
          uint64_t v135 = 0xAAAAAAAAAAAAAAAALL;
          int v64 = sub_100013C78(v58, v47, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v62) & v61, v60, &v135);
          unint64_t v65 = v64;
          if (v64) {
            int v64 = sub_10001D7F0( (uint64_t)v42,  0,  v135 - *(void *)(v126 + 32 * v36 + 48),  v135 + v64 - *(void *)(v126 + 32 * v36 + 48));
          }
          uint64_t v66 = v57 - v64;
        }

        uint64_t v68 = v55 != 0;
        sub_10001D400((uint64_t)v42, v45, v47);
        sub_10004D7EC(a3, v119, v42, v58 / *(unsigned int *)(v117 + 36));
        char v120 = v36;
        *(_DWORD *)(v126 + 32 * v36 + 60) += v47 - v57;
        pthread_mutex_lock(v121);
        *(void *)(v117 + 48 * v68 + 72) += v47 - v66 - v65;
        a5 = v63;
        uint64_t v10 = a3;
        uint64_t v12 = v115;
        if ((a8 & 1) != 0)
        {
          unint64_t v69 = a3 + 8 * v68;
          uint64_t v70 = *(void *)(v69 + 976);
          uint64_t v71 = v70 >= v47;
          unsigned int v72 = v70 - v47;
          if (!v71) {
            unsigned int v72 = 0LL;
          }
          *(void *)(v69 + 976) = v72;
        }

        goto LABEL_98;
      }

      char v67 = v126 + 32 * v36;
      if (sub_10001D234((uint64_t)v42, v45, v47))
      {
        sub_10001D318((uint64_t)v42, v45, v47);
        char v120 = v36;
        sub_10004D7EC( v10,  v55 != 0,  v42,  v36 + *(unsigned int *)(v53 + 40) * (unint64_t)*(unsigned int *)(v126 + 32));
        pthread_mutex_lock(v121);
        *(_DWORD *)(v67 + 60) -= v47;
        char v118 = v53;
        *(void *)(v53 + 48LL * (v55 != 0) + 72) -= v47;
        if ((a8 & 1) != 0)
        {
          unint64_t v75 = v10 + 8LL * (v55 != 0);
          unint64_t v76 = (void *)(v75 + 848);
          uint64_t v77 = *(void *)(v75 + 848);
          if (*(void *)(v75 + 832) < v77)
          {
            uint64_t v78 = "Main";
            if (v55) {
              uint64_t v78 = "T2";
            }
            panic( "%s, Reserved space < reserved metadata: %llu < %llu\n",  v78,  *(void *)(v10 + 832),  *(void *)(v10 + 848));
          }

          int v79 = (void *)(v75 + 832);
          uint64_t v12 = v115;
          if ((a8 & 0x40) != 0)
          {
            if (v77 < v47) {
              panic("reserved metadata space underflow: %lld (%lld)\n", v77, v47);
            }
            *unint64_t v76 = v77 - v47;
            *v79 -= v47;
          }

          else
          {
            if (*v79 - v77 >= v47)
            {
              uint64_t v77 = *v79 - v47;
            }

            else if (sub_100037DC8(v102) == 13)
            {
              sub_100013D94( "%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n",  "spaceman_set_bits_in_bm",  5403,  v101,  *v79 - v77,  v77,  v47);
            }

            else
            {
              sub_100013D94( "%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n",  "spaceman_set_bits_in_bm",  5403,  (const char *)(*(void *)(v102 + 384) + 208LL),  *v79 - v77,  v77,  v47);
            }

            *int v79 = v77;
          }

          if (!a2) {
            goto LABEL_98;
          }
          uint64_t v80 = a2[51];
          uint64_t v71 = v80 >= v47;
          char v81 = v80 - v47;
          if (!v71)
          {
            unsigned int v82 = sub_100037DC8((uint64_t)a2);
            uint64_t v83 = v103;
            if (v82 != 13) {
              uint64_t v83 = (const char *)(a2[48] + 208LL);
            }
            sub_100013D94( "%s:%d: %s fs reserved space underflow: %lld (%lld)\n",  "spaceman_set_bits_in_bm",  5415,  v83,  a2[51],  v47);
            char v81 = 0LL;
          }

          a2[51] = v81;
        }

        else
        {
          uint64_t v12 = v115;
          if (!a2) {
            goto LABEL_98;
          }
        }

        unsigned int v84 = a2[47];
        char v85 = *(void *)(v84 + 88);
        *(void *)(v84 + 88) = v85 + v47;
        unint64_t v86 = *(void *)(v84 + 72);
        if (v85 + v47 <= v86)
        {
          char v89 = (void *)(v118 + 192);
          uint64_t v87 = *(void *)(v118 + 192);
          uint64_t v88 = a6;
        }

        else
        {
          uint64_t v71 = v86 >= v85;
          uint64_t v87 = v86 - v85;
          uint64_t v88 = a6;
          if (v87 == 0 || !v71) {
            goto LABEL_97;
          }
          char v89 = (void *)(v118 + 192);
          unsigned int v47 = *(void *)(v118 + 192);
        }

        uint64_t *v89 = v87 + v47;
LABEL_97:
        sub_10001AAF0((uint64_t)a2, v88);
LABEL_98:
        pthread_mutex_unlock(v121);
        unsigned int v74 = 0;
        unint64_t v96 = 0LL;
        char v73 = 1;
        int v11 = (uint64_t)a1;
        uint64_t v36 = v120;
        goto LABEL_99;
      }

      char v73 = 0;
      unint64_t v96 = 22LL;
      unsigned int v74 = 1;
      int v11 = (uint64_t)a1;
      uint64_t v12 = v115;
LABEL_99:
      sub_10003E644(v10, a6, 0LL);
      sub_10003E644(v133, a6, v116);
      sub_10003E644(v132, a6, v122);
      sub_100038824(v132);
      uint64_t v132 = 0LL;
      int v9 = v124 + v128;
      v130 += v124;
      a5 -= v124;
      uint64_t v32 = v126;
      v128 += v124;
      ++v36;
      char v90 = v126 + 32 * v36;
      char v91 = *(void *)(v90 + 64);
      char v39 = (void *)(v90 + 64);
      unint64_t v38 = v91;
      uint64_t v35 = a6;
      if (a7 == 1) {
        goto LABEL_34;
      }
    }

    sub_10003D514(v133, 2);
    sub_100038824(v133);
    __int16 v133 = 0LL;
    if (a5 < 1) {
      char v92 = 1;
    }
    else {
      char v92 = v74;
    }
    unsigned int v16 = v106;
    unsigned int v14 = v130;
    int v17 = (unsigned int *)v104;
    if ((v92 & 1) != 0)
    {
      timespec v95 = 0;
      goto LABEL_128;
    }
  }

  unint64_t v96 = v33;
  sub_100013D94( "%s:%d: %s failed to allocate block from internal pool: %d\n",  "spaceman_modify_bits",  5554,  (const char *)(*(void *)(v11 + 384) + 208LL),  v33);
  timespec v95 = 1;
  unsigned int v16 = v106;
LABEL_124:
  if (!v123) {
LABEL_127:
  }
    pthread_mutex_unlock(v16);
LABEL_128:
  if (v134 && (v109 & 1) != 0) {
    sub_10003D514(v134, 2);
  }
  timespec v97 = v95 ^ 1;
  if (!v133) {
    timespec v97 = 1;
  }
  if ((v97 & 1) == 0) {
    sub_10003D514(v133, 2);
  }
  if (v134) {
    sub_100038824(v134);
  }
  if (v133) {
    sub_100038824(v133);
  }
  if (v132) {
    sub_100038824(v132);
  }
  if (a7 == 1)
  {
    if ((_DWORD)v96)
    {
      if (a5)
      {
        unint64_t v98 = a3 + 8 * v108;
        uint64_t v99 = *(void *)(v98 + 976);
        if (v99) {
          *(void *)(v98 + 976) = v99 - a5;
        }
      }
    }
  }

  return v96;
}

    pthread_mutex_unlock((pthread_mutex_t *)(v21 + 576));
    pthread_mutex_unlock((pthread_mutex_t *)(v21 + 384));
    sub_100038824(v21);
  }

  return v8;
}

LABEL_35:
  if ((a2 & 1) != 0 || !sub_10003EDDC(a1))
  {
    sub_10003EE28(a1, 1);
  }

  else
  {
    if (*(void *)(v4 + 720))
    {
      uint64_t v18 = *(void *)(v4 + 728);
      uint64_t v20 = *(void *)(v18 + 72);
      uint64_t v19 = v18 + 72;
      *(void *)(a1 + 72) = v20;
      if (v20) {
        *(void *)(*(void *)v19 + 80LL) = a1 + 72;
      }
    }

    else
    {
      uint64_t v19 = v4 + 720;
      *(void *)(a1 + 72) = 0LL;
    }

    *(void *)uint64_t v19 = a1;
    *(void *)(a1 + 80) = v19;
    *(void *)(v4 + 728) = a1;
  }

uint64_t sub_10003CF10(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 176))) {
      panic("%s:%d: rdlock == 0 failed %d\n");
    }
  }

  else
  {
    if ((a2 & 2) == 0) {
      panic("invalid lock flags: 0x%x\n");
    }
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 176))) {
      panic("%s:%d: wrlock == 0 failed %d\n");
    }
  }

  return 0LL;
}

uint64_t sub_10003CF9C(void *a1, char a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)(*a1 + 392LL);
  if (a1[1]) {
    uint64_t v8 = a1[1];
  }
  else {
    uint64_t v8 = *(void *)(*a1 + 392LL);
  }
  uint64_t v9 = a1[2];
  if ((v9 & 0x8000000) == 0)
  {
    if (*(_BYTE *)(v7 + 627)) {
      return 30LL;
    }
    if (!sub_10004E670(*(void *)(*a1 + 392LL), a3)) {
      return 22LL;
    }
    uint64_t v9 = a1[2];
  }

  if ((v9 & 0x10000000000LL) != 0)
  {
    if (*(_WORD *)(v8 + 36) == 13) {
      uint64_t v19 = (const char *)(v8 + 3992);
    }
    else {
      uint64_t v19 = (const char *)(*(void *)(v8 + 384) + 208LL);
    }
    sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x can't modify object before read completes\n",  "obj_modify",  5459,  v19,  a1[14],  v9,  *((_DWORD *)a1 + 8),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 10));
    return 22LL;
  }

  uint64_t v11 = a1[8];
  if (v11 && v11 == a1[7])
  {
    size_t v12 = *((unsigned int *)a1 + 12);
    uint64_t v13 = sub_100013E20(v12, *(void *)(v6 + 920));
    sub_10003F14C((unint64_t *)(v6 + 944), v9, (uint64_t)v13, v12);
    sub_10003F14C((unint64_t *)(qword_100070558 + 136), v9, (uint64_t)v13, v12);
    if (!v13) {
      return 12LL;
    }
    unsigned int v14 = (unsigned int *)(a1 + 4);
    do
      unsigned int v15 = __ldaxr(v14);
    while (__stxr(v15 | 8, v14));
    if ((v15 & 8) != 0)
    {
      do
      {
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 328));
        pthread_mutex_unlock((pthread_mutex_t *)(v6 + 328));
        do
          unsigned int v16 = __ldaxr(v14);
        while (__stxr(v16 | 8, v14));
      }

      while ((v16 & 8) != 0);
    }

    int v17 = (const void *)a1[8];
    if (v17 && v17 == (const void *)a1[7])
    {
      memcpy(v13, v17, v12);
      a1[8] = v13;
      do
        unsigned int v20 = __ldxr(v14);
      while (__stlxr(v20 & 0xFFFFFFF7, v14));
    }

    else
    {
      do
        unsigned int v18 = __ldxr(v14);
      while (__stlxr(v18 & 0xFFFFFFF7, v14));
      sub_100036918(v13, v12, a1[2], v6);
    }
  }

  uint64_t v21 = a1[2];
  if ((v21 & 0x80000000) != 0) {
    return 0LL;
  }
  if ((v21 & 0xC0000000) == 0)
  {
    if ((v21 & 0xC00000000LL) != 0 || a1[15] == a3) {
      return 0LL;
    }
    pthread_mutex_lock((pthread_mutex_t *)v6);
    uint64_t v24 = a1[2];
    if ((v24 & 0xC00000000LL) == 0)
    {
      while (a1[15] != a3)
      {
        unsigned int v26 = *(_DWORD *)(*(void *)(v7 + 376) + 36LL);
        int v27 = *((_DWORD *)a1 + 12);
        int v43 = 0;
        if ((v24 & 0x100000000LL) == 0)
        {
          a1[2] = v24 | (unint64_t)&_mh_execute_header;
          unint64_t v31 = (v26 + v27 - 1) / v26;
          sub_100036F84(v6);
          uint64_t v10 = sub_10004CBEC(v8, 72, v31, a3, &v43);
          pthread_mutex_lock((pthread_mutex_t *)v6);
          uint64_t v32 = a1[2];
          a1[2] = v32 & 0xFFFFFFFCFFFFFFFFLL;
          if ((_DWORD)v10)
          {
            if (*(_WORD *)(v8 + 36) == 13) {
              unsigned int v33 = (const char *)(v8 + 3992);
            }
            else {
              unsigned int v33 = (const char *)(*(void *)(v8 + 384) + 208LL);
            }
            sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n",  "obj_modify",  5575,  v33,  a1[14],  v32 & 0xFFFFFFFCFFFFFFFFLL,  *((_DWORD *)a1 + 8),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 10),  v31,  v10);
          }

          else
          {
            uint64_t v34 = 0x800000000LL;
            if ((v43 & 0x10) == 0) {
              uint64_t v34 = 0x400000000LL;
            }
            a1[2] = v34 | v32 & 0xFFFFFFFCFFFFFFFFLL;
          }

          sub_100036F84(v6);
          if ((v32 & 0x200000000LL) != 0) {
            j__pthread_cond_broadcast((pthread_cond_t *)(v6 + 1296));
          }
          return v10;
        }

        a1[2] = v24 | 0x200000000LL;
        sub_100013AD4((pthread_cond_t *)(v6 + 1296), (pthread_mutex_t *)v6, 2LL, 0LL);
        uint64_t v24 = a1[2];
        if ((v24 & 0xC00000000LL) != 0) {
          goto LABEL_43;
        }
      }
    }

    goto LABEL_43;
  }

  if ((a2 & 2) == 0) {
    return 0LL;
  }
  uint64_t v22 = (unsigned int *)(a1 + 4);
  if ((a1[4] & 1) != 0) {
    return 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)v6);
  if ((*(_BYTE *)v22 & 1) != 0) {
    goto LABEL_43;
  }
  uint64_t v23 = a1[19];
  if (v23)
  {
LABEL_39:
    sub_10003E25C(a1, a3, v23);
LABEL_43:
    sub_100036F84(v6);
    return 0LL;
  }

  if (a1[15] == a3)
  {
    uint64_t v23 = a1[16];
    goto LABEL_39;
  }

  do
    unsigned int v29 = __ldxr(v22);
  while (__stxr(v29 | 1, v22));
  sub_100036F84(v6);
  if ((*((_BYTE *)a1 + 19) & 0x10) != 0)
  {
    unint64_t v42 = 0LL;
  }

  else
  {
    if (*((_WORD *)a1 + 18) == 11 || *((_WORD *)a1 + 20) == 11) {
      uint64_t v30 = 2LL;
    }
    else {
      uint64_t v30 = 1LL;
    }
    unint64_t v42 = v30;
  }

  uint64_t v35 = sub_100048020((void *)v8, 72, v28, a3, &v42, 0LL);
  if ((_DWORD)v35)
  {
    uint64_t v10 = v35;
    if (*(_WORD *)(v8 + 36) == 13) {
      uint64_t v36 = (const char *)(v8 + 3992);
    }
    else {
      uint64_t v36 = (const char *)(*(void *)(v8 + 384) + 208LL);
    }
    sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error allocating new location %d\n",  "obj_modify",  5632,  v36,  a1[14],  a1[2],  *((_DWORD *)a1 + 8),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 10),  v35);
    pthread_mutex_lock((pthread_mutex_t *)v6);
    do
      unsigned int v41 = __ldxr(v22);
    while (__stxr(v41 & 0xFFFFFFFE, v22));
    sub_100036F84(v6);
  }

  else
  {
    if (a1[1]) {
      sub_10001AAE8();
    }
    pthread_mutex_lock((pthread_mutex_t *)v6);
    unint64_t v37 = a1[16];
    do
      unsigned int v38 = __ldxr(v22);
    while (__stxr(v38 & 0xFFFFFFFE, v22));
    sub_10003E25C(a1, a3, v42);
    sub_100036F84(v6);
    uint64_t v39 = sub_10004BD08((const char *)v8, 0LL, v37, v28, a3);
    uint64_t v10 = v39;
    if ((_DWORD)v39)
    {
      if (*(_WORD *)(v8 + 36) == 13) {
        unint64_t v40 = (const char *)(v8 + 3992);
      }
      else {
        unint64_t v40 = (const char *)(*(void *)(v8 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old space @ 0x%llx: %d\n",  "obj_modify",  5654,  v40,  a1[14],  a1[2],  *((_DWORD *)a1 + 8),  *((_DWORD *)a1 + 9),  *((_DWORD *)a1 + 10),  v37,  v39);
    }
  }

  return v10;
}

uint64_t sub_10003D514(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 176))) {
      goto LABEL_7;
    }
  }

  else
  {
    if ((a2 & 2) == 0) {
      panic("invalid unlock flags: 0x%x\n");
    }
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 176))) {
LABEL_7:
    }
      panic("%s:%d: unlock == 0 failed %d\n");
  }

  return 0LL;
}

uint64_t sub_10003D594( pthread_mutex_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unint64_t a7, uint64_t a8, uint64_t *a9)
{
  unint64_t v51 = a7;
  uint64_t v52 = a5;
  uint64_t v49 = 0LL;
  if (!a4) {
    return 22LL;
  }
  if (*(_DWORD *)(a4 + 12) < 0x178u) {
    return 22LL;
  }
  unsigned int v10 = *(_DWORD *)(a4 + 8);
  if (!v10) {
    return 22LL;
  }
  unsigned int v12 = *(_DWORD *)(*(void *)(*(void *)a1[6].__opaque + 376LL) + 36LL);
  if (v10 % v12) {
    return 22LL;
  }
  LODWORD(v16) = a6;
  __int16 v19 = a2;
  uint64_t v50 = 0xAAAAAAAAAAAAAAAALL;
  int v20 = a2 | (*(unsigned __int16 *)(a4 + 2) << 16);
  pthread_mutex_lock(a1);
  int v47 = v20;
  uint64_t v21 = sub_10003A4E8((uint64_t)a1, *(_DWORD *)(a4 + 12), *(_DWORD *)a4, *(_DWORD *)(a4 + 8), v20, 0LL, &v50);
  if ((_DWORD)v21)
  {
    uint64_t v13 = v21;
    goto LABEL_56;
  }

  unint64_t v22 = (v10 + v12 - 1) / v12;
  uint64_t v23 = v50;
  *(_DWORD *)(v50 + 36) = *(_DWORD *)a4 | v47 & 0xFFFF0000;
  *(_DWORD *)(v23 + 40) = *(_DWORD *)(a4 + 4);
  *(void *)(v23 + 112) = a3;
  *(void *)(v23 + 120) = a8;
  *(void *)(v23 + 16) |= v47 & 0xA000FC00 | ((unint64_t)(v19 & 0x200) << 34) | 0x2000000002LL;
  *(void *)(v23 + 128) = a5;
  uint64_t v24 = (unint64_t *)(v23 + 24);
  do
    unint64_t v25 = __ldxr(v24);
  while (__stxr(v25 + 1, v24));
  if ((~(_DWORD)v25 & 0xFFFFFFLL) == 0) {
    panic("Reference count overflowed for object %p!\n", (const void *)v23);
  }
  sub_100036F84((uint64_t)a1);
  if (v22 <= a7)
  {
    unint64_t v36 = sub_10003C6B0(v23, 0LL, 0, 0LL);
    goto LABEL_30;
  }

  uint64_t v26 = *(void *)(v23 + 56);
  int v27 = v22;
  do
  {
    if (v51 >= v27) {
      unint64_t v28 = v27;
    }
    else {
      unint64_t v28 = v51;
    }
    uint64_t v29 = sub_100051DF4(*(void *)(*(void *)(*(void *)v23 + 392LL) + 384LL), v52);
    if ((_DWORD)v29)
    {
      uint64_t v13 = v29;
      goto LABEL_40;
    }

    v27 -= v28;
    if (!v27) {
      goto LABEL_27;
    }
    uint64_t v32 = *(void *)a1[6].__opaque;
    uint64_t v33 = *(void *)(v32 + 376);
    else {
      unint64_t v16 = (v16 + v28);
    }
    v26 += v28 * *(unsigned int *)(v33 + 36);
    uint64_t v34 = sub_100013338(v32, v16, &v52, &v51);
  }

  while (v27 >= 1 && (_DWORD)v34 == 0);
  uint64_t v13 = v34;
  if ((_DWORD)v34)
  {
LABEL_40:
    pthread_mutex_lock(a1);
    goto LABEL_53;
  }

unint64_t sub_10003D9B0(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 392LL);
  uint64_t v5 = *(void **)(a1 + 56);
  int v6 = *(_DWORD *)(a1 + 48);
  unint64_t result = sub_10001D980(v5, (uint32x4_t *)(v5 + 1), (v6 - 8), 0LL, a2, a3);
  if (result)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    if (v8) {
      uint64_t v9 = (const char *)(v8 + 3992);
    }
    else {
      uint64_t v9 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
    }
    sub_100013D94( "%s:%d: %s failed: cksum 0x%016llx, oid 0x%llx, o_xid 0x%llx, o_type 0x%x, o_subtype 0x%x, size %d\n",  "obj_checksum_verify",  6786,  v9,  *v5,  v5[1],  v5[2],  *((_DWORD *)v5 + 6),  *((_DWORD *)v5 + 7),  v6);
    unsigned int v10 = (unint64_t *)(*(void *)(v4 + 376) + 992LL);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    if (*(_BYTE *)(v4 + 625))
    {
      unsigned int v12 = *(void (**)(uint64_t))(v4 + 616);
      if (v12) {
        v12(a1);
      }
    }

    return sub_100005194(v4);
  }

  return result;
}

uint64_t sub_10003DAB0(uint64_t result, _BYTE *a2)
{
  uint64_t v2 = *(pthread_mutex_t ***)(result + 136);
  uint64_t v3 = v2[2];
  if (((unint64_t)v3 & 0x10000000000LL) != 0)
  {
    uint64_t v5 = *v2;
    int v6 = (pthread_cond_t *)&(*v2)[20].__opaque[8];
    while (((unint64_t)v3 & 0x8000000000LL) != 0)
    {
      v2[2] = (pthread_mutex_t *)((unint64_t)v3 | 4);
      *a2 = 1;
      unint64_t result = sub_100013AD4(v6, v5, 2LL, 0LL);
      uint64_t v3 = v2[2];
    }

    v2[2] = (pthread_mutex_t *)((unint64_t)v3 | 0x8000000000LL);
    sub_100036F84((uint64_t)v5);
    *a2 = 0;
    return sub_100051F50(*(void *)(*(void *)(*v2)[6].__opaque + 384LL));
  }

  return result;
}

uint64_t sub_10003DB5C(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  char v7 = 0;
  pthread_mutex_lock((pthread_mutex_t *)v2);
  uint64_t v3 = *(void *)(v2 + 1344);
  if (v3)
  {
    while (1)
    {
      while (*(void *)(v3 + 136) != a1)
      {
        uint64_t v3 = *(void *)(v3 + 104);
        if (!v3) {
          goto LABEL_7;
        }
      }

      uint64_t v4 = *(void *)(a1 + 16);
      if ((v4 & 0x8000000000LL) == 0) {
        break;
      }
      *(void *)(a1 + 16) = v4 | 4;
      sub_100013AD4((pthread_cond_t *)(v2 + 1296), (pthread_mutex_t *)v2, 2LL, 0LL);
      uint64_t v3 = *(void *)(v2 + 1344);
      if (!v3) {
        goto LABEL_7;
      }
    }

    sub_10003DAB0(v3, &v7);
    if (v7) {
      sub_100036F84(v2);
    }
    return *(unsigned int *)(a1 + 52);
  }

  else
  {
LABEL_7:
    if ((*(_BYTE *)(a1 + 21) & 1) != 0) {
      uint64_t v5 = 2LL;
    }
    else {
      uint64_t v5 = *(unsigned int *)(a1 + 52);
    }
    sub_100036F84(v2);
  }

  return v5;
}

char *sub_10003DC28(char *result)
{
  uint64_t v1 = (unint64_t *)(result + 24);
  do
    unint64_t v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  if ((~(_DWORD)v2 & 0xFFFFFFLL) == 0) {
    panic("Reference count overflowed for object %p!\n", result);
  }
  return result;
}

uint64_t sub_10003DC74(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if ((v1 & 0x80000000) == 0) {
    panic( "obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx is not ephemeral\n",  (const void *)result,  *(void *)(result + 112),  v1,  *(_DWORD *)(result + 32),  *(_DWORD *)(result + 36),  *(_DWORD *)(result + 40),  *(void *)(result + 24));
  }
  unint64_t v2 = (unint64_t *)(result + 24);
  do
    unint64_t v3 = __ldxr(v2);
  while (__stxr(v3 + 1, v2));
  if ((~(_DWORD)v3 & 0xFFFFFFLL) == 0) {
    panic("Reference count overflowed for object %p!\n", (const void *)result);
  }
  return result;
}

uint64_t sub_10003DD00(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  unint64_t v3 = (unsigned int *)(a2 + 32);
  do
    unsigned int v4 = __ldxr(v3);
  while (__stxr(v4 | 0x10, v3));
  if ((v4 & 0x10) == 0)
  {
    uint64_t v5 = (unsigned int *)(result + 880);
    do
      unsigned int v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
    unsigned int v7 = v6;
    if (v6 >= 0x100)
    {
      do
      {
        do
          unsigned int v8 = __ldxr(v5);
        while (__stxr(v8 - 1, v5));
        int v9 = pthread_rwlock_unlock((pthread_rwlock_t *)(v2 + 128));
        if (v9) {
          panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  483,  v9);
        }
        int v10 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v2 + 128));
        if (v10) {
          panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  484,  v10);
        }
        sub_10003EB94(v2);
        int v11 = pthread_rwlock_unlock((pthread_rwlock_t *)(v2 + 128));
        if (v11) {
          panic( "%s:%d: unlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  490,  v11);
        }
        unint64_t result = pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 128));
        if ((_DWORD)result) {
          panic( "%s:%d: rdlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  493,  result);
        }
        do
          unsigned int v7 = __ldxr(v5);
        while (__stxr(v7 + 1, v5));
      }

      while (v7 > 0xFF);
    }

    *(void *)(*(void *)(v2 + 872) + 8LL * v7) = a2;
    unsigned int v12 = v7 << 24;
    do
      unsigned int v13 = __ldxr(v3);
    while (__stxr(v13 | v12, v3));
  }

  return result;
}

uint64_t sub_10003DE74(uint64_t a1, int a2)
{
  if ((*(_BYTE *)(a1 + 19) & 0x80) == 0) {
    return 22LL;
  }
  uint64_t v5 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v6 = *(void *)(a1 + 16);
  if ((a2 != 0) != ((v6 & 0x8000000) == 0))
  {
    sub_100036F1C((uint64_t)v5, v6, *(_DWORD *)(a1 + 48), -1);
    uint64_t v8 = *(void *)(a1 + 88);
    int v9 = *(void **)(a1 + 96);
    uint64_t v7 = a1 + 88;
    if (a2)
    {
      if (v8)
      {
        *(void *)(v8 + 96) = v9;
        int v9 = *(void **)(a1 + 96);
      }

      else
      {
        *(void *)&v5[11].__opaque[48] = v9;
      }

      *int v9 = v8;
      uint64_t v10 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v10 & 0xFFFFFFFFF7FFFFFFLL;
      *(_DWORD *)(a1 + 36) &= ~0x8000000u;
      if ((v10 & 0x80020000000LL) == 0) {
        *(_DWORD *)(*(void *)(a1 + 56) + 24LL) &= ~0x8000000u;
      }
      int v11 = *(void **)&v5[11].__opaque[32];
      *(void *)(a1 + 88) = 0LL;
      *(void *)(a1 + 96) = v11;
      *int v11 = a1;
      *(void *)&v5[11].__opaque[32] = v7;
      opaque = (unint64_t *)v5[19].__opaque;
      uint64_t v13 = *(unsigned int *)(a1 + 48);
      do
        unint64_t v14 = __ldxr(opaque);
      while (__stxr(v14 - v13, opaque));
      unsigned int v15 = (unint64_t *)&v5[19].__opaque[16];
      do
        unint64_t v16 = __ldxr(v15);
      while (__stxr(v16 + v13, v15));
      int v17 = (unint64_t *)&v5[19].__opaque[32];
      do
        unint64_t v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      uint64_t v19 = qword_100070558;
      int v20 = (unint64_t *)(qword_100070558 + 416);
      uint64_t v21 = *(unsigned int *)(a1 + 48);
      do
        unint64_t v22 = __ldxr(v20);
      while (__stxr(v22 - v21, v20));
      uint64_t v23 = (unint64_t *)(v19 + 432);
      do
        unint64_t v24 = __ldxr(v23);
      while (__stxr(v24 + v21, v23));
      unint64_t v25 = (unint64_t *)(v19 + 448);
      do
        unint64_t v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      if (*(void *)(a1 + 56))
      {
        int v27 = (unint64_t *)&v5[18].__opaque[16];
        uint64_t v28 = *(unsigned int *)(a1 + 48);
        do
          unint64_t v29 = __ldxr(v27);
        while (__stxr(v29 + v28, v27));
        int8x16_t v30 = (unint64_t *)&v5[18].__opaque[24];
        do
          unint64_t v31 = __ldxr(v30);
        while (__stxr(v31 + v28, v30));
        uint64_t v32 = (unint64_t *)&v5[18].__opaque[40];
      }

      else
      {
        uint64_t v32 = (unint64_t *)&v5[19];
      }

      do
        unint64_t v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
      if (*(void *)(a1 + 56))
      {
        uint64_t v34 = (unint64_t *)(v19 + 368);
        uint64_t v35 = *(unsigned int *)(a1 + 48);
        do
          unint64_t v36 = __ldxr(v34);
        while (__stxr(v36 + v35, v34));
        unint64_t v37 = (unint64_t *)(v19 + 376);
        do
          unint64_t v38 = __ldxr(v37);
        while (__stxr(v38 + v35, v37));
        uint64_t v39 = (unint64_t *)(v19 + 392);
      }

      else
      {
        uint64_t v39 = (unint64_t *)(v19 + 408);
      }
    }

    else
    {
      if (v8)
      {
        *(void *)(v8 + 96) = v9;
        int v9 = *(void **)(a1 + 96);
      }

      else
      {
        *(void *)&v5[11].__opaque[32] = v9;
      }

      *int v9 = v8;
      uint64_t v40 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v40 | 0x8000000;
      *(_DWORD *)(a1 + 36) |= 0x8000000u;
      if ((v40 & 0x80020000000LL) == 0) {
        *(_DWORD *)(*(void *)(a1 + 56) + 24LL) |= 0x8000000u;
      }
      uint64_t v41 = *(void **)&v5[11].__opaque[48];
      *(void *)(a1 + 88) = 0LL;
      *(void *)(a1 + 96) = v41;
      *uint64_t v41 = a1;
      *(void *)&v5[11].__opaque[48] = v7;
      unint64_t v42 = (unint64_t *)&v5[18].__opaque[16];
      uint64_t v43 = *(unsigned int *)(a1 + 48);
      do
        unint64_t v44 = __ldxr(v42);
      while (__stxr(v44 - v43, v42));
      uint64_t v45 = (unint64_t *)&v5[18].__opaque[32];
      do
        unint64_t v46 = __ldxr(v45);
      while (__stxr(v46 + v43, v45));
      int v47 = (unint64_t *)&v5[18].__opaque[48];
      do
        unint64_t v48 = __ldxr(v47);
      while (__stxr(v48 + 1, v47));
      uint64_t v49 = qword_100070558;
      uint64_t v50 = (unint64_t *)(qword_100070558 + 368);
      uint64_t v51 = *(unsigned int *)(a1 + 48);
      do
        unint64_t v52 = __ldxr(v50);
      while (__stxr(v52 - v51, v50));
      timespec v53 = (unint64_t *)(v49 + 384);
      do
        unint64_t v54 = __ldxr(v53);
      while (__stxr(v54 + v51, v53));
      unint64_t v55 = (unint64_t *)(v49 + 400);
      do
        unint64_t v56 = __ldxr(v55);
      while (__stxr(v56 + 1, v55));
      if (*(void *)(a1 + 56))
      {
        uint64_t v57 = (unint64_t *)v5[19].__opaque;
        uint64_t v58 = *(unsigned int *)(a1 + 48);
        do
          unint64_t v59 = __ldxr(v57);
        while (__stxr(v59 + v58, v57));
        uint64_t v60 = (unint64_t *)&v5[19].__opaque[8];
        do
          unint64_t v61 = __ldxr(v60);
        while (__stxr(v61 + v58, v60));
        uint64_t v62 = (unint64_t *)&v5[19].__opaque[24];
      }

      else
      {
        uint64_t v62 = (unint64_t *)&v5[19].__opaque[40];
      }

      do
        unint64_t v63 = __ldxr(v62);
      while (__stxr(v63 + 1, v62));
      if (*(void *)(a1 + 56))
      {
        int v64 = (unint64_t *)(v49 + 416);
        uint64_t v65 = *(unsigned int *)(a1 + 48);
        do
          unint64_t v66 = __ldxr(v64);
        while (__stxr(v66 + v65, v64));
        char v67 = (unint64_t *)(v49 + 424);
        do
          unint64_t v68 = __ldxr(v67);
        while (__stxr(v68 + v65, v67));
        uint64_t v39 = (unint64_t *)(v49 + 440);
      }

      else
      {
        uint64_t v39 = (unint64_t *)(v49 + 456);
      }
    }

    do
      unint64_t v69 = __ldxr(v39);
    while (__stxr(v69 + 1, v39));
    sub_100036F1C((uint64_t)v5, *(void *)(a1 + 16), *(_DWORD *)(a1 + 48), 1);
  }

  sub_100036F84((uint64_t)v5);
  return 0LL;
}

uint64_t sub_10003E20C(uint64_t a1, int a2)
{
  BOOL v3 = a2 != 0;
  unsigned int v4 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFBFFFFFFFFFLL | ((unint64_t)v3 << 38);
  sub_100036F84((uint64_t)v4);
  return 0LL;
}

void *sub_10003E25C(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *result;
  uint64_t v7 = result[2];
  if ((v7 & 0x10) != 0) {
    panic("deleted object @ %p can not be dirtied!! (flags: 0x%llx)\n", result, v7);
  }
  if ((v7 & 0x80000000000LL) != 0) {
    panic("ciphertext object @ %p can not be dirtied!! (flags: 0x%llx)\n", result, v7);
  }
  if ((v7 & 0x8000000) == 0)
  {
    unint64_t result = (void *)sub_10004E670(*(void *)(v6 + 392), a2);
    if (!(_DWORD)result) {
      panic( "oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x bad dirty xid: 0x%llx\n",  v5[14],  v5[2],  *((_DWORD *)v5 + 8),  *((_DWORD *)v5 + 9),  *((_DWORD *)v5 + 10),  a2);
    }
  }

  uint64_t v8 = v5[8];
  if (v8 && v8 == v5[7]) {
    panic( "oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object not prepared before dirtying\n",  v5[14],  v5[2],  *((_DWORD *)v5 + 8),  *((_DWORD *)v5 + 9),  *((_DWORD *)v5 + 10));
  }
  uint64_t v9 = v5[2];
  if ((v9 & 0x80000000) != 0)
  {
    v5[18] = a2;
  }

  else
  {
    uint64_t v10 = (unsigned int *)(v5 + 4);
    do
      unsigned int v11 = __ldxr(v10);
    while (__stxr(v11 | 1, v10));
    if ((v11 & 1) != 0)
    {
      if (a3 && v5[19] != a3) {
        panic("new address mismatch on redirty 0x%llx 0x%llx\n");
      }
    }

    else
    {
      unsigned int v12 = *((_DWORD *)v5 + 9);
      if ((v9 & 0xC00000000LL) == 0 && !(v12 >> 30))
      {
        uint64_t v13 = v5[15];
        if (v13 != a2 && v5[18] != a2) {
          panic( "virtual object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx\n",  v5[14],  v9,  *((_DWORD *)v5 + 8),  v12,  *((_DWORD *)v5 + 10),  v13,  v5[18],  a2);
        }
      }

      v5[21] = 0LL;
      if (v12 >> 30 == 1)
      {
        uint64_t v14 = v5[2];
        if ((v14 & 0x40) == 0)
        {
          uint64_t v15 = v5[15];
          if (v15 != a2)
          {
            uint64_t v16 = v5[18];
            if (v15 != v16 && !(v5[19] | a3)) {
              panic( "physical object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x% llx 0x%llx naddr 0x%llx 0x%llx\n",  v5[14],  v14,  *((_DWORD *)v5 + 8),  v12,  *((_DWORD *)v5 + 10),  v15,  v16,  a2,  0LL,  0LL);
            }
          }
        }
      }

      uint64_t v17 = v5[19];
      if (v17)
      {
        if (v17 != a3)
        {
          if (a3)
          {
            int v18 = *((_DWORD *)v5 + 9);
            if ((v18 & 0xC0000000) == 0x40000000) {
              panic( "physical object new address mismatch: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%l lx naddr 0x%llx 0x%llx\n",  v5[14],  v5[2],  *((_DWORD *)v5 + 8),  v18,  *((_DWORD *)v5 + 10),  v5[15],  v5[18],  a2,  v5[19],  a3);
            }
          }
        }
      }

      else
      {
        v5[19] = a3;
        if (a3 && (v5[2] & 0x40000000) != 0 && v5[14] != a3)
        {
          uint64_t v19 = v5[9];
          if (v19) {
            *(void *)(v19 + 80) = v5[10];
          }
          *(void *)v5[10] = v19;
          v5[14] = a3;
          int v20 = (uint64_t *)(*(void *)(v6 + 704) + 8LL * (*(_DWORD *)(v6 + 700) & a3));
          uint64_t v21 = *v20;
          v5[9] = *v20;
          if (v21) {
            *(void *)(v21 + 80) = v5 + 9;
          }
          *int v20 = (uint64_t)v5;
          v5[10] = v20;
        }
      }

      v5[18] = a2;
      int v22 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 128));
      if (v22) {
        panic( "%s:%d: wrlock == 0 failed %d\n",  "/Library/Caches/com.apple.xbs/Sources/apfs_executables/nx/obj.c",  5760,  v22);
      }
      uint64_t v23 = v5 + 11;
      if (v5[11] != 3735928559LL) {
        sub_10003ECE4(v5);
      }
      do
        unsigned int v24 = __ldxr(v10);
      while (__stxr(v24 & 0xFFFFEF, v10));
      if ((v24 & 0x10) != 0) {
        *(void *)(*(void *)(v6 + 872) + 8LL * HIBYTE(v24)) = 0LL;
      }
      if (*v23 != 3735928559LL) {
        panic( "obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x dirty object on the free list?!\n",  v5,  v5[14],  v5[2],  *((_DWORD *)v5 + 8),  *((_DWORD *)v5 + 9),  *((_DWORD *)v5 + 10));
      }
      uint64_t v25 = v5[2];
      v5[11] = 0LL;
      if ((v25 & 0x40000000) != 0)
      {
        int v27 = *(void **)(v6 + 824);
        v5[12] = v27;
        *int v27 = v5;
        *(void *)(v6 + 824) = v23;
        ++*(_DWORD *)(v6 + 888);
      }

      else
      {
        unint64_t v26 = *(void **)(v6 + 808);
        v5[12] = v26;
        *unint64_t v26 = v5;
        *(void *)(v6 + 808) = v23;
        ++*(_DWORD *)(v6 + 884);
      }

      unint64_t result = (void *)pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 128));
      if ((_DWORD)result) {
        panic("%s:%d: unlock == 0 failed %d\n");
      }
    }
  }

  return result;
}

void sub_10003E644(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_BYTE *)(a1 + 19) & 0x80) != 0)
  {
    *(void *)(a1 + 144) = a2;
  }

  else
  {
    uint64_t v6 = *(pthread_mutex_t **)a1;
    uint64_t v7 = (unsigned int *)(a1 + 32);
    do
      unsigned int v8 = __ldxr(v7);
    while (__stxr(v8, v7));
    if ((v8 & 1) == 0)
    {
      pthread_mutex_lock(v6);
      sub_10003E25C((void *)a1, a2, a3);
      sub_100036F84((uint64_t)v6);
    }
  }

uint64_t sub_10003E6C0(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v5 = *(void *)(a1 + 16);
  if ((v5 & 0x20000000000LL) != 0)
  {
    do
    {
      *(void *)(a1 + 16) = v5 | 0x80;
      uint64_t v7 = sub_100013AD4((pthread_cond_t *)&v4[20].__opaque[8], v4, 2LL, 0LL);
      uint64_t v5 = *(void *)(a1 + 16);
    }

    while ((v5 & 0x20000000000LL) != 0);
    uint64_t v6 = v7;
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v8;
  sub_100036F84((uint64_t)v4);
  return v6;
}

uint64_t sub_10003E754(unsigned int *a1)
{
  if ((*((_BYTE *)a1 + 19) & 0x80) == 0) {
    return sub_100005194(*(void *)(*(void *)a1 + 392LL));
  }
  uint64_t v2 = a1 + 8;
  do
    unsigned int v3 = __ldxr(v2);
  while (__stxr(v3 | 4, v2));
  return (4 * v3) & 0x10;
}

uint64_t sub_10003E794(unsigned int *a1)
{
  if ((*((_BYTE *)a1 + 19) & 0x80) == 0) {
    return sub_100005194(*(void *)(*(void *)a1 + 392LL));
  }
  uint64_t v2 = a1 + 8;
  do
    unsigned int v3 = __ldxr(v2);
  while (__stxr(v3 & 0xFFFFFFFB, v2));
  if ((v3 & 4) != 0) {
    return 0LL;
  }
  else {
    return 22LL;
  }
}

uint64_t sub_10003E7D8(uint64_t a1)
{
  uint64_t v1 = *(pthread_mutex_t **)a1;
  if ((*(_BYTE *)(a1 + 19) & 0x80) == 0) {
    return sub_100005194(*(void *)v1[6].__opaque);
  }
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v4 = *(void *)(a1 + 16);
  if ((v4 & 0x2000000000LL) != 0)
  {
    *(void *)(a1 + 16) = v4 & 0xFFFFFFDFFFFFFFFFLL;
    sub_100036F84((uint64_t)v1);
    return 0LL;
  }

  else
  {
    sub_100036F84((uint64_t)v1);
    return 22LL;
  }

uint64_t sub_10003E850(uint64_t a1, size_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a3 + 36);
  if (v4 > 0xA)
  {
    if (v4 != 11)
    {
      if (v4 == 13) {
        return sub_10002F178(a1, a2, a3, a4);
      }
      return 22LL;
    }

    return sub_100040FB0(a1, a2, a3, a4);
  }

  else
  {
    if (v4 != 2)
    {
      if (v4 == 3) {
        return sub_100028B2C(a1, a2, 0LL, a3, a4);
      }
      return 22LL;
    }

    return sub_100028D34(a1, a2, (void *)a3, a4);
  }

void sub_10003E8B8(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 736); i; uint64_t i = *(void *)(i + 88))
  {
    if ((*(_BYTE *)(i + 20) & 0x20) != 0) {
      sub_100013D4C( "%s:%d: %s Unknown object loaded from checkpoint: oid 0x%llx type 0x%x/0x%x\n",  "obj_checkpoint_check_for_unknown",  5950,  (const char *)(*(void *)(*(void *)(a1 + 392) + 384LL) + 208LL),  *(void *)(i + 112),  *(_DWORD *)(i + 36),  *(_DWORD *)(i + 40));
    }
  }

  sub_100036F84(a1);
}

unint64_t sub_10003E948(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 392LL);
  uint64_t v5 = *(void *)(a1 + 56);
  int v6 = *(_DWORD *)(a1 + 48);
  uint64_t v7 = (unint64_t *)(*(void *)(v4 + 376) + 984LL);
  do
    unint64_t v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  return sub_10001D914((unint64_t *)v5, (uint32x4_t *)(v5 + 8), (v6 - 8), 0LL, a2, a3);
}

unint64_t sub_10003E984(uint64_t a1, uint64_t a2, int a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v5 = (unint64_t *)(*(void *)(a1 + 376) + 984LL);
  do
    unint64_t v6 = __ldxr(v5);
  while (__stxr(v6 + 1, v5));
  return sub_10001D914((unint64_t *)a2, (uint32x4_t *)(a2 + 8), (a3 - 8), 0LL, a4, a5);
}

uint64_t sub_10003E9B4(int64x2_t *a1, int a2)
{
  uint64_t v4 = a1[80].i64[1];
  a1[80].i64[1] = v4 | 1;
  if (a2)
  {
    a1[80].i64[1] = v4 | 3;
    uint64_t v5 = qword_100070558;
    unint64_t v6 = (int64x2_t **)(qword_100070558 + 80);
    uint64_t v7 = *(void *)(qword_100070558 + 80);
    a1[58].i64[0] = v7;
    if (v7) {
      *(void *)(v7 + 936) = a1 + 58;
    }
    *unint64_t v6 = a1;
    a1[58].i64[1] = (uint64_t)v6;
  }

  else
  {
    uint64_t v5 = qword_100070558;
    uint64_t v8 = qword_100070558 + 72;
    uint64_t v9 = *(void *)(qword_100070558 + 72);
    a1[58].i64[0] = v9;
    if (v9) {
      *(void *)(v9 + 936) = a1 + 58;
    }
    *(void *)(v5 + 72) = a1;
    a1[58].i64[1] = v8;
    ++*(void *)(v5 + 104);
    *(int64x2_t *)(v5 + 136) = vaddq_s64(*(int64x2_t *)(v5 + 136), a1[59]);
    *(void *)(v5 + 152) += a1[60].i64[0];
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
}

void sub_10003EA80(uint64_t a1, const char *a2)
{
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v19 = v4;
  __int128 v20 = v4;
  __int128 v17 = v4;
  __int128 v18 = v4;
  __int128 v15 = v4;
  __int128 v16 = v4;
  *(_OWORD *)uint64_t v13 = v4;
  __int128 v14 = v4;
  int v5 = backtrace(v13, 16);
  unint64_t v6 = backtrace_symbols(v13, v5);
  fprintf( __stderrp,  "Allocated %s object with OID %lld flags %llx type %x %d from\n",  a2,  *(void *)(a1 + 112),  *(void *)(a1 + 16),  *(_DWORD *)(a1 + 36),  *(_DWORD *)(a1 + 40));
  if (v5 >= 1)
  {
    uint64_t v7 = v5;
    uint64_t v8 = v13;
    uint64_t v9 = (const char **)v6;
    do
    {
      unsigned int v11 = *v8++;
      uint64_t v10 = v11;
      unsigned int v12 = *v9++;
      fprintf(__stderrp, "\t%16p %s\n", v10, v12);
      --v7;
    }

    while (v7);
  }

  free(v6);
}

uint64_t *sub_10003EB94(uint64_t a1)
{
  v20.int tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v20.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  unint64_t result = (uint64_t *)clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v20);
  unint64_t v3 = *(unsigned int *)(a1 + 880);
  if ((_DWORD)v3)
  {
    unint64_t v4 = 0LL;
    int tv_sec = v20.tv_sec;
    do
    {
      unint64_t result = *(uint64_t **)(*(void *)(a1 + 872) + 8 * v4);
      if (result)
      {
        unint64_t v6 = (unsigned int *)(result + 4);
        do
          unsigned int v7 = __ldxr(v6);
        while (__stxr(v7, v6));
        uint64_t v8 = (unint64_t *)(result + 3);
        do
          unint64_t v9 = __ldxr(v8);
        while (__stxr(v9, v8));
        unint64_t v10 = v9 & 0xFFFFFF;
        unint64_t v11 = (v9 >> 24) & 0xFFFFF;
        unint64_t v12 = -(v9 >> 44) & 0xFFFFF;
        uint64_t v13 = result + 11;
        uint64_t v14 = result[11];
        if (v10 <= v11 && v12 == 0)
        {
          if (v14 == 3735928559LL && *((_WORD *)result + 18) != 13)
          {
            *((_DWORD *)result + 40) = tv_sec;
            uint64_t v16 = result[2];
            result[11] = 0LL;
            if ((v16 & 0x40000000) != 0)
            {
              __int128 v18 = *(void **)(a1 + 792);
              result[12] = (uint64_t)v18;
              *__int128 v18 = result;
              *(void *)(a1 + 792) = v13;
              ++*(_DWORD *)(a1 + 896);
            }

            else
            {
              __int128 v17 = *(void **)(a1 + 776);
              result[12] = (uint64_t)v17;
              *__int128 v17 = result;
              *(void *)(a1 + 776) = v13;
              ++*(_DWORD *)(a1 + 892);
            }
          }
        }

        else if (v14 != 3735928559LL)
        {
          unint64_t result = sub_10003ECE4(result);
        }

        do
          unsigned int v19 = __ldxr(v6);
        while (__stlxr(v19 & 0xFFFFEF, v6));
        unint64_t v3 = *(unsigned int *)(a1 + 880);
      }

      ++v4;
    }

    while (v4 < v3);
  }

  *(_DWORD *)(a1 + 880) = 0;
  return result;
}

uint64_t *sub_10003ECE4(uint64_t *result)
{
  uint64_t v1 = result[11];
  if (v1 != 3735928559LL)
  {
    uint64_t v2 = *result;
    unint64_t v3 = (void *)result[12];
    if ((*((_BYTE *)result + 19) & 0x40) != 0)
    {
      if (v1)
      {
        *(void *)(v1 + 96) = v3;
        unint64_t v3 = (void *)result[12];
      }

      else
      {
        *(void *)(v2 + 792) = v3;
      }

      *unint64_t v3 = v1;
      --*(_DWORD *)(v2 + 896);
    }

    else
    {
      if (v1)
      {
        *(void *)(v1 + 96) = v3;
        unint64_t v3 = (void *)result[12];
      }

      else
      {
        *(void *)(v2 + 776) = v3;
      }

      *unint64_t v3 = v1;
      --*(_DWORD *)(v2 + 892);
    }

    result[11] = 3735928559LL;
  }

  return result;
}

void sub_10003ED5C(void *a1, __int16 a2, int a3)
{
  if (a3 == 376)
  {
LABEL_2:
    uint64_t v3 = 376LL;
LABEL_3:
    sub_100014004(a1, v3);
  }

  else
  {
    switch(a2)
    {
      case 1:
        uint64_t v3 = 1928LL;
        goto LABEL_3;
      case 2:
      case 3:
      case 6:
      case 7:
      case 8:
        sub_100013FB4(a1, 4u);
        break;
      case 5:
        uint64_t v3 = 1608LL;
        goto LABEL_3;
      case 11:
        uint64_t v3 = 496LL;
        goto LABEL_3;
      case 13:
        uint64_t v3 = 4024LL;
        goto LABEL_3;
      case 17:
      case 30:
        uint64_t v3 = 400LL;
        goto LABEL_3;
      case 18:
        uint64_t v3 = 384LL;
        goto LABEL_3;
      case 25:
        uint64_t v3 = 416LL;
        goto LABEL_3;
      case 27:
      case 29:
        uint64_t v3 = 392LL;
        goto LABEL_3;
      default:
        goto LABEL_2;
    }
  }

uint64_t sub_10003EDDC(uint64_t a1)
{
  uint64_t result = 0LL;
  uint64_t v3 = 0LL;
  if ((*(_BYTE *)(a1 + 16) & 2) == 0)
  {
    else {
      return *(void *)(v3 + 16);
    }
  }

  return result;
}

void sub_10003EE28(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = (uint64_t (*)(uint64_t))sub_10003EDDC(a1);
    if (v3)
    {
      int v4 = v3(a1);
      if (v4)
      {
        uint64_t v5 = *(void *)(a1 + 8);
        if (v5) {
          unint64_t v6 = (const char *)(v5 + 3992);
        }
        else {
          unint64_t v6 = (const char *)(*(void *)(*(void *)(*(void *)a1 + 392LL) + 384LL) + 208LL);
        }
        sub_100013D94( "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error destroying: %d\n",  "obj_destroy_complete",  2871,  v6,  *(void *)(a1 + 112),  *(void *)(a1 + 16),  *(_DWORD *)(a1 + 36),  *(_DWORD *)(a1 + 40),  v4);
      }
    }
  }

  if (*(void *)(a1 + 88) != 3735928559LL) {
    panic( "object to be freed is on a list, o %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx list %p/%p\n",  (const void *)a1,  *(void *)(a1 + 112),  *(void *)(a1 + 16),  *(_DWORD *)(a1 + 32),  *(_DWORD *)(a1 + 36),  *(_DWORD *)(a1 + 40),  *(void *)(a1 + 24),  *(const void **)(a1 + 88),  *(const void **)(a1 + 96));
  }
  j__pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 176));
  sub_100036918(*(void **)(a1 + 56), *(unsigned int *)(a1 + 48), *(void *)(a1 + 16), *(void *)a1);
  sub_10003ED5C((void *)a1, *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 44));
}

void sub_10003EF30(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  int v24 = 16000;
  int v4 = *(_DWORD *)(a1 + 120);
  uint64_t v5 = *(pthread_cond_t ***)(a1 + 136);
  if (v4) {
    unint64_t v6 = (_DWORD *)(a1 + 120);
  }
  else {
    unint64_t v6 = 0LL;
  }
  if (*(_BYTE *)(a1 + 148)) {
    uint64_t v7 = *(void *)(a1 + 152);
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v8 = (pthread_mutex_t *)*v5;
  int v9 = *(_DWORD *)(a1 + 96);
  int v10 = *(_DWORD *)(a1 + 144);
  unsigned int v11 = v10 & 0xFFFF0000;
  if (v4)
  {
    v11 |= v4;
    int v12 = *(_DWORD *)(a1 + 124);
    if (v9)
    {
LABEL_9:
      pthread_mutex_lock((pthread_mutex_t *)*v5);
      *((_DWORD *)v5 + 13) = v9;
      goto LABEL_10;
    }
  }

  else
  {
    int v12 = 0;
    if (v9) {
      goto LABEL_9;
    }
  }

  if (((unint64_t)v5[2] & 0x80020000000LL) != 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)*v5);
    *((_DWORD *)v5 + 13) = 0;
LABEL_15:
    if (!sub_10003C938(v5, v10, (uint64_t)v5[14], v6, v7, (unint64_t)v5[15], v11, v12))
    {
      char v23 = 2;
      int v14 = sub_10003CB54((uint64_t)v5, v10, (unint64_t)v5[15], 0, &v24, &v23);
      *((_DWORD *)v5 + 13) = v14;
      if (!v14) {
        goto LABEL_18;
      }
    }

    goto LABEL_17;
  }

  int v22 = sub_10003D9B0(*(void *)(a1 + 136), a2, a3);
  pthread_mutex_lock(v8);
  *((_DWORD *)v5 + 13) = v22;
  if (!v22) {
    goto LABEL_15;
  }
LABEL_10:
  unint64_t v13 = (unint64_t)v5[2];
  v5[2] = (pthread_cond_t *)(v13 & 0xFFFFFE7FFFFFFFFBLL);
  if ((v13 & 4) != 0) {
    j__pthread_cond_broadcast(*v5 + 27);
  }
LABEL_17:
  v5[2] = (pthread_cond_t *)((unint64_t)v5[2] & 0xFFFFFFEFFFFFFFF7LL | 8);
LABEL_18:
  uint64_t v15 = *(void *)(a1 + 104);
  uint64_t v16 = *(void **)(a1 + 112);
  if (v15)
  {
    *(void *)(v15 + 112) = v16;
    uint64_t v16 = *(void **)(a1 + 112);
  }

  else
  {
    *(void *)v8[21].__opaque = v16;
  }

  void *v16 = v15;
  sub_100036F84((uint64_t)v8);
  sub_100038824(v5);
  if (*(_BYTE *)(a1 + 148)) {
    sub_100014004(*(void **)(a1 + 152), *(unsigned __int16 *)(v7 + 2));
  }
  sub_100014004((void *)a1, 160LL);
  __int128 v17 = (unsigned int *)&v8[14].__opaque[12];
  do
  {
    unsigned int v18 = __ldxr(v17);
    unsigned int v19 = v18 - 1;
  }

  while (__stxr(v19, v17));
  if (!v19)
  {
    timespec v20 = (unsigned int *)&v8[14].__opaque[8];
    do
      unsigned int v21 = __ldxr(v20);
    while (__stxr(v21, v20));
    if (v21)
    {
      pthread_mutex_lock(v8);
      j__pthread_cond_broadcast((pthread_cond_t *)&v8[20].__opaque[8]);
      sub_100036F84((uint64_t)v8);
    }
  }

unint64_t *sub_10003F14C(unint64_t *result, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v5 = a2 & 0xC8000000;
  if (a2 < 0 != v4)
  {
    if (v5 == 0x80000000)
    {
      if (a3)
      {
        __int128 v17 = result + 29;
        do
          unint64_t v18 = __ldxr(v17);
        while (__stxr(v18 + a4, v17));
        unsigned int v19 = result + 30;
        do
          unint64_t v20 = __ldxr(v19);
        while (__stxr(v20 + a4, v19));
        unsigned int v21 = result + 32;
      }

      else
      {
        unsigned int v21 = result + 34;
      }

      do
        unint64_t v24 = __ldxr(v21);
      while (__stxr(v24 + 1, v21));
    }

    else
    {
      if (v5 != -2013265920) {
        goto LABEL_28;
      }
      if (a3)
      {
        unint64_t v6 = result + 35;
        do
          unint64_t v7 = __ldxr(v6);
        while (__stxr(v7 + a4, v6));
        uint64_t v8 = result + 36;
        do
          unint64_t v9 = __ldxr(v8);
        while (__stxr(v9 + a4, v8));
        int v10 = result + 38;
      }

      else
      {
        int v10 = result + 40;
      }

      do
        unint64_t v23 = __ldxr(v10);
      while (__stxr(v23 + 1, v10));
    }
  }

  else
  {
    if (v5 != 0x40000000 && v5 != 0) {
LABEL_28:
    }
      panic("unexpected storagetype: 0x%x\n", a2 & 0xC8000000);
    if (a3)
    {
      int v12 = result + 23;
      do
        unint64_t v13 = __ldxr(v12);
      while (__stxr(v13 + a4, v12));
      int v14 = result + 24;
      do
        unint64_t v15 = __ldxr(v14);
      while (__stxr(v15 + a4, v14));
      uint64_t v16 = result + 26;
    }

    else
    {
      uint64_t v16 = result + 28;
    }

    do
      unint64_t v22 = __ldxr(v16);
    while (__stxr(v22 + 1, v16));
  }

  return result;
}

uint64_t sub_10003F28C(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10003F2E8(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0LL;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }

  return result;
}

uint64_t sub_10003F31C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v9 = *(char **)(a2 + 472);
  if ((a3 & 1) == 0 && v9)
  {
    *a5 = (uint64_t)v9;
    sub_10003DC28(v9);
    return 0LL;
  }

  if (v9)
  {
    *a5 = (uint64_t)v9;
    sub_10003DC28(v9);
    if ((a3 & 1) == 0) {
      return 0LL;
    }
    uint64_t v18 = sub_10003CF9C(*a5, (*(_DWORD *)(*(void *)(a2 + 376) + 40LL) >> 29) & 2, a4);
    if ((_DWORD)v18)
    {
      uint64_t v10 = v18;
      sub_100038824(*a5);
      *a5 = 0LL;
      return v10;
    }

uint64_t sub_10003F4CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 22LL;
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a3;
  *(void *)(a1 + 40) = *(void *)(a3 + 4);
  return result;
}

uint64_t sub_10003F4F4(void *a1)
{
  uint64_t v2 = a1[7];
  int v3 = *(_DWORD *)(v2 + 44);
  BOOL v4 = v3 == 1073741826 || v3 == -2147483646;
  if (v4 && ((v5 = *(_DWORD *)(v2 + 40), v5 != -2147483646) ? (BOOL v6 = v5 == 1073741826) : (BOOL v6 = 1), v6)
    || (uint64_t result = sub_100005194(*(void *)(*a1 + 392LL)), !(_DWORD)result))
  {
    uint64_t result = 0LL;
    a1[47] = v2;
  }

  return result;
}

uint64_t sub_10003F568(void *a1)
{
  uint64_t v2 = (uint64_t *)a1[59];
  if (v2 && !*(_DWORD *)(*a1 + 912LL)) {
    sub_100038824(v2);
  }
  return 0LL;
}

uint64_t sub_10003F598(uint64_t *a1, char a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5;
  uint64_t v8 = a1[47];
  unint64_t v9 = (void *)a1[1];
  uint64_t v10 = *(void *)(*a1 + 392);
  if (v9) {
    uint64_t v11 = a1[1];
  }
  else {
    uint64_t v11 = *(void *)(*a1 + 392);
  }
  memset(v106, 170, sizeof(v106));
  unsigned int v104 = -1431655766;
  unsigned int v105 = -1431655766;
  uint64_t v12 = *(unsigned int *)(*(void *)(v10 + 376) + 36LL);
  if ((a2 & 2) == 0)
  {
    if (*a3)
    {
      if (v9) {
        goto LABEL_7;
      }
    }

    else
    {
      *a3 = 1;
      if (v9)
      {
LABEL_7:
        uint64_t v13 = sub_10003CF9C(v9, 0, a5);
        if ((_DWORD)v13)
        {
          else {
            uint64_t v14 = (const char *)(v9[48] + 208LL);
          }
          sub_100013D94("%s:%d: %s obj_modify() failed: %d\n", "omap_reap", 309, v14, v13);
        }

LABEL_72:
        sub_10003B238(a1, v5);
        *a3 = -1;
        return v13;
      }
    }

    uint64_t v13 = 0LL;
    goto LABEL_25;
  }

  unsigned int v116 = 0LL;
  unint64_t v117 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v115 = 0LL;
  memset(v114, 170, sizeof(v114));
  memset(v113, 170, sizeof(v113));
  memset(v112, 170, sizeof(v112));
  unsigned int v111 = -1431655766;
  unint64_t v110 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v109[2] = v15;
  v109[3] = v15;
  v109[0] = v15;
  v109[1] = v15;
  unint64_t v107 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v108 = 0xAAAAAAAAAAAAAAAALL;
  sub_1000442BC(v11, &v108, &v107, 0LL, 0LL);
  if (v107 >= 0x7D1) {
    int v16 = 1024;
  }
  else {
    int v16 = 102;
  }
  if (v107 >= 0x3E9) {
    int v17 = v16;
  }
  else {
    int v17 = 51;
  }
  sub_10003CF10((uint64_t)a1, 2);
  int v18 = *((_DWORD *)a1 + 96);
  if ((v18 & 1) != 0)
  {
    while (1)
      ;
  }

  *((_DWORD *)a1 + 96) = v18 | 1;
  int v19 = sub_100041E64((void *)v11, a1, v5);
  if (v19)
  {
    LODWORD(v13) = v19;
    else {
      __int128 v20 = (const char *)(*(void *)(v11 + 384) + 208LL);
    }
    sub_100013D94("%s:%d: %s error modifying omap: %d\n", "omap_cleanup", 1443, v20, v13);
    if ((_DWORD)v13 == 28) {
      uint64_t v13 = 36LL;
    }
    else {
      uint64_t v13 = v13;
    }
    goto LABEL_75;
  }

  uint64_t v24 = sub_10003F31C(v11, (uint64_t)a1, 1LL, v5, (uint64_t *)&v115);
  if ((_DWORD)v24)
  {
    uint64_t v13 = v24;
    sub_100037DC8(v11);
    sub_100013D94("%s:%d: %s error getting mapping tree: %d\n");
    goto LABEL_75;
  }

  unsigned int v96 = v17;
  if (*a3)
  {
    unsigned int v39 = 0;
  }

  else
  {
    sub_10003D514((uint64_t)a1, 2);
    v114[0] = 0uLL;
    v112[0] = 16;
    unsigned int v111 = 16;
    sub_100026D8C((uint64_t)v109, (uint64_t)v115, 0LL, 0, (unint64_t *)v114, 16, 0x10u, v113, 0x10u, 0LL);
    unsigned int v39 = 0;
    if (!sub_100026EFC((uint64_t)v109))
    {
      unsigned int v39 = 0;
      int v101 = v12 - 1;
      uint64_t v91 = v8;
      do
      {
        if (*(void *)&v114[0] >= *(void *)(v8 + 88)) {
          break;
        }
        uint64_t v61 = v12;
        int v62 = sub_1000260EC((uint64_t)v115, 0LL, (unint64_t *)v114, 0x10u, v5);
        if (v62)
        {
          int v63 = v62;
          if (sub_100037DC8(v11) == 13) {
            sub_100013D94( "%s:%d: %s remove mapping (%lld, %lld) below watermark failed: %d\n",  "omap_cleanup",  1468,  (const char *)(v11 + 3992),  *(void *)&v114[0],  *((void *)&v114[0] + 1),  v63);
          }
          else {
            sub_100013D94( "%s:%d: %s remove mapping (%lld, %lld) below watermark failed: %d\n",  "omap_cleanup",  1468,  (const char *)(*(void *)(v11 + 384) + 208LL),  *(void *)&v114[0],  *((void *)&v114[0] + 1),  v63);
          }
        }

        if ((v113[0] & 1) == 0)
        {
          unsigned int v64 = (v101 + DWORD1(v113[0])) / v61;
          int v65 = sub_10004BD08((const char *)v11, 0LL, *((unint64_t *)&v113[0] + 1), v64, v5);
          if (v65)
          {
            int v66 = v65;
            int v67 = sub_100037DC8(v11);
            unint64_t v68 = (const char *)(v11 + 3992);
            if (v67 != 13) {
              unint64_t v68 = (const char *)(*(void *)(v11 + 384) + 208LL);
            }
            sub_100013D94( "%s:%d: %s spaceman_free(%lld, %d) failed: %d\n",  "omap_cleanup",  1475,  v68,  *((void *)&v113[0] + 1),  v64,  v66);
          }

          sub_1000390A0(*(pthread_mutex_t **)(v10 + 392), (uint64_t)v9, *(uint64_t *)&v114[0], *((uint64_t *)&v114[0] + 1));
          uint64_t v8 = v91;
        }

        if (v96 == v39)
        {
LABEL_191:
          sub_10003CF10((uint64_t)a1, 2);
          uint64_t v13 = 36LL;
          goto LABEL_75;
        }

        uint64_t v12 = v61;
        ++v39;
        sub_100026F18((uint64_t)v109);
      }

      while (!sub_100026EFC((uint64_t)v109));
    }

    sub_10003CF10((uint64_t)a1, 2);
  }

  unint64_t v41 = *(void *)(v8 + 56);
  if (!v41) {
    goto LABEL_211;
  }
  unsigned int v100 = v12;
  if (*a3 && *((void *)a3 + 4) != -1LL) {
    goto LABEL_85;
  }
  int v58 = *(_DWORD *)(v8 + 44);
  __int128 v119 = 0u;
  uint64_t v124 = 0LL;
  __int128 v123 = 0u;
  __int128 v122 = 0u;
  __int128 v121 = 0u;
  __int128 v120 = 0u;
  char v118 = sub_10003F2E8;
  DWORD2(v119) = 19;
  if ((unsigned __int16)v58 != 2)
  {
    uint64_t v13 = 22LL;
    goto LABEL_147;
  }

  uint64_t v13 = sub_100027CC4(v11, v58 & 0xFFFF0000, v41, 0LL, 0, (uint64_t)&v118, v5, &v116);
  if ((_DWORD)v13)
  {
LABEL_147:
    sub_100037DC8(v11);
    sub_100013D94("%s:%d: %s unable to get snapshot tree: %d\n");
    goto LABEL_75;
  }

  if (!*a3)
  {
    uint64_t v92 = v8;
    uint64_t v76 = v5;
    *((void *)a3 + 2) = 0LL;
    *((void *)a3 + 3) = 0LL;
    uint64_t v77 = (uint64_t *)(a3 + 4);
    unint64_t v117 = 0LL;
    v112[0] = 8;
    unsigned int v111 = 16;
    sub_100026D8C((uint64_t)v109, (uint64_t)v116, 0LL, 0, &v117, 8, 8u, &v114[1], 0x10u, 0LL);
    while (!sub_100026EFC((uint64_t)v109))
    {
      int v78 = v114[1];
      uint64_t v79 = *v77;
      if ((v114[1] & 1) != 0)
      {
        if (v79)
        {
          if (((a3[1] ^ LODWORD(v114[1])) & 2) != 0) {
            break;
          }
          *((void *)a3 + 3) = v117;
        }

        else
        {
          unint64_t v80 = v117;
          *((void *)a3 + 2) = v117;
          *((void *)a3 + 3) = v80;
          a3[1] = v78;
        }
      }

      else if (v79)
      {
        goto LABEL_206;
      }

      sub_100026F18((uint64_t)v109);
    }

    uint64_t v79 = *v77;
    if (*v77)
    {
LABEL_206:
      *((void *)a3 + 1) = v79;
      v112[0] = 8;
      unsigned int v111 = 16;
      uint64_t v81 = sub_100026464((uint64_t)v116, 0LL, (unint64_t *)a3 + 1, v112, 8u, &v114[1], &v111, 2u, 0, 0LL);
      uint64_t v5 = v76;
      uint64_t v8 = v92;
      if ((_DWORD)v81)
      {
        uint64_t v13 = v81;
        if ((_DWORD)v81 != 2) {
          goto LABEL_225;
        }
        *((void *)a3 + 1) = 0LL;
      }

      *((void *)a3 + 5) = 0LL;
      *((void *)a3 + 6) = 0LL;
      else {
        unsigned int v82 = (const char *)(*(void *)(v11 + 384) + 208LL);
      }
      sub_100013CBC( "%s:%d: %s started cleaning snapshots %lld-%lld\n",  "omap_cleanup",  1568,  v82,  *((void *)a3 + 2),  *((void *)a3 + 3));
      a1[60] = *((void *)a3 + 1);
      unint64_t v60 = *((void *)a3 + 3);
      a1[61] = v60;
      *a3 = 1;
      *((_DWORD *)a1 + 96) |= 2u;
      unint64_t v59 = (unint64_t *)(a3 + 8);
      goto LABEL_222;
    }

LABEL_211:
    uint64_t v13 = 0LL;
    goto LABEL_75;
  }

  unint64_t v59 = (unint64_t *)(a3 + 8);
  if (*((void *)a3 + 4) != -1LL) {
    goto LABEL_85;
  }
  unint64_t v60 = *((void *)a3 + 3);
LABEL_222:
  unint64_t *v59 = v60;
  v112[0] = 8;
  unsigned int v111 = 16;
  uint64_t v83 = sub_100026464((uint64_t)v116, 0LL, v59, v112, 8u, &v114[1], &v111, 4u, 0, 0LL);
  if ((_DWORD)v83)
  {
    uint64_t v13 = v83;
    if ((_DWORD)v83 == 2)
    {
      unint64_t *v59 = -1LL;
      goto LABEL_85;
    }

LABEL_225:
    sub_100037DC8(v11);
    sub_100013D94("%s:%d: %s error searching snapshot tree: %d\n");
    goto LABEL_75;
  }

LABEL_115:
      int v48 = 0;
      goto LABEL_126;
    }

    if ((v98 & 2) == 0)
    {
      uint64_t v13 = 0LL;
      if (*(void *)&v113[1] != *(void *)&v114[0]) {
        goto LABEL_115;
      }
      int v48 = 0;
      if (*((void *)&v113[1] + 1) > v87) {
        goto LABEL_126;
      }
    }

    int v49 = sub_1000260EC((uint64_t)v115, 0LL, (unint64_t *)v114, 0x10u, v5);
    if (v49)
    {
      int v50 = v49;
      if (sub_100037DC8(v11) == 13) {
        sub_100013D94( "%s:%d: %s remove mapping (%lld, %lld) failed: %d\n",  "omap_cleanup",  1689,  v86,  *(void *)&v114[0],  *((void *)&v114[0] + 1),  v50);
      }
      else {
        sub_100013D94( "%s:%d: %s remove mapping (%lld, %lld) failed: %d\n",  "omap_cleanup",  1689,  (const char *)(*(void *)(v11 + 384) + 208LL),  *(void *)&v114[0],  *((void *)&v114[0] + 1),  v50);
      }
    }

    unsigned int v51 = (v100 - 1 + DWORD1(v113[0])) / v100;
    uint64_t v13 = sub_10004BD08((const char *)v11, 0LL, *((unint64_t *)&v113[0] + 1), v51, v5);
    if ((_DWORD)v13)
    {
      int v52 = sub_100037DC8(v11);
      timespec v53 = (const char *)(v11 + 3992);
      if (v52 != 13) {
        timespec v53 = (const char *)(*(void *)(v11 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s spaceman_free(%lld, %d) failed: %d\n",  "omap_cleanup",  1695,  v53,  *((void *)&v113[0] + 1),  v51,  v13);
    }

    if ((v98 & 2) == 0) {
      sub_1000390A0(*(pthread_mutex_t **)(v10 + 392), (uint64_t)v9, *(uint64_t *)&v114[0], *((uint64_t *)&v114[0] + 1));
    }
    int v54 = (v98 >> 1) & 1;
    if (!(_DWORD)v45) {
      LOBYTE(v54) = 1;
    }
    int v48 = (LOBYTE(v112[1]) & v54);
    uint64_t v44 = v45;
LABEL_126:
    if ((v112[1] & 1) != 0)
    {
      if (v48)
      {
        int v55 = sub_1000260EC((uint64_t)v115, 0LL, (unint64_t *)&v113[1], 0x10u, v5);
        if (v55)
        {
          int v56 = v55;
          if (sub_100037DC8(v11) == 13) {
            sub_100013D94( "%s:%d: %s remove mapping (%lld, %lld) failed: %d\n",  "omap_cleanup",  1722,  v86,  *(void *)&v113[1],  *((void *)&v113[1] + 1),  v56);
          }
          else {
            sub_100013D94( "%s:%d: %s remove mapping (%lld, %lld) failed: %d\n",  "omap_cleanup",  1722,  (const char *)(*(void *)(v11 + 384) + 208LL),  *(void *)&v113[1],  *((void *)&v113[1] + 1),  v56);
          }
        }
      }

      v112[0] = 16;
      unsigned int v111 = 16;
      uint64_t v57 = sub_100026464((uint64_t)v115, 0LL, (unint64_t *)&v113[1], v112, 0x10u, &v112[1], &v111, 4u, 0, 0LL);
      uint64_t v13 = v57;
      if ((_DWORD)v57)
      {
        if ((_DWORD)v57 == 2)
        {
          uint64_t v13 = 0LL;
          *(void *)&v113[1] = 0LL;
        }

        else if (sub_100037DC8(v11) == 13)
        {
          sub_100013D94( "%s:%d: %s lookup returned unexpected error while iterating: %d\n",  "omap_cleanup",  1739,  v86,  v13);
        }

        else
        {
          sub_100013D94( "%s:%d: %s lookup returned unexpected error while iterating: %d\n",  "omap_cleanup",  1739,  (const char *)(*(void *)(v11 + 384) + 208LL),  v13);
        }
      }
    }

    ++v39;
    v114[0] = v113[1];
    v113[0] = *(_OWORD *)&v112[1];
    uint64_t v43 = *(void *)&v113[1];
  }

  while (*(void *)&v113[1]);
  sub_10003CF10((uint64_t)a1, 2);
  uint64_t v8 = v90;
  if ((_DWORD)v13) {
    goto LABEL_75;
  }
LABEL_167:
  int v69 = *(_DWORD *)(v8 + 44);
  unint64_t v70 = *(void *)(v8 + 56);
  __int128 v119 = 0u;
  __int128 v123 = 0u;
  __int128 v122 = 0u;
  __int128 v121 = 0u;
  __int128 v120 = 0u;
  uint64_t v124 = 0LL;
  char v118 = sub_10003F2E8;
  DWORD2(v119) = 19;
  if ((unsigned __int16)v69 != 2)
  {
    uint64_t v13 = 22LL;
    goto LABEL_147;
  }

  uint64_t v13 = sub_100027CC4(v11, v69 & 0xFFFF0000, v70, 0LL, 1, (uint64_t)&v118, v5, &v116);
  if ((_DWORD)v13) {
    goto LABEL_147;
  }
  if (sub_10003965C((uint64_t)v116) != *(void *)(v8 + 56))
  {
    *(void *)(v8 + 56) = sub_10003965C((uint64_t)v116);
    sub_10003E644((uint64_t)a1, v5, 0LL);
  }

  unint64_t v117 = v94;
  timespec v103 = (void *)(v8 + 72);
  while (1)
  {
    v112[0] = 8;
    unsigned int v111 = 16;
    uint64_t v71 = sub_100026464((uint64_t)v116, 0LL, &v117, v112, 8u, &v114[1], &v111, 4u, 0, 0LL);
    if ((_DWORD)v71) {
      break;
    }
    unint64_t v72 = v117;
    if (v117 < v87)
    {
      uint64_t v73 = sub_1000260EC((uint64_t)v116, 0LL, &v117, v112[0], v5);
      if ((_DWORD)v73)
      {
        uint64_t v13 = v73;
        sub_100037DC8(v11);
        sub_100013D94("%s:%d: %s error updating snapshot tree: %d\n");
        goto LABEL_75;
      }

      --*(_DWORD *)(v8 + 36);
      if (sub_100037DC8(v11) == 13) {
        sub_100013CBC( "%s:%d: %s completed cleaning snapshot %lld, om_snap_count %d om_most_recent_snap %lld\n",  "omap_cleanup",  1793,  (const char *)(v11 + 3992),  v117,  *(_DWORD *)(v8 + 36),  *(void *)(v8 + 64));
      }
      else {
        sub_100013CBC( "%s:%d: %s completed cleaning snapshot %lld, om_snap_count %d om_most_recent_snap %lld\n",  "omap_cleanup",  1793,  (const char *)(*(void *)(v11 + 384) + 208LL),  v117,  *(_DWORD *)(v8 + 36),  *(void *)(v8 + 64));
      }
      if ((v98 & 2) != 0 && v117 >= *v103)
      {
        unint64_t v74 = *(void *)(v8 + 80);
        BOOL v75 = v117 >= v74;
        if (v117 <= v74)
        {
          *timespec v103 = v117;
          if (v75)
          {
            *timespec v103 = 0LL;
            *(void *)(v8 + 80) = 0LL;
          }
        }
      }

      sub_10003E644((uint64_t)a1, v5, 0LL);
      unint64_t v72 = v117;
    }

    if (v72 >= v87) {
      goto LABEL_213;
    }
  }

  uint64_t v13 = v71;
  if ((_DWORD)v71 != 2) {
    goto LABEL_225;
  }
LABEL_213:
  if (v9 && (v98 & 2) != 0) {
    sub_100039304(*(void *)(v10 + 392), (uint64_t)v9, v94 + 1, v88);
  }
  if (*(_DWORD *)(v8 + 36))
  {
    unint64_t v117 = -1LL;
    v112[0] = 8;
    unsigned int v111 = 16;
    uint64_t v13 = sub_100026464((uint64_t)v116, 0LL, &v117, v112, 8u, &v114[1], &v111, 1u, 0, 0LL);
    if ((_DWORD)v13) {
      goto LABEL_75;
    }
    *(void *)(v8 + 64) = v117;
  }

  else
  {
    *(void *)(v8 + 64) = 0LL;
    uint64_t v84 = sub_100029238((size_t)v116, v5, 0LL);
    if ((_DWORD)v84)
    {
      uint64_t v13 = v84;
      sub_100037DC8(v11);
      sub_100013D94("%s:%d: %s error deleting empty snapshot tree: %d\n");
      goto LABEL_75;
    }

    *(void *)(v8 + 56) = 0LL;
    sub_10003E644((uint64_t)a1, v5, 0LL);
  }

  *a3 = 0;
  *((_DWORD *)a1 + 96) &= ~2u;
  a1[60] = 0LL;
  a1[61] = 0LL;
  if (*(void *)(v8 + 56)) {
    uint64_t v13 = 36LL;
  }
  else {
    uint64_t v13 = 0LL;
  }
LABEL_75:
  *((_DWORD *)a1 + 96) &= ~1u;
  sub_10003D514((uint64_t)a1, 2);
  if (v116) {
    sub_100038824(v116);
  }
  if (v115) {
    sub_100038824(v115);
  }
  return v13;
}

uint64_t sub_100040A44(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5, void *a6)
{
  else {
    uint64_t v12 = 0LL;
  }
  uint64_t v13 = a1;
  if (v12) {
    uint64_t v13 = *(void *)(v12 + 392);
  }
  int v21 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v22 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  *a6 = 0LL;
  uint64_t v14 = 22LL;
  if (a2 >> 30 && (a2 & 0x8000000) == 0 && (a4 == 1073741826 || a4 == -2147483646))
  {
    v20[0] = a3;
    v20[1] = a4;
    _OWORD v20[2] = 1073741826;
    uint64_t v14 = sub_10003A068( *(pthread_mutex_t **)(v13 + 392),  a2 & 0xFFFF0000,  0LL,  (uint64_t)&xmmword_10005B9F8,  (uint64_t)v20,  v12,  a5,  (uint64_t *)&v22);
    if (!(_DWORD)v14)
    {
      v23[1] = 0LL;
      __int128 v24 = 0u;
      uint64_t v28 = 0LL;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v25 = 0u;
      v23[0] = (uint64_t)sub_10003F28C;
      v23[2] = 0x20000000BLL;
      if (a4 < 0) {
        unsigned int v15 = 0x80000000;
      }
      else {
        unsigned int v15 = 0x40000000;
      }
      uint64_t v14 = sub_100027934(a1, v15 | a4 & 0xFFFF0000, 0, 0x10u, 16, v23, a5, (uint64_t *)&v21);
      if ((_DWORD)v14)
      {
        sub_10003B238(v22, a5);
        sub_100038824(v22);
      }

      else
      {
        int v16 = v21;
        *(_DWORD *)(v22[47] + 40) = a4;
        uint64_t v17 = sub_10003965C((uint64_t)v16);
        int v18 = v22;
        *(void *)(v22[47] + 48) = v17;
        sub_10003E644((uint64_t)v18, a5, 0LL);
        sub_100038824(v21);
        uint64_t v14 = 0LL;
        if (v22) {
          *a6 = v22;
        }
      }
    }
  }

  return v14;
}

uint64_t sub_100040C2C(uint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  else {
    uint64_t v8 = 0LL;
  }
  unint64_t v9 = (void *)a1;
  if (v8) {
    unint64_t v9 = *(void **)(v8 + 392);
  }
  __int128 v20 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = sub_10003B574(v9[49], 0x40000000u, a2, (int *)&xmmword_10005B9F8, 0LL, v8, 0LL, a3, (uint64_t *)&v20);
  if (!(_DWORD)v10)
  {
    if (v8) {
      uint64_t v11 = sub_10003965C(v8);
    }
    else {
      uint64_t v11 = 0LL;
    }
    int v12 = sub_100037DC0((uint64_t)v20);
    int v13 = sub_1000398C8((uint64_t)v20);
    uint64_t v14 = sub_10003965C((uint64_t)v20);
    if (a4) {
      uint64_t v15 = sub_100011884(v9, v12, v13, v11, v14, a3, 0, a4);
    }
    else {
      uint64_t v15 = sub_100011D2C(v9, v12, v13, v11, v14, a3, 0);
    }
    uint64_t v10 = v15;
    if ((_DWORD)v15)
    {
      else {
        int v16 = (const char *)(*(void *)(a1 + 384) + 208LL);
      }
      uint64_t v17 = sub_10003965C((uint64_t)v20);
      int v18 = sub_100037DC0((uint64_t)v20);
      sub_100013D94( "%s:%d: %s error adding omap 0x%llx type 0x%x to reap list: %d\n",  "omap_destroy",  522,  v16,  v17,  v18,  v10);
    }

    sub_100038824(v20);
  }

  return v10;
}

uint64_t sub_100040DD8(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  int v8 = sub_100037DC8(a1);
  uint64_t v9 = 0LL;
  uint64_t v10 = a1;
  if (a1 && v8 == 13)
  {
    uint64_t v10 = *(void *)(a1 + 392);
    if (*(void *)(a1 + 496)) {
      uint64_t v9 = *(void *)(a1 + 496);
    }
    else {
      uint64_t v9 = a1;
    }
  }

  if ((a2 & 1) == 0)
  {
LABEL_9:
    if (v9)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 1144));
      int v12 = *(char **)(v9 + 3608);
      *a4 = v12;
      int v13 = (uint64_t *)(*(void *)(v9 + 376) + 128LL);
    }

    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(v10 + 656));
      int v12 = *(char **)(v10 + 720);
      *a4 = v12;
      int v13 = (uint64_t *)(*(void *)(v10 + 376) + 160LL);
    }

    uint64_t v14 = *v13;
    if (v12)
    {
      sub_10003DC28(v12);
      if ((a2 & 1) == 0) {
        goto LABEL_25;
      }
      uint64_t v15 = sub_10003CF9C(*a4, a2, a3);
      if ((_DWORD)v15)
      {
        uint64_t v11 = v15;
        sub_100038824(*a4);
        if (v9) {
          int v16 = (pthread_mutex_t *)(v9 + 1144);
        }
        else {
          int v16 = (pthread_mutex_t *)(v10 + 656);
        }
        goto LABEL_33;
      }
    }

    else
    {
      uint64_t v17 = sub_10003B574( *(void *)(v10 + 392),  a2 | 0x40000000,  v14,  &xmmword_10005B9F8,  0LL,  v9,  0LL,  a3,  a4);
      if ((_DWORD)v17)
      {
        uint64_t v11 = v17;
        if (v9)
        {
LABEL_27:
          int v16 = (pthread_mutex_t *)(v9 + 1144);
LABEL_33:
          pthread_mutex_unlock(v16);
          return v11;
        }

LABEL_32:
        int v16 = (pthread_mutex_t *)(v10 + 656);
        goto LABEL_33;
      }

      int v18 = (char **)(v9 + 3608);
      if (!v9) {
        int v18 = (char **)(v10 + 720);
      }
      *int v18 = *a4;
      sub_10003DC28(*a4);
      if ((a2 & 1) == 0) {
        goto LABEL_25;
      }
    }

    if (sub_10003965C((uint64_t)*a4) != v14)
    {
      uint64_t v19 = sub_10003965C((uint64_t)*a4);
      if (v9)
      {
        *(void *)(*(void *)(v9 + 376) + 128LL) = v19;
        sub_10001AAF0(v9, a3);
        goto LABEL_26;
      }

      *(void *)(*(void *)(v10 + 376) + 160LL) = v19;
      sub_10003E644(a1, a3, 0LL);
      goto LABEL_31;
    }

      uint64_t v17 = *(void *)(v12[49] + 32);
      if (v17 <= v8[132])
      {
        int v18 = 0;
      }

      else if (*(_BYTE *)(a3 + 969))
      {
        int v18 = 1;
      }

      else
      {
        sub_100013D94( "%s:%d: %s main free queue tree is too large: %lld nodes (limit %d) xid %lld\n",  "spaceman_checkpoint_traverse",  3122,  (const char *)(*(void *)(a1 + 384) + 208LL),  v17,  v8[132],  *(void *)(a2 + 16));
        int v18 = 1;
        int v12 = v24;
      }

      *(_BYTE *)(a3 + 969) = v18;
      goto LABEL_38;
    }
  }

  if (v35 >= 0xFFFFFF) {
    unint64_t v38 = 0xFFFFFFLL;
  }
  else {
    unint64_t v38 = v35;
  }
  if (v30 <= v38) {
    goto LABEL_36;
  }
LABEL_56:
  uint64_t v43 = *(void *)&v62[0];
  *(void *)int v36 = *(void *)&v62[0];
  *(void *)(v36 + 8) = v30;
  *(_BYTE *)(v36 + 16) = v58;
  if (v29)
  {
    uint64_t v44 = *(void *)(a1 + 376);
    uint64_t v45 = v44 + 48LL * a2;
    uint64_t v46 = *(void *)(v45 + 56);
    if (v46 > v10)
    {
      int v47 = *(void *)(a3 + 32);
      if (v47)
      {
        int v48 = *(unsigned int *)(v44 + 36);
        int v49 = v10 * v48;
        if (v46 - 1 == v10) {
          int v48 = *(void *)(v45 + 48) % v48;
        }
        if (sub_100013C78(v49, v48, *(void *)(a3 + 24), v47, 0LL)) {
          *(_BYTE *)(v36 + 16) = 0;
        }
      }
    }
  }

  if (v43 % *(unsigned int *)(v34 + 36))
  {
    unint64_t v60 = 0u;
    uint64_t v61 = 0u;
    unint64_t v59 = 0u;
    sub_10004DFE0(a1, a2, 3uLL, (uint64_t)v62, (uint64_t)&v59);
    int v50 = (_OWORD *)(v36 + 24);
    if (*((uint64_t *)&v59 + 1) >= v30)
    {
      *(void *)&uint64_t v15 = v59;
      *int v50 = v59;
      *(void *)(v36 + 40) = v60;
    }

    else
    {
      uint64_t v15 = *(_OWORD *)v36;
      *int v50 = *(_OWORD *)v36;
      *(void *)(v36 + 40) = *(void *)(v36 + 16);
      *(void *)(v36 + 24) = v43 / *(unsigned int *)(v34 + 36) * *(unsigned int *)(v34 + 36);
    }
  }

  return *(double *)&v15;
}

uint64_t sub_100040FB0(uint64_t a1, size_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = sub_100037DC8(a1);
  __int128 v21 = 0uLL;
  if ((_DWORD)a4 == 2)
  {
    if (v8 == 13) {
      uint64_t v9 = a1;
    }
    else {
      uint64_t v9 = 0LL;
    }
    *(void *)(a3 + 8) = v9;
  }

  if ((*(_BYTE *)(a3 + 20) & 0x40) != 0) {
    return 0LL;
  }
  sub_10003CF10(a3, 1);
  int v10 = sub_1000398D0(*(_DWORD *)(*(void *)(a3 + 376) + 40LL));
  uint64_t v11 = *(void *)(a3 + 376);
  if (!v10 || !*(void *)(v11 + 48))
  {
LABEL_12:
    if (sub_1000398D0(*(_DWORD *)(v11 + 44))
      && (uint64_t v14 = *(void *)(a3 + 376), (v15 = *(void *)(v14 + 56)) != 0))
    {
      int v16 = *(_DWORD *)(v14 + 44);
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      uint64_t v28 = 0LL;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v25 = 0u;
      uint64_t v22 = sub_10003F2E8;
      DWORD2(v23) = 19;
      if ((unsigned __int16)v16 != 2)
      {
        sub_10003D514(a3, 1);
        int v18 = (uint64_t *)*((void *)&v21 + 1);
        if (!*((void *)&v21 + 1))
        {
          uint64_t v17 = (uint64_t *)v21;
          uint64_t v13 = 22LL;
          if (!(void)v21) {
            return v13;
          }
          goto LABEL_39;
        }

        uint64_t v13 = 22LL;
        goto LABEL_35;
      }

      uint64_t v13 = sub_100027CC4(a1, v16 & 0xFFFF0000, v15, 0LL, 0, (uint64_t)&v22, 0LL, (uint64_t **)&v21);
      sub_10003D514(a3, 1);
      if ((_DWORD)v13) {
        goto LABEL_32;
      }
    }

    else
    {
      sub_10003D514(a3, 1);
    }

    if ((sub_100037DC0(a3) & 0x80000000) == 0)
    {
      int v18 = (uint64_t *)*((void *)&v21 + 1);
      uint64_t v17 = (uint64_t *)v21;
      if (v21 != 0)
      {
        if (!*((void *)&v21 + 1))
        {
          if (!(void)v21) {
            return 0LL;
          }
          goto LABEL_38;
        }

        goto LABEL_34;
      }

      sub_10003E20C(a3, 1);
      goto LABEL_27;
    }

    if ((_DWORD)a4 == 2)
    {
      uint64_t v19 = sub_10003E7D8(a3);
    }

    else
    {
      if ((_DWORD)a4 != 1)
      {
LABEL_27:
        uint64_t v13 = 0LL;
        goto LABEL_32;
      }

      uint64_t v19 = sub_10003E754((unsigned int *)a3);
    }

    uint64_t v13 = v19;
LABEL_32:
    int v18 = (uint64_t *)*((void *)&v21 + 1);
    if (!*((void *)&v21 + 1)) {
      goto LABEL_36;
    }
    if ((_DWORD)v13)
    {
LABEL_35:
      sub_100038824(v18);
LABEL_36:
      uint64_t v17 = (uint64_t *)v21;
      if (!(void)v21) {
        return v13;
      }
      if ((_DWORD)v13)
      {
LABEL_39:
        sub_100038824(v17);
        return v13;
      }

uint64_t sub_100041220( uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  int v14 = sub_100037DC8(a1);
  unint64_t v15 = (void *)a1;
  if (a1)
  {
    unint64_t v15 = (void *)a1;
    if (v14 == 13) {
      unint64_t v15 = *(void **)(a1 + 392);
    }
  }

  v26[1] = a3;
  __int128 v27 = 0LL;
  v25[1] = a4;
  v26[0] = a2;
  v25[0] = __PAIR64__(a5, a6);
  __int128 v23 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  __int128 v24 = (char *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v16 = 22LL;
  if (sub_10004E670((uint64_t)v15, a7) && a2 && a3 && a5)
  {
    uint64_t v17 = v15[47];
    if ((*(_BYTE *)(v17 + 65) & 1) != 0)
    {
      uint64_t v21 = sub_100044238(v15, (uint64_t *)&v27);
      if ((_DWORD)v21)
      {
        uint64_t v16 = v21;
        else {
          sub_100013D94( "%s:%d: %s unable to get spaceman: %d\n",  "omap_set",  770,  (const char *)(*(void *)(a1 + 384) + 208LL),  v16);
        }
        return v16;
      }

      uint64_t v17 = v15[47];
      unsigned int v19 = (a5 + *(_DWORD *)(v17 + 36) - 1) / *(_DWORD *)(v17 + 36);
      if (v27) {
        uint64_t v18 = v27[47];
      }
      else {
        uint64_t v18 = 0LL;
      }
    }

    else
    {
      uint64_t v18 = 0LL;
      unsigned int v19 = (a5 + *(_DWORD *)(v17 + 36) - 1) / *(_DWORD *)(v17 + 36);
    }

    uint64_t v16 = sub_1000052C0(v17, v18, a4, v19, 0);
    if (v27) {
      sub_100038824(v27);
    }
    if (!(_DWORD)v16)
    {
      uint64_t v16 = sub_100040DD8(a1, 1LL, a7, &v24);
      if (!(_DWORD)v16)
      {
        sub_10003CF10((uint64_t)v24, 2);
        uint64_t v20 = sub_10003F31C(a1, (uint64_t)v24, 1LL, a7, (uint64_t *)&v23);
        if ((_DWORD)v20)
        {
          uint64_t v16 = v20;
        }

        else
        {
          if ((a6 & 4) != 0) {
            LODWORD(v25[0]) = *(_DWORD *)(*((void *)v24 + 47) + 32LL) & 0x10 | a6;
          }
          uint64_t v16 = sub_10001EADC(v23, 0LL, v26, 16, v25, 0x10u, a7);
          sub_100038824(v23);
        }

        sub_10003D514((uint64_t)v24, 2);
        sub_100038824((uint64_t *)v24);
      }
    }
  }

  return v16;
}

uint64_t sub_10004144C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  int v14 = sub_100037DC8(a1);
  uint64_t v15 = a1;
  if (a1)
  {
    uint64_t v15 = a1;
    if (v14 == 13) {
      uint64_t v15 = *(void *)(a1 + 392);
    }
  }

  *(void *)&__int128 v32 = a2;
  *((void *)&v32 + 1) = a3;
  v30[0] = a6;
  v30[1] = a5;
  uint64_t v31 = a4;
  memset(v29, 170, sizeof(v29));
  uint64_t v16 = 22LL;
  if (!sub_10004E670(v15, a7)) {
    return v16;
  }
  if (!a2) {
    return v16;
  }
  if (!a3) {
    return v16;
  }
  uint64_t v16 = sub_100040DD8(a1, 1LL, a7, (char **)&v29[2]);
  if ((_DWORD)v16) {
    return v16;
  }
  sub_10003CF10(v29[2], 2);
  uint64_t v16 = sub_10003F31C(a1, v29[2], 1LL, a7, &v29[1]);
  uint64_t v17 = v29[2];
  if ((_DWORD)v16)
  {
LABEL_45:
    sub_10003D514(v17, 2);
    sub_100038824(v29[2]);
    return v16;
  }

  uint64_t v18 = *(void *)(v29[2] + 376LL);
  unint64_t v19 = *(void *)(v18 + 64);
  if ((*(_BYTE *)(v29[2] + 384LL) & 2) != 0 && *(void *)(v29[2] + 488LL) == v19) {
    unint64_t v19 = *(void *)(v29[2] + 480LL);
  }
  if ((*(_BYTE *)(v18 + 32) & 1) != 0)
  {
    if ((a6 & 1) == 0)
    {
      *(_OWORD *)uint64_t v28 = v32;
      unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
      v29[0] = 0x1000000010LL;
      uint64_t v22 = sub_100026464(v29[1], 0LL, v28, (unsigned int *)v29 + 1, 0x10u, &v26, (unsigned int *)v29, 0, 0, 0LL);
      if ((_DWORD)v22) {
        goto LABEL_43;
      }
      int v20 = 0;
      BOOL v23 = ((v26 >> 1) & 1) == 0;
      goto LABEL_27;
    }

    int v20 = 0;
    goto LABEL_26;
  }

  int v20 = a6 & 1;
  if (v19 < a3)
  {
    if (v20)
    {
      *(_OWORD *)uint64_t v28 = v32;
      unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
      v29[0] = 0x1000000010LL;
      if (sub_100026464( v29[1],  0LL,  v28,  (unsigned int *)v29 + 1,  0x10u,  &v26,  (unsigned int *)v29,  2u,  0,  0LL)) {
        BOOL v21 = 0;
      }
      else {
        BOOL v21 = v28[0] == a2;
      }
      int v20 = v21;
    }

uint64_t sub_100041760( uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4, _DWORD *a5, _DWORD *a6, unint64_t *a7)
{
  unint64_t v11 = a3;
  uint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  __int128 v32 = (char *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v29 = a2;
  unint64_t v30 = a3;
  unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v25 = 16;
  unsigned int v26 = 16;
  char v24 = 0;
  uint64_t v14 = sub_100040DD8(a1, 0LL, 0LL, &v32);
  if (!(_DWORD)v14)
  {
    sub_10003CF10((uint64_t)v32, 1);
    if (*(void *)(*((void *)v32 + 47) + 88LL) > a2)
    {
      sub_10003D514((uint64_t)v32, 1);
      uint64_t v14 = 2LL;
LABEL_33:
      sub_100038824(v32);
      return v14;
    }

    uint64_t v15 = sub_10003F31C(a1, (uint64_t)v32, 0LL, 0LL, &v31);
    if ((_DWORD)v15)
    {
      uint64_t v14 = v15;
      sub_10003D514((uint64_t)v32, 1);
      goto LABEL_33;
    }

    if (!v11)
    {
      unint64_t v11 = -1LL;
      unint64_t v30 = -1LL;
    }

    BOOL v16 = 1;
    uint64_t v17 = sub_100026464(v31, 0LL, &v29, &v26, 0x10u, &v27, &v25, 1u, 0, 0LL);
    if ((_DWORD)v17) {
      goto LABEL_9;
    }
    uint64_t v18 = *((void *)v32 + 47);
    unint64_t v19 = *(void *)(v18 + 72);
    unint64_t v20 = v29;
    if (v19) {
      BOOL v21 = v29 == a2;
    }
    else {
      BOOL v21 = 0;
    }
    if (v21)
    {
      if (v30 < v19 || v30 > *(void *)(v18 + 80)) {
        goto LABEL_18;
      }
      unint64_t v29 = a2;
      unint64_t v30 = v19 - 1;
      uint64_t v17 = sub_100026464(v31, 0LL, &v29, &v26, 0x10u, &v27, &v25, 1u, 0, 0LL);
      if ((_DWORD)v17)
      {
LABEL_9:
        uint64_t v14 = v17;
        goto LABEL_31;
      }

      unint64_t v20 = v29;
    }

    if (v20 != a2)
    {
LABEL_30:
      uint64_t v14 = 2LL;
LABEL_31:
      sub_100038824(v31);
      sub_10003D514((uint64_t)v32, 1);
      if (!v16) {
        sub_100041B20(a1, (uint64_t)v32);
      }
      goto LABEL_33;
    }

uint64_t sub_1000419D8(uint64_t result, unint64_t a2, unint64_t a3, _BYTE *a4)
{
  uint64_t v13 = 1LL;
  unint64_t v14 = a2;
  if (*(void *)(result + 424))
  {
    uint64_t v4 = result;
    if (!*(_DWORD *)(result + 440))
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
      unsigned __int8 v12 = -86;
      __tp.int tv_sec = 0xAAAAAAAAAAAAAAAALL;
      __tp.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      if (__tp.tv_sec - *(void *)(v4 + 432) >= 601) {
        *a4 = 1;
      }
      sub_100029538(*(void *)(v4 + 424), &v13);
      unint64_t v7 = v13;
      uint64_t result = sub_1000398C8(*(void *)(v4 + 424));
      if (v7 <= 0x200000 / result)
      {
        LODWORD(__tp.tv_sec) = 8;
        unsigned int v10 = 9;
        uint64_t result = sub_100026464(*(void *)(v4 + 424), 0LL, &v14, (unsigned int *)&__tp, 8u, &v11, &v10, 0, 0, 0LL);
        if ((_DWORD)result == 2)
        {
          LOBYTE(v8) = *(_BYTE *)(v4 + 464);
        }

        else
        {
          if ((_DWORD)result) {
            return result;
          }
          if (!v11) {
            return result;
          }
          int v8 = *(unsigned __int8 *)(v4 + 464);
          if (v12 == v8) {
            return result;
          }
        }

        if (a3 == -1LL) {
          unint64_t v9 = 0LL;
        }
        else {
          unint64_t v9 = a3;
        }
        unint64_t v11 = v9;
        unsigned __int8 v12 = v8;
        return sub_10001EADC(*(void *)(v4 + 424), 0LL, &v14, 8LL, &v11, 9LL, 0LL);
      }
    }
  }

  return result;
}

uint64_t sub_100041B20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  sub_10003CF10(a2, 2);
  if (*(void *)(a2 + 424))
  {
    v6.int tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v6.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v6);
    if (v6.tv_sec - *(void *)(a2 + 432) >= 601)
    {
      sub_100029238(*(void *)(a2 + 424), 0LL, 0LL);
      sub_100038824(*(void *)(a2 + 424));
      *(void *)(a2 + 424) = 0LL;
    }
  }

  if (v3)
  {
    if (*(void *)(v3 + 496)) {
      uint64_t v3 = *(void *)(v3 + 496);
    }
    uint64_t v4 = *(void *)(v3 + 3616);
    if (v4)
    {
      sub_100038824(v4);
      *(void *)(v3 + 3616) = 0LL;
    }
  }

  return sub_10003D514(a2, 2);
}

uint64_t sub_100041BD8(uint64_t a1, unint64_t a2, void *a3)
{
  BOOL v16 = 0LL;
  uint64_t v17 = 0LL;
  memset(v15, 170, sizeof(v15));
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = sub_100040DD8(a1, 0LL, 0LL, &v17);
  if ((_DWORD)v6)
  {
    uint64_t v7 = v6;
    if (sub_100037DC8(a1) == 13) {
      sub_100013D94( "%s:%d: %s unable to get omap: %d\n",  "omap_find_next_snapshot_xid",  1150,  (const char *)(a1 + 3992),  v7);
    }
    else {
      sub_100013D94( "%s:%d: %s unable to get omap: %d\n",  "omap_find_next_snapshot_xid",  1150,  (const char *)(*(void *)(a1 + 384) + 208LL),  v7);
    }
    return v7;
  }

  uint64_t v8 = *((void *)v17 + 47);
  sub_10003CF10((uint64_t)v17, 1);
  if ((*(_BYTE *)(v8 + 32) & 1) == 0)
  {
    unint64_t v9 = *(void *)(v8 + 56);
    if (v9)
    {
      int v10 = *(_DWORD *)(v8 + 44);
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      uint64_t v24 = 0LL;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v21 = 0u;
      uint64_t v18 = sub_10003F2E8;
      DWORD2(v19) = 19;
      if ((unsigned __int16)v10 == 2)
      {
        uint64_t v7 = sub_100027CC4(a1, v10 & 0xFFFF0000, v9, 0LL, 0, (uint64_t)&v18, 0LL, &v16);
        if (!(_DWORD)v7)
        {
          unint64_t v14 = a2;
          do
          {
            v15[0] = 0x800000010LL;
            uint64_t v11 = sub_100026464( (uint64_t)v16,  0LL,  &v14,  (unsigned int *)v15 + 1,  8u,  &v15[1],  (unsigned int *)v15,  4u,  0,  0LL);
            if ((_DWORD)v11) {
              BOOL v12 = 1;
            }
            else {
              BOOL v12 = (v15[1] & 1) == 0;
            }
          }

          while (!v12);
          uint64_t v7 = v11;
          if (!(_DWORD)v11)
          {
            *a3 = v14;
            goto LABEL_20;
          }

          if ((_DWORD)v11 != 2)
          {
            sub_100037DC8(a1);
            sub_100013D94("%s:%d: %s error searching snapshot tree: %d\n");
            goto LABEL_20;
          }

          goto LABEL_16;
        }
      }

      else
      {
        uint64_t v7 = 22LL;
      }

      sub_100037DC8(a1);
      sub_100013D94("%s:%d: %s unable to get snapshot tree: %d\n");
      goto LABEL_20;
    }
  }

uint64_t sub_100041E64(void *a1, void *a2, uint64_t a3)
{
  else {
    uint64_t v6 = 0LL;
  }
  if (v6)
  {
    uint64_t v7 = *(void **)(v6 + 392);
    uint64_t result = sub_10003CF9C(a1, 0, a3);
    if ((_DWORD)result) {
      return result;
    }
    unint64_t v9 = (pthread_mutex_t *)(v6 + 1144);
  }

  else
  {
    uint64_t result = sub_10003CF9C(a1, 0, a3);
    if ((_DWORD)result) {
      return result;
    }
    unint64_t v9 = (pthread_mutex_t *)(a1 + 82);
    uint64_t v7 = a1;
  }

  pthread_mutex_lock(v9);
  uint64_t v10 = sub_10003965C((uint64_t)a2);
  unsigned int v11 = sub_100037DC0((uint64_t)a2);
  if (!sub_10003CF9C(a2, (v11 >> 29) & 2, a3) && sub_10003965C((uint64_t)a2) != v10)
  {
    uint64_t v13 = sub_10003965C((uint64_t)a2);
    if (v6)
    {
      *(void *)(*(void *)(v6 + 376) + 128LL) = v13;
      sub_10001AAF0(v6, a3);
      goto LABEL_12;
    }

    *(void *)(v7[47] + 160LL) = v13;
    sub_10003E644((uint64_t)a1, a3, 0LL);
LABEL_16:
    BOOL v12 = (pthread_mutex_t *)(v7 + 82);
    goto LABEL_17;
  }

  if (!v6) {
    goto LABEL_16;
  }
LABEL_12:
  BOOL v12 = (pthread_mutex_t *)(v6 + 1144);
LABEL_17:
  pthread_mutex_unlock(v12);
  return 0LL;
}

uint64_t sub_100041F78(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  if (!a3) {
    return 22LL;
  }
  uint64_t v3 = *(void *)a3;
  uint64_t v4 = *(void *)(*(void *)a3 + 16LL);
  if (!v4) {
    return 22LL;
  }
  uint64_t v5 = *(void *)(v3 + 128);
  if (!v5) {
    return 22LL;
  }
  int v6 = a3[2] | 1;
  *(void *)(a1 + 336) = 0x9D800000001LL;
  *(_DWORD *)(a1 + 32) = *(void *)(v3 + 8);
  *(int32x2_t *)(a1 + 36) = vmovn_s64(*(int64x2_t *)(v3 + 80));
  *(_DWORD *)(a1 + 44) = *(void *)(v3 + 96);
  uint64_t v7 = *(void *)(v3 + 24);
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 56) = v7;
  int v8 = *(_DWORD *)(v3 + 32);
  int v9 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(a1 + 64) = v8;
  *(_DWORD *)(a1 + 68) = v9;
  *(void *)(a1 + 72) = v4;
  __int128 v10 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(a1 + 96) = v10;
  uint64_t v11 = *(void *)(v3 + 64);
  uint64_t v12 = *(void *)(v3 + 72);
  *(_DWORD *)(a1 + 112) = v11;
  *(_DWORD *)(a1 + 116) = v12;
  *(void *)(a1 + 120) = v10;
  *(void *)(a1 + 152) = *(void *)(v3 + 104);
  uint64_t v13 = *(void *)(v3 + 120);
  *(_DWORD *)(a1 + 144) = v6;
  *(_DWORD *)(a1 + 148) = v13;
  uint64_t v14 = *(void *)(v3 + 152);
  *(_WORD *)(a1 + 224) = *(void *)(v3 + 144);
  int v15 = *(_DWORD *)(v3 + 112);
  *(_DWORD *)(a1 + 160) = v15;
  *(_DWORD *)(a1 + 164) = v5;
  *(_WORD *)(a1 + 264) = v14;
  *(_WORD *)(a1 + 304) = *(void *)(v3 + 160);
  *(_DWORD *)(a1 + 324) = 2520;
  int v16 = 8 * v15 + 2520;
  *(_DWORD *)(a1 + 328) = v16;
  uint64_t v17 = ((2 * v15 + 6) & 0xFFFFFFF8) + v16;
  *(_DWORD *)(a1 + 332) = v17;
  uint64_t v18 = a1 + v17;
  *(_WORD *)(a1 + 322) = v5 - 1;
  *(_WORD *)(a1 + 320) = 0;
  uint64_t v19 = (v5 & 0x7FFFFFFF) - 1;
  if ((v5 & 0x7FFFFFFF) == 1)
  {
    uint64_t v19 = 0LL;
  }

  else
  {
    uint64_t v20 = 0LL;
    do
    {
      *(_WORD *)(v18 + 2 * v20) = v20 + 1;
      ++v20;
    }

    while (v19 != v20);
  }

  *(_WORD *)(v18 + 2 * v19) = -1;
  int v22 = v17 + ((2 * v5 + 6) & 0xFFFFFFF8);
  *(_DWORD *)(a1 + 80) = v22;
  if (v9) {
    int v8 = v9;
  }
  uint64_t v23 = (v22 + 8 * v8);
  *(_DWORD *)(a1 + 128) = v23;
  if ((_DWORD)v12) {
    unsigned int v24 = v12;
  }
  else {
    unsigned int v24 = v11;
  }
  else {
    return 22LL;
  }
}

uint64_t sub_1000420D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(void *)(*(void *)a1 + 392LL);
  unint64_t v78 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v76 = v4;
  __int128 v77 = v4;
  __int128 v74 = v4;
  __int128 v75 = v4;
  __int128 v72 = v4;
  __int128 v73 = v4;
  __int128 v70 = v4;
  __int128 v71 = v4;
  __int128 v68 = v4;
  __int128 v69 = v4;
  __int128 v66 = v4;
  __int128 v67 = v4;
  __int128 v65 = v4;
  unsigned int v5 = *(_DWORD *)(v2 + 32);
  uint64_t v6 = *(void *)(v3 + 376);
  int v7 = *(_DWORD *)(v6 + 36);
  if (*(_BYTE *)(v3 + 624))
  {
    if (v5 == v7) {
      goto LABEL_3;
    }
LABEL_9:
    uint64_t v11 = v3;
    goto LABEL_10;
  }

  if (*(void *)(v2 + 96) + *(void *)(v2 + 48) != *(void *)(v6 + 40) || v5 != v7) {
    goto LABEL_9;
  }
LABEL_3:
  unsigned int v8 = 336;
  if ((*(_BYTE *)(v2 + 144) & 1) != 0)
  {
    if (*(_DWORD *)(v2 + 336)) {
      unsigned int v13 = 2520;
    }
    else {
      unsigned int v13 = 336;
    }
    unsigned int v14 = *(_DWORD *)(v2 + 340);
    if (*(_DWORD *)(v2 + 336)) {
      int v15 = 1;
    }
    else {
      int v15 = 2;
    }
    if (v14 <= v13) {
      unsigned int v8 = v13;
    }
    else {
      unsigned int v8 = *(_DWORD *)(v2 + 340);
    }
    if (v14 >= v13) {
      BOOL v9 = *(_DWORD *)(v2 + 336) == 0;
    }
    else {
      BOOL v9 = v15;
    }
  }

  else
  {
    BOOL v9 = 0;
  }

  unsigned int v16 = *(_DWORD *)(a1 + 48);
  uint64_t v17 = sub_10001007C(v5, *(void *)(v2 + 48), *(void *)(v2 + 96), *(_DWORD *)(v6 + 180), (uint64_t)&v65);
  if ((_DWORD)v17) {
    return v17;
  }
  if (v8 < v16) {
    int v18 = v9;
  }
  else {
    int v18 = v9 + 1;
  }
  if (*(_DWORD *)(v2 + 36) != (_DWORD)v70) {
    ++v18;
  }
  if (*(_DWORD *)(v2 + 40) != DWORD2(v70)) {
    ++v18;
  }
  if (*(_DWORD *)(v2 + 44) != (_DWORD)v71) {
    ++v18;
  }
  unint64_t v19 = *(void *)(v2 + 48);
  if (*(void *)(v2 + 56) != *((void *)&v66 + 1)) {
    ++v18;
  }
  unsigned int v20 = *(_DWORD *)(v2 + 64);
  uint64_t v21 = *(unsigned int *)(v2 + 68);
  if (v20 != (_DWORD)v67) {
    ++v18;
  }
  if ((_DWORD)v21 != DWORD2(v67) && *((void *)&v67 + 1) + v21 != 1) {
    ++v18;
  }
  if (*(void *)(v2 + 104) != *((void *)&v68 + 1)) {
    ++v18;
  }
  uint64_t v23 = *(unsigned int *)(v2 + 116);
  if (*(_DWORD *)(v2 + 112) != (_DWORD)v69) {
    ++v18;
  }
  if ((_DWORD)v23 != DWORD2(v69) && *((void *)&v69 + 1) + v23 != 1) {
    ++v18;
  }
  if ((*(void *)(v2 + 152) & 0x7FFFFFFFFFFFFFFFLL) != *((void *)&v71 + 1)) {
    ++v18;
  }
  uint64_t v25 = *(unsigned int *)(v2 + 160);
  if ((_DWORD)v25 != (_DWORD)v72) {
    ++v18;
  }
  unsigned int v26 = *(_DWORD *)(v2 + 164) & 0x7FFFFFFF;
  if (v26 > 0xFFFE) {
    ++v18;
  }
  if (*(_DWORD *)(v2 + 148) < 4u) {
    ++v18;
  }
  uint64_t v27 = *(unsigned int *)(v2 + 324);
  unint64_t v28 = *(unsigned int *)(v2 + 328);
  if (v27 + 8 * v25 > v28) {
    ++v18;
  }
  unint64_t v29 = *(unsigned int *)(v2 + 332);
  if (v28 + 2LL * (((_DWORD)v25 + 3) & 0xFFFFFFFC) > v29) {
    ++v18;
  }
  unint64_t v30 = *(unsigned int *)(v2 + 80);
  if (v29 + 2LL * ((v26 + 3) & 0xFFFFFFFC) > v30) {
    ++v18;
  }
  unint64_t v31 = *(unsigned int *)(v2 + 128);
  if ((_DWORD)v21) {
    unsigned int v20 = *(_DWORD *)(v2 + 68);
  }
  if (v30 + 8LL * v20 > v31) {
    ++v18;
  }
  if ((_DWORD)v23) {
    unsigned int v32 = *(_DWORD *)(v2 + 116);
  }
  else {
    unsigned int v32 = *(_DWORD *)(v2 + 112);
  }
  if (*(void *)(v2 + 72) > v19) {
    ++v18;
  }
  unint64_t v33 = *(void *)(v2 + 240);
  if (v33 < v19) {
    int v34 = v18;
  }
  else {
    int v34 = v18 + 1;
  }
  if (v33 && !*(void *)(v2 + 248)) {
    ++v34;
  }
  unint64_t v35 = *(void *)(v2 + 256);
  if (v35 <= sub_100039664(a1)) {
    int v36 = v34;
  }
  else {
    int v36 = v34 + 1;
  }
  unint64_t v37 = *(void *)(v2 + 96);
  unint64_t v38 = *(void *)(v2 + 120);
  unint64_t v39 = *(void *)(v2 + 280);
  if (v37)
  {
    if (v38 > v37) {
      ++v36;
    }
    if (v39 < v37) {
      int v40 = v36;
    }
    else {
      int v40 = v36 + 1;
    }
    if (v39 && !*(void *)(v2 + 288)) {
      ++v40;
    }
    unint64_t v41 = *(void *)(v2 + 296);
    BOOL v42 = v41 > sub_100039664(a1);
  }

  else
  {
    if (v38) {
      ++v36;
    }
    if (v39) {
      int v43 = v36 + 1;
    }
    else {
      int v43 = v36;
    }
    if (*(void *)(v2 + 288)) {
      int v40 = v43 + 1;
    }
    else {
      int v40 = v43;
    }
    BOOL v42 = *(void *)(v2 + 296) != 0LL;
  }

  int v44 = v40 + v42;
  unsigned int v45 = *(unsigned __int16 *)(v2 + 320);
  unsigned int v46 = *(_DWORD *)(v2 + 164) & 0x7FFFFFFF;
  if (v45 != 0xFFFF && v46 <= v45) {
    ++v44;
  }
  unsigned int v48 = *(unsigned __int16 *)(v2 + 322);
  if (v48 != 0xFFFF && v46 <= v48) {
    ++v44;
  }
  if (*(void *)(v2 + 192) <= *(void *)(v2 + 184)) {
    int v50 = 0;
  }
  else {
    int v50 = -1;
  }
  if (v44 == v50)
  {
LABEL_130:
    *(void *)(a1 + 376) = v2;
    *(void *)(a1 + 864) = v2 + *(unsigned int *)(v2 + 324);
    *(void *)(a1 + 872) = v2 + *(unsigned int *)(v2 + 328);
    *(void *)(a1 + 880) = v2 + *(unsigned int *)(v2 + 332);
    *(void *)(a1 + 888) = v2 + *(unsigned int *)(v2 + 80);
    *(void *)(a1 + 896) = v2 + *(unsigned int *)(v2 + 128);
    *(void *)(a1 + 904) = 0LL;
    *(_OWORD *)(a1 + 992) = 0u;
    *(_WORD *)(a1 + 1528) = 8;
    *(void *)(a1 + 1512) = *(void *)(v2 + 48) >> 5;
    *(void *)(a1 + 1520) = *(void *)(v2 + 96) >> 5;
    if (*(_BYTE *)(v3 + 625))
    {
      *(_WORD *)(a1 + 1528) = 0;
    }

    else if ((*(_BYTE *)(*(void *)(v3 + 376) + 65LL) & 1) == 0)
    {
      if (*(_BYTE *)(v3 + 628))
      {
        *(_WORD *)(a1 + 1528) = 32;
      }

      else
      {
        LODWORD(v65) = 0;
        sub_100052018(*(void *)(v3 + 384));
        if ((v65 & 2) != 0)
        {
          *(_WORD *)(a1 + 1528) = 2;
          unint64_t v51 = 0x40000000u / *(_DWORD *)(v2 + 32);
          if (*(void *)(a1 + 1512) > v51) {
            *(void *)(a1 + 1512) = v51;
          }
          if (*(void *)(a1 + 1520) > v51) {
            *(void *)(a1 + 1520) = v51;
          }
        }
      }
    }

    if ((*(_BYTE *)(a1 + 16) & 0x40) != 0) {
      uint64_t v52 = 0LL;
    }
    else {
      uint64_t v52 = sub_100039664(a1);
    }
    uint64_t v53 = 0LL;
    *(void *)(a1 + 912) = v52;
    char v54 = 1;
    do
    {
      char v55 = v54;
      uint64_t v56 = v2 + 48 * v53;
      size_t v59 = *(void *)(v56 + 56);
      int v58 = (unint64_t *)(v56 + 56);
      size_t v57 = v59;
      if (v59)
      {
        unint64_t v60 = sub_100013EEC(v57, 4uLL);
        uint64_t v61 = a1 + 8 * v53;
        *(void *)(v61 + 1488) = v60;
        if (v60 && *v58)
        {
          unint64_t v62 = 0LL;
          int v63 = (void *)(v61 + 1488);
          do
          {
            *(_DWORD *)(*v63 + 4 * v62) = *(_DWORD *)(v2 + 36) & 0xFFFFFF | (*(unsigned __int8 *)(*v63 + 4 * v62 + 3) << 24);
            *(_BYTE *)(*v63 + 4 * v62++ + 3) = 3;
          }

          while (v62 < *v58);
        }
      }

      else
      {
        *(void *)(a1 + 8 * v53 + 1488) = 0LL;
      }

      char v54 = 0;
      uint64_t v53 = 1LL;
    }

    while ((v55 & 1) != 0);
    uint64_t v12 = sub_1000139BC((pthread_mutex_t *)(a1 + 384));
    if ((_DWORD)v12) {
      goto LABEL_166;
    }
    uint64_t v12 = sub_1000139BC((pthread_mutex_t *)(a1 + 448));
    if (!(_DWORD)v12)
    {
      uint64_t v12 = sub_1000139BC((pthread_mutex_t *)(a1 + 512));
      if (!(_DWORD)v12)
      {
        uint64_t v12 = sub_1000139BC((pthread_mutex_t *)(a1 + 576));
        if (!(_DWORD)v12)
        {
          uint64_t v12 = sub_1000139BC((pthread_mutex_t *)(a1 + 640));
          if (!(_DWORD)v12)
          {
            uint64_t v12 = sub_1000139BC((pthread_mutex_t *)(a1 + 704));
            if (!(_DWORD)v12)
            {
              uint64_t v12 = sub_1000139D4((pthread_cond_t *)(a1 + 768));
              if (!(_DWORD)v12)
              {
LABEL_166:
                *(void *)(a1 + 1584) = sub_100013EEC(1uLL, 0xF8uLL);
                return v12;
              }

              j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 704));
            }

            j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 640));
          }

          j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 576));
        }

        j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 512));
      }

      j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 448));
    }

    j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 384));
    goto LABEL_166;
  }

  uint64_t v11 = v3;
LABEL_10:
  uint64_t v12 = sub_100005194(v11);
  if (!(_DWORD)v12) {
    goto LABEL_130;
  }
  return v12;
}

uint64_t sub_100042734(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 1600);
  if (v2) {
    sub_100014004(v2, 16LL * *(unsigned int *)(a1 + 1592));
  }
  uint64_t v3 = *(void **)(a1 + 1584);
  if (v3) {
    sub_100014004(v3, 248LL);
  }
  __int128 v4 = *(void **)(a1 + 1536);
  if (v4) {
    sub_100014004(v4, 16LL * *(unsigned __int16 *)(a1 + 1530));
  }
  sub_100031844(a1);
  uint64_t v5 = *(void *)(a1 + 1568);
  if (v5)
  {
    sub_10002B150(v5);
    sub_100014004(*(void **)(a1 + 1568), 1368LL);
  }

  uint64_t v6 = *(void *)(a1 + 1576);
  if (v6)
  {
    sub_10002B150(v6);
    sub_100014004(*(void **)(a1 + 1576), 1368LL);
  }

  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 384));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 448));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 512));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 576));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 640));
  j__pthread_mutex_destroy((pthread_mutex_t *)(a1 + 704));
  sub_1000139DC((pthread_cond_t *)(a1 + 768));
  return 0LL;
}

uint64_t sub_100042824(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[7];
  int v5 = sub_1000398C8((uint64_t)a1);
  uint64_t v6 = *(void *)(*a1 + 392LL);
  int v7 = *(_DWORD *)(*(void *)(v6 + 376) + 36LL);
  BOOL v8 = v5 != v7;
  if (a2)
  {
    uint64_t v9 = *a2;
    unsigned int v11 = *((_DWORD *)a2 + 2);
    int v10 = *((_DWORD *)a2 + 3);
    if (v5 == v7) {
      int v12 = 1;
    }
    else {
      int v12 = 2;
    }
    if (*(_DWORD *)(v4 + 32) != v10) {
      BOOL v8 = v12;
    }
    int v13 = v10 == *(_DWORD *)(v9 + 48LL * v11 + 68) - 1
        ? *(_DWORD *)(v9 + 48LL * v11 + 64) - *(_DWORD *)(v9 + 44) * v10
        : *(_DWORD *)(v9 + 44);
    if (*(_DWORD *)(v4 + 36) != v13) {
      return sub_100005194(v6);
    }
  }

  if (v8) {
    return sub_100005194(v6);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000428F4(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[7];
  int v5 = sub_1000398C8((uint64_t)a1);
  uint64_t v6 = *(void *)(*a1 + 392LL);
  int v7 = *(_DWORD *)(*(void *)(v6 + 376) + 36LL);
  BOOL v8 = v5 != v7;
  if (a2)
  {
    uint64_t v9 = *a2;
    unsigned int v11 = *((_DWORD *)a2 + 2);
    int v10 = *((_DWORD *)a2 + 3);
    if (v5 == v7) {
      int v12 = 1;
    }
    else {
      int v12 = 2;
    }
    if (*(_DWORD *)(v4 + 32) != v10) {
      BOOL v8 = v12;
    }
    if (v10 == *(_DWORD *)(v9 + 48LL * v11 + 64) - 1)
    {
      if (*(_DWORD *)(v4 + 36) != *(_DWORD *)(v9 + 48LL * v11 + 56) - *(_DWORD *)(v9 + 40) * v10) {
        return sub_100005194(v6);
      }
    }

    else if (*(_DWORD *)(v4 + 36) != *(_DWORD *)(v9 + 40))
    {
      return sub_100005194(v6);
    }
  }

  if (v8) {
    return sub_100005194(v6);
  }
  return 0LL;
}

uint64_t sub_1000429D4(uint64_t a1, int64_t a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v10 = *(void *)(a1 + 384);
  memset(v116, 170, sizeof(v116));
  uint64_t v110 = 0LL;
  unsigned int v111 = a3;
  __int16 v109 = 0;
  *a5 = 0LL;
  unint64_t v117 = 0LL;
  uint64_t v113 = 0LL;
  uint64_t v112 = 0LL;
  uint64_t v114 = 64LL;
  unsigned int v11 = (char *)sub_100014044(0x400uLL);
  uint64_t v115 = v11;
  if (!v11)
  {
    uint64_t v13 = 12LL;
    goto LABEL_86;
  }

  if (!a3)
  {
    uint64_t v112 = *(void *)(a2 + 16);
    uint64_t v113 = 1LL;
  }

  uint64_t v12 = *(void *)(a1 + 376);
  if ((*(_BYTE *)(v12 + 65) & 1) != 0)
  {
    v116[0] = *(void *)(a2 + 208);
    uint64_t v13 = sub_10004355C((uint64_t)v11, (uint64_t)&v111, v116[0], (unint64_t *)(v12 + 1368), 0LL);
    if ((_DWORD)v13) {
      goto LABEL_84;
    }
    uint64_t v83 = *(void *)(a1 + 376);
    if (((*(void *)(v83 + 1368) << __clz(__rbit64(*(unsigned int *)(v83 + 36)))) & 0x4000000000000000LL) != 0)
    {
      sub_100013D94( "%s:%d: %s WBC area was not allocated on main device\n",  "spaceman_create",  950,  (const char *)(*(void *)(a1 + 384) + 208LL));
      uint64_t v13 = 0LL;
      goto LABEL_84;
    }

    *(void *)(v83 + 1376) = v116[0];
  }

  LODWORD(v116[2]) = 0;
  v116[1] = a2;
  uint64_t v13 = sub_100039908( *(pthread_mutex_t **)(a1 + 392),  0x80000000,  0LL,  (uint64_t)&xmmword_10005BA44,  (uint64_t)&v116[1],  *(unsigned int *)(a2 + 136),  a4,  (uint64_t *)&v117);
  if ((_DWORD)v13) {
    goto LABEL_84;
  }
  sub_10003E644((uint64_t)v117, a4, 0LL);
  uint64_t v14 = v117[47];
  *a5 = v117[14];
  uint64_t v15 = *(void *)(a1 + 376);
  v116[0] = *(unsigned int *)(v15 + 104);
  uint64_t v13 = sub_1000135A8( a1,  (uint64_t (*)(uint64_t, uint64_t, int64_t, unint64_t *, int64_t *))sub_10004355C,  (uint64_t)&v111,  (unint64_t *)(v15 + 112),  v116,  0);
  if ((_DWORD)v13) {
    goto LABEL_84;
  }
  uint64_t v16 = *(void *)(a1 + 376);
  *(_DWORD *)(v16 + 104) = v116[0];
  v116[0] = *(unsigned int *)(v16 + 108);
  uint64_t v13 = sub_1000135A8( a1,  (uint64_t (*)(uint64_t, uint64_t, int64_t, unint64_t *, int64_t *))sub_10004355C,  (uint64_t)&v111,  (unint64_t *)(v16 + 120),  v116,  0);
  if ((_DWORD)v13
    || (*(_DWORD *)(*(void *)(a1 + 376) + 108LL) = v116[0],
        v116[0] = *(unsigned int *)(v14 + 164),
        uint64_t v13 = sub_1000135A8( a1,  (uint64_t (*)(uint64_t, uint64_t, int64_t, unint64_t *, int64_t *))sub_10004355C,  (uint64_t)&v111,  (unint64_t *)(v14 + 168),  v116,  0),  (_DWORD)v13)
    || (*(_DWORD *)(v14 + 164) = v116[0],
        v116[0] = *(void *)(v14 + 152),
        uint64_t v13 = sub_1000135A8( a1,  (uint64_t (*)(uint64_t, uint64_t, int64_t, unint64_t *, int64_t *))sub_10004355C,  (uint64_t)&v111,  (unint64_t *)(v14 + 176),  v116,  1),  (_DWORD)v13))
  {
LABEL_84:
    if (v115) {
      sub_100014004(v115, 16LL * v114);
    }
LABEL_86:
    uint64_t v84 = v117;
    if ((_DWORD)v13 && v117)
    {
      sub_10003B238(v117, a4);
    }

    else if (v117)
    {
      *a5 = v117[14];
      sub_100038824(v84);
      return v13;
    }

    *a5 = 0LL;
    return v13;
  }

  unint64_t v108 = (int *)v14;
  *(void *)(v14 + 152) = v116[0];
  if (!v111 || !v111[2] || !HIDWORD(v114))
  {
LABEL_16:
    unsigned int v20 = sub_100014044(v108[8]);
    uint64_t v21 = sub_100014044(v108[8]);
    uint64_t v13 = 12LL;
    uint64_t v104 = (uint64_t)v21;
    unsigned int v100 = sub_100014044(v108[8]);
    if (v100)
    {
      int v22 = v21;
      if (v21 && v20)
      {
        bzero(v20, v108[8]);
        uint64_t v25 = v108;
        if (v108[40])
        {
          unint64_t v26 = 0LL;
          while (1)
          {
            uint64_t v27 = v25;
            unint64_t v28 = v117;
            *(void *)(v117[108] + 8 * v26) = a4;
            uint64_t v29 = sub_1000436C4(a1, (uint64_t)v28, a4, &v110, &v109);
            if ((_DWORD)v29)
            {
              uint64_t v13 = v29;
              sub_100013D94("%s:%d: %s failed to allocate bitmap block from IP bitmap pool: %d\n");
              goto LABEL_104;
            }

            *(_WORD *)(v117[109] + 2 * v26) = v109;
            uint64_t v30 = sub_100051F74(v10, v110);
            if ((_DWORD)v30) {
              break;
            }
            ++v26;
            uint64_t v25 = v27;
          }

          uint64_t v13 = v30;
        }

        else
        {
LABEL_24:
          uint64_t v31 = 0LL;
          uint64_t v32 = (uint64_t)v100;
          uint64_t v95 = (uint64_t)v20;
          uint64_t v33 = 0xFFFFFFFFLL;
          char v34 = 1;
          do
          {
            char v92 = v34;
            unsigned int v96 = (unsigned int *)&v25[12 * v31 + 16];
            if (*v96)
            {
              unsigned int v35 = 0;
              unsigned int v98 = &v25[12 * v31 + 17];
              uint64_t v101 = v31;
              do
              {
                if (*v98)
                {
                  unsigned int v36 = v25[11];
                  if (v35 / v36 != (_DWORD)v33)
                  {
                    if ((_DWORD)v33 == -1)
                    {
                      uint64_t v39 = v35 / v36;
                    }

                    else
                    {
                      unint64_t v37 = v25;
                      sub_10003E984(a1, v32, v25[8], v23, v24);
                      uint64_t v38 = sub_100051F74(v10, *(void *)(v117[v101 + 111] + 8LL * v33));
                      if ((_DWORD)v38)
                      {
                        uint64_t v13 = v38;
                        sub_100013D94("%s:%d: %s failed to write cab %d: %d\n");
                        goto LABEL_103;
                      }

                      uint64_t v39 = v35 / v37[11];
                      LODWORD(v31) = v101;
                    }

                    uint64_t v33 = v39;
                    uint64_t v42 = sub_1000437A4(a1, (uint64_t)v117, v31, v39, v32, a4);
                    if ((_DWORD)v42)
                    {
                      uint64_t v86 = v42;
                      sub_100013D94( "%s:%d: %s failed to initialize cab %d: %d\n",  "spaceman_create",  1061,  (const char *)(*(void *)(a1 + 384) + 208LL),  v33,  v42);
                      uint64_t v13 = v86;
                      goto LABEL_103;
                    }

                    unsigned int v36 = v108[11];
                    LODWORD(v31) = v101;
                  }

                  uint64_t v105 = v33;
                  unsigned int v102 = v35 - v36 * v33;
                  ++*(_DWORD *)(v32 + 36);
                  int v40 = v117;
                  uint64_t v41 = (uint64_t)(v100 + 5);
                }

                else
                {
                  uint64_t v105 = v33;
                  int v40 = v117;
                  uint64_t v41 = v117[v31 + 111];
                  unsigned int v102 = v35;
                }

                uint64_t v43 = sub_100043874(a1, (uint64_t)v40, v31, v35, v104, a4, &v116[3]);
                if ((_DWORD)v43)
                {
                  uint64_t v13 = v43;
                  sub_100013D94( "%s:%d: %s failed to initialize cib %d: %d\n",  "spaceman_create",  1076,  (const char *)(*(void *)(a1 + 384) + 208LL),  v35,  v43);
                  unsigned int v20 = (void *)v95;
                  int v22 = (void *)v104;
                  goto LABEL_105;
                }

                *(void *)(v41 + 8LL * v102) = v116[3];
                sub_10003E984(a1, v104, v108[8], v44, v45);
                uint64_t v46 = sub_100051F74(v10, *(void *)(v41 + 8LL * v102));
                if ((_DWORD)v46)
                {
                  uint64_t v13 = v46;
                  sub_100013D94("%s:%d: %s failed to write cib %d: %d\n");
                  goto LABEL_103;
                }

                ++v35;
                uint64_t v33 = v105;
                uint64_t v25 = v108;
                uint64_t v32 = (uint64_t)v100;
                uint64_t v31 = v101;
              }

              while (v35 < *v96);
            }

            uint64_t v106 = v33;
            unsigned int v20 = (void *)v95;
            if (v25[12 * v31 + 17])
            {
              uint64_t v47 = v31;
              sub_10003E984(a1, v32, v25[8], v23, v24);
              uint64_t v48 = sub_100051F74(v10, *(void *)(v117[v47 + 111] + 8LL * v106));
              uint64_t v25 = v108;
              if ((_DWORD)v48)
              {
                uint64_t v13 = v48;
                sub_100013D94("%s:%d: %s failed to write cab %d: %d\n");
                goto LABEL_104;
              }
            }

            char v34 = 0;
            uint64_t v31 = 1LL;
            uint64_t v33 = v106;
          }

          while ((v92 & 1) != 0);
          if (a3)
          {
            uint64_t v13 = 0LL;
            uint64_t v49 = 0LL;
            char v50 = 1;
            do
            {
              if (!(_DWORD)v13)
              {
                unint64_t v51 = 0LL;
                char v103 = v50;
                uint64_t v52 = &v108[12 * v49];
                uint64_t v53 = (unsigned int *)(v52 + 16);
                char v54 = v52 + 17;
                char v55 = (uint64_t *)(v52 + 18);
                int v56 = -1;
                unsigned int v93 = v52 + 17;
                unint64_t v94 = (unsigned int *)(v52 + 16);
                while (2)
                {
                  if (v51 >= *v53)
                  {
                    uint64_t v13 = 0LL;
                  }

                  else
                  {
                    unint64_t v107 = v51;
                    if (*v54)
                    {
                      unsigned int v57 = v108[11];
                      unsigned int v58 = v51 / v57;
                      if (v51 / v57 != v56)
                      {
                        unint64_t v59 = sub_100051DF4(v10, *(void *)(v117[v49 + 111] + 8LL * v58));
                        if ((_DWORD)v59 || (unint64_t v59 = sub_100005224(v100, v108[8], v60, v61), (_DWORD)v59))
                        {
                          uint64_t v13 = v59;
                          sub_100013D94("%s:%d: %s failed to read cab %d: %d\n");
                          goto LABEL_103;
                        }

                        LODWORD(v51) = v107;
                        unsigned int v57 = v108[11];
                        int v56 = v58;
                      }

                      int v99 = v56;
                      unint64_t v62 = &v100[v51 - v57 * v56 + 5];
                    }

                    else
                    {
                      int v99 = v56;
                      unint64_t v62 = (uint64_t *)(v117[v49 + 111] + 8 * v51);
                    }

                    uint64_t v97 = *v62;
                    unint64_t v63 = sub_100051DF4(*(void *)(a1 + 384), *v62);
                    if ((_DWORD)v63 || (unint64_t v63 = sub_100005224((void *)v104, v108[8], v64, v65), (_DWORD)v63))
                    {
                      uint64_t v13 = v63;
                      sub_100013D94( "%s:%d: %s failed to read cib %d: %d\n",  "spaceman_create",  1129,  (const char *)(*(void *)(a1 + 384) + 208LL),  v107,  v63);
LABEL_74:
                      char v50 = v103;
                    }

                    else
                    {
                      unint64_t v68 = 0LL;
                      while (v68 < *(unsigned int *)(v104 + 36))
                      {
                        uint64_t v69 = ((uint64_t (*)(void, uint64_t, unint64_t, void, uint64_t))a3[3])( *a3,  v49,  *(void *)(v104 + 32 * v68 + 48)
                              / (unint64_t)(8 * v108[8])
                              * v108[8],
                                v108[8],
                                v95);
                        if ((_DWORD)v69) {
                          goto LABEL_73;
                        }
                        unint64_t v70 = v104 + 32 * v68;
                        unint64_t v71 = *(_DWORD *)(v70 + 56) & 0xFFFFF;
                        if ((_DWORD)v71)
                        {
                          unint64_t v72 = 0LL;
                          int v73 = *(_DWORD *)(v70 + 60);
                          uint64_t v74 = *v55;
                          __int128 v75 = (int8x8_t *)v95;
                          do
                          {
                            int8x8_t v76 = *v75++;
                            uint8x8_t v77 = (uint8x8_t)vcnt_s8(v76);
                            v77.i16[0] = vaddlv_u8(v77);
                            v73 -= v77.i32[0];
                            v74 -= v77.u32[0];
                            uint64_t *v55 = v74;
                            v72 += 64LL;
                          }

                          while (v72 < v71);
                          *(_DWORD *)(v70 + 60) = v73;
                        }

                        uint64_t v80 = *(void *)(v70 + 64);
                        uint64_t v79 = (void *)(v70 + 64);
                        uint64_t v78 = v80;
                        if (!v80)
                        {
                          uint64_t v81 = sub_1000439F4(a1, (uint64_t)v117, a4, (unint64_t *)&v116[3]);
                          if ((_DWORD)v81)
                          {
                            uint64_t v13 = v81;
                            sub_100013D94( "%s:%d: %s failed to allocate block from internal pool: %d\n",  "spaceman_create",  1155,  (const char *)(*(void *)(a1 + 384) + 208LL),  v81);
                            goto LABEL_74;
                          }

                          uint64_t v78 = v116[3];
                          *uint64_t v79 = v116[3];
                        }

                        uint64_t v69 = sub_100051F74(v10, v78);
                        ++v68;
                        if ((_DWORD)v69)
                        {
LABEL_73:
                          uint64_t v13 = v69;
                          goto LABEL_74;
                        }
                      }

                      sub_10003E984(a1, v104, v108[8], v66, v67);
                      uint64_t v13 = sub_100051F74(v10, v97);
                      unint64_t v51 = v107 + 1;
                      char v50 = v103;
                      char v54 = v93;
                      uint64_t v53 = v94;
                      int v56 = v99;
                      if (!(_DWORD)v13) {
                        continue;
                      }
                    }
                  }

                  break;
                }
              }

              char v82 = v50 & (*(void *)(a2 + 48) != 0LL);
              uint64_t v49 = 1LL;
              char v50 = 0;
            }

            while ((v82 & 1) != 0);
            unsigned int v20 = (void *)v95;
            int v22 = (void *)v104;
            if ((_DWORD)v13) {
              goto LABEL_105;
            }
          }

          uint64_t v87 = sub_100043D68(a1, (uint64_t)v117, v10, 0LL, 1uLL, a4);
          int v22 = (void *)v104;
          uint64_t v13 = v87;
          if ((_DWORD)v87) {
            goto LABEL_105;
          }
          uint64_t v88 = *(void *)(a1 + 376);
          if ((*(_BYTE *)(v88 + 65) & 1) != 0)
          {
            uint64_t v89 = sub_100043D68( a1,  (uint64_t)v117,  v10,  0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v88 + 36))),  1uLL,  a4);
            int v22 = (void *)v104;
            uint64_t v13 = v89;
            if ((_DWORD)v89) {
              goto LABEL_105;
            }
          }

          if (HIDWORD(v114))
          {
            uint64_t v90 = 0LL;
            unint64_t v91 = 0LL;
            unsigned int v20 = (void *)v95;
            while (1)
            {
              uint64_t v13 = sub_100043D68(a1, (uint64_t)v117, v10, *(void *)&v115[v90], *(void *)&v115[v90 + 8], a4);
              if ((_DWORD)v13) {
                break;
              }
              ++v91;
              v90 += 16LL;
              int v22 = (void *)v104;
              if (v91 >= HIDWORD(v114)) {
                goto LABEL_105;
              }
            }
          }

          else
          {
            uint64_t v13 = 0LL;
          }

LABEL_103:
          unsigned int v20 = (void *)v95;
        }

LABEL_104:
        int v22 = (void *)v104;
      }
    }

    else
    {
      int v22 = v21;
    }

LABEL_105:
    if (v100)
    {
      sub_100014004(v100, v108[8]);
      int v22 = (void *)v104;
    }

    if (v22) {
      sub_100014004(v22, v108[8]);
    }
    if (v20) {
      sub_100014004(v20, v108[8]);
    }
    goto LABEL_84;
  }

  uint64_t v17 = 0LL;
  unint64_t v18 = 0LL;
  while (1)
  {
    uint64_t v19 = ((uint64_t (*)(void, void, void))v111[2])( *v111,  *(void *)&v115[v17],  *(void *)&v115[v17 + 8]);
    if ((_DWORD)v19) {
      return v19;
    }
    ++v18;
    v17 += 16LL;
    if (v18 >= HIDWORD(v114)) {
      goto LABEL_16;
    }
  }

uint64_t sub_10004355C( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v7 = a3;
  unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  if (*(void *)a2)
  {
    uint64_t result = (*(uint64_t (**)(void, unint64_t, unint64_t *, unint64_t *))(*(void *)a2 + 8LL))( **(void **)a2,  a3,  &v23,  a5);
    if ((_DWORD)result) {
      return result;
    }
    if (a5) {
      unint64_t v7 = *a5;
    }
  }

  else
  {
    uint64_t v11 = *(void *)(a2 + 8);
    unint64_t v10 = *(void *)(a2 + 16);
    unint64_t v23 = v10;
    if (v11 - v10 < a3) {
      return 28LL;
    }
    if (a5)
    {
      *a5 = a3;
      unint64_t v10 = *(void *)(a2 + 16);
    }

    *(void *)(a2 + 16) = v10 + a3;
  }

  unint64_t v12 = v23;
  *a4 = v23;
  unsigned int v13 = *(_DWORD *)(a2 + 28);
  if (v13)
  {
    uint64_t v14 = (uint64_t *)(*(void *)(a2 + 32) + 16LL * (v13 - 1));
    uint64_t v15 = *v14;
    uint64_t v18 = v14[1];
    uint64_t v16 = v14 + 1;
    uint64_t v17 = v18;
    if (v12 == v18 + v15)
    {
      uint64_t result = 0LL;
      void *v16 = v17 + v7;
      return result;
    }
  }

  unsigned int v19 = *(_DWORD *)(a2 + 24);
  if (v13 >= v19)
  {
    uint64_t v21 = (char *)sub_100014044(16LL * (v19 + 64));
    if (!v21) {
      return 12LL;
    }
    unsigned int v20 = v21;
    memcpy(v21, *(const void **)(a2 + 32), 16LL * *(unsigned int *)(a2 + 24));
    bzero(&v20[16 * *(unsigned int *)(a2 + 24)], 0x400uLL);
    sub_100014004(*(void **)(a2 + 32), 16LL * *(unsigned int *)(a2 + 24));
    *(void *)(a2 + 32) = v20;
    unsigned int v13 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + 24) += 64;
    unint64_t v12 = v23;
  }

  else
  {
    unsigned int v20 = *(char **)(a2 + 32);
  }

  uint64_t result = 0LL;
  int v22 = (unint64_t *)&v20[16 * v13];
  *int v22 = v12;
  v22[1] = v7;
  *(_DWORD *)(a2 + 28) = v13 + 1;
  return result;
}

uint64_t sub_1000436C4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, _WORD *a5)
{
  uint64_t v5 = *(void *)(a2 + 376);
  uint64_t v6 = *(unsigned __int16 *)(v5 + 320);
  if (v6 == 0xFFFF) {
    return 28LL;
  }
  uint64_t v10 = *(void *)(a2 + 880);
  *(_WORD *)(v5 + 320) = *(_WORD *)(v10 + 2 * v6);
  *(_WORD *)(v10 + 2 * v6) = -1;
  sub_10003E644(a2, a3, 0LL);
  *a5 = v6;
  return sub_1000441FC(a1, v5, v6, a4);
}

uint64_t sub_1000437A4(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a2 + 376);
  unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_1000439F4(a1, a2, a6, &v17);
  uint64_t v14 = v13;
  if ((_DWORD)v13)
  {
    sub_100013D94( "%s:%d: %s failed to allocate block from internal pool: %d\n",  "spaceman_init_cab",  772,  (const char *)(*(void *)(a1 + 384) + 208LL),  v13);
  }

  else
  {
    unint64_t v15 = v17;
    *(void *)(*(void *)(a2 + 8LL * a3 + 888) + 8LL * a4) = v17;
    bzero((void *)a5, *(unsigned int *)(v12 + 32));
    *(void *)(a5 + 24) = 1073741830LL;
    *(void *)(a5 + 8) = v15;
    *(void *)(a5 + 16) = a6;
    *(_DWORD *)(a5 + 32) = a4;
  }

  return v14;
}

uint64_t sub_100043874(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v13 = *(unsigned int **)(a2 + 376);
  unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = sub_1000439F4(a1, a2, a6, &v29);
  uint64_t v15 = v14;
  if ((_DWORD)v14)
  {
    sub_100013D94( "%s:%d: %s failed to allocate block from internal pool: %d\n",  "spaceman_init_cib",  804,  (const char *)(*(void *)(a1 + 384) + 208LL),  v14);
    return v15;
  }

  unint64_t v16 = v29;
  *a7 = v29;
  bzero((void *)a5, v13[8]);
  *(void *)(a5 + 24) = 1073741831LL;
  *(void *)(a5 + 8) = v16;
  *(void *)(a5 + 16) = a6;
  *(_DWORD *)(a5 + 32) = a4;
  unint64_t v17 = &v13[12 * a3];
  if (v17[16] - 1 != a4)
  {
    LODWORD(v18) = v13[10];
LABEL_7:
    *(_DWORD *)(a5 + 36) = v18;
    if (!(_DWORD)v18) {
      return v15;
    }
    goto LABEL_8;
  }

  unint64_t v18 = v13[10];
  unint64_t v19 = *(void *)&v13[12 * a3 + 14] % v18;
  if (!v19) {
    goto LABEL_7;
  }
  *(_DWORD *)(a5 + 36) = v19;
  LODWORD(v18) = v19;
LABEL_8:
  unsigned int v20 = v17 + 12;
  unint64_t v21 = v13[9];
  unint64_t v22 = v13[10] * (unint64_t)a4;
  uint64_t v23 = v18;
  int8x16_t v24 = (void *)(a5 + 64);
  unint64_t v25 = v22 * v21;
  unint64_t v26 = ~v22 + *(void *)&v13[12 * a3 + 14];
  do
  {
    *(v24 - 3) = a6;
    *(v24 - 2) = v25;
    LODWORD(v27) = v21;
    if (!v26)
    {
      unint64_t v27 = *v20 % v21;
      if (!v27) {
        LODWORD(v27) = v21;
      }
    }

    *((_DWORD *)v24 - 2) = v27;
    *((_DWORD *)v24 - 1) = v27 & 0xFFFFF;
    *int8x16_t v24 = 0LL;
    v24 += 4;
    v25 += v21;
    --v26;
    --v23;
  }

  while (v23);
  return v15;
}

uint64_t sub_1000439F4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v6 = a1;
  uint64_t v7 = *(void *)(a2 + 376);
  unint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v38 = 0LL;
  uint64_t v35 = 0LL;
  uint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  if (!sub_10004E670(a1, a3)) {
    return 22LL;
  }
  int v8 = 8 * *(_DWORD *)(v7 + 32);
  if (!v8) {
    return 22LL;
  }
  unint64_t v26 = a4;
  unint64_t v27 = (pthread_mutex_t *)(a2 + 448);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 448));
  int v28 = v8;
  unint64_t v9 = v8;
  uint64_t v10 = a3;
  uint64_t v30 = v6;
  unint64_t v31 = v8;
LABEL_4:
  unsigned int v11 = 0;
  unint64_t v12 = *(void *)(a2 + 904);
  unint64_t v34 = 0LL;
  while (1)
  {
    uint64_t v13 = v7;
    unsigned int v14 = *(_DWORD *)(v7 + 160);
    if (v11 > v14)
    {
LABEL_34:
      uint64_t v7 = v13;
      if (sub_100044814(v6, a2, 0LL, 1LL, 0LL, v10)) {
        goto LABEL_4;
      }
      sub_100013D94( "%s:%d: %s unable to find free IP block or to free pending free IP blocks\n",  "spaceman_ip_block_alloc",  5100,  (const char *)(*(void *)(v6 + 384) + 208LL));
      uint64_t v24 = 28LL;
      goto LABEL_38;
    }

    unint64_t v15 = v12 / v9;
    unint64_t v32 = v12;
    if (v11 == v14)
    {
      uint64_t v7 = *(void *)(a2 + 904) % v9;
      if (!v7) {
        goto LABEL_34;
      }
    }

    else
    {
      LODWORD(v7) = v15 == v14 - 1
                  ? *(void *)(v7 + 152) - (*(void *)(v7 + 152) & 0x7FFFFFFFFFFFFFFFuLL) / v9 * v9
                  : v28;
    }

    unsigned int v16 = *(unsigned __int16 *)(*(void *)(a2 + 872) + 2 * v15);
    uint64_t v17 = sub_1000441FC(v6, v13, v16, &v36);
    if ((_DWORD)v17
      || (uint64_t v17 = sub_10003B574(*(void *)(v6 + 392), 1073741825LL, v36, &xmmword_10005BA74, 0LL, 0LL, 0LL, v10, &v38),
          (_DWORD)v17))
    {
      uint64_t v24 = v17;
      pthread_mutex_unlock(v27);
      return v24;
    }

    unint64_t v9 = v31;
    uint64_t v18 = *(void *)(v38 + 56);
    uint64_t v7 = v13;
    if (v31 + v15 * v31 >= (*(void *)(v13 + 152) & 0x7FFFFFFFFFFFFFFFuLL)) {
      unint64_t v12 = 0LL;
    }
    else {
      unint64_t v12 = v31 + v15 * v31;
    }
    uint64_t v10 = a3;
LABEL_32:
    sub_100038824(v38);
    ++v11;
    uint64_t v6 = v30;
    if (v34)
    {
      uint64_t v24 = 0LL;
LABEL_38:
      pthread_mutex_unlock(v27);
      *unint64_t v26 = v34;
      return v24;
    }
  }

  uint64_t v19 = v37;
  unint64_t v20 = v37 + v15 * v31;
  uint64_t v21 = *(void *)(v13 + 152);
  if ((v21 & 0x7FFFFFFFFFFFFFFFuLL) > v20)
  {
    uint64_t v7 = v13;
    if (v21 < 0)
    {
      uint64_t v22 = sub_100012C64(v30, *(void *)(v13 + 176), v20, &v34, 0LL);
      if ((_DWORD)v22) {
        goto LABEL_39;
      }
      uint64_t v19 = v37;
    }

    else
    {
      unint64_t v34 = *(void *)(v13 + 176) + v20;
    }

    sub_10001D318(v18, v19, 1LL);
    uint64_t v10 = a3;
    if (*(void *)(*(void *)(a2 + 864) + 8 * v15) != a3)
    {
      __int16 v33 = 0;
      uint64_t v22 = sub_1000436C4(v30, a2, a3, &v35, &v33);
      if ((_DWORD)v22 || (uint64_t v22 = sub_10004D9BC(v30, a2, v16, a3), (_DWORD)v22))
      {
LABEL_39:
        uint64_t v24 = v22;
        goto LABEL_41;
      }

      uint64_t v36 = v35;
      *(_WORD *)(*(void *)(a2 + 872) + 2 * v15) = v33;
      *(void *)(*(void *)(a2 + 864) + 8 * v15) = a3;
      uint64_t v7 = v13;
    }

    sub_10003E644(v38, a3, v36);
    unint64_t v9 = v31;
    unint64_t v23 = v15 * v31 + v37;
    if (v23 + 1 < (*(void *)(v7 + 152) & 0x7FFFFFFFFFFFFFFFuLL)) {
      unint64_t v12 = v23 + 1;
    }
    else {
      unint64_t v12 = 0LL;
    }
    *(void *)(a2 + 904) = v12;
    goto LABEL_32;
  }

  uint64_t v24 = 22LL;
LABEL_41:
  pthread_mutex_unlock(v27);
  sub_100038824(v38);
  return v24;
}

uint64_t sub_100043D68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(_DWORD **)(a2 + 376);
  char v7 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36LL)));
  uint64_t v8 = ((unint64_t)(a4 << v7) >> 62) & 1;
  uint64_t v9 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v7) & a4;
  unint64_t v10 = *(void *)&v6[12 * v8 + 12];
  BOOL v11 = v10 > v9;
  unint64_t v12 = v10 - v9;
  if (!v11 || v12 < a5) {
    return 22LL;
  }
  uint64_t v15 = a5;
  unsigned int v57 = &v6[12 * v8 + 17];
  if (*v57)
  {
    uint64_t v17 = sub_100014044(v6[8]);
    if (!v17) {
      return 12LL;
    }
  }

  else
  {
    uint64_t v17 = 0LL;
  }

  uint64_t v18 = sub_100014044(v6[8]);
  if (!v18) {
    return 12LL;
  }
  uint64_t v19 = (uint64_t)v18;
  unint64_t v20 = sub_100014044(v6[8]);
  if (!v20)
  {
    uint64_t v14 = 12LL;
    uint64_t v21 = (_DWORD *)v19;
    goto LABEL_54;
  }

  uint64_t v21 = v20;
  uint64_t v52 = v17;
  if (v15 < 1)
  {
    uint64_t v14 = 0LL;
    goto LABEL_51;
  }

  unint64_t v51 = (void *)(a2 + 8 * v8 + 888);
  unsigned int v60 = v8;
  uint64_t v22 = &v6[12 * v8 + 18];
  int v53 = -1;
  while (1)
  {
    unint64_t v23 = v9 / v6[9];
    unint64_t v24 = v23 / v6[10];
    int v55 = v24;
    if (!*v57)
    {
      uint64_t v30 = (uint64_t *)(*v51 + 8LL * v24);
      goto LABEL_21;
    }

    unsigned int v25 = v6[11];
    int v26 = v53;
LABEL_19:
    int v53 = v26;
    uint64_t v30 = &v52[v24 - v25 * v26 + 5];
LABEL_21:
    uint64_t v31 = *v30;
    unint64_t v32 = sub_100051DF4(a3, *v30);
    if ((_DWORD)v32 || (unint64_t v32 = sub_100005224((void *)v19, v6[8], v33, v34), (_DWORD)v32))
    {
      unint64_t v49 = v32;
      sub_100013D94( "%s:%d: %s failed to read cib %d: %d\n",  "spaceman_allocated",  1299,  (const char *)(*(void *)(a1 + 384) + 208LL),  v55,  v32);
      uint64_t v14 = v49;
      goto LABEL_51;
    }

    if (v15 < 1)
    {
      int v42 = 0;
    }

    else
    {
      uint64_t v56 = v31;
      unint64_t v37 = v23 % v6[10];
      while (v37 < *(unsigned int *)(v19 + 36))
      {
        unint64_t v38 = v19 + 32 * v37;
        uint64_t v41 = *(void *)(v38 + 64);
        int v40 = (uint64_t *)(v38 + 64);
        uint64_t v39 = v41;
        if (v41)
        {
          int v42 = 1;
        }

        else
        {
          uint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
          int v43 = sub_1000439F4(a1, a2, a6, (unint64_t *)&v62);
          if (v43)
          {
            sub_100013D94( "%s:%d: %s failed to allocate block from internal pool: %d\n",  "spaceman_allocated",  1310,  (const char *)(*(void *)(a1 + 384) + 208LL),  v43);
            break;
          }

          *int v40 = v62;
          bzero(v21, v6[8]);
        }

        uint64_t v44 = v6[9];
        uint64_t v45 = v9 % v44;
        unint64_t v46 = v44 - (v9 % v44);
        if (v15 >= v46) {
          uint64_t v47 = v46;
        }
        else {
          uint64_t v47 = v15;
        }
        sub_10001D318((uint64_t)v21, v45, v47);
        sub_10004D7EC(a2, v60, v21, v9 / v6[9]);
        *(_DWORD *)(v19 + 32 * v37 + 60) -= v47;
        *v22 -= v47;
        if (sub_100051F74(a3, *v40))
        {
          int v42 = 1;
          goto LABEL_42;
        }

        ++v37;
        v9 += v47;
        BOOL v11 = v15 <= v47;
        v15 -= v47;
        if (v11)
        {
          int v42 = 0;
          goto LABEL_42;
        }
      }

      int v42 = 1;
LABEL_42:
      uint64_t v31 = v56;
    }

    sub_10003E984(a1, v19, v6[8], v35, v36);
    uint64_t v48 = sub_100051F74(a3, v31);
    uint64_t v14 = v48;
    if (!v42 || (_DWORD)v48) {
      goto LABEL_51;
    }
  }

  unsigned int v54 = v24 / v25;
  unint64_t v27 = sub_100051DF4(a3, *(void *)(*v51 + 8LL * (v24 / v25)));
  if (!(_DWORD)v27)
  {
    unint64_t v27 = sub_100005224(v52, v6[8], v28, v29);
    if (!(_DWORD)v27)
    {
      unsigned int v25 = v6[11];
      int v26 = v54;
      LODWORD(v24) = v55;
      goto LABEL_19;
    }
  }

  uint64_t v14 = v27;
  sub_100013D94( "%s:%d: %s failed to read cab %d: %d\n",  "spaceman_allocated",  1283,  (const char *)(*(void *)(a1 + 384) + 208LL),  v54,  v27);
LABEL_51:
  if (v52) {
    sub_100014004(v52, v6[8]);
  }
  sub_100014004((void *)v19, v6[8]);
LABEL_54:
  sub_100014004(v21, v6[8]);
  return v14;
}

uint64_t sub_10004419C(void *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t result = sub_1000052C0(a1[47], *(void *)(a2 + 376), a3, a4, 0);
  if (!(_DWORD)result) {
    return sub_100012D38(a1, a3, a4, 0LL);
  }
  return result;
}

uint64_t sub_1000441FC(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  int v4 = *(_DWORD *)(a2 + 164);
  if ((v4 & 0x7FFFFFFFu) <= a3) {
    return 22LL;
  }
  uint64_t v5 = *(void *)(a2 + 168);
  if (v4 < 0) {
    return sub_100012C64(a1, v5, a3, a4, 0LL);
  }
  uint64_t result = 0LL;
  *a4 = v5 + a3;
  return result;
}

uint64_t sub_100044238(void *a1, uint64_t *a2)
{
  uint64_t v3 = (char *)a1[51];
  *a2 = (uint64_t)v3;
  if (v3) {
    goto LABEL_2;
  }
  uint64_t result = sub_10003B574( a1[49],  0x80000000,  *(void *)(a1[47] + 152LL),  (int *)&xmmword_10005BA44,  0LL,  0LL,  0LL,  0LL,  a2);
  if (!(_DWORD)result)
  {
    a1[51] = *a2;
    uint64_t v3 = (char *)*a2;
LABEL_2:
    sub_10003DC28(v3);
    return 0LL;
  }

  return result;
}

uint64_t sub_1000442BC( uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, BOOL *a5)
{
  uint64_t v9 = (void *)a1;
  else {
    uint64_t v10 = 0LL;
  }
  if (v10) {
    uint64_t v9 = *(void **)(v10 + 392);
  }
  uint64_t v21 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = sub_100044238(v9, (uint64_t *)&v21);
  if ((_DWORD)v11)
  {
    if (a2) {
      *a2 = 0LL;
    }
    if (a3) {
LABEL_10:
    }
      *a3 = 0LL;
  }

  else
  {
    uint64_t v13 = *(void *)&v21[5].__opaque[48];
    pthread_mutex_lock(v21 + 9);
    if (v10)
    {
      uint64_t v14 = v21;
      uint64_t v15 = *(void *)(v10 + 376);
      uint64_t v17 = *(void *)(v15 + 72);
      unint64_t v16 = *(void *)(v15 + 80);
      if (v16 >= *(void *)(*(void *)&v21[5].__opaque[48] + 96LL)
                + *(void *)(*(void *)&v21[5].__opaque[48] + 48LL)
                - *(void *)(*(void *)&v21[5].__opaque[48] + 184LL)
                + v17
        || v16 == 0)
      {
        unint64_t v19 = *(void *)(*(void *)&v21[5].__opaque[48] + 96LL)
            + *(void *)(*(void *)&v21[5].__opaque[48] + 48LL)
            - *(void *)(*(void *)&v21[5].__opaque[48] + 184LL)
            + v17;
      }

      else
      {
        unint64_t v19 = v16;
      }
    }

    else
    {
      unint64_t v19 = *(void *)(v13 + 96) + *(void *)(v13 + 48);
      uint64_t v14 = v21;
    }

    unint64_t v20 = sub_1000443E8(v14, v10, a5);
    pthread_mutex_unlock(v14 + 9);
    sub_100038824(&v21->__sig);
    if (a2) {
      *a2 = v19;
    }
    if (a3) {
      *a3 = v20;
    }
    a3 = a4;
    if (a4) {
      goto LABEL_10;
    }
  }

  return v11;
}

unint64_t sub_1000443E8(void *a1, uint64_t a2, BOOL *a3)
{
  uint64_t v3 = (void *)a1[47];
  uint64_t v4 = v3[30];
  uint64_t v5 = v3[35];
  uint64_t v6 = v3[24] - v3[23];
  uint64_t v7 = v3[15] + v3[9];
  unint64_t v8 = v7 + v4 + v5 + v6;
  if (!a2) {
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a2 + 376);
  unint64_t v10 = *(void *)(v9 + 72);
  uint64_t v13 = v9 + 80;
  uint64_t v12 = *(void *)(v9 + 80);
  unint64_t v11 = *(void *)(v13 + 8);
  BOOL v14 = v10 >= v11;
  unint64_t v15 = v10 - v11;
  if (!v14) {
    unint64_t v15 = 0LL;
  }
  v8 += v15;
  if (v12) {
    unint64_t v16 = v12 - (v11 + *(void *)(a2 + 408));
  }
  else {
LABEL_6:
  }
    unint64_t v16 = v8;
  unint64_t v17 = v7 - (a1[104] + a1[105]);
  if (v8 >= v16) {
    unint64_t v8 = v16;
  }
  if (a3) {
    *a3 = v17 < v8;
  }
  if (v17 >= v8) {
    return v8;
  }
  else {
    return v17;
  }
}

uint64_t sub_10004447C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6, unint64_t *a7, BOOL *a8, void *a9, unint64_t *a10, BOOL *a11)
{
  unint64_t v17 = (void *)a1;
  else {
    uint64_t v18 = 0LL;
  }
  if (v18) {
    unint64_t v17 = *(void **)(v18 + 392);
  }
  unint64_t v32 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  if (!a5) {
    return 22LL;
  }
  uint64_t v19 = sub_100044238(v17, (uint64_t *)&v32);
  if (!(_DWORD)v19)
  {
    pthread_mutex_lock(v32 + 9);
    unint64_t v20 = v32;
    unint64_t v21 = sub_1000443E8(v32, v18, a8);
    do
      unint64_t v22 = __ldxr(a5);
    while (__stxr(v22 + a2, a5));
    unint64_t v23 = a3 + a2 + v22;
    BOOL v24 = v23 > v21;
    unint64_t v25 = v23 - v21;
    if (v24)
    {
      do
        unint64_t v26 = __ldxr(a5);
      while (__stxr(v26 - a2, a5));
      BOOL v27 = v25 <= v22;
      uint64_t v19 = 28LL;
    }

    else
    {
      unint64_t v25 = 0LL;
      BOOL v27 = 0;
      uint64_t v19 = 0LL;
    }

    *a6 = v25;
    *a11 = v27;
    *a7 = v21;
    int8x16_t v28 = *(void **)&v20[5].__opaque[48];
    *a9 = v28[35] + v28[30];
    unint64_t v29 = v28[32];
    *a10 = v29;
    unint64_t v30 = v28[37];
    if (v30)
    {
      if (v29 >= v30) {
        unint64_t v29 = v30;
      }
      *a10 = v29;
    }

    pthread_mutex_unlock(v20 + 9);
    sub_100038824(&v32->__sig);
  }

  return v19;
}

uint64_t sub_1000445EC(void *a1, void *a2, uint64_t a3)
{
  uint64_t v12 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v11[2] = v6;
  v11[3] = v6;
  v11[0] = v6;
  v11[1] = v6;
  uint64_t v8 = *(void *)&v12[5].__opaque[48];
  sub_100044720((uint64_t)a1, (uint64_t)v11, 0, 0);
  pthread_mutex_lock(v12 + 7);
  sub_100044814((uint64_t)a1, (uint64_t)v12, 0, 1, (uint64_t)v11, a3);
  pthread_mutex_unlock(v12 + 7);
  pthread_mutex_lock(v12 + 8);
  uint64_t v9 = sub_100044814((uint64_t)a1, (uint64_t)v12, 2u, 1, (uint64_t)v11, a3);
  uint64_t v7 = sub_100044814((uint64_t)a1, (uint64_t)v12, 1u, 1, (uint64_t)v11, a3) + v9;
  *a2 = *(void *)(v8 + 240) + *(void *)(v8 + 280);
  pthread_mutex_unlock(v12 + 8);
  sub_100045054((uint64_t)a1, (uint64_t)v11);
  sub_100038824(&v12->__sig);
  return v7;
}

uint64_t sub_100044720(uint64_t result, uint64_t a2, int a3, int a4)
{
  if (a2)
  {
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    uint64_t result = sub_100052018(*(void *)(result + 384));
    if ((_DWORD)result)
    {
      if (!a4) {
        return result;
      }
    }

    else if ((a4 & 1) == 0)
    {
      return result;
    }

    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.uint64_t tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    uint64_t tv_nsec = __tp.tv_nsec;
    *(void *)a2 = __tp.tv_sec;
    tv_nsec /= 1000LL;
    *(_DWORD *)(a2 + 8) = tv_nsec;
    uint64_t v9 = 1000000 * tv_sec + (int)tv_nsec;
    *(void *)(a2 + 16) = v9;
    *(void *)(a2 + 24) = v9;
    if (a3) {
      __int16 v10 = a3;
    }
    else {
      __int16 v10 = 30;
    }
    *(_WORD *)(a2 + 60) = v10;
    *(_BYTE *)(a2 + 62) = 1;
    *(_BYTE *)(a2 + 63) = a4 & 1;
  }

  return result;
}

uint64_t sub_100044814(uint64_t a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = a5;
  uint64_t v7 = *(void *)(a2 + 376);
  unint64_t v70 = 0LL;
  memset(v69, 170, sizeof(v69));
  uint64_t v56 = v7;
  int v55 = *(_DWORD *)(v7 + 36);
  uint64_t v8 = 1532LL;
  if (!a3) {
    uint64_t v8 = 1534LL;
  }
  unsigned int v54 = (unsigned __int16 *)(a2 + 1534);
  if (a3) {
    uint64_t v9 = (_WORD *)(a2 + 1532);
  }
  else {
    uint64_t v9 = (_WORD *)(a2 + 1534);
  }
  if (a3) {
    uint64_t v10 = 1552LL;
  }
  else {
    uint64_t v10 = 1544LL;
  }
  if (a3) {
    uint64_t v11 = 1560LL;
  }
  else {
    uint64_t v11 = 1561LL;
  }
  unsigned int v12 = *(unsigned __int16 *)(a2 + v8);
  if (*(_WORD *)(a2 + v8))
  {
    int v13 = 0;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    unint64_t v16 = (pthread_mutex_t *)(a2 + 512);
    uint64_t v62 = (pthread_mutex_t *)(a2 + 448);
    do
    {
      if ((a4 & 2) == 0) {
        int v13 = 16;
      }
      uint64_t v17 = *(void *)(a2 + v10);
      *(_BYTE *)(a2 + v11) = 1;
      if (a3)
      {
        pthread_mutex_unlock(v16);
        uint64_t v18 = v16;
      }

      else
      {
        uint64_t v18 = v62;
        pthread_mutex_unlock(v62);
      }

      v14 += v17;
      v15 += v12;
      timespec __rqtp = (timespec)xmmword_10005B7C0;
      nanosleep(&__rqtp, 0LL);
      pthread_mutex_lock(v18);
      unsigned int v12 = (unsigned __int16)*v9;
    }

    while (*v9);
    uint64_t v6 = a5;
    if (v13) {
      goto LABEL_31;
    }
  }

  else
  {
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
  }

  if (!sub_100045974(a1, a2, a3, 0LL, 0, (uint64_t *)&v70) && v70)
  {
    LODWORD(__rqtp.tv_sec) = 16;
    unsigned int v68 = 8;
    int v19 = sub_1000261E0((uint64_t)v70, 0LL, v69, &__rqtp, &v69[2], &v68);
    unint64_t v63 = v69[0];
    if (a3 && !*(void *)(a2 + 1536)) {
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 384));
    }
    unint64_t v20 = a6;
    if (v19)
    {
LABEL_29:
      if (*(void *)(a2 + 1536))
      {
        sub_10004DB8C(a1, a2, a3, v6, v20);
      }

      else
      {
        sub_100051D1C(*(void *)(a1 + 384));
        if (a3) {
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 384));
        }
        sub_10004D8E8(a1, v6);
      }

      sub_100038824(v70);
      return v14;
    }

    char v22 = 0;
    int v53 = (void *)(v56 + 40LL * a3 + 216);
    unint64_t v59 = (pthread_mutex_t *)(a2 + 576);
    unint64_t v51 = (pthread_mutex_t *)(a2 + 448);
    int v57 = 2;
    while (1)
    {
      if (v68)
      {
        unint64_t v23 = v69[2];
      }

      else
      {
        v69[2] = 1LL;
        unint64_t v23 = 1LL;
      }

      unint64_t v24 = v69[0];
      if (v69[0] <= v20)
      {
        if (v69[0] > v63)
        {
          *int v53 = v69[0];
          if ((a4 & 2) == 0) {
            goto LABEL_29;
          }
        }

        if (*(_BYTE *)(a1 + 632))
        {
          uint64_t v25 = *(void *)(a1 + 376);
          if (v24 >= *(void *)(v25 + 1408))
          {
            uint64_t v50 = a2 + 8LL * a3;
            if (*(void *)(v50 + 920) < v20)
            {
              *(void *)(v50 + 920) = v20;
              sub_100013D04( "%s:%d: %s sfq %d processing xid %lld blocked by temporary checkpoints %lld\n",  "spaceman_free_completed",  6096,  (const char *)(*(void *)(a1 + 384) + 208LL),  a3,  v24,  *(void *)(v25 + 1408));
            }

            goto LABEL_29;
          }
        }

        unint64_t v26 = *(void *)(a2 + 912);
        if (v24 > v26)
        {
          if ((a4 & 3) != 0 && v57 && v24 != v20)
          {
            sub_10004EF7C(a1, 0xD0u);
            --v57;
            unint64_t v24 = v69[0];
            unint64_t v26 = *(void *)(a2 + 912);
          }

          if (v24 > v26) {
            goto LABEL_29;
          }
        }

        if (a3)
        {
          int v27 = sub_10004419C((void *)a1, a2, v69[1], v69[2]);
          if (v27)
          {
            int v28 = v27;
            pthread_mutex_lock(v59);
            sub_10004DA54(a1, a2, a3, v23);
            pthread_mutex_unlock(v59);
LABEL_59:
            if (sub_100013538(a1)) {
              sub_100013D94( "%s:%d: %s sfq %d error validating extent %lld %lld: %d\n",  "spaceman_free_completed",  6154,  (const char *)(*(void *)(a1 + 384) + 208LL),  a3,  v69[1],  v23,  v28);
            }
            goto LABEL_80;
          }

          pthread_mutex_lock(v59);
          uint64_t v52 = (void *)(a2 + 8LL * (a3 - 1) + 976);
          *v52 += v23;
          sub_10004DA54(a1, a2, a3, v23);
          pthread_mutex_unlock(v59);
          unint64_t v29 = v69[1];
          uint64_t v30 = *(void *)(a2 + 1536);
          if (v30)
          {
            unint64_t v31 = *(unsigned __int16 *)(a2 + 1532);
            *(_WORD *)(a2 + 1532) = v31 + 1;
            unint64_t v32 = *(void *)(a2 + 1552) + v23;
            *(void *)(a2 + 1552) = v32;
            int v33 = *(_DWORD *)(*(void *)(a2 + 376) + 36LL);
            uint64_t v34 = v30 + 16 * v31;
            *(void *)(v34 + 256) = v29;
            *(void *)(v34 + 264) = v23;
            goto LABEL_80;
          }

          sub_100051CDC(*(void *)(a1 + 384), v69[1]);
          sub_10004DF24((void *)a1, a2, v29, v23, 1, v20);
        }

        else
        {
          sub_10004DA54(a1, a2, 0, v23);
          int v28 = sub_10004DB0C(a1, a2, v69[1], v23, 0LL);
          if (v28) {
            goto LABEL_59;
          }
          unint64_t v35 = v69[1];
          uint64_t v36 = *(void *)(a2 + 1536);
          if (v36)
          {
            uint64_t v37 = *(unsigned __int16 *)(a2 + 1534);
            *(_WORD *)(a2 + 1534) = v37 + 1;
            *(void *)(a2 + 1544) += v23;
            unint64_t v38 = (unint64_t *)(v36 + 16 * v37);
            *unint64_t v38 = v35;
            v38[1] = v23;
            if ((unsigned __int16)(v37 + 1) >= 0x10u)
            {
              pthread_mutex_unlock(v51);
              uint64_t v39 = *v54;
              sub_10004D8E8(a1, v6);
              if (v39)
              {
                uint64_t v40 = 0LL;
                uint64_t v41 = 16 * v39;
                do
                {
                  sub_100051CDC(*(void *)(a1 + 384), *(void *)(*(void *)(a2 + 1536) + v40));
                  v40 += 16LL;
                }

                while (v41 != v40);
                sub_100051D1C(*(void *)(a1 + 384));
                pthread_mutex_lock(v51);
                uint64_t v42 = 0LL;
                unint64_t v43 = a6;
                do
                {
                  sub_10004DCE4( a1,  (void *)a2,  *(void *)(*(void *)(a2 + 1536) + v42),  *(void *)(*(void *)(a2 + 1536) + v42 + 8),  a6);
                  v42 += 16LL;
                }

                while (v41 != v42);
              }

              else
              {
                sub_100051D1C(*(void *)(a1 + 384));
                pthread_mutex_lock(v51);
                unint64_t v43 = a6;
              }

              *(void *)(a2 + 1544) = 0LL;
              *(_WORD *)(a2 + 1534) = 0;
              unint64_t v20 = v43;
            }

            goto LABEL_80;
          }

          sub_100051CDC(*(void *)(a1 + 384), v69[1]);
          sub_10004DCE4(a1, (void *)a2, v35, v23, v20);
        }

        sub_10004D8E8(a1, v6);
      }

      else
      {
        sub_100013D94( "%s:%d: %s sfq %d entry %lld:%lld %lld - bad xid, current xid %lld\n",  "spaceman_free_completed",  6069,  (const char *)(*(void *)(a1 + 384) + 208LL),  a3,  v69[0],  v69[1],  v23,  v20);
        if (a3)
        {
          pthread_mutex_lock(v59);
          sub_10004DA54(a1, a2, a3, v23);
          pthread_mutex_unlock(v59);
        }

        else
        {
          sub_10004DA54(a1, a2, 0, v23);
        }
      }

uint64_t sub_100045054(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (!*(_BYTE *)(a2 + 62)) {
    return 0LL;
  }
  v11.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v11.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v11);
  __darwin_time_t tv_sec = v11.tv_sec;
  int tv_nsec = v11.tv_nsec;
  *(void *)a2 = v11.tv_sec;
  tv_nsec /= 1000;
  *(_DWORD *)(a2 + 8) = tv_nsec;
  *(void *)(a2 + 32) = 1000000 * tv_sec + tv_nsec;
  *(_BYTE *)(a2 + 62) = 0;
  uint64_t v6 = *(int *)(a2 + 56);
  if (!(_DWORD)v6) {
    return 0LL;
  }
  uint64_t v7 = (unint64_t *)(*(void *)(a1 + 384) + 168LL);
  uint64_t v8 = -v6;
  do
    unint64_t v9 = __ldxr(v7);
  while (__stxr(v9 + v8, v7));
  return 1LL;
}

void sub_100045114(void *a1, uint64_t a2)
{
  int v13 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v12 = v4;
  *(_OWORD *)&v12[16] = v4;
  __int128 v10 = v4;
  __int128 v11 = v4;
  uint64_t v5 = *(void *)(a2 + 16);
  if (!sub_100044238(a1, (uint64_t *)&v13))
  {
    uint64_t v6 = *(void **)&v13[5].__opaque[48];
    sub_100044720((uint64_t)a1, (uint64_t)&v10, 0, 1);
    pthread_mutex_lock(v13 + 7);
    if (sub_100045484((uint64_t)a1, (uint64_t)v13, 0, 0))
    {
      while (sub_100045484((uint64_t)a1, (uint64_t)v13, 0, 1)
    }

    while (1)
    {
      uint64_t v7 = v13;
      if (!sub_100044814((uint64_t)a1, (uint64_t)v13, 0, 0, (uint64_t)&v10, v5))
      {
        uint64_t v7 = v13;
        break;
      }
    }

    pthread_mutex_unlock(v7 + 7);
    pthread_mutex_lock(v13 + 8);
    uint64_t v8 = v13;
    if (v6[30] > *(void *)&v13[23].__opaque[32])
    {
      while (1)
      {
        uint64_t v8 = v13;
        if (v6[30] <= *(void *)&v13[23].__opaque[32] >> 1) {
          break;
        }
        if (!sub_100044814((uint64_t)a1, (uint64_t)v13, 1u, 1, (uint64_t)&v10, v5))
        {
          uint64_t v8 = v13;
          break;
        }
      }
    }

    if (v6[35] > *(void *)&v8[23].__opaque[40])
    {
      while (v6[35] > *(void *)&v13[23].__opaque[40] >> 1
    }

    if (v6[30] > v6[9])
    {
    }

    if (v6[35] > v6[15])
    {
    }

    if (sub_100045484((uint64_t)a1, (uint64_t)v13, 1u, 0))
    {
      while (sub_100045484((uint64_t)a1, (uint64_t)v13, 1u, 1)
    }

    if (sub_100045484((uint64_t)a1, (uint64_t)v13, 2u, 0))
    {
      while (sub_100045484((uint64_t)a1, (uint64_t)v13, 2u, 1)
    }

    while (v5 - v6[32] > (unint64_t)*(unsigned __int16 *)&v13[23].__opaque[48]
    do
      uint64_t v9 = v6[37];
    while (v9
         && v5 - v9 > (unint64_t)*(unsigned __int16 *)&v13[23].__opaque[48]
         && sub_100044814((uint64_t)a1, (uint64_t)v13, 2u, 0, (uint64_t)&v10, v5));
    sub_100045054((uint64_t)a1, (uint64_t)&v10);
    *(_OWORD *)(a2 + 88) = *(_OWORD *)&v12[8];
    *(void *)(a2 + 80) = *(void *)v12 - v11;
    pthread_mutex_unlock(v13 + 8);
    sub_100038824(&v13->__sig);
  }

uint64_t sub_100045484(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = 0LL;
  if (!sub_100045974(a1, a2, a3, 0LL, 0, &v9) && v9)
  {
    uint64_t v7 = sub_100047CB0(a2, a3, v9, a4);
    sub_100038824(v9);
  }

  return v7;
}

uint64_t sub_100045500(void *a1)
{
  uint64_t v14 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v3 = *(void **)&v14[5].__opaque[48];
  pthread_mutex_lock(v14 + 9);
  unint64_t v4 = v3[9];
  unint64_t v5 = *(void *)&v14[23].__opaque[32] >> (v4 - v14[13].__sig < v3[6] >> 5);
  unint64_t v6 = v3[30];
  unint64_t v7 = v3[15];
  unint64_t v8 = *(void *)&v14[23].__opaque[40] >> (v7 - *(void *)v14[13].__opaque < v3[12] >> 5);
  unint64_t v9 = v3[35];
  pthread_mutex_unlock(v14 + 9);
  BOOL v12 = v9 > v7 || v9 > v8 || v6 > v4 || v6 > v5;
  if (v12 || sub_100045484((uint64_t)a1, (uint64_t)v14, 0, 0))
  {
    uint64_t v2 = 1LL;
  }

  else
  {
    uint64_t v2 = 1LL;
  }

  sub_100038824(&v14->__sig);
  return v2;
}

uint64_t sub_100045630(uint64_t a1, uint64_t a2)
{
  unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100044238(a1, &v5);
  if (!(_DWORD)result)
  {
    unint64_t v4 = v5;
    *(void *)(v5 + 912) = a2;
    return sub_100038824(v4);
  }

  return result;
}

uint64_t sub_100045674(uint64_t a1, size_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = *(unsigned __int16 **)(a3 + 376);
  unint64_t v24 = 0LL;
  char v22 = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v9 = sub_100045974(a1, a3, 0, 0LL, 0, (uint64_t *)&v23);
  if ((_DWORD)v9) {
    goto LABEL_49;
  }
  uint64_t v9 = sub_100045974(a1, a3, 1u, 0LL, 0, (uint64_t *)&v24);
  if ((_DWORD)v9) {
    goto LABEL_49;
  }
  uint64_t v9 = sub_100045974(a1, a3, 2u, 0LL, 0, (uint64_t *)&v22);
  if ((_DWORD)v9) {
    goto LABEL_49;
  }
  if ((_DWORD)a4 == 1)
  {
    uint64_t v14 = sub_10003E754((unsigned int *)a3);
    uint64_t v9 = v14;
    if ((_DWORD)v14 || (__int128 v11 = v23) == 0LL)
    {
      if ((_DWORD)v14 || (BOOL v12 = v24) == 0LL)
      {
        if (!(_DWORD)v14)
        {
          int v13 = v22;
          if (v22) {
            goto LABEL_42;
          }
        }

        goto LABEL_49;
      }

      goto LABEL_32;
    }

    unint64_t v15 = *(void *)(v23[49] + 32);
    if (v15 <= v8[112])
    {
      char v16 = 0;
    }

    else if (*(_BYTE *)(a3 + 968))
    {
      char v16 = 1;
    }

    else
    {
      sub_100013D94( "%s:%d: %s IP free queue tree is too large: %lld nodes (limit %d) xid %lld\n",  "spaceman_checkpoint_traverse",  3107,  (const char *)(*(void *)(a1 + 384) + 208LL),  v15,  v8[112],  *(void *)(a2 + 16));
      char v16 = 1;
      __int128 v11 = v23;
    }

    *(_BYTE *)(a3 + 968) = v16;
    goto LABEL_28;
  }

  if ((_DWORD)a4 == 2)
  {
    uint64_t v10 = sub_10003E7D8(a3);
    uint64_t v9 = v10;
    if ((_DWORD)v10 || (__int128 v11 = v23) == 0LL)
    {
      if ((_DWORD)v10 || (BOOL v12 = v24) == 0LL)
      {
        if ((_DWORD)v10) {
          goto LABEL_49;
        }
        int v13 = v22;
        if (!v22) {
          goto LABEL_49;
        }
LABEL_48:
        uint64_t v9 = sub_100028D34(a1, a2, v13, a4);
        goto LABEL_49;
      }

      goto LABEL_38;
    }

    goto LABEL_28;
  }

  __int128 v11 = v23;
  if (v23)
  {
LABEL_28:
    uint64_t v9 = sub_100028D34(a1, a2, v11, a4);
    goto LABEL_29;
  }

  uint64_t v9 = 0LL;
LABEL_29:
  if (!(_DWORD)v9)
  {
    BOOL v12 = v24;
    if (v24)
    {
      if ((_DWORD)a4 != 1)
      {
LABEL_38:
        uint64_t v9 = sub_100028D34(a1, a2, v12, a4);
        goto LABEL_39;
      }

LABEL_49:
  if (v23) {
    sub_100038824(v23);
  }
  if (v24) {
    sub_100038824(v24);
  }
  if (v22) {
    sub_100038824(v22);
  }
  return v9;
}

uint64_t sub_100045974(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t *a6)
{
  if (a3 > 2) {
    return 22LL;
  }
  uint64_t v10 = *(void *)(a2 + 376);
  uint64_t v11 = a2 + 8LL * a3;
  BOOL v12 = *(char **)(v11 + 944);
  *a6 = (uint64_t)v12;
  if (v12) {
    goto LABEL_4;
  }
  uint64_t v13 = v10 + 40LL * a3;
  uint64_t v16 = *(void *)(v13 + 208);
  unint64_t v15 = (uint64_t *)(v13 + 208);
  uint64_t v14 = v16;
  if (v16)
  {
    uint64_t result = sub_100027FC4(a1, 0x80000000LL, v14, 0LL, 0LL, 0LL, 9LL, sub_1000479E8, 0LL, a6);
    if (!(_DWORD)result)
    {
LABEL_8:
      *(void *)(v11 + 944) = *a6;
      BOOL v12 = (char *)*a6;
LABEL_4:
      sub_10003DC28(v12);
      return 0LL;
    }

    return result;
  }

  if (!a5)
  {
    uint64_t result = 0LL;
    goto LABEL_14;
  }

  uint64_t result = sub_10003CF9C(a2, 0LL, a4);
  if ((_DWORD)result)
  {
LABEL_14:
    *a6 = 0LL;
    return result;
  }

  uint64_t result = sub_100027C40(a1, 0x80000000, 6, 9, 0, 0x10u, 8, (uint64_t)sub_1000479E8, a4, a6);
  if (!(_DWORD)result)
  {
    *unint64_t v15 = sub_10003965C(*a6);
    sub_10003E644(a2, a4, 0LL);
    goto LABEL_8;
  }

  return result;
}

uint64_t sub_100045AA8( uint64_t a1, int a2, uint64_t a3, uint64_t (*a4)(void *a1, unint64_t a2, int64_t a3), void *a5)
{
  LODWORD(v7) = a2;
  uint64_t v8 = a1;
  __int128 v244 = 0u;
  __int128 v245 = 0u;
  memset(v243, 0, sizeof(v243));
  uint64_t v242 = 0LL;
  uint64_t v241 = 0LL;
  memset(v249, 0, 128);
  unint64_t v240 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v239 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v9 = (pthread_mutex_t *)(a1 + 848);
  unint64_t v228 = 0LL;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 848));
  if ((v7 & 0x30) == 0 && *(_BYTE *)(v8 + 641))
  {
    pthread_mutex_unlock(v9);
    return 16LL;
  }

  uint64_t v238 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 __base = v10;
  __int128 v230 = v10;
  __int128 v231 = v10;
  __int128 v232 = v10;
  __int128 v233 = v10;
  __int128 v234 = v10;
  __int128 v235 = v10;
  __int128 v236 = v10;
  unint64_t v237 = 0xAAAAAAAAAAAAAAAALL;
  ++*(_DWORD *)(v8 + 824);
  pthread_mutex_unlock(v9);
  uint64_t v11 = sub_100044238(v8, &v238);
  if ((_DWORD)v11) {
    goto LABEL_374;
  }
  int v192 = v7 & 0x30;
  v218 = a4;
  BOOL v12 = *(_DWORD **)&v238[5].__opaque[48];
  if ((v7 & 0x40) != 0)
  {
    unsigned int v13 = 4;
  }

  else if ((v7 & 0x20) != 0)
  {
    unsigned int v13 = 8;
  }

  else if (a4 == sub_100047418)
  {
    unsigned int v13 = 1;
  }

  else
  {
    unsigned int v13 = v12[10];
  }

  uint64_t v14 = sub_100014044(16LL * v12[10]);
  unint64_t v15 = (char *)sub_100014044(8LL * v12[10]);
  uint64_t v16 = v15;
  uint64_t v17 = 12LL;
  uint64_t v205 = v14;
  if (!v14 || !v15) {
    goto LABEL_369;
  }
  if ((v7 & 2) == 0) {
    pthread_mutex_lock(v238 + 6);
  }
  if (a3)
  {
    if ((v7 & 0x6C) != 0x40)
    {
      uint64_t v17 = 22LL;
      goto LABEL_359;
    }

    uint64_t v18 = ((unint64_t)(a3 << __clz(__rbit64(*(unsigned int *)(*(void *)(v8 + 376) + 36LL)))) >> 62) & 1;
  }

  else
  {
    if ((v7 & 4) != 0)
    {
      LODWORD(v18) = 0;
      unsigned int v19 = 1;
      goto LABEL_24;
    }

    LODWORD(v18) = (v7 >> 3) & 1;
  }

  unsigned int v19 = 2;
LABEL_24:
  BOOL v184 = 0;
  char v189 = 0;
  char v191 = 0;
  uint64_t v193 = 0LL;
  uint64_t v17 = 0LL;
  char v20 = &v228;
  if ((v7 & 0x20) == 0) {
    char v20 = 0LL;
  }
  unint64_t v183 = (uint64_t *)v20;
  char v196 = v7 & 0xFE;
  uint64_t v221 = v18;
  uint64_t v179 = v19;
  int v197 = v9;
  uint64_t v198 = (void *)v8;
  int v206 = v16;
  char v202 = v7;
  uint64_t v203 = v12;
  unsigned int v180 = v19;
  while (1)
  {
    if ((v7 & 1) != 0)
    {
      unint64_t v237 = 0LL;
      __int128 v235 = 0u;
      __int128 v236 = 0u;
      __int128 v233 = 0u;
      __int128 v234 = 0u;
      __int128 v231 = 0u;
      __int128 v232 = 0u;
      __int128 __base = 0u;
      __int128 v230 = 0u;
      LODWORD(v237) = sub_100031B20((uint64_t)v238, v221);
    }

    unint64_t v228 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v8 + 376) + 36LL)))) & a3;
    int v185 = sub_10002D4B0(*(void *)&v238[24].__opaque[8 * v221 + 24], v183);
    unint64_t v21 = v228;
    unint64_t v22 = v12[9];
    if ((v7 & 0x40) == 0)
    {
      unint64_t v21 = v228 / v22 * v22;
      unint64_t v228 = v21;
    }

    unint64_t v181 = v21;
    unint64_t v23 = &v12[12 * v221];
    unint64_t v24 = v23 + 16;
    uint64_t v186 = v23 + 16;
    uint64_t v187 = v23 + 17;
    int v188 = -1;
    unint64_t v25 = v21 / v22 / v12[10];
    unint64_t v26 = (char *)v205;
    uint64_t v27 = v17;
LABEL_32:
    uint64_t v17 = v27;
    if ((v7 & 1) != 0 && (_DWORD)v237)
    {
      int v164 = v25;
      qsort(&__base, 8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_100047684);
      if ((_DWORD)v237)
      {
        LODWORD(v25) = v164;
        unint64_t v24 = v186;
        if (DWORD2(v236))
        {
          unsigned int v165 = 6;
          unint64_t v167 = (unint64_t)&v236;
          unsigned int v166 = (_DWORD *)&v236 + 2;
          while (1)
          {
            LOBYTE(v248) = 0;
            int v168 = sub_100031B7C(v238, v221, *(void *)v167, &v248);
            if (v168) {
              sub_100013D94( "%s:%d: %s failed to evaluate chunk %llu (average free ext len %u) for disabled allocation zones, error %d\n",  "spaceman_iterate_free_extents_internal",  3914,  (const char *)(*(void *)(v8 + 384) + 208LL),  *(void *)v167,  *v166,  v168);
            }
            int v169 = v237;
            if ((_BYTE)v248)
            {
              int v169 = v237 - 1;
              LODWORD(v237) = v237 - 1;
            }

            unint64_t v24 = v186;
            uint64_t v17 = 0LL;
            LODWORD(v25) = v164;
            if (!v169 || v165 == -1) {
              break;
            }
            unint64_t v167 = (unint64_t)(&__base + v165);
            unsigned int v166 = (_DWORD *)(v167 | 8);
            --v165;
            if (!*(_DWORD *)(v167 + 8))
            {
              uint64_t v17 = 0LL;
              break;
            }
          }
        }
      }

      else
      {
        LODWORD(v25) = v164;
        unint64_t v24 = v186;
      }
    }

    if (v185)
    {
      if (v181) {
        char v170 = 0;
      }
      else {
        char v170 = (_DWORD)v25 == *v24;
      }
      sub_10002D558(*(void *)&v238[24].__opaque[8 * v221 + 24], v228, v170);
    }

    a3 = 0LL;
    if (++v221 == v179)
    {
      char v177 = 0;
      unsigned int v171 = v180;
      goto LABEL_348;
    }
  }

  unsigned int v190 = v13;
  unint64_t v28 = v228;
  unint64_t v31 = v12 + 9;
  unint64_t v29 = v12[9];
  unsigned int v30 = v31[1];
  if (!v192)
  {
    int v32 = v25;
    pthread_mutex_lock(v9);
    if (*(_BYTE *)(v8 + 641))
    {
      unsigned int v171 = v221;
      sub_100013D04( "%s:%d: %s nx_resize detected while processing dev=%d cib=%u out of %u cibs\n",  "spaceman_iterate_free_extents_internal",  3608,  (const char *)(*(void *)(v8 + 384) + 208LL),  v221,  v32,  *v186);
      pthread_mutex_unlock(v9);
      char v177 = 0;
      uint64_t v17 = 16LL;
      BOOL v12 = v203;
LABEL_380:
      char v172 = v185;
      goto LABEL_344;
    }

    pthread_mutex_unlock(v9);
    LODWORD(v25) = v32;
  }

  unsigned int v224 = v30;
  unint64_t v226 = v28;
  uint64_t v33 = v27;
  uint64_t v34 = v25;
  unsigned int v35 = v25;
  pthread_mutex_lock(&v238[v221 + 10]);
  int v36 = *v187;
  BOOL v222 = *v187 == 0;
  unsigned int v219 = v34;
  unsigned int v194 = v35;
  if (*v187)
  {
    unsigned int v37 = v35 / v203[11];
    uint64_t v38 = v193;
    if (v37 == v188 && v193)
    {
      sub_10003CF10(v242, 1);
      unsigned int v37 = v188;
    }

    else
    {
      uint64_t v40 = *(void *)(*(void *)&v238[13].__opaque[8 * v221 + 48] + 8LL * v37);
      if (v242)
      {
        sub_100038824(v242);
        uint64_t v242 = 0LL;
      }

      unint64_t v239 = (unint64_t)v203;
      unint64_t v240 = __PAIR64__(v37, v221);
      uint64_t v41 = sub_10003B574(*(void *)(v8 + 392), 1073741892LL, v40, &xmmword_10005BA54, &v239, 0LL, 0LL, 0LL, &v242);
      if ((_DWORD)v41)
      {
        uint64_t v17 = v41;
        sub_100013D94( "%s:%d: %s error getting cab %d @ %lld: %d\n",  "spaceman_iterate_free_extents_internal",  3635,  (const char *)(*(void *)(v8 + 384) + 208LL),  v37,  v40,  v41);
        char v177 = 0;
        if (v185)
        {
          char v191 = 1;
          LOBYTE(v7) = v202;
          BOOL v12 = v203;
          unsigned int v171 = v221;
          goto LABEL_347;
        }

        LOBYTE(v7) = v202;
        BOOL v12 = v203;
        unsigned int v171 = v221;
        goto LABEL_349;
      }

      uint64_t v33 = 0LL;
      uint64_t v38 = *(void *)(v242 + 56);
      int v188 = v37;
      unint64_t v26 = (char *)v205;
    }

    pthread_mutex_unlock(&v238[v221 + 10]);
    char v191 = 0;
    uint64_t v39 = (uint64_t *)(v38 + 8LL * (v194 - v203[11] * v37) + 40);
    char v189 = 1;
  }

  else
  {
    uint64_t v39 = (uint64_t *)(*(void *)&v238[13].__opaque[8 * v221 + 48] + 8 * v34);
    char v191 = 1;
    uint64_t v38 = v193;
  }

  uint64_t v193 = v38;
  if (v241)
  {
    sub_10003CF10(v241, 1);
    goto LABEL_50;
  }

  uint64_t v42 = *v39;
  unint64_t v239 = (unint64_t)v203;
  unint64_t v240 = __PAIR64__(v194, v221);
  uint64_t v43 = sub_10003B574(*(void *)(v8 + 392), 1073741892LL, v42, &xmmword_10005BA64, &v239, 0LL, 0LL, 0LL, &v241);
  if ((_DWORD)v43)
  {
    uint64_t v178 = v43;
    sub_100013D94( "%s:%d: %s error getting cib %d @ %lld: %d\n",  "spaceman_iterate_free_extents_internal",  3662,  (const char *)(*(void *)(v8 + 384) + 208LL),  v194,  v42,  v43);
    char v177 = 0;
    uint64_t v17 = v178;
    char v191 = v222;
    LOBYTE(v7) = v202;
    BOOL v12 = v203;
    uint64_t v16 = v206;
LABEL_379:
    unsigned int v171 = v221;
    goto LABEL_380;
  }

  uint64_t v33 = 0LL;
  uint64_t v16 = v206;
LABEL_50:
  uint64_t v44 = *(void *)(v241 + 56);
  LOBYTE(v7) = v202;
  if (v218 == sub_100047418)
  {
    sub_100044720(v8, (uint64_t)v243, 125, 0);
    if (v36) {
      goto LABEL_52;
    }
  }

  else if (v36)
  {
    goto LABEL_52;
  }

  pthread_mutex_unlock(&v238[v221 + 10]);
  char v191 = 0;
LABEL_52:
  uint64_t v211 = v44;
  uint64_t v45 = v33;
  if (v242)
  {
    sub_10003D514(v242, 1);
    char v189 = 0;
  }

  unint64_t v46 = v226 / v29 - v224 * (unint64_t)v194;
  unsigned int v47 = v226 % v29;
  BOOL v12 = v203;
  bzero(v16, 8LL * v203[10]);
  unsigned int v48 = v46;
  unsigned int v49 = *(_DWORD *)(v211 + 36) - v46;
  unsigned int v13 = v190;
  if (v190 >= v49) {
    size_t v50 = v49;
  }
  else {
    size_t v50 = v190;
  }
  size_t __nel = v50;
  unsigned int v199 = v48;
  if ((_DWORD)v50)
  {
    uint64_t v51 = 0LL;
    int v52 = v203[9];
    uint64_t v53 = 16LL * v50;
    unsigned int v54 = v48;
    do
    {
      int v55 = &v26[v51];
      *(_DWORD *)int v55 = v54;
      *((void *)v55 + 1) = *(void *)(v211 + 32LL * v54 + 64);
      if (v51) {
        unsigned int v56 = 0;
      }
      else {
        unsigned int v56 = v47;
      }
      v228 += v52 - v56;
      ++v54;
      v51 += 16LL;
    }

    while (v53 != v51);
    if ((v202 & 0x40) != 0) {
      goto LABEL_65;
    }
  }

  else
  {
    unsigned int v54 = v48;
    if ((v202 & 0x40) != 0) {
      goto LABEL_65;
    }
  }

  qsort(v26, __nel, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1000475B0);
LABEL_65:
  size_t v57 = __nel;
  if (!(_DWORD)__nel)
  {
    unsigned int v212 = 0;
    uint64_t v27 = v45;
    goto LABEL_296;
  }

  unsigned int v182 = v54;
  uint64_t v58 = 0LL;
  int v59 = 0;
  unsigned int v60 = v205 + 1;
  unsigned int v61 = v219;
  while (1)
  {
    uint64_t v62 = v58;
    uint64_t v63 = *v60;
    if (*v60) {
      break;
    }
LABEL_76:
    uint64_t v58 = v62 + 1;
    v60 += 2;
    if (v57 == v62 + 1)
    {
LABEL_77:
      uint64_t v67 = 0LL;
      int v209 = 0;
      unsigned int v212 = 0;
      unsigned int v195 = v62 + 1;
      BOOL v12 = v203;
      unsigned int v68 = v205;
      do
      {
        uint64_t v69 = (unsigned int *)&v68[2 * v67];
        unsigned int v201 = v12[10];
        uint64_t v70 = *v69;
        unint64_t v71 = &v249[v209];
        uint64_t v207 = *((void *)v69 + 1);
        uint64_t v208 = v71;
        if (v207)
        {
          uint64_t v72 = v67;
          if (*v71)
          {
            uint64_t v73 = sub_10003DB5C(*v71);
            if ((_DWORD)v73) {
              goto LABEL_340;
            }
          }

          else
          {
            uint64_t v73 = sub_10003B574( *(void *)(v8 + 392),  1073741888LL,  v207,  &xmmword_10005BA74,  0LL,  0LL,  0LL,  0LL,  &v249[v209]);
            if ((_DWORD)v73)
            {
LABEL_340:
              uint64_t v17 = v73;
              sub_100013D94( "%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n",  "spaceman_iterate_free_extents_internal",  3744,  (const char *)(*(void *)(v8 + 384) + 208LL),  v194,  *v69,  v207,  v73);
              if (*v208)
              {
                sub_100038824(*v208);
                *uint64_t v208 = 0LL;
              }

              goto LABEL_343;
            }
          }

          __int16 v225 = *(void **)(*v208 + 56);
          unsigned int v74 = *v69;
          uint64_t v67 = v72;
        }

        else
        {
          __int16 v225 = 0LL;
          unsigned int v74 = *v69;
        }

        uint64_t v75 = v70;
        uint64_t v204 = v67;
        if ((v7 & 0x40) != 0)
        {
          int8x8_t v76 = v225;
          if (v74)
          {
            *(void *)&v16[8 * v74] = *(void *)&v16[8 * v74 - 8];
            *(void *)&v16[8 * *v69 - 8] = 0LL;
            unsigned int v74 = *v69;
          }
        }

        else
        {
          int8x8_t v76 = v225;
        }

        unint64_t v77 = 0LL;
        int v215 = &v16[8 * v74];
        int v78 = *(_DWORD *)(v211 + 32 * v75 + 56);
        uint64_t v247 = 0LL;
        uint64_t v223 = v238;
        uint64_t v200 = *(void *)&v238[23].__opaque[8 * v221 + 8];
        char v79 = v196;
        if (v200) {
          char v79 = v7;
        }
        char v227 = v79;
        if ((v79 & 0x40) != 0) {
          unint64_t v77 = *(void *)v215;
        }
        uint64_t v210 = v75;
        uint64_t v80 = *(void *)&v78 & 0xFFFFFLL;
        uint64_t v248 = 0xAAAAAAAAAAAAAAAALL;
        if ((v78 & 0xFFFFFu) <= v47)
        {
          unsigned int v82 = 0;
          LODWORD(v81) = 0;
          uint64_t v84 = 0LL;
LABEL_154:
          LOBYTE(v7) = v202;
          BOOL v12 = v203;
          if ((v227 & 0x40) != 0) {
            goto LABEL_155;
          }
          goto LABEL_156;
        }

        uint64_t v81 = 0LL;
        unsigned int v82 = 0;
        uint64_t v83 = v47;
        uint64_t v84 = 0LL;
        char v216 = (void *)(v211 + 32 * v75 + 48);
        uint64_t v217 = (unint64_t *)&v238[24].__opaque[8 * v221 + 24];
        unsigned int v85 = 1;
        while (1)
        {
          if (!v76)
          {
            uint64_t v247 = v80;
            uint64_t v248 = v83;
            uint64_t v86 = v80;
            uint64_t v87 = v83;
            goto LABEL_102;
          }

          if (sub_10001D4C8(1, (uint64_t)v76, v248, v80 - v248, &v247))
          {
            uint64_t v86 = v247;
          }

          else
          {
            uint64_t v247 = v80;
            uint64_t v86 = v80;
          }

          uint64_t v87 = v248;
LABEL_102:
          uint64_t v83 = v86;
          uint64_t v88 = v86 - v87;
          if (v86 - v87 > v81) {
            uint64_t v81 = v86 - v87;
          }
          if ((v227 & 0x40) != 0)
          {
            unsigned int v220 = 100 * (v85 / 0x64) - 1;
            if (v77 && v87)
            {
              unsigned int v89 = v84;
              if (v221 == 1)
              {
                char v90 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
                unint64_t v91 = (0x4000000000000000uLL >> v90) | (*v216 - v77);
              }

              else
              {
                unint64_t v91 = *v216 - v77;
                char v90 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
              }

              sub_10002B884(*v217, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v90) & v91, v77);
              if (v218)
              {
                unsigned int v95 = v218(a5, v91, v77);
                if (BYTE14(v245))
                {
                  ++*((void *)&v244 + 1);
                  *(void *)&__int128 v245 = v245 + v77;
                }
              }

              else
              {
                unsigned int v95 = 0;
              }

              unint64_t v77 = 0LL;
              if (v89) {
                BOOL v96 = 1;
              }
              else {
                BOOL v96 = v95 == 0;
              }
              if (v96) {
                uint64_t v84 = v89;
              }
              else {
                uint64_t v84 = v95;
              }
              uint64_t v86 = v247;
              unsigned int v61 = v219;
            }

            if (v86 != v80)
            {
              int v92 = v84;
              if (v221 == 1)
              {
                char v93 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
                unint64_t v94 = (0x4000000000000000uLL >> v93) | (v87 - v77 + *v216);
              }

              else
              {
                unint64_t v94 = v87 - v77 + *v216;
                char v93 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
              }

              unint64_t v97 = v77 + v88;
LABEL_137:
              sub_10002B884(*v217, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v93) & v94, v97);
              if (v218)
              {
                unsigned int v98 = v218(a5, v94, v97);
                int v99 = BYTE14(v245);
                int8x8_t v76 = v225;
                if (BYTE14(v245))
                {
                  ++*((void *)&v244 + 1);
                  *(void *)&__int128 v245 = v245 + v97;
                  int v99 = 1;
                }

                LODWORD(v84) = v92;
              }

              else
              {
                unsigned int v98 = 0;
                int v99 = BYTE14(v245);
                LODWORD(v84) = v92;
                int8x8_t v76 = v225;
              }

              unint64_t v77 = 0LL;
              if ((_DWORD)v84) {
                BOOL v100 = 1;
              }
              else {
                BOOL v100 = v98 == 0;
              }
              if (v100) {
                uint64_t v84 = v84;
              }
              else {
                uint64_t v84 = v98;
              }
              unsigned int v61 = v219;
              if (v99 && v220 == v82)
              {
                sub_10004D8E8(*(void *)(v223->__sig + 392), (uint64_t)v243);
                unint64_t v77 = 0LL;
              }

              goto LABEL_151;
            }

            v77 += v88;
          }

          else if (v87)
          {
            if (v86 != v80)
            {
              int v92 = v84;
              unsigned int v220 = 100 * (v85 / 0x64) - 1;
              if (v221 == 1)
              {
                char v93 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
                unint64_t v94 = (0x4000000000000000uLL >> v93) | (v87 - v77 + *v216);
              }

              else
              {
                unint64_t v94 = v87 - v77 + *v216;
                char v93 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
              }

              unint64_t v97 = v88 + v77;
              goto LABEL_137;
            }

            *((_DWORD *)v215 + 1) = v88;
          }

          else
          {
            *(_DWORD *)int v215 = v88;
          }

          int8x8_t v76 = v225;
LABEL_151:
          ++v85;
          ++v82;
          if (v83 >= v80) {
            goto LABEL_154;
          }
        }

        BOOL v12 = v203;
        if ((v227 & 0x40) == 0 || !v77 || v82) {
          goto LABEL_154;
        }
        unsigned int v108 = v84;
        if (v221 == 1)
        {
          char v109 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
          unint64_t v110 = (0x4000000000000000uLL >> v109) | (*v216 - v77);
        }

        else
        {
          unint64_t v110 = *v216 - v77;
          char v109 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(v223->__sig + 392) + 376LL) + 36LL)));
        }

        LOBYTE(v7) = v202;
        sub_10002B884(*v217, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v109) & v110, v77);
        if (v218)
        {
          unsigned int v127 = v218(a5, v110, v77);
          if (BYTE14(v245))
          {
            ++*((void *)&v244 + 1);
            *(void *)&__int128 v245 = v245 + v77;
          }
        }

        else
        {
          unsigned int v127 = 0;
        }

        unsigned int v82 = 0;
        unint64_t v77 = 0LL;
        if (v108) {
          BOOL v140 = 1;
        }
        else {
          BOOL v140 = v127 == 0;
        }
        if (v140) {
          uint64_t v84 = v108;
        }
        else {
          uint64_t v84 = v127;
        }
LABEL_155:
        *(void *)int v215 = v77;
LABEL_156:
        uint64_t v8 = (uint64_t)v198;
        if ((v227 & 1) == 0) {
          goto LABEL_199;
        }
        unint64_t v101 = v210 + v201 * (unint64_t)v61;
        int v102 = *(_DWORD *)(v200 + 4 * v101);
        int v103 = v102 & 0xFF000000 | v81 & 0xFFFFFF;
        *(_DWORD *)(v200 + 4 * v101) = v103;
        if (v76)
        {
          int v104 = v102 & 0xFE000000 | v81 & 0xFFFFFF;
          int v105 = v103 | 0x1000000;
          if ((*v76 & 1LL) != 0) {
            int v105 = v104;
          }
          *(_DWORD *)(v200 + 4 * v101) = v105;
          uint64_t v106 = v200;
          if (v80 < 0x40 || (v76[(v80 >> 6) - 1] & 0x8000000000000000LL) != 0)
          {
            unsigned int v107 = v105 & 0xFDFFFFFF;
            goto LABEL_170;
          }
        }

        else
        {
          int v105 = v103 | 0x1000000;
          uint64_t v106 = v200;
        }

        unsigned int v107 = v105 | 0x2000000;
LABEL_170:
        *(_DWORD *)(v106 + 4 * v101) = v107;
        if (!(_DWORD)v237) {
          goto LABEL_199;
        }
        unsigned int v111 = *(_DWORD *)(v211 + 32 * v210 + 60) & 0xFFFFF;
        if (v111 == *(_DWORD *)(*(void *)&v223[5].__opaque[48] + 36LL))
        {
          char v246 = 0;
          int v112 = sub_100031B7C(v223, v221, v101, &v246);
          if (v112)
          {
            uint64_t v113 = *(void *)v223->__opaque;
            if (v113) {
              uint64_t v114 = (const char *)(v113 + 3992);
            }
            else {
              uint64_t v114 = (const char *)(*(void *)(*(void *)(v223->__sig + 392) + 384LL) + 208LL);
            }
            sub_100013D94( "%s:%d: %s failed to evaluate free chunk %llu for disabled allocation zone, error %d\n",  "spaceman_iterate_process_bitmap_block",  3390,  v114,  v101,  v112);
          }

          if (v246) {
            LODWORD(v237) = v237 - 1;
          }
          goto LABEL_199;
        }

        if (!v82 || v111 < 4) {
          goto LABEL_199;
        }
        unsigned int v115 = v111 / v82;
        unint64_t v116 = (unint64_t)(&__base + HIDWORD(v237));
        int v117 = v107 & 0xC000000;
        int v118 = v107 & 0xFFFFFC;
        BOOL v119 = v115 > *(_DWORD *)(v116 + 8) && v117 == 0;
        if (!v119 || v118 == 0) {
          goto LABEL_199;
        }
        int v121 = 0;
        *(_DWORD *)(v116 | 8) = v115;
        *(void *)unint64_t v116 = v101;
        uint64_t v122 = -7LL;
        unsigned int v123 = DWORD2(__base);
        uint64_t v124 = (unsigned int *)&v230 + 2;
        while (2)
        {
          unsigned int v126 = *v124;
          v124 += 4;
          unsigned int v125 = v126;
          if (v126 >= v123)
          {
LABEL_188:
            BOOL v135 = __CFADD__(v122++, 1LL);
            if (v135) {
              goto LABEL_237;
            }
            continue;
          }

          break;
        }

        if (v125)
        {
          int v121 = v122 + 8;
          unsigned int v123 = v125;
          goto LABEL_188;
        }

        int v121 = v122 + 8;
LABEL_237:
        HIDWORD(v237) = v121;
LABEL_199:
        unsigned int v128 = v212;
        if (v212) {
          BOOL v129 = 1;
        }
        else {
          BOOL v129 = (_DWORD)v84 == 0;
        }
        if (!v129) {
          unsigned int v128 = v84;
        }
        if ((v7 & 0x40) != 0 && v128)
        {
          uint64_t v17 = v84;
          uint64_t v9 = v197;
          goto LABEL_342;
        }

        unsigned int v212 = v128;
        uint64_t v9 = v197;
        unsigned int v68 = v205;
        uint64_t v16 = v206;
        if (!v207)
        {
          uint64_t v138 = v84;
          uint64_t v139 = v204;
          goto LABEL_225;
        }

        sub_100038824(*v208);
        *uint64_t v208 = 0LL;
        uint64_t v130 = v84;
        uint64_t v131 = 1LL;
        uint64_t v132 = (uint64_t)&v205[2 * v195 - 2];
        do
        {
          size_t v133 = v195 + v131;
          uint64_t v134 = *(void *)(v132 + 24);
          v132 += 16LL;
          ++v131;
          if (v134) {
            BOOL v135 = 1;
          }
          else {
            BOOL v135 = v133 >= __nel;
          }
        }

        while (!v135);
        unsigned int v195 = v195 + v131 - 1;
        if (!v134)
        {
          unsigned int v68 = v205;
          uint64_t v84 = v130;
          goto LABEL_223;
        }

        uint64_t v136 = sub_10003B574(v198[49], 1073742016LL, v134, &xmmword_10005BA74, 0LL, 0LL, 0LL, 0LL, v208);
        if ((_DWORD)v136 == 45 || (_DWORD)v136 == 16)
        {
          uint64_t v84 = 0LL;
          *uint64_t v208 = 0LL;
          unsigned int v68 = v205;
LABEL_223:
          uint64_t v139 = v204;
          goto LABEL_224;
        }

        uint64_t v17 = v136;
        uint64_t v139 = v204;
        if ((_DWORD)v136)
        {
          sub_100013D94( "%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n",  "spaceman_iterate_free_extents_internal",  3793,  (const char *)(v198[48] + 208LL),  v194,  *(_DWORD *)v132,  v134,  v136);
          goto LABEL_343;
        }

        unsigned int v68 = v205;
        uint64_t v84 = v136;
LABEL_224:
        uint64_t v138 = v84;
        int v209 = ((_BYTE)v209 + 1) & 0xF;
LABEL_225:
        unsigned int v47 = 0;
        uint64_t v67 = v139 + 1;
      }

      while (v67 != __nel);
      int v141 = 0;
      unint64_t v142 = 0LL;
      unint64_t v143 = 0LL;
      while (1)
      {
        uint64_t v144 = v141 + v199;
        uint64_t v145 = &v206[8 * v144];
        if ((v7 & 0x40) != 0)
        {
          unint64_t v146 = *(void *)v145;
          if (*(void *)v145)
          {
            if (v221 == 1) {
              unint64_t v143 = (*(void *)(v211 + 32 * v144 + 48) - v146 + (*(_DWORD *)(v211 + 32 * v144 + 56) & 0xFFFFF)) | (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36LL))));
            }
            else {
              unint64_t v143 = *(void *)(v211 + 32 * v144 + 48) - v146 + (*(_DWORD *)(v211 + 32 * v144 + 56) & 0xFFFFF);
            }
            unint64_t v142 = *(void *)v145;
          }

          goto LABEL_283;
        }

        unint64_t v147 = *(unsigned int *)v145;
        if ((_DWORD)v147) {
          break;
        }
LABEL_266:
        unint64_t v151 = *((unsigned int *)v145 + 1);
        if ((_DWORD)v151)
        {
          uint64_t v152 = v211 + 32 * v144;
          unsigned int v153 = (*(_DWORD *)(v152 + 56) & 0xFFFFF) - v151;
          if (v221 == 1)
          {
            unint64_t v154 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36LL)))) | (*(void *)(v152 + 48) + v153);
            if (!v142)
            {
LABEL_276:
              uint64_t v155 = 0LL;
              goto LABEL_277;
            }
          }

          else
          {
            unint64_t v154 = *(void *)(v152 + 48) + v153;
            if (!v142) {
              goto LABEL_276;
            }
          }

          if (v142 + v143 == v154)
          {
            uint64_t v155 = 0LL;
            v151 += v142;
            unint64_t v154 = v143;
          }

          else
          {
            sub_10002B884( *(void *)&v238[24].__opaque[8 * v221 + 24],  0,  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36LL)))) & v143,  v142);
            if (!v218) {
              goto LABEL_276;
            }
            uint64_t v155 = v218(a5, v143, v142);
            if (BYTE14(v245))
            {
              ++*((void *)&v244 + 1);
              *(void *)&__int128 v245 = v245 + v142;
            }
          }

LABEL_277:
          unsigned int v156 = v212;
          if (v212) {
            BOOL v157 = 1;
          }
          else {
            BOOL v157 = (_DWORD)v155 == 0;
          }
          uint64_t v138 = v155;
          if (!v157) {
            unsigned int v156 = v155;
          }
          unsigned int v212 = v156;
          unint64_t v143 = v154;
          unint64_t v142 = v151;
        }

LABEL_296:
          if (v218 == sub_100047418) {
            sub_1000475C8(v8);
          }
          sub_10003D514(v241, 1);
          if (BYTE14(v245))
          {
            if (sub_100045054(v8, (uint64_t)v243))
            {
              if (v13 <= 1) {
                unsigned int v13 = 1;
              }
              else {
                v13 >>= 1;
              }
              BOOL v160 = 1;
            }

            else
            {
              unsigned int v161 = v12[10];
              int v162 = 4 * v13;
              if (v161 < 4 * v13) {
                int v162 = v12[10];
              }
              if (v161 >= v13 + 1) {
                unsigned int v161 = v13 + 1;
              }
              if (v184) {
                unsigned int v13 = v161;
              }
              else {
                unsigned int v13 = v162;
              }
              BOOL v160 = v184;
            }

            BOOL v184 = v160;
          }

          if (*(_DWORD *)(v211 + 36) == v54)
          {
            sub_100038824(v241);
            uint64_t v241 = 0LL;
            unsigned int v163 = v194;
          }

          else
          {
            unsigned int v163 = v194 - 1;
          }

          unint64_t v24 = v186;
          LODWORD(v25) = v163 + 1;
          if (v212)
          {
            char v177 = 0;
            uint64_t v17 = v212;
            goto LABEL_379;
          }

          goto LABEL_32;
        }
      }

      if (v221 == 1)
      {
        unint64_t v7 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36LL)))) | *(void *)(v211 + 32 * v144 + 48);
        if (!v142) {
          goto LABEL_259;
        }
      }

      else
      {
        unint64_t v7 = *(void *)(v211 + 32 * v144 + 48);
        if (!v142) {
          goto LABEL_259;
        }
      }

      if (v142 + v143 == v7)
      {
        uint64_t v148 = 0LL;
        v147 += v142;
        unint64_t v7 = v143;
LABEL_260:
        unsigned int v149 = v212;
        if (v212) {
          BOOL v150 = 1;
        }
        else {
          BOOL v150 = (_DWORD)v148 == 0;
        }
        uint64_t v138 = v148;
        if (!v150) {
          unsigned int v149 = v148;
        }
        unsigned int v212 = v149;
        unint64_t v143 = v7;
        unint64_t v142 = v147;
        LOBYTE(v7) = v202;
        goto LABEL_266;
      }

      sub_10002B884( *(void *)&v238[24].__opaque[8 * v221 + 24],  0,  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(v198[47] + 36LL)))) & v143,  v142);
      if (v218)
      {
        uint64_t v148 = v218(a5, v143, v142);
        if (BYTE14(v245))
        {
          ++*((void *)&v244 + 1);
          *(void *)&__int128 v245 = v245 + v142;
        }

        goto LABEL_260;
      }

LABEL_259:
      uint64_t v148 = 0LL;
      goto LABEL_260;
    }
  }

  uint64_t v64 = sub_10003B574(*(void *)(v8 + 392), 1073742016LL, v63, &xmmword_10005BA74, 0LL, 0LL, 0LL, 0LL, &v249[v59]);
  size_t v57 = __nel;
  if (!(_DWORD)v64)
  {
LABEL_75:
    ++v59;
    uint64_t v16 = v206;
    unsigned int v61 = v219;
    if (v59 == 16) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }

  uint64_t v65 = v64;
  if ((_DWORD)v64 == 45 || (_DWORD)v64 == 16)
  {
    v249[v59] = 0LL;
    goto LABEL_75;
  }

  sub_100013D94( "%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n",  "spaceman_iterate_free_extents_internal",  3720,  (const char *)(*(void *)(v8 + 384) + 208LL),  v194,  *((_DWORD *)v60 - 2),  v63,  v64);
  uint64_t v17 = v65;
  BOOL v12 = v203;
LABEL_342:
  uint64_t v16 = v206;
LABEL_343:
  unsigned int v171 = v221;
  char v172 = v185;
  char v177 = 1;
LABEL_344:
  if (!(_DWORD)v17) {
    char v172 = 0;
  }
  if ((v172 & 1) != 0) {
LABEL_347:
  }
    sub_10002D558(*(void *)&v238[24].__opaque[8 * v171 + 24], v228, 0);
LABEL_348:
  if ((v191 & 1) != 0) {
LABEL_349:
  }
    pthread_mutex_unlock(&v238[(unint64_t)v171 + 10]);
  if (v242 && (v189 & 1) != 0) {
    sub_10003D514(v242, 1);
  }
  char v173 = v177 ^ 1;
  if (!v241) {
    char v173 = 1;
  }
  if ((v173 & 1) == 0)
  {
    sub_100045054(v8, (uint64_t)v243);
    if (v218 == sub_100047418) {
      sub_1000475C8(v8);
    }
    sub_10003D514(v241, 1);
  }

LABEL_359:
  if (v242) {
    sub_100038824(v242);
  }
  if (v241) {
    sub_100038824(v241);
  }
  for (uint64_t i = 0LL; i != 16; ++i)
  {
    uint64_t v175 = v249[i];
    if (v175)
    {
      sub_10003DB5C(v175);
      sub_100038824(v249[i]);
    }
  }

  if ((v7 & 2) == 0) {
    pthread_mutex_unlock(v238 + 6);
  }
LABEL_369:
  uint64_t v11 = v17;
  if (v16) {
    sub_100014004(v16, 8LL * v12[10]);
  }
  if (v205) {
    sub_100014004(v205, 16LL * v12[10]);
  }
  sub_100038824(v238);
LABEL_374:
  pthread_mutex_lock(v9);
  --*(_DWORD *)(v8 + 824);
  pthread_mutex_unlock(v9);
  return v11;
}

uint64_t sub_100047418(void *a1, unint64_t a2, int64_t a3)
{
  uint64_t v14 = 0LL;
  if (sub_100044238(a1, &v14) || (int v13 = sub_10004419C(a1, v14, a2, a3), sub_100038824(v14), !v13))
  {
    a1[212] += a3;
    if (a3 < 2)
    {
      uint64_t v8 = 0LL;
    }

    else
    {
      uint64_t v6 = 0LL;
      unint64_t v7 = a3;
      do
      {
        uint64_t v8 = v6 + 1;
        if (v7 < 4) {
          break;
        }
        v7 >>= 2;
      }

      while (v6++ < 4);
    }

    ++a1[v8 + 213];
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    int v11 = SLODWORD(__tp.tv_nsec) / 1000;
    sub_100051CDC(a1[48], a2);
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    a1[211] += 1000000 * (__tp.tv_sec - tv_sec) - v11 + SLODWORD(__tp.tv_nsec) / 1000;
  }

  else if (sub_100013538((uint64_t)a1))
  {
    sub_100013D94( "%s:%d: %s free extent %lld:%lld appears to span container metadata and should not be free: %d\n",  "spaceman_trim_free_extent_callback",  4022,  (const char *)(a1[48] + 208LL),  a2,  a3,  v13);
  }

  return 0LL;
}

uint64_t sub_1000475B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t sub_1000475C8(uint64_t a1)
{
  v5.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  __darwin_time_t tv_sec = v5.tv_sec;
  int v3 = SLODWORD(v5.tv_nsec) / 1000;
  sub_100051D1C(*(void *)(a1 + 384));
  v5.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  *(void *)(a1 + 1688) += 1000000 * (v5.tv_sec - tv_sec) - v3 + SLODWORD(v5.tv_nsec) / 1000;
  return result;
}

uint64_t sub_100047684(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004769C(void *a1, int a2, int a3)
{
  uint64_t v6 = 0LL;
  if (a3)
  {
    if (a2) {
      int v7 = 2;
    }
    else {
      int v7 = 0;
    }
    int v8 = v7 | a3;
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    a1[210] = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    uint64_t v6 = sub_100045AA8((uint64_t)a1, v8, 0LL, 0LL, a1);
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    sub_100013CBC("%s:%d: %s scan took %lld.%06lld s (no trims)\n");
  }

  return v6;
}

uint64_t sub_1000479E8(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22LL;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }

      else
      {
        uint64_t v8 = a2[1];
        uint64_t v9 = a4[1];
        BOOL v10 = v8 < v9;
        int v7 = v8 > v9;
        if (v10) {
          int v7 = -1;
        }
      }
    }

    else
    {
      int v7 = -1;
    }

    uint64_t result = 0LL;
    *a6 = v7;
  }

  return result;
}

uint64_t sub_100047A44(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v6 = *(void *)(a2 + 376);
  memset(v25, 170, sizeof(v25));
  *a6 = 0;
  uint64_t v7 = v6 + 40LL * a3;
  uint64_t v9 = *(void *)(v7 + 208);
  uint64_t v8 = (void *)(v7 + 208);
  if (!v9) {
    return 0LL;
  }
  unsigned int v23 = -1431655766;
  unsigned int v24 = -1431655766;
  uint64_t v16 = sub_100045974(a1, a2, a3, 0LL, 0, (uint64_t *)&v25[3]);
  if ((_DWORD)v16)
  {
    uint64_t v17 = v16;
    sub_100013D94( "%s:%d: %s can't get spaceman %d free queue tree %lld: %d\n",  "spaceman_fq_tree_find_overlap",  4656,  (const char *)(*(void *)(a1 + 384) + 208LL),  a3,  *v8,  v16);
  }

  else
  {
    unint64_t v18 = *(void *)(v6 + 40LL * a3 + 216);
    if (v18 > sub_100039664(a2))
    {
LABEL_23:
      uint64_t v17 = 0LL;
    }

    else
    {
      uint64_t v19 = a5 + a4;
      do
      {
        unsigned int v23 = 8;
        unsigned int v24 = 16;
        v25[0] = v18;
        v25[1] = a4;
        uint64_t v20 = sub_100026464(v25[3], 0LL, v25, &v24, 0x10u, &v25[2], &v23, 1u, 0, 0LL);
        if ((_DWORD)v20 != 2)
        {
          uint64_t v17 = v20;
          if ((_DWORD)v20) {
            break;
          }
          if (!v23) {
            void v25[2] = 1LL;
          }
        }

        unsigned int v23 = 8;
        unsigned int v24 = 16;
        v25[0] = v18;
        v25[1] = a4;
        uint64_t v21 = sub_100026464(v25[3], 0LL, v25, &v24, 0x10u, &v25[2], &v23, 4u, 0, 0LL);
        uint64_t v17 = v21;
        if ((_DWORD)v21 != 2)
        {
          if ((_DWORD)v21) {
            break;
          }
          if (!v23) {
            void v25[2] = 1LL;
          }
          if (v18 == v25[0] && v25[2] + v25[1] > a4 && v19 > (uint64_t)v25[1])
          {
LABEL_27:
            uint64_t v17 = 0LL;
            *a6 = 1;
            goto LABEL_24;
          }
        }

        ++v18;
      }

      while (v18 <= sub_100039664(a2));
      sub_100013D94( "%s:%d: %s error searching spaceman free queue tree: %d\n",  "spaceman_fq_tree_find_overlap",  4710,  (const char *)(*(void *)(a1 + 384) + 208LL),  v17);
    }

LABEL_24:
    sub_100038824(v25[3]);
  }

  return v17;
}

uint64_t sub_100047CB0(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  BOOL v4 = *(unsigned __int16 **)(a3 + 56);
  unint64_t v5 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 40LL * a2 + 224);
  if (a4)
  {
    unint64_t v6 = *(void *)(*(void *)(a3 + 392) + 32LL);
    if (v6 <= 1)
    {
      unsigned int v9 = v4[25] + v4[23] + v4[27];
      BOOL v10 = v9 >= sub_1000398C8(a3) >> 1;
      return !v10;
    }

    return 1LL;
  }

  if (*(void *)(*(void *)(a3 + 392) + 32LL) > 1uLL) {
    return 1LL;
  }
  unsigned int v11 = v4[25] + v4[23] + v4[27];
  BOOL v10 = v11 >= sub_1000398C8(a3) >> 2;
  return !v10;
}

uint64_t sub_100047D80(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(void *)(a2 + 376);
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = *(void *)(v6 + 152);
  if ((v7 & 0x8000000000000000LL) == 0)
  {
    uint64_t v8 = *(void *)(v6 + 176);
    unint64_t v9 = v8 + v7;
    BOOL v10 = __OFSUB__(a3, v8);
    uint64_t v11 = a3 - v8;
    if (v11 < 0 != v10 || v9 <= a3) {
      return 22LL;
    }
    uint64_t v13 = 0LL;
LABEL_12:
    *a4 = v11;
    return v13;
  }

  unint64_t v15 = (uint64_t *)(a2 + 1504);
  if (*(void *)(a2 + 1504))
  {
LABEL_8:
    *(void *)&v31[0] = a3;
    LODWORD(v28) = 8;
    LODWORD(v27[0]) = 16;
    uint64_t v13 = sub_100026464( *v15,  0LL,  (unint64_t *)v31,  (unsigned int *)&v28,  8u,  &v24,  (unsigned int *)v27,  1u,  0,  0LL);
    if ((_DWORD)v13) {
      return v13;
    }
    if (a3 - *(void *)&v31[0] >= v25) {
      return 2LL;
    }
    uint64_t v13 = 0LL;
    uint64_t v11 = v24 + a3 - *(void *)&v31[0];
    goto LABEL_12;
  }

  unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_100027C40(a1, 0x88000000, 0, 0, 0, 8u, 16, (uint64_t)sub_10001282C, 0LL, (uint64_t *)(a2 + 1504));
  if (!(_DWORD)v13)
  {
    uint64_t v33 = (char *)0xAAAAAAAAAAAAAAAALL;
    *(void *)&__int128 v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v31[0] = v18;
    v31[1] = v18;
    v31[2] = v18;
    v31[3] = v18;
    unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v13 = sub_10001292C(a1, *(void *)(*(void *)(a2 + 376) + 176LL), &v33);
    if (!(_DWORD)v13)
    {
      unint64_t v30 = 0LL;
      sub_100026ED4((uint64_t)v31, (uint64_t)v33, 0LL, 0, &v30, 8, 8u, &v28, 0x10u);
      uint64_t v13 = v19;
      if (sub_100026EFC((uint64_t)v31))
      {
        sub_100038824(v33);
        if ((_DWORD)v13) {
          return v13;
        }
        goto LABEL_8;
      }

      while (1)
      {
        unint64_t v26 = v28;
        v27[0] = v30;
        v27[1] = v29;
        uint64_t v20 = sub_10001EADC(*v15, 0LL, &v26, 8LL, v27, 16LL, 0LL);
        if ((_DWORD)v20) {
          break;
        }
        uint64_t v21 = sub_100026F18((uint64_t)v31);
        if ((_DWORD)v21)
        {
          uint64_t v13 = v21;
          unint64_t v22 = (const char *)(*(void *)(a1 + 384) + 208LL);
          unsigned int v23 = strerror(v21);
          sub_100013D94( "%s:%d: %s failed to get next internal pool reverse mapping, error %s(%d)\n",  "spaceman_set_up_ip_reverse_mapping_tree",  4861,  v22,  v23,  v13);
          goto LABEL_26;
        }

        if (sub_100026EFC((uint64_t)v31))
        {
          sub_100038824(v33);
          goto LABEL_8;
        }
      }

      uint64_t v13 = v20;
LABEL_26:
      sub_100038824(v33);
    }
  }

  return v13;
}

void *sub_100047FDC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 1530) = 256;
  *(_WORD *)(a2 + 1534) = 0;
  uint64_t result = sub_100013EEC(0x100uLL, 0x10uLL);
  *(void *)(a2 + 1536) = result;
  if (!result) {
    *(_WORD *)(a2 + 1530) = 0;
  }
  return result;
}

uint64_t sub_100048020(void *a1, int a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t *a6)
{
  uint64_t v9 = (uint64_t)a1;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v364 = v10;
  __int128 v365 = v10;
  __int128 v363 = v10;
  uint64_t v356 = 0LL;
  uint64_t v357 = 0LL;
  uint64_t v355 = 0LL;
  unint64_t v354 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v353 = 0xAAAAAAAAAAAAAAAALL;
  int64_t v351 = 0LL;
  uint64_t v367 = 0LL;
  uint64_t v368 = 0LL;
  uint64_t v11 = 0LL;
  if (sub_100037DC8((uint64_t)a1) == 13)
  {
    uint64_t v11 = a1;
    uint64_t v9 = a1[49];
  }

  *(void *)&__int128 v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  __int128 v361 = v12;
  __int128 v362 = v12;
  __int128 v360 = v12;
  v352[2] = v12;
  v352[3] = v12;
  v352[0] = v12;
  v352[1] = v12;
  unsigned int v13 = a2 | 0x1000;
  if (!a6) {
    unsigned int v13 = a2 & 0xFFFFEBFF;
  }
  uint64_t v14 = *(void *)(v9 + 376);
  uint64_t v15 = *(void *)(v14 + 1240);
  char v16 = __clz(__rbit64(*(unsigned int *)(v14 + 36)));
  unint64_t v17 = 0x4000000000000000uLL >> v16;
  BOOL v18 = ((0x4000000000000000uLL >> v16) & v15) != 0;
  uint64_t v19 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v16;
  uint64_t v20 = v19 & v15;
  uint64_t v21 = *(void *)(v14 + 1248);
  uint64_t v22 = (v20 + v21) & v19;
  BOOL v23 = v21 == 0;
  if (v21) {
    unint64_t v24 = v20;
  }
  else {
    unint64_t v24 = 0LL;
  }
  unint64_t v334 = v24;
  if (v23) {
    unint64_t v25 = 0LL;
  }
  else {
    unint64_t v25 = v22;
  }
  unint64_t v333 = v25;
  uint64_t v26 = *(void *)(v9 + 1752);
  unint64_t v27 = v17 & v26;
  int v332 = (v17 & v26) != 0;
  if (*(_BYTE *)(v9 + 636) || (uint64_t v29 = *(void *)(v9 + 1760)) == 0)
  {
    unint64_t v339 = 0LL;
    unint64_t v28 = 0LL;
  }

  else
  {
    unint64_t v339 = v19 & v26;
    unint64_t v28 = (v29 + (v19 & v26)) & v19;
  }

  if ((v13 & 0x80) != 0) {
    v13 |= 0x8100u;
  }
  if ((v13 & 0x200) != 0)
  {
    v13 |= 0x102u;
    *a5 = *(void *)(v9 + 1768);
  }

  unint64_t v338 = v28;
  int v30 = (v13 >> 2) & 0x100;
  if (*(_BYTE *)(v9 + 639)) {
    int v30 = 2304;
  }
  int v31 = v30 | v13;
  if ((v13 & 2) != 0)
  {
    v31 &= ~0x40u;
    unint64_t v32 = *a5;
    if ((v31 & 0x40) == 0) {
      goto LABEL_23;
    }
LABEL_25:
    int v33 = *(_DWORD *)a5;
    goto LABEL_26;
  }

  unint64_t v32 = 0LL;
  if ((v31 & 0x40) != 0) {
    goto LABEL_25;
  }
LABEL_23:
  int v33 = 3;
LABEL_26:
  *a5 = 0LL;
  int v340 = v31;
  if ((v31 & 4) != 0)
  {
    if (a3 < 1) {
      return 22LL;
    }
  }

  else
  {
    BOOL v35 = sub_10004E670(v9, a4);
    uint64_t v34 = 22LL;
    if (a3 < 1 || !v35) {
      return v34;
    }
  }

  v366 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v358 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v359 = 0xAAAAAAAAAAAAAAAALL;
  memset(v350, 170, sizeof(v350));
  unint64_t v349 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v34 = sub_100044238(v9, &v366);
  if ((_DWORD)v34) {
    return v34;
  }
  unsigned int v311 = v33;
  v304 = a5;
  int v36 = v366;
  unint64_t v37 = v366[47];
  uint64_t v38 = (void *)v366[198];
  unsigned int v39 = v340;
  if (v38)
  {
    uint64_t v40 = v38[1] + a3;
    ++*v38;
    v38[1] = v40;
    if ((v340 & 0x40) != 0)
    {
      uint64_t v41 = v38 + 2;
    }

    else
    {
      switch(a3)
      {
        case 1LL:
          uint64_t v42 = v38 + 4;
          unsigned int v39 = v340;
          goto LABEL_45;
        case 2LL:
          uint64_t v41 = v38 + 5;
          break;
        case 3LL:
          uint64_t v41 = v38 + 6;
          break;
        case 4LL:
          uint64_t v41 = v38 + 7;
          break;
        default:
          goto LABEL_42;
      }

      unsigned int v39 = v340;
    }

    ++*v41;
LABEL_42:
    if ((unint64_t)a3 >= 2 && !a6)
    {
      uint64_t v42 = v38 + 8;
LABEL_45:
      ++*v42;
    }
  }

  if ((v39 & 0x200) != 0)
  {
    unint64_t v43 = v338;
    unint64_t v338 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36LL)))) & *(void *)(v37 + 48LL * (v27 != 0) + 48);
    unint64_t v339 = v43;
  }

  if (!a6 && *(void *)(v37 + 96) + *(void *)(v37 + 48) <= (unint64_t)a3)
  {
    uint64_t v34 = 28LL;
    goto LABEL_661;
  }

  uint64_t v44 = *(void *)(v9 + 376);
  unsigned int v45 = v39;
  if ((v39 & 2) != 0)
  {
    char v46 = __clz(__rbit64(*(unsigned int *)(v44 + 36)));
    else {
      unsigned int v45 = v39;
    }
  }

  if ((v45 & 0x1A) == 2)
  {
    else {
      int v47 = 8;
    }
    v45 |= v47;
  }

  if ((~v45 & 0x38) == 0) {
    panic("Absurd combination of allocation flags for spaceman %llx", v36);
  }
  if (*(void *)(v37 + 96)) {
    __asm { BR              X12 }
  }

  if ((v45 & 0x10) != 0)
  {
    uint64_t v34 = 22LL;
    int v36 = v366;
    goto LABEL_661;
  }

  unint64_t v303 = v32;
  int v293 = v18;
  LODWORD(v368) = 0;
  LODWORD(v367) = 1;
  int v48 = v39 & 0x40;
  BOOL v292 = v48 == 0;
  pthread_mutex_lock((pthread_mutex_t *)v366 + 6);
  uint64_t v325 = 0LL;
  unsigned int v321 = 0;
  unint64_t v49 = 0LL;
  char v297 = 0;
  int v301 = 0;
  char v50 = 0;
  int v51 = v45 & 0x100 | v48;
  int v52 = 0;
  unsigned __int8 v331 = v51 == 0;
  if (v366[186]) {
    int v53 = v45;
  }
  else {
    int v53 = v45 | 0x100;
  }
  unsigned int v335 = v53;
  v312 = (const char *)(a1 + 499);
  unsigned int v54 = a6;
  int v294 = 2;
  unint64_t v342 = a3;
  uint64_t v55 = a3;
LABEL_68:
  char v291 = v50;
  unint64_t v341 = v49;
  do
  {
LABEL_69:
    int v330 = v52;
    do
    {
      uint64_t v56 = v55;
      int v57 = v330;
      while (1)
      {
        unsigned int v58 = v335;
        uint64_t v55 = v342;
        if (!(_BYTE)v57)
        {
          int v59 = v57;
          goto LABEL_82;
        }

        if (!v339)
        {
          if ((v331 & 1) == 0)
          {
            uint64_t v34 = 28LL;
LABEL_653:
            uint64_t v55 = v56;
            goto LABEL_654;
          }

          unint64_t v339 = 0LL;
          goto LABEL_81;
        }

        if ((v335 & 0x200) != 0)
        {
          unint64_t v338 = 0LL;
          unint64_t v339 = 0LL;
LABEL_81:
          int v59 = 0;
          unsigned __int8 v331 = 0;
          goto LABEL_82;
        }

        int v60 = sub_100037DC8((uint64_t)a1);
        unsigned int v61 = (const char *)(a1 + 499);
        if (v60 != 13) {
          unsigned int v61 = (const char *)(a1[48] + 208LL);
        }
        sub_100013CBC( "%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n",  "spaceman_alloc",  6927,  v61);
        unint64_t v338 = 0LL;
        unint64_t v339 = 0LL;
        int v59 = 0;
        unsigned __int8 v331 = 0;
        *(_BYTE *)(v9 + 636) = 1;
        *(void *)(v9 + 1784) = 0LL;
        unsigned int v54 = a6;
LABEL_82:
        uint64_t v62 = *((unsigned int *)&v368 + v59);
        unsigned int v343 = *((_DWORD *)&v367 + v59);
        int v315 = v59;
        int v330 = v59 + 1;
        if ((v340 & 4) != 0)
        {
          BOOL v70 = v62 == v332;
          if (v338) {
            BOOL v71 = v62 == v332;
          }
          else {
            BOOL v71 = 0;
          }
          goto LABEL_112;
        }

        if ((v335 & 1) != 0) {
          break;
        }
        BOOL v63 = 1;
        while (1)
        {
          if (v11)
          {
            uint64_t v64 = v11[47];
            unint64_t v65 = *(void *)(v64 + 80);
            if (v65)
            {
              uint64_t v66 = v11[51] + *(void *)(v64 + 88);
              if (v66 + v55 > v65)
              {
                uint64_t v55 = v65 - v66;
                uint64_t v34 = 69LL;
                if (!v54 || v55 < 1) {
                  goto LABEL_654;
                }
              }
            }
          }

          uint64_t v56 = *(void *)(v37 + 240)
              + *(void *)(v37 + 72)
              + *(void *)(v37 + 120)
              + *(void *)(v37 + 280)
              + *(void *)(v37 + 192)
              - *(void *)(v37 + 184);
          if (v11)
          {
            uint64_t v67 = v11[47];
            unint64_t v68 = *(void *)(v67 + 72);
            unint64_t v69 = *(void *)(v67 + 88);
            if (v68 > v69) {
              uint64_t v56 = v68 + v56 - v69;
            }
          }

          if (v55 > (unint64_t)v56)
          {
            uint64_t v34 = 28LL;
            if (!v54) {
              goto LABEL_653;
            }
            uint64_t v55 = v56;
            if (v56 < 1) {
              goto LABEL_653;
            }
          }

          uint64_t v56 = *(void *)(v37 + 48LL * v62 + 72) - v366[v62 + 104];
          if (v55 <= v56) {
            goto LABEL_105;
          }
          if (v63) {
            v56 += *(void *)(v37 + 40LL * v343 + 200);
          }
          if (v55 > v56) {
            break;
          }
LABEL_103:
          if (!v63) {
            goto LABEL_108;
          }
          pthread_mutex_unlock((pthread_mutex_t *)v366 + 6);
          pthread_mutex_lock((pthread_mutex_t *)v366 + 8);
          sub_100044720(v9, (uint64_t)v352, 0, 0);
          BOOL v63 = sub_100044814(v9, (uint64_t)v366, v343, 1, (uint64_t)v352, a4) != 0;
          sub_100045054(v9, (uint64_t)v352);
          pthread_mutex_unlock((pthread_mutex_t *)v366 + 8);
          pthread_mutex_lock((pthread_mutex_t *)v366 + 6);
          unsigned int v54 = a6;
          uint64_t v56 = 0LL;
          uint64_t v55 = v342;
LABEL_105:
          if (v55 <= v56)
          {
LABEL_108:
            BOOL v70 = v62 == v332;
            if (v338) {
              BOOL v71 = v62 == v332;
            }
            else {
              BOOL v71 = 0;
            }
            unsigned int v58 = v335;
LABEL_112:
            unsigned int v72 = v340;
            goto LABEL_113;
          }
        }

        if (v54 && v56 > 0)
        {
          uint64_t v55 = v56;
          goto LABEL_103;
        }

        int v57 = v330;
        v331 &= v330 == 0;
      }

      BOOL v70 = v62 == v332;
      if (v338) {
        BOOL v71 = v62 == v332;
      }
      else {
        BOOL v71 = 0;
      }
      unsigned int v72 = v340;
      unint64_t v91 = &v366[v62];
      if ((v335 & 0x40) != 0)
      {
        if (v91[106] >= v342) {
          goto LABEL_113;
        }
        sub_100037DC8((uint64_t)a1);
        uint64_t v55 = v342;
        sub_100013D94("%s:%d: %s Bogus attempt to perform metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n");
LABEL_684:
        uint64_t v34 = 28LL;
        goto LABEL_654;
      }

      if (v91[104] - v91[106] < v342)
      {
        sub_100037DC8((uint64_t)a1);
        uint64_t v55 = v342;
        sub_100013D94( "%s:%d: %s Bogus attempt to perform non-metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n");
        goto LABEL_684;
      }

LABEL_132:
      int v84 = (v72 >> 6) & 1;
      uint64_t v358 = 0LL;
      uint64_t v359 = 0LL;
      v350[2] = 0LL;
      v350[0] = 0LL;
      uint64_t v85 = v74[v62 + 196];
      if (!v85) {
        LOBYTE(v84) = 1;
      }
      char v86 = v82 | v84;
      if ((v58 & 0x8400) != 0) {
        char v87 = 1;
      }
      else {
        char v87 = v86;
      }
      if ((v87 & 1) != 0)
      {
        if (((v82 | ((v72 & 0x40) >> 6)) & 1) != 0)
        {
          unsigned int v319 = 0;
          v282 = 0LL;
          int v104 = v82 || v292;
          BOOL v329 = v62 == v293;
          int v105 = !v320;
          BOOL v279 = v320;
          unsigned int v106 = v58;
          goto LABEL_214;
        }

        int v336 = v58;
LABEL_190:
        if (!v366[v62 + 186] || (v336 & 0x100) != 0) {
          goto LABEL_210;
        }
        *(void *)&__int128 v363 = v351;
        *((void *)&v363 + 1) = v55;
        LOBYTE(v364) = v331 & 1;
        BYTE8(v365) = a6 == 0LL;
        *((void *)&v364 + 1) = 0LL;
        *(void *)&__int128 v365 = 0LL;
        if (v71)
        {
          *((void *)&v364 + 1) = v339;
          *(void *)&__int128 v365 = v338 - v339;
        }

        sub_10004AB00((unint64_t)v366, v62, (uint64_t)&v363, &v360);
        if (v107 != 28)
        {
          int v108 = v107;
          if (!v107)
          {
            int v109 = v361;
            int64_t v351 = v360;
            if (a6) {
              uint64_t v55 = *((void *)&v360 + 1);
            }
            char v297 = 1;
LABEL_203:
            LOBYTE(v72) = v340;
            if (v109) {
              BOOL v110 = 0;
            }
            else {
              BOOL v110 = v71;
            }
            if (v110)
            {
              unint64_t v338 = 0LL;
              unint64_t v339 = 0LL;
              if ((v336 & 0x200) == 0)
              {
                *(_BYTE *)(v9 + 636) = 1;
                *(void *)(v9 + 1784) = 0LL;
              }
            }

            unsigned __int8 v331 = v109 != 0;
LABEL_210:
            BOOL v329 = v62 == v293;
            if ((v87 & 1) != 0)
            {
              unsigned int v319 = 0;
              int v104 = 0;
              v282 = 0LL;
              int v105 = !v320;
              BOOL v279 = v320;
            }

            else
            {
              BOOL v279 = 0;
              int v104 = 0;
              v282 = &v351;
              int v105 = 1;
              unsigned int v319 = 1;
            }

            unsigned int v106 = v336;
LABEL_214:
            uint64_t v295 = 0LL;
            unint64_t v314 = 0LL;
            unint64_t v111 = v37 + 48LL * v62;
            v316 = (unint64_t *)(v111 + 48);
            v310 = (unsigned int *)(v111 + 64);
            unint64_t v287 = (_DWORD *)(v111 + 68);
            int v302 = v106 & 0x400;
            int v290 = v105 ^ 1;
            char v278 = v104;
            int v298 = v104 | ((v72 & 0x40) >> 6);
            char v280 = v105;
            int v281 = !v71;
            uint64_t v112 = v325;
            unsigned int v335 = v106;
            unint64_t v285 = v81;
            while (2)
            {
              if (v329 && v351 >= (uint64_t)v334 && v351 < (uint64_t)v333)
              {
                BOOL v114 = v279;
                else {
                  unint64_t v115 = v333;
                }
                int64_t v351 = v115;
              }

              if ((v105 & 1) == 0 && v351 >= (uint64_t)v339 && v351 < (uint64_t)v338)
              {
                BOOL v117 = v329;
                else {
                  unint64_t v118 = v338;
                }
                int64_t v351 = v118;
              }

              uint64_t v119 = v366[v62 + 196];
              if (v119)
              {
                LODWORD(v119) = sub_10002D4B0(v119, v282);
                int v301 = 0;
              }

              unint64_t v120 = v351;
              if (v351 >= *v316)
              {
                unint64_t v120 = 0LL;
                int64_t v351 = 0LL;
              }

              LODWORD(v324) = 0;
              unsigned int v321 = 0;
              unint64_t v121 = 0LL;
              int v283 = v119;
              int v305 = v319 & v119;
              int v288 = -1;
              unint64_t v317 = v341;
              uint64_t v122 = v314;
              while (1)
              {
                unint64_t v327 = v121;
                unint64_t v123 = v120 / *(unsigned int *)(v37 + 36) / *(unsigned int *)(v37 + 40);
                unint64_t v314 = v122;
                if (*v287)
                {
                  unsigned int v124 = *(_DWORD *)(v37 + 44);
                  unsigned int v125 = v123 / v124;
                  uint64_t v126 = v357;
                  if (v123 / v124 == v288)
                  {
                    LODWORD(v127) = v120 / *(unsigned int *)(v37 + 36) / *(unsigned int *)(v37 + 40);
                    unsigned int v125 = v288;
                  }

                  else
                  {
                    unint64_t v128 = v120;
                    uint64_t v130 = *(void *)(v366[v62 + 111] + 8LL * v125);
                    if (v357)
                    {
                      sub_100038824(v357);
                      uint64_t v357 = 0LL;
                    }

                    unint64_t v353 = v37;
                    unint64_t v354 = __PAIR64__(v125, v62);
                    uint64_t v131 = sub_10003B574( *(void *)(v9 + 392),  0x40000000LL,  v130,  &xmmword_10005BA54,  &v353,  0LL,  0LL,  0LL,  &v357);
                    if ((_DWORD)v131)
                    {
                      uint64_t v34 = v131;
                      unsigned int v54 = a6;
                      uint64_t v122 = v314;
LABEL_571:
                      unint64_t v120 = v128;
LABEL_572:
                      if (v321 <= *v310)
                      {
                        if (v283)
                        {
                          if (v319)
                          {
                            if ((_DWORD)v34) {
                              BOOL v245 = 0;
                            }
                            else {
                              BOOL v245 = v120 > v351;
                            }
                            if (v245)
                            {
                              unint64_t v246 = v358 || !v122
                                   ? *(void *)(v112 + 32LL * v317 + 48) + v358 + v359
                                   : v122 + v295;
                              if (v120 <= v246) {
                                unint64_t v120 = v246;
                              }
                            }
                          }

                          else
                          {
                            unint64_t v120 = 0LL;
                          }

                          uint64_t v247 = v366[v62 + 196];
                          unint64_t v244 = v120;
                          char v248 = 0;
LABEL_593:
                          sub_10002D558(v247, v244, v248);
                          unsigned int v54 = a6;
                        }
                      }

                      else if (v283)
                      {
                        if (v319) {
                          unint64_t v244 = *(void *)(v366[47] + 48LL * v62 + 48);
                        }
                        else {
                          unint64_t v244 = 0LL;
                        }
                        uint64_t v247 = v366[v62 + 196];
                        char v248 = 1;
                        goto LABEL_593;
                      }

LABEL_594:
                      uint64_t v249 = v358;
                      uint64_t v325 = v112;
                      if (!v358 && v122)
                      {
                        uint64_t v254 = *(unsigned int *)(v37 + 36);
                        unint64_t v255 = v295;
                        uint64_t v358 = v122;
                        uint64_t v359 = v295 % v254;
                        if ((_DWORD)v34) {
                          goto LABEL_654;
                        }
                        uint64_t v249 = v122;
                        if (!v295) {
                          goto LABEL_628;
                        }
                      }

                      else
                      {
                        if (v358 || (_DWORD)v34)
                        {
                          if ((_DWORD)v34) {
                            goto LABEL_654;
                          }
                        }

                        else
                        {
                          if (v321 == *(_DWORD *)(v37 + 48LL * v62 + 64) + 1)
                          {
                            int v52 = v330;
                            if ((v340 & 4) == 0)
                            {
                              pthread_mutex_unlock((pthread_mutex_t *)v366 + 6);
                              pthread_mutex_lock((pthread_mutex_t *)v366 + 8);
                              sub_100044720(v9, (uint64_t)v352, 0, 0);
                              uint64_t v250 = sub_100044814(v9, (uint64_t)v366, v343, 1, (uint64_t)v352, a4);
                              sub_100045054(v9, (uint64_t)v352);
                              pthread_mutex_unlock((pthread_mutex_t *)v366 + 8);
                              pthread_mutex_lock((pthread_mutex_t *)v366 + 6);
                              unsigned int v54 = a6;
                              if (v250) {
                                int v52 = v315;
                              }
                            }

                            unint64_t v341 = v317;
                            if (v357)
                            {
                              sub_100038824(v357);
                              unsigned int v54 = a6;
                              uint64_t v357 = 0LL;
                              unint64_t v341 = v317;
                            }

                            goto LABEL_69;
                          }

                          uint64_t v249 = 0LL;
                        }

LABEL_628:
                        unint64_t v255 = v359 + *(void *)(v112 + 32LL * v317 + 48);
                        uint64_t v122 = v249;
                      }

                      unint64_t v296 = v255;
                      if ((_DWORD)v62 == 1) {
                        v255 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36LL)));
                      }
                      int v256 = sub_10004419C((void *)v9, (uint64_t)v366, v255, v122);
                      if (v256)
                      {
                        int v270 = v256;
                        if (sub_100013538(*(void *)(*a1 + 392LL)))
                        {
                          if (sub_100037DC8((uint64_t)a1) == 13)
                          {
                            if ((_DWORD)v62 == 1) {
                            sub_100013D94( "%s:%d: %s found free extent (0x%llx:0x%llx) which should not be free!: %d\n",  "spaceman_alloc",  7903,  v312,  v296,  v122,  v270);
                            }
                          }

                          else
                          {
                            if ((_DWORD)v62 == 1) {
                            sub_100013D94( "%s:%d: %s found free extent (0x%llx:0x%llx) which should not be free!: %d\n",  "spaceman_alloc",  7903,  (const char *)(a1[48] + 208LL),  v296,  v122,  v270);
                            }
                          }
                        }

                        uint64_t v258 = sub_100005194(v9);
                      }

                      else
                      {
                        unint64_t v257 = *(void *)(v37 + 48LL * v62 + 48);
                        if ((v340 & 4) != 0 || v358 < 1) {
                          goto LABEL_685;
                        }
                        if (*(_BYTE *)(v9 + 627))
                        {
                          uint64_t v34 = 30LL;
                          goto LABEL_654;
                        }

                        if (v357)
                        {
                          sub_100038824(v357);
                          uint64_t v357 = 0LL;
                        }

                        if (v356)
                        {
                          sub_100038824(v356);
                          uint64_t v356 = 0LL;
                        }

                        if (v355)
                        {
                          sub_100038824(v355);
                          uint64_t v355 = 0LL;
                        }

                        uint64_t v258 = sub_10003CF9C(v366, 0LL, a4);
                        if (!(_DWORD)v258)
                        {
                          unint64_t v259 = v296;
                          if ((_DWORD)v62 == 1) {
                          uint64_t v34 = sub_10004AF18((void *)v9, v11, (uint64_t)v366, v259, v122, a4, 0, v335);
                          }
                          sub_10002CEE8(v366[v62 + 196], v296, v122);
                          if ((_DWORD)v34)
                          {
                            int v260 = sub_100037DC8((uint64_t)a1);
                            int v261 = (const char *)(a1 + 499);
                            if (v260 != 13) {
                              int v261 = (const char *)(a1[48] + 208LL);
                            }
                            sub_100013D94( "%s:%d: %s Failed to set bits for allocation %lld:%lld: %d\n",  "spaceman_alloc",  7948,  v261,  v296,  v122,  v34);
                            int v52 = v315;
                            if (!v319) {
                              goto LABEL_654;
                            }
                            sub_10002B1A8(v366[v62 + 196]);
                            char v50 = 1;
                            unsigned int v54 = a6;
                            unint64_t v49 = v317;
                            if ((v291 & 1) != 0) {
                              goto LABEL_654;
                            }
                            goto LABEL_68;
                          }

LABEL_685:
                          if (v296 + v122 >= v257) {
                            unint64_t v267 = 0LL;
                          }
                          else {
                            unint64_t v267 = v296 + v122;
                          }
                          if ((_DWORD)v62 == 1) {
                          unint64_t *v304 = v296;
                          }
                          if (a6) {
                            *a6 = v122;
                          }
                          int v268 = v366;
                          unsigned int v269 = (void *)v366[198];
                          if (v269)
                          {
                            v269[10] += v122;
                            if ((v278 & 1) != 0)
                            {
                              ++v269[3];
LABEL_704:
                              if ((*(_DWORD *)(v268[v62 + 186]
                                              + 4
                                              * (v268[17 * v62 + 152 + 4 * v307]
                                               / (unint64_t)*(unsigned int *)(v37 + 36))) & 0xFFFFFFu) <= v307)
                              {
                                int v271 = sub_100031D18(v9, (uint64_t)v268, v62, v307);
                                uint64_t v34 = 0LL;
                                if (!v271 || v271 == 28) {
                                  goto LABEL_654;
                                }
                                sub_100037DC8((uint64_t)a1);
                                sub_100013D94("%s:%d: %s failed to update chunk for alloc zone %d: %d\n");
                              }

LABEL_732:
                              uint64_t v34 = 0LL;
                              goto LABEL_654;
                            }
                          }

                          else if ((v278 & 1) != 0)
                          {
                            goto LABEL_704;
                          }

                          if ((v335 & 0x200) != 0)
                          {
                            unint64_t v272 = *(void *)(v9 + 1752);
                            char v273 = __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36LL)));
                            unint64_t v274 = 0x4000000000000000uLL >> v273;
                            if ((_DWORD)v62 == (((0x4000000000000000uLL >> v273) & v272) != 0)
                              && (uint64_t v275 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v273, v267 >= (v275 & v272))
                              && v267 < ((*(void *)(v9 + 1760) + v272) & v275))
                            {
                              uint64_t v34 = 0LL;
                              if ((_DWORD)v62 == 1) {
                                unint64_t v276 = v274;
                              }
                              else {
                                unint64_t v276 = 0LL;
                              }
                              unint64_t v272 = v276 | v267;
                            }

                            else
                            {
                              uint64_t v34 = 0LL;
                            }

                            *(void *)(v9 + 1768) = v272;
                            goto LABEL_654;
                          }

                          if ((v335 & 0x142) != 0
                            && (_DWORD)v62 == (((v303 << __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36LL)))) & 0x4000000000000000LL) != 0))
                          {
                            if (v306) {
                              sub_100030EFC((uint64_t)v268, v62, v311, v267);
                            }
                          }

                          else
                          {
                            v268[v62 + 124] = v267;
                            if ((v331 & 1) != 0 && sub_100032204((uint64_t)v268, v62, v267, 5LL))
                            {
                              *(void *)&__int128 v363 = v267;
                              *((void *)&v363 + 1) = 1LL;
                              LOBYTE(v364) = 1;
                              BYTE8(v365) = 1;
                              *((void *)&v364 + 1) = 0LL;
                              *(void *)&__int128 v365 = 0LL;
                              sub_10004AB00((unint64_t)v366, v62, (uint64_t)&v363, &v360);
                              if (v277)
                              {
                                if (v277 != 28)
                                {
                                  sub_100037DC8((uint64_t)a1);
                                  sub_100013D94("%s:%d: %s failed to move roving pointer for dev %d error %d\n");
                                }
                              }

                              else if (*((uint64_t *)&v360 + 1) >= 1)
                              {
                                uint64_t v34 = 0LL;
                                v366[v62 + 124] = v360;
                                goto LABEL_654;
                              }
                            }
                          }

                          goto LABEL_732;
                        }
                      }

                      uint64_t v34 = v258;
                      goto LABEL_654;
                    }

                    unsigned int v124 = *(_DWORD *)(v37 + 44);
                    uint64_t v126 = v357;
                    unint64_t v120 = v128;
                    int v288 = v125;
                    unint64_t v127 = v128 / *(unsigned int *)(v37 + 36) / *(unsigned int *)(v37 + 40);
                  }

                  unint64_t v128 = v120;
                  BOOL v129 = (uint64_t *)(*(void *)(v126 + 56) + 8LL * (v123 - v124 * v125) + 40);
                  LODWORD(v123) = v127;
                  uint64_t v122 = v314;
                }

                else
                {
                  unint64_t v128 = v120;
                  BOOL v129 = (uint64_t *)(v366[v62 + 111] + 8LL * v123);
                }

                uint64_t v132 = *v129;
                unint64_t v353 = v37;
                unint64_t v354 = __PAIR64__(v123, v62);
                uint64_t v309 = v132;
                uint64_t v133 = sub_10003B574( *(void *)(v9 + 392),  0x40000000LL,  v132,  &xmmword_10005BA64,  &v353,  0LL,  0LL,  0LL,  &v356);
                if ((_DWORD)v133)
                {
                  uint64_t v34 = v133;
                  unsigned int v54 = a6;
                  goto LABEL_571;
                }

                uint64_t v112 = *(void *)(v356 + 56);
                unsigned int v134 = *(_DWORD *)(v112 + 32);
                uint64_t v136 = *(unsigned int *)(v37 + 36);
                unsigned int v135 = *(_DWORD *)(v37 + 40);
                unint64_t v137 = v135 * (unint64_t)v134;
                unsigned int v54 = a6;
                unint64_t v120 = v128;
                unsigned int v138 = v321 == *v310 ? v351 / v136 - v137 + 1 : *(_DWORD *)(v112 + 36);
                unint64_t v139 = v327;
                unint64_t v140 = v128 / v136 - v135 * (unint64_t)v134;
                unint64_t v317 = v140;
                uint64_t v34 = 0LL;
LABEL_540:
                if (!v358 && v122 != v55)
                {
                  BOOL v234 = v139 || !v122 ? (_DWORD)v34 == 0 : (v34 | v302) == 0;
                  BOOL v235 = !v234;
                  if (((v235 | v301) & 1) == 0)
                  {
                    unint64_t v236 = v120;
                    uint64_t v237 = v122;
                    uint64_t v238 = v112;
                    unint64_t v239 = v139;
                    sub_100038824(v356);
                    unint64_t v121 = v239;
                    uint64_t v112 = v238;
                    uint64_t v122 = v237;
                    unint64_t v120 = v236;
                    unsigned int v54 = a6;
                    uint64_t v356 = 0LL;
                    if (++v321 <= *v310) {
                      continue;
                    }
                  }
                }

                goto LABEL_572;
              }

              unint64_t v286 = v138 - 1;
              unint64_t v341 = v140;
              unsigned int v284 = v138;
              unint64_t v318 = v138;
              __int16 v141 = v335;
              uint64_t v326 = *(void *)(v356 + 56);
              unint64_t v308 = v137;
LABEL_259:
              if (v324 <= 2)
              {
                unsigned int v143 = *(_DWORD *)(v37 + 36);
              }

              else
              {
                uint64_t v142 = v362;
                unsigned int v143 = *(_DWORD *)(v37 + 36);
                if (!((v297 ^ 1) & 1 | ((uint64_t)v362 < 1)) && v55 <= 2 * v143)
                {
                  if (v356)
                  {
                    sub_100038824(v356);
                    unsigned int v54 = a6;
                    uint64_t v356 = 0LL;
                    uint64_t v142 = v362;
                  }

                  char v297 = 0;
                  int64_t v351 = *((void *)&v361 + 1);
                  if (v54) {
                    uint64_t v55 = v142;
                  }
                  unsigned __int8 v331 = BYTE8(v362) != 0;
                  LOBYTE(v105) = v280;
                  int v240 = v281;
                  if (BYTE8(v362)) {
                    int v240 = 1;
                  }
                  if (v240) {
                    unint64_t v241 = v339;
                  }
                  else {
                    unint64_t v241 = 0LL;
                  }
                  unint64_t v242 = v338;
                  if (!v240) {
                    unint64_t v242 = 0LL;
                  }
                  unint64_t v338 = v242;
                  unint64_t v339 = v241;
                  if ((v240 & 1) == 0 && (v141 & 0x200) == 0)
                  {
                    unint64_t v338 = 0LL;
                    unint64_t v339 = 0LL;
                    unsigned __int8 v331 = 0;
                    char v297 = 0;
                    *(_BYTE *)(v9 + 636) = 1;
                    *(void *)(v9 + 1784) = 0LL;
                  }

                  continue;
                }
              }

              break;
            }

            uint64_t v144 = v112 + 32 * v341;
            unint64_t v145 = *(void *)(v144 + 48);
            v328 = (void *)(v144 + 48);
            unint64_t v146 = v137 + v341;
            if (v145 != (v137 + v341) * v143)
            {
              int v148 = sub_100037DC8((uint64_t)a1);
              unsigned int v149 = (const char *)(a1 + 499);
              if (v148 != 13) {
                unsigned int v149 = (const char *)(a1[48] + 208LL);
              }
              sub_100013D94( "%s:%d: %s skip bad chunk info ci @ block %lld (cib %lld) ci_index 0x%x ci_addr 0x%llx (expect 0x%llx)\n",  "spaceman_alloc",  7422,  v149,  v309,  *(void *)(v112 + 8),  v341,  *v328,  v146 * *(unsigned int *)(v37 + 36));
              unint64_t v150 = *(unsigned int *)(v37 + 36) + *(unsigned int *)(v37 + 36) * v146;
              unsigned int v54 = a6;
LABEL_344:
              unint64_t v139 = 0LL;
              if (v150 >= *v316) {
                unint64_t v120 = 0LL;
              }
              else {
                unint64_t v120 = v150;
              }
              goto LABEL_347;
            }

            if (v321 == *v310 && v351 / v143 - v137 == v341) {
              uint64_t v147 = v351 - v145;
            }
            else {
              uint64_t v147 = *(_DWORD *)(v112 + 32 * v341 + 56) & 0xFFFFFLL;
            }
            if (v329 && v334 > v145 && v334 < v147 + v145 && v334 - v145 < v147) {
              uint64_t v147 = v334 - v145;
            }
            if (v320)
            {
              unint64_t v151 = v339 - v145;
              BOOL v152 = v339 <= v145 || v339 >= v147 + v145;
              int v153 = v152;
              char v154 = v319;
              if (v152) {
                char v154 = 1;
              }
              int v155 = v153 ^ 1;
              if (v151 >= v147) {
                unint64_t v151 = v147;
              }
              if ((v154 & 1) != 0)
              {
                int v156 = v155;
              }

              else
              {
                uint64_t v147 = v151;
                int v156 = 0;
              }
            }

            else
            {
              int v156 = 0;
            }

            uint64_t v157 = v120 - v145;
            if (v329 && v333 > v145 && v333 < v147 + v145)
            {
              if (v333 - v145 > v157) {
                uint64_t v157 = v333 - v145;
              }
              unint64_t v120 = v157 + v145;
              if (v157 > 0) {
                unint64_t v139 = 0LL;
              }
            }

            if (v320 && v338 > v145 && v338 < v147 + v145)
            {
              if ((v319 & 1) != 0)
              {
                int v156 = 1;
                goto LABEL_305;
              }

              if (v338 - v145 > v157) {
                uint64_t v157 = v338 - v145;
              }
              unint64_t v120 = v157 + v145;
              if (v157 > 0) {
                unint64_t v139 = 0LL;
              }
              if (!v54)
              {
LABEL_391:
                uint64_t v192 = v326 + 32 * v341;
                int64_t v193 = *(_DWORD *)(v192 + 60) & 0xFFFFF;
                if (!v139 || v193 < (*(_DWORD *)(v192 + 56) & 0xFFFFFu) && (uint64_t)(v55 - v139) > v193)
                {
                  if ((_DWORD)v193)
                  {
                    if (v341 >= v286
                      || (uint64_t v194 = v326 + 32 * (v341 + 1),
                          unsigned int v195 = *(_DWORD *)(v194 + 60) & 0xFFFFF,
                          v55 <= v195 + v193))
                    {
                      unint64_t v139 = 0LL;
                    }

                    else
                    {
                      unint64_t v139 = 0LL;
                      if (v195 < (*(_DWORD *)(v194 + 56) & 0xFFFFFu)) {
                        int v156 = 1;
                      }
                    }
                  }

                  else
                  {
                    unint64_t v139 = 0LL;
                    int v156 = 2;
                  }
                }
              }
            }

            else
            {
LABEL_305:
              if (!v54) {
                goto LABEL_391;
              }
            }

            if (v329 && v333 >= v147 + v145 && v334 <= v157 + v145) {
              int v156 = 2;
            }
            if (v156) {
              BOOL v159 = 0;
            }
            else {
              BOOL v159 = v320;
            }
            BOOL v161 = v339 <= v157 + v145 && v338 >= v147 + v145;
            if (v159) {
              unsigned int v162 = v161;
            }
            else {
              unsigned int v162 = v156;
            }
            if (v54)
            {
              uint64_t v163 = v326;
              if ((*(_DWORD *)(v326 + 32 * v341 + 60) & 0xFFFFF) == 0) {
                unsigned int v162 = 2;
              }
            }

            else
            {
              uint64_t v163 = v326;
            }

            uint64_t v164 = v163 + 32 * v341;
            uint64_t v166 = *(void *)(v164 + 64);
            unsigned int v165 = (uint64_t *)(v164 + 64);
            if (!v166 && ((*(_DWORD *)(v163 + 32 * v341 + 56) ^ *(_DWORD *)(v163 + 32 * v341 + 60)) & 0xFFFFF) != 0) {
              unsigned int v162 = 2;
            }
            unint64_t v322 = v120;
            if (((v162 == 0) & v331) == 1)
            {
              unint64_t v167 = v139;
              BOOL v168 = sub_100032204((uint64_t)v366, v62, v145, v55);
              unint64_t v139 = v167;
              unint64_t v120 = v322;
              unsigned int v54 = a6;
              unsigned int v162 = v168;
            }

            if (v162 > v319)
            {
              unint64_t v150 = v120 + v147 - v157;
              BOOL v169 = v329;
              if (v150 < v334) {
                BOOL v169 = 0;
              }
              __int16 v141 = v335;
              uint64_t v112 = v326;
              unint64_t v137 = v308;
              if (v169 && v150 < v333) {
                goto LABEL_343;
              }
              int v170 = v290;
              if (v150 < v339) {
                int v170 = 0;
              }
              if (v170 == 1 && v150 < v338) {
LABEL_343:
              }
                unint64_t v150 = *v328 + (*(_DWORD *)(v326 + 32 * v341 + 56) & 0xFFFFF);
              goto LABEL_344;
            }

            unint64_t v324 = (v324 + 1);
            uint64_t v171 = *v165;
            uint64_t v355 = 0LL;
            if (v171)
            {
              uint64_t v172 = v62;
              unint64_t v173 = v139;
              uint64_t v174 = sub_10003B574( *(void *)(v9 + 392),  0x40000000LL,  v171,  &xmmword_10005BA74,  0LL,  0LL,  0LL,  0LL,  &v355);
              if ((_DWORD)v174)
              {
                uint64_t v34 = v174;
                unint64_t v317 = v341;
                unsigned int v54 = a6;
                uint64_t v112 = v326;
                uint64_t v122 = v314;
                unint64_t v120 = v322;
                unint64_t v139 = v173;
                uint64_t v62 = v172;
                goto LABEL_540;
              }

              uint64_t v175 = v355;
              unint64_t v120 = v322;
              unint64_t v139 = v173;
              uint64_t v62 = v172;
              if (!v139)
              {
LABEL_435:
                unint64_t v323 = v120;
                if (v175)
                {
                  if (v366[v62 + 196])
                  {
                    if (v147 <= v157)
                    {
                      uint64_t v289 = 0LL;
                      uint64_t v204 = 0LL;
                    }

                    else
                    {
                      uint64_t v204 = 0LL;
                      uint64_t v289 = 0LL;
                      unint64_t v300 = v120 - v157;
                      uint64_t v205 = v157;
                      do
                      {
                        sub_10001D7E8(*(void *)(v355 + 56), v147 - v205, v205, v147, &v359, &v358);
                        if (!v358) {
                          break;
                        }
                        if (v358 > v204)
                        {
                          BOOL v206 = v204 < v55;
                          if (v302) {
                            BOOL v206 = v204 == 0;
                          }
                          if (v206)
                          {
                            uint64_t v289 = v359;
                            if (v55 >= v358) {
                              uint64_t v204 = v358;
                            }
                            else {
                              uint64_t v204 = v55;
                            }
                          }
                        }

                        if (v162) {
                          BOOL v207 = 1;
                        }
                        else {
                          BOOL v207 = v204 < v55;
                        }
                        char v208 = v298;
                        if (v207) {
                          char v208 = 0;
                        }
                        if ((v208 & 1) != 0) {
                          break;
                        }
                        sub_10002B884(v366[v62 + 196], v305, v300 + v359, v358);
                        uint64_t v205 = v358 + v359;
                      }

                      while (v358 + v359 < v147);
                    }

                    unint64_t v211 = 0LL;
                    uint64_t v358 = v204;
                    uint64_t v359 = v289;
                    if (!v162)
                    {
                      unsigned int v54 = a6;
                      if (v204 >= v55)
                      {
                        unint64_t v139 = 0LL;
                        uint64_t v34 = 0LL;
                        unint64_t v120 = v147 - v157 + v323;
LABEL_525:
                        unint64_t v317 = v341;
                        goto LABEL_538;
                      }

LABEL_469:
                      unint64_t v213 = v358;
                      if (!v54)
                      {
                        unint64_t v214 = v323;
                        goto LABEL_482;
                      }

                      unint64_t v214 = v323;
                      if (v358 > (uint64_t)v314)
                      {
                        uint64_t v215 = v359;
                        if (v162)
                        {
                          unint64_t v216 = v211;
                          unint64_t v217 = v323 - v157;
                          if ((sub_1000323A4( v9,  (uint64_t)v366,  v62,  v323 - v157 + v359,  v358,  v335,  v285,  &v350[1],  &v349) & 1) != 0)
                          {
                            unint64_t v218 = v314;
                            unint64_t v219 = v295;
                            if (v349 > v314) {
                              unint64_t v219 = v350[1];
                            }
                            uint64_t v295 = v219;
                            if (v349 > v314) {
                              unint64_t v218 = v349;
                            }
                            unint64_t v314 = v218;
                            unint64_t v213 = v358;
                            unsigned int v54 = a6;
                            unint64_t v214 = v323;
                            unint64_t v211 = v216;
                            goto LABEL_482;
                          }

                          unint64_t v213 = v358;
                          uint64_t v215 = v359;
                          unsigned int v54 = a6;
                          unint64_t v214 = v323;
                          unint64_t v211 = v216;
                        }

                        else
                        {
                          unint64_t v217 = v323 - v157;
                        }

                        uint64_t v295 = v217 + v215;
                        unint64_t v314 = v213;
                      }

LABEL_482:
                      __int16 v141 = v335;
                      unint64_t v137 = v308;
                      if (!v213 || v359 + v213 != v147)
                      {
                        if (v302 && v314)
                        {
                          unint64_t v139 = 0LL;
                          uint64_t v34 = 0LL;
                          unint64_t v120 = v147 - v157 + v214;
                          goto LABEL_525;
                        }

                        unint64_t v213 = v211;
                        if (!v211)
                        {
                          uint64_t v220 = v147 - v55;
                          if (v147 >= v55)
                          {
                            uint64_t v221 = v55;
                          }

                          else
                          {
                            uint64_t v220 = 0LL;
                            uint64_t v221 = v147;
                          }

                          int v222 = sub_10001D54C(*(void *)(v355 + 56), v220, v221, &v359);
                          unsigned int v54 = a6;
                          unint64_t v214 = v323;
                          if (v222 && v359 < v147 - 1)
                          {
                            unint64_t v213 = v147 + ~v359;
                            sub_10002B884(v366[v62 + 196], v305, v323 - v157 + v359 + 1, v213);
                            unint64_t v214 = v323;
                            unsigned int v54 = a6;
                          }

                          else
                          {
                            unint64_t v213 = 0LL;
                          }
                        }
                      }

                      uint64_t v358 = 0LL;
                      unint64_t v223 = v214 + v147 - v157;
                      BOOL v224 = v329;
                      if (v223 < v334) {
                        BOOL v224 = 0;
                      }
                      uint64_t v112 = v326;
                      if (v224 && v223 < v333) {
                        goto LABEL_502;
                      }
                      int v225 = v290;
                      if (v223 < v339) {
                        int v225 = 0;
                      }
                      if (v225 == 1 && v223 < v338)
                      {
LABEL_502:
                        unint64_t v213 = 0LL;
                        unint64_t v223 = *v328 + (*(_DWORD *)(v326 + 32 * v341 + 56) & 0xFFFFF);
                      }

                      if (v223 >= *v316) {
                        unint64_t v139 = 0LL;
                      }
                      else {
                        unint64_t v139 = v213;
                      }
                      if (v223 >= *v316) {
                        unint64_t v120 = 0LL;
                      }
                      else {
                        unint64_t v120 = v223;
                      }
                      if (v355)
                      {
                        unint64_t v226 = v120;
                        unint64_t v227 = v139;
                        sub_100038824(v355);
                        unint64_t v139 = v227;
                        uint64_t v112 = v326;
                        unint64_t v120 = v226;
                        unsigned int v54 = a6;
                      }

                      uint64_t v355 = 0LL;
                      if ((_DWORD)v324) {
                        BOOL v228 = v139 == 0;
                      }
                      else {
                        BOOL v228 = 0;
                      }
                      unsigned int v229 = v319;
                      if (!v228) {
                        unsigned int v229 = 0;
                      }
                      if (v229 == 1)
                      {
                        if (v314 | v350[0])
                        {
                          unint64_t v230 = v120;
                          int v231 = sub_10002B2B0(v366[v62 + 196], v324);
                          unint64_t v139 = 0LL;
                          if (v231)
                          {
                            uint64_t v34 = 0LL;
                            unint64_t v232 = v314;
                            unint64_t v233 = v295;
                            if (v350[0] > v314) {
                              unint64_t v233 = v350[2];
                            }
                            uint64_t v295 = v233;
                            if (v350[0] > v314) {
                              unint64_t v232 = v350[0];
                            }
                            int v301 = 1;
                            unint64_t v317 = v341;
                            uint64_t v122 = v232;
                            unsigned int v54 = a6;
                            unint64_t v120 = v230;
                            goto LABEL_540;
                          }

                          unsigned int v54 = a6;
                          unint64_t v120 = v230;
LABEL_520:
                          unint64_t v137 = v308;
                        }

                        else
                        {
                          unint64_t v139 = 0LL;
                          unint64_t v314 = 0LL;
                        }
                      }

                      goto LABEL_347;
                    }
                  }

                  else
                  {
                    if (sub_10001D5D4(*(void *)(v175 + 56), v55, v157, v147, &v359, &v358, v302 != 0))
                    {
                      unint64_t v139 = 0LL;
                      uint64_t v34 = 0LL;
                      unint64_t v317 = v341;
                      unsigned int v54 = a6;
                      uint64_t v112 = v326;
                      uint64_t v122 = v314;
                      unint64_t v120 = v323;
                      goto LABEL_540;
                    }

                    unint64_t v211 = 0LL;
                  }
                }

                else
                {
                  uint64_t v209 = v147 - v157;
                  if (v55 >= v147 - v157) {
                    unint64_t v210 = v147 - v157;
                  }
                  else {
                    unint64_t v210 = v55;
                  }
                  uint64_t v358 = v210;
                  uint64_t v359 = v157;
                  if (v55 <= v147 - v157)
                  {
                    if (!v162)
                    {
                      unint64_t v139 = 0LL;
                      uint64_t v34 = 0LL;
LABEL_537:
                      unint64_t v317 = v341;
                      unsigned int v54 = a6;
LABEL_538:
                      uint64_t v112 = v326;
LABEL_539:
                      uint64_t v122 = v314;
                      goto LABEL_540;
                    }
                  }

                  else
                  {
                    uint64_t v209 = 0LL;
                  }

                  unint64_t v212 = v209;
                  sub_10002B884(v366[v62 + 196], v305, v120, v210);
                  unint64_t v211 = v212;
                }

                unsigned int v54 = a6;
                goto LABEL_469;
              }
            }

            else
            {
              uint64_t v175 = 0LL;
              if (!v139) {
                goto LABEL_435;
              }
            }

            uint64_t v176 = v55 - v139;
            if (v162) {
              uint64_t v177 = v147;
            }
            else {
              uint64_t v177 = v176;
            }
            if (!v175
              || (uint64_t v299 = v157,
                  unint64_t v178 = v139,
                  int v179 = sub_10001D4C8(1, *(void *)(v175 + 56), 0LL, v177, &v359),
                  unint64_t v139 = v178,
                  uint64_t v180 = v299,
                  unint64_t v120 = v322,
                  !v179))
            {
              uint64_t v188 = v177 + v139;
              if (!v162 && v55 == v188)
              {
                if (v355)
                {
                  unint64_t v243 = v139;
                  sub_100038824(v355);
                  unint64_t v139 = v243;
                  unint64_t v120 = v322;
                }

                uint64_t v34 = 0LL;
                uint64_t v295 = v120 - v139;
                uint64_t v355 = 0LL;
                unint64_t v317 = v341;
                uint64_t v122 = v55;
                unsigned int v54 = a6;
                uint64_t v112 = v326;
                goto LABEL_572;
              }

              unint64_t v189 = v120 - v139;
              sub_10002B884(v366[v62 + 196], v305, v120 - v139, v177 + v139);
              if (a6 && v188 > (uint64_t)v314)
              {
                if (v162
                  && sub_1000323A4(v9, (uint64_t)v366, v62, v189, v188, v335, v285, &v350[1], &v349))
                {
                  unint64_t v190 = v349;
                  if (v349 >= v55) {
                    unint64_t v190 = v55;
                  }
                  unint64_t v349 = v190;
                  unint64_t v191 = v314;
                  if (v190 <= v314) {
                    unint64_t v189 = v295;
                  }
                  else {
                    unint64_t v189 = v350[1];
                  }
                  if (v190 > v314) {
                    unint64_t v191 = v190;
                  }
                  unint64_t v314 = v191;
                }

                else
                {
                  if (v188 >= v55) {
                    unint64_t v196 = v55;
                  }
                  else {
                    unint64_t v196 = v188;
                  }
                  unint64_t v314 = v196;
                }
              }

              else
              {
                unint64_t v189 = v295;
              }

              unint64_t v197 = v177 + v322;
              BOOL v198 = v329;
              if (v197 < v334) {
                BOOL v198 = 0;
              }
              if (v198 && v197 < v333) {
                goto LABEL_414;
              }
              int v199 = v290;
              if (v197 < v339) {
                int v199 = 0;
              }
              if (v199 == 1 && v197 < v338)
              {
LABEL_414:
                uint64_t v188 = 0LL;
                unint64_t v197 = *v328 + (*(_DWORD *)(v326 + 32 * v341 + 56) & 0xFFFFF);
              }

              unint64_t v200 = *v316;
              if (v197 < *v316) {
                unint64_t v120 = v197;
              }
              else {
                unint64_t v120 = 0LL;
              }
              if (v355)
              {
                unint64_t v201 = v120;
                sub_100038824(v355);
                unint64_t v120 = v201;
              }

              uint64_t v355 = 0LL;
              if (v197 < v200 && v188)
              {
                unint64_t v139 = v188;
                uint64_t v295 = v189;
                unsigned int v54 = a6;
                __int16 v141 = v335;
                uint64_t v112 = v326;
                goto LABEL_520;
              }

              unint64_t v139 = 0LL;
              unsigned int v54 = a6;
              __int16 v141 = v335;
              unint64_t v137 = v308;
              if (v302 && v314)
              {
                unint64_t v139 = 0LL;
                uint64_t v34 = 0LL;
                unint64_t v317 = v341;
                uint64_t v295 = v189;
                goto LABEL_538;
              }

              uint64_t v295 = v189;
              uint64_t v112 = v326;
LABEL_347:
              if (++v341 >= v318)
              {
                uint64_t v34 = 0LL;
                unint64_t v317 = v284;
                goto LABEL_539;
              }

              goto LABEL_259;
            }

            uint64_t v181 = v359;
            if (!a6) {
              goto LABEL_434;
            }
            uint64_t v182 = v359 + v139;
            if (v162)
            {
              uint64_t v183 = v322 - v139;
              unint64_t v184 = v139;
              if ((sub_1000323A4(v9, (uint64_t)v366, v62, v322 - v139, v182, v335, v285, &v350[1], &v349) & 1) != 0)
              {
                unint64_t v185 = v349;
                if (v349 >= v55) {
                  unint64_t v185 = v55;
                }
                unint64_t v349 = v185;
                unint64_t v186 = v314;
                unint64_t v187 = v295;
                if (v185 > v314) {
                  unint64_t v187 = v350[1];
                }
                uint64_t v295 = v187;
                if (v185 > v314) {
                  unint64_t v186 = v185;
                }
                unint64_t v120 = v322;
                unint64_t v139 = v184;
                uint64_t v180 = v299;
LABEL_431:
                unint64_t v314 = v186;
                if (v186 && v302)
                {
                  if (v355)
                  {
                    sub_100038824(v355);
                    unint64_t v120 = v322;
                  }

                  unint64_t v139 = 0LL;
                  uint64_t v34 = 0LL;
                  uint64_t v355 = 0LL;
                  goto LABEL_537;
                }

                uint64_t v181 = v359;
LABEL_434:
                unint64_t v202 = v120;
                sub_10002B884(v366[v62 + 196], v305, v120 - v139, v181 + v139);
                unint64_t v203 = v202 - v180;
                uint64_t v157 = v359;
                unint64_t v120 = v203 + v359;
                uint64_t v175 = v355;
                goto LABEL_435;
              }

              uint64_t v182 = v359 + v184;
              uint64_t v295 = v183;
              unint64_t v120 = v322;
              unint64_t v139 = v184;
              uint64_t v180 = v299;
            }

            else
            {
              uint64_t v295 = v322 - v139;
            }

            if (v182 >= v55) {
              unint64_t v186 = v55;
            }
            else {
              unint64_t v186 = v182;
            }
            goto LABEL_431;
          }

          else {
            sub_100013D94( "%s:%d: %s failed to search bitmap hints: %d\n",  "spaceman_alloc",  7255,  (const char *)(a1[48] + 208LL),  v108);
          }
        }

        int v109 = 0;
        goto LABEL_203;
      }

      v350[2] = v81;
      v350[0] = v55;
      unsigned int v88 = v58 & 0xFFFFDFFF;
      if ((v331 & 1) != 0) {
        int v89 = 0x2000;
      }
      else {
        int v89 = 0;
      }
      unsigned int v335 = v88 | v89;
      int v90 = sub_10002D784(v85, (unsigned __int16)v88 | (unsigned __int16)v89, (int64_t *)&v350[2], v350);
      unsigned int v54 = a6;
    }

    while (v90 == 28);
    unint64_t v313 = v350[0];
    uint64_t v295 = v350[2];
    if (v350[0] && !v350[2])
    {
      unint64_t v313 = 0LL;
      v350[0] = 0LL;
    }

    if (v294 == (_DWORD)v62) {
      int v92 = 0;
    }
    else {
      int v92 = 3;
    }
    if (v90 != 3) {
      int v92 = v90;
    }
    if (v92 != 3)
    {
      if (!v92 && v313 && v350[2])
      {
        BOOL v251 = (v58 & 0x200) == 0 && v71;
        unsigned int v319 = 1;
        char v278 = 0;
        if (v251)
        {
          if ((uint64_t)v350[2] >= (uint64_t)v338)
          {
            unint64_t v317 = v341;
            uint64_t v34 = 0LL;
          }

          else
          {
            if ((uint64_t)(v313 + v350[2]) < (uint64_t)v339)
            {
              unint64_t v317 = v341;
              uint64_t v34 = 0LL;
            }

            else
            {
              int v252 = sub_100037DC8((uint64_t)a1);
              unsigned int v253 = (const char *)(a1 + 499);
              if (v252 != 13) {
                unsigned int v253 = (const char *)(a1[48] + 208LL);
              }
              sub_100013CBC( "%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n",  "spaceman_alloc",  7208,  v253);
              char v278 = 0;
              uint64_t v34 = 0LL;
              unsigned int v319 = 1;
              *(_BYTE *)(v9 + 636) = 1;
              *(void *)(v9 + 1784) = 0LL;
              unint64_t v317 = v341;
            }

            unsigned int v54 = a6;
          }
        }

        else
        {
          unint64_t v317 = v341;
          uint64_t v34 = 0LL;
        }

        uint64_t v112 = v325;
        uint64_t v122 = v313;
        goto LABEL_594;
      }

      int v336 = v335 | 0x100;
      LOBYTE(v72) = v340;
      goto LABEL_190;
    }

    *(void *)&__int128 v93 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v93 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __int128 v347 = v93;
    __int128 v348 = v93;
    __int128 v346 = v93;
    *(void *)&__int128 v346 = v366[v62 + 196];
    *((void *)&v346 + 1) = v55;
    *(void *)&__int128 v347 = v313;
    *((void *)&v347 + 1) = sub_10002D75C(v335, v55, v313);
    *(void *)&__int128 v348 = 0LL;
    *((void *)&v348 + 1) = v335;
    unint64_t v94 = v366;
    unsigned int v95 = &v366[v62];
    BOOL v96 = v95 + 102;
    uint64_t v97 = v95[102];
    if ((v97 & 0x10) != 0)
    {
      uint64_t v98 = v95[102];
      do
      {
        *BOOL v96 = v98 | 0x20;
        sub_1000139E8( (pthread_cond_t *)v94 + 16,  (pthread_mutex_t *)v94 + 6,  8LL,  (uint64_t)"spaceman_alloc_fxc_scan_wait",  0LL);
        unint64_t v94 = v366;
        BOOL v96 = &v366[v62 + 102];
        uint64_t v98 = *v96;
      }

      while ((*v96 & 0x10) != 0);
      *BOOL v96 = v98 | 0x10;
      int v52 = v315;
      if ((v97 & 0x10) == 0 || *(void *)(v94[v62 + 196] + 128LL) < *((void *)&v347 + 1)) {
        goto LABEL_169;
      }
      uint64_t v34 = 0LL;
    }

    else
    {
      *BOOL v96 = v97 | 0x10;
      int v52 = v315;
LABEL_169:
      pthread_mutex_unlock((pthread_mutex_t *)v94 + 6);
      if ((_DWORD)v62 == 1) {
        int v99 = 42;
      }
      else {
        int v99 = 38;
      }
      LODWORD(v34) = sub_100045AA8( v9,  v99,  0LL,  (uint64_t (*)(void *, unint64_t, int64_t))sub_10004AA8C,  &v346);
      pthread_mutex_lock((pthread_mutex_t *)v366 + 6);
      if ((_DWORD)v34 == 34 || (_DWORD)v34 == 37) {
        unsigned int v101 = 0;
      }
      else {
        unsigned int v101 = v34;
      }
      if ((_DWORD)v34 == HIDWORD(v348)) {
        uint64_t v34 = v101;
      }
      else {
        uint64_t v34 = v34;
      }
      int v294 = v62;
    }

    v350[0] = 0LL;
    v350[2] = 0LL;
    int v102 = v366;
    uint64_t v103 = v366[v62 + 102];
    if ((v103 & 0x20) != 0)
    {
      j__pthread_cond_broadcast((pthread_cond_t *)v366 + 16);
      int v102 = v366;
      uint64_t v103 = v366[v62 + 102];
    }

    unsigned int v54 = a6;
    v102[v62 + 102] = v103 & 0xFFFFFFFFFFFFFFCFLL;
  }

  while (!(_DWORD)v34);
LABEL_654:
  if (v357) {
    sub_100038824(v357);
  }
  if (v356) {
    sub_100038824(v356);
  }
  if (v355) {
    sub_100038824(v355);
  }
  pthread_mutex_unlock((pthread_mutex_t *)v366 + 6);
  int v36 = v366;
  if ((_DWORD)v34)
  {
LABEL_661:
    uint64_t v262 = v36[198];
    if (v262) {
      ++*(void *)(v262 + 72);
    }
    sub_100038824(v36);
    return v34;
  }

  sub_100038824(v366);
  if ((v335 & 4) != 0) {
    return 0LL;
  }
  uint64_t v34 = 0LL;
  uint64_t v264 = *(void *)(v9 + 1760);
  if (!v264 || (v335 & 0x200) != 0) {
    return v34;
  }
  int64_t v265 = *(void *)(v9 + 1752);
  if (*(_BYTE *)(v9 + 636))
  {
    if (a6) {
      uint64_t v55 = *a6;
    }
    unint64_t v266 = *(void *)(v9 + 1784) + v55;
    *(void *)(v9 + 1784) = v266;
    if (v266 >= 0x401)
    {
      sub_100013CBC( "%s:%d: %s Found enough data to allocate outside the soft block-out range, re-enable soft block-out range\n",  "spaceman_alloc",  8085,  v312);
      uint64_t v34 = 0LL;
      *(_BYTE *)(v9 + 636) = 0;
      return v34;
    }

    return 0LL;
  }

  sub_100013CBC( "%s:%d: %s Space outside soft block-out range seems fragmented (requested %llu, but could alloc only %llu), disable s oft block-out range\n",  "spaceman_alloc",  8092,  v312,  v55,  *a6);
  uint64_t v34 = 0LL;
  *(_BYTE *)(v9 + 636) = 1;
  *(void *)(v9 + 1784) = 0LL;
  return v34;
}

uint64_t sub_10004AA8C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = *(unsigned int *)(a1 + 44);
  if (!(_DWORD)result)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (!v5)
    {
      *(void *)(a1 + 32) = a2;
      uint64_t v5 = a2;
    }

    if (*(void *)(a1 + 24) <= a3)
    {
      uint64_t result = 37LL;
    }

    else
    {
      uint64_t v6 = *(unsigned int *)(*(void *)(*(void *)(*(void *)a1 + 8LL) + 376LL) + 36LL);
      uint64_t result = sub_10002B2B0(*(void *)a1, (a2 - v5 / v6 * v6) / v6);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t result = 34LL;
    }

    *(_DWORD *)(a1 + 44) = result;
  }

  return result;
}

double sub_10004AB00(unint64_t a1, unsigned int a2, uint64_t a3, _OWORD *a4)
{
  char v6 = 0;
  __int128 v7 = *(_OWORD *)(a3 + 16);
  __int128 v8 = *(_OWORD *)(a3 + 32);
  v62[0] = *(_OWORD *)a3;
  v62[1] = v7;
  uint64_t v9 = *(void *)(a1 + 376);
  int v58 = *(unsigned __int8 *)(a3 + 16);
  int v52 = *(unsigned __int8 *)(a3 + 40);
  unint64_t v10 = *(void *)a3 / (uint64_t)*(unsigned int *)(v9 + 36);
  unint64_t v11 = v10;
  v62[2] = v8;
  unsigned int v13 = (void *)(a1 + 8LL * a2 + 1488);
  uint64_t v14 = *v13 + 4 * v10;
  uint64_t v56 = *(void *)(a3 + 8);
  *(void *)&__int128 v15 = 0LL;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  uint64_t v57 = v9;
  char v16 = (void *)(v9 + 48LL * a2 + 56);
  uint64_t v53 = v14;
  do
  {
    if (!v58)
    {
      int v29 = 1;
      uint64_t v30 = v56;
      uint64_t v14 = v53;
      unint64_t v31 = v10;
      goto LABEL_24;
    }

    uint64_t v17 = *(void *)(a1 + 376);
    if ((*(_BYTE *)(v14 + 3) & 0xC) == 0)
    {
      uint64_t v18 = v17 + 48LL * a2;
      unint64_t v19 = *(void *)(v18 + 56);
      if (v19 <= v11) {
        goto LABEL_19;
      }
      uint64_t v20 = *(void *)(a3 + 32);
      if (!v20) {
        goto LABEL_19;
      }
      unint64_t v21 = *(unsigned int *)(v17 + 36);
      uint64_t v22 = v21;
      if (v19 - 1 == v11) {
        uint64_t v22 = *(void *)(v18 + 48) % v21;
      }
      if (!sub_100013C78(v11 * v21, v22, *(void *)(a3 + 24), v20, 0LL))
      {
LABEL_19:
        if (v11 == v10)
        {
          int v29 = 1;
        }

        else
        {
          int v29 = 0;
          *(void *)&v62[0] = v11 * *(unsigned int *)(v57 + 36);
        }

        unint64_t v31 = v11;
        uint64_t v30 = v56;
        goto LABEL_24;
      }

      uint64_t v17 = *(void *)(a1 + 376);
    }

    uint64_t v23 = v17 + 48LL * a2;
    unint64_t v24 = *(void *)(v23 + 56);
    if (v24 > v11 && (uint64_t v25 = *(void *)(a3 + 32)) != 0)
    {
      unint64_t v26 = *(unsigned int *)(v17 + 36);
      uint64_t v27 = v26;
      if (v24 - 1 == v11) {
        uint64_t v27 = *(void *)(v23 + 48) % v26;
      }
      BOOL v28 = sub_100013C78(v11 * v26, v27, *(void *)(a3 + 24), v25, 0LL) != 0;
    }

    else
    {
      BOOL v28 = 0;
    }

    v6 |= v28;
    unint64_t v11 = (v11 + 1) % *v16;
    uint64_t v14 = *v13 + 4 * v11;
  }

  while (v11 != v10);
  if ((v6 & 1) == 0) {
    return *(double *)&v15;
  }
  int v29 = 1;
  uint64_t v30 = v56;
  unint64_t v31 = v10;
LABEL_24:
  if (v30 < 2) {
    goto LABEL_55;
  }
  LODWORD(v32) = *(_DWORD *)v14 & 0xFFFFFF;
  if ((*(_DWORD *)v14 & 0x2000000) != 0 && v31 < *v16 - 1LL)
  {
    int v33 = *(_DWORD *)(*v13 + 4 * v31 + 4);
    if ((v33 & 0x1000000) != 0 && (!v58 || (v33 & 0xC000000) == 0))
    {
      unsigned int v42 = v33 & 0xFFFFFF;
      int v37 = v52;
      if (v52)
      {
        uint64_t v36 = (uint64_t)a4;
        uint64_t v34 = v57;
        unsigned int v35 = *(_DWORD *)(v57 + 36);
        goto LABEL_32;
      }

      else {
        unint64_t v32 = v32;
      }
      if (v30 >= v32) {
        uint64_t v30 = v32;
      }
LABEL_55:
      uint64_t v36 = (uint64_t)a4;
      uint64_t v34 = v57;
      goto LABEL_56;
    }
  }

  uint64_t v34 = v57;
  unsigned int v35 = *(_DWORD *)(v57 + 36);
  uint64_t v36 = (uint64_t)a4;
  int v37 = v52;
  if (!v52)
  {
LABEL_36:
    *(void *)&v62[0] = v31 * v35;
    sub_10004DFE0(a1, a2, 0LL, (uint64_t)v62, v36);
    uint64_t v39 = *(void *)(v36 + 8);
    if (v37) {
      BOOL v40 = v39 < v30;
    }
    else {
      BOOL v40 = 0;
    }
    int v41 = v40;
    if (!v39 || v41)
    {
      __int128 v15 = *(_OWORD *)(v36 + 24);
      *(_OWORD *)uint64_t v36 = v15;
      *(void *)(v36 + 16) = *(void *)(v36 + 40);
      *(void *)(v36 + 24) = 0LL;
      *(void *)(v36 + 32) = 0LL;
      *(void *)(v36 + 40) = 0LL;
    }

    return *(double *)&v15;
  }

uint64_t sub_10004AF18( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, char a8)
{
  uint64_t v9 = a4;
  uint64_t v10 = a3;
  uint64_t v11 = (uint64_t)a1;
  uint64_t v107 = 0LL;
  unint64_t v111 = 0LL;
  char v109 = 0;
  __int128 v12 = *(unsigned int **)(a3 + 376);
  uint64_t v133 = 0LL;
  uint64_t v134 = 0LL;
  char v13 = __clz(__rbit64(*(unsigned int *)(a1[47] + 36LL)));
  uint64_t v132 = 0LL;
  memset(v131, 170, sizeof(v131));
  uint64_t v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & a4;
  uint64_t v15 = ((unint64_t)(a4 << v13) >> 62) & 1;
  char v16 = (pthread_mutex_t *)(a3 + (v15 << 6) + 640);
  uint64_t v17 = &v12[12 * v15 + 17];
  uint64_t v108 = v15;
  int v105 = (uint64_t *)(a3 + 8 * v15 + 888);
  unsigned int v106 = v16;
  unint64_t v121 = (pthread_mutex_t *)(a3 + 576);
  if (a2) {
    uint64_t v18 = a2;
  }
  else {
    uint64_t v18 = a1;
  }
  uint64_t v102 = (uint64_t)v18;
  unsigned int v101 = (const char *)(v18 + 499);
  uint64_t v103 = (const char *)(a2 + 499);
  unsigned int v110 = -1;
  unint64_t v115 = v12;
  uint64_t v104 = (uint64_t)&v12[12 * v15 + 17];
  while (1)
  {
    uint64_t v128 = v9;
    pthread_mutex_lock(v16);
    unint64_t v19 = v14 / v12[9];
    unint64_t v20 = v19 / v12[10];
    uint64_t v130 = v14;
    unsigned int v123 = *v17;
    if (*v17)
    {
      unsigned int v21 = v20 / v12[11];
      if (v21 != v110 || v107 == 0)
      {
        unint64_t v111 = *(void *)(*v105 + 8LL * v21);
        if (v134)
        {
          sub_100038824(v134);
          uint64_t v134 = 0LL;
        }

        v131[1] = (unint64_t)v12;
        v131[2] = __PAIR64__(v21, v108);
        uint64_t v23 = sub_10003B574( *(void *)(v11 + 392),  1073741829LL,  v111,  &xmmword_10005BA54,  &v131[1],  0LL,  0LL,  a6,  &v134);
        if ((_DWORD)v23)
        {
          uint64_t v96 = v23;
          sub_100013D94( "%s:%d: %s error getting cab %d @ %lld: %d\n",  "spaceman_modify_bits",  5492,  (const char *)(*(void *)(v11 + 384) + 208LL),  v21,  v111,  v23);
          char v95 = 0;
          goto LABEL_127;
        }

        uint64_t v107 = *(void *)(v134 + 56);
        unsigned int v110 = v21;
      }

      else
      {
        sub_10003CF10(v134, 2);
      }

      pthread_mutex_unlock(v16);
      if (sub_100039664(v134) == a6)
      {
        uint64_t v25 = v111;
        unsigned int v26 = v110;
      }

      else
      {
        uint64_t v27 = sub_1000439F4(v11, v10, a6, v131);
        if ((_DWORD)v27)
        {
          uint64_t v96 = v27;
          if (sub_100013538(v11)) {
            sub_100013D94( "%s:%d: %s failed to allocate block from internal pool: %d\n",  "spaceman_modify_bits",  5511,  (const char *)(*(void *)(v11 + 384) + 208LL),  v96);
          }
          char v95 = 0;
          char v109 = 1;
          goto LABEL_128;
        }

        uint64_t v25 = v131[0];
        unsigned int v26 = v110;
        *(void *)(*v105 + 8LL * v110) = v131[0];
        sub_10003E644(v134, a6, v25);
        uint64_t v28 = sub_10004E254(v11, (pthread_mutex_t *)v10, v111, a6);
        if ((_DWORD)v28)
        {
          uint64_t v96 = v28;
          sub_100013D94( "%s:%d: %s failed to free internal pool block %lld: %d\n",  "spaceman_modify_bits",  5518,  (const char *)(*(void *)(v11 + 384) + 208LL),  v111,  v28);
          char v95 = 0;
          char v109 = 1;
          goto LABEL_128;
        }
      }

      uint64_t v24 = v107 + 40;
      unint64_t v29 = v12[10];
      LODWORD(v20) = v20 - v12[11] * v26;
      v131[1] = (unint64_t)v12;
      LODWORD(v131[2]) = v108;
      HIDWORD(v131[2]) = v19 / v29;
      char v109 = 1;
      unint64_t v111 = v25;
    }

    else
    {
      uint64_t v24 = *v105;
      v131[1] = (unint64_t)v12;
      v131[2] = __PAIR64__(v20, v108);
      if (!v24)
      {
        char v95 = 0;
        uint64_t v96 = 22LL;
        char v16 = v106;
        goto LABEL_127;
      }
    }

    unint64_t v30 = *(void *)(v24 + 8LL * v20);
    uint64_t v31 = sub_10003B574(*(void *)(v11 + 392), 1073741829LL, v30, &xmmword_10005BA64, &v131[1], 0LL, 0LL, a6, &v133);
    if ((_DWORD)v31)
    {
      uint64_t v96 = v31;
      if (v110 == -1) {
        int v94 = 0;
      }
      else {
        int v94 = v12[11] * v110;
      }
      char v16 = v106;
      sub_100013D94( "%s:%d: %s error getting cib %d @ %lld: %d\n",  "spaceman_modify_bits",  5544,  (const char *)(*(void *)(v11 + 384) + 208LL),  v94 + v20,  v30,  v31);
      char v95 = 0;
      goto LABEL_124;
    }

    uint64_t v126 = *(void *)(v133 + 56);
    if (sub_100039664(v133) == a6)
    {
      uint64_t v116 = v30;
      char v16 = v106;
      uint64_t v32 = v126;
      goto LABEL_29;
    }

    uint64_t v33 = sub_1000439F4(v11, v10, a6, v131);
    if ((_DWORD)v33) {
      break;
    }
    *(void *)(v24 + 8LL * v20) = v131[0];
    if (v134) {
      sub_10003E644(v134, a6, v111);
    }
    uint64_t v116 = v131[0];
    sub_10003E644(v133, a6, v131[0]);
    uint64_t v34 = sub_10004E254(v11, (pthread_mutex_t *)v10, v30, a6);
    char v16 = v106;
    uint64_t v32 = v126;
    if ((_DWORD)v34)
    {
      uint64_t v96 = v34;
      sub_100013D94( "%s:%d: %s failed to free internal pool block %lld: %d\n",  "spaceman_modify_bits",  5564,  (const char *)(*(void *)(v11 + 384) + 208LL),  v30,  v34);
      char v95 = 1;
      goto LABEL_124;
    }

uint64_t sub_10004BD08(const char *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v24 = 0;
  if (sub_100037DC8((uint64_t)a1) == 13)
  {
    uint64_t v9 = *((void *)a1 + 49);
    uint64_t v10 = (uint64_t)a1;
  }

  else
  {
    uint64_t v10 = 0LL;
    uint64_t v9 = (uint64_t)a1;
  }

  else {
    uint64_t v11 = 1LL;
  }
  BOOL v12 = sub_10004E670(v9, a5);
  uint64_t v13 = 22LL;
  if (a4 >= 1 && v12)
  {
    uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v13 = sub_100044238(v9, &v25);
    if (!(_DWORD)v13)
    {
      uint64_t v14 = v25;
      uint64_t v15 = *(void *)(v25 + 1584);
      if (v15)
      {
        uint64_t v16 = *(void *)(v15 + 104) + a4;
        ++*(void *)(v15 + 96);
        *(void *)(v15 + 104) = v16;
      }

      int v17 = sub_10004419C((void *)v9, v14, a3, a4);
      if (v17)
      {
        int v18 = v17;
        if (sub_100013538(*(void *)(*(void *)a1 + 392LL)))
        {
          else {
            unint64_t v19 = (const char *)(*((void *)a1 + 48) + 208LL);
          }
          sub_100013D94( "%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be freed: %d\n",  "spaceman_free",  8194,  v19,  a3,  a4,  v18);
        }

        uint64_t v13 = 22LL;
        goto LABEL_23;
      }

      uint64_t v13 = sub_10003CF9C(v25, 0LL, a5);
      if (!(_DWORD)v13)
      {
        if (*(_BYTE *)(v9 + 629))
        {
          int v20 = sub_10004BF94((void *)v9, a3, a4, &v24);
          if (v20 | v24)
          {
            uint64_t v13 = 0LL;
            goto LABEL_23;
          }

          pthread_mutex_lock((pthread_mutex_t *)(v25 + 384));
          uint64_t v13 = sub_10004C028((void *)v9, v25, a3, a4, a5);
          sub_100051D1C(*(void *)(v9 + 384));
          if (v10 && !(_DWORD)v13)
          {
            sub_10004C110(v10, v25, a4, a5);
            sub_10003E644(v25, a5, 0LL);
          }

          uint64_t v23 = (pthread_mutex_t *)(v25 + 384);
        }

        else
        {
          pthread_mutex_lock((pthread_mutex_t *)(v25 + 512));
          uint64_t v22 = sub_10004C220(v9, v25, v11, a3, a4, a5);
          uint64_t v13 = v22;
          if (v10 && !(_DWORD)v22)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v25 + 384));
            sub_10004C110(v10, v25, a4, a5);
            sub_10003E644(v25, a5, 0LL);
            pthread_mutex_unlock((pthread_mutex_t *)(v25 + 384));
          }

          uint64_t v23 = (pthread_mutex_t *)(v25 + 512);
        }

        pthread_mutex_unlock(v23);
      }

uint64_t sub_10004BF94(void *a1, unint64_t a2, uint64_t a3, BOOL *a4)
{
  __int128 v8 = (pthread_mutex_t *)a1[52];
  pthread_mutex_lock(v8 + 8);
  pthread_mutex_lock(v8 + 6);
  uint64_t v9 = sub_10004C608(a1, (uint64_t)v8, 1, a2, a3, a4, 0LL);
  pthread_mutex_unlock(v8 + 6);
  pthread_mutex_unlock(v8 + 8);
  return v9;
}

uint64_t sub_10004C028(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  int v10 = sub_10004419C(a1, a2, a3, a4);
  if (v10)
  {
    int v11 = v10;
    if (sub_100013538((uint64_t)a1)) {
      sub_100013D94( "%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be free: %d\n",  "spaceman_freed",  5744,  (const char *)(a1[48] + 208LL),  a3,  a4,  v11);
    }
    return 22LL;
  }

  sub_100051CDC(a1[48], a3);
  return sub_10004DF24(a1, a2, a3, a4, 0, a5);
}

void sub_10004C110(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 376);
  __int128 v8 = (pthread_mutex_t *)(a2 + 576);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 576));
  uint64_t v9 = *(void *)(a1 + 376);
  unint64_t v10 = *(void *)(v9 + 88);
  BOOL v11 = v10 >= a3;
  unint64_t v12 = v10 - a3;
  if (v11)
  {
    *(void *)(v9 + 88) = v12;
  }

  else
  {
    uint64_t v13 = sub_10003965C(a1);
    sub_100013D94( "%s:%d: %s fs %lld alloc count underflow: %lld (%lld)\n",  "spaceman_free_fs_deduct_block_counts",  8118,  (const char *)(a1 + 3992),  v13,  *(void *)(*(void *)(a1 + 376) + 88LL),  a3);
    unint64_t v12 = 0LL;
    uint64_t v9 = *(void *)(a1 + 376);
    *(void *)(v9 + 88) = 0LL;
  }

  unint64_t v14 = *(void *)(v9 + 72);
  if (v14)
  {
    unint64_t v15 = v12 + a3;
    BOOL v11 = v14 >= v12;
    unint64_t v16 = v14 - v12;
    if (!v11) {
      unint64_t v16 = 0LL;
    }
    if (v15 <= v14) {
      unint64_t v16 = a3;
    }
    unint64_t v17 = *(void *)(v7 + 192);
    unint64_t v18 = v17 - v16;
    if (v17 < v16)
    {
      sub_100013D94( "%s:%d: %s spaceman fs reserve alloc count underflow: %lld (%lld)\n",  "spaceman_free_fs_deduct_block_counts",  8133,  (const char *)(a1 + 3992),  *(void *)(v7 + 192),  v16);
      unint64_t v18 = 0LL;
    }

    *(void *)(v7 + 192) = v18;
  }

  pthread_mutex_unlock(v8);
  sub_10001AAF0(a1, a4);
}

uint64_t sub_10004C220(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a2 + 376);
  uint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
  v35[0] = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
  memset(v33, 170, 24);
  uint64_t v13 = sub_100045974(a1, a2, a3, a6, 1, &v36);
  if (!(_DWORD)v13)
  {
    *(void *)&__int128 v32 = 0LL;
    *(void *)&__int128 v34 = a6;
    *((void *)&v34 + 1) = a4;
    int v30 = 8;
    unsigned int v31 = 16;
    uint64_t v14 = sub_100026464(v36, 0LL, (unint64_t *)&v34, &v31, 0x10u, v35, (unsigned int *)&v30, 1u, 0, 0LL);
    if ((_DWORD)v14 == 2) {
      goto LABEL_13;
    }
    uint64_t v13 = v14;
    if ((_DWORD)v14) {
      goto LABEL_43;
    }
    if ((void)v34 != a6) {
      goto LABEL_13;
    }
    if (v30)
    {
      uint64_t v15 = v35[0];
    }

    else
    {
      uint64_t v15 = 1LL;
      v35[0] = 1LL;
    }

    if (v15 + *((void *)&v34 + 1) <= a4)
    {
      if (v15 + *((void *)&v34 + 1) != a4) {
        goto LABEL_13;
      }
    }

    else
    {
      sub_100013D94( "%s:%d: %s range 0x%llx:%lld overlaps with recently-freed range 0x%llx:%lld\n",  "spaceman_fq_tree_insert",  4542,  (const char *)(*(void *)(a1 + 384) + 208LL),  a4,  a5,  *((void *)&v34 + 1),  v15);
      uint64_t v15 = v35[0];
      a5 += a4 - (v35[0] + *((void *)&v34 + 1));
      if (a5 < 1)
      {
        uint64_t v13 = 22LL;
        goto LABEL_43;
      }

      a4 = v35[0] + *((void *)&v34 + 1);
    }

    v33[0] = v34;
    uint64_t v16 = v15 + a5;
    *(void *)&v33[1] = v15 + a5;
    if ((void)v34)
    {
LABEL_14:
      __int128 v34 = v33[0];
      int v30 = 8;
      unsigned int v31 = 16;
      uint64_t v17 = sub_100026464(v36, 0LL, (unint64_t *)&v34, &v31, 0x10u, v35, (unsigned int *)&v30, 4u, 0, 0LL);
      if ((_DWORD)v17 == 2)
      {
LABEL_31:
        int v30 = 8 * (v16 != 1);
        uint64_t v13 = sub_10001EADC(v36, 0LL, v33, 16LL, &v33[1], v30, a6);
        if (!(_DWORD)v13)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 576));
          uint64_t v22 = v12 + 40LL * a3;
          uint64_t v25 = *(void *)(v22 + 200);
          uint64_t v23 = (void *)(v22 + 200);
          uint64_t v24 = v25;
          if (!v25) {
            *(void *)(v12 + 40LL * a3 + 216) = a6;
          }
          *uint64_t v23 = v24 + a5;
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 576));
          sub_10003E644(a2, a6, 0LL);
          if ((void)v32)
          {
            int v26 = sub_1000260EC(v36, 0LL, (unint64_t *)&v32, 0x10u, a6);
            if (v26) {
              sub_100013D94( "%s:%d: %s removal of replaced free extent failed: %d\n",  "spaceman_fq_tree_insert",  4619,  (const char *)(*(void *)(a1 + 384) + 208LL),  v26);
            }
          }

          if (sub_100047CB0(a2, a3, v36, 0))
          {
            *(void *)&__int128 v27 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v29[2] = v27;
            void v29[3] = v27;
            v29[0] = v27;
            v29[1] = v27;
            sub_100044720(a1, (uint64_t)v29, 0, 0);
            sub_100045054(a1, (uint64_t)v29);
          }

          uint64_t v13 = 0LL;
        }

        goto LABEL_43;
      }

      uint64_t v13 = v17;
      if (!(_DWORD)v17)
      {
        if ((void)v34 == a6)
        {
          if (v30)
          {
            uint64_t v18 = v35[0];
          }

          else
          {
            uint64_t v18 = 1LL;
            v35[0] = 1LL;
          }

          uint64_t v19 = v16 + *((void *)&v33[0] + 1);
          if (*((uint64_t *)&v34 + 1) <= v16 + *((void *)&v33[0] + 1))
          {
            if (*((uint64_t *)&v34 + 1) < v16 + *((void *)&v33[0] + 1))
            {
              uint64_t v20 = v18 + *((void *)&v34 + 1);
              sub_100013D94( "%s:%d: %s range 0x%llx:%lld overlaps with recently-freed range 0x%llx:%lld\n",  "spaceman_fq_tree_insert",  4584,  (const char *)(*(void *)(a1 + 384) + 208LL),  a4,  a5,  *((void *)&v34 + 1),  v18);
              if (v20 > v19)
              {
                v16 += v20 - v19;
                *(void *)&v33[1] = v16;
              }

              if (v20 >= v19) {
                uint64_t v21 = v19;
              }
              else {
                uint64_t v21 = v20;
              }
              a5 = a5 - v21 + *((void *)&v34 + 1);
            }

            else
            {
              v16 += v18;
              *(void *)&v33[1] = v16;
            }

            __int128 v32 = v34;
          }
        }

        goto LABEL_31;
      }

LABEL_43:
      sub_100038824(v36);
      return v13;
    }

uint64_t sub_10004C608( void *a1, uint64_t a2, char a3, unint64_t a4, uint64_t a5, BOOL *a6, void *a7)
{
  uint64_t v7 = a6;
  uint64_t v8 = a5;
  unint64_t v9 = a4;
  uint64_t v68 = 0LL;
  uint64_t v69 = 0LL;
  unint64_t v66 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v67 = 0LL;
  unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
  char v11 = __clz(__rbit64(*(unsigned int *)(a1[47] + 36LL)));
  unint64_t v12 = (0x4000000000000000uLL >> v11) & a4;
  BOOL v61 = v12 != 0;
  if (v12) {
    int v13 = 2;
  }
  else {
    int v13 = 1;
  }
  uint64_t v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v11) & a4;
  if ((a3 & 2) != 0) {
    *a7 = 0LL;
  }
  uint64_t v15 = *(unsigned int **)(a2 + 376);
  unint64_t v16 = *(void *)&v15[12 * (v12 != 0) + 12];
  if (v16 <= a5 || v14 > v16 - a5)
  {
    if (v12) {
      uint64_t v18 = "tier2";
    }
    else {
      uint64_t v18 = "main";
    }
    sub_100013D94( "%s:%d: %s block range %lld:%lld out of %s bounds %lld\n",  "spaceman_check_allocation_status_internal",  8292,  (const char *)(a1[48] + 208LL),  v14,  a5,  v18,  v16);
    return 22LL;
  }

  unsigned int v53 = v13;
  if (a5 <= 0)
  {
    BOOL v20 = 0;
    uint64_t v19 = 0LL;
    if ((a3 & 3) == 0) {
      goto LABEL_65;
    }
    goto LABEL_73;
  }

  BOOL v20 = 0;
  uint64_t v21 = 0LL;
  uint64_t v22 = v14 + a5;
  unint64_t v57 = &v15[12 * (v12 != 0) + 17];
  unint64_t v56 = (uint64_t *)(a2 + 8LL * (v12 != 0) + 888);
  int v60 = a3 & 3;
  int v23 = -1;
  while (1)
  {
    unint64_t v24 = v15[10];
    unint64_t v25 = v14 / v15[9];
    unint64_t v59 = v25;
    unint64_t v26 = v25 / v24;
    if (*v57) {
      break;
    }
    uint64_t v21 = *v56;
    unint64_t v32 = v25 / v24;
LABEL_25:
    unint64_t v65 = (unint64_t)v15;
    unint64_t v66 = __PAIR64__(v26, v61);
    if (!v21)
    {
      uint64_t v19 = 22LL;
LABEL_60:
      uint64_t v7 = a6;
      unint64_t v9 = a4;
      uint64_t v8 = a5;
      goto LABEL_64;
    }

    int v58 = v23;
    uint64_t v33 = v21;
    uint64_t v34 = *(void *)(v21 + 8LL * v32);
    uint64_t v35 = sub_10003B574(a1[49], 0x40000000LL, v34, &xmmword_10005BA64, &v65, 0LL, 0LL, 0LL, &v68);
    if ((_DWORD)v35)
    {
      uint64_t v19 = v35;
      sub_100013D94( "%s:%d: %s error getting cib %d @ %lld: %d\n",  "spaceman_check_allocation_status_internal",  8344,  (const char *)(a1[48] + 208LL),  v59 / v15[10],  v34,  v35);
      goto LABEL_63;
    }

    if (v14 < v22)
    {
      uint64_t v36 = *(void *)(v68 + 56);
      unint64_t v37 = v59 % v15[10];
      do
      {
        uint64_t v38 = *(void *)(v36 + 32 * v37 + 64);
        if (v38)
        {
          uint64_t v39 = sub_10003B574(a1[49], 0x40000000LL, v38, &xmmword_10005BA74, 0LL, 0LL, 0LL, 0LL, &v67);
          if ((_DWORD)v39)
          {
            uint64_t v19 = v39;
            sub_100013D94( "%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n",  "spaceman_check_allocation_status_internal",  8371,  (const char *)(a1[48] + 208LL),  v59 / v15[10],  v37,  v38,  v39);
            goto LABEL_50;
          }

          uint64_t v40 = *(void *)(v67 + 56);
          uint64_t v41 = v15[9];
          uint64_t v42 = v14 % v41;
          uint64_t v43 = v41 - v14 % v41;
          if (v22 - v14 >= v43) {
            uint64_t v44 = v43;
          }
          else {
            uint64_t v44 = v22 - v14;
          }
          if ((a3 & 1) != 0)
          {
            int v45 = sub_10001D234(v40, v42, v44);
            int v46 = a3 & 2 | v45;
            BOOL v20 = v45 == 0;
            sub_100038824(v67);
            uint64_t v67 = 0LL;
            if (!v46)
            {
              uint64_t v19 = 0LL;
              BOOL v20 = 1;
              goto LABEL_58;
            }
          }

          else if ((a3 & 2) != 0)
          {
            *a7 += sub_10001D7F0(v40, 0, v42, v44 + v42);
            sub_100038824(v67);
            uint64_t v67 = 0LL;
          }

          else
          {
            BOOL v20 = sub_10001D154(v40, v42, v44);
            sub_100038824(v67);
            uint64_t v67 = 0LL;
            if (!v20) {
              goto LABEL_57;
            }
          }
        }

        else
        {
          if (!v60)
          {
            BOOL v20 = 0;
LABEL_57:
            uint64_t v19 = 0LL;
LABEL_58:
            uint64_t v7 = a6;
            goto LABEL_75;
          }

          if (v22 - v14 >= (*(_DWORD *)(v36 + 32 * v37 + 60) & 0xFFFFF) + v14 / v15[9] * v15[9] - v14) {
            uint64_t v44 = (*(_DWORD *)(v36 + 32 * v37 + 60) & 0xFFFFF) + v14 / v15[9] * v15[9] - v14;
          }
          else {
            uint64_t v44 = v22 - v14;
          }
          BOOL v20 = 0;
          if (a7) {
            *a7 += v44;
          }
        }

        v14 += v44;
        ++v37;
      }

      while (v14 < v22);
    }

    uint64_t v19 = 0LL;
LABEL_50:
    sub_100038824(v68);
    uint64_t v68 = 0LL;
    if (v14 < v22)
    {
      uint64_t v21 = v33;
      int v23 = v58;
      if (!(_DWORD)v19) {
        continue;
      }
    }

    goto LABEL_60;
  }

  unsigned int v27 = v15[11];
  unsigned int v28 = v26 / v27;
  unint64_t v29 = v25 / v24;
  if (v26 / v27 == v23)
  {
LABEL_23:
    LODWORD(v32) = v26 - v27 * v23;
    LODWORD(v26) = v29;
    goto LABEL_25;
  }

  uint64_t v30 = *(void *)(*v56 + 8LL * v28);
  if (v69)
  {
    sub_100038824(v69);
    uint64_t v69 = 0LL;
  }

  unint64_t v65 = (unint64_t)v15;
  unint64_t v66 = __PAIR64__(v28, v61);
  uint64_t v31 = sub_10003B574(a1[49], 0x40000000LL, v30, &xmmword_10005BA54, &v65, 0LL, 0LL, 0LL, &v69);
  if (!(_DWORD)v31)
  {
    uint64_t v21 = *(void *)(v69 + 56) + 40LL;
    unsigned int v27 = v15[11];
    int v23 = v28;
    unint64_t v29 = v59 / v15[10];
    goto LABEL_23;
  }

  uint64_t v47 = v31;
  sub_100013D94( "%s:%d: %s error getting cab %d @ %lld: %d\n",  "spaceman_check_allocation_status_internal",  8319,  (const char *)(a1[48] + 208LL),  v28,  v30,  v31);
  uint64_t v19 = v47;
LABEL_63:
  uint64_t v7 = a6;
  unint64_t v9 = a4;
  uint64_t v8 = a5;
LABEL_64:
  if (!v60)
  {
LABEL_65:
    if (!(_DWORD)v19 && v20)
    {
      char v64 = 0;
      uint64_t v48 = sub_100047A44((uint64_t)a1, a2, v53, v9, v8, &v64);
      uint64_t v19 = v48;
      if (v64 && (_DWORD)v48 == 0) {
        BOOL v20 = 0;
      }
    }
  }

uint64_t sub_10004CBEC(uint64_t a1, int a2, unint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v8 = a1;
  else {
    unint64_t v9 = 0LL;
  }
  if (v9) {
    uint64_t v8 = v9[49];
  }
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&__int128 v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[2] = v10;
  v32[3] = v10;
  v32[0] = v10;
  v32[1] = v10;
  uint64_t v34 = 0LL;
  uint64_t v35 = 0LL;
  uint64_t v11 = sub_100044238(v8, &v33);
  if (!(_DWORD)v11)
  {
    unint64_t v12 = *(void **)(v33 + 376);
    if ((~a2 & 0x38) == 0) {
      panic("Absurd combination of allocation flags for spaceman %llx", v33);
    }
    if (*(void *)(*(void *)(v33 + 376) + 96LL)) {
      __asm { BR              X12 }
    }

    if ((a2 & 0x10) != 0)
    {
      uint64_t v11 = 22LL;
      goto LABEL_45;
    }

    LODWORD(v35) = 0;
    LODWORD(v34) = 1;
    int v30 = a2 & 0x40;
    pthread_mutex_lock((pthread_mutex_t *)(v33 + 384));
    pthread_mutex_lock((pthread_mutex_t *)(v33 + 576));
    uint64_t v13 = 0LL;
LABEL_15:
    uint64_t v14 = *((unsigned int *)&v35 + v13);
    uint64_t v15 = *((unsigned int *)&v34 + v13++);
    BOOL v16 = 1;
    while (1)
    {
      if (v9)
      {
        uint64_t v17 = v9[47];
        unint64_t v18 = *(void *)(v17 + 80);
        if (v18)
        {
          if (*(void *)(v17 + 88) + a3 + v9[51] > v18)
          {
            uint64_t v11 = 69LL;
            goto LABEL_43;
          }
        }
      }

      unint64_t v19 = v12[30] + v12[9] + v12[15] + v12[35] + v12[24] - v12[23];
      if (v9)
      {
        uint64_t v20 = v9[47];
        unint64_t v21 = *(void *)(v20 + 72);
        unint64_t v22 = *(void *)(v20 + 88);
        BOOL v23 = v21 >= v22;
        unint64_t v24 = v21 - v22;
        if (!v23) {
          unint64_t v24 = 0LL;
        }
        v19 += v24;
      }

      if (v19 < a3)
      {
        uint64_t v11 = 28LL;
LABEL_43:
        unint64_t v25 = (pthread_mutex_t *)v33;
        goto LABEL_44;
      }

      unint64_t v25 = (pthread_mutex_t *)v33;
      unint64_t v26 = v12[6 * v14 + 9] - *(void *)(v33 + 8 * v14 + 832);
      if (v26 < a3)
      {
        if (!v16 || v12[5 * v15 + 25] + v26 < a3 || !v16)
        {
          if (v13 != 1) {
            goto LABEL_15;
          }
          uint64_t v11 = 28LL;
LABEL_44:
          pthread_mutex_unlock(v25 + 9);
          pthread_mutex_unlock((pthread_mutex_t *)(v33 + 384));
LABEL_45:
          sub_100038824(v33);
          return v11;
        }

        pthread_mutex_unlock((pthread_mutex_t *)(v33 + 576));
        pthread_mutex_unlock((pthread_mutex_t *)(v33 + 384));
        pthread_mutex_lock((pthread_mutex_t *)(v33 + 512));
        sub_100044720(v8, (uint64_t)v32, 0, 0);
        BOOL v16 = sub_100044814(v8, v33, v15, 1LL, v32, a4) != 0;
        sub_100045054(v8, (uint64_t)v32);
        pthread_mutex_unlock((pthread_mutex_t *)(v33 + 512));
        pthread_mutex_lock((pthread_mutex_t *)(v33 + 384));
        pthread_mutex_lock((pthread_mutex_t *)(v33 + 576));
        unint64_t v26 = 0LL;
      }

      if (v26 >= a3)
      {
        unint64_t v25 = (pthread_mutex_t *)v33;
        unint64_t v27 = v33 + 8 * v14;
        *(void *)(v27 + 832) += a3;
        if (v30) {
          *(void *)(v27 + 848) += a3;
        }
        if (v9) {
          v9[51] += a3;
        }
        uint64_t v11 = 0LL;
        if ((_DWORD)v14 == 1) {
          int v28 = 16;
        }
        else {
          int v28 = 8;
        }
        *a5 = v28 | v30;
        goto LABEL_44;
      }
    }
  }

  return v11;
}

uint64_t sub_10004CFD4(uint64_t a1, unsigned int a2, unint64_t a3)
{
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t v7 = (void *)a1;
  if (v6) {
    uint64_t v7 = *(void **)(v6 + 392);
  }
  uint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = sub_100044238(v7, &v21);
  if (!(_DWORD)v8)
  {
    uint64_t v9 = (a2 >> 4) & 1;
    pthread_mutex_lock((pthread_mutex_t *)(v21 + 384));
    pthread_mutex_lock((pthread_mutex_t *)(v21 + 576));
    if (*(void *)(v21 + 8LL * v9 + 832) < *(void *)(v21 + 8LL * v9 + 848))
    {
      __int128 v10 = "T2";
      if (!(_DWORD)v9) {
        __int128 v10 = "Main";
      }
      panic( "%s, Reserved space < reserved metadata: %llu < %llu\n",  v10,  *(void *)(v21 + 832),  *(void *)(v21 + 848));
    }

    uint64_t v11 = v21;
    uint64_t v12 = v21 + 8 * v9;
    unint64_t v13 = *(void *)(v12 + 848);
    if ((a2 & 0x40) != 0)
    {
      if (v13 < a3) {
        panic("reserved metadata space underflow: %lld (%lld)\n", *(void *)(v12 + 848), a3);
      }
      *(void *)(v12 + 848) = v13 - a3;
      *(void *)(v11 + 8 * v9 + 832) -= a3;
      if (!v6) {
        goto LABEL_29;
      }
      goto LABEL_23;
    }

    uint64_t v14 = *(void *)(v12 + 832);
    if (v14 - v13 >= a3)
    {
      *(void *)(v12 + 832) = v14 - a3;
      if (v6)
      {
LABEL_23:
        unint64_t v16 = *(void *)(v6 + 408);
        BOOL v17 = v16 >= a3;
        unint64_t v18 = v16 - a3;
        if (!v17)
        {
          else {
            unint64_t v19 = (const char *)(*(void *)(a1 + 384) + 208LL);
          }
          sub_100013D94( "%s:%d: %s fs reserved space underflow: %lld (%lld)\n",  "spaceman_unreserve",  8678,  v19,  *(void *)(v6 + 408),  a3);
          unint64_t v18 = 0LL;
        }

        *(void *)(v6 + 408) = v18;
      }
    }

    else
    {
      else {
        uint64_t v15 = (const char *)(*(void *)(a1 + 384) + 208LL);
      }
      sub_100013D94( "%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n",  "spaceman_unreserve",  8669,  v15,  *(void *)(v21 + 8 * v9 + 832) - v13,  v13,  a3);
      *(void *)(v21 + 8 * v9 + 832) = v13;
      if (v6) {
        goto LABEL_23;
      }
    }

uint64_t sub_10004D208(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v27 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = sub_100044238(a1, (uint64_t *)&v27);
  if (!(_DWORD)v10)
  {
    uint64_t v11 = *(void **)&v27[5].__opaque[48];
    uint64_t v10 = sub_10003CF9C(v27, 0, a5);
    if (!(_DWORD)v10)
    {
      pthread_mutex_lock(v27 + 8);
      pthread_mutex_lock(v27 + 6);
      pthread_mutex_lock(v27 + 9);
      uint64_t v12 = *(void **)(a2 + 376);
      unint64_t v13 = v12[9];
      uint64_t v14 = a3 - v13;
      if ((uint64_t)(a3 - v13) < 0 && v11[23] < v13 - a3)
      {
        uint64_t v10 = sub_100005194((uint64_t)a1);
LABEL_30:
        pthread_mutex_unlock(v27 + 9);
        pthread_mutex_unlock(v27 + 6);
        pthread_mutex_unlock(v27 + 8);
        sub_100038824(&v27->__sig);
        return v10;
      }

      if (a4 && a3 > a4)
      {
        sub_100013D94("%s:%d: %s Quota %llu is smaller than reserve %llu\n");
LABEL_9:
        uint64_t v10 = 22LL;
        goto LABEL_30;
      }

      if (a4)
      {
        unint64_t v15 = *(void *)(a2 + 408) + v12[11];
        if (v15 > a4)
        {
          sub_100013D94( "%s:%d: %s Quota %llu is smaller than what's currently allocated and reserved %llu\n",  "spaceman_fs_bounds_set",  8743,  (const char *)(a2 + 3992),  a4,  v15);
          uint64_t v10 = 69LL;
          goto LABEL_30;
        }
      }

      if (v14 <= 0)
      {
        uint64_t v16 = v11[24];
        unint64_t v18 = v11[23] + v14;
      }

      else
      {
        uint64_t v17 = v11[23];
        uint64_t v16 = v11[24];
        if (v14 > (unint64_t)(v11[9]
                                    - v27[13].__sig
                                    + v11[30]
                                    + v11[15]
                                    + v11[35]
                                    - (*(void *)v27[13].__opaque
                                     + v17)
                                    + v16))
        {
          uint64_t v10 = 28LL;
          goto LABEL_30;
        }

        unint64_t v19 = v11[12] + v11[6];
        unint64_t v20 = 50LL;
        if (v19 >> 2 > 0x4FA) {
          unint64_t v20 = v19 / 0x64;
        }
        unint64_t v18 = v17 + v14;
        if (v18 > v19 - v20)
        {
          sub_100013D94( "%s:%d: %s %llu blocks are already reserved in container, Cannot reserve more than %llu blocks in the container\n");
          goto LABEL_9;
        }
      }

      unint64_t v21 = v12[11];
      if (v13 >= v21) {
        unint64_t v22 = v12[11];
      }
      else {
        unint64_t v22 = v12[9];
      }
      v12[9] = a3;
      if (v21 >= a3) {
        unint64_t v23 = a3;
      }
      else {
        unint64_t v23 = v21;
      }
      unint64_t v24 = v16 + v23;
      v11[23] = v18;
      v11[24] = v24;
      unint64_t v25 = v24 - v22;
      if (v24 < v22)
      {
        sub_100013D94( "%s:%d: %s sm_fs_reserve_alloc_count underflow, sm_fs_reserve_alloc_count %lld, new fs_reserve_block_count %lld , old fs_reserve_block_count %lld alloc_count %lld\n",  "spaceman_fs_bounds_set",  8795,  (const char *)(a2 + 3992),  v24,  a3,  v13,  v21);
        unint64_t v25 = 0LL;
        uint64_t v12 = *(void **)(a2 + 376);
      }

      v11[24] = v25;
      v12[10] = a4;
      sub_10003E644((uint64_t)v27, a5, 0LL);
      sub_10001AAF0(a2, a5);
      uint64_t v10 = 0LL;
      goto LABEL_30;
    }
  }

  return v10;
}

uint64_t sub_10004D4EC(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v19 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100044238(a1, (uint64_t *)&v19);
  if (!(_DWORD)result)
  {
    uint64_t v6 = *(void *)&v19[5].__opaque[48];
    uint64_t result = sub_10003CF9C(v19, 0, a3);
    if (!(_DWORD)result)
    {
      pthread_mutex_lock(v19 + 6);
      pthread_mutex_lock(v19 + 9);
      uint64_t v7 = *(void **)(a2 + 376);
      unint64_t v8 = v7[9];
      unint64_t v9 = v7[11];
      if (v9)
      {
        uint64_t v10 = sub_10003965C(a2);
        sub_100013D94( "%s:%d: %s file system %lld alloc block count is not zero: %lld/%lld\n",  "spaceman_fs_bounds_clear",  8844,  (const char *)(a2 + 3992),  v10,  v9,  v8);
        uint64_t v7 = *(void **)(a2 + 376);
        if (v7[9]) {
          goto LABEL_8;
        }
      }

      else if (v8)
      {
        goto LABEL_8;
      }

      if (!v7[10])
      {
LABEL_15:
        pthread_mutex_unlock(v19 + 9);
        pthread_mutex_unlock(v19 + 6);
        sub_100038824(&v19->__sig);
        return 0LL;
      }

uint64_t sub_10004D6A0(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[47];
  if (!*(void *)(v2 + 1248)) {
    return 0LL;
  }
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = (pthread_mutex_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_100044238(a1, (uint64_t *)&v10);
  if (!(_DWORD)v5)
  {
    uint64_t v6 = *(void *)&v10[5].__opaque[48];
    uint64_t v5 = sub_10003CF9C(v10, 0, a2);
    if (!(_DWORD)v5)
    {
      uint64_t v7 = (*(void *)(v2 + 1240) << __clz(__rbit64(*(unsigned int *)(a1[47] + 36LL))) >> 62) & 1LL;
      pthread_mutex_lock(v10 + 8);
      pthread_mutex_lock(v10 + 6);
      uint64_t v5 = sub_10004C608(a1, (uint64_t)v10, 2, *(void *)(v2 + 1240), *(void *)(v2 + 1248), &v11, &v9);
      pthread_mutex_lock(v10 + 9);
      *(void *)(v6 + 48LL * v7 + 72) += v9;
      pthread_mutex_unlock(v10 + 9);
      *(_OWORD *)(a1[47] + 1240LL) = 0u;
      pthread_mutex_unlock(v10 + 6);
      pthread_mutex_unlock(v10 + 8);
      sub_10003E644((uint64_t)v10, a2, 0LL);
    }

    sub_100038824(&v10->__sig);
  }

  return v5;
}

uint64_t sub_10004D7EC(uint64_t result, unsigned int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 376);
  uint64_t v5 = *(void *)(result + 8LL * a2 + 1488);
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  if (v5)
  {
    uint64_t v8 = *(void *)(result + 1584);
    if (v8) {
      ++*(void *)(v8 + 112);
    }
    if (*(void *)(v4 + 48LL * a2 + 56) - 1LL == a4) {
      unint64_t v9 = *(void *)(v4 + 48LL * a2 + 48) % (unint64_t)*(unsigned int *)(v4 + 36);
    }
    else {
      unint64_t v9 = *(unsigned int *)(v4 + 36);
    }
    *(_DWORD *)(v5 + 4 * a4) = (*(_DWORD *)(v5 + 4 * a4) & 0xFEFFFFFF | ((*a3 & 1) << 24)) ^ 0x1000000;
    uint64_t result = sub_10001D7E0((uint64_t)a3, 0xFFFFFFLL, 0LL, v9, &v12, &v11);
    if (v9 < 0x40 || (*(void *)&a3[2 * (v9 >> 6) - 2] & 0x8000000000000000LL) != 0) {
      unsigned int v10 = *(_DWORD *)(v5 + 4 * a4) & 0xFDFFFFFF;
    }
    else {
      unsigned int v10 = *(_DWORD *)(v5 + 4 * a4) | 0x2000000;
    }
    *(_DWORD *)(v5 + 4 * a4) = v10 & 0xFF000000 | v11 & 0xFFFFFF;
  }

  return result;
}

uint64_t sub_10004D8E8(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    if (*(_BYTE *)(a2 + 62))
    {
      if (!*(_BYTE *)(a2 + 63))
      {
        uint64_t v3 = result;
        v9.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v9.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        uint64_t result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v9);
        __darwin_time_t tv_sec = v9.tv_sec;
        int tv_nsec = v9.tv_nsec;
        *(void *)a2 = v9.tv_sec;
        tv_nsec /= 1000;
        *(_DWORD *)(a2 + 8) = tv_nsec;
        uint64_t v6 = 1000000 * tv_sec + tv_nsec;
        *(void *)(a2 + 32) = v6;
        if (v6 - *(void *)(a2 + 24) >= 1000 * (unint64_t)*(unsigned __int16 *)(a2 + 60))
        {
          uint64_t v7 = (unint64_t *)(*(void *)(v3 + 384) + 168LL);
          do
            unint64_t v8 = __ldxr(v7);
          while (__stxr(v8 + 1, v7));
          ++*(_DWORD *)(a2 + 56);
          *(void *)(a2 + 24) = *(void *)(a2 + 32);
        }
      }
    }
  }

  return result;
}

uint64_t sub_10004D9BC(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 376);
  unsigned int v5 = *(_DWORD *)(v4 + 164) & 0x7FFFFFFF;
  if (v5 <= a3) {
    return 22LL;
  }
  unsigned int v6 = *(unsigned __int16 *)(v4 + 322);
  if (v6 == 0xFFFF)
  {
    uint64_t v7 = *(void *)(a2 + 880);
  }

  else
  {
    if (v5 <= v6) {
      return sub_100005194(a1);
    }
    uint64_t v7 = *(void *)(a2 + 880);
    *(_WORD *)(v7 + 2LL * *(unsigned __int16 *)(v4 + 322)) = a3;
  }

  *(_WORD *)(v7 + 2LL * a3) = -1;
  *(_WORD *)(v4 + 322) = a3;
  sub_10003E644(a2, a4, 0LL);
  return 0LL;
}

uint64_t sub_10004DA54(uint64_t result, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 376) + 40LL * a3;
  unint64_t v6 = *(void *)(v4 + 200);
  unsigned int v5 = (unint64_t *)(v4 + 200);
  unint64_t v7 = v6 - a4;
  if (v6 >= a4)
  {
    *unsigned int v5 = v7;
  }

  else
  {
    uint64_t v11 = result;
    uint64_t result = sub_100013538(result);
    if ((_DWORD)result) {
      uint64_t result = (uint64_t)sub_100013D94( "%s:%d: %s sfq %d count underflow %lld - %lld\n",  "spaceman_decrement_free_queue_count",  5765,  (const char *)(*(void *)(v11 + 384) + 208LL),  a3,  *(void *)(*(void *)(a2 + 376) + 40LL * a3 + 200),  a4);
    }
    *(void *)(*(void *)(a2 + 376) + 40LL * a3 + 200) = 0LL;
  }

  return result;
}

uint64_t sub_10004DB0C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v7 = *(void *)(*(void *)(a2 + 376) + 152LL);
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100047D80(a1, a2, a3, (uint64_t *)&v9);
  if ((_DWORD)result == 2) {
    return 22LL;
  }
  if ((_DWORD)result) {
    return result;
  }
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) <= a4 || v9 > (v7 & 0x7FFFFFFFFFFFFFFFuLL) - a4) {
    return 22LL;
  }
  uint64_t result = 0LL;
  if (a5) {
    *a5 = v9;
  }
  return result;
}

uint64_t sub_10004DB8C(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9 = (void *)result;
  if (a3)
  {
    if (!*(_WORD *)(a2 + 1532)) {
      return result;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 512));
    unsigned int v10 = *(unsigned __int16 *)(a2 + 1532) + 16;
    unsigned int v11 = 16;
  }

  else
  {
    if (!*(_WORD *)(a2 + 1534)) {
      return result;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 448));
    unsigned int v11 = 0;
    unsigned int v10 = *(unsigned __int16 *)(a2 + 1534);
  }

  sub_10004D8E8((uint64_t)v9, a4);
  if (v11 < v10)
  {
    uint64_t v12 = 16LL * v11;
    unint64_t v13 = v10 - (unint64_t)v11;
    do
    {
      sub_100051CDC(v9[48], *(void *)(*(void *)(a2 + 1536) + v12));
      v12 += 16LL;
      --v13;
    }

    while (v13);
  }

  sub_100051D1C(v9[48]);
  if (a3)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 512));
    uint64_t v14 = (pthread_mutex_t *)(a2 + 384);
  }

  else
  {
    uint64_t v14 = (pthread_mutex_t *)(a2 + 448);
  }

  uint64_t result = pthread_mutex_lock(v14);
  if (v11 < v10)
  {
    uint64_t v15 = 16LL * v11;
    unint64_t v16 = v10 - (unint64_t)v11;
    do
    {
      uint64_t v17 = (unint64_t *)(*(void *)(a2 + 1536) + v15);
      unint64_t v18 = *v17;
      unint64_t v19 = v17[1];
      if (a3) {
        uint64_t result = sub_10004DF24(v9, a2, v18, v19, 1, a5);
      }
      else {
        uint64_t result = sub_10004DCE4((uint64_t)v9, (void *)a2, v18, v19, a5);
      }
      v15 += 16LL;
      --v16;
    }

    while (v16);
  }

  if (a3)
  {
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(a2 + 384));
    *(void *)(a2 + 1552) = 0LL;
    *(_WORD *)(a2 + 1532) = 0;
  }

  else
  {
    *(void *)(a2 + 1544) = 0LL;
    *(_WORD *)(a2 + 1534) = 0;
  }

  return result;
}

uint64_t sub_10004DCE4(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = a2[47];
  uint64_t v25 = 0LL;
  uint64_t result = sub_10004E670(a1, a5);
  if ((_DWORD)result)
  {
    unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t result = sub_10004DB0C(a1, (uint64_t)a2, a3, a4, &v26);
    if ((_DWORD)result)
    {
      if ((_DWORD)result == 22) {
        return (uint64_t)sub_100013D94("%s:%d: %s attempt to free block(s) outside of internal pool: 0x%llx:0x%llx\n");
      }
      else {
        return (uint64_t)sub_100013D94("%s:%d: %s Error mapping freed IP block range 0x%llx:0x%llx to index: %d\n");
      }
    }

    else
    {
      int v12 = 8 * *(_DWORD *)(v10 + 32);
      if (v12) {
        BOOL v13 = a4 < 1;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13)
      {
        unint64_t v14 = v12;
        unint64_t v15 = v26;
        uint64_t v21 = v10;
        do
        {
          unint64_t v16 = v15 / v14;
          unsigned int v17 = *(unsigned __int16 *)(a2[109] + 2 * (v15 / v14));
          uint64_t result = sub_1000441FC(a1, v10, v17, &v24);
          if ((_DWORD)result) {
            break;
          }
          uint64_t result = sub_10003B574(*(void *)(a1 + 392), 1073741825LL, v24, &xmmword_10005BA74, 0LL, 0LL, 0LL, a5, &v25);
          if ((_DWORD)result) {
            break;
          }
          uint64_t v18 = *(void *)(v25 + 56);
          unint64_t v19 = v26 % v14;
          else {
            uint64_t v20 = a4;
          }
          if (*(void *)(a2[108] + 8 * v16) != a5)
          {
            unint64_t v23 = 0LL;
            __int16 v22 = 0;
            if (sub_1000436C4(a1, (uint64_t)a2, a5, &v23, &v22)
              || sub_10004D9BC(a1, (uint64_t)a2, v17, a5))
            {
              return sub_100038824(v25);
            }

            unint64_t v24 = v23;
            *(_WORD *)(a2[109] + 2 * v16) = v22;
            *(void *)(a2[108] + 8 * v16) = a5;
          }

          sub_10001D400(v18, v19, v20);
          sub_10003E644(v25, a5, v24);
          uint64_t result = sub_100038824(v25);
          unint64_t v15 = v26 + v20;
          v26 += v20;
          BOOL v13 = a4 <= v20;
          a4 -= v20;
          uint64_t v10 = v21;
        }

        while (!v13);
      }
    }
  }

  return result;
}

uint64_t sub_10004DF24(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, char a5, uint64_t a6)
{
  if (a4) {
    sub_100030E0C((uint64_t)a1, a2, a3);
  }
  uint64_t v12 = sub_10004AF18(a1, 0LL, a2, a3, a4, a6, 1, a5);
  if (!(_DWORD)v12)
  {
    char v13 = __clz(__rbit64(*(unsigned int *)(a1[47] + 36LL)));
    sub_10002B884( *(void *)(a2 + (((a3 << v13) & 0x4000000000000000LL) >> 59) + 1568),  0,  ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & a3,  a4);
  }

  return v12;
}

unint64_t sub_10004DFE0( unint64_t result, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5;
  unint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 376);
  uint64_t v9 = a2;
  unint64_t v10 = *(void *)(v8 + 48LL * a2 + 56);
  uint64_t v11 = *(void *)(a4 + 8);
  uint64_t v12 = *(unsigned int *)(v8 + 36);
  uint64_t v13 = *(void *)a4 / v12;
  uint64_t v14 = result + 8LL * a2;
  unsigned int v15 = *(_DWORD *)(*(void *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
  if (a3) {
    unint64_t v16 = a3;
  }
  else {
    unint64_t v16 = *(void *)(v8 + 48LL * a2 + 56);
  }
  if (v10 < v16) {
    unint64_t v16 = *(void *)(v8 + 48LL * a2 + 56);
  }
  else {
    int v17 = *(_DWORD *)(v8 + 36);
  }
  if (v15 == v17 || v16 < 2)
  {
    unint64_t v19 = *(void *)a4 / v12;
    LODWORD(v14) = *(_DWORD *)(*(void *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
    goto LABEL_37;
  }

  uint64_t v20 = (uint64_t *)(v14 + 1488);
  unint64_t v21 = v16 - 1;
  unint64_t v22 = v13 + 1;
  unsigned int v23 = *(_DWORD *)(*(void *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
  uint64_t v24 = *(void *)a4 / v12;
  do
  {
    unint64_t v19 = v22 % v10;
    uint64_t v25 = *v20;
    int v26 = *(_DWORD *)(*v20 + 4 * (v22 % v10));
    LODWORD(v14) = v26 & 0xFFFFFF;
    if ((v26 & 0xFFFFFFu) > v15)
    {
      uint64_t v13 = v22 % v10;
      unsigned int v15 = v26 & 0xFFFFFF;
    }

    if (v14 > v23)
    {
      if (*(_BYTE *)(a4 + 16))
      {
        if ((v26 & 0xC000000) != 0) {
          goto LABEL_34;
        }
        uint64_t v27 = *(void *)(v7 + 376);
        uint64_t v28 = v27 + 48LL * v9;
        unint64_t v29 = *(void *)(v28 + 56);
        if (v29 > v19)
        {
          uint64_t v30 = *(void *)(a4 + 32);
          if (v30)
          {
            uint64_t v47 = v24;
            unint64_t v48 = v7;
            uint64_t v49 = v9;
            uint64_t v50 = v11;
            uint64_t v51 = v8;
            unint64_t v31 = *(unsigned int *)(v27 + 36);
            uint64_t v32 = v31;
            if (v29 - 1 == v19) {
              uint64_t v32 = *(void *)(v28 + 48) % v31;
            }
            uint64_t result = sub_100013C78(v19 * v31, v32, *(void *)(a4 + 24), v30, 0LL);
            uint64_t v11 = v50;
            uint64_t v8 = v51;
            unint64_t v7 = v48;
            uint64_t v9 = v49;
            uint64_t v24 = v47;
            if (result) {
              goto LABEL_34;
            }
            LODWORD(v14) = *(_DWORD *)(v25 + 4 * v19) & 0xFFFFFF;
          }
        }
      }

      LODWORD(v12) = *(_DWORD *)(v8 + 36);
      else {
        int v33 = *(_DWORD *)(v8 + 36);
      }
      uint64_t v24 = v22 % v10;
      unsigned int v23 = v14;
    }

uint64_t sub_10004E254(uint64_t a1, pthread_mutex_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = 22LL;
  if (sub_10004E670(a1, a4))
  {
    pthread_mutex_lock(a2 + 7);
    unsigned int v9 = sub_100047D80(a1, (uint64_t)a2, a3, &v11);
    if (v9 == 2) {
      uint64_t v8 = 22LL;
    }
    else {
      uint64_t v8 = v9;
    }
    if (!(_DWORD)v8) {
      uint64_t v8 = sub_10004C220(a1, (uint64_t)a2, 0LL, a3, 1LL, a4);
    }
    pthread_mutex_unlock(a2 + 7);
  }

  return v8;
}

uint64_t sub_10004E2FC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 376) + 36LL);
  unint64_t v7 = (pthread_mutex_t *)sub_100013EEC(1uLL, 0x130uLL);
  if (!v7) {
    return 12LL;
  }
  uint64_t v8 = (uint64_t)v7;
  v7[1].__uint64_t sig = a2;
  *(void *)v7[1].__opaque = 0LL;
  *(void *)&v7[1].__opaque[40] = 0LL;
  *(_DWORD *)&v7[1].__opaque[8] = 0;
  *(_DWORD *)&v7[1].__opaque[12] = (v6 - 40) / 0x28uLL;
  *(void *)&v7[1].__opaque[48] = (char *)v7 + 112;
  v7[2].__uint64_t sig = 0LL;
  *(void *)v7[2].__opaque = v7 + 2;
  uint64_t v9 = sub_1000139BC(v7);
  if (!(_DWORD)v9)
  {
    uint64_t v10 = sub_1000139D4((pthread_cond_t *)(v8 + 256));
    if ((_DWORD)v10)
    {
      uint64_t v9 = v10;
      j__pthread_mutex_destroy((pthread_mutex_t *)v8);
    }

    else if (*(_BYTE *)(a1 + 627) || (uint64_t v9 = sub_10004E40C(v8, v6), !(_DWORD)v9))
    {
      uint64_t v9 = 0LL;
      uint64_t v12 = *(void *)(a1 + 376);
      int v13 = *(_DWORD *)(v12 + 104) & 0x7FFFFFFF;
      int v14 = *(_DWORD *)(v12 + 108) & 0x7FFFFFFF;
      *(_DWORD *)(v8 + 88) = v13;
      *(_DWORD *)(v8 + 92) = v14;
      *(void *)(v8 + 96) = *(void *)(v12 + 128);
      *(_DWORD *)(v8 + 104) = v13;
      *(_DWORD *)(v8 + 108) = v14;
      *a3 = v8;
      return v9;
    }
  }

  sub_100014004((void *)v8, 304LL);
  return v9;
}

uint64_t sub_10004E40C(uint64_t a1, unsigned int a2)
{
  size_t v3 = a2;
  int v4 = 4;
  while (1)
  {
    uint64_t v5 = sub_100013EEC(1uLL, 0x78uLL);
    if (!v5) {
      break;
    }
    uint64_t v6 = v5;
    v5[7] = sub_100014044(v3);
    v6[8] = sub_100014044(v3);
    unint64_t v7 = *(void **)(a1 + 120);
    *uint64_t v6 = 0LL;
    v6[1] = v7;
    *unint64_t v7 = v6;
    *(void *)(a1 + 120) = v6;
    if (!v6[7] || !v6[8]) {
      break;
    }
    if (!--v4) {
      return 0LL;
    }
  }

  while (1)
  {
    int v13 = *(uint64_t **)(a1 + 112);
    if (!v13) {
      break;
    }
    uint64_t v9 = *v13;
    uint64_t v10 = (void *)v13[1];
    if (*v13)
    {
      *(void *)(v9 + 8) = v10;
      uint64_t v10 = (void *)v13[1];
    }

    else
    {
      *(void *)(a1 + 120) = v10;
    }

    *uint64_t v10 = v9;
    uint64_t v11 = (void *)v13[7];
    if (v11) {
      sub_100014004(v11, v3);
    }
    uint64_t v12 = (void *)v13[8];
    if (v12) {
      sub_100014004(v12, v3);
    }
    sub_100014004(v13, 120LL);
  }

  return 12LL;
}

void sub_10004E4E8(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v6 = a2[18];
  if (v6)
  {
    sub_100013D94( "%s:%d: %s Trash unfinished tx xid=0x%llx\n",  "tx_mgr_free_tx",  189,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v6 + 16));
    unint64_t v7 = (void *)a2[18];
    uint64_t v8 = (void *)a2[15];
    *unint64_t v7 = 0LL;
    v7[1] = v8;
    void *v8 = v7;
    a2[15] = a2[18];
    a2[18] = 0LL;
  }

  uint64_t v9 = a2[16];
  if (v9)
  {
    sub_100013D94( "%s:%d: %s Trash unfinished pending tx, xid range = 0x%llx - 0x%llx\n",  "tx_mgr_free_tx",  197,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v9 + 16),  *(void *)(**(void **)(a2[17] + 8LL) + 16LL));
    uint64_t v10 = a2[16];
    if (v10)
    {
      *(void *)a2[15] = v10;
      *(void *)(a2[16] + 8LL) = a2[15];
      a2[15] = a2[17];
      a2[16] = 0LL;
      a2[17] = a2 + 16;
    }
  }

  uint64_t v11 = (void *)a2[14];
  if (v11)
  {
    do
    {
      int v13 = (void *)*v11;
      uint64_t v12 = (void *)v11[1];
      if (*v11)
      {
        v13[1] = v12;
        uint64_t v12 = (void *)v11[1];
      }

      else
      {
        a2[15] = v12;
      }

      void *v12 = v13;
      int v14 = (void *)v11[7];
      if (v14) {
        sub_100014004(v14, a3);
      }
      unsigned int v15 = (void *)v11[8];
      if (v15) {
        sub_100014004(v15, a3);
      }
      sub_100014004(v11, 120LL);
      uint64_t v11 = v13;
    }

    while (v13);
  }

void sub_10004E638(uint64_t a1, uint64_t a2, unsigned int a3)
{
}

BOOL sub_10004E670(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 624))
  {
    uint64_t v2 = (void *)(*(void *)(a1 + 376) + 96LL);
    return *v2 == a2;
  }

  uint64_t v3 = *(void *)(a1 + 400);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 144);
    if (v4)
    {
      uint64_t v2 = (void *)(v4 + 16);
      return *v2 == a2;
    }
  }

  return 0LL;
}

uint64_t sub_10004E6B0(void *a1, int a2)
{
  uint64_t v4 = a1[50];
  size_t v5 = *(unsigned int *)(a1[47] + 36LL);
  uint64_t v6 = sub_100013EEC(1uLL, v5);
  if (!v6) {
    return 12LL;
  }
  unint64_t v7 = v6;
  uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    unsigned int v8 = *(_DWORD *)(v4 + 96);
    while (1)
    {
      uint64_t v12 = -1LL;
      uint64_t v9 = sub_1000132F4((uint64_t)a1, v8, &v12);
      if ((_DWORD)v9) {
        break;
      }
      uint64_t v9 = sub_100051F74(a1[48], v12);
      if ((_DWORD)v9) {
        break;
      }
      unsigned int v8 = (*(_DWORD *)(v4 + 96) + 1) % *(_DWORD *)(v4 + 88);
      *(_DWORD *)(v4 + 96) = v8;
      if (!--a2) {
        goto LABEL_7;
      }
    }

    uint64_t v10 = v9;
    sub_100013D94( "%s:%d: %s failed to zero checkpoint descriptor block %d @ %lld: %d\n",  "tx_checkpoint_desc_zero",  394,  (const char *)(a1[48] + 208LL),  *(_DWORD *)(v4 + 96),  v12,  v9);
  }

  else
  {
LABEL_7:
    uint64_t v10 = 0LL;
  }

  sub_100014004(v7, v5);
  return v10;
}

uint64_t sub_10004E7D0(uint64_t a1, uint64_t a2, int a3)
{
  char v6 = 0;
  uint64_t v7 = *(void *)(a1 + 400);
  while (1)
  {
    unsigned int v8 = *(_DWORD *)(v7 + 96);
    unsigned int v9 = *(_DWORD *)(v7 + 104);
    unsigned int v10 = v9;
    if (v8 > v9) {
      unsigned int v10 = *(_DWORD *)(v7 + 88) + v9;
    }
    unsigned int v11 = *(_DWORD *)(v7 + 100);
    unsigned int v12 = *(_DWORD *)(v7 + 108);
    unsigned int v13 = v12;
    if (v11 > v12) {
      unsigned int v13 = *(_DWORD *)(v7 + 92) + v12;
    }
    unsigned int v14 = v10 - v8;
    unsigned int v15 = v13 - v11;
    unsigned int v16 = *(_DWORD *)(a2 + 48) + a3;
    if (v16 <= v15 && !(v6 & 1 | (*(_DWORD *)(a2 + 40) + 1 > v14))) {
      return 0LL;
    }
    if ((v6 & 1) != 0 || !*(void *)(v7 + 128)) {
      break;
    }
    sub_10004E8F0(a1, 0x50u, 0);
    char v6 = 1;
  }

  if (!*(_WORD *)(v7 + 82)) {
    sub_100013D94( "%s:%d: %s checkpoint area out of space: stable: %d %d - next %d %d available %d %d tx[%lld] %d %d\n",  "tx_checkpoint_space_check",  495,  (const char *)(*(void *)(a1 + 384) + 208LL),  v9,  v12,  v8,  v11,  v14,  v15,  *(void *)(a2 + 16),  *(_DWORD *)(a2 + 40) + 1,  v16);
  }
  *(_WORD *)(v7 + 82) = 1;
  return 28LL;
}

uint64_t sub_10004E8F0(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 400);
  if ((a2 & 0x40) != 0)
  {
    uint64_t v7 = *(void *)(v6 + 128);
    if (!v7 || (*(_BYTE *)(v7 + 24) & 0x40) == 0) {
      return 0LL;
    }
  }

  if (a3) {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 400));
  }
  uint64_t v8 = sub_100051C7C(*(void *)(a1 + 384), (a2 >> 4) & 1);
  if (a3) {
    pthread_mutex_lock((pthread_mutex_t *)v6);
  }
  if ((_DWORD)v8 == 25 || (_DWORD)v8 == 0)
  {
    unsigned int v10 = *(uint64_t **)(v6 + 128);
    if (v10)
    {
      do
      {
        unsigned int v11 = (uint64_t *)*v10;
        int v12 = *((_DWORD *)v10 + 6);
        if ((v12 & 0x40) != 0)
        {
          *((_DWORD *)v10 + 6) = v12 & 0xFFFFFFBF;
          v20.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v20.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v20);
          __darwin_time_t v13 = 1000000 * v20.tv_sec + SLODWORD(v20.tv_nsec) / 1000;
          __darwin_time_t v14 = v13 - v10[9];
          v10[9] = v13;
          v10[13] += v14;
          unint64_t v15 = v10[2];
          if (!*(_BYTE *)(a1 + 632) || v15 < *(void *)(*(void *)(a1 + 376) + 1408LL))
          {
            *(_DWORD *)(v6 + 104) = *((_DWORD *)v10 + 9);
            *(_DWORD *)(v6 + 108) = *((_DWORD *)v10 + 11);
          }

          sub_100045630(a1, v15);
          uint64_t v16 = *v10;
          int v17 = (void *)v10[1];
          if (*v10)
          {
            *(void *)(v16 + 8) = v17;
            int v17 = (void *)v10[1];
          }

          else
          {
            *(void *)(v6 + 136) = v17;
          }

          *int v17 = v16;
          *unsigned int v10 = 0LL;
          uint64_t v18 = *(void **)(v6 + 120);
          v10[1] = (uint64_t)v18;
          *uint64_t v18 = v10;
          *(void *)(v6 + 120) = v10;
          j__pthread_cond_broadcast((pthread_cond_t *)(v6 + 256));
        }

        unsigned int v10 = v11;
      }

      while (v11);
    }

    return 0LL;
  }

  return v8;
}

uint64_t sub_10004EA7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 + 64);
  if (*(_DWORD *)(v6 + 36) == *(_DWORD *)(*(void *)(a1 + 400) + 84LL))
  {
    ++*(_DWORD *)(a2 + 40);
    *(_DWORD *)(v6 + 36) = 0;
  }

  uint64_t v7 = sub_10004E7D0(a1, a2, v5);
  if (!(_DWORD)v7)
  {
    if ((*(_BYTE *)(a3 + 19) & 0x20) == 0)
    {
      unsigned int v10 = *(void **)(a3 + 56);
      v8.i64[0] = *(void *)(a3 + 36);
      v10[3] = v8.i64[0];
      uint64_t v11 = *(void *)(a2 + 16);
      v10[1] = *(void *)(a3 + 112);
      v10[2] = v11;
      sub_10003E948(a3, v8, v9);
    }

    *(void *)(a3 + 120) = *(void *)(a2 + 16);
    *(void *)(a3 + 144) = 0LL;
    ++*(_DWORD *)(*(void *)(a2 + 64) + 36LL);
    *(_DWORD *)(a2 + 48) += v5;
  }

  return v7;
}

uint64_t sub_10004EB4C(void *a1, uint64_t a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  int8x16_t v8 = (_DWORD *)a1[50];
  unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  size_t v9 = *(unsigned int *)(a1[47] + 36LL);
  int v10 = *(_DWORD *)(a3 + 48);
  uint64_t v11 = *(void *)(a2 + 64);
  if (*(_DWORD *)(v11 + 36) == v8[21])
  {
    sub_10003E984((uint64_t)a1, v11, *(_DWORD *)(a1[47] + 36LL), a4, a5);
    uint64_t v12 = sub_100051F74(a1[48], *(void *)(*(void *)(a2 + 64) + 8LL));
    if ((_DWORD)v12)
    {
      uint64_t v13 = v12;
      if (!v8[19]) {
        sub_100013D94("%s:%d: %s failed to write checkpoint map block %lld: %d\n");
      }
      return v13;
    }

    unint64_t v14 = (*(_DWORD *)(a2 + 40) + v8[24]) % v8[22];
    unint64_t v42 = -1LL;
    uint64_t v15 = sub_1000132F4((uint64_t)a1, v14, &v42);
    if ((_DWORD)v15)
    {
      uint64_t v13 = v15;
      if (!v8[19]) {
        sub_100013D94("%s:%d: %s error getting next checkpoint map block address %d: %d\n");
      }
      return v13;
    }

    bzero(*(void **)(a2 + 64), v9);
    uint64_t v16 = *(void *)(a2 + 64);
    *(_DWORD *)(v16 + 24) = 1073741836;
    *(void *)(v16 + 8) = v42;
    *(void *)(v16 + 16) = *(void *)(a2 + 16);
    ++*(_DWORD *)(a2 + 40);
  }

  unint64_t v17 = (*(_DWORD *)(a2 + 48) + v8[25]) % v8[23];
  uint64_t v41 = -1LL;
  uint64_t v18 = sub_100013338((uint64_t)a1, v17, &v41, &v40);
  if ((_DWORD)v18)
  {
    uint64_t v13 = v18;
    if (!v8[19]) {
      sub_100013D94("%s:%d: %s error getting next checkpoint data block address %d: %d\n");
    }
  }

  else
  {
    signed int v19 = ((int)v9 + v10 - 1) / v9;
    pthread_mutex_lock((pthread_mutex_t *)(a1[49] + 328LL));
    timespec v20 = (unsigned int *)(a3 + 32);
    do
      unsigned int v21 = __ldxr(v20);
    while (__stxr(v21 | 8, v20));
    if ((v21 & 8) != 0)
    {
      do
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328LL));
        pthread_mutex_lock((pthread_mutex_t *)(a1[49] + 328LL));
        do
          unsigned int v22 = __ldxr(v20);
        while (__stxr(v22 | 8, v20));
      }

      while ((v22 & 8) != 0);
    }

    uint64_t v38 = a3;
    unint64_t v39 = *(char **)(a3 + 64);
    *(void *)(a3 + 128) = v41;
    if (v19 < 1)
    {
LABEL_30:
      else {
        uint64_t v27 = v39;
      }
      *(void *)(v38 + 64) = 0LL;
      uint64_t v28 = a1[49];
      uint64_t v29 = *(void *)(*(void *)(v28 + 848) + 104LL);
      *(void *)(v28 + 848) = v29;
      if (!v29) {
        *(void *)(v28 + 856) = v28 + 848;
      }
      *(void *)(v38 + 104) = 3735928559LL;
      do
        unsigned int v30 = __ldxr(v20);
      while (__stxr(v30 & 0xFFFFFFF7, v20));
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328LL));
      uint64_t v31 = *(void *)(a2 + 64);
      unsigned int v32 = *(_DWORD *)(v31 + 36);
      uint64_t v33 = v31 + 40LL * v32;
      *(void *)(v33 + 40) = *(void *)(v38 + 36);
      *(void *)(v33 + 48) = *(unsigned int *)(v38 + 48);
      uint64_t v34 = *(void *)(v38 + 8);
      if (v34)
      {
        uint64_t v34 = sub_10003965C(v34);
        uint64_t v31 = *(void *)(a2 + 64);
        unsigned int v32 = *(_DWORD *)(v31 + 36);
      }

      unint64_t v35 = (void *)(v31 + 40LL * v32);
      v35[7] = v34;
      v35[8] = *(void *)(v38 + 112);
      v35[9] = *(void *)(v38 + 128);
      *(_DWORD *)(v31 + 36) = v32 + 1;
      *(_DWORD *)(a2 + 48) += v19;
      if (v27) {
        sub_100036918(v27, *(unsigned int *)(v38 + 48), *(void *)(v38 + 16), a1[49]);
      }
      return 0LL;
    }

    else
    {
      unsigned int v23 = v39;
      int v24 = v19;
      while (1)
      {
        unint64_t v25 = v40 >= v24 ? v24 : v40;
        uint64_t v26 = sub_100051F74(a1[48], v41);
        if ((_DWORD)v26) {
          break;
        }
        v24 -= v25;
        if (!v24) {
          goto LABEL_30;
        }
        unint64_t v17 = (int)v17 + (int)v25 >= (*(_DWORD *)(a1[47] + 108LL) & 0x7FFFFFFFu) ? 0LL : (v17 + v25);
        uint64_t v26 = sub_100013338((uint64_t)a1, v17, &v41, &v40);
        if ((_DWORD)v26) {
          break;
        }
        v23 += v25 * v9;
        if (v24 <= 0) {
          goto LABEL_30;
        }
      }

      uint64_t v13 = v26;
      do
        unsigned int v36 = __ldxr(v20);
      while (__stxr(v36 & 0xFFFFFFF7, v20));
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328LL));
      if (!v8[19]) {
        sub_100013D94("%s:%d: %s failed to write checkpoint data block %lld: %d\n");
      }
    }
  }

  return v13;
}

uint64_t sub_10004EF7C(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 400);
  if ((a2 & 0x80) != 0 && (uint64_t v5 = *(void *)(v4 + 144)) != 0 && (*(_BYTE *)(v5 + 24) & 8) != 0)
  {
    int v6 = 0;
    if ((a2 & 0x40) == 0) {
      goto LABEL_11;
    }
  }

  else
  {
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 400));
    int v6 = 1;
    if ((a2 & 0x40) == 0) {
      goto LABEL_11;
    }
  }

  uint64_t v7 = *(void *)(v4 + 128);
  if (!v7 || (*(_BYTE *)(v7 + 24) & 0x40) == 0)
  {
    if (v6) {
      pthread_mutex_unlock((pthread_mutex_t *)v4);
    }
    return 0LL;
  }

uint64_t sub_10004F01C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v2);
  *(_DWORD *)(v2 + 72) |= 1u;
  pthread_mutex_unlock((pthread_mutex_t *)v2);
  while (1)
  {
    uint64_t result = sub_10004F230(a1, 8);
    if ((_DWORD)result != 16) {
      break;
    }
    sub_100013CBC( "%s:%d: %s waiting for transaction to finish\n",  "tx_unmount",  1880,  (const char *)(*(void *)(a1 + 384) + 208LL));
    sleep(1u);
  }

  if ((_DWORD)result)
  {
    uint64_t result = (uint64_t)sub_100013D94( "%s:%d: %s tx_finish() failed, %d\n",  "tx_unmount",  1895,  (const char *)(*(void *)(a1 + 384) + 208LL),  result);
    if (!*(_BYTE *)(a1 + 629))
    {
      pthread_mutex_lock((pthread_mutex_t *)v2);
      return pthread_mutex_unlock((pthread_mutex_t *)v2);
    }
  }

  else if (!*(_BYTE *)(a1 + 629))
  {
    pthread_mutex_lock((pthread_mutex_t *)v2);
    if ((*(_BYTE *)(v2 + 72) & 2) != 0)
    {
      int v4 = sub_10004E8F0(a1, 0x10u, 0);
      if (v4) {
        sub_100013D94( "%s:%d: %s First sync/barrier failed: %d\n",  "tx_unmount",  1909,  (const char *)(*(void *)(a1 + 384) + 208LL),  v4);
      }
      if (!*(_BYTE *)(a1 + 628))
      {
        uint64_t v7 = *(void *)(a1 + 376);
        if (*(_DWORD *)(v7 + 140))
        {
          if (*(_DWORD *)(v7 + 148)) {
            *(void *)(v7 + 1264) |= 2uLL;
          }
        }
      }

      sub_10003E948(a1, v5, v6);
      int v8 = sub_100051F74(*(void *)(a1 + 384), 0LL);
      if (v8) {
        sub_100013D94( "%s:%d: %s failed to write superblock to block 0: %d\n",  "tx_unmount",  1920,  (const char *)(*(void *)(a1 + 384) + 208LL),  v8);
      }
      size_t v9 = *(_BYTE **)(a1 + 376);
      if ((v9[65] & 1) != 0)
      {
        int v10 = sub_1000107A8(a1, v9);
        if (v10) {
          sub_100013D94( "%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n",  "tx_unmount",  1925,  (const char *)(*(void *)(a1 + 384) + 208LL),  v10);
        }
      }

      int v11 = sub_10004E8F0(a1, 0x10u, 0);
      if (v11) {
        sub_100013D94( "%s:%d: %s Final sync/barrier failed: %d\n",  "tx_unmount",  1932,  (const char *)(*(void *)(a1 + 384) + 208LL),  v11);
      }
    }

    return pthread_mutex_unlock((pthread_mutex_t *)v2);
  }

  return result;
}

uint64_t sub_10004F230(uint64_t a1, __int16 a2)
{
  if (*(_BYTE *)(a1 + 627)) {
    return 30LL;
  }
  uint64_t v5 = *(void *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v5);
  int v6 = *(_DWORD *)(v5 + 72);
  if ((a2 & 8) == 0 && (v6 & 1) != 0)
  {
LABEL_18:
    uint64_t v2 = 1LL;
  }

  else
  {
    while (1)
    {
      uint64_t v7 = *(void *)(v5 + 144);
      if ((v6 & 0x40) == 0) {
        break;
      }
      if (v7) {
        *(_DWORD *)(v7 + 24) |= 0x100000u;
      }
      if ((a2 & 0x100) != 0)
      {
        *(_DWORD *)(v5 + 72) = v6 & 0xFFFFFFF3;
        j__pthread_cond_broadcast((pthread_cond_t *)(v5 + 256));
        uint64_t v7 = *(void *)(v5 + 144);
      }

      if (v7)
      {
        uint64_t v2 = *(unsigned int *)(v7 + 52);
        if ((_DWORD)v2) {
          goto LABEL_19;
        }
      }

      sub_1000139E8( (pthread_cond_t *)(v5 + 256),  (pthread_mutex_t *)v5,  8LL,  (uint64_t)"nx_tx_finish_wait_for_dirty_data",  0LL);
      uint64_t v8 = *(void *)(v5 + 144);
      if (v8)
      {
        unsigned int v9 = *(_DWORD *)(v8 + 52);
        if (v9 | a2 & 0x100)
        {
          if (v9) {
            uint64_t v2 = v9;
          }
          else {
            uint64_t v2 = 35LL;
          }
          goto LABEL_19;
        }
      }

      else if ((a2 & 0x100) != 0)
      {
        goto LABEL_65;
      }

      int v6 = *(_DWORD *)(v5 + 72);
      if ((a2 & 8) == 0 && (v6 & 1) != 0) {
        goto LABEL_18;
      }
    }

    if (v7 || (uint64_t v7 = **(void **)(*(void *)(v5 + 136) + 8LL)) != 0 && (*(_BYTE *)(v7 + 24) & 0x30) != 0)
    {
      if ((a2 & 2) == 0 && (v6 & 0xC) == 8)
      {
        uint64_t v2 = 16LL;
        goto LABEL_19;
      }

      uint64_t v11 = *(void *)(v7 + 16);
      if ((a2 & 8) == 0) {
        ++*(void *)(v5 + 176);
      }
      int v12 = *(_DWORD *)(v7 + 24);
      int v13 = a2 & 1;
      if (v12 & 0x100000 | a2 & 0x10 | v13 | a2 & 0x20) {
        *(_DWORD *)(v7 + 24) = ((a2 & 0x30) << 14) | (v13 << 17) | v12 & 0xFFEFFFFF;
      }
      if ((v12 & 1) != 0) {
        sub_10004FB3C(v7, 1, 2);
      }
      if (*(_DWORD *)(v7 + 28))
      {
        uint64_t v2 = (16 * v13) ^ 0x10u;
      }

      else
      {
        if ((*(_BYTE *)(v7 + 24) & 2) != 0)
        {
          unint64_t v14 = sub_10004FB3C(v7, 2, 4);
          unint64_t v15 = v14;
          if (v14 >= 0xF4241) {
            sub_100013D4C( "%s:%d: %s tx xid %lld took %lld us to close\n",  "tx_finish",  2149,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v7 + 16),  v14);
          }
          *(void *)(v5 + 248) = (*(void *)(v5 + 248) + v15) >> 1;
        }

        uint64_t v2 = sub_10004FC2C(a1);
        if (!(_DWORD)v2)
        {
          int v16 = *(_DWORD *)(v5 + 72);
          if ((v16 & 0x40) != 0)
          {
            *(_DWORD *)(v5 + 72) = v16 & 0xFFFFFFF3;
            if ((a2 & 0x100) != 0)
            {
LABEL_65:
              uint64_t v2 = 35LL;
              goto LABEL_19;
            }

            j__pthread_cond_broadcast((pthread_cond_t *)(v5 + 256));
          }

          uint64_t v2 = 0LL;
        }
      }

      if ((a2 & 9) != 0)
      {
        if ((a2 & 1) != 0) {
          int v17 = 126;
        }
        else {
          int v17 = 62;
        }
        do
        {
          if (*(void *)(v7 + 16) != v11 || (*(_DWORD *)(v7 + 24) & v17) == 0) {
            break;
          }
          if (!(_DWORD)v2) {
            sub_1000139E8((pthread_cond_t *)(v5 + 256), (pthread_mutex_t *)v5, 8LL, (uint64_t)"nx_tx_finish_wait", 0LL);
          }
          int v18 = *(_DWORD *)(v5 + 72);
          if ((a2 & 8) == 0 && (v18 & 1) != 0) {
            goto LABEL_18;
          }
          if ((a2 & 0x100) != 0 && (v18 & 4) == 0) {
            goto LABEL_65;
          }
        }

        while (!*(_DWORD *)(v5 + 76));
        uint64_t v19 = **(void **)(*(void *)(v5 + 136) + 8LL);
      }
    }

    else if ((a2 & 0x11) != 0)
    {
      uint64_t v2 = sub_10004E8F0(a1, a2 & 0x10, 0);
    }

    else
    {
      uint64_t v2 = 0LL;
    }
  }

uint64_t sub_10004F560(uint64_t a1, uint64_t *a2, char a3)
{
  if (*(_BYTE *)(a1 + 627)) {
    return 30LL;
  }
  uint64_t v7 = *(void *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v7);
  if ((*(_DWORD *)(v7 + 72) & 1) != 0)
  {
LABEL_37:
    pthread_mutex_unlock((pthread_mutex_t *)v7);
    return 1LL;
  }

  uint64_t v8 = *a2;
  if (*a2 != -1)
  {
    if (v8) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }

  uint64_t v11 = *(void *)(v7 + 144);
  if (v11) {
    BOOL v12 = (*(_DWORD *)(v7 + 72) & 0xC) == 8;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12 || (*(_BYTE *)(v11 + 24) & 0x1C) != 0)
  {
    *a2 = 0LL;
LABEL_15:
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    unint64_t v15 = 0LL;
    uint64_t v32 = SLODWORD(__tp.tv_nsec) / 1000;
    __darwin_time_t tv_sec = __tp.tv_sec;
    while (1)
    {
      uint64_t v9 = *(void *)(v7 + 144);
      if (v9 && (*(_BYTE *)(v9 + 24) & 0x1E) != 0)
      {
        int v16 = "nx_tx_wait";
        if ((a3 & 2) != 0)
        {
LABEL_20:
          int v17 = *(_DWORD *)(v9 + 24);
          unint64_t v15 = "nx_tx_wait_closing";
          if ((v17 & 2) == 0)
          {
            if ((v17 & 4) != 0)
            {
              uint64_t v18 = **(void **)(*(void *)(v7 + 136) + 8LL);
              if (!v18 || (unint64_t v15 = "nx_tx_wait_closed_prev_flushing", (*(_BYTE *)(v18 + 24) & 0x30) == 0)) {
                unint64_t v15 = "nx_tx_wait_closed";
              }
            }

            else if ((v17 & 0x18) != 0)
            {
              unint64_t v15 = "nx_tx_wait_flush";
            }

            else
            {
              unint64_t v15 = v16;
            }
          }

          goto LABEL_36;
        }
      }

      else
      {
        if ((a3 & 2) != 0 || (*(_BYTE *)(v7 + 72) & 8) == 0)
        {
          uint64_t v3 = 0LL;
          int v34 = 0;
          if (!v9) {
            goto LABEL_42;
          }
LABEL_40:
          if ((*(_BYTE *)(v9 + 24) & 1) != 0)
          {
            if (!(_DWORD)v3)
            {
              ++*(_DWORD *)(v9 + 28);
              *a2 = *(void *)(v9 + 16);
              if (v15)
              {
                int v10 = v34;
                if (v34)
                {
                  if (strcmp(v15, "nx_tx_wait_frozen"))
                  {
                    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
                    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
                    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
                    unint64_t v26 = 1000000 * (__tp.tv_sec - tv_sec) - v32 + SLODWORD(__tp.tv_nsec) / 1000;
                    *(void *)(v7 + 168) += v26;
                    if (v26 > 0xF4240 && sub_100013538(a1)) {
                      sub_100013D4C( "%s:%d: %s waited %lld us to open tx xid %lld (%s)\n",  "tx_enter_internal",  2414,  (const char *)(*(void *)(a1 + 384) + 208LL),  v26,  *(void *)(v9 + 16),  v15);
                    }
                    ++*(void *)(v7 + 160);
                  }

                  int v10 = 1;
                }
              }

              else
              {
                int v10 = v34;
              }

LABEL_86:
            pthread_mutex_unlock((pthread_mutex_t *)v7);
            return v3;
          }

          while (1)
          {
            int v23 = *(_DWORD *)(v9 + 24);
            if ((v23 & 1) == 0) {
              break;
            }
            do
            {
              sub_100013CBC( "%s:%d: %s waiting for available tx to open: xid %lld\n",  "tx_enter_internal",  2399,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v7 + 64));
              sub_1000139E8((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8LL, (uint64_t)"nx_tx_wait_open", 0LL);
LABEL_62:
              uint64_t v9 = *(void *)(v7 + 144);
              if (v9) {
                goto LABEL_40;
              }
LABEL_42:
              uint64_t v19 = *(uint64_t **)(v7 + 112);
            }

            while (!v19);
            *(void *)(v7 + 144) = v19;
            uint64_t v20 = *v19;
            unsigned int v21 = (void *)v19[1];
            if (*v19)
            {
              *(void *)(v20 + 8) = v21;
              unsigned int v21 = (void *)v19[1];
            }

            else
            {
              *(void *)(v7 + 120) = v21;
            }

            *unsigned int v21 = v20;
            uint64_t v22 = *(void *)(v7 + 64);
            *(void *)(v7 + 64) = v22 + 1;
            uint64_t v9 = *(void *)(v7 + 144);
            *(void *)(v9 + 16) = v22;
            *(void *)(v9 + 24) = 0LL;
            *(_DWORD *)(v9 + 32) = 0;
            *(_DWORD *)(v9 + 52) = 0;
          }

          if (*(_BYTE *)(a1 + 626))
          {
            sub_10003E948(a1, v13, v14);
            uint64_t v3 = sub_100051F74(*(void *)(a1 + 384), 0LL);
            if ((_DWORD)v3) {
              goto LABEL_50;
            }
            int v24 = *(_BYTE **)(a1 + 376);
            if ((v24[65] & 1) != 0)
            {
              uint64_t v25 = sub_1000107A8(a1, v24);
              if ((_DWORD)v25)
              {
                uint64_t v3 = v25;
                sub_100013D94( "%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n",  "tx_enter_internal",  2371,  (const char *)(*(void *)(a1 + 384) + 208LL),  v25);
LABEL_50:
                sub_100013D94( "%s:%d: %s Error: tx[%lld] failed to unclean superblock: %d\n",  "tx_enter_internal",  2377,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(*(void *)(v7 + 144) + 16LL),  v3);
                uint64_t v9 = *(void *)(v7 + 144);
LABEL_53:
                sub_100013D94( "%s:%d: %s Error: tx[%lld] failed to start: %d\n",  "tx_enter_internal",  2381,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v9 + 16),  v3);
                goto LABEL_62;
              }
            }

            *(_BYTE *)(a1 + 626) = 0;
            uint64_t v9 = *(void *)(v7 + 144);
            int v23 = *(_DWORD *)(v9 + 24);
            if ((v23 & 1) != 0) {
              panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v23, 1, 0);
            }
          }

          else if ((_DWORD)v3)
          {
            goto LABEL_53;
          }

          *(_DWORD *)(v9 + 24) = v23 | 1;
          __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
          __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          *(void *)(v9 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
          if ((a3 & 2) != 0) {
            *(_DWORD *)(*(void *)(v7 + 144) + 24LL) |= 0x10000u;
          }
          j__pthread_cond_broadcast((pthread_cond_t *)(v7 + 256));
          uint64_t v3 = 0LL;
          int v34 = 1;
          goto LABEL_62;
        }

        if (*(unsigned __int16 *)(v7 + 80) >= 0xAu)
        {
LABEL_73:
          uint64_t v27 = **(void **)(*(void *)(v7 + 136) + 8LL);
          if (v27)
          {
            if (*(_DWORD *)(v27 + 24) & 0x30)
            {
              BOOL v29 = 0;
            }

            else
            {
              uint64_t v27 = *(void *)(v7 + 144);
              BOOL v29 = v9 == 0;
            }

            if (!v29)
            {
              uint64_t v9 = v27;
              goto LABEL_82;
            }
          }

          else if (v9)
          {
LABEL_82:
            unsigned int v30 = *(_DWORD *)(v9 + 52);
            if (v30) {
              uint64_t v3 = v30;
            }
            else {
              uint64_t v3 = 5LL;
            }
            goto LABEL_86;
          }

          uint64_t v3 = 5LL;
          goto LABEL_86;
        }
      }

      if ((*(_DWORD *)(v7 + 72) & 8) != 0) {
        int v16 = "nx_tx_wait_frozen";
      }
      else {
        int v16 = "nx_tx_wait";
      }
      if (v9) {
        goto LABEL_20;
      }
      unint64_t v15 = v16;
LABEL_36:
      sub_1000139E8((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8LL, (uint64_t)v15, 0LL);
      if ((*(_BYTE *)(v7 + 72) & 1) != 0) {
        goto LABEL_37;
      }
    }
  }

  uint64_t v8 = *(void *)(v11 + 16);
  *a2 = v8;
  if (!v8) {
    goto LABEL_15;
  }
LABEL_6:
  uint64_t v9 = *(void *)(v7 + 144);
  if (v9 && v8 == *(void *)(v9 + 16))
  {
    int v10 = 0;
    ++*(_DWORD *)(v9 + 28);
    goto LABEL_88;
  }

  pthread_mutex_unlock((pthread_mutex_t *)v7);
  return 22LL;
}

__darwin_time_t sub_10004FB3C(uint64_t a1, int a2, int a3)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(a1 + 24);
    if ((v4 & a2) == 0) {
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v4, a3, a2);
    }
  }

  if (a3)
  {
    int v5 = *(_DWORD *)(a1 + 24);
    if ((v5 & a3) != 0) {
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v5, a3, a2);
    }
  }

  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 24) & ~a2 | a3;
  __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  __darwin_time_t v6 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  __darwin_time_t result = v6 - *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v6;
  return result;
}

uint64_t sub_10004FC2C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 400);
  for (int i = *(_DWORD *)(v2 + 72); (i & 0x10) != 0; int i = *(_DWORD *)(v2 + 72))
  {
    *(_DWORD *)(v2 + 72) = i | 0x20;
    sub_1000139E8((pthread_cond_t *)(v2 + 256), (pthread_mutex_t *)v2, 8LL, (uint64_t)"nx_tx_flush_busy", 0LL);
  }

  *(_DWORD *)(v2 + 72) = i | 0x10;
  size_t v4 = **(void **)(*(void *)(v2 + 136) + 8LL);
  if (!v4 || (int v5 = *(_DWORD *)(v4 + 24), (v5 & 0x10) == 0))
  {
    size_t v4 = *(void *)(v2 + 144);
    if (!v4) {
      goto LABEL_9;
    }
    int v5 = *(_DWORD *)(v4 + 24);
  }

  if ((v5 & 0x14) == 0 || (uint64_t v6 = sub_10005006C(a1, v4), !(_DWORD)v6))
  {
LABEL_9:
    size_t v7 = *(void *)(v2 + 144);
    if (v7 && (*(_BYTE *)(v7 + 24) & 4) != 0) {
      uint64_t v6 = sub_10005006C(a1, v7);
    }
    else {
      uint64_t v6 = 0LL;
    }
  }

  int v8 = *(_DWORD *)(v2 + 72);
  *(_DWORD *)(v2 + 72) = v8 & 0xFFFFFFCF;
  if ((v8 & 0x20) != 0) {
    j__pthread_cond_broadcast((pthread_cond_t *)(v2 + 256));
  }
  return v6;
}

uint64_t sub_10004FD18(uint64_t a1, uint64_t *a2)
{
  return sub_10004F560(a1, a2, 0);
}

uint64_t sub_10004FD20(uint64_t a1, uint64_t *a2)
{
  return sub_10004F560(a1, a2, 2);
}

uint64_t sub_10004FD28(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_BYTE *)(a1 + 627))
  {
    uint64_t v7 = *(void *)(a1 + 400);
    pthread_mutex_lock((pthread_mutex_t *)v7);
    uint64_t v8 = *(void *)(v7 + 144);
    if ((*(_BYTE *)(v8 + 24) & 1) == 0) {
      goto LABEL_22;
    }
    if ((a3 & 4) != 0)
    {
      BOOL v9 = 0;
      ++*(void *)(v7 + 176);
    }

    else
    {
      if (*(_DWORD *)(v8 + 32) <= 0x186A0u && !sub_100039058(*(void *)(a1 + 392)))
      {
        int v18 = sub_100045500((void *)a1);
        BOOL v9 = v18 == 0;
        BOOL v10 = v18 != 0;
LABEL_10:
        if ((*(_BYTE *)(v7 + 72) & 0x40) != 0)
        {
          if (!v9) {
            *(_DWORD *)(v8 + 24) |= 0x100000u;
          }
        }

        else
        {
          int v11 = *(_DWORD *)(v8 + 24);
          if ((v11 & 0x100000) != 0)
          {
            v11 &= ~0x100000u;
            *(_DWORD *)(v8 + 24) = v11;
          }

          else if (!v10)
          {
            goto LABEL_22;
          }

          if ((v11 & 1) == 0) {
            panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v11, 2, 1);
          }
          if ((v11 & 2) != 0) {
            panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v11, 2, 1);
          }
          *(_DWORD *)(v8 + 24) = v11 & 0xFFFFFFFC | 2;
          __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
          __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          *(void *)(v8 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
        }

LABEL_28:
        *(_DWORD *)(v8 + 24) |= 0x80000u;
        goto LABEL_29;
      }

      BOOL v9 = 0;
    }

    BOOL v10 = 1;
    goto LABEL_10;
  }

  return 30LL;
}

uint64_t sub_10005006C(uint64_t a1, size_t a2)
{
  uint64_t v5 = *(void *)(a1 + 392);
  uint64_t v4 = *(void *)(a1 + 400);
  unint64_t v88 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = **(void **)(*(void *)(v4 + 136) + 8LL);
  if (v6 && (*(_BYTE *)(v6 + 24) & 0x10) != 0)
  {
    if (v6 != a2) {
      panic("not handling the flushing tx!\n");
    }
  }

  else
  {
    if (*(void *)(v4 + 144) != a2) {
      panic("not handling the current tx!\n");
    }
    if ((*(_BYTE *)(a2 + 24) & 0x14) == 0) {
      panic("current tx not closed/flushing?!\n");
    }
  }

  int v7 = *(_DWORD *)(a2 + 24);
  if ((v7 & 0x10) != 0)
  {
LABEL_45:
    if (*(_BYTE *)(a1 + 629))
    {
      int v23 = *(_DWORD *)(a2 + 24);
      if ((v23 & 0x10) == 0) {
        panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v23, 1, 16);
      }
      if ((v23 & 1) != 0) {
        panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v23, 1, 16);
      }
      *(_DWORD *)(a2 + 24) = v23 & 0xFFFFFFEE | 1;
      __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
      __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      *(void *)(a2 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
      *(_DWORD *)(a2 + 32) = 0;
      *(_DWORD *)(a2 + 52) = 0;
    }

    else if (*(void *)(v4 + 144) == a2)
    {
      *(void *)a2 = 0LL;
      int v24 = *(size_t **)(v4 + 136);
      *(void *)(a2 + 8) = v24;
      *int v24 = a2;
      *(void *)(v4 + 136) = a2;
      *(void *)(v4 + 144) = 0LL;
    }

    pthread_mutex_unlock((pthread_mutex_t *)v4);
    j__pthread_cond_broadcast((pthread_cond_t *)(v4 + 256));
    uint64_t v25 = sub_100038C84((pthread_mutex_t *)v5, 2 * (*(_BYTE *)(a1 + 629) == 0));
    if (*(_BYTE *)(a1 + 629))
    {
      pthread_mutex_lock((pthread_mutex_t *)v4);
      sub_100038618(v5);
      sub_10004E8F0(a1, 0, 0);
      j__pthread_cond_broadcast((pthread_cond_t *)(v4 + 256));
      uint64_t v11 = 0LL;
      *(_DWORD *)(a2 + 52) = 0;
      return v11;
    }

    uint64_t v11 = v25;
    if ((_DWORD)v25)
    {
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94( "%s:%d: %s xid %lld error flushing objects from the cache: %d\n",  "tx_flush",  1120,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v11);
      }
      int v28 = 1122;
      goto LABEL_73;
    }

    while (1)
    {
      uint64_t v30 = *(void *)(v5 + 848);
      if (!v30) {
        break;
      }
      uint64_t v29 = sub_10004EB4C((void *)a1, a2, *(void *)(v5 + 848), v26, v27);
      if ((_DWORD)v29)
      {
        uint64_t v11 = v29;
        pthread_mutex_lock((pthread_mutex_t *)v4);
        if (!*(_DWORD *)(v4 + 76)) {
          sub_100013D94( "%s:%d: %s xid %lld failed to write checkpoint data @ 0x%llx: %d\n",  "tx_flush",  1136,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(void *)(v30 + 128),  v11);
        }
        int v28 = 1138;
        goto LABEL_73;
      }

      sub_10003E794((unsigned int *)v30);
      sub_100038824((uint64_t *)v30);
    }

    uint64_t v31 = *(void *)(a2 + 64);
    *(_DWORD *)(v31 + 32) |= 1u;
    sub_10003E984(a1, v31, *(_DWORD *)(*(void *)(a1 + 376) + 36LL), v26, v27);
    uint64_t v32 = sub_100051F74(*(void *)(a1 + 384), *(void *)(*(void *)(a2 + 64) + 8LL));
    if ((_DWORD)v32)
    {
      uint64_t v11 = v32;
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94( "%s:%d: %s xid %lld failed to write last checkpoint map block %lld: %d\n",  "tx_flush",  1155,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(void *)(*(void *)(a2 + 64) + 8LL),  v11);
      }
      int v28 = 1157;
LABEL_73:
      *(_DWORD *)(v4 + 76) = v28;
      ++*(_WORD *)(v4 + 80);
LABEL_74:
      uint64_t v19 = (pthread_cond_t *)(v4 + 256);
      goto LABEL_75;
    }

    ++*(_DWORD *)(a2 + 40);
    pthread_mutex_lock((pthread_mutex_t *)v4);
    int v41 = *(_DWORD *)(a2 + 40);
    unint64_t v42 = *(_DWORD **)(a2 + 56);
    int v43 = *(_DWORD *)(a2 + 48);
    int v44 = v42[37];
    if (v41 != v42[35] || v43 != v44) {
      panic("flush phase checkpoint lengths (%d %d) don't match prepare phase (%d %d)\n", v41, v43, v42[35], v44);
    }
    uint64_t v46 = *(_DWORD **)(a1 + 376);
    v46[34] = v42[34];
    v46[35] = v41;
    v46[36] = v42[36];
    v46[37] = v43;
    int v47 = *(_DWORD *)(a2 + 24);
    if ((v47 & 0x10) == 0) {
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v47, 32, 16);
    }
    if ((v47 & 0x20) != 0) {
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v47, 32, 16);
    }
    *(_DWORD *)(a2 + 24) = v47 & 0xFFFFFFCF | 0x20;
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t v48 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    unint64_t v49 = v48 - *(void *)(a2 + 72);
    *(void *)(a2 + 72) = v48;
    if (v49 > 0xF4240) {
      sub_100013D4C( "%s:%d: %s tx xid %lld took %lld us to flush\n",  "tx_flush",  1184,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v49);
    }
    *(void *)(a2 + 104) = v49;
    j__pthread_cond_broadcast((pthread_cond_t *)(v4 + 256));
    uint64_t v50 = sub_10004E8F0(a1, 0, 1);
    if ((_DWORD)v50)
    {
      uint64_t v11 = v50;
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94( "%s:%d: %s xid %lld sync/barrier failed: %d\n",  "tx_flush",  1193,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v50);
      }
      int v51 = 1195;
      goto LABEL_111;
    }

    pthread_mutex_unlock((pthread_mutex_t *)v4);
    if (*(_BYTE *)(a1 + 632))
    {
      *(_DWORD *)(a2 + 24) |= 0x80000u;
      bzero(*(void **)(a2 + 64), *(unsigned int *)(*(void *)(a1 + 376) + 36LL));
    }

    uint64_t v52 = sub_100051F74(*(void *)(a1 + 384), *(void *)(a2 + 112));
    if ((_DWORD)v52)
    {
      uint64_t v11 = v52;
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94( "%s:%d: %s xid %lld failed to write checkpoint superblock %lld: %d\n",  "tx_flush",  1222,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(void *)(a2 + 112),  v11);
      }
      int v51 = 1224;
      goto LABEL_111;
    }

    if ((*(_BYTE *)(a2 + 26) & 8) == 0)
    {
LABEL_114:
      pthread_mutex_lock((pthread_mutex_t *)v4);
      unint64_t v55 = sub_10004FB3C(a2, 32, 64);
      unint64_t v56 = v55;
      if (v55 > 0xF4240) {
        sub_100013D4C( "%s:%d: %s tx xid %lld took %lld us to sync and write superblock\n",  "tx_flush",  1285,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v55);
      }
      *(void *)(a2 + 104) += v56;
      unsigned int v57 = *(_DWORD *)(a2 + 24);
      if ((v57 & 0x20000) == 0) {
        goto LABEL_144;
      }
      ++*(void *)(v4 + 184);
      if ((v57 & 0x40000) != 0) {
        ++*(void *)(v4 + 192);
      }
      uint64_t v58 = sub_10004E8F0(a1, (v57 >> 14) & 0x10, 0);
      if (!(_DWORD)v58)
      {
LABEL_144:
        *(_DWORD *)(a2 + 52) = 0;
        *(_DWORD *)(v4 + 72) |= 2u;
        *(void *)(v4 + 76) = 0LL;
        uint64_t v79 = *(void *)(a2 + 56);
        int v80 = *(_DWORD *)(v79 + 128);
        uint64_t v81 = *(void *)(a1 + 376);
        *(_DWORD *)(v81 + 128) = v80;
        *(_DWORD *)(v4 + 96) = v80;
        int v82 = *(_DWORD *)(v79 + 132);
        *(_DWORD *)(v81 + 132) = v82;
        *(_DWORD *)(v4 + 100) = v82;
        *(void *)(v81 + 16) = *(void *)(v79 + 16);
        uint64_t v83 = *(void *)(v4 + 152);
        *(void *)(v4 + 152) = v83 + 1;
        if (v83)
        {
          v84.i64[0] = *(unsigned int *)(a2 + 32);
          v84.i64[1] = *(void *)(a2 + 80);
          *(uint64x2_t *)(v4 + 200) = vshrq_n_u64((uint64x2_t)vaddq_s64(*(int64x2_t *)(v4 + 200), v84), 1uLL);
          *(uint64x2_t *)(v4 + 216) = vshrq_n_u64( (uint64x2_t)vaddq_s64(*(int64x2_t *)(a2 + 88), *(int64x2_t *)(v4 + 216)),  1uLL);
          *(void *)(v4 + 240) = (*(void *)(a2 + 104) + *(void *)(v4 + 240)) >> 1;
          if (__ROR8__(0xCCCCCCCCCCCCCCCDLL * (v83 + 1), 2) <= 0xCCCCCCCCCCCCCCCuLL && sub_100013538(a1))
          {
            unint64_t v85 = *(void *)(v4 + 160);
            if (v85 <= 1) {
              unint64_t v86 = 1LL;
            }
            else {
              unint64_t v86 = *(void *)(v4 + 160);
            }
            sub_100013CBC( "%s:%d: %s xid %llu tx stats: # %llu owait %llu %lluus finish %llu bar2 %lld f %lld enter %llu fq %llu %llu %lluus close %lluus prep %lluus flush %lluus\n",  "tx_flush",  1349,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(void *)(v4 + 152),  v85,  *(void *)(v4 + 168) / v86,  *(void *)(v4 + 176),  *(void *)(v4 + 184),  *(void *)(v4 + 192),  *(void *)(v4 + 200),  *(void *)(v4 + 216),  *(void *)(v4 + 224),  *(void *)(v4 + 208),  *(void *)(v4 + 248),  *(void *)(v4 + 232),  *(void *)(v4 + 240));
          }
        }

        else
        {
          *(void *)(v4 + 200) = *(unsigned int *)(a2 + 32);
          *(_OWORD *)(v4 + 208) = *(_OWORD *)(a2 + 80);
          *(void *)(v4 + 224) = *(void *)(a2 + 96);
          *(void *)(v4 + 240) = *(void *)(a2 + 104);
        }

        j__pthread_cond_broadcast((pthread_cond_t *)(v4 + 256));
        return 0LL;
      }

      uint64_t v11 = v58;
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94( "%s:%d: %s xid %lld second sync/barrier failed: %d\n",  "tx_flush",  1297,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v58);
      }
      *(_DWORD *)(v4 + 76) = 1299;
      ++*(_WORD *)(v4 + 80);
      --*(_DWORD *)(a2 + 40);
      uint64_t v53 = a2;
      int v54 = 64;
LABEL_112:
      *(void *)(a2 + 104) += sub_10004FB3C(v53, v54, 16);
      goto LABEL_74;
    }

    uint64_t v78 = sub_100051F74(*(void *)(a1 + 384), 0LL);
    if ((_DWORD)v78)
    {
      uint64_t v11 = v78;
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94("%s:%d: %s xid %lld failed to write block 0 superblock: %d\n");
      }
    }

    else
    {
      if ((*(_BYTE *)(*(void *)(a1 + 376) + 65LL) & 1) == 0) {
        goto LABEL_114;
      }
      uint64_t v87 = sub_1000107A8(a1, *(const void **)(a2 + 56));
      if (!(_DWORD)v87) {
        goto LABEL_114;
      }
      uint64_t v11 = v87;
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94("%s:%d: %s xid %lld failed to write superblock to fusion tier2 device block 0: %d\n");
      }
    }

    pthread_mutex_lock((pthread_mutex_t *)v4);
    int v51 = 1259;
LABEL_111:
    *(_DWORD *)(v4 + 76) = v51;
    ++*(_WORD *)(v4 + 80);
    --*(_DWORD *)(a2 + 40);
    uint64_t v53 = a2;
    int v54 = 32;
    goto LABEL_112;
  }

  if ((v7 & 4) == 0) {
    panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v7, 8, 4);
  }
  if ((v7 & 8) != 0) {
    panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v7, 8, 4);
  }
  *(_DWORD *)(a2 + 24) = v7 & 0xFFFFFFF3 | 8;
  __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  __darwin_time_t v8 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  unint64_t v9 = v8 - *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v8;
  if (v9 > 0xF4240) {
    sub_100013D4C( "%s:%d: %s tx xid %lld was closed for %lld us waiting to prepare to flush\n",  "tx_flush",  853,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v9);
  }
  uint64_t v10 = sub_100037354(v5, 0, 2 * (*(_BYTE *)(a1 + 629) == 0), *(void *)(a2 + 16));
  if ((_DWORD)v10)
  {
    uint64_t v11 = v10;
    if (!*(_DWORD *)(v4 + 76)) {
      sub_100013D94( "%s:%d: %s xid %lld error preparing to flush object cache: %d\n",  "tx_flush",  859,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v10);
    }
    int v12 = 861;
    goto LABEL_20;
  }

  if (*(_BYTE *)(a1 + 629))
  {
    int v20 = *(_DWORD *)(a2 + 24);
    if ((v20 & 8) == 0) {
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v20, 16, 8);
    }
    if ((v20 & 0x10) != 0) {
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v20, 16, 8);
    }
    *(_DWORD *)(a2 + 24) = v20 & 0xFFFFFFE7 | 0x10;
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t v21 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    unint64_t v22 = v21 - *(void *)(a2 + 72);
    *(void *)(a2 + 72) = v21;
    if (v22 > 0xF4240) {
      sub_100013D4C( "%s:%d: %s tx xid %lld took %lld us to prepare to flush\n",  "tx_flush",  871,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v22);
    }
LABEL_44:
    *(void *)(v4 + 232) = (*(void *)(v4 + 232) + v22) >> 1;
    goto LABEL_45;
  }

  *(_DWORD *)(a2 + 36) = *(_DWORD *)(v4 + 96);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(v4 + 100);
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  unint64_t v88 = -1LL;
  uint64_t v33 = sub_1000132F4(a1, *(unsigned int *)(*(void *)(a1 + 376) + 128LL), &v88);
  if ((_DWORD)v33)
  {
    uint64_t v11 = v33;
    if (!*(_DWORD *)(v4 + 76)) {
      sub_100013D94( "%s:%d: %s xid %lld error getting first checkpoint map block address %d: %d\n",  "tx_flush",  891,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(_DWORD *)(*(void *)(a1 + 376) + 128LL),  v33);
    }
    int v12 = 893;
    goto LABEL_20;
  }

  bzero(*(void **)(a2 + 64), *(unsigned int *)(*(void *)(a1 + 376) + 36LL));
  uint64_t v35 = *(void *)(a2 + 64);
  *(_DWORD *)(v35 + 24) = 1073741836;
  *(void *)(v35 + 8) = v88;
  *(void *)(v35 + 16) = *(void *)(a2 + 16);
  ++*(_DWORD *)(a2 + 40);
  uint64_t v11 = sub_100010860(a1, a2, 1LL);
  if ((_DWORD)v11) {
    goto LABEL_21;
  }
  uint64_t v36 = *(void *)(v5 + 736);
  if (!v36)
  {
LABEL_86:
    int v38 = *(_DWORD *)(v4 + 96);
    *(void *)(a2 + 112) = -1LL;
    unsigned int v39 = (*(_DWORD *)(a2 + 40) + v38) % *(_DWORD *)(v4 + 88);
    uint64_t v40 = sub_1000132F4(a1, v39, (void *)(a2 + 112));
    if ((_DWORD)v40)
    {
      uint64_t v11 = v40;
      if (!*(_DWORD *)(v4 + 76)) {
        sub_100013D94( "%s:%d: %s xid %lld error getting next checkpoint superblock address %d: %d\n",  "tx_flush",  940,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v39,  v40);
      }
      int v12 = 942;
      goto LABEL_20;
    }

    ++*(_DWORD *)(a2 + 40);
    int v59 = *(_DWORD *)(v5 + 900) - 1;
    if (*(_DWORD *)(a2 + 48) != v59) {
      sub_100013D94( "%s:%d: %s xid %lld checkpoint data block count is not value tracked by cache: %d != %d\n",  "tx_flush",  992,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(_DWORD *)(a2 + 48),  v59);
    }
    uint64_t v60 = *(void *)(a1 + 376);
    *(void *)(v60 + 88) = *(void *)(v5 + 400);
    *(void *)(v60 + 96) = *(void *)(v4 + 64);
    memcpy(*(void **)(a2 + 56), (const void *)v60, *(unsigned int *)(v60 + 36));
    uint64_t v63 = *(void *)(a2 + 16);
    uint64_t v64 = *(void *)(a2 + 56);
    *(void *)(v64 + 16) = v63;
    int v65 = *(_DWORD *)(v4 + 96);
    *(_DWORD *)(v64 + 136) = v65;
    int v66 = *(_DWORD *)(v4 + 100);
    *(_DWORD *)(v64 + 144) = v66;
    unsigned int v67 = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(v64 + 140) = v67;
    unsigned int v68 = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(v64 + 148) = v68;
    unsigned int v69 = v67 + v65;
    unsigned int v71 = *(_DWORD *)(v4 + 88);
    unsigned int v70 = *(_DWORD *)(v4 + 92);
    int v72 = v69 % v71;
    unsigned int v73 = (v68 + v66) % v70;
    if (!*(_DWORD *)(v4 + 76))
    {
      if (v67 > v71 >> 2)
      {
        sub_100013D94( "%s:%d: %s xid %lld checkpoint descriptor count is larger than expected: %d > %d\n",  "tx_flush",  1017,  (const char *)(*(void *)(a1 + 384) + 208LL),  v63,  v67,  v71 >> 2);
        unsigned int v68 = *(_DWORD *)(a2 + 48);
        unsigned int v70 = *(_DWORD *)(v4 + 92);
      }

      if (v68 > v70 >> 2)
      {
        sub_100013D94( "%s:%d: %s xid %lld checkpoint data block count is larger than expected: %d > %d\n",  "tx_flush",  1021,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v68,  v70 >> 2);
        unsigned int v68 = *(_DWORD *)(a2 + 48);
      }

      int v74 = *(_DWORD *)(v5 + 900) - 1;
      if (v68 != v74) {
        sub_100013D94( "%s:%d: %s xid %lld checkpoint data block count is not value tracked by cache: %d != %d\n",  "tx_flush",  1025,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v68,  v74);
      }
    }

    uint64_t v75 = *(void *)(a2 + 56);
    *(_DWORD *)(v75 + 128) = v72;
    *(_DWORD *)(v75 + 132) = v73;
    sub_10003E984(a1, v75, *(_DWORD *)(*(void *)(a1 + 376) + 36LL), v61, v62);
    *(_DWORD *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 40) = 1;
    *(_DWORD *)(*(void *)(a2 + 64) + 36LL) = 0;
    int v76 = *(_DWORD *)(a2 + 24);
    if ((v76 & 8) == 0) {
      panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v76, 16, 8);
    }
    if ((v76 & 0x10) != 0) {
      panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v76, 16, 8);
    }
    *(_DWORD *)(a2 + 24) = v76 & 0xFFFFFFE7 | 0x10;
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t v77 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    unint64_t v22 = v77 - *(void *)(a2 + 72);
    *(void *)(a2 + 72) = v77;
    if (v22 > 0xF4240) {
      sub_100013D4C( "%s:%d: %s tx xid %lld took %lld us to prepare to flush\n",  "tx_flush",  1048,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  v22);
    }
    goto LABEL_44;
  }

  while (v36 == a1)
  {
LABEL_85:
    uint64_t v36 = *(void *)(v36 + 88);
    if (!v36) {
      goto LABEL_86;
    }
  }

  uint64_t v37 = sub_10004EA7C(a1, a2, v36);
  if (!(_DWORD)v37)
  {
    sub_10003DC74(v36);
    if ((*(_BYTE *)(v36 + 32) & 4) == 0 && (*(_BYTE *)(v36 + 20) & 0x20) == 0) {
      sub_100013D4C( "%s:%d: %s Unknown NEW persistent ephemeral object found: oid 0x%llx type 0x%x/0x%x\n",  "tx_flush",  928,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(v36 + 112),  *(_DWORD *)(v36 + 36),  *(_DWORD *)(v36 + 40));
    }
    *(void *)(v36 + 64) = *(void *)(v36 + 56);
    *(void *)(v36 + 104) = 0LL;
    **(void **)(v5 + 856) = v36;
    *(void *)(v5 + 856) = v36 + 104;
    goto LABEL_85;
  }

  uint64_t v11 = v37;
  if (!*(_DWORD *)(v4 + 76)) {
    sub_100013D94( "%s:%d: %s xid %lld error preparing ephemeral object (oid 0x%llx type 0x%x/0x%x): %d\n",  "tx_flush",  919,  (const char *)(*(void *)(a1 + 384) + 208LL),  *(void *)(a2 + 16),  *(void *)(v36 + 112),  *(_DWORD *)(v36 + 36),  *(_DWORD *)(v36 + 40),  v37);
  }
  int v12 = 921;
LABEL_20:
  *(_DWORD *)(v4 + 76) = v12;
  ++*(_WORD *)(v4 + 80);
LABEL_21:
  sub_100038618(v5);
  uint64_t v13 = *(void *)(v5 + 848);
  if (v13)
  {
    int v14 = (uint64_t *)(v5 + 848);
    do
    {
      uint64_t v15 = *(void *)(v13 + 104);
      *int v14 = v15;
      if (!v15) {
        *(void *)(v5 + 856) = v14;
      }
      *(void *)(v13 + 104) = 3735928559LL;
      *(void *)(v13 + 64) = 0LL;
      sub_10003E794((unsigned int *)v13);
      sub_100038824((uint64_t *)v13);
      uint64_t v13 = *v14;
    }

    while (*v14);
  }

  for (uint64_t i = *(void *)(v5 + 736); i; uint64_t i = *(void *)(i + 88))
  {
    if ((*(_BYTE *)(i + 32) & 4) != 0) {
      sub_10003E794((unsigned int *)i);
    }
  }

  int v17 = *(_DWORD *)(v4 + 72);
  if ((v17 & 0x40) != 0) {
    *(_DWORD *)(v4 + 72) = v17 & 0xFFFFFFBF;
  }
  int v18 = *(_DWORD *)(a2 + 24);
  if ((v18 & 8) == 0) {
    panic("can't transition from tx flags 0x%x to 0x%x (expected 0x%x)\n", v18, 1, 8);
  }
  if ((v18 & 1) != 0) {
    panic("bad transition tx flags 0x%x to 0x%x (expected 0x%x)\n", v18, 1, 8);
  }
  *(_DWORD *)(a2 + 24) = v18 & 0xFFFFFFF6 | 1;
  __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  __tp.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  *(void *)(a2 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  uint64_t v19 = (pthread_cond_t *)(v4 + 256);
LABEL_75:
  j__pthread_cond_broadcast(v19);
  *(_DWORD *)(a2 + 52) = v11;
  return v11;
}

uint64_t sub_1000511D8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  if (a2)
  {
    __int16 v2 = a2;
    *(_WORD *)(a1 + 2) = 4;
    uint64_t v4 = sub_100014044(0x10uLL);
    *(void *)(a1 + 8) = v4;
    if (!v4) {
      *(_WORD *)(a1 + 2) = 0;
    }
    *(_WORD *)(a1 + 6) = (v2 + 7) & 0xFFF8;
    uint64_t v5 = sub_100014044((unsigned __int16)(v2 + 7) & 0xFFF8);
    *(void *)(a1 + 16) = v5;
    if (!v5) {
      *(_WORD *)(a1 + 6) = 0;
    }
  }

  return 0LL;
}

uint64_t sub_100051244(unsigned __int16 *a1, unsigned __int16 *a2, unint64_t a3)
{
  *(void *)a1 = 0LL;
  *((void *)a1 + 1) = 0LL;
  *((void *)a1 + 2) = 0LL;
  if (a3 < 4) {
    return 28LL;
  }
  uint64_t v6 = *a2;
  *a1 = v6;
  uint64_t v7 = a2[1];
  a1[2] = v7;
  a1[1] = v6;
  if (v7 + 4 * v6 + 4 > a3) {
    goto LABEL_10;
  }
  if ((_DWORD)v6)
  {
    unsigned int v8 = 0;
    unint64_t v9 = a2 + 3;
    uint64_t v10 = v6;
    while (v7 > v8)
    {
      signed int v11 = *v9;
      v8 += (v11 + 7) & 0x1FFF8;
      v9 += 2;
      if (!--v10) {
        goto LABEL_9;
      }
    }

    goto LABEL_10;
  }

LABEL_9:
  unsigned int v12 = ((_WORD)v7 + 7) & 0xFFF8;
  a1[3] = v12;
  if (v12 < v7)
  {
LABEL_10:
    uint64_t result = 22LL;
LABEL_11:
    *(void *)a1 = 0LL;
    *((void *)a1 + 1) = 0LL;
    *((void *)a1 + 2) = 0LL;
    return result;
  }

  uint64_t v13 = 2 * v6;
  *((void *)a1 + 1) = sub_100014044(4 * v6);
  int v14 = sub_100014044(a1[3]);
  *((void *)a1 + 2) = v14;
  uint64_t v15 = (void *)*((void *)a1 + 1);
  uint64_t v16 = *a1;
  if (!v15 || !v14)
  {
    sub_100014004(v15, 4 * v16);
    sub_100014004(*((void **)a1 + 2), a1[3]);
    uint64_t result = 12LL;
    goto LABEL_11;
  }

  memcpy(v15, a2 + 2, 4 * v16);
  memcpy(*((void **)a1 + 2), &a2[v13 + 2], a1[2]);
  bzero((void *)(*((void *)a1 + 2) + a1[2]), a1[3] - (unint64_t)a1[2]);
  return 0LL;
}

uint64_t sub_100051390(unsigned __int16 *a1, unint64_t a2, int a3, _DWORD *a4, void *a5, _DWORD *a6)
{
  if (a2 < 4) {
    return 28LL;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  if (v8 + 4 * v7 + 4 > a2) {
    return 22LL;
  }
  if (*a1)
  {
    unsigned int v9 = 0;
    uint64_t v10 = (uint64_t)&a1[2 * v7 + 2];
    for (uint64_t i = a1 + 3; ; i += 2)
    {
      int v12 = *i;
      if (*((unsigned __int8 *)i - 2) == a3)
      {
        if (a4) {
          *a4 = *((unsigned __int8 *)i - 1);
        }
        if (a6) {
          *a6 = v12;
        }
        uint64_t result = 0LL;
        *a5 = v10 + v9;
        return result;
      }

      v9 += (v12 + 7) & 0x1FFF8;
      if (!--v7) {
        return 2LL;
      }
    }

    return 22LL;
  }

  return 2LL;
}

uint64_t sub_100051434(unsigned __int16 *a1, unint64_t a2, int a3, const void *a4, int a5)
{
  int v9 = -1431655766;
  uint64_t __dst = 0LL;
  uint64_t result = sub_100051390(a1, a2, a3, 0LL, &__dst, &v9);
  if (!(_DWORD)result)
  {
    if (v9 == a5)
    {
      memcpy(__dst, a4, a5);
      return 0LL;
    }

    else
    {
      return 34LL;
    }
  }

  return result;
}

uint64_t sub_1000514A4(uint64_t a1, unsigned __int16 *a2)
{
  if (*((void *)a2 + 2))
  {
    uint64_t v4 = sub_100014044(a2[3]);
    if (!v4) {
      return 12LL;
    }
    uint64_t v5 = v4;
    memcpy(v4, *((const void **)a2 + 2), a2[3]);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  if (!*((void *)a2 + 1))
  {
    uint64_t v7 = 0LL;
    goto LABEL_9;
  }

  uint64_t v6 = sub_100014044(4LL * a2[1]);
  if (v6)
  {
    uint64_t v7 = v6;
    memcpy(v6, *((const void **)a2 + 1), 4LL * *a2);
LABEL_9:
    uint64_t result = 0LL;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v5;
    return result;
  }

  sub_100014004(v5, a2[3]);
  return 12LL;
}

uint64_t sub_100051550(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return 0LL;
}

uint64_t sub_100051594(unsigned __int16 *a1)
{
  return a1[2] + 4 * *a1 + 4;
}

uint64_t sub_1000515A8(unsigned __int16 *a1, _WORD *a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  *a2 = v3;
  a2[1] = a1[2];
  uint64_t v6 = a2 + 2;
  memcpy(a2 + 2, *((const void **)a1 + 1), 4LL * *a1);
  memcpy(&v6[2 * *a1], *((const void **)a1 + 2), a1[2]);
  return 0LL;
}

uint64_t sub_100051620(unsigned __int16 *a1, int a2, char a3, void *__src, size_t __n)
{
  char v8 = a2;
  uint64_t v10 = *a1;
  if (*a1)
  {
    int v11 = 0;
    uint64_t v12 = 0LL;
    unsigned int v13 = 0;
    unsigned int v14 = *a1;
    uint64_t v15 = *((void *)a1 + 1);
    int v16 = v10 - 1;
    while (*(unsigned __int8 *)(v15 + v12) != a2)
    {
      v13 += (*(unsigned __int16 *)(v15 + v12 + 2) + 7) & 0x1FFF8;
      v12 += 4LL;
      ++v11;
      if (4 * v10 == v12) {
        goto LABEL_14;
      }
    }

    uint64_t v17 = *((void *)a1 + 2);
    int v18 = (char *)(v17 + v13);
    uint64_t v19 = v15 + v12;
    *(_BYTE *)(v19 + 1) = a3;
    if (v18)
    {
      uint64_t v20 = *(unsigned __int16 *)(v19 + 2);
      if (v20 == __n) {
        goto LABEL_22;
      }
      unint64_t v21 = ((_DWORD)v20 + 7) & 0x1FFF8;
      size_t v22 = (__n + 7) & 0xFFFFFFFFFFFFFFF8LL;
      size_t v23 = v22 - v21;
      if (v22 < v21)
      {
        if (v16 > v11) {
          memmove((void *)(v17 + v13 + v22), (const void *)(v17 + v13 + v21), a1[3] - (v13 + v21));
        }
        unsigned __int16 v24 = a1[2] - (v21 - v22);
LABEL_32:
        a1[2] = v24;
LABEL_33:
        *(_WORD *)(*((void *)a1 + 1) + v12 + 2) = __n;
        if (!v18) {
          return 22LL;
        }
        goto LABEL_22;
      }

      if (v22 <= v21) {
        goto LABEL_33;
      }
      uint64_t v33 = v13;
      uint64_t v34 = a1[2];
      if (v23 + v34 <= a1[3])
      {
LABEL_29:
        if (v16 > v11)
        {
          memmove(&v18[v22], &v18[v21], v34 - v33 - v21);
          LOWORD(v34) = a1[2];
        }

        unsigned __int16 v24 = v34 + v23;
        goto LABEL_32;
      }

      if (!sub_10005187C((uint64_t)a1, __n))
      {
        int v18 = (char *)(*((void *)a1 + 2) + v33);
        LODWORD(v34) = a1[2];
        int v16 = *a1 - 1;
        goto LABEL_29;
      }

      return 28LL;
    }

    unsigned int v14 = v11;
  }

  else
  {
    unsigned int v14 = 0;
  }

LABEL_14:
  uint64_t v25 = a1[1];
  if (v10 >= v25)
  {
    unsigned __int16 v26 = v25 + 4;
    int8x16_t v27 = sub_100014080(*((void **)a1 + 1), 4 * v25, (4 * (v25 + 4)));
    if (!v27) {
      return 28LL;
    }
    *((void *)a1 + 1) = v27;
    a1[1] = v26;
  }

  uint64_t v28 = a1[2];
  size_t v29 = (__n + 7) & 0xFFFFFFFFFFFFFFF8LL;
  if (v29 + v28 > a1[3])
  {
    uint64_t v28 = a1[2];
  }

  uint64_t v31 = *((void *)a1 + 2);
  uint64_t v32 = *((void *)a1 + 1) + 4LL * v14;
  *(_BYTE *)uint64_t v32 = v8;
  *(_BYTE *)(v32 + 1) = a3;
  *(_WORD *)(v32 + 2) = __n;
  ++*a1;
  int v18 = (char *)(v31 + v28);
  a1[2] = v28 + v29;
  if (!(v31 + v28)) {
    return 22LL;
  }
LABEL_22:
  memcpy(v18, __src, __n);
  if ((__n & 7) != 0) {
    bzero(&v18[__n], 8 - (__n & 7));
  }
  return 0LL;
}

uint64_t sub_10005187C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int16 *)(a1 + 6);
  size_t v4 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) + v3;
  uint64_t v5 = sub_100014080(*(void **)(a1 + 16), v3, v4);
  if (!v5) {
    return 28LL;
  }
  uint64_t v6 = v5;
  uint64_t result = 0LL;
  *(void *)(a1 + 16) = v6;
  *(_WORD *)(a1 + 6) = v4;
  return result;
}

uint64_t sub_1000518D4(unsigned __int16 *a1, int a2, _DWORD *a3, char *__dst, size_t __n)
{
  if (!*a1) {
    return 2LL;
  }
  uint64_t v9 = 0LL;
  unsigned int v10 = 0;
  uint64_t v11 = *((void *)a1 + 1);
  while (*(unsigned __int8 *)(v11 + v9) != a2)
  {
    v10 += (*(unsigned __int16 *)(v11 + v9 + 2) + 7) & 0x1FFF8;
    v9 += 4LL;
    if (4LL * *a1 == v9) {
      return 2LL;
    }
  }

  unsigned int v13 = (const void *)(*((void *)a1 + 2) + v10);
  size_t v14 = *(unsigned __int16 *)(v11 + v9 + 2);
  if (v14 >= __n)
  {
    memcpy(__dst, v13, __n);
  }

  else
  {
    memcpy(__dst, v13, v14);
    uint64_t v15 = *(unsigned __int16 *)(*((void *)a1 + 1) + v9 + 2);
    bzero(&__dst[v15], __n - v15);
  }

  uint64_t result = 0LL;
  if (a3) {
    *a3 = *(unsigned __int8 *)(*((void *)a1 + 1) + v9 + 1);
  }
  return result;
}

uint64_t sub_1000519B8(unsigned __int16 *a1, int a2, _DWORD *a3, void *a4, _DWORD *a5)
{
  if (!*a1) {
    return 2LL;
  }
  uint64_t v5 = 0LL;
  unsigned int v6 = 0;
  uint64_t v7 = *((void *)a1 + 1);
  while (*(unsigned __int8 *)(v7 + v5) != a2)
  {
    v6 += (*(unsigned __int16 *)(v7 + v5 + 2) + 7) & 0x1FFF8;
    v5 += 4LL;
    if (4LL * *a1 == v5) {
      return 2LL;
    }
  }

  *a4 = *((void *)a1 + 2) + v6;
  if (a3) {
    *a3 = *(unsigned __int8 *)(*((void *)a1 + 1) + v5 + 1);
  }
  uint64_t v8 = 0LL;
  if (a5) {
    *a5 = *(unsigned __int16 *)(*((void *)a1 + 1) + v5 + 2);
  }
  return v8;
}

uint64_t sub_100051A44(unsigned __int16 *a1, int a2)
{
  if (!*a1) {
    return 2LL;
  }
  uint64_t v3 = 0LL;
  unsigned int v4 = 0;
  uint64_t v5 = *((void *)a1 + 1);
  for (uint64_t i = 2LL; *(unsigned __int8 *)(v5 + i - 2) != a2; i += 4LL)
  {
    v4 += (*(unsigned __int16 *)(v5 + i) + 7) & 0x1FFF8;
    if (*a1 == ++v3) {
      return 2LL;
    }
  }

  uint64_t v8 = (*(unsigned __int16 *)(v5 + i) + 7) & 0x1FFF8;
  memmove((void *)(*((void *)a1 + 2) + v4), (const void *)(*((void *)a1 + 2) + v4 + v8), (int)(a1[3] - v4 - v8));
  a1[2] -= v8;
  memmove((void *)(*((void *)a1 + 1) + i - 2), (const void *)(*((void *)a1 + 1) + i + 2), 4LL * (~(_DWORD)v3 + *a1));
  uint64_t result = 0LL;
  --*a1;
  return result;
}

uint64_t sub_100051B24(int a1)
{
  unsigned int v7 = -1431655766;
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v6.st_blksize = v2;
  *(timespec *)v6.st_qspare = v2;
  v6.st_birthtimespec = v2;
  *(timespec *)&v6.st_size = v2;
  v6.st_mtimespec = v2;
  v6.st_ctimespec = v2;
  *(timespec *)&v6.st_uid = v2;
  v6.st_atimespec = v2;
  *(timespec *)&v6.dev_t st_dev = v2;
  memset(&__b, 170, sizeof(__b));
  if (!ioctl(a1, 0x40046418uLL, &v7)) {
    return v7;
  }
  if (!fstatfs(a1, &__b)) {
    return __b.f_bsize;
  }
  if (!fstat(a1, &v6)) {
    return v6.st_blksize;
  }
  uint64_t v3 = __error();
  unsigned int v4 = strerror(*v3);
  sub_100013D94("%s:%d: can't get the device block size (%s). assuming 512\n", "io_get_device_block_size", 56, v4);
  return 512LL;
}

uint64_t sub_100051C28(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 72))();
}

uint64_t sub_100051C34(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    uint64_t v2 = sub_100051C34();
  }
  else {
    uint64_t v2 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 8LL))(a1) + v2;
}

uint64_t sub_100051C7C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4) {
    unsigned int v5 = sub_100051C7C(v4, a2);
  }
  else {
    unsigned int v5 = 0;
  }
  LODWORD(va_start(va, result) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 72) + 80LL))(a1, a2);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v5;
  }
}

uint64_t sub_100051CDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 88LL))();
      }
    }
  }

  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 88LL))();
}

uint64_t sub_100051D1C(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    unsigned int v2 = sub_100051D1C();
  }
  else {
    unsigned int v2 = 0;
  }
  LODWORD(va_start(va, result) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 104LL))(a1);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_100051D68(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    unsigned int v2 = sub_100051D68();
  }
  else {
    unsigned int v2 = 0;
  }
  LODWORD(va_start(va, result) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 112LL))(a1);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_100051DB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 120LL))();
}

uint64_t sub_100051DC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 128LL))();
}

uint64_t sub_100051DCC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 136LL))();
}

uint64_t sub_100051DD8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 144LL))();
}

BOOL sub_100051DE4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 116) != 0;
}

uint64_t sub_100051DF4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24LL))();
      }
    }
  }

  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24LL))();
}

uint64_t sub_100051E38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }

  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 32);
  if (v12) {
    return v12();
  }
  uint64_t v14 = (*(uint64_t (**)(void))(v11 + 24))();
  uint64_t v15 = v14;
  int v16 = *(void (**)(uint64_t))a6;
  if (*(void *)a6)
  {
    *(_DWORD *)(a6 + 96) = v14;
    v16(a6);
  }

  return v15;
}

uint64_t sub_100051ED0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = a1;
  uint64_t v10 = *(void *)(a1 + 80);
  if (v10)
  {
    while (1)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(v9 + 88);
      if ((v12 & a2) == 0) {
        break;
      }
      a2 &= ~v12;
      uint64_t v10 = *(void *)(v11 + 80);
      uint64_t v9 = v11;
      if (!v10)
      {
        if (!a9) {
          goto LABEL_8;
        }
        goto LABEL_5;
      }
    }
  }

  uint64_t v11 = v9;
  if (a9)
  {
LABEL_5:
    unsigned int v13 = *(uint64_t (**)(void))(*(void *)(v11 + 72) + 40LL);
    if (v13) {
      return v13();
    }
    else {
      return 45LL;
    }
  }

  else
  {
LABEL_8:
    if (a6) {
      return sub_100051E38(v11, a2, a3, a4, a5, a7);
    }
    else {
      return (*(uint64_t (**)(void))(*(void *)(v11 + 72) + 24LL))();
    }
  }

uint64_t sub_100051F50(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 48LL))();
}

uint64_t sub_100051F5C(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 72) + 56LL);
  if (v1) {
    return v1();
  }
  else {
    return 45LL;
  }
}

uint64_t sub_100051F74(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64LL))();
      }
    }
  }

  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64LL))();
}

uint64_t sub_100051FB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }

  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  if (!a7) {
    return (*(uint64_t (**)(void))(v11 + 64))();
  }
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 72);
  if (v12) {
    return v12();
  }
  else {
    return 45LL;
  }
}

uint64_t sub_100052018(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16LL))();
}

uint64_t sub_100052024(uint64_t a1, uint64_t a2)
{
  uint64_t result = aio_error((const aiocb *)(a2 + 8));
  if ((_DWORD)result == -1) {
    return *__error();
  }
  return result;
}

uint64_t sub_10005204C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_100052054(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

uint64_t sub_10005205C(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2) {
    *a2 = a1[26];
  }
  if (a3) {
    *a3 = a1[27];
  }
  if (a4) {
    *a4 = a1[28];
  }
  if (a5) {
    *a5 = a1[29];
  }
  return 0LL;
}

uint64_t sub_100052098( int *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return sub_100052CF0(a1, a2, a3, a4, a5, a7);
}

uint64_t sub_1000520A0( uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if ((a9 & 0xFFFFFFFA) != 0)
  {
    uint64_t v9 = 45LL;
LABEL_7:
    sub_100013D94( "%s:%d: failed to read blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n",  "fd_dev_read_extended",  622,  a2,  a3,  a9,  v9,  (const char *)(a1 + 208));
    return v9;
  }

  if (((a9 >> 2) ^ 1) != (a8 == 0))
  {
    uint64_t v9 = 22LL;
    goto LABEL_7;
  }

  if (a6) {
    return sub_100052CF0((int *)a1, a2, a3, (uint64_t)a4, a5, a7);
  }
  else {
    return sub_100052A90(a1, a2, a3, a4, a5);
  }
}

uint64_t sub_10005214C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (aiocb *)(a2 + 8);
  aiocblist = (aiocb *)(a2 + 8);
  if (aio_suspend((const aiocb *const *)&aiocblist, 1, 0LL) || (unint64_t v5 = aio_return(v3), v5 == -1LL))
  {
    uint64_t v4 = *__error();
  }

  else if (v5 >= *(void *)(a2 + 32))
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    uint64_t v4 = 5LL;
  }

  stat v6 = *(void (**)(uint64_t))a2;
  if (*(void *)a2)
  {
    *(_DWORD *)(a2 + 96) = v4;
    v6(a2);
  }

  return v4;
}

uint64_t sub_1000521D4( uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  if ((a7 & 0xFFFFFFFA) != 0)
  {
    uint64_t v7 = 45LL;
  }

  else
  {
    if (((a7 >> 2) ^ 1) == (a6 == 0)) {
      return sub_100052DD4(a1, a2, a3, a4, a5, a7);
    }
    uint64_t v7 = 22LL;
  }

  sub_100013D94( "%s:%d: failed to write blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n",  "fd_dev_write_extended",  866,  a2,  a3,  a7,  v7,  (const char *)(a1 + 208));
  return v7;
}

uint64_t sub_100052268(uint64_t a1, int a2)
{
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    unint64_t v5 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v5)
    {
      uint64_t result = sub_100052C20(a1, *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 48));
      if ((_DWORD)result) {
        return result;
      }
      *(_DWORD *)(a1 + 36) = 0;
    }
  }

  fsync(*(_DWORD *)a1);
  int v7 = *(_DWORD *)(a1 + 4);
  if ((v7 & 0x80000000) == 0) {
    fsync(v7);
  }
  if (!a2 && (*(_BYTE *)(a1 + 104) & 2) != 0)
  {
    __int128 v10 = xmmword_10005BAA8;
    uint64_t v11 = 2LL;
    int v9 = ioctl(*(_DWORD *)a1, 0x80186416uLL, &v10);
  }

  else
  {
    int v8 = *(_DWORD *)a1;
    if ((*(_WORD *)(a1 + 64) & 0xF000) == 0x8000) {
      int v9 = fcntl(v8, 51, 0LL);
    }
    else {
      int v9 = ioctl(v8, 0x20006416uLL, 0LL);
    }
  }

  if (v9 == -1) {
    return *__error();
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100052350()
{
  return 0LL;
}

uint64_t sub_100052358()
{
  return 0LL;
}

uint64_t sub_100052360(uint64_t a1)
{
  uint64_t v2 = (const char *)(a1 + 208);
  size_t v3 = strlen((const char *)(a1 + 208));
  uint64_t v4 = *(void **)(a1 + 24);
  if (!v4)
  {
    uint64_t v7 = 0LL;
    goto LABEL_10;
  }

  unint64_t v5 = *(unsigned int *)(a1 + 36);
  if (!(_DWORD)v5)
  {
    uint64_t v7 = 0LL;
LABEL_9:
    sub_100014004(v4, (*(_DWORD *)(a1 + 100) * *(_DWORD *)(a1 + 32)));
    *(void *)(a1 + 24) = 0LL;
    goto LABEL_10;
  }

  uint64_t v6 = sub_100052C20(a1, *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 48));
  uint64_t v7 = v6;
  if ((_DWORD)v6) {
    sub_100013D94("%s:%d: Hit an error flushing the cache, %d dev_name = %s\n", "fd_dev_close", 370, v6, v2);
  }
  *(_DWORD *)(a1 + 36) = 0;
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:
  if (close(*(_DWORD *)a1)) {
    uint64_t v7 = *__error();
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if ((v8 & 0x80000000) == 0 && close(v8)) {
    uint64_t v7 = *__error();
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if ((v9 & 0x80000000) == 0 && close(v9)) {
    uint64_t v7 = *__error();
  }
  sub_100014004((void *)a1, v3 + 216);
  return v7;
}

uint64_t sub_100052468(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_100052470(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 128) * (unint64_t)*(unsigned int *)(a1 + 100) / a2;
  *(_DWORD *)(a1 + 100) = a2;
  *(void *)(a1 + 128) = v2;
  return 0LL;
}

BOOL sub_100052494(uint64_t a1)
{
  return *(_DWORD *)(a1 + 108) != 0;
}

BOOL sub_1000524A4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 112) != 0;
}

uint64_t sub_1000524B4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_1000524BC(uint64_t a1)
{
  dev_t v19 = -1431655766;
  int v17 = -1431655766;
  int v18 = -1431655766;
  dev_t v16 = -1431655766;
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v15.st_blksize = v2;
  *(timespec *)v15.st_qspare = v2;
  v15.st_birthtimespec = v2;
  *(timespec *)&v15.off_t st_size = v2;
  v15.st_mtimespec = v2;
  v15.st_ctimespec = v2;
  *(timespec *)&v15.st_uid = v2;
  v15.st_atimespec = v2;
  *(timespec *)&v15.dev_t st_dev = v2;
  if (fstat(*(_DWORD *)a1, &v15))
  {
    size_t v3 = __error();
    uint64_t v4 = *v3;
    sub_100013D94( "%s:%d: Couldn't fstat dev_fd (%d), err %d dev_name = %s\n",  "dev_init_common",  983,  *(_DWORD *)a1,  *v3,  (const char *)(a1 + 208));
  }

  else
  {
    *(void *)(a1 + 72) = off_1000700A0;
    int v5 = sub_100051B24(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 96) = v5;
    *(_DWORD *)(a1 + 100) = v5;
    int v6 = *(_DWORD *)a1;
    unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
    v7.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v7.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v20.st_blksize = v7;
    *(timespec *)v20.st_qspare = v7;
    v20.st_birthtimespec = v7;
    *(timespec *)&v20.off_t st_size = v7;
    v20.st_mtimespec = v7;
    v20.st_ctimespec = v7;
    *(timespec *)&v20.st_uid = v7;
    v20.st_atimespec = v7;
    *(timespec *)&v20.dev_t st_dev = v7;
    if (ioctl(v6, 0x40086419uLL, &v21))
    {
      if (fstat(v6, &v20))
      {
        int v8 = __error();
        int v9 = strerror(*v8);
        sub_100013D94("%s:%d: can't get block count (%s)\n", "io_get_num_device_blocks", 77, v9);
        unint64_t v10 = 0LL;
      }

      else
      {
        off_t st_size = v20.st_size;
        unint64_t v10 = st_size / (int)sub_100051B24(v6);
      }
    }

    else
    {
      unint64_t v10 = v21;
    }

    *(void *)(a1 + 128) = v10;
    sub_1000302F8(*(_DWORD *)a1, &v19, &v18, &v17, &v16);
    uint64_t v4 = 0LL;
    int v12 = v18;
    *(_DWORD *)(a1 + 104) = v19;
    *(_DWORD *)(a1 + 108) = v12;
    dev_t v13 = v16;
    *(_DWORD *)(a1 + 112) = v17;
    *(_DWORD *)(a1 + 116) = v13;
    *(_WORD *)(a1 + 64) = v15.st_mode;
    *(_DWORD *)(a1 + 120) = 0;
  }

  return v4;
}

uint64_t sub_100052650(const char *a1, int a2, int **a3)
{
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v6 = 5LL;
  }
  else {
    uint64_t v6 = 0LL;
  }
  timespec v7 = &a1[v6];
  size_t v8 = strlen(&a1[v6]);
  *a3 = 0LL;
  int v9 = (int *)sub_100013EEC(1uLL, v8 + 216);
  if (v9)
  {
    unint64_t v10 = v9;
    v11.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v11.int tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v36.st_blksize = v11;
    *(timespec *)v36.st_qspare = v11;
    v36.st_birthtimespec = v11;
    *(timespec *)&v36.off_t st_size = v11;
    v36.st_mtimespec = v11;
    v36.st_ctimespec = v11;
    *(timespec *)&v36.st_uid = v11;
    v36.st_atimespec = v11;
    *(timespec *)&v36.dev_t st_dev = v11;
    v9[17] = 0;
    if (stat(a1, &v36) || (v36.st_mode & 0xF000) != 0x4000)
    {
      unint64_t v14 = sub_100030900(a1, 0LL);
      if (v14)
      {
        stat v15 = (char *)v14;
        unsigned int v16 = a2 & 0xFFFFFFCF | 0x10;
        v10[2] = -1;
        int v17 = open(a1, v16);
        v10[1] = v17;
        if (v17 < 0)
        {
          uint64_t v25 = __error();
          uint64_t v13 = *v25;
          unsigned __int16 v26 = strerror(*v25);
          sub_100013D94("%s:%d: failed to open volume device %s: %s\n", "dev_init", 1107, a1, v26);
        }

        else
        {
          int v18 = open(v15, v16);
          *unint64_t v10 = v18;
          if ((v18 & 0x80000000) == 0)
          {
LABEL_30:
            uint64_t v31 = sub_1000524BC((uint64_t)v10);
            if ((_DWORD)v31)
            {
              uint64_t v13 = v31;
              free(v15);
LABEL_38:
              sub_100014004(v10, v8 + 216);
              return v13;
            }

            strlcpy((char *)v10 + 208, v7, v8 + 1);
            free(v15);
LABEL_39:
            uint64_t v13 = 0LL;
            *a3 = v10;
            return v13;
          }

          dev_t v19 = __error();
          uint64_t v13 = *v19;
          stat v20 = strerror(*v19);
          sub_100013D94("%s:%d: failed to open container device %s: %s\n", "dev_init", 1113, v15, v20);
          close(v10[1]);
        }
      }

      else
      {
        *(void *)(v10 + 1) = -1LL;
        int v21 = open(a1, a2);
        *unint64_t v10 = v21;
        if ((v21 & 0x80000000) == 0)
        {
LABEL_29:
          stat v15 = 0LL;
          goto LABEL_30;
        }

        uint64_t v35 = a3;
        int v22 = 30;
        while (*__error() == 16 && v22 != 0)
        {
          sub_100013D94( "%s:%d: open %s hit EBUSY, attempts remaining: %u dev_name = %s\n",  "dev_init",  1133,  a1,  v22,  v7);
          sleep(1u);
          int v24 = open(a1, a2);
          *unint64_t v10 = v24;
          --v22;
          if ((v24 & 0x80000000) == 0)
          {
            stat v15 = 0LL;
            a3 = v35;
            goto LABEL_30;
          }
        }

        stat v15 = 0LL;
        uint64_t v13 = *__error();
        a3 = v35;
      }
    }

    else
    {
      memset(__b, 170, sizeof(__b));
      memset(v38, 170, sizeof(v38));
      memset(__str, 170, sizeof(__str));
      snprintf(__b, 0x400uLL, "%s/apfs", a1);
      snprintf(__str, 0x400uLL, "%s/apfs_data", a1);
      snprintf(v38, 0x400uLL, "%s/nx", a1);
      int v12 = open(__b, a2);
      v10[1] = v12;
      if (v12 < 0) {
        uint64_t v13 = *__error();
      }
      else {
        uint64_t v13 = 0LL;
      }
      int v27 = open(__str, a2);
      v10[2] = v27;
      if (v27 < 0) {
        uint64_t v13 = *__error();
      }
      int v28 = open(v38, a2);
      int v29 = v28;
      *unint64_t v10 = v28;
      int v30 = v10[1];
      if ((v30 & 0x80000000) == 0 && (v10[2] & 0x80000000) == 0 && (v28 & 0x80000000) == 0) {
        goto LABEL_29;
      }
      if (!(_DWORD)v13)
      {
        uint64_t v13 = *__error();
        int v29 = *v10;
        int v30 = v10[1];
      }

      int v32 = v10[2];
      uint64_t v33 = strerror(v13);
      sub_100013D94( "%s:%d: failed to open apfs/nx special devices ['%s'(%d) / '%s'(%d) / '%s'(%d)] - err %d (%s) dev_name = '%s'\n",  "dev_init",  1094,  __b,  v30,  __str,  v32,  v38,  v29,  v13,  v33,  v7);
      close(*v10);
      close(v10[1]);
      close(v10[2]);
      stat v15 = 0LL;
    }

    free(v15);
    if ((_DWORD)v13) {
      goto LABEL_38;
    }
    goto LABEL_39;
  }

  return 12LL;
}

uint64_t sub_100052A70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == a1) {
    return 22LL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 80) = a2;
  *(void *)(a1 + 88) = a3;
  return result;
}

uint64_t sub_100052A90(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v10 = sub_100052B9C(a1, a2, a3);
  if (!(_DWORD)v10)
  {
    unint64_t v11 = *(unsigned int *)(a1 + 100);
    if ((a2 & 0x8000000000000000LL) == 0
      && is_mul_ok(a2, v11)
      && ((a2 * v11) & 0x8000000000000000LL) == 0
      && is_mul_ok(a3, v11))
    {
      unint64_t v13 = a3 * v11;
      if (!a5 || (int v14 = *(_DWORD *)(a1 + 4), v14 < 0)) {
        int v14 = *(_DWORD *)a1;
      }
      ssize_t v15 = pread(v14, a4, a3 * v11, a2 * v11);
      if (v15 < 0)
      {
        unsigned int v16 = __error();
        uint64_t v10 = *v16;
        sub_100013D94( "%s:%d: blknum 0x%llx size %zu, error %d dev_name = %s\n",  "fd_dev_read_helper",  510,  a2,  a3,  *v16,  (const char *)(a1 + 208));
      }

      else if (v15 == v13)
      {
        return 0LL;
      }

      else
      {
        return 5LL;
      }
    }

    else
    {
      sub_100013D94( "%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n",  "fd_dev_read_helper",  476,  a2,  a3,  *(_DWORD *)(a1 + 100),  (const char *)(a1 + 208));
      return 22LL;
    }
  }

  return v10;
}

uint64_t sub_100052B9C(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v7)
    {
      unint64_t v8 = *(void *)(a1 + 40);
      if (a3 + a2 > v8 && v8 + v7 > a2)
      {
        uint64_t result = sub_100052C20(a1, v8, v7, v6, *(void *)(a1 + 48));
        if ((_DWORD)result) {
          return result;
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }

  unint64_t v10 = *(void *)(a1 + 128);
  if (v10 - a2 >= a3 && v10 > a2) {
    return 0LL;
  }
  else {
    return 6LL;
  }
}

uint64_t sub_100052C20(uint64_t a1, unint64_t a2, unint64_t a3, void *__buf, uint64_t a5)
{
  unint64_t v5 = *(void *)(a1 + 128);
  BOOL v6 = v5 > a2;
  unint64_t v7 = v5 - a2;
  if (!v6 || v7 < a3) {
    return 6LL;
  }
  unint64_t v10 = *(unsigned int *)(a1 + 100);
  if ((a2 & 0x8000000000000000LL) == 0
    && is_mul_ok(a2, v10)
    && (off_t v11 = a2 * v10, ((a2 * v10) & 0x8000000000000000LL) == 0)
    && is_mul_ok(a3, v10))
  {
    size_t v12 = a3 * v10;
    if (!a5 || (int v13 = *(_DWORD *)(a1 + 4), v13 < 0)) {
      int v13 = *(_DWORD *)a1;
    }
    ssize_t v14 = pwrite(v13, __buf, v12, v11);
    if (v14 < 0)
    {
      return *__error();
    }

    else if (v14 == v12)
    {
      return 0LL;
    }

    else
    {
      return 5LL;
    }
  }

  else
  {
    sub_100013D94( "%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n",  "_fd_dev_write",  725,  a2,  a3,  *(_DWORD *)(a1 + 100),  (const char *)(a1 + 208));
    return 22LL;
  }

uint64_t sub_100052CF0(int *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = sub_100052B9C((uint64_t)a1, a2, a3);
  if (!(_DWORD)v12)
  {
    *(_OWORD *)(a6 + 8) = 0u;
    ssize_t v14 = (aiocb *)(a6 + 8);
    *(void *)(a6 + 88) = a5;
    *(_OWORD *)(a6 + 24) = 0u;
    *(_OWORD *)(a6 + 40) = 0u;
    *(_OWORD *)(a6 + 56) = 0u;
    *(_OWORD *)(a6 + 72) = 0u;
    uint64_t v15 = a1[25];
    *(void *)(a6 + 16) = v15 * a2;
    *(void *)(a6 + 24) = a4;
    *(void *)(a6 + 32) = v15 * a3;
    if (!a5 || (int v16 = a1[1], v16 < 0)) {
      int v16 = *a1;
    }
    v14->aio_fildes = v16;
    if (!aio_read(v14)) {
      return 0LL;
    }
    if (*__error() == 35)
    {
      uint64_t v12 = 16LL;
    }

    else
    {
      uint64_t v12 = *__error();
      if (!(_DWORD)v12) {
        return v12;
      }
    }
  }

  int v13 = *(void (**)(uint64_t))a6;
  if (*(void *)a6)
  {
    *(_DWORD *)(a6 + 96) = v12;
    v13(a6);
  }

  return v12;
}

uint64_t sub_100052DD4(uint64_t a1, unint64_t a2, unint64_t a3, char *__buf, uint64_t a5, int a6)
{
  unint64_t v8 = __buf;
  unint64_t v9 = a3;
  unint64_t v10 = a2;
  uint64_t v12 = *(void *)(a1 + 24);
  if (*(_DWORD *)(a1 + 60))
  {
    if (!v12)
    {
      unsigned int v13 = *(_DWORD *)(a1 + 100);
      unsigned int v14 = v13 <= 0x100000 ? 0x100000 / v13 : 1;
      *(_DWORD *)(a1 + 32) = v14;
      int v16 = sub_100014044(v14 * v13);
      *(void *)(a1 + 24) = v16;
      *(_DWORD *)(a1 + 36) = 0;
      if (!v16) {
        return 12LL;
      }
    }
  }

  else if (!v12)
  {
    return sub_100052C20(a1, a2, a3, __buf, a5);
  }

  if (!v9) {
    return 0LL;
  }
  unsigned int v17 = *(_DWORD *)(a1 + 36);
  while (1)
  {
    while (1)
    {
      unint64_t v18 = v9 >= *(_DWORD *)(a1 + 32) - v17 ? *(_DWORD *)(a1 + 32) - v17 : v9;
      if ((a6 & 4) != 0 || ((*(_DWORD *)(a1 + 56) ^ a6) & 1) != 0 || v10 != *(void *)(a1 + 40) + v17) {
        break;
      }
      if (!(_DWORD)v18 || *(void *)(a1 + 48) != a5) {
        break;
      }
      memcpy( (void *)(*(void *)(a1 + 24) + *(_DWORD *)(a1 + 100) * v17),  v8,  (*(_DWORD *)(a1 + 100) * v18));
      unsigned int v17 = *(_DWORD *)(a1 + 36) + v18;
      *(_DWORD *)(a1 + 36) = v17;
      v10 += v18;
      v9 -= v18;
      v8 += (*(_DWORD *)(a1 + 100) * v18);
      if (!v9) {
        return 0LL;
      }
    }

    if (v17)
    {
      uint64_t result = sub_100052C20(a1, *(void *)(a1 + 40), v17, *(void **)(a1 + 24), *(void *)(a1 + 48));
      if ((_DWORD)result) {
        break;
      }
    }

    unsigned int v17 = 0;
    *(_DWORD *)(a1 + 36) = 0;
    *(void *)(a1 + 40) = v10;
    *(void *)(a1 + 48) = a5;
    *(_DWORD *)(a1 + 56) = a6;
  }

  return result;
}

void sub_100052F58(io_registry_entry_t a1, const char *a2)
{
}

void sub_100053010(uint64_t a1)
{
}

void sub_100053024(uint64_t a1)
{
}

void sub_100053038(uint64_t a1)
{
}

void sub_10005304C(uint64_t a1)
{
}

void sub_100053060(uint64_t a1)
{
}

void sub_100053074(unsigned __int16 *a1)
{
}

void sub_100053098()
{
}

void sub_1000530B0(uint64_t a1)
{
}

void sub_1000530C4(uint64_t a1)
{
}

void sub_1000530D8(uint64_t a1)
{
}

void sub_1000530EC()
{
}

void sub_100053104()
{
}

void sub_10005311C()
{
}

void sub_100053134(const char *a1)
{
  timespec v2 = sub_100006544(a1);
  sub_100006940((uint64_t)v2, v1, "%s is hosting %s");
}

void sub_10005315C(uint64_t a1)
{
}

void sub_100053184(uint64_t a1)
{
}

void sub_100053198(uint64_t a1)
{
}

void sub_1000531C0(uint64_t a1)
{
}

void sub_1000531E8(io_registry_entry_t a1)
{
  uint64_t v1 = sub_1000067E0(a1);
  sub_10000694C(v1, v2, "failed to get media from %s");
}

void sub_100053210(io_registry_entry_t *a1)
{
  uint64_t v1 = sub_1000067E0(*a1);
  sub_10000694C(v1, v2, "failed to get container scheme from %s");
}

void sub_10005323C(uint64_t a1, uint64_t a2)
{
}

void sub_100053258(io_object_t a1)
{
  uint64_t v1 = IOObjectRelease(a1);
  sub_100006940(v1, v2, "%s is already a synthesized APFS device");
}

void sub_100053280(uint64_t a1)
{
  if (!a1) {
    panic("assertion failed: %s", "ino");
  }
  panic("assertion failed: %s", "ino_has_vnode(ino)");
}

#error "100053344: call analysis failed (funcsize=24)"
#error "There were 1 decompilation failure(s) on 682 function(s)"